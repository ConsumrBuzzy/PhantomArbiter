var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod2) => function __require() {
  return mod2 || (0, cb[__getOwnPropNames(cb)[0]])((mod2 = { exports: {} }).exports, mod2), mod2.exports;
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod2, isNodeMode, target) => (target = mod2 != null ? __create(__getProtoOf(mod2)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod2 || !mod2.__esModule ? __defProp(target, "default", { value: mod2, enumerable: true }) : target,
  mod2
));

// node_modules/@solana/buffer-layout/lib/Layout.js
var require_Layout = __commonJS({
  "node_modules/@solana/buffer-layout/lib/Layout.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.s16 = exports2.s8 = exports2.nu64be = exports2.u48be = exports2.u40be = exports2.u32be = exports2.u24be = exports2.u16be = exports2.nu64 = exports2.u48 = exports2.u40 = exports2.u32 = exports2.u24 = exports2.u16 = exports2.u8 = exports2.offset = exports2.greedy = exports2.Constant = exports2.UTF8 = exports2.CString = exports2.Blob = exports2.Boolean = exports2.BitField = exports2.BitStructure = exports2.VariantLayout = exports2.Union = exports2.UnionLayoutDiscriminator = exports2.UnionDiscriminator = exports2.Structure = exports2.Sequence = exports2.DoubleBE = exports2.Double = exports2.FloatBE = exports2.Float = exports2.NearInt64BE = exports2.NearInt64 = exports2.NearUInt64BE = exports2.NearUInt64 = exports2.IntBE = exports2.Int = exports2.UIntBE = exports2.UInt = exports2.OffsetLayout = exports2.GreedyCount = exports2.ExternalLayout = exports2.bindConstructorLayout = exports2.nameWithProperty = exports2.Layout = exports2.uint8ArrayToBuffer = exports2.checkUint8Array = void 0;
    exports2.constant = exports2.utf8 = exports2.cstr = exports2.blob = exports2.unionLayoutDiscriminator = exports2.union = exports2.seq = exports2.bits = exports2.struct = exports2.f64be = exports2.f64 = exports2.f32be = exports2.f32 = exports2.ns64be = exports2.s48be = exports2.s40be = exports2.s32be = exports2.s24be = exports2.s16be = exports2.ns64 = exports2.s48 = exports2.s40 = exports2.s32 = exports2.s24 = void 0;
    var buffer_1 = require("buffer");
    function checkUint8Array(b) {
      if (!(b instanceof Uint8Array)) {
        throw new TypeError("b must be a Uint8Array");
      }
    }
    exports2.checkUint8Array = checkUint8Array;
    function uint8ArrayToBuffer(b) {
      checkUint8Array(b);
      return buffer_1.Buffer.from(b.buffer, b.byteOffset, b.length);
    }
    exports2.uint8ArrayToBuffer = uint8ArrayToBuffer;
    var Layout = class {
      constructor(span, property) {
        if (!Number.isInteger(span)) {
          throw new TypeError("span must be an integer");
        }
        this.span = span;
        this.property = property;
      }
      /** Function to create an Object into which decoded properties will
       * be written.
       *
       * Used only for layouts that {@link Layout#decode|decode} to Object
       * instances, which means:
       * * {@link Structure}
       * * {@link Union}
       * * {@link VariantLayout}
       * * {@link BitStructure}
       *
       * If left undefined the JavaScript representation of these layouts
       * will be Object instances.
       *
       * See {@link bindConstructorLayout}.
       */
      makeDestinationObject() {
        return {};
      }
      /**
       * Calculate the span of a specific instance of a layout.
       *
       * @param {Uint8Array} b - the buffer that contains an encoded instance.
       *
       * @param {Number} [offset] - the offset at which the encoded instance
       * starts.  If absent a zero offset is inferred.
       *
       * @return {Number} - the number of bytes covered by the layout
       * instance.  If this method is not overridden in a subclass the
       * definition-time constant {@link Layout#span|span} will be
       * returned.
       *
       * @throws {RangeError} - if the length of the value cannot be
       * determined.
       */
      getSpan(b, offset) {
        if (0 > this.span) {
          throw new RangeError("indeterminate span");
        }
        return this.span;
      }
      /**
       * Replicate the layout using a new property.
       *
       * This function must be used to get a structurally-equivalent layout
       * with a different name since all {@link Layout} instances are
       * immutable.
       *
       * **NOTE** This is a shallow copy.  All fields except {@link
       * Layout#property|property} are strictly equal to the origin layout.
       *
       * @param {String} property - the value for {@link
       * Layout#property|property} in the replica.
       *
       * @returns {Layout} - the copy with {@link Layout#property|property}
       * set to `property`.
       */
      replicate(property) {
        const rv = Object.create(this.constructor.prototype);
        Object.assign(rv, this);
        rv.property = property;
        return rv;
      }
      /**
       * Create an object from layout properties and an array of values.
       *
       * **NOTE** This function returns `undefined` if invoked on a layout
       * that does not return its value as an Object.  Objects are
       * returned for things that are a {@link Structure}, which includes
       * {@link VariantLayout|variant layouts} if they are structures, and
       * excludes {@link Union}s.  If you want this feature for a union
       * you must use {@link Union.getVariant|getVariant} to select the
       * desired layout.
       *
       * @param {Array} values - an array of values that correspond to the
       * default order for properties.  As with {@link Layout#decode|decode}
       * layout elements that have no property name are skipped when
       * iterating over the array values.  Only the top-level properties are
       * assigned; arguments are not assigned to properties of contained
       * layouts.  Any unused values are ignored.
       *
       * @return {(Object|undefined)}
       */
      fromArray(values) {
        return void 0;
      }
    };
    exports2.Layout = Layout;
    function nameWithProperty(name, lo) {
      if (lo.property) {
        return name + "[" + lo.property + "]";
      }
      return name;
    }
    exports2.nameWithProperty = nameWithProperty;
    function bindConstructorLayout(Class, layout) {
      if ("function" !== typeof Class) {
        throw new TypeError("Class must be constructor");
      }
      if (Object.prototype.hasOwnProperty.call(Class, "layout_")) {
        throw new Error("Class is already bound to a layout");
      }
      if (!(layout && layout instanceof Layout)) {
        throw new TypeError("layout must be a Layout");
      }
      if (Object.prototype.hasOwnProperty.call(layout, "boundConstructor_")) {
        throw new Error("layout is already bound to a constructor");
      }
      Class.layout_ = layout;
      layout.boundConstructor_ = Class;
      layout.makeDestinationObject = () => new Class();
      Object.defineProperty(Class.prototype, "encode", {
        value(b, offset) {
          return layout.encode(this, b, offset);
        },
        writable: true
      });
      Object.defineProperty(Class, "decode", {
        value(b, offset) {
          return layout.decode(b, offset);
        },
        writable: true
      });
    }
    exports2.bindConstructorLayout = bindConstructorLayout;
    var ExternalLayout = class extends Layout {
      /**
       * Return `true` iff the external layout decodes to an unsigned
       * integer layout.
       *
       * In that case it can be used as the source of {@link
       * Sequence#count|Sequence counts}, {@link Blob#length|Blob lengths},
       * or as {@link UnionLayoutDiscriminator#layout|external union
       * discriminators}.
       *
       * @abstract
       */
      isCount() {
        throw new Error("ExternalLayout is abstract");
      }
    };
    exports2.ExternalLayout = ExternalLayout;
    var GreedyCount = class extends ExternalLayout {
      constructor(elementSpan = 1, property) {
        if (!Number.isInteger(elementSpan) || 0 >= elementSpan) {
          throw new TypeError("elementSpan must be a (positive) integer");
        }
        super(-1, property);
        this.elementSpan = elementSpan;
      }
      /** @override */
      isCount() {
        return true;
      }
      /** @override */
      decode(b, offset = 0) {
        checkUint8Array(b);
        const rem = b.length - offset;
        return Math.floor(rem / this.elementSpan);
      }
      /** @override */
      encode(src, b, offset) {
        return 0;
      }
    };
    exports2.GreedyCount = GreedyCount;
    var OffsetLayout = class extends ExternalLayout {
      constructor(layout, offset = 0, property) {
        if (!(layout instanceof Layout)) {
          throw new TypeError("layout must be a Layout");
        }
        if (!Number.isInteger(offset)) {
          throw new TypeError("offset must be integer or undefined");
        }
        super(layout.span, property || layout.property);
        this.layout = layout;
        this.offset = offset;
      }
      /** @override */
      isCount() {
        return this.layout instanceof UInt || this.layout instanceof UIntBE;
      }
      /** @override */
      decode(b, offset = 0) {
        return this.layout.decode(b, offset + this.offset);
      }
      /** @override */
      encode(src, b, offset = 0) {
        return this.layout.encode(src, b, offset + this.offset);
      }
    };
    exports2.OffsetLayout = OffsetLayout;
    var UInt = class extends Layout {
      constructor(span, property) {
        super(span, property);
        if (6 < this.span) {
          throw new RangeError("span must not exceed 6 bytes");
        }
      }
      /** @override */
      decode(b, offset = 0) {
        return uint8ArrayToBuffer(b).readUIntLE(offset, this.span);
      }
      /** @override */
      encode(src, b, offset = 0) {
        uint8ArrayToBuffer(b).writeUIntLE(src, offset, this.span);
        return this.span;
      }
    };
    exports2.UInt = UInt;
    var UIntBE = class extends Layout {
      constructor(span, property) {
        super(span, property);
        if (6 < this.span) {
          throw new RangeError("span must not exceed 6 bytes");
        }
      }
      /** @override */
      decode(b, offset = 0) {
        return uint8ArrayToBuffer(b).readUIntBE(offset, this.span);
      }
      /** @override */
      encode(src, b, offset = 0) {
        uint8ArrayToBuffer(b).writeUIntBE(src, offset, this.span);
        return this.span;
      }
    };
    exports2.UIntBE = UIntBE;
    var Int = class extends Layout {
      constructor(span, property) {
        super(span, property);
        if (6 < this.span) {
          throw new RangeError("span must not exceed 6 bytes");
        }
      }
      /** @override */
      decode(b, offset = 0) {
        return uint8ArrayToBuffer(b).readIntLE(offset, this.span);
      }
      /** @override */
      encode(src, b, offset = 0) {
        uint8ArrayToBuffer(b).writeIntLE(src, offset, this.span);
        return this.span;
      }
    };
    exports2.Int = Int;
    var IntBE = class extends Layout {
      constructor(span, property) {
        super(span, property);
        if (6 < this.span) {
          throw new RangeError("span must not exceed 6 bytes");
        }
      }
      /** @override */
      decode(b, offset = 0) {
        return uint8ArrayToBuffer(b).readIntBE(offset, this.span);
      }
      /** @override */
      encode(src, b, offset = 0) {
        uint8ArrayToBuffer(b).writeIntBE(src, offset, this.span);
        return this.span;
      }
    };
    exports2.IntBE = IntBE;
    var V2E32 = Math.pow(2, 32);
    function divmodInt64(src) {
      const hi32 = Math.floor(src / V2E32);
      const lo32 = src - hi32 * V2E32;
      return { hi32, lo32 };
    }
    function roundedInt64(hi32, lo32) {
      return hi32 * V2E32 + lo32;
    }
    var NearUInt64 = class extends Layout {
      constructor(property) {
        super(8, property);
      }
      /** @override */
      decode(b, offset = 0) {
        const buffer = uint8ArrayToBuffer(b);
        const lo32 = buffer.readUInt32LE(offset);
        const hi32 = buffer.readUInt32LE(offset + 4);
        return roundedInt64(hi32, lo32);
      }
      /** @override */
      encode(src, b, offset = 0) {
        const split = divmodInt64(src);
        const buffer = uint8ArrayToBuffer(b);
        buffer.writeUInt32LE(split.lo32, offset);
        buffer.writeUInt32LE(split.hi32, offset + 4);
        return 8;
      }
    };
    exports2.NearUInt64 = NearUInt64;
    var NearUInt64BE = class extends Layout {
      constructor(property) {
        super(8, property);
      }
      /** @override */
      decode(b, offset = 0) {
        const buffer = uint8ArrayToBuffer(b);
        const hi32 = buffer.readUInt32BE(offset);
        const lo32 = buffer.readUInt32BE(offset + 4);
        return roundedInt64(hi32, lo32);
      }
      /** @override */
      encode(src, b, offset = 0) {
        const split = divmodInt64(src);
        const buffer = uint8ArrayToBuffer(b);
        buffer.writeUInt32BE(split.hi32, offset);
        buffer.writeUInt32BE(split.lo32, offset + 4);
        return 8;
      }
    };
    exports2.NearUInt64BE = NearUInt64BE;
    var NearInt64 = class extends Layout {
      constructor(property) {
        super(8, property);
      }
      /** @override */
      decode(b, offset = 0) {
        const buffer = uint8ArrayToBuffer(b);
        const lo32 = buffer.readUInt32LE(offset);
        const hi32 = buffer.readInt32LE(offset + 4);
        return roundedInt64(hi32, lo32);
      }
      /** @override */
      encode(src, b, offset = 0) {
        const split = divmodInt64(src);
        const buffer = uint8ArrayToBuffer(b);
        buffer.writeUInt32LE(split.lo32, offset);
        buffer.writeInt32LE(split.hi32, offset + 4);
        return 8;
      }
    };
    exports2.NearInt64 = NearInt64;
    var NearInt64BE = class extends Layout {
      constructor(property) {
        super(8, property);
      }
      /** @override */
      decode(b, offset = 0) {
        const buffer = uint8ArrayToBuffer(b);
        const hi32 = buffer.readInt32BE(offset);
        const lo32 = buffer.readUInt32BE(offset + 4);
        return roundedInt64(hi32, lo32);
      }
      /** @override */
      encode(src, b, offset = 0) {
        const split = divmodInt64(src);
        const buffer = uint8ArrayToBuffer(b);
        buffer.writeInt32BE(split.hi32, offset);
        buffer.writeUInt32BE(split.lo32, offset + 4);
        return 8;
      }
    };
    exports2.NearInt64BE = NearInt64BE;
    var Float = class extends Layout {
      constructor(property) {
        super(4, property);
      }
      /** @override */
      decode(b, offset = 0) {
        return uint8ArrayToBuffer(b).readFloatLE(offset);
      }
      /** @override */
      encode(src, b, offset = 0) {
        uint8ArrayToBuffer(b).writeFloatLE(src, offset);
        return 4;
      }
    };
    exports2.Float = Float;
    var FloatBE = class extends Layout {
      constructor(property) {
        super(4, property);
      }
      /** @override */
      decode(b, offset = 0) {
        return uint8ArrayToBuffer(b).readFloatBE(offset);
      }
      /** @override */
      encode(src, b, offset = 0) {
        uint8ArrayToBuffer(b).writeFloatBE(src, offset);
        return 4;
      }
    };
    exports2.FloatBE = FloatBE;
    var Double = class extends Layout {
      constructor(property) {
        super(8, property);
      }
      /** @override */
      decode(b, offset = 0) {
        return uint8ArrayToBuffer(b).readDoubleLE(offset);
      }
      /** @override */
      encode(src, b, offset = 0) {
        uint8ArrayToBuffer(b).writeDoubleLE(src, offset);
        return 8;
      }
    };
    exports2.Double = Double;
    var DoubleBE = class extends Layout {
      constructor(property) {
        super(8, property);
      }
      /** @override */
      decode(b, offset = 0) {
        return uint8ArrayToBuffer(b).readDoubleBE(offset);
      }
      /** @override */
      encode(src, b, offset = 0) {
        uint8ArrayToBuffer(b).writeDoubleBE(src, offset);
        return 8;
      }
    };
    exports2.DoubleBE = DoubleBE;
    var Sequence = class extends Layout {
      constructor(elementLayout, count, property) {
        if (!(elementLayout instanceof Layout)) {
          throw new TypeError("elementLayout must be a Layout");
        }
        if (!(count instanceof ExternalLayout && count.isCount() || Number.isInteger(count) && 0 <= count)) {
          throw new TypeError("count must be non-negative integer or an unsigned integer ExternalLayout");
        }
        let span = -1;
        if (!(count instanceof ExternalLayout) && 0 < elementLayout.span) {
          span = count * elementLayout.span;
        }
        super(span, property);
        this.elementLayout = elementLayout;
        this.count = count;
      }
      /** @override */
      getSpan(b, offset = 0) {
        if (0 <= this.span) {
          return this.span;
        }
        let span = 0;
        let count = this.count;
        if (count instanceof ExternalLayout) {
          count = count.decode(b, offset);
        }
        if (0 < this.elementLayout.span) {
          span = count * this.elementLayout.span;
        } else {
          let idx = 0;
          while (idx < count) {
            span += this.elementLayout.getSpan(b, offset + span);
            ++idx;
          }
        }
        return span;
      }
      /** @override */
      decode(b, offset = 0) {
        const rv = [];
        let i = 0;
        let count = this.count;
        if (count instanceof ExternalLayout) {
          count = count.decode(b, offset);
        }
        while (i < count) {
          rv.push(this.elementLayout.decode(b, offset));
          offset += this.elementLayout.getSpan(b, offset);
          i += 1;
        }
        return rv;
      }
      /** Implement {@link Layout#encode|encode} for {@link Sequence}.
       *
       * **NOTE** If `src` is shorter than {@link Sequence#count|count} then
       * the unused space in the buffer is left unchanged.  If `src` is
       * longer than {@link Sequence#count|count} the unneeded elements are
       * ignored.
       *
       * **NOTE** If {@link Layout#count|count} is an instance of {@link
       * ExternalLayout} then the length of `src` will be encoded as the
       * count after `src` is encoded. */
      encode(src, b, offset = 0) {
        const elo = this.elementLayout;
        const span = src.reduce((span2, v) => {
          return span2 + elo.encode(v, b, offset + span2);
        }, 0);
        if (this.count instanceof ExternalLayout) {
          this.count.encode(src.length, b, offset);
        }
        return span;
      }
    };
    exports2.Sequence = Sequence;
    var Structure = class extends Layout {
      constructor(fields, property, decodePrefixes) {
        if (!(Array.isArray(fields) && fields.reduce((acc, v) => acc && v instanceof Layout, true))) {
          throw new TypeError("fields must be array of Layout instances");
        }
        if ("boolean" === typeof property && void 0 === decodePrefixes) {
          decodePrefixes = property;
          property = void 0;
        }
        for (const fd of fields) {
          if (0 > fd.span && void 0 === fd.property) {
            throw new Error("fields cannot contain unnamed variable-length layout");
          }
        }
        let span = -1;
        try {
          span = fields.reduce((span2, fd) => span2 + fd.getSpan(), 0);
        } catch (e) {
        }
        super(span, property);
        this.fields = fields;
        this.decodePrefixes = !!decodePrefixes;
      }
      /** @override */
      getSpan(b, offset = 0) {
        if (0 <= this.span) {
          return this.span;
        }
        let span = 0;
        try {
          span = this.fields.reduce((span2, fd) => {
            const fsp = fd.getSpan(b, offset);
            offset += fsp;
            return span2 + fsp;
          }, 0);
        } catch (e) {
          throw new RangeError("indeterminate span");
        }
        return span;
      }
      /** @override */
      decode(b, offset = 0) {
        checkUint8Array(b);
        const dest = this.makeDestinationObject();
        for (const fd of this.fields) {
          if (void 0 !== fd.property) {
            dest[fd.property] = fd.decode(b, offset);
          }
          offset += fd.getSpan(b, offset);
          if (this.decodePrefixes && b.length === offset) {
            break;
          }
        }
        return dest;
      }
      /** Implement {@link Layout#encode|encode} for {@link Structure}.
       *
       * If `src` is missing a property for a member with a defined {@link
       * Layout#property|property} the corresponding region of the buffer is
       * left unmodified. */
      encode(src, b, offset = 0) {
        const firstOffset = offset;
        let lastOffset = 0;
        let lastWrote = 0;
        for (const fd of this.fields) {
          let span = fd.span;
          lastWrote = 0 < span ? span : 0;
          if (void 0 !== fd.property) {
            const fv = src[fd.property];
            if (void 0 !== fv) {
              lastWrote = fd.encode(fv, b, offset);
              if (0 > span) {
                span = fd.getSpan(b, offset);
              }
            }
          }
          lastOffset = offset;
          offset += span;
        }
        return lastOffset + lastWrote - firstOffset;
      }
      /** @override */
      fromArray(values) {
        const dest = this.makeDestinationObject();
        for (const fd of this.fields) {
          if (void 0 !== fd.property && 0 < values.length) {
            dest[fd.property] = values.shift();
          }
        }
        return dest;
      }
      /**
       * Get access to the layout of a given property.
       *
       * @param {String} property - the structure member of interest.
       *
       * @return {Layout} - the layout associated with `property`, or
       * undefined if there is no such property.
       */
      layoutFor(property) {
        if ("string" !== typeof property) {
          throw new TypeError("property must be string");
        }
        for (const fd of this.fields) {
          if (fd.property === property) {
            return fd;
          }
        }
        return void 0;
      }
      /**
       * Get the offset of a structure member.
       *
       * @param {String} property - the structure member of interest.
       *
       * @return {Number} - the offset in bytes to the start of `property`
       * within the structure, or undefined if `property` is not a field
       * within the structure.  If the property is a member but follows a
       * variable-length structure member a negative number will be
       * returned.
       */
      offsetOf(property) {
        if ("string" !== typeof property) {
          throw new TypeError("property must be string");
        }
        let offset = 0;
        for (const fd of this.fields) {
          if (fd.property === property) {
            return offset;
          }
          if (0 > fd.span) {
            offset = -1;
          } else if (0 <= offset) {
            offset += fd.span;
          }
        }
        return void 0;
      }
    };
    exports2.Structure = Structure;
    var UnionDiscriminator = class {
      constructor(property) {
        this.property = property;
      }
      /** Analog to {@link Layout#decode|Layout decode} for union discriminators.
       *
       * The implementation of this method need not reference the buffer if
       * variant information is available through other means. */
      decode(b, offset) {
        throw new Error("UnionDiscriminator is abstract");
      }
      /** Analog to {@link Layout#decode|Layout encode} for union discriminators.
       *
       * The implementation of this method need not store the value if
       * variant information is maintained through other means. */
      encode(src, b, offset) {
        throw new Error("UnionDiscriminator is abstract");
      }
    };
    exports2.UnionDiscriminator = UnionDiscriminator;
    var UnionLayoutDiscriminator = class extends UnionDiscriminator {
      constructor(layout, property) {
        if (!(layout instanceof ExternalLayout && layout.isCount())) {
          throw new TypeError("layout must be an unsigned integer ExternalLayout");
        }
        super(property || layout.property || "variant");
        this.layout = layout;
      }
      /** Delegate decoding to {@link UnionLayoutDiscriminator#layout|layout}. */
      decode(b, offset) {
        return this.layout.decode(b, offset);
      }
      /** Delegate encoding to {@link UnionLayoutDiscriminator#layout|layout}. */
      encode(src, b, offset) {
        return this.layout.encode(src, b, offset);
      }
    };
    exports2.UnionLayoutDiscriminator = UnionLayoutDiscriminator;
    var Union = class extends Layout {
      constructor(discr, defaultLayout, property) {
        let discriminator;
        if (discr instanceof UInt || discr instanceof UIntBE) {
          discriminator = new UnionLayoutDiscriminator(new OffsetLayout(discr));
        } else if (discr instanceof ExternalLayout && discr.isCount()) {
          discriminator = new UnionLayoutDiscriminator(discr);
        } else if (!(discr instanceof UnionDiscriminator)) {
          throw new TypeError("discr must be a UnionDiscriminator or an unsigned integer layout");
        } else {
          discriminator = discr;
        }
        if (void 0 === defaultLayout) {
          defaultLayout = null;
        }
        if (!(null === defaultLayout || defaultLayout instanceof Layout)) {
          throw new TypeError("defaultLayout must be null or a Layout");
        }
        if (null !== defaultLayout) {
          if (0 > defaultLayout.span) {
            throw new Error("defaultLayout must have constant span");
          }
          if (void 0 === defaultLayout.property) {
            defaultLayout = defaultLayout.replicate("content");
          }
        }
        let span = -1;
        if (defaultLayout) {
          span = defaultLayout.span;
          if (0 <= span && (discr instanceof UInt || discr instanceof UIntBE)) {
            span += discriminator.layout.span;
          }
        }
        super(span, property);
        this.discriminator = discriminator;
        this.usesPrefixDiscriminator = discr instanceof UInt || discr instanceof UIntBE;
        this.defaultLayout = defaultLayout;
        this.registry = {};
        let boundGetSourceVariant = this.defaultGetSourceVariant.bind(this);
        this.getSourceVariant = function(src) {
          return boundGetSourceVariant(src);
        };
        this.configGetSourceVariant = function(gsv) {
          boundGetSourceVariant = gsv.bind(this);
        };
      }
      /** @override */
      getSpan(b, offset = 0) {
        if (0 <= this.span) {
          return this.span;
        }
        const vlo = this.getVariant(b, offset);
        if (!vlo) {
          throw new Error("unable to determine span for unrecognized variant");
        }
        return vlo.getSpan(b, offset);
      }
      /**
       * Method to infer a registered Union variant compatible with `src`.
       *
       * The first satisfied rule in the following sequence defines the
       * return value:
       * * If `src` has properties matching the Union discriminator and
       *   the default layout, `undefined` is returned regardless of the
       *   value of the discriminator property (this ensures the default
       *   layout will be used);
       * * If `src` has a property matching the Union discriminator, the
       *   value of the discriminator identifies a registered variant, and
       *   either (a) the variant has no layout, or (b) `src` has the
       *   variant's property, then the variant is returned (because the
       *   source satisfies the constraints of the variant it identifies);
       * * If `src` does not have a property matching the Union
       *   discriminator, but does have a property matching a registered
       *   variant, then the variant is returned (because the source
       *   matches a variant without an explicit conflict);
       * * An error is thrown (because we either can't identify a variant,
       *   or we were explicitly told the variant but can't satisfy it).
       *
       * @param {Object} src - an object presumed to be compatible with
       * the content of the Union.
       *
       * @return {(undefined|VariantLayout)} - as described above.
       *
       * @throws {Error} - if `src` cannot be associated with a default or
       * registered variant.
       */
      defaultGetSourceVariant(src) {
        if (Object.prototype.hasOwnProperty.call(src, this.discriminator.property)) {
          if (this.defaultLayout && this.defaultLayout.property && Object.prototype.hasOwnProperty.call(src, this.defaultLayout.property)) {
            return void 0;
          }
          const vlo = this.registry[src[this.discriminator.property]];
          if (vlo && (!vlo.layout || vlo.property && Object.prototype.hasOwnProperty.call(src, vlo.property))) {
            return vlo;
          }
        } else {
          for (const tag2 in this.registry) {
            const vlo = this.registry[tag2];
            if (vlo.property && Object.prototype.hasOwnProperty.call(src, vlo.property)) {
              return vlo;
            }
          }
        }
        throw new Error("unable to infer src variant");
      }
      /** Implement {@link Layout#decode|decode} for {@link Union}.
       *
       * If the variant is {@link Union#addVariant|registered} the return
       * value is an instance of that variant, with no explicit
       * discriminator.  Otherwise the {@link Union#defaultLayout|default
       * layout} is used to decode the content. */
      decode(b, offset = 0) {
        let dest;
        const dlo = this.discriminator;
        const discr = dlo.decode(b, offset);
        const clo = this.registry[discr];
        if (void 0 === clo) {
          const defaultLayout = this.defaultLayout;
          let contentOffset = 0;
          if (this.usesPrefixDiscriminator) {
            contentOffset = dlo.layout.span;
          }
          dest = this.makeDestinationObject();
          dest[dlo.property] = discr;
          dest[defaultLayout.property] = defaultLayout.decode(b, offset + contentOffset);
        } else {
          dest = clo.decode(b, offset);
        }
        return dest;
      }
      /** Implement {@link Layout#encode|encode} for {@link Union}.
       *
       * This API assumes the `src` object is consistent with the union's
       * {@link Union#defaultLayout|default layout}.  To encode variants
       * use the appropriate variant-specific {@link VariantLayout#encode}
       * method. */
      encode(src, b, offset = 0) {
        const vlo = this.getSourceVariant(src);
        if (void 0 === vlo) {
          const dlo = this.discriminator;
          const clo = this.defaultLayout;
          let contentOffset = 0;
          if (this.usesPrefixDiscriminator) {
            contentOffset = dlo.layout.span;
          }
          dlo.encode(src[dlo.property], b, offset);
          return contentOffset + clo.encode(src[clo.property], b, offset + contentOffset);
        }
        return vlo.encode(src, b, offset);
      }
      /** Register a new variant structure within a union.  The newly
       * created variant is returned.
       *
       * @param {Number} variant - initializer for {@link
       * VariantLayout#variant|variant}.
       *
       * @param {Layout} layout - initializer for {@link
       * VariantLayout#layout|layout}.
       *
       * @param {String} property - initializer for {@link
       * Layout#property|property}.
       *
       * @return {VariantLayout} */
      addVariant(variant, layout, property) {
        const rv = new VariantLayout(this, variant, layout, property);
        this.registry[variant] = rv;
        return rv;
      }
      /**
       * Get the layout associated with a registered variant.
       *
       * If `vb` does not produce a registered variant the function returns
       * `undefined`.
       *
       * @param {(Number|Uint8Array)} vb - either the variant number, or a
       * buffer from which the discriminator is to be read.
       *
       * @param {Number} offset - offset into `vb` for the start of the
       * union.  Used only when `vb` is an instance of {Uint8Array}.
       *
       * @return {({VariantLayout}|undefined)}
       */
      getVariant(vb, offset = 0) {
        let variant;
        if (vb instanceof Uint8Array) {
          variant = this.discriminator.decode(vb, offset);
        } else {
          variant = vb;
        }
        return this.registry[variant];
      }
    };
    exports2.Union = Union;
    var VariantLayout = class extends Layout {
      constructor(union, variant, layout, property) {
        if (!(union instanceof Union)) {
          throw new TypeError("union must be a Union");
        }
        if (!Number.isInteger(variant) || 0 > variant) {
          throw new TypeError("variant must be a (non-negative) integer");
        }
        if ("string" === typeof layout && void 0 === property) {
          property = layout;
          layout = null;
        }
        if (layout) {
          if (!(layout instanceof Layout)) {
            throw new TypeError("layout must be a Layout");
          }
          if (null !== union.defaultLayout && 0 <= layout.span && layout.span > union.defaultLayout.span) {
            throw new Error("variant span exceeds span of containing union");
          }
          if ("string" !== typeof property) {
            throw new TypeError("variant must have a String property");
          }
        }
        let span = union.span;
        if (0 > union.span) {
          span = layout ? layout.span : 0;
          if (0 <= span && union.usesPrefixDiscriminator) {
            span += union.discriminator.layout.span;
          }
        }
        super(span, property);
        this.union = union;
        this.variant = variant;
        this.layout = layout || null;
      }
      /** @override */
      getSpan(b, offset = 0) {
        if (0 <= this.span) {
          return this.span;
        }
        let contentOffset = 0;
        if (this.union.usesPrefixDiscriminator) {
          contentOffset = this.union.discriminator.layout.span;
        }
        let span = 0;
        if (this.layout) {
          span = this.layout.getSpan(b, offset + contentOffset);
        }
        return contentOffset + span;
      }
      /** @override */
      decode(b, offset = 0) {
        const dest = this.makeDestinationObject();
        if (this !== this.union.getVariant(b, offset)) {
          throw new Error("variant mismatch");
        }
        let contentOffset = 0;
        if (this.union.usesPrefixDiscriminator) {
          contentOffset = this.union.discriminator.layout.span;
        }
        if (this.layout) {
          dest[this.property] = this.layout.decode(b, offset + contentOffset);
        } else if (this.property) {
          dest[this.property] = true;
        } else if (this.union.usesPrefixDiscriminator) {
          dest[this.union.discriminator.property] = this.variant;
        }
        return dest;
      }
      /** @override */
      encode(src, b, offset = 0) {
        let contentOffset = 0;
        if (this.union.usesPrefixDiscriminator) {
          contentOffset = this.union.discriminator.layout.span;
        }
        if (this.layout && !Object.prototype.hasOwnProperty.call(src, this.property)) {
          throw new TypeError("variant lacks property " + this.property);
        }
        this.union.discriminator.encode(this.variant, b, offset);
        let span = contentOffset;
        if (this.layout) {
          this.layout.encode(src[this.property], b, offset + contentOffset);
          span += this.layout.getSpan(b, offset + contentOffset);
          if (0 <= this.union.span && span > this.union.span) {
            throw new Error("encoded variant overruns containing union");
          }
        }
        return span;
      }
      /** Delegate {@link Layout#fromArray|fromArray} to {@link
       * VariantLayout#layout|layout}. */
      fromArray(values) {
        if (this.layout) {
          return this.layout.fromArray(values);
        }
        return void 0;
      }
    };
    exports2.VariantLayout = VariantLayout;
    function fixBitwiseResult(v) {
      if (0 > v) {
        v += 4294967296;
      }
      return v;
    }
    var BitStructure = class extends Layout {
      constructor(word, msb, property) {
        if (!(word instanceof UInt || word instanceof UIntBE)) {
          throw new TypeError("word must be a UInt or UIntBE layout");
        }
        if ("string" === typeof msb && void 0 === property) {
          property = msb;
          msb = false;
        }
        if (4 < word.span) {
          throw new RangeError("word cannot exceed 32 bits");
        }
        super(word.span, property);
        this.word = word;
        this.msb = !!msb;
        this.fields = [];
        let value = 0;
        this._packedSetValue = function(v) {
          value = fixBitwiseResult(v);
          return this;
        };
        this._packedGetValue = function() {
          return value;
        };
      }
      /** @override */
      decode(b, offset = 0) {
        const dest = this.makeDestinationObject();
        const value = this.word.decode(b, offset);
        this._packedSetValue(value);
        for (const fd of this.fields) {
          if (void 0 !== fd.property) {
            dest[fd.property] = fd.decode(b);
          }
        }
        return dest;
      }
      /** Implement {@link Layout#encode|encode} for {@link BitStructure}.
       *
       * If `src` is missing a property for a member with a defined {@link
       * Layout#property|property} the corresponding region of the packed
       * value is left unmodified.  Unused bits are also left unmodified. */
      encode(src, b, offset = 0) {
        const value = this.word.decode(b, offset);
        this._packedSetValue(value);
        for (const fd of this.fields) {
          if (void 0 !== fd.property) {
            const fv = src[fd.property];
            if (void 0 !== fv) {
              fd.encode(fv);
            }
          }
        }
        return this.word.encode(this._packedGetValue(), b, offset);
      }
      /** Register a new bitfield with a containing bit structure.  The
       * resulting bitfield is returned.
       *
       * @param {Number} bits - initializer for {@link BitField#bits|bits}.
       *
       * @param {string} property - initializer for {@link
       * Layout#property|property}.
       *
       * @return {BitField} */
      addField(bits, property) {
        const bf = new BitField(this, bits, property);
        this.fields.push(bf);
        return bf;
      }
      /** As with {@link BitStructure#addField|addField} for single-bit
       * fields with `boolean` value representation.
       *
       * @param {string} property - initializer for {@link
       * Layout#property|property}.
       *
       * @return {Boolean} */
      // `Boolean` conflicts with the native primitive type
      // eslint-disable-next-line @typescript-eslint/ban-types
      addBoolean(property) {
        const bf = new Boolean2(this, property);
        this.fields.push(bf);
        return bf;
      }
      /**
       * Get access to the bit field for a given property.
       *
       * @param {String} property - the bit field of interest.
       *
       * @return {BitField} - the field associated with `property`, or
       * undefined if there is no such property.
       */
      fieldFor(property) {
        if ("string" !== typeof property) {
          throw new TypeError("property must be string");
        }
        for (const fd of this.fields) {
          if (fd.property === property) {
            return fd;
          }
        }
        return void 0;
      }
    };
    exports2.BitStructure = BitStructure;
    var BitField = class {
      constructor(container, bits, property) {
        if (!(container instanceof BitStructure)) {
          throw new TypeError("container must be a BitStructure");
        }
        if (!Number.isInteger(bits) || 0 >= bits) {
          throw new TypeError("bits must be positive integer");
        }
        const totalBits = 8 * container.span;
        const usedBits = container.fields.reduce((sum2, fd) => sum2 + fd.bits, 0);
        if (bits + usedBits > totalBits) {
          throw new Error("bits too long for span remainder (" + (totalBits - usedBits) + " of " + totalBits + " remain)");
        }
        this.container = container;
        this.bits = bits;
        this.valueMask = (1 << bits) - 1;
        if (32 === bits) {
          this.valueMask = 4294967295;
        }
        this.start = usedBits;
        if (this.container.msb) {
          this.start = totalBits - usedBits - bits;
        }
        this.wordMask = fixBitwiseResult(this.valueMask << this.start);
        this.property = property;
      }
      /** Store a value into the corresponding subsequence of the containing
       * bit field. */
      decode(b, offset) {
        const word = this.container._packedGetValue();
        const wordValue = fixBitwiseResult(word & this.wordMask);
        const value = wordValue >>> this.start;
        return value;
      }
      /** Store a value into the corresponding subsequence of the containing
       * bit field.
       *
       * **NOTE** This is not a specialization of {@link
       * Layout#encode|Layout.encode} and there is no return value. */
      encode(value) {
        if ("number" !== typeof value || !Number.isInteger(value) || value !== fixBitwiseResult(value & this.valueMask)) {
          throw new TypeError(nameWithProperty("BitField.encode", this) + " value must be integer not exceeding " + this.valueMask);
        }
        const word = this.container._packedGetValue();
        const wordValue = fixBitwiseResult(value << this.start);
        this.container._packedSetValue(fixBitwiseResult(word & ~this.wordMask) | wordValue);
      }
    };
    exports2.BitField = BitField;
    var Boolean2 = class extends BitField {
      constructor(container, property) {
        super(container, 1, property);
      }
      /** Override {@link BitField#decode|decode} for {@link Boolean|Boolean}.
       *
       * @returns {boolean} */
      decode(b, offset) {
        return !!super.decode(b, offset);
      }
      /** @override */
      encode(value) {
        if ("boolean" === typeof value) {
          value = +value;
        }
        super.encode(value);
      }
    };
    exports2.Boolean = Boolean2;
    var Blob = class extends Layout {
      constructor(length, property) {
        if (!(length instanceof ExternalLayout && length.isCount() || Number.isInteger(length) && 0 <= length)) {
          throw new TypeError("length must be positive integer or an unsigned integer ExternalLayout");
        }
        let span = -1;
        if (!(length instanceof ExternalLayout)) {
          span = length;
        }
        super(span, property);
        this.length = length;
      }
      /** @override */
      getSpan(b, offset) {
        let span = this.span;
        if (0 > span) {
          span = this.length.decode(b, offset);
        }
        return span;
      }
      /** @override */
      decode(b, offset = 0) {
        let span = this.span;
        if (0 > span) {
          span = this.length.decode(b, offset);
        }
        return uint8ArrayToBuffer(b).slice(offset, offset + span);
      }
      /** Implement {@link Layout#encode|encode} for {@link Blob}.
       *
       * **NOTE** If {@link Layout#count|count} is an instance of {@link
       * ExternalLayout} then the length of `src` will be encoded as the
       * count after `src` is encoded. */
      encode(src, b, offset) {
        let span = this.length;
        if (this.length instanceof ExternalLayout) {
          span = src.length;
        }
        if (!(src instanceof Uint8Array && span === src.length)) {
          throw new TypeError(nameWithProperty("Blob.encode", this) + " requires (length " + span + ") Uint8Array as src");
        }
        if (offset + span > b.length) {
          throw new RangeError("encoding overruns Uint8Array");
        }
        const srcBuffer = uint8ArrayToBuffer(src);
        uint8ArrayToBuffer(b).write(srcBuffer.toString("hex"), offset, span, "hex");
        if (this.length instanceof ExternalLayout) {
          this.length.encode(span, b, offset);
        }
        return span;
      }
    };
    exports2.Blob = Blob;
    var CString = class extends Layout {
      constructor(property) {
        super(-1, property);
      }
      /** @override */
      getSpan(b, offset = 0) {
        checkUint8Array(b);
        let idx = offset;
        while (idx < b.length && 0 !== b[idx]) {
          idx += 1;
        }
        return 1 + idx - offset;
      }
      /** @override */
      decode(b, offset = 0) {
        const span = this.getSpan(b, offset);
        return uint8ArrayToBuffer(b).slice(offset, offset + span - 1).toString("utf-8");
      }
      /** @override */
      encode(src, b, offset = 0) {
        if ("string" !== typeof src) {
          src = String(src);
        }
        const srcb = buffer_1.Buffer.from(src, "utf8");
        const span = srcb.length;
        if (offset + span > b.length) {
          throw new RangeError("encoding overruns Buffer");
        }
        const buffer = uint8ArrayToBuffer(b);
        srcb.copy(buffer, offset);
        buffer[offset + span] = 0;
        return span + 1;
      }
    };
    exports2.CString = CString;
    var UTF8 = class extends Layout {
      constructor(maxSpan, property) {
        if ("string" === typeof maxSpan && void 0 === property) {
          property = maxSpan;
          maxSpan = void 0;
        }
        if (void 0 === maxSpan) {
          maxSpan = -1;
        } else if (!Number.isInteger(maxSpan)) {
          throw new TypeError("maxSpan must be an integer");
        }
        super(-1, property);
        this.maxSpan = maxSpan;
      }
      /** @override */
      getSpan(b, offset = 0) {
        checkUint8Array(b);
        return b.length - offset;
      }
      /** @override */
      decode(b, offset = 0) {
        const span = this.getSpan(b, offset);
        if (0 <= this.maxSpan && this.maxSpan < span) {
          throw new RangeError("text length exceeds maxSpan");
        }
        return uint8ArrayToBuffer(b).slice(offset, offset + span).toString("utf-8");
      }
      /** @override */
      encode(src, b, offset = 0) {
        if ("string" !== typeof src) {
          src = String(src);
        }
        const srcb = buffer_1.Buffer.from(src, "utf8");
        const span = srcb.length;
        if (0 <= this.maxSpan && this.maxSpan < span) {
          throw new RangeError("text length exceeds maxSpan");
        }
        if (offset + span > b.length) {
          throw new RangeError("encoding overruns Buffer");
        }
        srcb.copy(uint8ArrayToBuffer(b), offset);
        return span;
      }
    };
    exports2.UTF8 = UTF8;
    var Constant = class extends Layout {
      constructor(value, property) {
        super(0, property);
        this.value = value;
      }
      /** @override */
      decode(b, offset) {
        return this.value;
      }
      /** @override */
      encode(src, b, offset) {
        return 0;
      }
    };
    exports2.Constant = Constant;
    exports2.greedy = (elementSpan, property) => new GreedyCount(elementSpan, property);
    exports2.offset = (layout, offset, property) => new OffsetLayout(layout, offset, property);
    exports2.u8 = (property) => new UInt(1, property);
    exports2.u16 = (property) => new UInt(2, property);
    exports2.u24 = (property) => new UInt(3, property);
    exports2.u32 = (property) => new UInt(4, property);
    exports2.u40 = (property) => new UInt(5, property);
    exports2.u48 = (property) => new UInt(6, property);
    exports2.nu64 = (property) => new NearUInt64(property);
    exports2.u16be = (property) => new UIntBE(2, property);
    exports2.u24be = (property) => new UIntBE(3, property);
    exports2.u32be = (property) => new UIntBE(4, property);
    exports2.u40be = (property) => new UIntBE(5, property);
    exports2.u48be = (property) => new UIntBE(6, property);
    exports2.nu64be = (property) => new NearUInt64BE(property);
    exports2.s8 = (property) => new Int(1, property);
    exports2.s16 = (property) => new Int(2, property);
    exports2.s24 = (property) => new Int(3, property);
    exports2.s32 = (property) => new Int(4, property);
    exports2.s40 = (property) => new Int(5, property);
    exports2.s48 = (property) => new Int(6, property);
    exports2.ns64 = (property) => new NearInt64(property);
    exports2.s16be = (property) => new IntBE(2, property);
    exports2.s24be = (property) => new IntBE(3, property);
    exports2.s32be = (property) => new IntBE(4, property);
    exports2.s40be = (property) => new IntBE(5, property);
    exports2.s48be = (property) => new IntBE(6, property);
    exports2.ns64be = (property) => new NearInt64BE(property);
    exports2.f32 = (property) => new Float(property);
    exports2.f32be = (property) => new FloatBE(property);
    exports2.f64 = (property) => new Double(property);
    exports2.f64be = (property) => new DoubleBE(property);
    exports2.struct = (fields, property, decodePrefixes) => new Structure(fields, property, decodePrefixes);
    exports2.bits = (word, msb, property) => new BitStructure(word, msb, property);
    exports2.seq = (elementLayout, count, property) => new Sequence(elementLayout, count, property);
    exports2.union = (discr, defaultLayout, property) => new Union(discr, defaultLayout, property);
    exports2.unionLayoutDiscriminator = (layout, property) => new UnionLayoutDiscriminator(layout, property);
    exports2.blob = (length, property) => new Blob(length, property);
    exports2.cstr = (property) => new CString(property);
    exports2.utf8 = (maxSpan, property) => new UTF8(maxSpan, property);
    exports2.constant = (value, property) => new Constant(value, property);
  }
});

// node_modules/file-uri-to-path/index.js
var require_file_uri_to_path = __commonJS({
  "node_modules/file-uri-to-path/index.js"(exports2, module2) {
    var sep = require("path").sep || "/";
    module2.exports = fileUriToPath;
    function fileUriToPath(uri) {
      if ("string" != typeof uri || uri.length <= 7 || "file://" != uri.substring(0, 7)) {
        throw new TypeError("must pass in a file:// URI to convert to a file path");
      }
      var rest = decodeURI(uri.substring(7));
      var firstSlash = rest.indexOf("/");
      var host = rest.substring(0, firstSlash);
      var path = rest.substring(firstSlash + 1);
      if ("localhost" == host)
        host = "";
      if (host) {
        host = sep + sep + host;
      }
      path = path.replace(/^(.+)\|/, "$1:");
      if (sep == "\\") {
        path = path.replace(/\//g, "\\");
      }
      if (/^.+\:/.test(path)) {
      } else {
        path = sep + path;
      }
      return host + path;
    }
  }
});

// node_modules/bindings/bindings.js
var require_bindings = __commonJS({
  "node_modules/bindings/bindings.js"(exports2, module2) {
    var fs = require("fs");
    var path = require("path");
    var fileURLToPath = require_file_uri_to_path();
    var join = path.join;
    var dirname = path.dirname;
    var exists = fs.accessSync && function(path2) {
      try {
        fs.accessSync(path2);
      } catch (e) {
        return false;
      }
      return true;
    } || fs.existsSync || path.existsSync;
    var defaults = {
      arrow: process.env.NODE_BINDINGS_ARROW || " \u2192 ",
      compiled: process.env.NODE_BINDINGS_COMPILED_DIR || "compiled",
      platform: process.platform,
      arch: process.arch,
      nodePreGyp: "node-v" + process.versions.modules + "-" + process.platform + "-" + process.arch,
      version: process.versions.node,
      bindings: "bindings.node",
      try: [
        // node-gyp's linked version in the "build" dir
        ["module_root", "build", "bindings"],
        // node-waf and gyp_addon (a.k.a node-gyp)
        ["module_root", "build", "Debug", "bindings"],
        ["module_root", "build", "Release", "bindings"],
        // Debug files, for development (legacy behavior, remove for node v0.9)
        ["module_root", "out", "Debug", "bindings"],
        ["module_root", "Debug", "bindings"],
        // Release files, but manually compiled (legacy behavior, remove for node v0.9)
        ["module_root", "out", "Release", "bindings"],
        ["module_root", "Release", "bindings"],
        // Legacy from node-waf, node <= 0.4.x
        ["module_root", "build", "default", "bindings"],
        // Production "Release" buildtype binary (meh...)
        ["module_root", "compiled", "version", "platform", "arch", "bindings"],
        // node-qbs builds
        ["module_root", "addon-build", "release", "install-root", "bindings"],
        ["module_root", "addon-build", "debug", "install-root", "bindings"],
        ["module_root", "addon-build", "default", "install-root", "bindings"],
        // node-pre-gyp path ./lib/binding/{node_abi}-{platform}-{arch}
        ["module_root", "lib", "binding", "nodePreGyp", "bindings"]
      ]
    };
    function bindings(opts) {
      if (typeof opts == "string") {
        opts = { bindings: opts };
      } else if (!opts) {
        opts = {};
      }
      Object.keys(defaults).map(function(i2) {
        if (!(i2 in opts))
          opts[i2] = defaults[i2];
      });
      if (!opts.module_root) {
        opts.module_root = exports2.getRoot(exports2.getFileName());
      }
      if (path.extname(opts.bindings) != ".node") {
        opts.bindings += ".node";
      }
      var requireFunc = typeof __webpack_require__ === "function" ? __non_webpack_require__ : require;
      var tries = [], i = 0, l = opts.try.length, n, b, err;
      for (; i < l; i++) {
        n = join.apply(
          null,
          opts.try[i].map(function(p) {
            return opts[p] || p;
          })
        );
        tries.push(n);
        try {
          b = opts.path ? requireFunc.resolve(n) : requireFunc(n);
          if (!opts.path) {
            b.path = n;
          }
          return b;
        } catch (e) {
          if (e.code !== "MODULE_NOT_FOUND" && e.code !== "QUALIFIED_PATH_RESOLUTION_FAILED" && !/not find/i.test(e.message)) {
            throw e;
          }
        }
      }
      err = new Error(
        "Could not locate the bindings file. Tried:\n" + tries.map(function(a) {
          return opts.arrow + a;
        }).join("\n")
      );
      err.tries = tries;
      throw err;
    }
    module2.exports = exports2 = bindings;
    exports2.getFileName = function getFileName(calling_file) {
      var origPST = Error.prepareStackTrace, origSTL = Error.stackTraceLimit, dummy = {}, fileName;
      Error.stackTraceLimit = 10;
      Error.prepareStackTrace = function(e, st) {
        for (var i = 0, l = st.length; i < l; i++) {
          fileName = st[i].getFileName();
          if (fileName !== __filename) {
            if (calling_file) {
              if (fileName !== calling_file) {
                return;
              }
            } else {
              return;
            }
          }
        }
      };
      Error.captureStackTrace(dummy);
      dummy.stack;
      Error.prepareStackTrace = origPST;
      Error.stackTraceLimit = origSTL;
      var fileSchema = "file://";
      if (fileName.indexOf(fileSchema) === 0) {
        fileName = fileURLToPath(fileName);
      }
      return fileName;
    };
    exports2.getRoot = function getRoot(file) {
      var dir = dirname(file), prev;
      while (true) {
        if (dir === ".") {
          dir = process.cwd();
        }
        if (exists(join(dir, "package.json")) || exists(join(dir, "node_modules"))) {
          return dir;
        }
        if (prev === dir) {
          throw new Error(
            'Could not find module root given file: "' + file + '". Do you have a `package.json` file? '
          );
        }
        prev = dir;
        dir = join(dir, "..");
      }
    };
  }
});

// node_modules/bigint-buffer/dist/node.js
var require_node = __commonJS({
  "node_modules/bigint-buffer/dist/node.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var converter;
    {
      try {
        converter = require_bindings()("bigint_buffer");
      } catch (e) {
        console.warn("bigint: Failed to load bindings, pure JS will be used (try npm run rebuild?)");
      }
    }
    function toBigIntLE2(buf) {
      if (converter === void 0) {
        const reversed = Buffer.from(buf);
        reversed.reverse();
        const hex = reversed.toString("hex");
        if (hex.length === 0) {
          return BigInt(0);
        }
        return BigInt(`0x${hex}`);
      }
      return converter.toBigInt(buf, false);
    }
    exports2.toBigIntLE = toBigIntLE2;
    function toBigIntBE2(buf) {
      if (converter === void 0) {
        const hex = buf.toString("hex");
        if (hex.length === 0) {
          return BigInt(0);
        }
        return BigInt(`0x${hex}`);
      }
      return converter.toBigInt(buf, true);
    }
    exports2.toBigIntBE = toBigIntBE2;
    function toBufferLE2(num, width) {
      if (converter === void 0) {
        const hex = num.toString(16);
        const buffer = Buffer.from(hex.padStart(width * 2, "0").slice(0, width * 2), "hex");
        buffer.reverse();
        return buffer;
      }
      return converter.fromBigInt(num, Buffer.allocUnsafe(width), false);
    }
    exports2.toBufferLE = toBufferLE2;
    function toBufferBE2(num, width) {
      if (converter === void 0) {
        const hex = num.toString(16);
        return Buffer.from(hex.padStart(width * 2, "0").slice(0, width * 2), "hex");
      }
      return converter.fromBigInt(num, Buffer.allocUnsafe(width), true);
    }
    exports2.toBufferBE = toBufferBE2;
  }
});

// node_modules/buffer-layout/lib/Layout.js
var require_Layout2 = __commonJS({
  "node_modules/buffer-layout/lib/Layout.js"(exports2) {
    "use strict";
    var Layout = class {
      constructor(span, property) {
        if (!Number.isInteger(span)) {
          throw new TypeError("span must be an integer");
        }
        this.span = span;
        this.property = property;
      }
      /** Function to create an Object into which decoded properties will
       * be written.
       *
       * Used only for layouts that {@link Layout#decode|decode} to Object
       * instances, which means:
       * * {@link Structure}
       * * {@link Union}
       * * {@link VariantLayout}
       * * {@link BitStructure}
       *
       * If left undefined the JavaScript representation of these layouts
       * will be Object instances.
       *
       * See {@link bindConstructorLayout}.
       */
      makeDestinationObject() {
        return {};
      }
      /**
       * Decode from a Buffer into an JavaScript value.
       *
       * @param {Buffer} b - the buffer from which encoded data is read.
       *
       * @param {Number} [offset] - the offset at which the encoded data
       * starts.  If absent a zero offset is inferred.
       *
       * @returns {(Number|Array|Object)} - the value of the decoded data.
       *
       * @abstract
       */
      decode(b, offset) {
        throw new Error("Layout is abstract");
      }
      /**
       * Encode a JavaScript value into a Buffer.
       *
       * @param {(Number|Array|Object)} src - the value to be encoded into
       * the buffer.  The type accepted depends on the (sub-)type of {@link
       * Layout}.
       *
       * @param {Buffer} b - the buffer into which encoded data will be
       * written.
       *
       * @param {Number} [offset] - the offset at which the encoded data
       * starts.  If absent a zero offset is inferred.
       *
       * @returns {Number} - the number of bytes encoded, including the
       * space skipped for internal padding, but excluding data such as
       * {@link Sequence#count|lengths} when stored {@link
       * ExternalLayout|externally}.  This is the adjustment to `offset`
       * producing the offset where data for the next layout would be
       * written.
       *
       * @abstract
       */
      encode(src, b, offset) {
        throw new Error("Layout is abstract");
      }
      /**
       * Calculate the span of a specific instance of a layout.
       *
       * @param {Buffer} b - the buffer that contains an encoded instance.
       *
       * @param {Number} [offset] - the offset at which the encoded instance
       * starts.  If absent a zero offset is inferred.
       *
       * @return {Number} - the number of bytes covered by the layout
       * instance.  If this method is not overridden in a subclass the
       * definition-time constant {@link Layout#span|span} will be
       * returned.
       *
       * @throws {RangeError} - if the length of the value cannot be
       * determined.
       */
      getSpan(b, offset) {
        if (0 > this.span) {
          throw new RangeError("indeterminate span");
        }
        return this.span;
      }
      /**
       * Replicate the layout using a new property.
       *
       * This function must be used to get a structurally-equivalent layout
       * with a different name since all {@link Layout} instances are
       * immutable.
       *
       * **NOTE** This is a shallow copy.  All fields except {@link
       * Layout#property|property} are strictly equal to the origin layout.
       *
       * @param {String} property - the value for {@link
       * Layout#property|property} in the replica.
       *
       * @returns {Layout} - the copy with {@link Layout#property|property}
       * set to `property`.
       */
      replicate(property) {
        const rv = Object.create(this.constructor.prototype);
        Object.assign(rv, this);
        rv.property = property;
        return rv;
      }
      /**
       * Create an object from layout properties and an array of values.
       *
       * **NOTE** This function returns `undefined` if invoked on a layout
       * that does not return its value as an Object.  Objects are
       * returned for things that are a {@link Structure}, which includes
       * {@link VariantLayout|variant layouts} if they are structures, and
       * excludes {@link Union}s.  If you want this feature for a union
       * you must use {@link Union.getVariant|getVariant} to select the
       * desired layout.
       *
       * @param {Array} values - an array of values that correspond to the
       * default order for properties.  As with {@link Layout#decode|decode}
       * layout elements that have no property name are skipped when
       * iterating over the array values.  Only the top-level properties are
       * assigned; arguments are not assigned to properties of contained
       * layouts.  Any unused values are ignored.
       *
       * @return {(Object|undefined)}
       */
      fromArray(values) {
        return void 0;
      }
    };
    exports2.Layout = Layout;
    function nameWithProperty(name, lo) {
      if (lo.property) {
        return name + "[" + lo.property + "]";
      }
      return name;
    }
    exports2.nameWithProperty = nameWithProperty;
    function bindConstructorLayout(Class, layout) {
      if ("function" !== typeof Class) {
        throw new TypeError("Class must be constructor");
      }
      if (Class.hasOwnProperty("layout_")) {
        throw new Error("Class is already bound to a layout");
      }
      if (!(layout && layout instanceof Layout)) {
        throw new TypeError("layout must be a Layout");
      }
      if (layout.hasOwnProperty("boundConstructor_")) {
        throw new Error("layout is already bound to a constructor");
      }
      Class.layout_ = layout;
      layout.boundConstructor_ = Class;
      layout.makeDestinationObject = () => new Class();
      Object.defineProperty(Class.prototype, "encode", {
        value: function(b, offset) {
          return layout.encode(this, b, offset);
        },
        writable: true
      });
      Object.defineProperty(Class, "decode", {
        value: function(b, offset) {
          return layout.decode(b, offset);
        },
        writable: true
      });
    }
    exports2.bindConstructorLayout = bindConstructorLayout;
    var ExternalLayout = class extends Layout {
      /**
       * Return `true` iff the external layout decodes to an unsigned
       * integer layout.
       *
       * In that case it can be used as the source of {@link
       * Sequence#count|Sequence counts}, {@link Blob#length|Blob lengths},
       * or as {@link UnionLayoutDiscriminator#layout|external union
       * discriminators}.
       *
       * @abstract
       */
      isCount() {
        throw new Error("ExternalLayout is abstract");
      }
    };
    var GreedyCount = class extends ExternalLayout {
      constructor(elementSpan, property) {
        if (void 0 === elementSpan) {
          elementSpan = 1;
        }
        if (!Number.isInteger(elementSpan) || 0 >= elementSpan) {
          throw new TypeError("elementSpan must be a (positive) integer");
        }
        super(-1, property);
        this.elementSpan = elementSpan;
      }
      /** @override */
      isCount() {
        return true;
      }
      /** @override */
      decode(b, offset) {
        if (void 0 === offset) {
          offset = 0;
        }
        const rem = b.length - offset;
        return Math.floor(rem / this.elementSpan);
      }
      /** @override */
      encode(src, b, offset) {
        return 0;
      }
    };
    var OffsetLayout = class extends ExternalLayout {
      constructor(layout, offset, property) {
        if (!(layout instanceof Layout)) {
          throw new TypeError("layout must be a Layout");
        }
        if (void 0 === offset) {
          offset = 0;
        } else if (!Number.isInteger(offset)) {
          throw new TypeError("offset must be integer or undefined");
        }
        super(layout.span, property || layout.property);
        this.layout = layout;
        this.offset = offset;
      }
      /** @override */
      isCount() {
        return this.layout instanceof UInt || this.layout instanceof UIntBE;
      }
      /** @override */
      decode(b, offset) {
        if (void 0 === offset) {
          offset = 0;
        }
        return this.layout.decode(b, offset + this.offset);
      }
      /** @override */
      encode(src, b, offset) {
        if (void 0 === offset) {
          offset = 0;
        }
        return this.layout.encode(src, b, offset + this.offset);
      }
    };
    var UInt = class extends Layout {
      constructor(span, property) {
        super(span, property);
        if (6 < this.span) {
          throw new RangeError("span must not exceed 6 bytes");
        }
      }
      /** @override */
      decode(b, offset) {
        if (void 0 === offset) {
          offset = 0;
        }
        return b.readUIntLE(offset, this.span);
      }
      /** @override */
      encode(src, b, offset) {
        if (void 0 === offset) {
          offset = 0;
        }
        b.writeUIntLE(src, offset, this.span);
        return this.span;
      }
    };
    var UIntBE = class extends Layout {
      constructor(span, property) {
        super(span, property);
        if (6 < this.span) {
          throw new RangeError("span must not exceed 6 bytes");
        }
      }
      /** @override */
      decode(b, offset) {
        if (void 0 === offset) {
          offset = 0;
        }
        return b.readUIntBE(offset, this.span);
      }
      /** @override */
      encode(src, b, offset) {
        if (void 0 === offset) {
          offset = 0;
        }
        b.writeUIntBE(src, offset, this.span);
        return this.span;
      }
    };
    var Int = class extends Layout {
      constructor(span, property) {
        super(span, property);
        if (6 < this.span) {
          throw new RangeError("span must not exceed 6 bytes");
        }
      }
      /** @override */
      decode(b, offset) {
        if (void 0 === offset) {
          offset = 0;
        }
        return b.readIntLE(offset, this.span);
      }
      /** @override */
      encode(src, b, offset) {
        if (void 0 === offset) {
          offset = 0;
        }
        b.writeIntLE(src, offset, this.span);
        return this.span;
      }
    };
    var IntBE = class extends Layout {
      constructor(span, property) {
        super(span, property);
        if (6 < this.span) {
          throw new RangeError("span must not exceed 6 bytes");
        }
      }
      /** @override */
      decode(b, offset) {
        if (void 0 === offset) {
          offset = 0;
        }
        return b.readIntBE(offset, this.span);
      }
      /** @override */
      encode(src, b, offset) {
        if (void 0 === offset) {
          offset = 0;
        }
        b.writeIntBE(src, offset, this.span);
        return this.span;
      }
    };
    var V2E32 = Math.pow(2, 32);
    function divmodInt64(src) {
      const hi32 = Math.floor(src / V2E32);
      const lo32 = src - hi32 * V2E32;
      return { hi32, lo32 };
    }
    function roundedInt64(hi32, lo32) {
      return hi32 * V2E32 + lo32;
    }
    var NearUInt64 = class extends Layout {
      constructor(property) {
        super(8, property);
      }
      /** @override */
      decode(b, offset) {
        if (void 0 === offset) {
          offset = 0;
        }
        const lo32 = b.readUInt32LE(offset);
        const hi32 = b.readUInt32LE(offset + 4);
        return roundedInt64(hi32, lo32);
      }
      /** @override */
      encode(src, b, offset) {
        if (void 0 === offset) {
          offset = 0;
        }
        const split = divmodInt64(src);
        b.writeUInt32LE(split.lo32, offset);
        b.writeUInt32LE(split.hi32, offset + 4);
        return 8;
      }
    };
    var NearUInt64BE = class extends Layout {
      constructor(property) {
        super(8, property);
      }
      /** @override */
      decode(b, offset) {
        if (void 0 === offset) {
          offset = 0;
        }
        const hi32 = b.readUInt32BE(offset);
        const lo32 = b.readUInt32BE(offset + 4);
        return roundedInt64(hi32, lo32);
      }
      /** @override */
      encode(src, b, offset) {
        if (void 0 === offset) {
          offset = 0;
        }
        const split = divmodInt64(src);
        b.writeUInt32BE(split.hi32, offset);
        b.writeUInt32BE(split.lo32, offset + 4);
        return 8;
      }
    };
    var NearInt64 = class extends Layout {
      constructor(property) {
        super(8, property);
      }
      /** @override */
      decode(b, offset) {
        if (void 0 === offset) {
          offset = 0;
        }
        const lo32 = b.readUInt32LE(offset);
        const hi32 = b.readInt32LE(offset + 4);
        return roundedInt64(hi32, lo32);
      }
      /** @override */
      encode(src, b, offset) {
        if (void 0 === offset) {
          offset = 0;
        }
        const split = divmodInt64(src);
        b.writeUInt32LE(split.lo32, offset);
        b.writeInt32LE(split.hi32, offset + 4);
        return 8;
      }
    };
    var NearInt64BE = class extends Layout {
      constructor(property) {
        super(8, property);
      }
      /** @override */
      decode(b, offset) {
        if (void 0 === offset) {
          offset = 0;
        }
        const hi32 = b.readInt32BE(offset);
        const lo32 = b.readUInt32BE(offset + 4);
        return roundedInt64(hi32, lo32);
      }
      /** @override */
      encode(src, b, offset) {
        if (void 0 === offset) {
          offset = 0;
        }
        const split = divmodInt64(src);
        b.writeInt32BE(split.hi32, offset);
        b.writeUInt32BE(split.lo32, offset + 4);
        return 8;
      }
    };
    var Float = class extends Layout {
      constructor(property) {
        super(4, property);
      }
      /** @override */
      decode(b, offset) {
        if (void 0 === offset) {
          offset = 0;
        }
        return b.readFloatLE(offset);
      }
      /** @override */
      encode(src, b, offset) {
        if (void 0 === offset) {
          offset = 0;
        }
        b.writeFloatLE(src, offset);
        return 4;
      }
    };
    var FloatBE = class extends Layout {
      constructor(property) {
        super(4, property);
      }
      /** @override */
      decode(b, offset) {
        if (void 0 === offset) {
          offset = 0;
        }
        return b.readFloatBE(offset);
      }
      /** @override */
      encode(src, b, offset) {
        if (void 0 === offset) {
          offset = 0;
        }
        b.writeFloatBE(src, offset);
        return 4;
      }
    };
    var Double = class extends Layout {
      constructor(property) {
        super(8, property);
      }
      /** @override */
      decode(b, offset) {
        if (void 0 === offset) {
          offset = 0;
        }
        return b.readDoubleLE(offset);
      }
      /** @override */
      encode(src, b, offset) {
        if (void 0 === offset) {
          offset = 0;
        }
        b.writeDoubleLE(src, offset);
        return 8;
      }
    };
    var DoubleBE = class extends Layout {
      constructor(property) {
        super(8, property);
      }
      /** @override */
      decode(b, offset) {
        if (void 0 === offset) {
          offset = 0;
        }
        return b.readDoubleBE(offset);
      }
      /** @override */
      encode(src, b, offset) {
        if (void 0 === offset) {
          offset = 0;
        }
        b.writeDoubleBE(src, offset);
        return 8;
      }
    };
    var Sequence = class extends Layout {
      constructor(elementLayout, count, property) {
        if (!(elementLayout instanceof Layout)) {
          throw new TypeError("elementLayout must be a Layout");
        }
        if (!(count instanceof ExternalLayout && count.isCount() || Number.isInteger(count) && 0 <= count)) {
          throw new TypeError("count must be non-negative integer or an unsigned integer ExternalLayout");
        }
        let span = -1;
        if (!(count instanceof ExternalLayout) && 0 < elementLayout.span) {
          span = count * elementLayout.span;
        }
        super(span, property);
        this.elementLayout = elementLayout;
        this.count = count;
      }
      /** @override */
      getSpan(b, offset) {
        if (0 <= this.span) {
          return this.span;
        }
        if (void 0 === offset) {
          offset = 0;
        }
        let span = 0;
        let count = this.count;
        if (count instanceof ExternalLayout) {
          count = count.decode(b, offset);
        }
        if (0 < this.elementLayout.span) {
          span = count * this.elementLayout.span;
        } else {
          let idx = 0;
          while (idx < count) {
            span += this.elementLayout.getSpan(b, offset + span);
            ++idx;
          }
        }
        return span;
      }
      /** @override */
      decode(b, offset) {
        if (void 0 === offset) {
          offset = 0;
        }
        const rv = [];
        let i = 0;
        let count = this.count;
        if (count instanceof ExternalLayout) {
          count = count.decode(b, offset);
        }
        while (i < count) {
          rv.push(this.elementLayout.decode(b, offset));
          offset += this.elementLayout.getSpan(b, offset);
          i += 1;
        }
        return rv;
      }
      /** Implement {@link Layout#encode|encode} for {@link Sequence}.
       *
       * **NOTE** If `src` is shorter than {@link Sequence#count|count} then
       * the unused space in the buffer is left unchanged.  If `src` is
       * longer than {@link Sequence#count|count} the unneeded elements are
       * ignored.
       *
       * **NOTE** If {@link Layout#count|count} is an instance of {@link
       * ExternalLayout} then the length of `src` will be encoded as the
       * count after `src` is encoded. */
      encode(src, b, offset) {
        if (void 0 === offset) {
          offset = 0;
        }
        const elo = this.elementLayout;
        const span = src.reduce((span2, v) => {
          return span2 + elo.encode(v, b, offset + span2);
        }, 0);
        if (this.count instanceof ExternalLayout) {
          this.count.encode(src.length, b, offset);
        }
        return span;
      }
    };
    var Structure = class extends Layout {
      constructor(fields, property, decodePrefixes) {
        if (!(Array.isArray(fields) && fields.reduce((acc, v) => acc && v instanceof Layout, true))) {
          throw new TypeError("fields must be array of Layout instances");
        }
        if ("boolean" === typeof property && void 0 === decodePrefixes) {
          decodePrefixes = property;
          property = void 0;
        }
        for (const fd of fields) {
          if (0 > fd.span && void 0 === fd.property) {
            throw new Error("fields cannot contain unnamed variable-length layout");
          }
        }
        let span = -1;
        try {
          span = fields.reduce((span2, fd) => span2 + fd.getSpan(), 0);
        } catch (e) {
        }
        super(span, property);
        this.fields = fields;
        this.decodePrefixes = !!decodePrefixes;
      }
      /** @override */
      getSpan(b, offset) {
        if (0 <= this.span) {
          return this.span;
        }
        if (void 0 === offset) {
          offset = 0;
        }
        let span = 0;
        try {
          span = this.fields.reduce((span2, fd) => {
            const fsp = fd.getSpan(b, offset);
            offset += fsp;
            return span2 + fsp;
          }, 0);
        } catch (e) {
          throw new RangeError("indeterminate span");
        }
        return span;
      }
      /** @override */
      decode(b, offset) {
        if (void 0 === offset) {
          offset = 0;
        }
        const dest = this.makeDestinationObject();
        for (const fd of this.fields) {
          if (void 0 !== fd.property) {
            dest[fd.property] = fd.decode(b, offset);
          }
          offset += fd.getSpan(b, offset);
          if (this.decodePrefixes && b.length === offset) {
            break;
          }
        }
        return dest;
      }
      /** Implement {@link Layout#encode|encode} for {@link Structure}.
       *
       * If `src` is missing a property for a member with a defined {@link
       * Layout#property|property} the corresponding region of the buffer is
       * left unmodified. */
      encode(src, b, offset) {
        if (void 0 === offset) {
          offset = 0;
        }
        const firstOffset = offset;
        let lastOffset = 0;
        let lastWrote = 0;
        for (const fd of this.fields) {
          let span = fd.span;
          lastWrote = 0 < span ? span : 0;
          if (void 0 !== fd.property) {
            const fv = src[fd.property];
            if (void 0 !== fv) {
              lastWrote = fd.encode(fv, b, offset);
              if (0 > span) {
                span = fd.getSpan(b, offset);
              }
            }
          }
          lastOffset = offset;
          offset += span;
        }
        return lastOffset + lastWrote - firstOffset;
      }
      /** @override */
      fromArray(values) {
        const dest = this.makeDestinationObject();
        for (const fd of this.fields) {
          if (void 0 !== fd.property && 0 < values.length) {
            dest[fd.property] = values.shift();
          }
        }
        return dest;
      }
      /**
       * Get access to the layout of a given property.
       *
       * @param {String} property - the structure member of interest.
       *
       * @return {Layout} - the layout associated with `property`, or
       * undefined if there is no such property.
       */
      layoutFor(property) {
        if ("string" !== typeof property) {
          throw new TypeError("property must be string");
        }
        for (const fd of this.fields) {
          if (fd.property === property) {
            return fd;
          }
        }
      }
      /**
       * Get the offset of a structure member.
       *
       * @param {String} property - the structure member of interest.
       *
       * @return {Number} - the offset in bytes to the start of `property`
       * within the structure, or undefined if `property` is not a field
       * within the structure.  If the property is a member but follows a
       * variable-length structure member a negative number will be
       * returned.
       */
      offsetOf(property) {
        if ("string" !== typeof property) {
          throw new TypeError("property must be string");
        }
        let offset = 0;
        for (const fd of this.fields) {
          if (fd.property === property) {
            return offset;
          }
          if (0 > fd.span) {
            offset = -1;
          } else if (0 <= offset) {
            offset += fd.span;
          }
        }
      }
    };
    var UnionDiscriminator = class {
      constructor(property) {
        this.property = property;
      }
      /** Analog to {@link Layout#decode|Layout decode} for union discriminators.
       *
       * The implementation of this method need not reference the buffer if
       * variant information is available through other means. */
      decode() {
        throw new Error("UnionDiscriminator is abstract");
      }
      /** Analog to {@link Layout#decode|Layout encode} for union discriminators.
       *
       * The implementation of this method need not store the value if
       * variant information is maintained through other means. */
      encode() {
        throw new Error("UnionDiscriminator is abstract");
      }
    };
    var UnionLayoutDiscriminator = class extends UnionDiscriminator {
      constructor(layout, property) {
        if (!(layout instanceof ExternalLayout && layout.isCount())) {
          throw new TypeError("layout must be an unsigned integer ExternalLayout");
        }
        super(property || layout.property || "variant");
        this.layout = layout;
      }
      /** Delegate decoding to {@link UnionLayoutDiscriminator#layout|layout}. */
      decode(b, offset) {
        return this.layout.decode(b, offset);
      }
      /** Delegate encoding to {@link UnionLayoutDiscriminator#layout|layout}. */
      encode(src, b, offset) {
        return this.layout.encode(src, b, offset);
      }
    };
    var Union = class extends Layout {
      constructor(discr, defaultLayout, property) {
        const upv = discr instanceof UInt || discr instanceof UIntBE;
        if (upv) {
          discr = new UnionLayoutDiscriminator(new OffsetLayout(discr));
        } else if (discr instanceof ExternalLayout && discr.isCount()) {
          discr = new UnionLayoutDiscriminator(discr);
        } else if (!(discr instanceof UnionDiscriminator)) {
          throw new TypeError("discr must be a UnionDiscriminator or an unsigned integer layout");
        }
        if (void 0 === defaultLayout) {
          defaultLayout = null;
        }
        if (!(null === defaultLayout || defaultLayout instanceof Layout)) {
          throw new TypeError("defaultLayout must be null or a Layout");
        }
        if (null !== defaultLayout) {
          if (0 > defaultLayout.span) {
            throw new Error("defaultLayout must have constant span");
          }
          if (void 0 === defaultLayout.property) {
            defaultLayout = defaultLayout.replicate("content");
          }
        }
        let span = -1;
        if (defaultLayout) {
          span = defaultLayout.span;
          if (0 <= span && upv) {
            span += discr.layout.span;
          }
        }
        super(span, property);
        this.discriminator = discr;
        this.usesPrefixDiscriminator = upv;
        this.defaultLayout = defaultLayout;
        this.registry = {};
        let boundGetSourceVariant = this.defaultGetSourceVariant.bind(this);
        this.getSourceVariant = function(src) {
          return boundGetSourceVariant(src);
        };
        this.configGetSourceVariant = function(gsv) {
          boundGetSourceVariant = gsv.bind(this);
        };
      }
      /** @override */
      getSpan(b, offset) {
        if (0 <= this.span) {
          return this.span;
        }
        if (void 0 === offset) {
          offset = 0;
        }
        const vlo = this.getVariant(b, offset);
        if (!vlo) {
          throw new Error("unable to determine span for unrecognized variant");
        }
        return vlo.getSpan(b, offset);
      }
      /**
       * Method to infer a registered Union variant compatible with `src`.
       *
       * The first satisified rule in the following sequence defines the
       * return value:
       * * If `src` has properties matching the Union discriminator and
       *   the default layout, `undefined` is returned regardless of the
       *   value of the discriminator property (this ensures the default
       *   layout will be used);
       * * If `src` has a property matching the Union discriminator, the
       *   value of the discriminator identifies a registered variant, and
       *   either (a) the variant has no layout, or (b) `src` has the
       *   variant's property, then the variant is returned (because the
       *   source satisfies the constraints of the variant it identifies);
       * * If `src` does not have a property matching the Union
       *   discriminator, but does have a property matching a registered
       *   variant, then the variant is returned (because the source
       *   matches a variant without an explicit conflict);
       * * An error is thrown (because we either can't identify a variant,
       *   or we were explicitly told the variant but can't satisfy it).
       *
       * @param {Object} src - an object presumed to be compatible with
       * the content of the Union.
       *
       * @return {(undefined|VariantLayout)} - as described above.
       *
       * @throws {Error} - if `src` cannot be associated with a default or
       * registered variant.
       */
      defaultGetSourceVariant(src) {
        if (src.hasOwnProperty(this.discriminator.property)) {
          if (this.defaultLayout && src.hasOwnProperty(this.defaultLayout.property)) {
            return void 0;
          }
          const vlo = this.registry[src[this.discriminator.property]];
          if (vlo && (!vlo.layout || src.hasOwnProperty(vlo.property))) {
            return vlo;
          }
        } else {
          for (const tag2 in this.registry) {
            const vlo = this.registry[tag2];
            if (src.hasOwnProperty(vlo.property)) {
              return vlo;
            }
          }
        }
        throw new Error("unable to infer src variant");
      }
      /** Implement {@link Layout#decode|decode} for {@link Union}.
       *
       * If the variant is {@link Union#addVariant|registered} the return
       * value is an instance of that variant, with no explicit
       * discriminator.  Otherwise the {@link Union#defaultLayout|default
       * layout} is used to decode the content. */
      decode(b, offset) {
        if (void 0 === offset) {
          offset = 0;
        }
        let dest;
        const dlo = this.discriminator;
        const discr = dlo.decode(b, offset);
        let clo = this.registry[discr];
        if (void 0 === clo) {
          let contentOffset = 0;
          clo = this.defaultLayout;
          if (this.usesPrefixDiscriminator) {
            contentOffset = dlo.layout.span;
          }
          dest = this.makeDestinationObject();
          dest[dlo.property] = discr;
          dest[clo.property] = this.defaultLayout.decode(b, offset + contentOffset);
        } else {
          dest = clo.decode(b, offset);
        }
        return dest;
      }
      /** Implement {@link Layout#encode|encode} for {@link Union}.
       *
       * This API assumes the `src` object is consistent with the union's
       * {@link Union#defaultLayout|default layout}.  To encode variants
       * use the appropriate variant-specific {@link VariantLayout#encode}
       * method. */
      encode(src, b, offset) {
        if (void 0 === offset) {
          offset = 0;
        }
        const vlo = this.getSourceVariant(src);
        if (void 0 === vlo) {
          const dlo = this.discriminator;
          const clo = this.defaultLayout;
          let contentOffset = 0;
          if (this.usesPrefixDiscriminator) {
            contentOffset = dlo.layout.span;
          }
          dlo.encode(src[dlo.property], b, offset);
          return contentOffset + clo.encode(
            src[clo.property],
            b,
            offset + contentOffset
          );
        }
        return vlo.encode(src, b, offset);
      }
      /** Register a new variant structure within a union.  The newly
       * created variant is returned.
       *
       * @param {Number} variant - initializer for {@link
       * VariantLayout#variant|variant}.
       *
       * @param {Layout} layout - initializer for {@link
       * VariantLayout#layout|layout}.
       *
       * @param {String} property - initializer for {@link
       * Layout#property|property}.
       *
       * @return {VariantLayout} */
      addVariant(variant, layout, property) {
        const rv = new VariantLayout(this, variant, layout, property);
        this.registry[variant] = rv;
        return rv;
      }
      /**
       * Get the layout associated with a registered variant.
       *
       * If `vb` does not produce a registered variant the function returns
       * `undefined`.
       *
       * @param {(Number|Buffer)} vb - either the variant number, or a
       * buffer from which the discriminator is to be read.
       *
       * @param {Number} offset - offset into `vb` for the start of the
       * union.  Used only when `vb` is an instance of {Buffer}.
       *
       * @return {({VariantLayout}|undefined)}
       */
      getVariant(vb, offset) {
        let variant = vb;
        if (Buffer.isBuffer(vb)) {
          if (void 0 === offset) {
            offset = 0;
          }
          variant = this.discriminator.decode(vb, offset);
        }
        return this.registry[variant];
      }
    };
    var VariantLayout = class extends Layout {
      constructor(union, variant, layout, property) {
        if (!(union instanceof Union)) {
          throw new TypeError("union must be a Union");
        }
        if (!Number.isInteger(variant) || 0 > variant) {
          throw new TypeError("variant must be a (non-negative) integer");
        }
        if ("string" === typeof layout && void 0 === property) {
          property = layout;
          layout = null;
        }
        if (layout) {
          if (!(layout instanceof Layout)) {
            throw new TypeError("layout must be a Layout");
          }
          if (null !== union.defaultLayout && 0 <= layout.span && layout.span > union.defaultLayout.span) {
            throw new Error("variant span exceeds span of containing union");
          }
          if ("string" !== typeof property) {
            throw new TypeError("variant must have a String property");
          }
        }
        let span = union.span;
        if (0 > union.span) {
          span = layout ? layout.span : 0;
          if (0 <= span && union.usesPrefixDiscriminator) {
            span += union.discriminator.layout.span;
          }
        }
        super(span, property);
        this.union = union;
        this.variant = variant;
        this.layout = layout || null;
      }
      /** @override */
      getSpan(b, offset) {
        if (0 <= this.span) {
          return this.span;
        }
        if (void 0 === offset) {
          offset = 0;
        }
        let contentOffset = 0;
        if (this.union.usesPrefixDiscriminator) {
          contentOffset = this.union.discriminator.layout.span;
        }
        return contentOffset + this.layout.getSpan(b, offset + contentOffset);
      }
      /** @override */
      decode(b, offset) {
        const dest = this.makeDestinationObject();
        if (void 0 === offset) {
          offset = 0;
        }
        if (this !== this.union.getVariant(b, offset)) {
          throw new Error("variant mismatch");
        }
        let contentOffset = 0;
        if (this.union.usesPrefixDiscriminator) {
          contentOffset = this.union.discriminator.layout.span;
        }
        if (this.layout) {
          dest[this.property] = this.layout.decode(b, offset + contentOffset);
        } else if (this.property) {
          dest[this.property] = true;
        } else if (this.union.usesPrefixDiscriminator) {
          dest[this.union.discriminator.property] = this.variant;
        }
        return dest;
      }
      /** @override */
      encode(src, b, offset) {
        if (void 0 === offset) {
          offset = 0;
        }
        let contentOffset = 0;
        if (this.union.usesPrefixDiscriminator) {
          contentOffset = this.union.discriminator.layout.span;
        }
        if (this.layout && !src.hasOwnProperty(this.property)) {
          throw new TypeError("variant lacks property " + this.property);
        }
        this.union.discriminator.encode(this.variant, b, offset);
        let span = contentOffset;
        if (this.layout) {
          this.layout.encode(src[this.property], b, offset + contentOffset);
          span += this.layout.getSpan(b, offset + contentOffset);
          if (0 <= this.union.span && span > this.union.span) {
            throw new Error("encoded variant overruns containing union");
          }
        }
        return span;
      }
      /** Delegate {@link Layout#fromArray|fromArray} to {@link
       * VariantLayout#layout|layout}. */
      fromArray(values) {
        if (this.layout) {
          return this.layout.fromArray(values);
        }
      }
    };
    function fixBitwiseResult(v) {
      if (0 > v) {
        v += 4294967296;
      }
      return v;
    }
    var BitStructure = class extends Layout {
      constructor(word, msb, property) {
        if (!(word instanceof UInt || word instanceof UIntBE)) {
          throw new TypeError("word must be a UInt or UIntBE layout");
        }
        if ("string" === typeof msb && void 0 === property) {
          property = msb;
          msb = void 0;
        }
        if (4 < word.span) {
          throw new RangeError("word cannot exceed 32 bits");
        }
        super(word.span, property);
        this.word = word;
        this.msb = !!msb;
        this.fields = [];
        let value = 0;
        this._packedSetValue = function(v) {
          value = fixBitwiseResult(v);
          return this;
        };
        this._packedGetValue = function() {
          return value;
        };
      }
      /** @override */
      decode(b, offset) {
        const dest = this.makeDestinationObject();
        if (void 0 === offset) {
          offset = 0;
        }
        const value = this.word.decode(b, offset);
        this._packedSetValue(value);
        for (const fd of this.fields) {
          if (void 0 !== fd.property) {
            dest[fd.property] = fd.decode(value);
          }
        }
        return dest;
      }
      /** Implement {@link Layout#encode|encode} for {@link BitStructure}.
       *
       * If `src` is missing a property for a member with a defined {@link
       * Layout#property|property} the corresponding region of the packed
       * value is left unmodified.  Unused bits are also left unmodified. */
      encode(src, b, offset) {
        if (void 0 === offset) {
          offset = 0;
        }
        const value = this.word.decode(b, offset);
        this._packedSetValue(value);
        for (const fd of this.fields) {
          if (void 0 !== fd.property) {
            const fv = src[fd.property];
            if (void 0 !== fv) {
              fd.encode(fv);
            }
          }
        }
        return this.word.encode(this._packedGetValue(), b, offset);
      }
      /** Register a new bitfield with a containing bit structure.  The
       * resulting bitfield is returned.
       *
       * @param {Number} bits - initializer for {@link BitField#bits|bits}.
       *
       * @param {string} property - initializer for {@link
       * Layout#property|property}.
       *
       * @return {BitField} */
      addField(bits, property) {
        const bf = new BitField(this, bits, property);
        this.fields.push(bf);
        return bf;
      }
      /** As with {@link BitStructure#addField|addField} for single-bit
       * fields with `boolean` value representation.
       *
       * @param {string} property - initializer for {@link
       * Layout#property|property}.
       *
       * @return {Boolean} */
      addBoolean(property) {
        const bf = new Boolean2(this, property);
        this.fields.push(bf);
        return bf;
      }
      /**
       * Get access to the bit field for a given property.
       *
       * @param {String} property - the bit field of interest.
       *
       * @return {BitField} - the field associated with `property`, or
       * undefined if there is no such property.
       */
      fieldFor(property) {
        if ("string" !== typeof property) {
          throw new TypeError("property must be string");
        }
        for (const fd of this.fields) {
          if (fd.property === property) {
            return fd;
          }
        }
      }
    };
    var BitField = class {
      constructor(container, bits, property) {
        if (!(container instanceof BitStructure)) {
          throw new TypeError("container must be a BitStructure");
        }
        if (!Number.isInteger(bits) || 0 >= bits) {
          throw new TypeError("bits must be positive integer");
        }
        const totalBits = 8 * container.span;
        const usedBits = container.fields.reduce((sum2, fd) => sum2 + fd.bits, 0);
        if (bits + usedBits > totalBits) {
          throw new Error("bits too long for span remainder (" + (totalBits - usedBits) + " of " + totalBits + " remain)");
        }
        this.container = container;
        this.bits = bits;
        this.valueMask = (1 << bits) - 1;
        if (32 === bits) {
          this.valueMask = 4294967295;
        }
        this.start = usedBits;
        if (this.container.msb) {
          this.start = totalBits - usedBits - bits;
        }
        this.wordMask = fixBitwiseResult(this.valueMask << this.start);
        this.property = property;
      }
      /** Store a value into the corresponding subsequence of the containing
       * bit field. */
      decode() {
        const word = this.container._packedGetValue();
        const wordValue = fixBitwiseResult(word & this.wordMask);
        const value = wordValue >>> this.start;
        return value;
      }
      /** Store a value into the corresponding subsequence of the containing
       * bit field.
       *
       * **NOTE** This is not a specialization of {@link
       * Layout#encode|Layout.encode} and there is no return value. */
      encode(value) {
        if (!Number.isInteger(value) || value !== fixBitwiseResult(value & this.valueMask)) {
          throw new TypeError(nameWithProperty("BitField.encode", this) + " value must be integer not exceeding " + this.valueMask);
        }
        const word = this.container._packedGetValue();
        const wordValue = fixBitwiseResult(value << this.start);
        this.container._packedSetValue(fixBitwiseResult(word & ~this.wordMask) | wordValue);
      }
    };
    var Boolean2 = class extends BitField {
      constructor(container, property) {
        super(container, 1, property);
      }
      /** Override {@link BitField#decode|decode} for {@link Boolean|Boolean}.
       *
       * @returns {boolean} */
      decode(b, offset) {
        return !!BitField.prototype.decode.call(this, b, offset);
      }
      /** @override */
      encode(value) {
        if ("boolean" === typeof value) {
          value = +value;
        }
        return BitField.prototype.encode.call(this, value);
      }
    };
    var Blob = class extends Layout {
      constructor(length, property) {
        if (!(length instanceof ExternalLayout && length.isCount() || Number.isInteger(length) && 0 <= length)) {
          throw new TypeError("length must be positive integer or an unsigned integer ExternalLayout");
        }
        let span = -1;
        if (!(length instanceof ExternalLayout)) {
          span = length;
        }
        super(span, property);
        this.length = length;
      }
      /** @override */
      getSpan(b, offset) {
        let span = this.span;
        if (0 > span) {
          span = this.length.decode(b, offset);
        }
        return span;
      }
      /** @override */
      decode(b, offset) {
        if (void 0 === offset) {
          offset = 0;
        }
        let span = this.span;
        if (0 > span) {
          span = this.length.decode(b, offset);
        }
        return b.slice(offset, offset + span);
      }
      /** Implement {@link Layout#encode|encode} for {@link Blob}.
       *
       * **NOTE** If {@link Layout#count|count} is an instance of {@link
       * ExternalLayout} then the length of `src` will be encoded as the
       * count after `src` is encoded. */
      encode(src, b, offset) {
        let span = this.length;
        if (this.length instanceof ExternalLayout) {
          span = src.length;
        }
        if (!(Buffer.isBuffer(src) && span === src.length)) {
          throw new TypeError(nameWithProperty("Blob.encode", this) + " requires (length " + span + ") Buffer as src");
        }
        if (offset + span > b.length) {
          throw new RangeError("encoding overruns Buffer");
        }
        b.write(src.toString("hex"), offset, span, "hex");
        if (this.length instanceof ExternalLayout) {
          this.length.encode(span, b, offset);
        }
        return span;
      }
    };
    var CString = class extends Layout {
      constructor(property) {
        super(-1, property);
      }
      /** @override */
      getSpan(b, offset) {
        if (!Buffer.isBuffer(b)) {
          throw new TypeError("b must be a Buffer");
        }
        if (void 0 === offset) {
          offset = 0;
        }
        let idx = offset;
        while (idx < b.length && 0 !== b[idx]) {
          idx += 1;
        }
        return 1 + idx - offset;
      }
      /** @override */
      decode(b, offset, dest) {
        if (void 0 === offset) {
          offset = 0;
        }
        let span = this.getSpan(b, offset);
        return b.slice(offset, offset + span - 1).toString("utf-8");
      }
      /** @override */
      encode(src, b, offset) {
        if (void 0 === offset) {
          offset = 0;
        }
        if ("string" !== typeof src) {
          src = src.toString();
        }
        const srcb = new Buffer(src, "utf8");
        const span = srcb.length;
        if (offset + span > b.length) {
          throw new RangeError("encoding overruns Buffer");
        }
        srcb.copy(b, offset);
        b[offset + span] = 0;
        return span + 1;
      }
    };
    var UTF8 = class extends Layout {
      constructor(maxSpan, property) {
        if ("string" === typeof maxSpan && void 0 === property) {
          property = maxSpan;
          maxSpan = void 0;
        }
        if (void 0 === maxSpan) {
          maxSpan = -1;
        } else if (!Number.isInteger(maxSpan)) {
          throw new TypeError("maxSpan must be an integer");
        }
        super(-1, property);
        this.maxSpan = maxSpan;
      }
      /** @override */
      getSpan(b, offset) {
        if (!Buffer.isBuffer(b)) {
          throw new TypeError("b must be a Buffer");
        }
        if (void 0 === offset) {
          offset = 0;
        }
        return b.length - offset;
      }
      /** @override */
      decode(b, offset, dest) {
        if (void 0 === offset) {
          offset = 0;
        }
        let span = this.getSpan(b, offset);
        if (0 <= this.maxSpan && this.maxSpan < span) {
          throw new RangeError("text length exceeds maxSpan");
        }
        return b.slice(offset, offset + span).toString("utf-8");
      }
      /** @override */
      encode(src, b, offset) {
        if (void 0 === offset) {
          offset = 0;
        }
        if ("string" !== typeof src) {
          src = src.toString();
        }
        const srcb = new Buffer(src, "utf8");
        const span = srcb.length;
        if (0 <= this.maxSpan && this.maxSpan < span) {
          throw new RangeError("text length exceeds maxSpan");
        }
        if (offset + span > b.length) {
          throw new RangeError("encoding overruns Buffer");
        }
        srcb.copy(b, offset);
        return span;
      }
    };
    var Constant = class extends Layout {
      constructor(value, property) {
        super(0, property);
        this.value = value;
      }
      /** @override */
      decode(b, offset, dest) {
        return this.value;
      }
      /** @override */
      encode(src, b, offset) {
        return 0;
      }
    };
    exports2.ExternalLayout = ExternalLayout;
    exports2.GreedyCount = GreedyCount;
    exports2.OffsetLayout = OffsetLayout;
    exports2.UInt = UInt;
    exports2.UIntBE = UIntBE;
    exports2.Int = Int;
    exports2.IntBE = IntBE;
    exports2.Float = Float;
    exports2.FloatBE = FloatBE;
    exports2.Double = Double;
    exports2.DoubleBE = DoubleBE;
    exports2.Sequence = Sequence;
    exports2.Structure = Structure;
    exports2.UnionDiscriminator = UnionDiscriminator;
    exports2.UnionLayoutDiscriminator = UnionLayoutDiscriminator;
    exports2.Union = Union;
    exports2.VariantLayout = VariantLayout;
    exports2.BitStructure = BitStructure;
    exports2.BitField = BitField;
    exports2.Boolean = Boolean2;
    exports2.Blob = Blob;
    exports2.CString = CString;
    exports2.UTF8 = UTF8;
    exports2.Constant = Constant;
    exports2.greedy = (elementSpan, property) => new GreedyCount(elementSpan, property);
    exports2.offset = (layout, offset, property) => new OffsetLayout(layout, offset, property);
    exports2.u8 = (property) => new UInt(1, property);
    exports2.u16 = (property) => new UInt(2, property);
    exports2.u24 = (property) => new UInt(3, property);
    exports2.u32 = (property) => new UInt(4, property);
    exports2.u40 = (property) => new UInt(5, property);
    exports2.u48 = (property) => new UInt(6, property);
    exports2.nu64 = (property) => new NearUInt64(property);
    exports2.u16be = (property) => new UIntBE(2, property);
    exports2.u24be = (property) => new UIntBE(3, property);
    exports2.u32be = (property) => new UIntBE(4, property);
    exports2.u40be = (property) => new UIntBE(5, property);
    exports2.u48be = (property) => new UIntBE(6, property);
    exports2.nu64be = (property) => new NearUInt64BE(property);
    exports2.s8 = (property) => new Int(1, property);
    exports2.s16 = (property) => new Int(2, property);
    exports2.s24 = (property) => new Int(3, property);
    exports2.s32 = (property) => new Int(4, property);
    exports2.s40 = (property) => new Int(5, property);
    exports2.s48 = (property) => new Int(6, property);
    exports2.ns64 = (property) => new NearInt64(property);
    exports2.s16be = (property) => new IntBE(2, property);
    exports2.s24be = (property) => new IntBE(3, property);
    exports2.s32be = (property) => new IntBE(4, property);
    exports2.s40be = (property) => new IntBE(5, property);
    exports2.s48be = (property) => new IntBE(6, property);
    exports2.ns64be = (property) => new NearInt64BE(property);
    exports2.f32 = (property) => new Float(property);
    exports2.f32be = (property) => new FloatBE(property);
    exports2.f64 = (property) => new Double(property);
    exports2.f64be = (property) => new DoubleBE(property);
    exports2.struct = (fields, property, decodePrefixes) => new Structure(fields, property, decodePrefixes);
    exports2.bits = (word, msb, property) => new BitStructure(word, msb, property);
    exports2.seq = (elementLayout, count, property) => new Sequence(elementLayout, count, property);
    exports2.union = (discr, defaultLayout, property) => new Union(discr, defaultLayout, property);
    exports2.unionLayoutDiscriminator = (layout, property) => new UnionLayoutDiscriminator(layout, property);
    exports2.blob = (length, property) => new Blob(length, property);
    exports2.cstr = (property) => new CString(property);
    exports2.utf8 = (maxSpan, property) => new UTF8(maxSpan, property);
    exports2.const = (value, property) => new Constant(value, property);
  }
});

// node_modules/bn.js/lib/bn.js
var require_bn = __commonJS({
  "node_modules/bn.js/lib/bn.js"(exports2, module2) {
    (function(module3, exports3) {
      "use strict";
      function assert(val, msg) {
        if (!val)
          throw new Error(msg || "Assertion failed");
      }
      function inherits(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
      function BN23(number, base, endian) {
        if (BN23.isBN(number)) {
          return number;
        }
        this.negative = 0;
        this.words = null;
        this.length = 0;
        this.red = null;
        if (number !== null) {
          if (base === "le" || base === "be") {
            endian = base;
            base = 10;
          }
          this._init(number || 0, base || 10, endian || "be");
        }
      }
      if (typeof module3 === "object") {
        module3.exports = BN23;
      } else {
        exports3.BN = BN23;
      }
      BN23.BN = BN23;
      BN23.wordSize = 26;
      var Buffer2;
      try {
        if (typeof window !== "undefined" && typeof window.Buffer !== "undefined") {
          Buffer2 = window.Buffer;
        } else {
          Buffer2 = require("buffer").Buffer;
        }
      } catch (e) {
      }
      BN23.isBN = function isBN(num) {
        if (num instanceof BN23) {
          return true;
        }
        return num !== null && typeof num === "object" && num.constructor.wordSize === BN23.wordSize && Array.isArray(num.words);
      };
      BN23.max = function max2(left, right) {
        if (left.cmp(right) > 0)
          return left;
        return right;
      };
      BN23.min = function min2(left, right) {
        if (left.cmp(right) < 0)
          return left;
        return right;
      };
      BN23.prototype._init = function init(number, base, endian) {
        if (typeof number === "number") {
          return this._initNumber(number, base, endian);
        }
        if (typeof number === "object") {
          return this._initArray(number, base, endian);
        }
        if (base === "hex") {
          base = 16;
        }
        assert(base === (base | 0) && base >= 2 && base <= 36);
        number = number.toString().replace(/\s+/g, "");
        var start = 0;
        if (number[0] === "-") {
          start++;
          this.negative = 1;
        }
        if (start < number.length) {
          if (base === 16) {
            this._parseHex(number, start, endian);
          } else {
            this._parseBase(number, base, start);
            if (endian === "le") {
              this._initArray(this.toArray(), base, endian);
            }
          }
        }
      };
      BN23.prototype._initNumber = function _initNumber(number, base, endian) {
        if (number < 0) {
          this.negative = 1;
          number = -number;
        }
        if (number < 67108864) {
          this.words = [number & 67108863];
          this.length = 1;
        } else if (number < 4503599627370496) {
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863
          ];
          this.length = 2;
        } else {
          assert(number < 9007199254740992);
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863,
            1
          ];
          this.length = 3;
        }
        if (endian !== "le")
          return;
        this._initArray(this.toArray(), base, endian);
      };
      BN23.prototype._initArray = function _initArray(number, base, endian) {
        assert(typeof number.length === "number");
        if (number.length <= 0) {
          this.words = [0];
          this.length = 1;
          return this;
        }
        this.length = Math.ceil(number.length / 3);
        this.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) {
          this.words[i] = 0;
        }
        var j, w;
        var off = 0;
        if (endian === "be") {
          for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
            w = number[i] | number[i - 1] << 8 | number[i - 2] << 16;
            this.words[j] |= w << off & 67108863;
            this.words[j + 1] = w >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j++;
            }
          }
        } else if (endian === "le") {
          for (i = 0, j = 0; i < number.length; i += 3) {
            w = number[i] | number[i + 1] << 8 | number[i + 2] << 16;
            this.words[j] |= w << off & 67108863;
            this.words[j + 1] = w >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j++;
            }
          }
        }
        return this._strip();
      };
      function parseHex4Bits(string, index) {
        var c = string.charCodeAt(index);
        if (c >= 48 && c <= 57) {
          return c - 48;
        } else if (c >= 65 && c <= 70) {
          return c - 55;
        } else if (c >= 97 && c <= 102) {
          return c - 87;
        } else {
          assert(false, "Invalid character in " + string);
        }
      }
      function parseHexByte(string, lowerBound, index) {
        var r = parseHex4Bits(string, index);
        if (index - 1 >= lowerBound) {
          r |= parseHex4Bits(string, index - 1) << 4;
        }
        return r;
      }
      BN23.prototype._parseHex = function _parseHex(number, start, endian) {
        this.length = Math.ceil((number.length - start) / 6);
        this.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) {
          this.words[i] = 0;
        }
        var off = 0;
        var j = 0;
        var w;
        if (endian === "be") {
          for (i = number.length - 1; i >= start; i -= 2) {
            w = parseHexByte(number, start, i) << off;
            this.words[j] |= w & 67108863;
            if (off >= 18) {
              off -= 18;
              j += 1;
              this.words[j] |= w >>> 26;
            } else {
              off += 8;
            }
          }
        } else {
          var parseLength = number.length - start;
          for (i = parseLength % 2 === 0 ? start + 1 : start; i < number.length; i += 2) {
            w = parseHexByte(number, start, i) << off;
            this.words[j] |= w & 67108863;
            if (off >= 18) {
              off -= 18;
              j += 1;
              this.words[j] |= w >>> 26;
            } else {
              off += 8;
            }
          }
        }
        this._strip();
      };
      function parseBase(str, start, end, mul2) {
        var r = 0;
        var b = 0;
        var len = Math.min(str.length, end);
        for (var i = start; i < len; i++) {
          var c = str.charCodeAt(i) - 48;
          r *= mul2;
          if (c >= 49) {
            b = c - 49 + 10;
          } else if (c >= 17) {
            b = c - 17 + 10;
          } else {
            b = c;
          }
          assert(c >= 0 && b < mul2, "Invalid character");
          r += b;
        }
        return r;
      }
      BN23.prototype._parseBase = function _parseBase(number, base, start) {
        this.words = [0];
        this.length = 1;
        for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base) {
          limbLen++;
        }
        limbLen--;
        limbPow = limbPow / base | 0;
        var total = number.length - start;
        var mod2 = total % limbLen;
        var end = Math.min(total, total - mod2) + start;
        var word = 0;
        for (var i = start; i < end; i += limbLen) {
          word = parseBase(number, i, i + limbLen, base);
          this.imuln(limbPow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        if (mod2 !== 0) {
          var pow3 = 1;
          word = parseBase(number, i, number.length, base);
          for (i = 0; i < mod2; i++) {
            pow3 *= base;
          }
          this.imuln(pow3);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        this._strip();
      };
      BN23.prototype.copy = function copy(dest) {
        dest.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) {
          dest.words[i] = this.words[i];
        }
        dest.length = this.length;
        dest.negative = this.negative;
        dest.red = this.red;
      };
      function move(dest, src) {
        dest.words = src.words;
        dest.length = src.length;
        dest.negative = src.negative;
        dest.red = src.red;
      }
      BN23.prototype._move = function _move(dest) {
        move(dest, this);
      };
      BN23.prototype.clone = function clone3() {
        var r = new BN23(null);
        this.copy(r);
        return r;
      };
      BN23.prototype._expand = function _expand(size) {
        while (this.length < size) {
          this.words[this.length++] = 0;
        }
        return this;
      };
      BN23.prototype._strip = function strip() {
        while (this.length > 1 && this.words[this.length - 1] === 0) {
          this.length--;
        }
        return this._normSign();
      };
      BN23.prototype._normSign = function _normSign() {
        if (this.length === 1 && this.words[0] === 0) {
          this.negative = 0;
        }
        return this;
      };
      if (typeof Symbol !== "undefined" && typeof Symbol.for === "function") {
        try {
          BN23.prototype[Symbol.for("nodejs.util.inspect.custom")] = inspect;
        } catch (e) {
          BN23.prototype.inspect = inspect;
        }
      } else {
        BN23.prototype.inspect = inspect;
      }
      function inspect() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      }
      var zeros = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
      ];
      var groupSizes = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
      ];
      var groupBases = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        1e7,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64e6,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        243e5,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
      ];
      BN23.prototype.toString = function toString(base, padding) {
        base = base || 10;
        padding = padding | 0 || 1;
        var out;
        if (base === 16 || base === "hex") {
          out = "";
          var off = 0;
          var carry = 0;
          for (var i = 0; i < this.length; i++) {
            var w = this.words[i];
            var word = ((w << off | carry) & 16777215).toString(16);
            carry = w >>> 24 - off & 16777215;
            off += 2;
            if (off >= 26) {
              off -= 26;
              i--;
            }
            if (carry !== 0 || i !== this.length - 1) {
              out = zeros[6 - word.length] + word + out;
            } else {
              out = word + out;
            }
          }
          if (carry !== 0) {
            out = carry.toString(16) + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        if (base === (base | 0) && base >= 2 && base <= 36) {
          var groupSize = groupSizes[base];
          var groupBase = groupBases[base];
          out = "";
          var c = this.clone();
          c.negative = 0;
          while (!c.isZero()) {
            var r = c.modrn(groupBase).toString(base);
            c = c.idivn(groupBase);
            if (!c.isZero()) {
              out = zeros[groupSize - r.length] + r + out;
            } else {
              out = r + out;
            }
          }
          if (this.isZero()) {
            out = "0" + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        assert(false, "Base should be between 2 and 36");
      };
      BN23.prototype.toNumber = function toNumber() {
        var ret = this.words[0];
        if (this.length === 2) {
          ret += this.words[1] * 67108864;
        } else if (this.length === 3 && this.words[2] === 1) {
          ret += 4503599627370496 + this.words[1] * 67108864;
        } else if (this.length > 2) {
          assert(false, "Number can only safely store up to 53 bits");
        }
        return this.negative !== 0 ? -ret : ret;
      };
      BN23.prototype.toJSON = function toJSON() {
        return this.toString(16, 2);
      };
      if (Buffer2) {
        BN23.prototype.toBuffer = function toBuffer(endian, length) {
          return this.toArrayLike(Buffer2, endian, length);
        };
      }
      BN23.prototype.toArray = function toArray(endian, length) {
        return this.toArrayLike(Array, endian, length);
      };
      var allocate = function allocate2(ArrayType, size) {
        if (ArrayType.allocUnsafe) {
          return ArrayType.allocUnsafe(size);
        }
        return new ArrayType(size);
      };
      BN23.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
        this._strip();
        var byteLength = this.byteLength();
        var reqLength = length || Math.max(1, byteLength);
        assert(byteLength <= reqLength, "byte array longer than desired length");
        assert(reqLength > 0, "Requested array length <= 0");
        var res = allocate(ArrayType, reqLength);
        var postfix = endian === "le" ? "LE" : "BE";
        this["_toArrayLike" + postfix](res, byteLength);
        return res;
      };
      BN23.prototype._toArrayLikeLE = function _toArrayLikeLE(res, byteLength) {
        var position = 0;
        var carry = 0;
        for (var i = 0, shift = 0; i < this.length; i++) {
          var word = this.words[i] << shift | carry;
          res[position++] = word & 255;
          if (position < res.length) {
            res[position++] = word >> 8 & 255;
          }
          if (position < res.length) {
            res[position++] = word >> 16 & 255;
          }
          if (shift === 6) {
            if (position < res.length) {
              res[position++] = word >> 24 & 255;
            }
            carry = 0;
            shift = 0;
          } else {
            carry = word >>> 24;
            shift += 2;
          }
        }
        if (position < res.length) {
          res[position++] = carry;
          while (position < res.length) {
            res[position++] = 0;
          }
        }
      };
      BN23.prototype._toArrayLikeBE = function _toArrayLikeBE(res, byteLength) {
        var position = res.length - 1;
        var carry = 0;
        for (var i = 0, shift = 0; i < this.length; i++) {
          var word = this.words[i] << shift | carry;
          res[position--] = word & 255;
          if (position >= 0) {
            res[position--] = word >> 8 & 255;
          }
          if (position >= 0) {
            res[position--] = word >> 16 & 255;
          }
          if (shift === 6) {
            if (position >= 0) {
              res[position--] = word >> 24 & 255;
            }
            carry = 0;
            shift = 0;
          } else {
            carry = word >>> 24;
            shift += 2;
          }
        }
        if (position >= 0) {
          res[position--] = carry;
          while (position >= 0) {
            res[position--] = 0;
          }
        }
      };
      if (Math.clz32) {
        BN23.prototype._countBits = function _countBits(w) {
          return 32 - Math.clz32(w);
        };
      } else {
        BN23.prototype._countBits = function _countBits(w) {
          var t = w;
          var r = 0;
          if (t >= 4096) {
            r += 13;
            t >>>= 13;
          }
          if (t >= 64) {
            r += 7;
            t >>>= 7;
          }
          if (t >= 8) {
            r += 4;
            t >>>= 4;
          }
          if (t >= 2) {
            r += 2;
            t >>>= 2;
          }
          return r + t;
        };
      }
      BN23.prototype._zeroBits = function _zeroBits(w) {
        if (w === 0)
          return 26;
        var t = w;
        var r = 0;
        if ((t & 8191) === 0) {
          r += 13;
          t >>>= 13;
        }
        if ((t & 127) === 0) {
          r += 7;
          t >>>= 7;
        }
        if ((t & 15) === 0) {
          r += 4;
          t >>>= 4;
        }
        if ((t & 3) === 0) {
          r += 2;
          t >>>= 2;
        }
        if ((t & 1) === 0) {
          r++;
        }
        return r;
      };
      BN23.prototype.bitLength = function bitLength() {
        var w = this.words[this.length - 1];
        var hi = this._countBits(w);
        return (this.length - 1) * 26 + hi;
      };
      function toBitArray(num) {
        var w = new Array(num.bitLength());
        for (var bit = 0; bit < w.length; bit++) {
          var off = bit / 26 | 0;
          var wbit = bit % 26;
          w[bit] = num.words[off] >>> wbit & 1;
        }
        return w;
      }
      BN23.prototype.zeroBits = function zeroBits() {
        if (this.isZero())
          return 0;
        var r = 0;
        for (var i = 0; i < this.length; i++) {
          var b = this._zeroBits(this.words[i]);
          r += b;
          if (b !== 26)
            break;
        }
        return r;
      };
      BN23.prototype.byteLength = function byteLength() {
        return Math.ceil(this.bitLength() / 8);
      };
      BN23.prototype.toTwos = function toTwos(width) {
        if (this.negative !== 0) {
          return this.abs().inotn(width).iaddn(1);
        }
        return this.clone();
      };
      BN23.prototype.fromTwos = function fromTwos(width) {
        if (this.testn(width - 1)) {
          return this.notn(width).iaddn(1).ineg();
        }
        return this.clone();
      };
      BN23.prototype.isNeg = function isNeg() {
        return this.negative !== 0;
      };
      BN23.prototype.neg = function neg() {
        return this.clone().ineg();
      };
      BN23.prototype.ineg = function ineg() {
        if (!this.isZero()) {
          this.negative ^= 1;
        }
        return this;
      };
      BN23.prototype.iuor = function iuor(num) {
        while (this.length < num.length) {
          this.words[this.length++] = 0;
        }
        for (var i = 0; i < num.length; i++) {
          this.words[i] = this.words[i] | num.words[i];
        }
        return this._strip();
      };
      BN23.prototype.ior = function ior(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuor(num);
      };
      BN23.prototype.or = function or(num) {
        if (this.length > num.length)
          return this.clone().ior(num);
        return num.clone().ior(this);
      };
      BN23.prototype.uor = function uor(num) {
        if (this.length > num.length)
          return this.clone().iuor(num);
        return num.clone().iuor(this);
      };
      BN23.prototype.iuand = function iuand(num) {
        var b;
        if (this.length > num.length) {
          b = num;
        } else {
          b = this;
        }
        for (var i = 0; i < b.length; i++) {
          this.words[i] = this.words[i] & num.words[i];
        }
        this.length = b.length;
        return this._strip();
      };
      BN23.prototype.iand = function iand(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuand(num);
      };
      BN23.prototype.and = function and(num) {
        if (this.length > num.length)
          return this.clone().iand(num);
        return num.clone().iand(this);
      };
      BN23.prototype.uand = function uand(num) {
        if (this.length > num.length)
          return this.clone().iuand(num);
        return num.clone().iuand(this);
      };
      BN23.prototype.iuxor = function iuxor(num) {
        var a;
        var b;
        if (this.length > num.length) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }
        for (var i = 0; i < b.length; i++) {
          this.words[i] = a.words[i] ^ b.words[i];
        }
        if (this !== a) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }
        this.length = a.length;
        return this._strip();
      };
      BN23.prototype.ixor = function ixor(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuxor(num);
      };
      BN23.prototype.xor = function xor(num) {
        if (this.length > num.length)
          return this.clone().ixor(num);
        return num.clone().ixor(this);
      };
      BN23.prototype.uxor = function uxor(num) {
        if (this.length > num.length)
          return this.clone().iuxor(num);
        return num.clone().iuxor(this);
      };
      BN23.prototype.inotn = function inotn(width) {
        assert(typeof width === "number" && width >= 0);
        var bytesNeeded = Math.ceil(width / 26) | 0;
        var bitsLeft = width % 26;
        this._expand(bytesNeeded);
        if (bitsLeft > 0) {
          bytesNeeded--;
        }
        for (var i = 0; i < bytesNeeded; i++) {
          this.words[i] = ~this.words[i] & 67108863;
        }
        if (bitsLeft > 0) {
          this.words[i] = ~this.words[i] & 67108863 >> 26 - bitsLeft;
        }
        return this._strip();
      };
      BN23.prototype.notn = function notn(width) {
        return this.clone().inotn(width);
      };
      BN23.prototype.setn = function setn(bit, val) {
        assert(typeof bit === "number" && bit >= 0);
        var off = bit / 26 | 0;
        var wbit = bit % 26;
        this._expand(off + 1);
        if (val) {
          this.words[off] = this.words[off] | 1 << wbit;
        } else {
          this.words[off] = this.words[off] & ~(1 << wbit);
        }
        return this._strip();
      };
      BN23.prototype.iadd = function iadd(num) {
        var r;
        if (this.negative !== 0 && num.negative === 0) {
          this.negative = 0;
          r = this.isub(num);
          this.negative ^= 1;
          return this._normSign();
        } else if (this.negative === 0 && num.negative !== 0) {
          num.negative = 0;
          r = this.isub(num);
          num.negative = 1;
          return r._normSign();
        }
        var a, b;
        if (this.length > num.length) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }
        var carry = 0;
        for (var i = 0; i < b.length; i++) {
          r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
          this.words[i] = r & 67108863;
          carry = r >>> 26;
        }
        for (; carry !== 0 && i < a.length; i++) {
          r = (a.words[i] | 0) + carry;
          this.words[i] = r & 67108863;
          carry = r >>> 26;
        }
        this.length = a.length;
        if (carry !== 0) {
          this.words[this.length] = carry;
          this.length++;
        } else if (a !== this) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }
        return this;
      };
      BN23.prototype.add = function add2(num) {
        var res;
        if (num.negative !== 0 && this.negative === 0) {
          num.negative = 0;
          res = this.sub(num);
          num.negative ^= 1;
          return res;
        } else if (num.negative === 0 && this.negative !== 0) {
          this.negative = 0;
          res = num.sub(this);
          this.negative = 1;
          return res;
        }
        if (this.length > num.length)
          return this.clone().iadd(num);
        return num.clone().iadd(this);
      };
      BN23.prototype.isub = function isub(num) {
        if (num.negative !== 0) {
          num.negative = 0;
          var r = this.iadd(num);
          num.negative = 1;
          return r._normSign();
        } else if (this.negative !== 0) {
          this.negative = 0;
          this.iadd(num);
          this.negative = 1;
          return this._normSign();
        }
        var cmp = this.cmp(num);
        if (cmp === 0) {
          this.negative = 0;
          this.length = 1;
          this.words[0] = 0;
          return this;
        }
        var a, b;
        if (cmp > 0) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }
        var carry = 0;
        for (var i = 0; i < b.length; i++) {
          r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
          carry = r >> 26;
          this.words[i] = r & 67108863;
        }
        for (; carry !== 0 && i < a.length; i++) {
          r = (a.words[i] | 0) + carry;
          carry = r >> 26;
          this.words[i] = r & 67108863;
        }
        if (carry === 0 && i < a.length && a !== this) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }
        this.length = Math.max(this.length, i);
        if (a !== this) {
          this.negative = 1;
        }
        return this._strip();
      };
      BN23.prototype.sub = function sub2(num) {
        return this.clone().isub(num);
      };
      function smallMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        var len = self2.length + num.length | 0;
        out.length = len;
        len = len - 1 | 0;
        var a = self2.words[0] | 0;
        var b = num.words[0] | 0;
        var r = a * b;
        var lo = r & 67108863;
        var carry = r / 67108864 | 0;
        out.words[0] = lo;
        for (var k = 1; k < len; k++) {
          var ncarry = carry >>> 26;
          var rword = carry & 67108863;
          var maxJ = Math.min(k, num.length - 1);
          for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
            var i = k - j | 0;
            a = self2.words[i] | 0;
            b = num.words[j] | 0;
            r = a * b + rword;
            ncarry += r / 67108864 | 0;
            rword = r & 67108863;
          }
          out.words[k] = rword | 0;
          carry = ncarry | 0;
        }
        if (carry !== 0) {
          out.words[k] = carry | 0;
        } else {
          out.length--;
        }
        return out._strip();
      }
      var comb10MulTo = function comb10MulTo2(self2, num, out) {
        var a = self2.words;
        var b = num.words;
        var o = out.words;
        var c = 0;
        var lo;
        var mid;
        var hi;
        var a0 = a[0] | 0;
        var al0 = a0 & 8191;
        var ah0 = a0 >>> 13;
        var a1 = a[1] | 0;
        var al1 = a1 & 8191;
        var ah1 = a1 >>> 13;
        var a2 = a[2] | 0;
        var al2 = a2 & 8191;
        var ah2 = a2 >>> 13;
        var a3 = a[3] | 0;
        var al3 = a3 & 8191;
        var ah3 = a3 >>> 13;
        var a4 = a[4] | 0;
        var al4 = a4 & 8191;
        var ah4 = a4 >>> 13;
        var a5 = a[5] | 0;
        var al5 = a5 & 8191;
        var ah5 = a5 >>> 13;
        var a6 = a[6] | 0;
        var al6 = a6 & 8191;
        var ah6 = a6 >>> 13;
        var a7 = a[7] | 0;
        var al7 = a7 & 8191;
        var ah7 = a7 >>> 13;
        var a8 = a[8] | 0;
        var al8 = a8 & 8191;
        var ah8 = a8 >>> 13;
        var a9 = a[9] | 0;
        var al9 = a9 & 8191;
        var ah9 = a9 >>> 13;
        var b0 = b[0] | 0;
        var bl0 = b0 & 8191;
        var bh0 = b0 >>> 13;
        var b1 = b[1] | 0;
        var bl1 = b1 & 8191;
        var bh1 = b1 >>> 13;
        var b2 = b[2] | 0;
        var bl2 = b2 & 8191;
        var bh2 = b2 >>> 13;
        var b3 = b[3] | 0;
        var bl3 = b3 & 8191;
        var bh3 = b3 >>> 13;
        var b4 = b[4] | 0;
        var bl4 = b4 & 8191;
        var bh4 = b4 >>> 13;
        var b5 = b[5] | 0;
        var bl5 = b5 & 8191;
        var bh5 = b5 >>> 13;
        var b6 = b[6] | 0;
        var bl6 = b6 & 8191;
        var bh6 = b6 >>> 13;
        var b7 = b[7] | 0;
        var bl7 = b7 & 8191;
        var bh7 = b7 >>> 13;
        var b8 = b[8] | 0;
        var bl8 = b8 & 8191;
        var bh8 = b8 >>> 13;
        var b9 = b[9] | 0;
        var bl9 = b9 & 8191;
        var bh9 = b9 >>> 13;
        out.negative = self2.negative ^ num.negative;
        out.length = 19;
        lo = Math.imul(al0, bl0);
        mid = Math.imul(al0, bh0);
        mid = mid + Math.imul(ah0, bl0) | 0;
        hi = Math.imul(ah0, bh0);
        var w0 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
        w0 &= 67108863;
        lo = Math.imul(al1, bl0);
        mid = Math.imul(al1, bh0);
        mid = mid + Math.imul(ah1, bl0) | 0;
        hi = Math.imul(ah1, bh0);
        lo = lo + Math.imul(al0, bl1) | 0;
        mid = mid + Math.imul(al0, bh1) | 0;
        mid = mid + Math.imul(ah0, bl1) | 0;
        hi = hi + Math.imul(ah0, bh1) | 0;
        var w1 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
        w1 &= 67108863;
        lo = Math.imul(al2, bl0);
        mid = Math.imul(al2, bh0);
        mid = mid + Math.imul(ah2, bl0) | 0;
        hi = Math.imul(ah2, bh0);
        lo = lo + Math.imul(al1, bl1) | 0;
        mid = mid + Math.imul(al1, bh1) | 0;
        mid = mid + Math.imul(ah1, bl1) | 0;
        hi = hi + Math.imul(ah1, bh1) | 0;
        lo = lo + Math.imul(al0, bl2) | 0;
        mid = mid + Math.imul(al0, bh2) | 0;
        mid = mid + Math.imul(ah0, bl2) | 0;
        hi = hi + Math.imul(ah0, bh2) | 0;
        var w2 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
        w2 &= 67108863;
        lo = Math.imul(al3, bl0);
        mid = Math.imul(al3, bh0);
        mid = mid + Math.imul(ah3, bl0) | 0;
        hi = Math.imul(ah3, bh0);
        lo = lo + Math.imul(al2, bl1) | 0;
        mid = mid + Math.imul(al2, bh1) | 0;
        mid = mid + Math.imul(ah2, bl1) | 0;
        hi = hi + Math.imul(ah2, bh1) | 0;
        lo = lo + Math.imul(al1, bl2) | 0;
        mid = mid + Math.imul(al1, bh2) | 0;
        mid = mid + Math.imul(ah1, bl2) | 0;
        hi = hi + Math.imul(ah1, bh2) | 0;
        lo = lo + Math.imul(al0, bl3) | 0;
        mid = mid + Math.imul(al0, bh3) | 0;
        mid = mid + Math.imul(ah0, bl3) | 0;
        hi = hi + Math.imul(ah0, bh3) | 0;
        var w3 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
        w3 &= 67108863;
        lo = Math.imul(al4, bl0);
        mid = Math.imul(al4, bh0);
        mid = mid + Math.imul(ah4, bl0) | 0;
        hi = Math.imul(ah4, bh0);
        lo = lo + Math.imul(al3, bl1) | 0;
        mid = mid + Math.imul(al3, bh1) | 0;
        mid = mid + Math.imul(ah3, bl1) | 0;
        hi = hi + Math.imul(ah3, bh1) | 0;
        lo = lo + Math.imul(al2, bl2) | 0;
        mid = mid + Math.imul(al2, bh2) | 0;
        mid = mid + Math.imul(ah2, bl2) | 0;
        hi = hi + Math.imul(ah2, bh2) | 0;
        lo = lo + Math.imul(al1, bl3) | 0;
        mid = mid + Math.imul(al1, bh3) | 0;
        mid = mid + Math.imul(ah1, bl3) | 0;
        hi = hi + Math.imul(ah1, bh3) | 0;
        lo = lo + Math.imul(al0, bl4) | 0;
        mid = mid + Math.imul(al0, bh4) | 0;
        mid = mid + Math.imul(ah0, bl4) | 0;
        hi = hi + Math.imul(ah0, bh4) | 0;
        var w4 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
        w4 &= 67108863;
        lo = Math.imul(al5, bl0);
        mid = Math.imul(al5, bh0);
        mid = mid + Math.imul(ah5, bl0) | 0;
        hi = Math.imul(ah5, bh0);
        lo = lo + Math.imul(al4, bl1) | 0;
        mid = mid + Math.imul(al4, bh1) | 0;
        mid = mid + Math.imul(ah4, bl1) | 0;
        hi = hi + Math.imul(ah4, bh1) | 0;
        lo = lo + Math.imul(al3, bl2) | 0;
        mid = mid + Math.imul(al3, bh2) | 0;
        mid = mid + Math.imul(ah3, bl2) | 0;
        hi = hi + Math.imul(ah3, bh2) | 0;
        lo = lo + Math.imul(al2, bl3) | 0;
        mid = mid + Math.imul(al2, bh3) | 0;
        mid = mid + Math.imul(ah2, bl3) | 0;
        hi = hi + Math.imul(ah2, bh3) | 0;
        lo = lo + Math.imul(al1, bl4) | 0;
        mid = mid + Math.imul(al1, bh4) | 0;
        mid = mid + Math.imul(ah1, bl4) | 0;
        hi = hi + Math.imul(ah1, bh4) | 0;
        lo = lo + Math.imul(al0, bl5) | 0;
        mid = mid + Math.imul(al0, bh5) | 0;
        mid = mid + Math.imul(ah0, bl5) | 0;
        hi = hi + Math.imul(ah0, bh5) | 0;
        var w5 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
        w5 &= 67108863;
        lo = Math.imul(al6, bl0);
        mid = Math.imul(al6, bh0);
        mid = mid + Math.imul(ah6, bl0) | 0;
        hi = Math.imul(ah6, bh0);
        lo = lo + Math.imul(al5, bl1) | 0;
        mid = mid + Math.imul(al5, bh1) | 0;
        mid = mid + Math.imul(ah5, bl1) | 0;
        hi = hi + Math.imul(ah5, bh1) | 0;
        lo = lo + Math.imul(al4, bl2) | 0;
        mid = mid + Math.imul(al4, bh2) | 0;
        mid = mid + Math.imul(ah4, bl2) | 0;
        hi = hi + Math.imul(ah4, bh2) | 0;
        lo = lo + Math.imul(al3, bl3) | 0;
        mid = mid + Math.imul(al3, bh3) | 0;
        mid = mid + Math.imul(ah3, bl3) | 0;
        hi = hi + Math.imul(ah3, bh3) | 0;
        lo = lo + Math.imul(al2, bl4) | 0;
        mid = mid + Math.imul(al2, bh4) | 0;
        mid = mid + Math.imul(ah2, bl4) | 0;
        hi = hi + Math.imul(ah2, bh4) | 0;
        lo = lo + Math.imul(al1, bl5) | 0;
        mid = mid + Math.imul(al1, bh5) | 0;
        mid = mid + Math.imul(ah1, bl5) | 0;
        hi = hi + Math.imul(ah1, bh5) | 0;
        lo = lo + Math.imul(al0, bl6) | 0;
        mid = mid + Math.imul(al0, bh6) | 0;
        mid = mid + Math.imul(ah0, bl6) | 0;
        hi = hi + Math.imul(ah0, bh6) | 0;
        var w6 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
        w6 &= 67108863;
        lo = Math.imul(al7, bl0);
        mid = Math.imul(al7, bh0);
        mid = mid + Math.imul(ah7, bl0) | 0;
        hi = Math.imul(ah7, bh0);
        lo = lo + Math.imul(al6, bl1) | 0;
        mid = mid + Math.imul(al6, bh1) | 0;
        mid = mid + Math.imul(ah6, bl1) | 0;
        hi = hi + Math.imul(ah6, bh1) | 0;
        lo = lo + Math.imul(al5, bl2) | 0;
        mid = mid + Math.imul(al5, bh2) | 0;
        mid = mid + Math.imul(ah5, bl2) | 0;
        hi = hi + Math.imul(ah5, bh2) | 0;
        lo = lo + Math.imul(al4, bl3) | 0;
        mid = mid + Math.imul(al4, bh3) | 0;
        mid = mid + Math.imul(ah4, bl3) | 0;
        hi = hi + Math.imul(ah4, bh3) | 0;
        lo = lo + Math.imul(al3, bl4) | 0;
        mid = mid + Math.imul(al3, bh4) | 0;
        mid = mid + Math.imul(ah3, bl4) | 0;
        hi = hi + Math.imul(ah3, bh4) | 0;
        lo = lo + Math.imul(al2, bl5) | 0;
        mid = mid + Math.imul(al2, bh5) | 0;
        mid = mid + Math.imul(ah2, bl5) | 0;
        hi = hi + Math.imul(ah2, bh5) | 0;
        lo = lo + Math.imul(al1, bl6) | 0;
        mid = mid + Math.imul(al1, bh6) | 0;
        mid = mid + Math.imul(ah1, bl6) | 0;
        hi = hi + Math.imul(ah1, bh6) | 0;
        lo = lo + Math.imul(al0, bl7) | 0;
        mid = mid + Math.imul(al0, bh7) | 0;
        mid = mid + Math.imul(ah0, bl7) | 0;
        hi = hi + Math.imul(ah0, bh7) | 0;
        var w7 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
        w7 &= 67108863;
        lo = Math.imul(al8, bl0);
        mid = Math.imul(al8, bh0);
        mid = mid + Math.imul(ah8, bl0) | 0;
        hi = Math.imul(ah8, bh0);
        lo = lo + Math.imul(al7, bl1) | 0;
        mid = mid + Math.imul(al7, bh1) | 0;
        mid = mid + Math.imul(ah7, bl1) | 0;
        hi = hi + Math.imul(ah7, bh1) | 0;
        lo = lo + Math.imul(al6, bl2) | 0;
        mid = mid + Math.imul(al6, bh2) | 0;
        mid = mid + Math.imul(ah6, bl2) | 0;
        hi = hi + Math.imul(ah6, bh2) | 0;
        lo = lo + Math.imul(al5, bl3) | 0;
        mid = mid + Math.imul(al5, bh3) | 0;
        mid = mid + Math.imul(ah5, bl3) | 0;
        hi = hi + Math.imul(ah5, bh3) | 0;
        lo = lo + Math.imul(al4, bl4) | 0;
        mid = mid + Math.imul(al4, bh4) | 0;
        mid = mid + Math.imul(ah4, bl4) | 0;
        hi = hi + Math.imul(ah4, bh4) | 0;
        lo = lo + Math.imul(al3, bl5) | 0;
        mid = mid + Math.imul(al3, bh5) | 0;
        mid = mid + Math.imul(ah3, bl5) | 0;
        hi = hi + Math.imul(ah3, bh5) | 0;
        lo = lo + Math.imul(al2, bl6) | 0;
        mid = mid + Math.imul(al2, bh6) | 0;
        mid = mid + Math.imul(ah2, bl6) | 0;
        hi = hi + Math.imul(ah2, bh6) | 0;
        lo = lo + Math.imul(al1, bl7) | 0;
        mid = mid + Math.imul(al1, bh7) | 0;
        mid = mid + Math.imul(ah1, bl7) | 0;
        hi = hi + Math.imul(ah1, bh7) | 0;
        lo = lo + Math.imul(al0, bl8) | 0;
        mid = mid + Math.imul(al0, bh8) | 0;
        mid = mid + Math.imul(ah0, bl8) | 0;
        hi = hi + Math.imul(ah0, bh8) | 0;
        var w8 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
        w8 &= 67108863;
        lo = Math.imul(al9, bl0);
        mid = Math.imul(al9, bh0);
        mid = mid + Math.imul(ah9, bl0) | 0;
        hi = Math.imul(ah9, bh0);
        lo = lo + Math.imul(al8, bl1) | 0;
        mid = mid + Math.imul(al8, bh1) | 0;
        mid = mid + Math.imul(ah8, bl1) | 0;
        hi = hi + Math.imul(ah8, bh1) | 0;
        lo = lo + Math.imul(al7, bl2) | 0;
        mid = mid + Math.imul(al7, bh2) | 0;
        mid = mid + Math.imul(ah7, bl2) | 0;
        hi = hi + Math.imul(ah7, bh2) | 0;
        lo = lo + Math.imul(al6, bl3) | 0;
        mid = mid + Math.imul(al6, bh3) | 0;
        mid = mid + Math.imul(ah6, bl3) | 0;
        hi = hi + Math.imul(ah6, bh3) | 0;
        lo = lo + Math.imul(al5, bl4) | 0;
        mid = mid + Math.imul(al5, bh4) | 0;
        mid = mid + Math.imul(ah5, bl4) | 0;
        hi = hi + Math.imul(ah5, bh4) | 0;
        lo = lo + Math.imul(al4, bl5) | 0;
        mid = mid + Math.imul(al4, bh5) | 0;
        mid = mid + Math.imul(ah4, bl5) | 0;
        hi = hi + Math.imul(ah4, bh5) | 0;
        lo = lo + Math.imul(al3, bl6) | 0;
        mid = mid + Math.imul(al3, bh6) | 0;
        mid = mid + Math.imul(ah3, bl6) | 0;
        hi = hi + Math.imul(ah3, bh6) | 0;
        lo = lo + Math.imul(al2, bl7) | 0;
        mid = mid + Math.imul(al2, bh7) | 0;
        mid = mid + Math.imul(ah2, bl7) | 0;
        hi = hi + Math.imul(ah2, bh7) | 0;
        lo = lo + Math.imul(al1, bl8) | 0;
        mid = mid + Math.imul(al1, bh8) | 0;
        mid = mid + Math.imul(ah1, bl8) | 0;
        hi = hi + Math.imul(ah1, bh8) | 0;
        lo = lo + Math.imul(al0, bl9) | 0;
        mid = mid + Math.imul(al0, bh9) | 0;
        mid = mid + Math.imul(ah0, bl9) | 0;
        hi = hi + Math.imul(ah0, bh9) | 0;
        var w9 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
        w9 &= 67108863;
        lo = Math.imul(al9, bl1);
        mid = Math.imul(al9, bh1);
        mid = mid + Math.imul(ah9, bl1) | 0;
        hi = Math.imul(ah9, bh1);
        lo = lo + Math.imul(al8, bl2) | 0;
        mid = mid + Math.imul(al8, bh2) | 0;
        mid = mid + Math.imul(ah8, bl2) | 0;
        hi = hi + Math.imul(ah8, bh2) | 0;
        lo = lo + Math.imul(al7, bl3) | 0;
        mid = mid + Math.imul(al7, bh3) | 0;
        mid = mid + Math.imul(ah7, bl3) | 0;
        hi = hi + Math.imul(ah7, bh3) | 0;
        lo = lo + Math.imul(al6, bl4) | 0;
        mid = mid + Math.imul(al6, bh4) | 0;
        mid = mid + Math.imul(ah6, bl4) | 0;
        hi = hi + Math.imul(ah6, bh4) | 0;
        lo = lo + Math.imul(al5, bl5) | 0;
        mid = mid + Math.imul(al5, bh5) | 0;
        mid = mid + Math.imul(ah5, bl5) | 0;
        hi = hi + Math.imul(ah5, bh5) | 0;
        lo = lo + Math.imul(al4, bl6) | 0;
        mid = mid + Math.imul(al4, bh6) | 0;
        mid = mid + Math.imul(ah4, bl6) | 0;
        hi = hi + Math.imul(ah4, bh6) | 0;
        lo = lo + Math.imul(al3, bl7) | 0;
        mid = mid + Math.imul(al3, bh7) | 0;
        mid = mid + Math.imul(ah3, bl7) | 0;
        hi = hi + Math.imul(ah3, bh7) | 0;
        lo = lo + Math.imul(al2, bl8) | 0;
        mid = mid + Math.imul(al2, bh8) | 0;
        mid = mid + Math.imul(ah2, bl8) | 0;
        hi = hi + Math.imul(ah2, bh8) | 0;
        lo = lo + Math.imul(al1, bl9) | 0;
        mid = mid + Math.imul(al1, bh9) | 0;
        mid = mid + Math.imul(ah1, bl9) | 0;
        hi = hi + Math.imul(ah1, bh9) | 0;
        var w10 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
        w10 &= 67108863;
        lo = Math.imul(al9, bl2);
        mid = Math.imul(al9, bh2);
        mid = mid + Math.imul(ah9, bl2) | 0;
        hi = Math.imul(ah9, bh2);
        lo = lo + Math.imul(al8, bl3) | 0;
        mid = mid + Math.imul(al8, bh3) | 0;
        mid = mid + Math.imul(ah8, bl3) | 0;
        hi = hi + Math.imul(ah8, bh3) | 0;
        lo = lo + Math.imul(al7, bl4) | 0;
        mid = mid + Math.imul(al7, bh4) | 0;
        mid = mid + Math.imul(ah7, bl4) | 0;
        hi = hi + Math.imul(ah7, bh4) | 0;
        lo = lo + Math.imul(al6, bl5) | 0;
        mid = mid + Math.imul(al6, bh5) | 0;
        mid = mid + Math.imul(ah6, bl5) | 0;
        hi = hi + Math.imul(ah6, bh5) | 0;
        lo = lo + Math.imul(al5, bl6) | 0;
        mid = mid + Math.imul(al5, bh6) | 0;
        mid = mid + Math.imul(ah5, bl6) | 0;
        hi = hi + Math.imul(ah5, bh6) | 0;
        lo = lo + Math.imul(al4, bl7) | 0;
        mid = mid + Math.imul(al4, bh7) | 0;
        mid = mid + Math.imul(ah4, bl7) | 0;
        hi = hi + Math.imul(ah4, bh7) | 0;
        lo = lo + Math.imul(al3, bl8) | 0;
        mid = mid + Math.imul(al3, bh8) | 0;
        mid = mid + Math.imul(ah3, bl8) | 0;
        hi = hi + Math.imul(ah3, bh8) | 0;
        lo = lo + Math.imul(al2, bl9) | 0;
        mid = mid + Math.imul(al2, bh9) | 0;
        mid = mid + Math.imul(ah2, bl9) | 0;
        hi = hi + Math.imul(ah2, bh9) | 0;
        var w11 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
        w11 &= 67108863;
        lo = Math.imul(al9, bl3);
        mid = Math.imul(al9, bh3);
        mid = mid + Math.imul(ah9, bl3) | 0;
        hi = Math.imul(ah9, bh3);
        lo = lo + Math.imul(al8, bl4) | 0;
        mid = mid + Math.imul(al8, bh4) | 0;
        mid = mid + Math.imul(ah8, bl4) | 0;
        hi = hi + Math.imul(ah8, bh4) | 0;
        lo = lo + Math.imul(al7, bl5) | 0;
        mid = mid + Math.imul(al7, bh5) | 0;
        mid = mid + Math.imul(ah7, bl5) | 0;
        hi = hi + Math.imul(ah7, bh5) | 0;
        lo = lo + Math.imul(al6, bl6) | 0;
        mid = mid + Math.imul(al6, bh6) | 0;
        mid = mid + Math.imul(ah6, bl6) | 0;
        hi = hi + Math.imul(ah6, bh6) | 0;
        lo = lo + Math.imul(al5, bl7) | 0;
        mid = mid + Math.imul(al5, bh7) | 0;
        mid = mid + Math.imul(ah5, bl7) | 0;
        hi = hi + Math.imul(ah5, bh7) | 0;
        lo = lo + Math.imul(al4, bl8) | 0;
        mid = mid + Math.imul(al4, bh8) | 0;
        mid = mid + Math.imul(ah4, bl8) | 0;
        hi = hi + Math.imul(ah4, bh8) | 0;
        lo = lo + Math.imul(al3, bl9) | 0;
        mid = mid + Math.imul(al3, bh9) | 0;
        mid = mid + Math.imul(ah3, bl9) | 0;
        hi = hi + Math.imul(ah3, bh9) | 0;
        var w12 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
        w12 &= 67108863;
        lo = Math.imul(al9, bl4);
        mid = Math.imul(al9, bh4);
        mid = mid + Math.imul(ah9, bl4) | 0;
        hi = Math.imul(ah9, bh4);
        lo = lo + Math.imul(al8, bl5) | 0;
        mid = mid + Math.imul(al8, bh5) | 0;
        mid = mid + Math.imul(ah8, bl5) | 0;
        hi = hi + Math.imul(ah8, bh5) | 0;
        lo = lo + Math.imul(al7, bl6) | 0;
        mid = mid + Math.imul(al7, bh6) | 0;
        mid = mid + Math.imul(ah7, bl6) | 0;
        hi = hi + Math.imul(ah7, bh6) | 0;
        lo = lo + Math.imul(al6, bl7) | 0;
        mid = mid + Math.imul(al6, bh7) | 0;
        mid = mid + Math.imul(ah6, bl7) | 0;
        hi = hi + Math.imul(ah6, bh7) | 0;
        lo = lo + Math.imul(al5, bl8) | 0;
        mid = mid + Math.imul(al5, bh8) | 0;
        mid = mid + Math.imul(ah5, bl8) | 0;
        hi = hi + Math.imul(ah5, bh8) | 0;
        lo = lo + Math.imul(al4, bl9) | 0;
        mid = mid + Math.imul(al4, bh9) | 0;
        mid = mid + Math.imul(ah4, bl9) | 0;
        hi = hi + Math.imul(ah4, bh9) | 0;
        var w13 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
        w13 &= 67108863;
        lo = Math.imul(al9, bl5);
        mid = Math.imul(al9, bh5);
        mid = mid + Math.imul(ah9, bl5) | 0;
        hi = Math.imul(ah9, bh5);
        lo = lo + Math.imul(al8, bl6) | 0;
        mid = mid + Math.imul(al8, bh6) | 0;
        mid = mid + Math.imul(ah8, bl6) | 0;
        hi = hi + Math.imul(ah8, bh6) | 0;
        lo = lo + Math.imul(al7, bl7) | 0;
        mid = mid + Math.imul(al7, bh7) | 0;
        mid = mid + Math.imul(ah7, bl7) | 0;
        hi = hi + Math.imul(ah7, bh7) | 0;
        lo = lo + Math.imul(al6, bl8) | 0;
        mid = mid + Math.imul(al6, bh8) | 0;
        mid = mid + Math.imul(ah6, bl8) | 0;
        hi = hi + Math.imul(ah6, bh8) | 0;
        lo = lo + Math.imul(al5, bl9) | 0;
        mid = mid + Math.imul(al5, bh9) | 0;
        mid = mid + Math.imul(ah5, bl9) | 0;
        hi = hi + Math.imul(ah5, bh9) | 0;
        var w14 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
        w14 &= 67108863;
        lo = Math.imul(al9, bl6);
        mid = Math.imul(al9, bh6);
        mid = mid + Math.imul(ah9, bl6) | 0;
        hi = Math.imul(ah9, bh6);
        lo = lo + Math.imul(al8, bl7) | 0;
        mid = mid + Math.imul(al8, bh7) | 0;
        mid = mid + Math.imul(ah8, bl7) | 0;
        hi = hi + Math.imul(ah8, bh7) | 0;
        lo = lo + Math.imul(al7, bl8) | 0;
        mid = mid + Math.imul(al7, bh8) | 0;
        mid = mid + Math.imul(ah7, bl8) | 0;
        hi = hi + Math.imul(ah7, bh8) | 0;
        lo = lo + Math.imul(al6, bl9) | 0;
        mid = mid + Math.imul(al6, bh9) | 0;
        mid = mid + Math.imul(ah6, bl9) | 0;
        hi = hi + Math.imul(ah6, bh9) | 0;
        var w15 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
        w15 &= 67108863;
        lo = Math.imul(al9, bl7);
        mid = Math.imul(al9, bh7);
        mid = mid + Math.imul(ah9, bl7) | 0;
        hi = Math.imul(ah9, bh7);
        lo = lo + Math.imul(al8, bl8) | 0;
        mid = mid + Math.imul(al8, bh8) | 0;
        mid = mid + Math.imul(ah8, bl8) | 0;
        hi = hi + Math.imul(ah8, bh8) | 0;
        lo = lo + Math.imul(al7, bl9) | 0;
        mid = mid + Math.imul(al7, bh9) | 0;
        mid = mid + Math.imul(ah7, bl9) | 0;
        hi = hi + Math.imul(ah7, bh9) | 0;
        var w16 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
        w16 &= 67108863;
        lo = Math.imul(al9, bl8);
        mid = Math.imul(al9, bh8);
        mid = mid + Math.imul(ah9, bl8) | 0;
        hi = Math.imul(ah9, bh8);
        lo = lo + Math.imul(al8, bl9) | 0;
        mid = mid + Math.imul(al8, bh9) | 0;
        mid = mid + Math.imul(ah8, bl9) | 0;
        hi = hi + Math.imul(ah8, bh9) | 0;
        var w17 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
        w17 &= 67108863;
        lo = Math.imul(al9, bl9);
        mid = Math.imul(al9, bh9);
        mid = mid + Math.imul(ah9, bl9) | 0;
        hi = Math.imul(ah9, bh9);
        var w18 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
        w18 &= 67108863;
        o[0] = w0;
        o[1] = w1;
        o[2] = w2;
        o[3] = w3;
        o[4] = w4;
        o[5] = w5;
        o[6] = w6;
        o[7] = w7;
        o[8] = w8;
        o[9] = w9;
        o[10] = w10;
        o[11] = w11;
        o[12] = w12;
        o[13] = w13;
        o[14] = w14;
        o[15] = w15;
        o[16] = w16;
        o[17] = w17;
        o[18] = w18;
        if (c !== 0) {
          o[19] = c;
          out.length++;
        }
        return out;
      };
      if (!Math.imul) {
        comb10MulTo = smallMulTo;
      }
      function bigMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        out.length = self2.length + num.length;
        var carry = 0;
        var hncarry = 0;
        for (var k = 0; k < out.length - 1; k++) {
          var ncarry = hncarry;
          hncarry = 0;
          var rword = carry & 67108863;
          var maxJ = Math.min(k, num.length - 1);
          for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
            var i = k - j;
            var a = self2.words[i] | 0;
            var b = num.words[j] | 0;
            var r = a * b;
            var lo = r & 67108863;
            ncarry = ncarry + (r / 67108864 | 0) | 0;
            lo = lo + rword | 0;
            rword = lo & 67108863;
            ncarry = ncarry + (lo >>> 26) | 0;
            hncarry += ncarry >>> 26;
            ncarry &= 67108863;
          }
          out.words[k] = rword;
          carry = ncarry;
          ncarry = hncarry;
        }
        if (carry !== 0) {
          out.words[k] = carry;
        } else {
          out.length--;
        }
        return out._strip();
      }
      function jumboMulTo(self2, num, out) {
        return bigMulTo(self2, num, out);
      }
      BN23.prototype.mulTo = function mulTo(num, out) {
        var res;
        var len = this.length + num.length;
        if (this.length === 10 && num.length === 10) {
          res = comb10MulTo(this, num, out);
        } else if (len < 63) {
          res = smallMulTo(this, num, out);
        } else if (len < 1024) {
          res = bigMulTo(this, num, out);
        } else {
          res = jumboMulTo(this, num, out);
        }
        return res;
      };
      function FFTM(x, y) {
        this.x = x;
        this.y = y;
      }
      FFTM.prototype.makeRBT = function makeRBT(N) {
        var t = new Array(N);
        var l = BN23.prototype._countBits(N) - 1;
        for (var i = 0; i < N; i++) {
          t[i] = this.revBin(i, l, N);
        }
        return t;
      };
      FFTM.prototype.revBin = function revBin(x, l, N) {
        if (x === 0 || x === N - 1)
          return x;
        var rb = 0;
        for (var i = 0; i < l; i++) {
          rb |= (x & 1) << l - i - 1;
          x >>= 1;
        }
        return rb;
      };
      FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N) {
        for (var i = 0; i < N; i++) {
          rtws[i] = rws[rbt[i]];
          itws[i] = iws[rbt[i]];
        }
      };
      FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N, rbt) {
        this.permute(rbt, rws, iws, rtws, itws, N);
        for (var s = 1; s < N; s <<= 1) {
          var l = s << 1;
          var rtwdf = Math.cos(2 * Math.PI / l);
          var itwdf = Math.sin(2 * Math.PI / l);
          for (var p = 0; p < N; p += l) {
            var rtwdf_ = rtwdf;
            var itwdf_ = itwdf;
            for (var j = 0; j < s; j++) {
              var re = rtws[p + j];
              var ie = itws[p + j];
              var ro = rtws[p + j + s];
              var io = itws[p + j + s];
              var rx = rtwdf_ * ro - itwdf_ * io;
              io = rtwdf_ * io + itwdf_ * ro;
              ro = rx;
              rtws[p + j] = re + ro;
              itws[p + j] = ie + io;
              rtws[p + j + s] = re - ro;
              itws[p + j + s] = ie - io;
              if (j !== l) {
                rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                rtwdf_ = rx;
              }
            }
          }
        }
      };
      FFTM.prototype.guessLen13b = function guessLen13b(n, m) {
        var N = Math.max(m, n) | 1;
        var odd = N & 1;
        var i = 0;
        for (N = N / 2 | 0; N; N = N >>> 1) {
          i++;
        }
        return 1 << i + 1 + odd;
      };
      FFTM.prototype.conjugate = function conjugate(rws, iws, N) {
        if (N <= 1)
          return;
        for (var i = 0; i < N / 2; i++) {
          var t = rws[i];
          rws[i] = rws[N - i - 1];
          rws[N - i - 1] = t;
          t = iws[i];
          iws[i] = -iws[N - i - 1];
          iws[N - i - 1] = -t;
        }
      };
      FFTM.prototype.normalize13b = function normalize13b(ws, N) {
        var carry = 0;
        for (var i = 0; i < N / 2; i++) {
          var w = Math.round(ws[2 * i + 1] / N) * 8192 + Math.round(ws[2 * i] / N) + carry;
          ws[i] = w & 67108863;
          if (w < 67108864) {
            carry = 0;
          } else {
            carry = w / 67108864 | 0;
          }
        }
        return ws;
      };
      FFTM.prototype.convert13b = function convert13b(ws, len, rws, N) {
        var carry = 0;
        for (var i = 0; i < len; i++) {
          carry = carry + (ws[i] | 0);
          rws[2 * i] = carry & 8191;
          carry = carry >>> 13;
          rws[2 * i + 1] = carry & 8191;
          carry = carry >>> 13;
        }
        for (i = 2 * len; i < N; ++i) {
          rws[i] = 0;
        }
        assert(carry === 0);
        assert((carry & ~8191) === 0);
      };
      FFTM.prototype.stub = function stub(N) {
        var ph = new Array(N);
        for (var i = 0; i < N; i++) {
          ph[i] = 0;
        }
        return ph;
      };
      FFTM.prototype.mulp = function mulp(x, y, out) {
        var N = 2 * this.guessLen13b(x.length, y.length);
        var rbt = this.makeRBT(N);
        var _ = this.stub(N);
        var rws = new Array(N);
        var rwst = new Array(N);
        var iwst = new Array(N);
        var nrws = new Array(N);
        var nrwst = new Array(N);
        var niwst = new Array(N);
        var rmws = out.words;
        rmws.length = N;
        this.convert13b(x.words, x.length, rws, N);
        this.convert13b(y.words, y.length, nrws, N);
        this.transform(rws, _, rwst, iwst, N, rbt);
        this.transform(nrws, _, nrwst, niwst, N, rbt);
        for (var i = 0; i < N; i++) {
          var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
          iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
          rwst[i] = rx;
        }
        this.conjugate(rwst, iwst, N);
        this.transform(rwst, iwst, rmws, _, N, rbt);
        this.conjugate(rmws, _, N);
        this.normalize13b(rmws, N);
        out.negative = x.negative ^ y.negative;
        out.length = x.length + y.length;
        return out._strip();
      };
      BN23.prototype.mul = function mul2(num) {
        var out = new BN23(null);
        out.words = new Array(this.length + num.length);
        return this.mulTo(num, out);
      };
      BN23.prototype.mulf = function mulf(num) {
        var out = new BN23(null);
        out.words = new Array(this.length + num.length);
        return jumboMulTo(this, num, out);
      };
      BN23.prototype.imul = function imul(num) {
        return this.clone().mulTo(num, this);
      };
      BN23.prototype.imuln = function imuln(num) {
        var isNegNum = num < 0;
        if (isNegNum)
          num = -num;
        assert(typeof num === "number");
        assert(num < 67108864);
        var carry = 0;
        for (var i = 0; i < this.length; i++) {
          var w = (this.words[i] | 0) * num;
          var lo = (w & 67108863) + (carry & 67108863);
          carry >>= 26;
          carry += w / 67108864 | 0;
          carry += lo >>> 26;
          this.words[i] = lo & 67108863;
        }
        if (carry !== 0) {
          this.words[i] = carry;
          this.length++;
        }
        this.length = num === 0 ? 1 : this.length;
        return isNegNum ? this.ineg() : this;
      };
      BN23.prototype.muln = function muln(num) {
        return this.clone().imuln(num);
      };
      BN23.prototype.sqr = function sqr() {
        return this.mul(this);
      };
      BN23.prototype.isqr = function isqr() {
        return this.imul(this.clone());
      };
      BN23.prototype.pow = function pow3(num) {
        var w = toBitArray(num);
        if (w.length === 0)
          return new BN23(1);
        var res = this;
        for (var i = 0; i < w.length; i++, res = res.sqr()) {
          if (w[i] !== 0)
            break;
        }
        if (++i < w.length) {
          for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
            if (w[i] === 0)
              continue;
            res = res.mul(q);
          }
        }
        return res;
      };
      BN23.prototype.iushln = function iushln(bits) {
        assert(typeof bits === "number" && bits >= 0);
        var r = bits % 26;
        var s = (bits - r) / 26;
        var carryMask = 67108863 >>> 26 - r << 26 - r;
        var i;
        if (r !== 0) {
          var carry = 0;
          for (i = 0; i < this.length; i++) {
            var newCarry = this.words[i] & carryMask;
            var c = (this.words[i] | 0) - newCarry << r;
            this.words[i] = c | carry;
            carry = newCarry >>> 26 - r;
          }
          if (carry) {
            this.words[i] = carry;
            this.length++;
          }
        }
        if (s !== 0) {
          for (i = this.length - 1; i >= 0; i--) {
            this.words[i + s] = this.words[i];
          }
          for (i = 0; i < s; i++) {
            this.words[i] = 0;
          }
          this.length += s;
        }
        return this._strip();
      };
      BN23.prototype.ishln = function ishln(bits) {
        assert(this.negative === 0);
        return this.iushln(bits);
      };
      BN23.prototype.iushrn = function iushrn(bits, hint, extended) {
        assert(typeof bits === "number" && bits >= 0);
        var h;
        if (hint) {
          h = (hint - hint % 26) / 26;
        } else {
          h = 0;
        }
        var r = bits % 26;
        var s = Math.min((bits - r) / 26, this.length);
        var mask = 67108863 ^ 67108863 >>> r << r;
        var maskedWords = extended;
        h -= s;
        h = Math.max(0, h);
        if (maskedWords) {
          for (var i = 0; i < s; i++) {
            maskedWords.words[i] = this.words[i];
          }
          maskedWords.length = s;
        }
        if (s === 0) {
        } else if (this.length > s) {
          this.length -= s;
          for (i = 0; i < this.length; i++) {
            this.words[i] = this.words[i + s];
          }
        } else {
          this.words[0] = 0;
          this.length = 1;
        }
        var carry = 0;
        for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
          var word = this.words[i] | 0;
          this.words[i] = carry << 26 - r | word >>> r;
          carry = word & mask;
        }
        if (maskedWords && carry !== 0) {
          maskedWords.words[maskedWords.length++] = carry;
        }
        if (this.length === 0) {
          this.words[0] = 0;
          this.length = 1;
        }
        return this._strip();
      };
      BN23.prototype.ishrn = function ishrn(bits, hint, extended) {
        assert(this.negative === 0);
        return this.iushrn(bits, hint, extended);
      };
      BN23.prototype.shln = function shln(bits) {
        return this.clone().ishln(bits);
      };
      BN23.prototype.ushln = function ushln(bits) {
        return this.clone().iushln(bits);
      };
      BN23.prototype.shrn = function shrn(bits) {
        return this.clone().ishrn(bits);
      };
      BN23.prototype.ushrn = function ushrn(bits) {
        return this.clone().iushrn(bits);
      };
      BN23.prototype.testn = function testn(bit) {
        assert(typeof bit === "number" && bit >= 0);
        var r = bit % 26;
        var s = (bit - r) / 26;
        var q = 1 << r;
        if (this.length <= s)
          return false;
        var w = this.words[s];
        return !!(w & q);
      };
      BN23.prototype.imaskn = function imaskn(bits) {
        assert(typeof bits === "number" && bits >= 0);
        var r = bits % 26;
        var s = (bits - r) / 26;
        assert(this.negative === 0, "imaskn works only with positive numbers");
        if (this.length <= s) {
          return this;
        }
        if (r !== 0) {
          s++;
        }
        this.length = Math.min(s, this.length);
        if (r !== 0) {
          var mask = 67108863 ^ 67108863 >>> r << r;
          this.words[this.length - 1] &= mask;
        }
        return this._strip();
      };
      BN23.prototype.maskn = function maskn(bits) {
        return this.clone().imaskn(bits);
      };
      BN23.prototype.iaddn = function iaddn(num) {
        assert(typeof num === "number");
        assert(num < 67108864);
        if (num < 0)
          return this.isubn(-num);
        if (this.negative !== 0) {
          if (this.length === 1 && (this.words[0] | 0) <= num) {
            this.words[0] = num - (this.words[0] | 0);
            this.negative = 0;
            return this;
          }
          this.negative = 0;
          this.isubn(num);
          this.negative = 1;
          return this;
        }
        return this._iaddn(num);
      };
      BN23.prototype._iaddn = function _iaddn(num) {
        this.words[0] += num;
        for (var i = 0; i < this.length && this.words[i] >= 67108864; i++) {
          this.words[i] -= 67108864;
          if (i === this.length - 1) {
            this.words[i + 1] = 1;
          } else {
            this.words[i + 1]++;
          }
        }
        this.length = Math.max(this.length, i + 1);
        return this;
      };
      BN23.prototype.isubn = function isubn(num) {
        assert(typeof num === "number");
        assert(num < 67108864);
        if (num < 0)
          return this.iaddn(-num);
        if (this.negative !== 0) {
          this.negative = 0;
          this.iaddn(num);
          this.negative = 1;
          return this;
        }
        this.words[0] -= num;
        if (this.length === 1 && this.words[0] < 0) {
          this.words[0] = -this.words[0];
          this.negative = 1;
        } else {
          for (var i = 0; i < this.length && this.words[i] < 0; i++) {
            this.words[i] += 67108864;
            this.words[i + 1] -= 1;
          }
        }
        return this._strip();
      };
      BN23.prototype.addn = function addn(num) {
        return this.clone().iaddn(num);
      };
      BN23.prototype.subn = function subn(num) {
        return this.clone().isubn(num);
      };
      BN23.prototype.iabs = function iabs() {
        this.negative = 0;
        return this;
      };
      BN23.prototype.abs = function abs2() {
        return this.clone().iabs();
      };
      BN23.prototype._ishlnsubmul = function _ishlnsubmul(num, mul2, shift) {
        var len = num.length + shift;
        var i;
        this._expand(len);
        var w;
        var carry = 0;
        for (i = 0; i < num.length; i++) {
          w = (this.words[i + shift] | 0) + carry;
          var right = (num.words[i] | 0) * mul2;
          w -= right & 67108863;
          carry = (w >> 26) - (right / 67108864 | 0);
          this.words[i + shift] = w & 67108863;
        }
        for (; i < this.length - shift; i++) {
          w = (this.words[i + shift] | 0) + carry;
          carry = w >> 26;
          this.words[i + shift] = w & 67108863;
        }
        if (carry === 0)
          return this._strip();
        assert(carry === -1);
        carry = 0;
        for (i = 0; i < this.length; i++) {
          w = -(this.words[i] | 0) + carry;
          carry = w >> 26;
          this.words[i] = w & 67108863;
        }
        this.negative = 1;
        return this._strip();
      };
      BN23.prototype._wordDiv = function _wordDiv(num, mode) {
        var shift = this.length - num.length;
        var a = this.clone();
        var b = num;
        var bhi = b.words[b.length - 1] | 0;
        var bhiBits = this._countBits(bhi);
        shift = 26 - bhiBits;
        if (shift !== 0) {
          b = b.ushln(shift);
          a.iushln(shift);
          bhi = b.words[b.length - 1] | 0;
        }
        var m = a.length - b.length;
        var q;
        if (mode !== "mod") {
          q = new BN23(null);
          q.length = m + 1;
          q.words = new Array(q.length);
          for (var i = 0; i < q.length; i++) {
            q.words[i] = 0;
          }
        }
        var diff = a.clone()._ishlnsubmul(b, 1, m);
        if (diff.negative === 0) {
          a = diff;
          if (q) {
            q.words[m] = 1;
          }
        }
        for (var j = m - 1; j >= 0; j--) {
          var qj = (a.words[b.length + j] | 0) * 67108864 + (a.words[b.length + j - 1] | 0);
          qj = Math.min(qj / bhi | 0, 67108863);
          a._ishlnsubmul(b, qj, j);
          while (a.negative !== 0) {
            qj--;
            a.negative = 0;
            a._ishlnsubmul(b, 1, j);
            if (!a.isZero()) {
              a.negative ^= 1;
            }
          }
          if (q) {
            q.words[j] = qj;
          }
        }
        if (q) {
          q._strip();
        }
        a._strip();
        if (mode !== "div" && shift !== 0) {
          a.iushrn(shift);
        }
        return {
          div: q || null,
          mod: a
        };
      };
      BN23.prototype.divmod = function divmod(num, mode, positive) {
        assert(!num.isZero());
        if (this.isZero()) {
          return {
            div: new BN23(0),
            mod: new BN23(0)
          };
        }
        var div2, mod2, res;
        if (this.negative !== 0 && num.negative === 0) {
          res = this.neg().divmod(num, mode);
          if (mode !== "mod") {
            div2 = res.div.neg();
          }
          if (mode !== "div") {
            mod2 = res.mod.neg();
            if (positive && mod2.negative !== 0) {
              mod2.iadd(num);
            }
          }
          return {
            div: div2,
            mod: mod2
          };
        }
        if (this.negative === 0 && num.negative !== 0) {
          res = this.divmod(num.neg(), mode);
          if (mode !== "mod") {
            div2 = res.div.neg();
          }
          return {
            div: div2,
            mod: res.mod
          };
        }
        if ((this.negative & num.negative) !== 0) {
          res = this.neg().divmod(num.neg(), mode);
          if (mode !== "div") {
            mod2 = res.mod.neg();
            if (positive && mod2.negative !== 0) {
              mod2.isub(num);
            }
          }
          return {
            div: res.div,
            mod: mod2
          };
        }
        if (num.length > this.length || this.cmp(num) < 0) {
          return {
            div: new BN23(0),
            mod: this
          };
        }
        if (num.length === 1) {
          if (mode === "div") {
            return {
              div: this.divn(num.words[0]),
              mod: null
            };
          }
          if (mode === "mod") {
            return {
              div: null,
              mod: new BN23(this.modrn(num.words[0]))
            };
          }
          return {
            div: this.divn(num.words[0]),
            mod: new BN23(this.modrn(num.words[0]))
          };
        }
        return this._wordDiv(num, mode);
      };
      BN23.prototype.div = function div2(num) {
        return this.divmod(num, "div", false).div;
      };
      BN23.prototype.mod = function mod2(num) {
        return this.divmod(num, "mod", false).mod;
      };
      BN23.prototype.umod = function umod(num) {
        return this.divmod(num, "mod", true).mod;
      };
      BN23.prototype.divRound = function divRound(num) {
        var dm = this.divmod(num);
        if (dm.mod.isZero())
          return dm.div;
        var mod2 = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
        var half = num.ushrn(1);
        var r2 = num.andln(1);
        var cmp = mod2.cmp(half);
        if (cmp < 0 || r2 === 1 && cmp === 0)
          return dm.div;
        return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
      };
      BN23.prototype.modrn = function modrn(num) {
        var isNegNum = num < 0;
        if (isNegNum)
          num = -num;
        assert(num <= 67108863);
        var p = (1 << 26) % num;
        var acc = 0;
        for (var i = this.length - 1; i >= 0; i--) {
          acc = (p * acc + (this.words[i] | 0)) % num;
        }
        return isNegNum ? -acc : acc;
      };
      BN23.prototype.modn = function modn(num) {
        return this.modrn(num);
      };
      BN23.prototype.idivn = function idivn(num) {
        var isNegNum = num < 0;
        if (isNegNum)
          num = -num;
        assert(num <= 67108863);
        var carry = 0;
        for (var i = this.length - 1; i >= 0; i--) {
          var w = (this.words[i] | 0) + carry * 67108864;
          this.words[i] = w / num | 0;
          carry = w % num;
        }
        this._strip();
        return isNegNum ? this.ineg() : this;
      };
      BN23.prototype.divn = function divn(num) {
        return this.clone().idivn(num);
      };
      BN23.prototype.egcd = function egcd(p) {
        assert(p.negative === 0);
        assert(!p.isZero());
        var x = this;
        var y = p.clone();
        if (x.negative !== 0) {
          x = x.umod(p);
        } else {
          x = x.clone();
        }
        var A = new BN23(1);
        var B = new BN23(0);
        var C = new BN23(0);
        var D = new BN23(1);
        var g = 0;
        while (x.isEven() && y.isEven()) {
          x.iushrn(1);
          y.iushrn(1);
          ++g;
        }
        var yp = y.clone();
        var xp = x.clone();
        while (!x.isZero()) {
          for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1)
            ;
          if (i > 0) {
            x.iushrn(i);
            while (i-- > 0) {
              if (A.isOdd() || B.isOdd()) {
                A.iadd(yp);
                B.isub(xp);
              }
              A.iushrn(1);
              B.iushrn(1);
            }
          }
          for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
            ;
          if (j > 0) {
            y.iushrn(j);
            while (j-- > 0) {
              if (C.isOdd() || D.isOdd()) {
                C.iadd(yp);
                D.isub(xp);
              }
              C.iushrn(1);
              D.iushrn(1);
            }
          }
          if (x.cmp(y) >= 0) {
            x.isub(y);
            A.isub(C);
            B.isub(D);
          } else {
            y.isub(x);
            C.isub(A);
            D.isub(B);
          }
        }
        return {
          a: C,
          b: D,
          gcd: y.iushln(g)
        };
      };
      BN23.prototype._invmp = function _invmp(p) {
        assert(p.negative === 0);
        assert(!p.isZero());
        var a = this;
        var b = p.clone();
        if (a.negative !== 0) {
          a = a.umod(p);
        } else {
          a = a.clone();
        }
        var x1 = new BN23(1);
        var x2 = new BN23(0);
        var delta = b.clone();
        while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
          for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1)
            ;
          if (i > 0) {
            a.iushrn(i);
            while (i-- > 0) {
              if (x1.isOdd()) {
                x1.iadd(delta);
              }
              x1.iushrn(1);
            }
          }
          for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
            ;
          if (j > 0) {
            b.iushrn(j);
            while (j-- > 0) {
              if (x2.isOdd()) {
                x2.iadd(delta);
              }
              x2.iushrn(1);
            }
          }
          if (a.cmp(b) >= 0) {
            a.isub(b);
            x1.isub(x2);
          } else {
            b.isub(a);
            x2.isub(x1);
          }
        }
        var res;
        if (a.cmpn(1) === 0) {
          res = x1;
        } else {
          res = x2;
        }
        if (res.cmpn(0) < 0) {
          res.iadd(p);
        }
        return res;
      };
      BN23.prototype.gcd = function gcd(num) {
        if (this.isZero())
          return num.abs();
        if (num.isZero())
          return this.abs();
        var a = this.clone();
        var b = num.clone();
        a.negative = 0;
        b.negative = 0;
        for (var shift = 0; a.isEven() && b.isEven(); shift++) {
          a.iushrn(1);
          b.iushrn(1);
        }
        do {
          while (a.isEven()) {
            a.iushrn(1);
          }
          while (b.isEven()) {
            b.iushrn(1);
          }
          var r = a.cmp(b);
          if (r < 0) {
            var t = a;
            a = b;
            b = t;
          } else if (r === 0 || b.cmpn(1) === 0) {
            break;
          }
          a.isub(b);
        } while (true);
        return b.iushln(shift);
      };
      BN23.prototype.invm = function invm(num) {
        return this.egcd(num).a.umod(num);
      };
      BN23.prototype.isEven = function isEven() {
        return (this.words[0] & 1) === 0;
      };
      BN23.prototype.isOdd = function isOdd3() {
        return (this.words[0] & 1) === 1;
      };
      BN23.prototype.andln = function andln(num) {
        return this.words[0] & num;
      };
      BN23.prototype.bincn = function bincn(bit) {
        assert(typeof bit === "number");
        var r = bit % 26;
        var s = (bit - r) / 26;
        var q = 1 << r;
        if (this.length <= s) {
          this._expand(s + 1);
          this.words[s] |= q;
          return this;
        }
        var carry = q;
        for (var i = s; carry !== 0 && i < this.length; i++) {
          var w = this.words[i] | 0;
          w += carry;
          carry = w >>> 26;
          w &= 67108863;
          this.words[i] = w;
        }
        if (carry !== 0) {
          this.words[i] = carry;
          this.length++;
        }
        return this;
      };
      BN23.prototype.isZero = function isZero() {
        return this.length === 1 && this.words[0] === 0;
      };
      BN23.prototype.cmpn = function cmpn(num) {
        var negative = num < 0;
        if (this.negative !== 0 && !negative)
          return -1;
        if (this.negative === 0 && negative)
          return 1;
        this._strip();
        var res;
        if (this.length > 1) {
          res = 1;
        } else {
          if (negative) {
            num = -num;
          }
          assert(num <= 67108863, "Number is too big");
          var w = this.words[0] | 0;
          res = w === num ? 0 : w < num ? -1 : 1;
        }
        if (this.negative !== 0)
          return -res | 0;
        return res;
      };
      BN23.prototype.cmp = function cmp(num) {
        if (this.negative !== 0 && num.negative === 0)
          return -1;
        if (this.negative === 0 && num.negative !== 0)
          return 1;
        var res = this.ucmp(num);
        if (this.negative !== 0)
          return -res | 0;
        return res;
      };
      BN23.prototype.ucmp = function ucmp(num) {
        if (this.length > num.length)
          return 1;
        if (this.length < num.length)
          return -1;
        var res = 0;
        for (var i = this.length - 1; i >= 0; i--) {
          var a = this.words[i] | 0;
          var b = num.words[i] | 0;
          if (a === b)
            continue;
          if (a < b) {
            res = -1;
          } else if (a > b) {
            res = 1;
          }
          break;
        }
        return res;
      };
      BN23.prototype.gtn = function gtn(num) {
        return this.cmpn(num) === 1;
      };
      BN23.prototype.gt = function gt(num) {
        return this.cmp(num) === 1;
      };
      BN23.prototype.gten = function gten(num) {
        return this.cmpn(num) >= 0;
      };
      BN23.prototype.gte = function gte(num) {
        return this.cmp(num) >= 0;
      };
      BN23.prototype.ltn = function ltn(num) {
        return this.cmpn(num) === -1;
      };
      BN23.prototype.lt = function lt(num) {
        return this.cmp(num) === -1;
      };
      BN23.prototype.lten = function lten(num) {
        return this.cmpn(num) <= 0;
      };
      BN23.prototype.lte = function lte(num) {
        return this.cmp(num) <= 0;
      };
      BN23.prototype.eqn = function eqn(num) {
        return this.cmpn(num) === 0;
      };
      BN23.prototype.eq = function eq(num) {
        return this.cmp(num) === 0;
      };
      BN23.red = function red(num) {
        return new Red(num);
      };
      BN23.prototype.toRed = function toRed(ctx) {
        assert(!this.red, "Already a number in reduction context");
        assert(this.negative === 0, "red works only with positives");
        return ctx.convertTo(this)._forceRed(ctx);
      };
      BN23.prototype.fromRed = function fromRed() {
        assert(this.red, "fromRed works only with numbers in reduction context");
        return this.red.convertFrom(this);
      };
      BN23.prototype._forceRed = function _forceRed(ctx) {
        this.red = ctx;
        return this;
      };
      BN23.prototype.forceRed = function forceRed(ctx) {
        assert(!this.red, "Already a number in reduction context");
        return this._forceRed(ctx);
      };
      BN23.prototype.redAdd = function redAdd(num) {
        assert(this.red, "redAdd works only with red numbers");
        return this.red.add(this, num);
      };
      BN23.prototype.redIAdd = function redIAdd(num) {
        assert(this.red, "redIAdd works only with red numbers");
        return this.red.iadd(this, num);
      };
      BN23.prototype.redSub = function redSub(num) {
        assert(this.red, "redSub works only with red numbers");
        return this.red.sub(this, num);
      };
      BN23.prototype.redISub = function redISub(num) {
        assert(this.red, "redISub works only with red numbers");
        return this.red.isub(this, num);
      };
      BN23.prototype.redShl = function redShl(num) {
        assert(this.red, "redShl works only with red numbers");
        return this.red.shl(this, num);
      };
      BN23.prototype.redMul = function redMul(num) {
        assert(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.mul(this, num);
      };
      BN23.prototype.redIMul = function redIMul(num) {
        assert(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.imul(this, num);
      };
      BN23.prototype.redSqr = function redSqr() {
        assert(this.red, "redSqr works only with red numbers");
        this.red._verify1(this);
        return this.red.sqr(this);
      };
      BN23.prototype.redISqr = function redISqr() {
        assert(this.red, "redISqr works only with red numbers");
        this.red._verify1(this);
        return this.red.isqr(this);
      };
      BN23.prototype.redSqrt = function redSqrt() {
        assert(this.red, "redSqrt works only with red numbers");
        this.red._verify1(this);
        return this.red.sqrt(this);
      };
      BN23.prototype.redInvm = function redInvm() {
        assert(this.red, "redInvm works only with red numbers");
        this.red._verify1(this);
        return this.red.invm(this);
      };
      BN23.prototype.redNeg = function redNeg() {
        assert(this.red, "redNeg works only with red numbers");
        this.red._verify1(this);
        return this.red.neg(this);
      };
      BN23.prototype.redPow = function redPow(num) {
        assert(this.red && !num.red, "redPow(normalNum)");
        this.red._verify1(this);
        return this.red.pow(this, num);
      };
      var primes = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };
      function MPrime(name, p) {
        this.name = name;
        this.p = new BN23(p, 16);
        this.n = this.p.bitLength();
        this.k = new BN23(1).iushln(this.n).isub(this.p);
        this.tmp = this._tmp();
      }
      MPrime.prototype._tmp = function _tmp() {
        var tmp = new BN23(null);
        tmp.words = new Array(Math.ceil(this.n / 13));
        return tmp;
      };
      MPrime.prototype.ireduce = function ireduce(num) {
        var r = num;
        var rlen;
        do {
          this.split(r, this.tmp);
          r = this.imulK(r);
          r = r.iadd(this.tmp);
          rlen = r.bitLength();
        } while (rlen > this.n);
        var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
        if (cmp === 0) {
          r.words[0] = 0;
          r.length = 1;
        } else if (cmp > 0) {
          r.isub(this.p);
        } else {
          if (r.strip !== void 0) {
            r.strip();
          } else {
            r._strip();
          }
        }
        return r;
      };
      MPrime.prototype.split = function split(input, out) {
        input.iushrn(this.n, 0, out);
      };
      MPrime.prototype.imulK = function imulK(num) {
        return num.imul(this.k);
      };
      function K256() {
        MPrime.call(
          this,
          "k256",
          "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
        );
      }
      inherits(K256, MPrime);
      K256.prototype.split = function split(input, output) {
        var mask = 4194303;
        var outLen = Math.min(input.length, 9);
        for (var i = 0; i < outLen; i++) {
          output.words[i] = input.words[i];
        }
        output.length = outLen;
        if (input.length <= 9) {
          input.words[0] = 0;
          input.length = 1;
          return;
        }
        var prev = input.words[9];
        output.words[output.length++] = prev & mask;
        for (i = 10; i < input.length; i++) {
          var next = input.words[i] | 0;
          input.words[i - 10] = (next & mask) << 4 | prev >>> 22;
          prev = next;
        }
        prev >>>= 22;
        input.words[i - 10] = prev;
        if (prev === 0 && input.length > 10) {
          input.length -= 10;
        } else {
          input.length -= 9;
        }
      };
      K256.prototype.imulK = function imulK(num) {
        num.words[num.length] = 0;
        num.words[num.length + 1] = 0;
        num.length += 2;
        var lo = 0;
        for (var i = 0; i < num.length; i++) {
          var w = num.words[i] | 0;
          lo += w * 977;
          num.words[i] = lo & 67108863;
          lo = w * 64 + (lo / 67108864 | 0);
        }
        if (num.words[num.length - 1] === 0) {
          num.length--;
          if (num.words[num.length - 1] === 0) {
            num.length--;
          }
        }
        return num;
      };
      function P224() {
        MPrime.call(
          this,
          "p224",
          "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
        );
      }
      inherits(P224, MPrime);
      function P192() {
        MPrime.call(
          this,
          "p192",
          "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
        );
      }
      inherits(P192, MPrime);
      function P25519() {
        MPrime.call(
          this,
          "25519",
          "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
        );
      }
      inherits(P25519, MPrime);
      P25519.prototype.imulK = function imulK(num) {
        var carry = 0;
        for (var i = 0; i < num.length; i++) {
          var hi = (num.words[i] | 0) * 19 + carry;
          var lo = hi & 67108863;
          hi >>>= 26;
          num.words[i] = lo;
          carry = hi;
        }
        if (carry !== 0) {
          num.words[num.length++] = carry;
        }
        return num;
      };
      BN23._prime = function prime(name) {
        if (primes[name])
          return primes[name];
        var prime2;
        if (name === "k256") {
          prime2 = new K256();
        } else if (name === "p224") {
          prime2 = new P224();
        } else if (name === "p192") {
          prime2 = new P192();
        } else if (name === "p25519") {
          prime2 = new P25519();
        } else {
          throw new Error("Unknown prime " + name);
        }
        primes[name] = prime2;
        return prime2;
      };
      function Red(m) {
        if (typeof m === "string") {
          var prime = BN23._prime(m);
          this.m = prime.p;
          this.prime = prime;
        } else {
          assert(m.gtn(1), "modulus must be greater than 1");
          this.m = m;
          this.prime = null;
        }
      }
      Red.prototype._verify1 = function _verify1(a) {
        assert(a.negative === 0, "red works only with positives");
        assert(a.red, "red works only with red numbers");
      };
      Red.prototype._verify2 = function _verify2(a, b) {
        assert((a.negative | b.negative) === 0, "red works only with positives");
        assert(
          a.red && a.red === b.red,
          "red works only with red numbers"
        );
      };
      Red.prototype.imod = function imod(a) {
        if (this.prime)
          return this.prime.ireduce(a)._forceRed(this);
        move(a, a.umod(this.m)._forceRed(this));
        return a;
      };
      Red.prototype.neg = function neg(a) {
        if (a.isZero()) {
          return a.clone();
        }
        return this.m.sub(a)._forceRed(this);
      };
      Red.prototype.add = function add2(a, b) {
        this._verify2(a, b);
        var res = a.add(b);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.iadd = function iadd(a, b) {
        this._verify2(a, b);
        var res = a.iadd(b);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res;
      };
      Red.prototype.sub = function sub2(a, b) {
        this._verify2(a, b);
        var res = a.sub(b);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.isub = function isub(a, b) {
        this._verify2(a, b);
        var res = a.isub(b);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res;
      };
      Red.prototype.shl = function shl(a, num) {
        this._verify1(a);
        return this.imod(a.ushln(num));
      };
      Red.prototype.imul = function imul(a, b) {
        this._verify2(a, b);
        return this.imod(a.imul(b));
      };
      Red.prototype.mul = function mul2(a, b) {
        this._verify2(a, b);
        return this.imod(a.mul(b));
      };
      Red.prototype.isqr = function isqr(a) {
        return this.imul(a, a.clone());
      };
      Red.prototype.sqr = function sqr(a) {
        return this.mul(a, a);
      };
      Red.prototype.sqrt = function sqrt2(a) {
        if (a.isZero())
          return a.clone();
        var mod3 = this.m.andln(3);
        assert(mod3 % 2 === 1);
        if (mod3 === 3) {
          var pow3 = this.m.add(new BN23(1)).iushrn(2);
          return this.pow(a, pow3);
        }
        var q = this.m.subn(1);
        var s = 0;
        while (!q.isZero() && q.andln(1) === 0) {
          s++;
          q.iushrn(1);
        }
        assert(!q.isZero());
        var one = new BN23(1).toRed(this);
        var nOne = one.redNeg();
        var lpow = this.m.subn(1).iushrn(1);
        var z = this.m.bitLength();
        z = new BN23(2 * z * z).toRed(this);
        while (this.pow(z, lpow).cmp(nOne) !== 0) {
          z.redIAdd(nOne);
        }
        var c = this.pow(z, q);
        var r = this.pow(a, q.addn(1).iushrn(1));
        var t = this.pow(a, q);
        var m = s;
        while (t.cmp(one) !== 0) {
          var tmp = t;
          for (var i = 0; tmp.cmp(one) !== 0; i++) {
            tmp = tmp.redSqr();
          }
          assert(i < m);
          var b = this.pow(c, new BN23(1).iushln(m - i - 1));
          r = r.redMul(b);
          c = b.redSqr();
          t = t.redMul(c);
          m = i;
        }
        return r;
      };
      Red.prototype.invm = function invm(a) {
        var inv = a._invmp(this.m);
        if (inv.negative !== 0) {
          inv.negative = 0;
          return this.imod(inv).redNeg();
        } else {
          return this.imod(inv);
        }
      };
      Red.prototype.pow = function pow3(a, num) {
        if (num.isZero())
          return new BN23(1).toRed(this);
        if (num.cmpn(1) === 0)
          return a.clone();
        var windowSize = 4;
        var wnd = new Array(1 << windowSize);
        wnd[0] = new BN23(1).toRed(this);
        wnd[1] = a;
        for (var i = 2; i < wnd.length; i++) {
          wnd[i] = this.mul(wnd[i - 1], a);
        }
        var res = wnd[0];
        var current = 0;
        var currentLen = 0;
        var start = num.bitLength() % 26;
        if (start === 0) {
          start = 26;
        }
        for (i = num.length - 1; i >= 0; i--) {
          var word = num.words[i];
          for (var j = start - 1; j >= 0; j--) {
            var bit = word >> j & 1;
            if (res !== wnd[0]) {
              res = this.sqr(res);
            }
            if (bit === 0 && current === 0) {
              currentLen = 0;
              continue;
            }
            current <<= 1;
            current |= bit;
            currentLen++;
            if (currentLen !== windowSize && (i !== 0 || j !== 0))
              continue;
            res = this.mul(res, wnd[current]);
            currentLen = 0;
            current = 0;
          }
          start = 26;
        }
        return res;
      };
      Red.prototype.convertTo = function convertTo(num) {
        var r = num.umod(this.m);
        return r === num ? r.clone() : r;
      };
      Red.prototype.convertFrom = function convertFrom(num) {
        var res = num.clone();
        res.red = null;
        return res;
      };
      BN23.mont = function mont(num) {
        return new Mont(num);
      };
      function Mont(m) {
        Red.call(this, m);
        this.shift = this.m.bitLength();
        if (this.shift % 26 !== 0) {
          this.shift += 26 - this.shift % 26;
        }
        this.r = new BN23(1).iushln(this.shift);
        this.r2 = this.imod(this.r.sqr());
        this.rinv = this.r._invmp(this.m);
        this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
        this.minv = this.minv.umod(this.r);
        this.minv = this.r.sub(this.minv);
      }
      inherits(Mont, Red);
      Mont.prototype.convertTo = function convertTo(num) {
        return this.imod(num.ushln(this.shift));
      };
      Mont.prototype.convertFrom = function convertFrom(num) {
        var r = this.imod(num.mul(this.rinv));
        r.red = null;
        return r;
      };
      Mont.prototype.imul = function imul(a, b) {
        if (a.isZero() || b.isZero()) {
          a.words[0] = 0;
          a.length = 1;
          return a;
        }
        var t = a.imul(b);
        var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u = t.isub(c).iushrn(this.shift);
        var res = u;
        if (u.cmp(this.m) >= 0) {
          res = u.isub(this.m);
        } else if (u.cmpn(0) < 0) {
          res = u.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.mul = function mul2(a, b) {
        if (a.isZero() || b.isZero())
          return new BN23(0)._forceRed(this);
        var t = a.mul(b);
        var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u = t.isub(c).iushrn(this.shift);
        var res = u;
        if (u.cmp(this.m) >= 0) {
          res = u.isub(this.m);
        } else if (u.cmpn(0) < 0) {
          res = u.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.invm = function invm(a) {
        var res = this.imod(a._invmp(this.m).mul(this.r2));
        return res._forceRed(this);
      };
    })(typeof module2 === "undefined" || module2, exports2);
  }
});

// node_modules/@coral-xyz/borsh/dist/index.js
var require_dist = __commonJS({
  "node_modules/@coral-xyz/borsh/dist/index.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.struct = exports2.f64 = exports2.f32 = exports2.i32 = exports2.u32 = exports2.i16 = exports2.u16 = exports2.i8 = exports2.u8 = void 0;
    exports2.u64 = u643;
    exports2.i64 = i642;
    exports2.u128 = u1282;
    exports2.i128 = i128;
    exports2.u256 = u2562;
    exports2.i256 = i256;
    exports2.publicKey = publicKey2;
    exports2.option = option;
    exports2.bool = bool2;
    exports2.vec = vec;
    exports2.tagged = tagged;
    exports2.vecU8 = vecU8;
    exports2.str = str;
    exports2.rustEnum = rustEnum;
    exports2.array = array;
    exports2.map = map;
    var buffer_layout_1 = require_Layout2();
    var web3_js_1 = require("@solana/web3.js");
    var bn_js_1 = __importDefault(require_bn());
    var buffer_layout_2 = require_Layout2();
    Object.defineProperty(exports2, "u8", { enumerable: true, get: function() {
      return buffer_layout_2.u8;
    } });
    Object.defineProperty(exports2, "i8", { enumerable: true, get: function() {
      return buffer_layout_2.s8;
    } });
    Object.defineProperty(exports2, "u16", { enumerable: true, get: function() {
      return buffer_layout_2.u16;
    } });
    Object.defineProperty(exports2, "i16", { enumerable: true, get: function() {
      return buffer_layout_2.s16;
    } });
    Object.defineProperty(exports2, "u32", { enumerable: true, get: function() {
      return buffer_layout_2.u32;
    } });
    Object.defineProperty(exports2, "i32", { enumerable: true, get: function() {
      return buffer_layout_2.s32;
    } });
    Object.defineProperty(exports2, "f32", { enumerable: true, get: function() {
      return buffer_layout_2.f32;
    } });
    Object.defineProperty(exports2, "f64", { enumerable: true, get: function() {
      return buffer_layout_2.f64;
    } });
    Object.defineProperty(exports2, "struct", { enumerable: true, get: function() {
      return buffer_layout_2.struct;
    } });
    var BNLayout = class extends buffer_layout_1.Layout {
      constructor(span, signed, property) {
        super(span, property);
        this.blob = (0, buffer_layout_1.blob)(span);
        this.signed = signed;
      }
      decode(b, offset = 0) {
        const num = new bn_js_1.default(this.blob.decode(b, offset), 10, "le");
        if (this.signed) {
          return num.fromTwos(this.span * 8).clone();
        }
        return num;
      }
      encode(src, b, offset = 0) {
        if (this.signed) {
          src = src.toTwos(this.span * 8);
        }
        return this.blob.encode(src.toArrayLike(Buffer, "le", this.span), b, offset);
      }
    };
    function u643(property) {
      return new BNLayout(8, false, property);
    }
    function i642(property) {
      return new BNLayout(8, true, property);
    }
    function u1282(property) {
      return new BNLayout(16, false, property);
    }
    function i128(property) {
      return new BNLayout(16, true, property);
    }
    function u2562(property) {
      return new BNLayout(32, false, property);
    }
    function i256(property) {
      return new BNLayout(32, true, property);
    }
    var WrappedLayout = class extends buffer_layout_1.Layout {
      constructor(layout, decoder, encoder, property) {
        super(layout.span, property);
        this.layout = layout;
        this.decoder = decoder;
        this.encoder = encoder;
      }
      decode(b, offset) {
        return this.decoder(this.layout.decode(b, offset));
      }
      encode(src, b, offset) {
        return this.layout.encode(this.encoder(src), b, offset);
      }
      getSpan(b, offset) {
        return this.layout.getSpan(b, offset);
      }
    };
    function publicKey2(property) {
      return new WrappedLayout((0, buffer_layout_1.blob)(32), (b) => new web3_js_1.PublicKey(b), (key) => key.toBuffer(), property);
    }
    var OptionLayout = class extends buffer_layout_1.Layout {
      constructor(layout, property) {
        super(-1, property);
        this.layout = layout;
        this.discriminator = (0, buffer_layout_1.u8)();
      }
      encode(src, b, offset = 0) {
        if (src === null || src === void 0) {
          return this.discriminator.encode(0, b, offset);
        }
        this.discriminator.encode(1, b, offset);
        return this.layout.encode(src, b, offset + 1) + 1;
      }
      decode(b, offset = 0) {
        const discriminator = this.discriminator.decode(b, offset);
        if (discriminator === 0) {
          return null;
        } else if (discriminator === 1) {
          return this.layout.decode(b, offset + 1);
        }
        throw new Error("Invalid option " + this.property);
      }
      getSpan(b, offset = 0) {
        const discriminator = this.discriminator.decode(b, offset);
        if (discriminator === 0) {
          return 1;
        } else if (discriminator === 1) {
          return this.layout.getSpan(b, offset + 1) + 1;
        }
        throw new Error("Invalid option " + this.property);
      }
    };
    function option(layout, property) {
      return new OptionLayout(layout, property);
    }
    function bool2(property) {
      return new WrappedLayout((0, buffer_layout_1.u8)(), decodeBool, encodeBool, property);
    }
    function decodeBool(value) {
      if (value === 0) {
        return false;
      } else if (value === 1) {
        return true;
      }
      throw new Error("Invalid bool: " + value);
    }
    function encodeBool(value) {
      return value ? 1 : 0;
    }
    function vec(elementLayout, property) {
      const length = (0, buffer_layout_1.u32)("length");
      const layout = (0, buffer_layout_1.struct)([
        length,
        (0, buffer_layout_1.seq)(elementLayout, (0, buffer_layout_1.offset)(length, -length.span), "values")
      ]);
      return new WrappedLayout(layout, ({ values }) => values, (values) => ({ values }), property);
    }
    function tagged(tag2, layout, property) {
      const wrappedLayout = (0, buffer_layout_1.struct)([
        u643("tag"),
        layout.replicate("data")
      ]);
      function decodeTag({ tag: receivedTag, data }) {
        if (!receivedTag.eq(tag2)) {
          throw new Error("Invalid tag, expected: " + tag2.toString("hex") + ", got: " + receivedTag.toString("hex"));
        }
        return data;
      }
      return new WrappedLayout(wrappedLayout, decodeTag, (data) => ({ tag: tag2, data }), property);
    }
    function vecU8(property) {
      const length = (0, buffer_layout_1.u32)("length");
      const layout = (0, buffer_layout_1.struct)([
        length,
        (0, buffer_layout_1.blob)((0, buffer_layout_1.offset)(length, -length.span), "data")
      ]);
      return new WrappedLayout(layout, ({ data }) => data, (data) => ({ data }), property);
    }
    function str(property) {
      return new WrappedLayout(vecU8(), (data) => data.toString("utf-8"), (s) => Buffer.from(s, "utf-8"), property);
    }
    function rustEnum(variants, property, discriminant) {
      const unionLayout = (0, buffer_layout_1.union)(discriminant !== null && discriminant !== void 0 ? discriminant : (0, buffer_layout_1.u8)(), property);
      variants.forEach((variant, index) => unionLayout.addVariant(index, variant, variant.property));
      return unionLayout;
    }
    function array(elementLayout, length, property) {
      const layout = (0, buffer_layout_1.struct)([
        (0, buffer_layout_1.seq)(elementLayout, length, "values")
      ]);
      return new WrappedLayout(layout, ({ values }) => values, (values) => ({ values }), property);
    }
    var MapEntryLayout = class extends buffer_layout_1.Layout {
      constructor(keyLayout, valueLayout, property) {
        super(keyLayout.span + valueLayout.span, property);
        this.keyLayout = keyLayout;
        this.valueLayout = valueLayout;
      }
      decode(b, offset) {
        offset = offset || 0;
        const key = this.keyLayout.decode(b, offset);
        const value = this.valueLayout.decode(b, offset + this.keyLayout.getSpan(b, offset));
        return [key, value];
      }
      encode(src, b, offset) {
        offset = offset || 0;
        const keyBytes = this.keyLayout.encode(src[0], b, offset);
        const valueBytes = this.valueLayout.encode(src[1], b, offset + keyBytes);
        return keyBytes + valueBytes;
      }
      getSpan(b, offset) {
        return this.keyLayout.getSpan(b, offset) + this.valueLayout.getSpan(b, offset);
      }
    };
    function map(keyLayout, valueLayout, property) {
      const length = (0, buffer_layout_1.u32)("length");
      const layout = (0, buffer_layout_1.struct)([
        length,
        (0, buffer_layout_1.seq)(new MapEntryLayout(keyLayout, valueLayout), (0, buffer_layout_1.offset)(length, -length.span), "values")
      ]);
      return new WrappedLayout(layout, ({ values }) => new Map(values), (values) => ({ values: Array.from(values.entries()) }), property);
    }
  }
});

// node_modules/gaussian/lib/box-muller.js
var require_box_muller = __commonJS({
  "node_modules/gaussian/lib/box-muller.js"(exports2, module2) {
    (function(exports3) {
      const PRECISION2 = 1e9;
      const _2PI = Math.PI * 2;
      function generateGaussian(mean, std, randFn = null) {
        var u1;
        var u2;
        if (randFn) {
          u1 = randFn();
          u2 = randFn();
        } else {
          u1 = Math.random();
          u2 = Math.random();
        }
        var z0 = Math.sqrt(-2 * Math.log(u1)) * Math.cos(_2PI * u2);
        var z1 = Math.sqrt(-2 * Math.log(u1)) * Math.sin(_2PI * u2);
        return z0 * std + mean;
      }
      exports3(generateGaussian);
    })(typeof exports2 !== "undefined" ? function(e) {
      module2.exports = e;
    } : function(e) {
      this["boxmuller"] = e;
    });
  }
});

// node_modules/gaussian/lib/gaussian.js
var require_gaussian = __commonJS({
  "node_modules/gaussian/lib/gaussian.js"(exports2, module2) {
    (function(exports3) {
      const generateGaussian = require_box_muller();
      var erfc = function(x) {
        var z = Math.abs(x);
        var t = 1 / (1 + z / 2);
        var r = t * Math.exp(-z * z - 1.26551223 + t * (1.00002368 + t * (0.37409196 + t * (0.09678418 + t * (-0.18628806 + t * (0.27886807 + t * (-1.13520398 + t * (1.48851587 + t * (-0.82215223 + t * 0.17087277)))))))));
        return x >= 0 ? r : 2 - r;
      };
      var ierfc = function(x) {
        if (x >= 2) {
          return -100;
        }
        if (x <= 0) {
          return 100;
        }
        var xx = x < 1 ? x : 2 - x;
        var t = Math.sqrt(-2 * Math.log(xx / 2));
        var r = -0.70711 * ((2.30753 + t * 0.27061) / (1 + t * (0.99229 + t * 0.04481)) - t);
        for (var j = 0; j < 2; j++) {
          var err = erfc(r) - xx;
          r += err / (1.1283791670955126 * Math.exp(-(r * r)) - r * err);
        }
        return x < 1 ? r : -r;
      };
      var Gaussian = function(mean, variance) {
        if (variance <= 0) {
          throw new Error("Variance must be > 0 (but was " + variance + ")");
        }
        this.mean = mean;
        this.variance = variance;
        this.standardDeviation = Math.sqrt(variance);
      };
      Gaussian.prototype.pdf = function(x) {
        var m = this.standardDeviation * Math.sqrt(2 * Math.PI);
        var e = Math.exp(-Math.pow(x - this.mean, 2) / (2 * this.variance));
        return e / m;
      };
      Gaussian.prototype.cdf = function(x) {
        return 0.5 * erfc(-(x - this.mean) / (this.standardDeviation * Math.sqrt(2)));
      };
      Gaussian.prototype.ppf = function(x) {
        return this.mean - this.standardDeviation * Math.sqrt(2) * ierfc(2 * x);
      };
      Gaussian.prototype.mul = function(d) {
        if (typeof d === "number") {
          return this.scale(d);
        }
        var precision = 1 / this.variance;
        var dprecision = 1 / d.variance;
        return fromPrecisionMean(
          precision + dprecision,
          precision * this.mean + dprecision * d.mean
        );
      };
      Gaussian.prototype.div = function(d) {
        if (typeof d === "number") {
          return this.scale(1 / d);
        }
        var precision = 1 / this.variance;
        var dprecision = 1 / d.variance;
        return fromPrecisionMean(
          precision - dprecision,
          precision * this.mean - dprecision * d.mean
        );
      };
      Gaussian.prototype.add = function(d) {
        return gaussian2(this.mean + d.mean, this.variance + d.variance);
      };
      Gaussian.prototype.sub = function(d) {
        return gaussian2(this.mean - d.mean, this.variance + d.variance);
      };
      Gaussian.prototype.scale = function(c) {
        return gaussian2(this.mean * c, this.variance * c * c);
      };
      Gaussian.prototype.random = function(num, randFn = null) {
        let mean = this.mean;
        let std = this.standardDeviation;
        return Array(num).fill(0).map(() => {
          return generateGaussian(mean, std, randFn);
        });
      };
      var gaussian2 = function(mean, variance) {
        return new Gaussian(mean, variance);
      };
      var fromPrecisionMean = function(precision, precisionmean) {
        return gaussian2(precisionmean / precision, 1 / precision);
      };
      exports3(gaussian2);
    })(typeof exports2 !== "undefined" ? function(e) {
      module2.exports = e;
    } : function(e) {
      this["gaussian"] = e;
    });
  }
});

// node_modules/decimal.js/decimal.js
var require_decimal = __commonJS({
  "node_modules/decimal.js/decimal.js"(exports2, module2) {
    (function(globalScope) {
      "use strict";
      var EXP_LIMIT2 = 9e15, MAX_DIGITS2 = 1e9, NUMERALS2 = "0123456789abcdef", LN102 = "2.3025850929940456840179914546843642076011014886287729760333279009675726096773524802359972050895982983419677840422862486334095254650828067566662873690987816894829072083255546808437998948262331985283935053089653777326288461633662222876982198867465436674744042432743651550489343149393914796194044002221051017141748003688084012647080685567743216228355220114804663715659121373450747856947683463616792101806445070648000277502684916746550586856935673420670581136429224554405758925724208241314695689016758940256776311356919292033376587141660230105703089634572075440370847469940168269282808481184289314848524948644871927809676271275775397027668605952496716674183485704422507197965004714951050492214776567636938662976979522110718264549734772662425709429322582798502585509785265383207606726317164309505995087807523710333101197857547331541421808427543863591778117054309827482385045648019095610299291824318237525357709750539565187697510374970888692180205189339507238539205144634197265287286965110862571492198849978748873771345686209167058", PI2 = "3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632789", DEFAULTS2 = {
        // These values must be integers within the stated ranges (inclusive).
        // Most of these values can be changed at run-time using the `Decimal.config` method.
        // The maximum number of significant digits of the result of a calculation or base conversion.
        // E.g. `Decimal.config({ precision: 20 });`
        precision: 20,
        // 1 to MAX_DIGITS
        // The rounding mode used when rounding to `precision`.
        //
        // ROUND_UP         0 Away from zero.
        // ROUND_DOWN       1 Towards zero.
        // ROUND_CEIL       2 Towards +Infinity.
        // ROUND_FLOOR      3 Towards -Infinity.
        // ROUND_HALF_UP    4 Towards nearest neighbour. If equidistant, up.
        // ROUND_HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.
        // ROUND_HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.
        // ROUND_HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.
        // ROUND_HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.
        //
        // E.g.
        // `Decimal.rounding = 4;`
        // `Decimal.rounding = Decimal.ROUND_HALF_UP;`
        rounding: 4,
        // 0 to 8
        // The modulo mode used when calculating the modulus: a mod n.
        // The quotient (q = a / n) is calculated according to the corresponding rounding mode.
        // The remainder (r) is calculated as: r = a - n * q.
        //
        // UP         0 The remainder is positive if the dividend is negative, else is negative.
        // DOWN       1 The remainder has the same sign as the dividend (JavaScript %).
        // FLOOR      3 The remainder has the same sign as the divisor (Python %).
        // HALF_EVEN  6 The IEEE 754 remainder function.
        // EUCLID     9 Euclidian division. q = sign(n) * floor(a / abs(n)). Always positive.
        //
        // Truncated division (1), floored division (3), the IEEE 754 remainder (6), and Euclidian
        // division (9) are commonly used for the modulus operation. The other rounding modes can also
        // be used, but they may not give useful results.
        modulo: 1,
        // 0 to 9
        // The exponent value at and beneath which `toString` returns exponential notation.
        // JavaScript numbers: -7
        toExpNeg: -7,
        // 0 to -EXP_LIMIT
        // The exponent value at and above which `toString` returns exponential notation.
        // JavaScript numbers: 21
        toExpPos: 21,
        // 0 to EXP_LIMIT
        // The minimum exponent value, beneath which underflow to zero occurs.
        // JavaScript numbers: -324  (5e-324)
        minE: -EXP_LIMIT2,
        // -1 to -EXP_LIMIT
        // The maximum exponent value, above which overflow to Infinity occurs.
        // JavaScript numbers: 308  (1.7976931348623157e+308)
        maxE: EXP_LIMIT2,
        // 1 to EXP_LIMIT
        // Whether to use cryptographically-secure random number generation, if available.
        crypto: false
        // true/false
      }, Decimal2, inexact2, noConflict, quadrant2, external2 = true, decimalError2 = "[DecimalError] ", invalidArgument2 = decimalError2 + "Invalid argument: ", precisionLimitExceeded2 = decimalError2 + "Precision limit exceeded", cryptoUnavailable2 = decimalError2 + "crypto unavailable", tag2 = "[object Decimal]", mathfloor3 = Math.floor, mathpow2 = Math.pow, isBinary2 = /^0b([01]+(\.[01]*)?|\.[01]+)(p[+-]?\d+)?$/i, isHex2 = /^0x([0-9a-f]+(\.[0-9a-f]*)?|\.[0-9a-f]+)(p[+-]?\d+)?$/i, isOctal2 = /^0o([0-7]+(\.[0-7]*)?|\.[0-7]+)(p[+-]?\d+)?$/i, isDecimal2 = /^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i, BASE3 = 1e7, LOG_BASE3 = 7, MAX_SAFE_INTEGER3 = 9007199254740991, LN10_PRECISION2 = LN102.length - 1, PI_PRECISION2 = PI2.length - 1, P2 = { toStringTag: tag2 };
      P2.absoluteValue = P2.abs = function() {
        var x = new this.constructor(this);
        if (x.s < 0)
          x.s = 1;
        return finalise2(x);
      };
      P2.ceil = function() {
        return finalise2(new this.constructor(this), this.e + 1, 2);
      };
      P2.clampedTo = P2.clamp = function(min3, max3) {
        var k, x = this, Ctor = x.constructor;
        min3 = new Ctor(min3);
        max3 = new Ctor(max3);
        if (!min3.s || !max3.s)
          return new Ctor(NaN);
        if (min3.gt(max3))
          throw Error(invalidArgument2 + max3);
        k = x.cmp(min3);
        return k < 0 ? min3 : x.cmp(max3) > 0 ? max3 : new Ctor(x);
      };
      P2.comparedTo = P2.cmp = function(y) {
        var i, j, xdL, ydL, x = this, xd = x.d, yd = (y = new x.constructor(y)).d, xs = x.s, ys = y.s;
        if (!xd || !yd) {
          return !xs || !ys ? NaN : xs !== ys ? xs : xd === yd ? 0 : !xd ^ xs < 0 ? 1 : -1;
        }
        if (!xd[0] || !yd[0])
          return xd[0] ? xs : yd[0] ? -ys : 0;
        if (xs !== ys)
          return xs;
        if (x.e !== y.e)
          return x.e > y.e ^ xs < 0 ? 1 : -1;
        xdL = xd.length;
        ydL = yd.length;
        for (i = 0, j = xdL < ydL ? xdL : ydL; i < j; ++i) {
          if (xd[i] !== yd[i])
            return xd[i] > yd[i] ^ xs < 0 ? 1 : -1;
        }
        return xdL === ydL ? 0 : xdL > ydL ^ xs < 0 ? 1 : -1;
      };
      P2.cosine = P2.cos = function() {
        var pr, rm, x = this, Ctor = x.constructor;
        if (!x.d)
          return new Ctor(NaN);
        if (!x.d[0])
          return new Ctor(1);
        pr = Ctor.precision;
        rm = Ctor.rounding;
        Ctor.precision = pr + Math.max(x.e, x.sd()) + LOG_BASE3;
        Ctor.rounding = 1;
        x = cosine2(Ctor, toLessThanHalfPi2(Ctor, x));
        Ctor.precision = pr;
        Ctor.rounding = rm;
        return finalise2(quadrant2 == 2 || quadrant2 == 3 ? x.neg() : x, pr, rm, true);
      };
      P2.cubeRoot = P2.cbrt = function() {
        var e, m, n, r, rep, s, sd, t, t3, t3plusx, x = this, Ctor = x.constructor;
        if (!x.isFinite() || x.isZero())
          return new Ctor(x);
        external2 = false;
        s = x.s * mathpow2(x.s * x, 1 / 3);
        if (!s || Math.abs(s) == 1 / 0) {
          n = digitsToString2(x.d);
          e = x.e;
          if (s = (e - n.length + 1) % 3)
            n += s == 1 || s == -2 ? "0" : "00";
          s = mathpow2(n, 1 / 3);
          e = mathfloor3((e + 1) / 3) - (e % 3 == (e < 0 ? -1 : 2));
          if (s == 1 / 0) {
            n = "5e" + e;
          } else {
            n = s.toExponential();
            n = n.slice(0, n.indexOf("e") + 1) + e;
          }
          r = new Ctor(n);
          r.s = x.s;
        } else {
          r = new Ctor(s.toString());
        }
        sd = (e = Ctor.precision) + 3;
        for (; ; ) {
          t = r;
          t3 = t.times(t).times(t);
          t3plusx = t3.plus(x);
          r = divide2(t3plusx.plus(x).times(t), t3plusx.plus(t3), sd + 2, 1);
          if (digitsToString2(t.d).slice(0, sd) === (n = digitsToString2(r.d)).slice(0, sd)) {
            n = n.slice(sd - 3, sd + 1);
            if (n == "9999" || !rep && n == "4999") {
              if (!rep) {
                finalise2(t, e + 1, 0);
                if (t.times(t).times(t).eq(x)) {
                  r = t;
                  break;
                }
              }
              sd += 4;
              rep = 1;
            } else {
              if (!+n || !+n.slice(1) && n.charAt(0) == "5") {
                finalise2(r, e + 1, 1);
                m = !r.times(r).times(r).eq(x);
              }
              break;
            }
          }
        }
        external2 = true;
        return finalise2(r, e, Ctor.rounding, m);
      };
      P2.decimalPlaces = P2.dp = function() {
        var w, d = this.d, n = NaN;
        if (d) {
          w = d.length - 1;
          n = (w - mathfloor3(this.e / LOG_BASE3)) * LOG_BASE3;
          w = d[w];
          if (w)
            for (; w % 10 == 0; w /= 10)
              n--;
          if (n < 0)
            n = 0;
        }
        return n;
      };
      P2.dividedBy = P2.div = function(y) {
        return divide2(this, new this.constructor(y));
      };
      P2.dividedToIntegerBy = P2.divToInt = function(y) {
        var x = this, Ctor = x.constructor;
        return finalise2(divide2(x, new Ctor(y), 0, 1, 1), Ctor.precision, Ctor.rounding);
      };
      P2.equals = P2.eq = function(y) {
        return this.cmp(y) === 0;
      };
      P2.floor = function() {
        return finalise2(new this.constructor(this), this.e + 1, 3);
      };
      P2.greaterThan = P2.gt = function(y) {
        return this.cmp(y) > 0;
      };
      P2.greaterThanOrEqualTo = P2.gte = function(y) {
        var k = this.cmp(y);
        return k == 1 || k === 0;
      };
      P2.hyperbolicCosine = P2.cosh = function() {
        var k, n, pr, rm, len, x = this, Ctor = x.constructor, one = new Ctor(1);
        if (!x.isFinite())
          return new Ctor(x.s ? 1 / 0 : NaN);
        if (x.isZero())
          return one;
        pr = Ctor.precision;
        rm = Ctor.rounding;
        Ctor.precision = pr + Math.max(x.e, x.sd()) + 4;
        Ctor.rounding = 1;
        len = x.d.length;
        if (len < 32) {
          k = Math.ceil(len / 3);
          n = (1 / tinyPow2(4, k)).toString();
        } else {
          k = 16;
          n = "2.3283064365386962890625e-10";
        }
        x = taylorSeries2(Ctor, 1, x.times(n), new Ctor(1), true);
        var cosh2_x, i = k, d8 = new Ctor(8);
        for (; i--; ) {
          cosh2_x = x.times(x);
          x = one.minus(cosh2_x.times(d8.minus(cosh2_x.times(d8))));
        }
        return finalise2(x, Ctor.precision = pr, Ctor.rounding = rm, true);
      };
      P2.hyperbolicSine = P2.sinh = function() {
        var k, pr, rm, len, x = this, Ctor = x.constructor;
        if (!x.isFinite() || x.isZero())
          return new Ctor(x);
        pr = Ctor.precision;
        rm = Ctor.rounding;
        Ctor.precision = pr + Math.max(x.e, x.sd()) + 4;
        Ctor.rounding = 1;
        len = x.d.length;
        if (len < 3) {
          x = taylorSeries2(Ctor, 2, x, x, true);
        } else {
          k = 1.4 * Math.sqrt(len);
          k = k > 16 ? 16 : k | 0;
          x = x.times(1 / tinyPow2(5, k));
          x = taylorSeries2(Ctor, 2, x, x, true);
          var sinh2_x, d5 = new Ctor(5), d16 = new Ctor(16), d20 = new Ctor(20);
          for (; k--; ) {
            sinh2_x = x.times(x);
            x = x.times(d5.plus(sinh2_x.times(d16.times(sinh2_x).plus(d20))));
          }
        }
        Ctor.precision = pr;
        Ctor.rounding = rm;
        return finalise2(x, pr, rm, true);
      };
      P2.hyperbolicTangent = P2.tanh = function() {
        var pr, rm, x = this, Ctor = x.constructor;
        if (!x.isFinite())
          return new Ctor(x.s);
        if (x.isZero())
          return new Ctor(x);
        pr = Ctor.precision;
        rm = Ctor.rounding;
        Ctor.precision = pr + 7;
        Ctor.rounding = 1;
        return divide2(x.sinh(), x.cosh(), Ctor.precision = pr, Ctor.rounding = rm);
      };
      P2.inverseCosine = P2.acos = function() {
        var x = this, Ctor = x.constructor, k = x.abs().cmp(1), pr = Ctor.precision, rm = Ctor.rounding;
        if (k !== -1) {
          return k === 0 ? x.isNeg() ? getPi2(Ctor, pr, rm) : new Ctor(0) : new Ctor(NaN);
        }
        if (x.isZero())
          return getPi2(Ctor, pr + 4, rm).times(0.5);
        Ctor.precision = pr + 6;
        Ctor.rounding = 1;
        x = new Ctor(1).minus(x).div(x.plus(1)).sqrt().atan();
        Ctor.precision = pr;
        Ctor.rounding = rm;
        return x.times(2);
      };
      P2.inverseHyperbolicCosine = P2.acosh = function() {
        var pr, rm, x = this, Ctor = x.constructor;
        if (x.lte(1))
          return new Ctor(x.eq(1) ? 0 : NaN);
        if (!x.isFinite())
          return new Ctor(x);
        pr = Ctor.precision;
        rm = Ctor.rounding;
        Ctor.precision = pr + Math.max(Math.abs(x.e), x.sd()) + 4;
        Ctor.rounding = 1;
        external2 = false;
        x = x.times(x).minus(1).sqrt().plus(x);
        external2 = true;
        Ctor.precision = pr;
        Ctor.rounding = rm;
        return x.ln();
      };
      P2.inverseHyperbolicSine = P2.asinh = function() {
        var pr, rm, x = this, Ctor = x.constructor;
        if (!x.isFinite() || x.isZero())
          return new Ctor(x);
        pr = Ctor.precision;
        rm = Ctor.rounding;
        Ctor.precision = pr + 2 * Math.max(Math.abs(x.e), x.sd()) + 6;
        Ctor.rounding = 1;
        external2 = false;
        x = x.times(x).plus(1).sqrt().plus(x);
        external2 = true;
        Ctor.precision = pr;
        Ctor.rounding = rm;
        return x.ln();
      };
      P2.inverseHyperbolicTangent = P2.atanh = function() {
        var pr, rm, wpr, xsd, x = this, Ctor = x.constructor;
        if (!x.isFinite())
          return new Ctor(NaN);
        if (x.e >= 0)
          return new Ctor(x.abs().eq(1) ? x.s / 0 : x.isZero() ? x : NaN);
        pr = Ctor.precision;
        rm = Ctor.rounding;
        xsd = x.sd();
        if (Math.max(xsd, pr) < 2 * -x.e - 1)
          return finalise2(new Ctor(x), pr, rm, true);
        Ctor.precision = wpr = xsd - x.e;
        x = divide2(x.plus(1), new Ctor(1).minus(x), wpr + pr, 1);
        Ctor.precision = pr + 4;
        Ctor.rounding = 1;
        x = x.ln();
        Ctor.precision = pr;
        Ctor.rounding = rm;
        return x.times(0.5);
      };
      P2.inverseSine = P2.asin = function() {
        var halfPi, k, pr, rm, x = this, Ctor = x.constructor;
        if (x.isZero())
          return new Ctor(x);
        k = x.abs().cmp(1);
        pr = Ctor.precision;
        rm = Ctor.rounding;
        if (k !== -1) {
          if (k === 0) {
            halfPi = getPi2(Ctor, pr + 4, rm).times(0.5);
            halfPi.s = x.s;
            return halfPi;
          }
          return new Ctor(NaN);
        }
        Ctor.precision = pr + 6;
        Ctor.rounding = 1;
        x = x.div(new Ctor(1).minus(x.times(x)).sqrt().plus(1)).atan();
        Ctor.precision = pr;
        Ctor.rounding = rm;
        return x.times(2);
      };
      P2.inverseTangent = P2.atan = function() {
        var i, j, k, n, px, t, r, wpr, x2, x = this, Ctor = x.constructor, pr = Ctor.precision, rm = Ctor.rounding;
        if (!x.isFinite()) {
          if (!x.s)
            return new Ctor(NaN);
          if (pr + 4 <= PI_PRECISION2) {
            r = getPi2(Ctor, pr + 4, rm).times(0.5);
            r.s = x.s;
            return r;
          }
        } else if (x.isZero()) {
          return new Ctor(x);
        } else if (x.abs().eq(1) && pr + 4 <= PI_PRECISION2) {
          r = getPi2(Ctor, pr + 4, rm).times(0.25);
          r.s = x.s;
          return r;
        }
        Ctor.precision = wpr = pr + 10;
        Ctor.rounding = 1;
        k = Math.min(28, wpr / LOG_BASE3 + 2 | 0);
        for (i = k; i; --i)
          x = x.div(x.times(x).plus(1).sqrt().plus(1));
        external2 = false;
        j = Math.ceil(wpr / LOG_BASE3);
        n = 1;
        x2 = x.times(x);
        r = new Ctor(x);
        px = x;
        for (; i !== -1; ) {
          px = px.times(x2);
          t = r.minus(px.div(n += 2));
          px = px.times(x2);
          r = t.plus(px.div(n += 2));
          if (r.d[j] !== void 0)
            for (i = j; r.d[i] === t.d[i] && i--; )
              ;
        }
        if (k)
          r = r.times(2 << k - 1);
        external2 = true;
        return finalise2(r, Ctor.precision = pr, Ctor.rounding = rm, true);
      };
      P2.isFinite = function() {
        return !!this.d;
      };
      P2.isInteger = P2.isInt = function() {
        return !!this.d && mathfloor3(this.e / LOG_BASE3) > this.d.length - 2;
      };
      P2.isNaN = function() {
        return !this.s;
      };
      P2.isNegative = P2.isNeg = function() {
        return this.s < 0;
      };
      P2.isPositive = P2.isPos = function() {
        return this.s > 0;
      };
      P2.isZero = function() {
        return !!this.d && this.d[0] === 0;
      };
      P2.lessThan = P2.lt = function(y) {
        return this.cmp(y) < 0;
      };
      P2.lessThanOrEqualTo = P2.lte = function(y) {
        return this.cmp(y) < 1;
      };
      P2.logarithm = P2.log = function(base) {
        var isBase10, d, denominator, k, inf, num, sd, r, arg = this, Ctor = arg.constructor, pr = Ctor.precision, rm = Ctor.rounding, guard = 5;
        if (base == null) {
          base = new Ctor(10);
          isBase10 = true;
        } else {
          base = new Ctor(base);
          d = base.d;
          if (base.s < 0 || !d || !d[0] || base.eq(1))
            return new Ctor(NaN);
          isBase10 = base.eq(10);
        }
        d = arg.d;
        if (arg.s < 0 || !d || !d[0] || arg.eq(1)) {
          return new Ctor(d && !d[0] ? -1 / 0 : arg.s != 1 ? NaN : d ? 0 : 1 / 0);
        }
        if (isBase10) {
          if (d.length > 1) {
            inf = true;
          } else {
            for (k = d[0]; k % 10 === 0; )
              k /= 10;
            inf = k !== 1;
          }
        }
        external2 = false;
        sd = pr + guard;
        num = naturalLogarithm2(arg, sd);
        denominator = isBase10 ? getLn102(Ctor, sd + 10) : naturalLogarithm2(base, sd);
        r = divide2(num, denominator, sd, 1);
        if (checkRoundingDigits2(r.d, k = pr, rm)) {
          do {
            sd += 10;
            num = naturalLogarithm2(arg, sd);
            denominator = isBase10 ? getLn102(Ctor, sd + 10) : naturalLogarithm2(base, sd);
            r = divide2(num, denominator, sd, 1);
            if (!inf) {
              if (+digitsToString2(r.d).slice(k + 1, k + 15) + 1 == 1e14) {
                r = finalise2(r, pr + 1, 0);
              }
              break;
            }
          } while (checkRoundingDigits2(r.d, k += 10, rm));
        }
        external2 = true;
        return finalise2(r, pr, rm);
      };
      P2.minus = P2.sub = function(y) {
        var d, e, i, j, k, len, pr, rm, xd, xe, xLTy, yd, x = this, Ctor = x.constructor;
        y = new Ctor(y);
        if (!x.d || !y.d) {
          if (!x.s || !y.s)
            y = new Ctor(NaN);
          else if (x.d)
            y.s = -y.s;
          else
            y = new Ctor(y.d || x.s !== y.s ? x : NaN);
          return y;
        }
        if (x.s != y.s) {
          y.s = -y.s;
          return x.plus(y);
        }
        xd = x.d;
        yd = y.d;
        pr = Ctor.precision;
        rm = Ctor.rounding;
        if (!xd[0] || !yd[0]) {
          if (yd[0])
            y.s = -y.s;
          else if (xd[0])
            y = new Ctor(x);
          else
            return new Ctor(rm === 3 ? -0 : 0);
          return external2 ? finalise2(y, pr, rm) : y;
        }
        e = mathfloor3(y.e / LOG_BASE3);
        xe = mathfloor3(x.e / LOG_BASE3);
        xd = xd.slice();
        k = xe - e;
        if (k) {
          xLTy = k < 0;
          if (xLTy) {
            d = xd;
            k = -k;
            len = yd.length;
          } else {
            d = yd;
            e = xe;
            len = xd.length;
          }
          i = Math.max(Math.ceil(pr / LOG_BASE3), len) + 2;
          if (k > i) {
            k = i;
            d.length = 1;
          }
          d.reverse();
          for (i = k; i--; )
            d.push(0);
          d.reverse();
        } else {
          i = xd.length;
          len = yd.length;
          xLTy = i < len;
          if (xLTy)
            len = i;
          for (i = 0; i < len; i++) {
            if (xd[i] != yd[i]) {
              xLTy = xd[i] < yd[i];
              break;
            }
          }
          k = 0;
        }
        if (xLTy) {
          d = xd;
          xd = yd;
          yd = d;
          y.s = -y.s;
        }
        len = xd.length;
        for (i = yd.length - len; i > 0; --i)
          xd[len++] = 0;
        for (i = yd.length; i > k; ) {
          if (xd[--i] < yd[i]) {
            for (j = i; j && xd[--j] === 0; )
              xd[j] = BASE3 - 1;
            --xd[j];
            xd[i] += BASE3;
          }
          xd[i] -= yd[i];
        }
        for (; xd[--len] === 0; )
          xd.pop();
        for (; xd[0] === 0; xd.shift())
          --e;
        if (!xd[0])
          return new Ctor(rm === 3 ? -0 : 0);
        y.d = xd;
        y.e = getBase10Exponent2(xd, e);
        return external2 ? finalise2(y, pr, rm) : y;
      };
      P2.modulo = P2.mod = function(y) {
        var q, x = this, Ctor = x.constructor;
        y = new Ctor(y);
        if (!x.d || !y.s || y.d && !y.d[0])
          return new Ctor(NaN);
        if (!y.d || x.d && !x.d[0]) {
          return finalise2(new Ctor(x), Ctor.precision, Ctor.rounding);
        }
        external2 = false;
        if (Ctor.modulo == 9) {
          q = divide2(x, y.abs(), 0, 3, 1);
          q.s *= y.s;
        } else {
          q = divide2(x, y, 0, Ctor.modulo, 1);
        }
        q = q.times(y);
        external2 = true;
        return x.minus(q);
      };
      P2.naturalExponential = P2.exp = function() {
        return naturalExponential2(this);
      };
      P2.naturalLogarithm = P2.ln = function() {
        return naturalLogarithm2(this);
      };
      P2.negated = P2.neg = function() {
        var x = new this.constructor(this);
        x.s = -x.s;
        return finalise2(x);
      };
      P2.plus = P2.add = function(y) {
        var carry, d, e, i, k, len, pr, rm, xd, yd, x = this, Ctor = x.constructor;
        y = new Ctor(y);
        if (!x.d || !y.d) {
          if (!x.s || !y.s)
            y = new Ctor(NaN);
          else if (!x.d)
            y = new Ctor(y.d || x.s === y.s ? x : NaN);
          return y;
        }
        if (x.s != y.s) {
          y.s = -y.s;
          return x.minus(y);
        }
        xd = x.d;
        yd = y.d;
        pr = Ctor.precision;
        rm = Ctor.rounding;
        if (!xd[0] || !yd[0]) {
          if (!yd[0])
            y = new Ctor(x);
          return external2 ? finalise2(y, pr, rm) : y;
        }
        k = mathfloor3(x.e / LOG_BASE3);
        e = mathfloor3(y.e / LOG_BASE3);
        xd = xd.slice();
        i = k - e;
        if (i) {
          if (i < 0) {
            d = xd;
            i = -i;
            len = yd.length;
          } else {
            d = yd;
            e = k;
            len = xd.length;
          }
          k = Math.ceil(pr / LOG_BASE3);
          len = k > len ? k + 1 : len + 1;
          if (i > len) {
            i = len;
            d.length = 1;
          }
          d.reverse();
          for (; i--; )
            d.push(0);
          d.reverse();
        }
        len = xd.length;
        i = yd.length;
        if (len - i < 0) {
          i = len;
          d = yd;
          yd = xd;
          xd = d;
        }
        for (carry = 0; i; ) {
          carry = (xd[--i] = xd[i] + yd[i] + carry) / BASE3 | 0;
          xd[i] %= BASE3;
        }
        if (carry) {
          xd.unshift(carry);
          ++e;
        }
        for (len = xd.length; xd[--len] == 0; )
          xd.pop();
        y.d = xd;
        y.e = getBase10Exponent2(xd, e);
        return external2 ? finalise2(y, pr, rm) : y;
      };
      P2.precision = P2.sd = function(z) {
        var k, x = this;
        if (z !== void 0 && z !== !!z && z !== 1 && z !== 0)
          throw Error(invalidArgument2 + z);
        if (x.d) {
          k = getPrecision2(x.d);
          if (z && x.e + 1 > k)
            k = x.e + 1;
        } else {
          k = NaN;
        }
        return k;
      };
      P2.round = function() {
        var x = this, Ctor = x.constructor;
        return finalise2(new Ctor(x), x.e + 1, Ctor.rounding);
      };
      P2.sine = P2.sin = function() {
        var pr, rm, x = this, Ctor = x.constructor;
        if (!x.isFinite())
          return new Ctor(NaN);
        if (x.isZero())
          return new Ctor(x);
        pr = Ctor.precision;
        rm = Ctor.rounding;
        Ctor.precision = pr + Math.max(x.e, x.sd()) + LOG_BASE3;
        Ctor.rounding = 1;
        x = sine2(Ctor, toLessThanHalfPi2(Ctor, x));
        Ctor.precision = pr;
        Ctor.rounding = rm;
        return finalise2(quadrant2 > 2 ? x.neg() : x, pr, rm, true);
      };
      P2.squareRoot = P2.sqrt = function() {
        var m, n, sd, r, rep, t, x = this, d = x.d, e = x.e, s = x.s, Ctor = x.constructor;
        if (s !== 1 || !d || !d[0]) {
          return new Ctor(!s || s < 0 && (!d || d[0]) ? NaN : d ? x : 1 / 0);
        }
        external2 = false;
        s = Math.sqrt(+x);
        if (s == 0 || s == 1 / 0) {
          n = digitsToString2(d);
          if ((n.length + e) % 2 == 0)
            n += "0";
          s = Math.sqrt(n);
          e = mathfloor3((e + 1) / 2) - (e < 0 || e % 2);
          if (s == 1 / 0) {
            n = "5e" + e;
          } else {
            n = s.toExponential();
            n = n.slice(0, n.indexOf("e") + 1) + e;
          }
          r = new Ctor(n);
        } else {
          r = new Ctor(s.toString());
        }
        sd = (e = Ctor.precision) + 3;
        for (; ; ) {
          t = r;
          r = t.plus(divide2(x, t, sd + 2, 1)).times(0.5);
          if (digitsToString2(t.d).slice(0, sd) === (n = digitsToString2(r.d)).slice(0, sd)) {
            n = n.slice(sd - 3, sd + 1);
            if (n == "9999" || !rep && n == "4999") {
              if (!rep) {
                finalise2(t, e + 1, 0);
                if (t.times(t).eq(x)) {
                  r = t;
                  break;
                }
              }
              sd += 4;
              rep = 1;
            } else {
              if (!+n || !+n.slice(1) && n.charAt(0) == "5") {
                finalise2(r, e + 1, 1);
                m = !r.times(r).eq(x);
              }
              break;
            }
          }
        }
        external2 = true;
        return finalise2(r, e, Ctor.rounding, m);
      };
      P2.tangent = P2.tan = function() {
        var pr, rm, x = this, Ctor = x.constructor;
        if (!x.isFinite())
          return new Ctor(NaN);
        if (x.isZero())
          return new Ctor(x);
        pr = Ctor.precision;
        rm = Ctor.rounding;
        Ctor.precision = pr + 10;
        Ctor.rounding = 1;
        x = x.sin();
        x.s = 1;
        x = divide2(x, new Ctor(1).minus(x.times(x)).sqrt(), pr + 10, 0);
        Ctor.precision = pr;
        Ctor.rounding = rm;
        return finalise2(quadrant2 == 2 || quadrant2 == 4 ? x.neg() : x, pr, rm, true);
      };
      P2.times = P2.mul = function(y) {
        var carry, e, i, k, r, rL, t, xdL, ydL, x = this, Ctor = x.constructor, xd = x.d, yd = (y = new Ctor(y)).d;
        y.s *= x.s;
        if (!xd || !xd[0] || !yd || !yd[0]) {
          return new Ctor(!y.s || xd && !xd[0] && !yd || yd && !yd[0] && !xd ? NaN : !xd || !yd ? y.s / 0 : y.s * 0);
        }
        e = mathfloor3(x.e / LOG_BASE3) + mathfloor3(y.e / LOG_BASE3);
        xdL = xd.length;
        ydL = yd.length;
        if (xdL < ydL) {
          r = xd;
          xd = yd;
          yd = r;
          rL = xdL;
          xdL = ydL;
          ydL = rL;
        }
        r = [];
        rL = xdL + ydL;
        for (i = rL; i--; )
          r.push(0);
        for (i = ydL; --i >= 0; ) {
          carry = 0;
          for (k = xdL + i; k > i; ) {
            t = r[k] + yd[i] * xd[k - i - 1] + carry;
            r[k--] = t % BASE3 | 0;
            carry = t / BASE3 | 0;
          }
          r[k] = (r[k] + carry) % BASE3 | 0;
        }
        for (; !r[--rL]; )
          r.pop();
        if (carry)
          ++e;
        else
          r.shift();
        y.d = r;
        y.e = getBase10Exponent2(r, e);
        return external2 ? finalise2(y, Ctor.precision, Ctor.rounding) : y;
      };
      P2.toBinary = function(sd, rm) {
        return toStringBinary2(this, 2, sd, rm);
      };
      P2.toDecimalPlaces = P2.toDP = function(dp, rm) {
        var x = this, Ctor = x.constructor;
        x = new Ctor(x);
        if (dp === void 0)
          return x;
        checkInt322(dp, 0, MAX_DIGITS2);
        if (rm === void 0)
          rm = Ctor.rounding;
        else
          checkInt322(rm, 0, 8);
        return finalise2(x, dp + x.e + 1, rm);
      };
      P2.toExponential = function(dp, rm) {
        var str, x = this, Ctor = x.constructor;
        if (dp === void 0) {
          str = finiteToString2(x, true);
        } else {
          checkInt322(dp, 0, MAX_DIGITS2);
          if (rm === void 0)
            rm = Ctor.rounding;
          else
            checkInt322(rm, 0, 8);
          x = finalise2(new Ctor(x), dp + 1, rm);
          str = finiteToString2(x, true, dp + 1);
        }
        return x.isNeg() && !x.isZero() ? "-" + str : str;
      };
      P2.toFixed = function(dp, rm) {
        var str, y, x = this, Ctor = x.constructor;
        if (dp === void 0) {
          str = finiteToString2(x);
        } else {
          checkInt322(dp, 0, MAX_DIGITS2);
          if (rm === void 0)
            rm = Ctor.rounding;
          else
            checkInt322(rm, 0, 8);
          y = finalise2(new Ctor(x), dp + x.e + 1, rm);
          str = finiteToString2(y, false, dp + y.e + 1);
        }
        return x.isNeg() && !x.isZero() ? "-" + str : str;
      };
      P2.toFraction = function(maxD) {
        var d, d0, d1, d2, e, k, n, n0, n1, pr, q, r, x = this, xd = x.d, Ctor = x.constructor;
        if (!xd)
          return new Ctor(x);
        n1 = d0 = new Ctor(1);
        d1 = n0 = new Ctor(0);
        d = new Ctor(d1);
        e = d.e = getPrecision2(xd) - x.e - 1;
        k = e % LOG_BASE3;
        d.d[0] = mathpow2(10, k < 0 ? LOG_BASE3 + k : k);
        if (maxD == null) {
          maxD = e > 0 ? d : n1;
        } else {
          n = new Ctor(maxD);
          if (!n.isInt() || n.lt(n1))
            throw Error(invalidArgument2 + n);
          maxD = n.gt(d) ? e > 0 ? d : n1 : n;
        }
        external2 = false;
        n = new Ctor(digitsToString2(xd));
        pr = Ctor.precision;
        Ctor.precision = e = xd.length * LOG_BASE3 * 2;
        for (; ; ) {
          q = divide2(n, d, 0, 1, 1);
          d2 = d0.plus(q.times(d1));
          if (d2.cmp(maxD) == 1)
            break;
          d0 = d1;
          d1 = d2;
          d2 = n1;
          n1 = n0.plus(q.times(d2));
          n0 = d2;
          d2 = d;
          d = n.minus(q.times(d2));
          n = d2;
        }
        d2 = divide2(maxD.minus(d0), d1, 0, 1, 1);
        n0 = n0.plus(d2.times(n1));
        d0 = d0.plus(d2.times(d1));
        n0.s = n1.s = x.s;
        r = divide2(n1, d1, e, 1).minus(x).abs().cmp(divide2(n0, d0, e, 1).minus(x).abs()) < 1 ? [n1, d1] : [n0, d0];
        Ctor.precision = pr;
        external2 = true;
        return r;
      };
      P2.toHexadecimal = P2.toHex = function(sd, rm) {
        return toStringBinary2(this, 16, sd, rm);
      };
      P2.toNearest = function(y, rm) {
        var x = this, Ctor = x.constructor;
        x = new Ctor(x);
        if (y == null) {
          if (!x.d)
            return x;
          y = new Ctor(1);
          rm = Ctor.rounding;
        } else {
          y = new Ctor(y);
          if (rm === void 0) {
            rm = Ctor.rounding;
          } else {
            checkInt322(rm, 0, 8);
          }
          if (!x.d)
            return y.s ? x : y;
          if (!y.d) {
            if (y.s)
              y.s = x.s;
            return y;
          }
        }
        if (y.d[0]) {
          external2 = false;
          x = divide2(x, y, 0, rm, 1).times(y);
          external2 = true;
          finalise2(x);
        } else {
          y.s = x.s;
          x = y;
        }
        return x;
      };
      P2.toNumber = function() {
        return +this;
      };
      P2.toOctal = function(sd, rm) {
        return toStringBinary2(this, 8, sd, rm);
      };
      P2.toPower = P2.pow = function(y) {
        var e, k, pr, r, rm, s, x = this, Ctor = x.constructor, yn = +(y = new Ctor(y));
        if (!x.d || !y.d || !x.d[0] || !y.d[0])
          return new Ctor(mathpow2(+x, yn));
        x = new Ctor(x);
        if (x.eq(1))
          return x;
        pr = Ctor.precision;
        rm = Ctor.rounding;
        if (y.eq(1))
          return finalise2(x, pr, rm);
        e = mathfloor3(y.e / LOG_BASE3);
        if (e >= y.d.length - 1 && (k = yn < 0 ? -yn : yn) <= MAX_SAFE_INTEGER3) {
          r = intPow2(Ctor, x, k, pr);
          return y.s < 0 ? new Ctor(1).div(r) : finalise2(r, pr, rm);
        }
        s = x.s;
        if (s < 0) {
          if (e < y.d.length - 1)
            return new Ctor(NaN);
          if ((y.d[e] & 1) == 0)
            s = 1;
          if (x.e == 0 && x.d[0] == 1 && x.d.length == 1) {
            x.s = s;
            return x;
          }
        }
        k = mathpow2(+x, yn);
        e = k == 0 || !isFinite(k) ? mathfloor3(yn * (Math.log("0." + digitsToString2(x.d)) / Math.LN10 + x.e + 1)) : new Ctor(k + "").e;
        if (e > Ctor.maxE + 1 || e < Ctor.minE - 1)
          return new Ctor(e > 0 ? s / 0 : 0);
        external2 = false;
        Ctor.rounding = x.s = 1;
        k = Math.min(12, (e + "").length);
        r = naturalExponential2(y.times(naturalLogarithm2(x, pr + k)), pr);
        if (r.d) {
          r = finalise2(r, pr + 5, 1);
          if (checkRoundingDigits2(r.d, pr, rm)) {
            e = pr + 10;
            r = finalise2(naturalExponential2(y.times(naturalLogarithm2(x, e + k)), e), e + 5, 1);
            if (+digitsToString2(r.d).slice(pr + 1, pr + 15) + 1 == 1e14) {
              r = finalise2(r, pr + 1, 0);
            }
          }
        }
        r.s = s;
        external2 = true;
        Ctor.rounding = rm;
        return finalise2(r, pr, rm);
      };
      P2.toPrecision = function(sd, rm) {
        var str, x = this, Ctor = x.constructor;
        if (sd === void 0) {
          str = finiteToString2(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);
        } else {
          checkInt322(sd, 1, MAX_DIGITS2);
          if (rm === void 0)
            rm = Ctor.rounding;
          else
            checkInt322(rm, 0, 8);
          x = finalise2(new Ctor(x), sd, rm);
          str = finiteToString2(x, sd <= x.e || x.e <= Ctor.toExpNeg, sd);
        }
        return x.isNeg() && !x.isZero() ? "-" + str : str;
      };
      P2.toSignificantDigits = P2.toSD = function(sd, rm) {
        var x = this, Ctor = x.constructor;
        if (sd === void 0) {
          sd = Ctor.precision;
          rm = Ctor.rounding;
        } else {
          checkInt322(sd, 1, MAX_DIGITS2);
          if (rm === void 0)
            rm = Ctor.rounding;
          else
            checkInt322(rm, 0, 8);
        }
        return finalise2(new Ctor(x), sd, rm);
      };
      P2.toString = function() {
        var x = this, Ctor = x.constructor, str = finiteToString2(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);
        return x.isNeg() && !x.isZero() ? "-" + str : str;
      };
      P2.truncated = P2.trunc = function() {
        return finalise2(new this.constructor(this), this.e + 1, 1);
      };
      P2.valueOf = P2.toJSON = function() {
        var x = this, Ctor = x.constructor, str = finiteToString2(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);
        return x.isNeg() ? "-" + str : str;
      };
      function digitsToString2(d) {
        var i, k, ws, indexOfLastWord = d.length - 1, str = "", w = d[0];
        if (indexOfLastWord > 0) {
          str += w;
          for (i = 1; i < indexOfLastWord; i++) {
            ws = d[i] + "";
            k = LOG_BASE3 - ws.length;
            if (k)
              str += getZeroString2(k);
            str += ws;
          }
          w = d[i];
          ws = w + "";
          k = LOG_BASE3 - ws.length;
          if (k)
            str += getZeroString2(k);
        } else if (w === 0) {
          return "0";
        }
        for (; w % 10 === 0; )
          w /= 10;
        return str + w;
      }
      function checkInt322(i, min3, max3) {
        if (i !== ~~i || i < min3 || i > max3) {
          throw Error(invalidArgument2 + i);
        }
      }
      function checkRoundingDigits2(d, i, rm, repeating) {
        var di, k, r, rd;
        for (k = d[0]; k >= 10; k /= 10)
          --i;
        if (--i < 0) {
          i += LOG_BASE3;
          di = 0;
        } else {
          di = Math.ceil((i + 1) / LOG_BASE3);
          i %= LOG_BASE3;
        }
        k = mathpow2(10, LOG_BASE3 - i);
        rd = d[di] % k | 0;
        if (repeating == null) {
          if (i < 3) {
            if (i == 0)
              rd = rd / 100 | 0;
            else if (i == 1)
              rd = rd / 10 | 0;
            r = rm < 4 && rd == 99999 || rm > 3 && rd == 49999 || rd == 5e4 || rd == 0;
          } else {
            r = (rm < 4 && rd + 1 == k || rm > 3 && rd + 1 == k / 2) && (d[di + 1] / k / 100 | 0) == mathpow2(10, i - 2) - 1 || (rd == k / 2 || rd == 0) && (d[di + 1] / k / 100 | 0) == 0;
          }
        } else {
          if (i < 4) {
            if (i == 0)
              rd = rd / 1e3 | 0;
            else if (i == 1)
              rd = rd / 100 | 0;
            else if (i == 2)
              rd = rd / 10 | 0;
            r = (repeating || rm < 4) && rd == 9999 || !repeating && rm > 3 && rd == 4999;
          } else {
            r = ((repeating || rm < 4) && rd + 1 == k || !repeating && rm > 3 && rd + 1 == k / 2) && (d[di + 1] / k / 1e3 | 0) == mathpow2(10, i - 3) - 1;
          }
        }
        return r;
      }
      function convertBase2(str, baseIn, baseOut) {
        var j, arr = [0], arrL, i = 0, strL = str.length;
        for (; i < strL; ) {
          for (arrL = arr.length; arrL--; )
            arr[arrL] *= baseIn;
          arr[0] += NUMERALS2.indexOf(str.charAt(i++));
          for (j = 0; j < arr.length; j++) {
            if (arr[j] > baseOut - 1) {
              if (arr[j + 1] === void 0)
                arr[j + 1] = 0;
              arr[j + 1] += arr[j] / baseOut | 0;
              arr[j] %= baseOut;
            }
          }
        }
        return arr.reverse();
      }
      function cosine2(Ctor, x) {
        var k, len, y;
        if (x.isZero())
          return x;
        len = x.d.length;
        if (len < 32) {
          k = Math.ceil(len / 3);
          y = (1 / tinyPow2(4, k)).toString();
        } else {
          k = 16;
          y = "2.3283064365386962890625e-10";
        }
        Ctor.precision += k;
        x = taylorSeries2(Ctor, 1, x.times(y), new Ctor(1));
        for (var i = k; i--; ) {
          var cos2x = x.times(x);
          x = cos2x.times(cos2x).minus(cos2x).times(8).plus(1);
        }
        Ctor.precision -= k;
        return x;
      }
      var divide2 = /* @__PURE__ */ function() {
        function multiplyInteger(x, k, base) {
          var temp, carry = 0, i = x.length;
          for (x = x.slice(); i--; ) {
            temp = x[i] * k + carry;
            x[i] = temp % base | 0;
            carry = temp / base | 0;
          }
          if (carry)
            x.unshift(carry);
          return x;
        }
        function compare2(a, b, aL, bL) {
          var i, r;
          if (aL != bL) {
            r = aL > bL ? 1 : -1;
          } else {
            for (i = r = 0; i < aL; i++) {
              if (a[i] != b[i]) {
                r = a[i] > b[i] ? 1 : -1;
                break;
              }
            }
          }
          return r;
        }
        function subtract(a, b, aL, base) {
          var i = 0;
          for (; aL--; ) {
            a[aL] -= i;
            i = a[aL] < b[aL] ? 1 : 0;
            a[aL] = i * base + a[aL] - b[aL];
          }
          for (; !a[0] && a.length > 1; )
            a.shift();
        }
        return function(x, y, pr, rm, dp, base) {
          var cmp, e, i, k, logBase, more, prod, prodL, q, qd, rem, remL, rem0, sd, t, xi, xL, yd0, yL, yz, Ctor = x.constructor, sign3 = x.s == y.s ? 1 : -1, xd = x.d, yd = y.d;
          if (!xd || !xd[0] || !yd || !yd[0]) {
            return new Ctor(
              // Return NaN if either NaN, or both Infinity or 0.
              !x.s || !y.s || (xd ? yd && xd[0] == yd[0] : !yd) ? NaN : (
                // Return 0 if x is 0 or y is Infinity, or return Infinity as y is 0.
                xd && xd[0] == 0 || !yd ? sign3 * 0 : sign3 / 0
              )
            );
          }
          if (base) {
            logBase = 1;
            e = x.e - y.e;
          } else {
            base = BASE3;
            logBase = LOG_BASE3;
            e = mathfloor3(x.e / logBase) - mathfloor3(y.e / logBase);
          }
          yL = yd.length;
          xL = xd.length;
          q = new Ctor(sign3);
          qd = q.d = [];
          for (i = 0; yd[i] == (xd[i] || 0); i++)
            ;
          if (yd[i] > (xd[i] || 0))
            e--;
          if (pr == null) {
            sd = pr = Ctor.precision;
            rm = Ctor.rounding;
          } else if (dp) {
            sd = pr + (x.e - y.e) + 1;
          } else {
            sd = pr;
          }
          if (sd < 0) {
            qd.push(1);
            more = true;
          } else {
            sd = sd / logBase + 2 | 0;
            i = 0;
            if (yL == 1) {
              k = 0;
              yd = yd[0];
              sd++;
              for (; (i < xL || k) && sd--; i++) {
                t = k * base + (xd[i] || 0);
                qd[i] = t / yd | 0;
                k = t % yd | 0;
              }
              more = k || i < xL;
            } else {
              k = base / (yd[0] + 1) | 0;
              if (k > 1) {
                yd = multiplyInteger(yd, k, base);
                xd = multiplyInteger(xd, k, base);
                yL = yd.length;
                xL = xd.length;
              }
              xi = yL;
              rem = xd.slice(0, yL);
              remL = rem.length;
              for (; remL < yL; )
                rem[remL++] = 0;
              yz = yd.slice();
              yz.unshift(0);
              yd0 = yd[0];
              if (yd[1] >= base / 2)
                ++yd0;
              do {
                k = 0;
                cmp = compare2(yd, rem, yL, remL);
                if (cmp < 0) {
                  rem0 = rem[0];
                  if (yL != remL)
                    rem0 = rem0 * base + (rem[1] || 0);
                  k = rem0 / yd0 | 0;
                  if (k > 1) {
                    if (k >= base)
                      k = base - 1;
                    prod = multiplyInteger(yd, k, base);
                    prodL = prod.length;
                    remL = rem.length;
                    cmp = compare2(prod, rem, prodL, remL);
                    if (cmp == 1) {
                      k--;
                      subtract(prod, yL < prodL ? yz : yd, prodL, base);
                    }
                  } else {
                    if (k == 0)
                      cmp = k = 1;
                    prod = yd.slice();
                  }
                  prodL = prod.length;
                  if (prodL < remL)
                    prod.unshift(0);
                  subtract(rem, prod, remL, base);
                  if (cmp == -1) {
                    remL = rem.length;
                    cmp = compare2(yd, rem, yL, remL);
                    if (cmp < 1) {
                      k++;
                      subtract(rem, yL < remL ? yz : yd, remL, base);
                    }
                  }
                  remL = rem.length;
                } else if (cmp === 0) {
                  k++;
                  rem = [0];
                }
                qd[i++] = k;
                if (cmp && rem[0]) {
                  rem[remL++] = xd[xi] || 0;
                } else {
                  rem = [xd[xi]];
                  remL = 1;
                }
              } while ((xi++ < xL || rem[0] !== void 0) && sd--);
              more = rem[0] !== void 0;
            }
            if (!qd[0])
              qd.shift();
          }
          if (logBase == 1) {
            q.e = e;
            inexact2 = more;
          } else {
            for (i = 1, k = qd[0]; k >= 10; k /= 10)
              i++;
            q.e = i + e * logBase - 1;
            finalise2(q, dp ? pr + q.e + 1 : pr, rm, more);
          }
          return q;
        };
      }();
      function finalise2(x, sd, rm, isTruncated) {
        var digits, i, j, k, rd, roundUp, w, xd, xdi, Ctor = x.constructor;
        out:
          if (sd != null) {
            xd = x.d;
            if (!xd)
              return x;
            for (digits = 1, k = xd[0]; k >= 10; k /= 10)
              digits++;
            i = sd - digits;
            if (i < 0) {
              i += LOG_BASE3;
              j = sd;
              w = xd[xdi = 0];
              rd = w / mathpow2(10, digits - j - 1) % 10 | 0;
            } else {
              xdi = Math.ceil((i + 1) / LOG_BASE3);
              k = xd.length;
              if (xdi >= k) {
                if (isTruncated) {
                  for (; k++ <= xdi; )
                    xd.push(0);
                  w = rd = 0;
                  digits = 1;
                  i %= LOG_BASE3;
                  j = i - LOG_BASE3 + 1;
                } else {
                  break out;
                }
              } else {
                w = k = xd[xdi];
                for (digits = 1; k >= 10; k /= 10)
                  digits++;
                i %= LOG_BASE3;
                j = i - LOG_BASE3 + digits;
                rd = j < 0 ? 0 : w / mathpow2(10, digits - j - 1) % 10 | 0;
              }
            }
            isTruncated = isTruncated || sd < 0 || xd[xdi + 1] !== void 0 || (j < 0 ? w : w % mathpow2(10, digits - j - 1));
            roundUp = rm < 4 ? (rd || isTruncated) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : rd > 5 || rd == 5 && (rm == 4 || isTruncated || rm == 6 && // Check whether the digit to the left of the rounding digit is odd.
            (i > 0 ? j > 0 ? w / mathpow2(10, digits - j) : 0 : xd[xdi - 1]) % 10 & 1 || rm == (x.s < 0 ? 8 : 7));
            if (sd < 1 || !xd[0]) {
              xd.length = 0;
              if (roundUp) {
                sd -= x.e + 1;
                xd[0] = mathpow2(10, (LOG_BASE3 - sd % LOG_BASE3) % LOG_BASE3);
                x.e = -sd || 0;
              } else {
                xd[0] = x.e = 0;
              }
              return x;
            }
            if (i == 0) {
              xd.length = xdi;
              k = 1;
              xdi--;
            } else {
              xd.length = xdi + 1;
              k = mathpow2(10, LOG_BASE3 - i);
              xd[xdi] = j > 0 ? (w / mathpow2(10, digits - j) % mathpow2(10, j) | 0) * k : 0;
            }
            if (roundUp) {
              for (; ; ) {
                if (xdi == 0) {
                  for (i = 1, j = xd[0]; j >= 10; j /= 10)
                    i++;
                  j = xd[0] += k;
                  for (k = 1; j >= 10; j /= 10)
                    k++;
                  if (i != k) {
                    x.e++;
                    if (xd[0] == BASE3)
                      xd[0] = 1;
                  }
                  break;
                } else {
                  xd[xdi] += k;
                  if (xd[xdi] != BASE3)
                    break;
                  xd[xdi--] = 0;
                  k = 1;
                }
              }
            }
            for (i = xd.length; xd[--i] === 0; )
              xd.pop();
          }
        if (external2) {
          if (x.e > Ctor.maxE) {
            x.d = null;
            x.e = NaN;
          } else if (x.e < Ctor.minE) {
            x.e = 0;
            x.d = [0];
          }
        }
        return x;
      }
      function finiteToString2(x, isExp, sd) {
        if (!x.isFinite())
          return nonFiniteToString2(x);
        var k, e = x.e, str = digitsToString2(x.d), len = str.length;
        if (isExp) {
          if (sd && (k = sd - len) > 0) {
            str = str.charAt(0) + "." + str.slice(1) + getZeroString2(k);
          } else if (len > 1) {
            str = str.charAt(0) + "." + str.slice(1);
          }
          str = str + (x.e < 0 ? "e" : "e+") + x.e;
        } else if (e < 0) {
          str = "0." + getZeroString2(-e - 1) + str;
          if (sd && (k = sd - len) > 0)
            str += getZeroString2(k);
        } else if (e >= len) {
          str += getZeroString2(e + 1 - len);
          if (sd && (k = sd - e - 1) > 0)
            str = str + "." + getZeroString2(k);
        } else {
          if ((k = e + 1) < len)
            str = str.slice(0, k) + "." + str.slice(k);
          if (sd && (k = sd - len) > 0) {
            if (e + 1 === len)
              str += ".";
            str += getZeroString2(k);
          }
        }
        return str;
      }
      function getBase10Exponent2(digits, e) {
        var w = digits[0];
        for (e *= LOG_BASE3; w >= 10; w /= 10)
          e++;
        return e;
      }
      function getLn102(Ctor, sd, pr) {
        if (sd > LN10_PRECISION2) {
          external2 = true;
          if (pr)
            Ctor.precision = pr;
          throw Error(precisionLimitExceeded2);
        }
        return finalise2(new Ctor(LN102), sd, 1, true);
      }
      function getPi2(Ctor, sd, rm) {
        if (sd > PI_PRECISION2)
          throw Error(precisionLimitExceeded2);
        return finalise2(new Ctor(PI2), sd, rm, true);
      }
      function getPrecision2(digits) {
        var w = digits.length - 1, len = w * LOG_BASE3 + 1;
        w = digits[w];
        if (w) {
          for (; w % 10 == 0; w /= 10)
            len--;
          for (w = digits[0]; w >= 10; w /= 10)
            len++;
        }
        return len;
      }
      function getZeroString2(k) {
        var zs = "";
        for (; k--; )
          zs += "0";
        return zs;
      }
      function intPow2(Ctor, x, n, pr) {
        var isTruncated, r = new Ctor(1), k = Math.ceil(pr / LOG_BASE3 + 4);
        external2 = false;
        for (; ; ) {
          if (n % 2) {
            r = r.times(x);
            if (truncate2(r.d, k))
              isTruncated = true;
          }
          n = mathfloor3(n / 2);
          if (n === 0) {
            n = r.d.length - 1;
            if (isTruncated && r.d[n] === 0)
              ++r.d[n];
            break;
          }
          x = x.times(x);
          truncate2(x.d, k);
        }
        external2 = true;
        return r;
      }
      function isOdd3(n) {
        return n.d[n.d.length - 1] & 1;
      }
      function maxOrMin2(Ctor, args, n) {
        var k, y, x = new Ctor(args[0]), i = 0;
        for (; ++i < args.length; ) {
          y = new Ctor(args[i]);
          if (!y.s) {
            x = y;
            break;
          }
          k = x.cmp(y);
          if (k === n || k === 0 && x.s === n) {
            x = y;
          }
        }
        return x;
      }
      function naturalExponential2(x, sd) {
        var denominator, guard, j, pow4, sum3, t, wpr, rep = 0, i = 0, k = 0, Ctor = x.constructor, rm = Ctor.rounding, pr = Ctor.precision;
        if (!x.d || !x.d[0] || x.e > 17) {
          return new Ctor(x.d ? !x.d[0] ? 1 : x.s < 0 ? 0 : 1 / 0 : x.s ? x.s < 0 ? 0 : x : 0 / 0);
        }
        if (sd == null) {
          external2 = false;
          wpr = pr;
        } else {
          wpr = sd;
        }
        t = new Ctor(0.03125);
        while (x.e > -2) {
          x = x.times(t);
          k += 5;
        }
        guard = Math.log(mathpow2(2, k)) / Math.LN10 * 2 + 5 | 0;
        wpr += guard;
        denominator = pow4 = sum3 = new Ctor(1);
        Ctor.precision = wpr;
        for (; ; ) {
          pow4 = finalise2(pow4.times(x), wpr, 1);
          denominator = denominator.times(++i);
          t = sum3.plus(divide2(pow4, denominator, wpr, 1));
          if (digitsToString2(t.d).slice(0, wpr) === digitsToString2(sum3.d).slice(0, wpr)) {
            j = k;
            while (j--)
              sum3 = finalise2(sum3.times(sum3), wpr, 1);
            if (sd == null) {
              if (rep < 3 && checkRoundingDigits2(sum3.d, wpr - guard, rm, rep)) {
                Ctor.precision = wpr += 10;
                denominator = pow4 = t = new Ctor(1);
                i = 0;
                rep++;
              } else {
                return finalise2(sum3, Ctor.precision = pr, rm, external2 = true);
              }
            } else {
              Ctor.precision = pr;
              return sum3;
            }
          }
          sum3 = t;
        }
      }
      function naturalLogarithm2(y, sd) {
        var c, c0, denominator, e, numerator, rep, sum3, t, wpr, x1, x2, n = 1, guard = 10, x = y, xd = x.d, Ctor = x.constructor, rm = Ctor.rounding, pr = Ctor.precision;
        if (x.s < 0 || !xd || !xd[0] || !x.e && xd[0] == 1 && xd.length == 1) {
          return new Ctor(xd && !xd[0] ? -1 / 0 : x.s != 1 ? NaN : xd ? 0 : x);
        }
        if (sd == null) {
          external2 = false;
          wpr = pr;
        } else {
          wpr = sd;
        }
        Ctor.precision = wpr += guard;
        c = digitsToString2(xd);
        c0 = c.charAt(0);
        if (Math.abs(e = x.e) < 15e14) {
          while (c0 < 7 && c0 != 1 || c0 == 1 && c.charAt(1) > 3) {
            x = x.times(y);
            c = digitsToString2(x.d);
            c0 = c.charAt(0);
            n++;
          }
          e = x.e;
          if (c0 > 1) {
            x = new Ctor("0." + c);
            e++;
          } else {
            x = new Ctor(c0 + "." + c.slice(1));
          }
        } else {
          t = getLn102(Ctor, wpr + 2, pr).times(e + "");
          x = naturalLogarithm2(new Ctor(c0 + "." + c.slice(1)), wpr - guard).plus(t);
          Ctor.precision = pr;
          return sd == null ? finalise2(x, pr, rm, external2 = true) : x;
        }
        x1 = x;
        sum3 = numerator = x = divide2(x.minus(1), x.plus(1), wpr, 1);
        x2 = finalise2(x.times(x), wpr, 1);
        denominator = 3;
        for (; ; ) {
          numerator = finalise2(numerator.times(x2), wpr, 1);
          t = sum3.plus(divide2(numerator, new Ctor(denominator), wpr, 1));
          if (digitsToString2(t.d).slice(0, wpr) === digitsToString2(sum3.d).slice(0, wpr)) {
            sum3 = sum3.times(2);
            if (e !== 0)
              sum3 = sum3.plus(getLn102(Ctor, wpr + 2, pr).times(e + ""));
            sum3 = divide2(sum3, new Ctor(n), wpr, 1);
            if (sd == null) {
              if (checkRoundingDigits2(sum3.d, wpr - guard, rm, rep)) {
                Ctor.precision = wpr += guard;
                t = numerator = x = divide2(x1.minus(1), x1.plus(1), wpr, 1);
                x2 = finalise2(x.times(x), wpr, 1);
                denominator = rep = 1;
              } else {
                return finalise2(sum3, Ctor.precision = pr, rm, external2 = true);
              }
            } else {
              Ctor.precision = pr;
              return sum3;
            }
          }
          sum3 = t;
          denominator += 2;
        }
      }
      function nonFiniteToString2(x) {
        return String(x.s * x.s / 0);
      }
      function parseDecimal2(x, str) {
        var e, i, len;
        if ((e = str.indexOf(".")) > -1)
          str = str.replace(".", "");
        if ((i = str.search(/e/i)) > 0) {
          if (e < 0)
            e = i;
          e += +str.slice(i + 1);
          str = str.substring(0, i);
        } else if (e < 0) {
          e = str.length;
        }
        for (i = 0; str.charCodeAt(i) === 48; i++)
          ;
        for (len = str.length; str.charCodeAt(len - 1) === 48; --len)
          ;
        str = str.slice(i, len);
        if (str) {
          len -= i;
          x.e = e = e - i - 1;
          x.d = [];
          i = (e + 1) % LOG_BASE3;
          if (e < 0)
            i += LOG_BASE3;
          if (i < len) {
            if (i)
              x.d.push(+str.slice(0, i));
            for (len -= LOG_BASE3; i < len; )
              x.d.push(+str.slice(i, i += LOG_BASE3));
            str = str.slice(i);
            i = LOG_BASE3 - str.length;
          } else {
            i -= len;
          }
          for (; i--; )
            str += "0";
          x.d.push(+str);
          if (external2) {
            if (x.e > x.constructor.maxE) {
              x.d = null;
              x.e = NaN;
            } else if (x.e < x.constructor.minE) {
              x.e = 0;
              x.d = [0];
            }
          }
        } else {
          x.e = 0;
          x.d = [0];
        }
        return x;
      }
      function parseOther2(x, str) {
        var base, Ctor, divisor, i, isFloat, len, p, xd, xe;
        if (str.indexOf("_") > -1) {
          str = str.replace(/(\d)_(?=\d)/g, "$1");
          if (isDecimal2.test(str))
            return parseDecimal2(x, str);
        } else if (str === "Infinity" || str === "NaN") {
          if (!+str)
            x.s = NaN;
          x.e = NaN;
          x.d = null;
          return x;
        }
        if (isHex2.test(str)) {
          base = 16;
          str = str.toLowerCase();
        } else if (isBinary2.test(str)) {
          base = 2;
        } else if (isOctal2.test(str)) {
          base = 8;
        } else {
          throw Error(invalidArgument2 + str);
        }
        i = str.search(/p/i);
        if (i > 0) {
          p = +str.slice(i + 1);
          str = str.substring(2, i);
        } else {
          str = str.slice(2);
        }
        i = str.indexOf(".");
        isFloat = i >= 0;
        Ctor = x.constructor;
        if (isFloat) {
          str = str.replace(".", "");
          len = str.length;
          i = len - i;
          divisor = intPow2(Ctor, new Ctor(base), i, i * 2);
        }
        xd = convertBase2(str, base, BASE3);
        xe = xd.length - 1;
        for (i = xe; xd[i] === 0; --i)
          xd.pop();
        if (i < 0)
          return new Ctor(x.s * 0);
        x.e = getBase10Exponent2(xd, xe);
        x.d = xd;
        external2 = false;
        if (isFloat)
          x = divide2(x, divisor, len * 4);
        if (p)
          x = x.times(Math.abs(p) < 54 ? mathpow2(2, p) : Decimal2.pow(2, p));
        external2 = true;
        return x;
      }
      function sine2(Ctor, x) {
        var k, len = x.d.length;
        if (len < 3) {
          return x.isZero() ? x : taylorSeries2(Ctor, 2, x, x);
        }
        k = 1.4 * Math.sqrt(len);
        k = k > 16 ? 16 : k | 0;
        x = x.times(1 / tinyPow2(5, k));
        x = taylorSeries2(Ctor, 2, x, x);
        var sin2_x, d5 = new Ctor(5), d16 = new Ctor(16), d20 = new Ctor(20);
        for (; k--; ) {
          sin2_x = x.times(x);
          x = x.times(d5.plus(sin2_x.times(d16.times(sin2_x).minus(d20))));
        }
        return x;
      }
      function taylorSeries2(Ctor, n, x, y, isHyperbolic) {
        var j, t, u, x2, i = 1, pr = Ctor.precision, k = Math.ceil(pr / LOG_BASE3);
        external2 = false;
        x2 = x.times(x);
        u = new Ctor(y);
        for (; ; ) {
          t = divide2(u.times(x2), new Ctor(n++ * n++), pr, 1);
          u = isHyperbolic ? y.plus(t) : y.minus(t);
          y = divide2(t.times(x2), new Ctor(n++ * n++), pr, 1);
          t = u.plus(y);
          if (t.d[k] !== void 0) {
            for (j = k; t.d[j] === u.d[j] && j--; )
              ;
            if (j == -1)
              break;
          }
          j = u;
          u = y;
          y = t;
          t = j;
          i++;
        }
        external2 = true;
        t.d.length = k + 1;
        return t;
      }
      function tinyPow2(b, e) {
        var n = b;
        while (--e)
          n *= b;
        return n;
      }
      function toLessThanHalfPi2(Ctor, x) {
        var t, isNeg = x.s < 0, pi = getPi2(Ctor, Ctor.precision, 1), halfPi = pi.times(0.5);
        x = x.abs();
        if (x.lte(halfPi)) {
          quadrant2 = isNeg ? 4 : 1;
          return x;
        }
        t = x.divToInt(pi);
        if (t.isZero()) {
          quadrant2 = isNeg ? 3 : 2;
        } else {
          x = x.minus(t.times(pi));
          if (x.lte(halfPi)) {
            quadrant2 = isOdd3(t) ? isNeg ? 2 : 3 : isNeg ? 4 : 1;
            return x;
          }
          quadrant2 = isOdd3(t) ? isNeg ? 1 : 4 : isNeg ? 3 : 2;
        }
        return x.minus(pi).abs();
      }
      function toStringBinary2(x, baseOut, sd, rm) {
        var base, e, i, k, len, roundUp, str, xd, y, Ctor = x.constructor, isExp = sd !== void 0;
        if (isExp) {
          checkInt322(sd, 1, MAX_DIGITS2);
          if (rm === void 0)
            rm = Ctor.rounding;
          else
            checkInt322(rm, 0, 8);
        } else {
          sd = Ctor.precision;
          rm = Ctor.rounding;
        }
        if (!x.isFinite()) {
          str = nonFiniteToString2(x);
        } else {
          str = finiteToString2(x);
          i = str.indexOf(".");
          if (isExp) {
            base = 2;
            if (baseOut == 16) {
              sd = sd * 4 - 3;
            } else if (baseOut == 8) {
              sd = sd * 3 - 2;
            }
          } else {
            base = baseOut;
          }
          if (i >= 0) {
            str = str.replace(".", "");
            y = new Ctor(1);
            y.e = str.length - i;
            y.d = convertBase2(finiteToString2(y), 10, base);
            y.e = y.d.length;
          }
          xd = convertBase2(str, 10, base);
          e = len = xd.length;
          for (; xd[--len] == 0; )
            xd.pop();
          if (!xd[0]) {
            str = isExp ? "0p+0" : "0";
          } else {
            if (i < 0) {
              e--;
            } else {
              x = new Ctor(x);
              x.d = xd;
              x.e = e;
              x = divide2(x, y, sd, rm, 0, base);
              xd = x.d;
              e = x.e;
              roundUp = inexact2;
            }
            i = xd[sd];
            k = base / 2;
            roundUp = roundUp || xd[sd + 1] !== void 0;
            roundUp = rm < 4 ? (i !== void 0 || roundUp) && (rm === 0 || rm === (x.s < 0 ? 3 : 2)) : i > k || i === k && (rm === 4 || roundUp || rm === 6 && xd[sd - 1] & 1 || rm === (x.s < 0 ? 8 : 7));
            xd.length = sd;
            if (roundUp) {
              for (; ++xd[--sd] > base - 1; ) {
                xd[sd] = 0;
                if (!sd) {
                  ++e;
                  xd.unshift(1);
                }
              }
            }
            for (len = xd.length; !xd[len - 1]; --len)
              ;
            for (i = 0, str = ""; i < len; i++)
              str += NUMERALS2.charAt(xd[i]);
            if (isExp) {
              if (len > 1) {
                if (baseOut == 16 || baseOut == 8) {
                  i = baseOut == 16 ? 4 : 3;
                  for (--len; len % i; len++)
                    str += "0";
                  xd = convertBase2(str, base, baseOut);
                  for (len = xd.length; !xd[len - 1]; --len)
                    ;
                  for (i = 1, str = "1."; i < len; i++)
                    str += NUMERALS2.charAt(xd[i]);
                } else {
                  str = str.charAt(0) + "." + str.slice(1);
                }
              }
              str = str + (e < 0 ? "p" : "p+") + e;
            } else if (e < 0) {
              for (; ++e; )
                str = "0" + str;
              str = "0." + str;
            } else {
              if (++e > len)
                for (e -= len; e--; )
                  str += "0";
              else if (e < len)
                str = str.slice(0, e) + "." + str.slice(e);
            }
          }
          str = (baseOut == 16 ? "0x" : baseOut == 2 ? "0b" : baseOut == 8 ? "0o" : "") + str;
        }
        return x.s < 0 ? "-" + str : str;
      }
      function truncate2(arr, len) {
        if (arr.length > len) {
          arr.length = len;
          return true;
        }
      }
      function abs2(x) {
        return new this(x).abs();
      }
      function acos2(x) {
        return new this(x).acos();
      }
      function acosh2(x) {
        return new this(x).acosh();
      }
      function add2(x, y) {
        return new this(x).plus(y);
      }
      function asin2(x) {
        return new this(x).asin();
      }
      function asinh2(x) {
        return new this(x).asinh();
      }
      function atan3(x) {
        return new this(x).atan();
      }
      function atanh2(x) {
        return new this(x).atanh();
      }
      function atan22(y, x) {
        y = new this(y);
        x = new this(x);
        var r, pr = this.precision, rm = this.rounding, wpr = pr + 4;
        if (!y.s || !x.s) {
          r = new this(NaN);
        } else if (!y.d && !x.d) {
          r = getPi2(this, wpr, 1).times(x.s > 0 ? 0.25 : 0.75);
          r.s = y.s;
        } else if (!x.d || y.isZero()) {
          r = x.s < 0 ? getPi2(this, pr, rm) : new this(0);
          r.s = y.s;
        } else if (!y.d || x.isZero()) {
          r = getPi2(this, wpr, 1).times(0.5);
          r.s = y.s;
        } else if (x.s < 0) {
          this.precision = wpr;
          this.rounding = 1;
          r = this.atan(divide2(y, x, wpr, 1));
          x = getPi2(this, wpr, 1);
          this.precision = pr;
          this.rounding = rm;
          r = y.s < 0 ? r.minus(x) : r.plus(x);
        } else {
          r = this.atan(divide2(y, x, wpr, 1));
        }
        return r;
      }
      function cbrt2(x) {
        return new this(x).cbrt();
      }
      function ceil2(x) {
        return finalise2(x = new this(x), x.e + 1, 2);
      }
      function clamp2(x, min3, max3) {
        return new this(x).clamp(min3, max3);
      }
      function config2(obj) {
        if (!obj || typeof obj !== "object")
          throw Error(decimalError2 + "Object expected");
        var i, p, v, useDefaults = obj.defaults === true, ps = [
          "precision",
          1,
          MAX_DIGITS2,
          "rounding",
          0,
          8,
          "toExpNeg",
          -EXP_LIMIT2,
          0,
          "toExpPos",
          0,
          EXP_LIMIT2,
          "maxE",
          0,
          EXP_LIMIT2,
          "minE",
          -EXP_LIMIT2,
          0,
          "modulo",
          0,
          9
        ];
        for (i = 0; i < ps.length; i += 3) {
          if (p = ps[i], useDefaults)
            this[p] = DEFAULTS2[p];
          if ((v = obj[p]) !== void 0) {
            if (mathfloor3(v) === v && v >= ps[i + 1] && v <= ps[i + 2])
              this[p] = v;
            else
              throw Error(invalidArgument2 + p + ": " + v);
          }
        }
        if (p = "crypto", useDefaults)
          this[p] = DEFAULTS2[p];
        if ((v = obj[p]) !== void 0) {
          if (v === true || v === false || v === 0 || v === 1) {
            if (v) {
              if (typeof crypto != "undefined" && crypto && (crypto.getRandomValues || crypto.randomBytes)) {
                this[p] = true;
              } else {
                throw Error(cryptoUnavailable2);
              }
            } else {
              this[p] = false;
            }
          } else {
            throw Error(invalidArgument2 + p + ": " + v);
          }
        }
        return this;
      }
      function cos2(x) {
        return new this(x).cos();
      }
      function cosh2(x) {
        return new this(x).cosh();
      }
      function clone3(obj) {
        var i, p, ps;
        function Decimal3(v) {
          var e, i2, t, x = this;
          if (!(x instanceof Decimal3))
            return new Decimal3(v);
          x.constructor = Decimal3;
          if (isDecimalInstance2(v)) {
            x.s = v.s;
            if (external2) {
              if (!v.d || v.e > Decimal3.maxE) {
                x.e = NaN;
                x.d = null;
              } else if (v.e < Decimal3.minE) {
                x.e = 0;
                x.d = [0];
              } else {
                x.e = v.e;
                x.d = v.d.slice();
              }
            } else {
              x.e = v.e;
              x.d = v.d ? v.d.slice() : v.d;
            }
            return;
          }
          t = typeof v;
          if (t === "number") {
            if (v === 0) {
              x.s = 1 / v < 0 ? -1 : 1;
              x.e = 0;
              x.d = [0];
              return;
            }
            if (v < 0) {
              v = -v;
              x.s = -1;
            } else {
              x.s = 1;
            }
            if (v === ~~v && v < 1e7) {
              for (e = 0, i2 = v; i2 >= 10; i2 /= 10)
                e++;
              if (external2) {
                if (e > Decimal3.maxE) {
                  x.e = NaN;
                  x.d = null;
                } else if (e < Decimal3.minE) {
                  x.e = 0;
                  x.d = [0];
                } else {
                  x.e = e;
                  x.d = [v];
                }
              } else {
                x.e = e;
                x.d = [v];
              }
              return;
            }
            if (v * 0 !== 0) {
              if (!v)
                x.s = NaN;
              x.e = NaN;
              x.d = null;
              return;
            }
            return parseDecimal2(x, v.toString());
          }
          if (t === "string") {
            if ((i2 = v.charCodeAt(0)) === 45) {
              v = v.slice(1);
              x.s = -1;
            } else {
              if (i2 === 43)
                v = v.slice(1);
              x.s = 1;
            }
            return isDecimal2.test(v) ? parseDecimal2(x, v) : parseOther2(x, v);
          }
          if (t === "bigint") {
            if (v < 0) {
              v = -v;
              x.s = -1;
            } else {
              x.s = 1;
            }
            return parseDecimal2(x, v.toString());
          }
          throw Error(invalidArgument2 + v);
        }
        Decimal3.prototype = P2;
        Decimal3.ROUND_UP = 0;
        Decimal3.ROUND_DOWN = 1;
        Decimal3.ROUND_CEIL = 2;
        Decimal3.ROUND_FLOOR = 3;
        Decimal3.ROUND_HALF_UP = 4;
        Decimal3.ROUND_HALF_DOWN = 5;
        Decimal3.ROUND_HALF_EVEN = 6;
        Decimal3.ROUND_HALF_CEIL = 7;
        Decimal3.ROUND_HALF_FLOOR = 8;
        Decimal3.EUCLID = 9;
        Decimal3.config = Decimal3.set = config2;
        Decimal3.clone = clone3;
        Decimal3.isDecimal = isDecimalInstance2;
        Decimal3.abs = abs2;
        Decimal3.acos = acos2;
        Decimal3.acosh = acosh2;
        Decimal3.add = add2;
        Decimal3.asin = asin2;
        Decimal3.asinh = asinh2;
        Decimal3.atan = atan3;
        Decimal3.atanh = atanh2;
        Decimal3.atan2 = atan22;
        Decimal3.cbrt = cbrt2;
        Decimal3.ceil = ceil2;
        Decimal3.clamp = clamp2;
        Decimal3.cos = cos2;
        Decimal3.cosh = cosh2;
        Decimal3.div = div2;
        Decimal3.exp = exp2;
        Decimal3.floor = floor2;
        Decimal3.hypot = hypot2;
        Decimal3.ln = ln2;
        Decimal3.log = log3;
        Decimal3.log10 = log102;
        Decimal3.log2 = log22;
        Decimal3.max = max2;
        Decimal3.min = min2;
        Decimal3.mod = mod2;
        Decimal3.mul = mul2;
        Decimal3.pow = pow3;
        Decimal3.random = random2;
        Decimal3.round = round2;
        Decimal3.sign = sign2;
        Decimal3.sin = sin2;
        Decimal3.sinh = sinh2;
        Decimal3.sqrt = sqrt2;
        Decimal3.sub = sub2;
        Decimal3.sum = sum2;
        Decimal3.tan = tan2;
        Decimal3.tanh = tanh2;
        Decimal3.trunc = trunc2;
        if (obj === void 0)
          obj = {};
        if (obj) {
          if (obj.defaults !== true) {
            ps = ["precision", "rounding", "toExpNeg", "toExpPos", "maxE", "minE", "modulo", "crypto"];
            for (i = 0; i < ps.length; )
              if (!obj.hasOwnProperty(p = ps[i++]))
                obj[p] = this[p];
          }
        }
        Decimal3.config(obj);
        return Decimal3;
      }
      function div2(x, y) {
        return new this(x).div(y);
      }
      function exp2(x) {
        return new this(x).exp();
      }
      function floor2(x) {
        return finalise2(x = new this(x), x.e + 1, 3);
      }
      function hypot2() {
        var i, n, t = new this(0);
        external2 = false;
        for (i = 0; i < arguments.length; ) {
          n = new this(arguments[i++]);
          if (!n.d) {
            if (n.s) {
              external2 = true;
              return new this(1 / 0);
            }
            t = n;
          } else if (t.d) {
            t = t.plus(n.times(n));
          }
        }
        external2 = true;
        return t.sqrt();
      }
      function isDecimalInstance2(obj) {
        return obj instanceof Decimal2 || obj && obj.toStringTag === tag2 || false;
      }
      function ln2(x) {
        return new this(x).ln();
      }
      function log3(x, y) {
        return new this(x).log(y);
      }
      function log22(x) {
        return new this(x).log(2);
      }
      function log102(x) {
        return new this(x).log(10);
      }
      function max2() {
        return maxOrMin2(this, arguments, -1);
      }
      function min2() {
        return maxOrMin2(this, arguments, 1);
      }
      function mod2(x, y) {
        return new this(x).mod(y);
      }
      function mul2(x, y) {
        return new this(x).mul(y);
      }
      function pow3(x, y) {
        return new this(x).pow(y);
      }
      function random2(sd) {
        var d, e, k, n, i = 0, r = new this(1), rd = [];
        if (sd === void 0)
          sd = this.precision;
        else
          checkInt322(sd, 1, MAX_DIGITS2);
        k = Math.ceil(sd / LOG_BASE3);
        if (!this.crypto) {
          for (; i < k; )
            rd[i++] = Math.random() * 1e7 | 0;
        } else if (crypto.getRandomValues) {
          d = crypto.getRandomValues(new Uint32Array(k));
          for (; i < k; ) {
            n = d[i];
            if (n >= 429e7) {
              d[i] = crypto.getRandomValues(new Uint32Array(1))[0];
            } else {
              rd[i++] = n % 1e7;
            }
          }
        } else if (crypto.randomBytes) {
          d = crypto.randomBytes(k *= 4);
          for (; i < k; ) {
            n = d[i] + (d[i + 1] << 8) + (d[i + 2] << 16) + ((d[i + 3] & 127) << 24);
            if (n >= 214e7) {
              crypto.randomBytes(4).copy(d, i);
            } else {
              rd.push(n % 1e7);
              i += 4;
            }
          }
          i = k / 4;
        } else {
          throw Error(cryptoUnavailable2);
        }
        k = rd[--i];
        sd %= LOG_BASE3;
        if (k && sd) {
          n = mathpow2(10, LOG_BASE3 - sd);
          rd[i] = (k / n | 0) * n;
        }
        for (; rd[i] === 0; i--)
          rd.pop();
        if (i < 0) {
          e = 0;
          rd = [0];
        } else {
          e = -1;
          for (; rd[0] === 0; e -= LOG_BASE3)
            rd.shift();
          for (k = 1, n = rd[0]; n >= 10; n /= 10)
            k++;
          if (k < LOG_BASE3)
            e -= LOG_BASE3 - k;
        }
        r.e = e;
        r.d = rd;
        return r;
      }
      function round2(x) {
        return finalise2(x = new this(x), x.e + 1, this.rounding);
      }
      function sign2(x) {
        x = new this(x);
        return x.d ? x.d[0] ? x.s : 0 * x.s : x.s || NaN;
      }
      function sin2(x) {
        return new this(x).sin();
      }
      function sinh2(x) {
        return new this(x).sinh();
      }
      function sqrt2(x) {
        return new this(x).sqrt();
      }
      function sub2(x, y) {
        return new this(x).sub(y);
      }
      function sum2() {
        var i = 0, args = arguments, x = new this(args[i]);
        external2 = false;
        for (; x.s && ++i < args.length; )
          x = x.plus(args[i]);
        external2 = true;
        return finalise2(x, this.precision, this.rounding);
      }
      function tan2(x) {
        return new this(x).tan();
      }
      function tanh2(x) {
        return new this(x).tanh();
      }
      function trunc2(x) {
        return finalise2(x = new this(x), x.e + 1, 1);
      }
      Decimal2 = clone3(DEFAULTS2);
      Decimal2.prototype.constructor = Decimal2;
      Decimal2["default"] = Decimal2.Decimal = Decimal2;
      LN102 = new Decimal2(LN102);
      PI2 = new Decimal2(PI2);
      if (typeof define == "function" && define.amd) {
        define(function() {
          return Decimal2;
        });
      } else if (typeof module2 != "undefined" && module2.exports) {
        if (typeof Symbol == "function" && typeof Symbol.iterator == "symbol") {
          P2[Symbol["for"]("nodejs.util.inspect.custom")] = P2.toString;
          P2[Symbol.toStringTag] = "Decimal";
        }
        module2.exports = Decimal2;
      } else {
        if (!globalScope) {
          globalScope = typeof self != "undefined" && self && self.self == self ? self : window;
        }
        noConflict = globalScope.Decimal;
        Decimal2.noConflict = function() {
          globalScope.Decimal = noConflict;
          return Decimal2;
        };
        globalScope.Decimal = Decimal2;
      }
    })(exports2);
  }
});

// node_modules/@orca-so/whirlpools-sdk/dist/artifacts/whirlpool.json
var require_whirlpool = __commonJS({
  "node_modules/@orca-so/whirlpools-sdk/dist/artifacts/whirlpool.json"(exports2, module2) {
    module2.exports = {
      version: "0.4.0",
      name: "whirlpool",
      instructions: [
        {
          name: "initializeConfig",
          docs: [
            "Initializes a WhirlpoolsConfig account that hosts info & authorities",
            "required to govern a set of Whirlpools.",
            "",
            "### Parameters",
            "- `fee_authority` - Authority authorized to initialize fee-tiers and set customs fees.",
            "- `collect_protocol_fees_authority` - Authority authorized to collect protocol fees.",
            "- `reward_emissions_super_authority` - Authority authorized to set reward authorities in pools."
          ],
          accounts: [
            {
              name: "config",
              isMut: true,
              isSigner: true
            },
            {
              name: "funder",
              isMut: true,
              isSigner: true
            },
            {
              name: "systemProgram",
              isMut: false,
              isSigner: false
            }
          ],
          args: [
            {
              name: "feeAuthority",
              type: "publicKey"
            },
            {
              name: "collectProtocolFeesAuthority",
              type: "publicKey"
            },
            {
              name: "rewardEmissionsSuperAuthority",
              type: "publicKey"
            },
            {
              name: "defaultProtocolFeeRate",
              type: "u16"
            }
          ]
        },
        {
          name: "initializePool",
          docs: [
            "Initializes a Whirlpool account.",
            "Fee rate is set to the default values on the config and supplied fee_tier.",
            "",
            "### Parameters",
            "- `bumps` - The bump value when deriving the PDA of the Whirlpool address.",
            "- `tick_spacing` - The desired tick spacing for this pool.",
            "- `initial_sqrt_price` - The desired initial sqrt-price for this pool",
            "",
            "#### Special Errors",
            "`InvalidTokenMintOrder` - The order of mints have to be ordered by",
            "`SqrtPriceOutOfBounds` - provided initial_sqrt_price is not between 2^-64 to 2^64",
            ""
          ],
          accounts: [
            {
              name: "whirlpoolsConfig",
              isMut: false,
              isSigner: false
            },
            {
              name: "tokenMintA",
              isMut: false,
              isSigner: false
            },
            {
              name: "tokenMintB",
              isMut: false,
              isSigner: false
            },
            {
              name: "funder",
              isMut: true,
              isSigner: true
            },
            {
              name: "whirlpool",
              isMut: true,
              isSigner: false
            },
            {
              name: "tokenVaultA",
              isMut: true,
              isSigner: true
            },
            {
              name: "tokenVaultB",
              isMut: true,
              isSigner: true
            },
            {
              name: "feeTier",
              isMut: false,
              isSigner: false
            },
            {
              name: "tokenProgram",
              isMut: false,
              isSigner: false
            },
            {
              name: "systemProgram",
              isMut: false,
              isSigner: false
            },
            {
              name: "rent",
              isMut: false,
              isSigner: false
            }
          ],
          args: [
            {
              name: "bumps",
              type: {
                defined: "WhirlpoolBumps"
              }
            },
            {
              name: "tickSpacing",
              type: "u16"
            },
            {
              name: "initialSqrtPrice",
              type: "u128"
            }
          ]
        },
        {
          name: "initializeTickArray",
          docs: [
            "Initializes a tick_array account to represent a tick-range in a Whirlpool.",
            "",
            "### Parameters",
            "- `start_tick_index` - The starting tick index for this tick-array.",
            "Has to be a multiple of TickArray size & the tick spacing of this pool.",
            "",
            "#### Special Errors",
            "- `InvalidStartTick` - if the provided start tick is out of bounds or is not a multiple of",
            "TICK_ARRAY_SIZE * tick spacing."
          ],
          accounts: [
            {
              name: "whirlpool",
              isMut: false,
              isSigner: false
            },
            {
              name: "funder",
              isMut: true,
              isSigner: true
            },
            {
              name: "tickArray",
              isMut: true,
              isSigner: false
            },
            {
              name: "systemProgram",
              isMut: false,
              isSigner: false
            }
          ],
          args: [
            {
              name: "startTickIndex",
              type: "i32"
            }
          ]
        },
        {
          name: "initializeFeeTier",
          docs: [
            "Initializes a fee_tier account usable by Whirlpools in a WhirlpoolConfig space.",
            "",
            "### Authority",
            '- "fee_authority" - Set authority in the WhirlpoolConfig',
            "",
            "### Parameters",
            "- `tick_spacing` - The tick-spacing that this fee-tier suggests the default_fee_rate for.",
            "- `default_fee_rate` - The default fee rate that a pool will use if the pool uses this",
            "fee tier during initialization.",
            "",
            "#### Special Errors",
            "- `InvalidTickSpacing` - If the provided tick_spacing is 0.",
            "- `FeeRateMaxExceeded` - If the provided default_fee_rate exceeds MAX_FEE_RATE."
          ],
          accounts: [
            {
              name: "config",
              isMut: false,
              isSigner: false
            },
            {
              name: "feeTier",
              isMut: true,
              isSigner: false
            },
            {
              name: "funder",
              isMut: true,
              isSigner: true
            },
            {
              name: "feeAuthority",
              isMut: false,
              isSigner: true
            },
            {
              name: "systemProgram",
              isMut: false,
              isSigner: false
            }
          ],
          args: [
            {
              name: "tickSpacing",
              type: "u16"
            },
            {
              name: "defaultFeeRate",
              type: "u16"
            }
          ]
        },
        {
          name: "initializeReward",
          docs: [
            "Initialize reward for a Whirlpool. A pool can only support up to a set number of rewards.",
            "",
            "### Authority",
            '- "reward_authority" - assigned authority by the reward_super_authority for the specified',
            "reward-index in this Whirlpool",
            "",
            "### Parameters",
            "- `reward_index` - The reward index that we'd like to initialize. (0 <= index <= NUM_REWARDS)",
            "",
            "#### Special Errors",
            "- `InvalidRewardIndex` - If the provided reward index doesn't match the lowest uninitialized",
            "index in this pool, or exceeds NUM_REWARDS, or",
            "all reward slots for this pool has been initialized."
          ],
          accounts: [
            {
              name: "rewardAuthority",
              isMut: false,
              isSigner: true
            },
            {
              name: "funder",
              isMut: true,
              isSigner: true
            },
            {
              name: "whirlpool",
              isMut: true,
              isSigner: false
            },
            {
              name: "rewardMint",
              isMut: false,
              isSigner: false
            },
            {
              name: "rewardVault",
              isMut: true,
              isSigner: true
            },
            {
              name: "tokenProgram",
              isMut: false,
              isSigner: false
            },
            {
              name: "systemProgram",
              isMut: false,
              isSigner: false
            },
            {
              name: "rent",
              isMut: false,
              isSigner: false
            }
          ],
          args: [
            {
              name: "rewardIndex",
              type: "u8"
            }
          ]
        },
        {
          name: "setRewardEmissions",
          docs: [
            "Set the reward emissions for a reward in a Whirlpool.",
            "",
            "### Authority",
            '- "reward_authority" - assigned authority by the reward_super_authority for the specified',
            "reward-index in this Whirlpool",
            "",
            "### Parameters",
            "- `reward_index` - The reward index (0 <= index <= NUM_REWARDS) that we'd like to modify.",
            "- `emissions_per_second_x64` - The amount of rewards emitted in this pool.",
            "",
            "#### Special Errors",
            "- `RewardVaultAmountInsufficient` - The amount of rewards in the reward vault cannot emit",
            "more than a day of desired emissions.",
            "- `InvalidTimestamp` - Provided timestamp is not in order with the previous timestamp.",
            "- `InvalidRewardIndex` - If the provided reward index doesn't match the lowest uninitialized",
            "index in this pool, or exceeds NUM_REWARDS, or",
            "all reward slots for this pool has been initialized."
          ],
          accounts: [
            {
              name: "whirlpool",
              isMut: true,
              isSigner: false
            },
            {
              name: "rewardAuthority",
              isMut: false,
              isSigner: true
            },
            {
              name: "rewardVault",
              isMut: false,
              isSigner: false
            }
          ],
          args: [
            {
              name: "rewardIndex",
              type: "u8"
            },
            {
              name: "emissionsPerSecondX64",
              type: "u128"
            }
          ]
        },
        {
          name: "openPosition",
          docs: [
            "Open a position in a Whirlpool. A unique token will be minted to represent the position",
            "in the users wallet. The position will start off with 0 liquidity.",
            "",
            "### Parameters",
            "- `tick_lower_index` - The tick specifying the lower end of the position range.",
            "- `tick_upper_index` - The tick specifying the upper end of the position range.",
            "",
            "#### Special Errors",
            "- `InvalidTickIndex` - If a provided tick is out of bounds, out of order or not a multiple of",
            "the tick-spacing in this pool."
          ],
          accounts: [
            {
              name: "funder",
              isMut: true,
              isSigner: true
            },
            {
              name: "owner",
              isMut: false,
              isSigner: false
            },
            {
              name: "position",
              isMut: true,
              isSigner: false
            },
            {
              name: "positionMint",
              isMut: true,
              isSigner: true
            },
            {
              name: "positionTokenAccount",
              isMut: true,
              isSigner: false
            },
            {
              name: "whirlpool",
              isMut: false,
              isSigner: false
            },
            {
              name: "tokenProgram",
              isMut: false,
              isSigner: false
            },
            {
              name: "systemProgram",
              isMut: false,
              isSigner: false
            },
            {
              name: "rent",
              isMut: false,
              isSigner: false
            },
            {
              name: "associatedTokenProgram",
              isMut: false,
              isSigner: false
            }
          ],
          args: [
            {
              name: "bumps",
              type: {
                defined: "OpenPositionBumps"
              }
            },
            {
              name: "tickLowerIndex",
              type: "i32"
            },
            {
              name: "tickUpperIndex",
              type: "i32"
            }
          ]
        },
        {
          name: "openPositionWithMetadata",
          docs: [
            "Open a position in a Whirlpool. A unique token will be minted to represent the position",
            "in the users wallet. Additional Metaplex metadata is appended to identify the token.",
            "The position will start off with 0 liquidity.",
            "",
            "### Parameters",
            "- `tick_lower_index` - The tick specifying the lower end of the position range.",
            "- `tick_upper_index` - The tick specifying the upper end of the position range.",
            "",
            "#### Special Errors",
            "- `InvalidTickIndex` - If a provided tick is out of bounds, out of order or not a multiple of",
            "the tick-spacing in this pool."
          ],
          accounts: [
            {
              name: "funder",
              isMut: true,
              isSigner: true
            },
            {
              name: "owner",
              isMut: false,
              isSigner: false
            },
            {
              name: "position",
              isMut: true,
              isSigner: false
            },
            {
              name: "positionMint",
              isMut: true,
              isSigner: true
            },
            {
              name: "positionMetadataAccount",
              isMut: true,
              isSigner: false,
              docs: [
                "https://github.com/metaplex-foundation/mpl-token-metadata/blob/master/programs/token-metadata/program/src/utils/metadata.rs#L78"
              ]
            },
            {
              name: "positionTokenAccount",
              isMut: true,
              isSigner: false
            },
            {
              name: "whirlpool",
              isMut: false,
              isSigner: false
            },
            {
              name: "tokenProgram",
              isMut: false,
              isSigner: false
            },
            {
              name: "systemProgram",
              isMut: false,
              isSigner: false
            },
            {
              name: "rent",
              isMut: false,
              isSigner: false
            },
            {
              name: "associatedTokenProgram",
              isMut: false,
              isSigner: false
            },
            {
              name: "metadataProgram",
              isMut: false,
              isSigner: false
            },
            {
              name: "metadataUpdateAuth",
              isMut: false,
              isSigner: false
            }
          ],
          args: [
            {
              name: "bumps",
              type: {
                defined: "OpenPositionWithMetadataBumps"
              }
            },
            {
              name: "tickLowerIndex",
              type: "i32"
            },
            {
              name: "tickUpperIndex",
              type: "i32"
            }
          ]
        },
        {
          name: "increaseLiquidity",
          docs: [
            "Add liquidity to a position in the Whirlpool. This call also updates the position's accrued fees and rewards.",
            "",
            "### Authority",
            "- `position_authority` - authority that owns the token corresponding to this desired position.",
            "",
            "### Parameters",
            "- `liquidity_amount` - The total amount of Liquidity the user is willing to deposit.",
            "- `token_max_a` - The maximum amount of tokenA the user is willing to deposit.",
            "- `token_max_b` - The maximum amount of tokenB the user is willing to deposit.",
            "",
            "#### Special Errors",
            "- `LiquidityZero` - Provided liquidity amount is zero.",
            "- `LiquidityTooHigh` - Provided liquidity exceeds u128::max.",
            "- `TokenMaxExceeded` - The required token to perform this operation exceeds the user defined amount."
          ],
          accounts: [
            {
              name: "whirlpool",
              isMut: true,
              isSigner: false
            },
            {
              name: "tokenProgram",
              isMut: false,
              isSigner: false
            },
            {
              name: "positionAuthority",
              isMut: false,
              isSigner: true
            },
            {
              name: "position",
              isMut: true,
              isSigner: false
            },
            {
              name: "positionTokenAccount",
              isMut: false,
              isSigner: false
            },
            {
              name: "tokenOwnerAccountA",
              isMut: true,
              isSigner: false
            },
            {
              name: "tokenOwnerAccountB",
              isMut: true,
              isSigner: false
            },
            {
              name: "tokenVaultA",
              isMut: true,
              isSigner: false
            },
            {
              name: "tokenVaultB",
              isMut: true,
              isSigner: false
            },
            {
              name: "tickArrayLower",
              isMut: true,
              isSigner: false
            },
            {
              name: "tickArrayUpper",
              isMut: true,
              isSigner: false
            }
          ],
          args: [
            {
              name: "liquidityAmount",
              type: "u128"
            },
            {
              name: "tokenMaxA",
              type: "u64"
            },
            {
              name: "tokenMaxB",
              type: "u64"
            }
          ]
        },
        {
          name: "decreaseLiquidity",
          docs: [
            "Withdraw liquidity from a position in the Whirlpool. This call also updates the position's accrued fees and rewards.",
            "",
            "### Authority",
            "- `position_authority` - authority that owns the token corresponding to this desired position.",
            "",
            "### Parameters",
            "- `liquidity_amount` - The total amount of Liquidity the user desires to withdraw.",
            "- `token_min_a` - The minimum amount of tokenA the user is willing to withdraw.",
            "- `token_min_b` - The minimum amount of tokenB the user is willing to withdraw.",
            "",
            "#### Special Errors",
            "- `LiquidityZero` - Provided liquidity amount is zero.",
            "- `LiquidityTooHigh` - Provided liquidity exceeds u128::max.",
            "- `TokenMinSubceeded` - The required token to perform this operation subceeds the user defined amount."
          ],
          accounts: [
            {
              name: "whirlpool",
              isMut: true,
              isSigner: false
            },
            {
              name: "tokenProgram",
              isMut: false,
              isSigner: false
            },
            {
              name: "positionAuthority",
              isMut: false,
              isSigner: true
            },
            {
              name: "position",
              isMut: true,
              isSigner: false
            },
            {
              name: "positionTokenAccount",
              isMut: false,
              isSigner: false
            },
            {
              name: "tokenOwnerAccountA",
              isMut: true,
              isSigner: false
            },
            {
              name: "tokenOwnerAccountB",
              isMut: true,
              isSigner: false
            },
            {
              name: "tokenVaultA",
              isMut: true,
              isSigner: false
            },
            {
              name: "tokenVaultB",
              isMut: true,
              isSigner: false
            },
            {
              name: "tickArrayLower",
              isMut: true,
              isSigner: false
            },
            {
              name: "tickArrayUpper",
              isMut: true,
              isSigner: false
            }
          ],
          args: [
            {
              name: "liquidityAmount",
              type: "u128"
            },
            {
              name: "tokenMinA",
              type: "u64"
            },
            {
              name: "tokenMinB",
              type: "u64"
            }
          ]
        },
        {
          name: "updateFeesAndRewards",
          docs: [
            "Update the accrued fees and rewards for a position.",
            "",
            "#### Special Errors",
            "- `TickNotFound` - Provided tick array account does not contain the tick for this position.",
            "- `LiquidityZero` - Position has zero liquidity and therefore already has the most updated fees and reward values."
          ],
          accounts: [
            {
              name: "whirlpool",
              isMut: true,
              isSigner: false
            },
            {
              name: "position",
              isMut: true,
              isSigner: false
            },
            {
              name: "tickArrayLower",
              isMut: false,
              isSigner: false
            },
            {
              name: "tickArrayUpper",
              isMut: false,
              isSigner: false
            }
          ],
          args: []
        },
        {
          name: "collectFees",
          docs: [
            "Collect fees accrued for this position.",
            "",
            "### Authority",
            "- `position_authority` - authority that owns the token corresponding to this desired position."
          ],
          accounts: [
            {
              name: "whirlpool",
              isMut: false,
              isSigner: false
            },
            {
              name: "positionAuthority",
              isMut: false,
              isSigner: true
            },
            {
              name: "position",
              isMut: true,
              isSigner: false
            },
            {
              name: "positionTokenAccount",
              isMut: false,
              isSigner: false
            },
            {
              name: "tokenOwnerAccountA",
              isMut: true,
              isSigner: false
            },
            {
              name: "tokenVaultA",
              isMut: true,
              isSigner: false
            },
            {
              name: "tokenOwnerAccountB",
              isMut: true,
              isSigner: false
            },
            {
              name: "tokenVaultB",
              isMut: true,
              isSigner: false
            },
            {
              name: "tokenProgram",
              isMut: false,
              isSigner: false
            }
          ],
          args: []
        },
        {
          name: "collectReward",
          docs: [
            "Collect rewards accrued for this position.",
            "",
            "### Authority",
            "- `position_authority` - authority that owns the token corresponding to this desired position."
          ],
          accounts: [
            {
              name: "whirlpool",
              isMut: false,
              isSigner: false
            },
            {
              name: "positionAuthority",
              isMut: false,
              isSigner: true
            },
            {
              name: "position",
              isMut: true,
              isSigner: false
            },
            {
              name: "positionTokenAccount",
              isMut: false,
              isSigner: false
            },
            {
              name: "rewardOwnerAccount",
              isMut: true,
              isSigner: false
            },
            {
              name: "rewardVault",
              isMut: true,
              isSigner: false
            },
            {
              name: "tokenProgram",
              isMut: false,
              isSigner: false
            }
          ],
          args: [
            {
              name: "rewardIndex",
              type: "u8"
            }
          ]
        },
        {
          name: "collectProtocolFees",
          docs: [
            "Collect the protocol fees accrued in this Whirlpool",
            "",
            "### Authority",
            "- `collect_protocol_fees_authority` - assigned authority in the WhirlpoolConfig that can collect protocol fees"
          ],
          accounts: [
            {
              name: "whirlpoolsConfig",
              isMut: false,
              isSigner: false
            },
            {
              name: "whirlpool",
              isMut: true,
              isSigner: false
            },
            {
              name: "collectProtocolFeesAuthority",
              isMut: false,
              isSigner: true
            },
            {
              name: "tokenVaultA",
              isMut: true,
              isSigner: false
            },
            {
              name: "tokenVaultB",
              isMut: true,
              isSigner: false
            },
            {
              name: "tokenDestinationA",
              isMut: true,
              isSigner: false
            },
            {
              name: "tokenDestinationB",
              isMut: true,
              isSigner: false
            },
            {
              name: "tokenProgram",
              isMut: false,
              isSigner: false
            }
          ],
          args: []
        },
        {
          name: "swap",
          docs: [
            "Perform a swap in this Whirlpool",
            "",
            "### Authority",
            '- "token_authority" - The authority to withdraw tokens from the input token account.',
            "",
            "### Parameters",
            "- `amount` - The amount of input or output token to swap from (depending on amount_specified_is_input).",
            "- `other_amount_threshold` - The maximum/minimum of input/output token to swap into (depending on amount_specified_is_input).",
            "- `sqrt_price_limit` - The maximum/minimum price the swap will swap to.",
            "- `amount_specified_is_input` - Specifies the token the parameter `amount`represents. If true, the amount represents the input token of the swap.",
            "- `a_to_b` - The direction of the swap. True if swapping from A to B. False if swapping from B to A.",
            "",
            "#### Special Errors",
            "- `ZeroTradableAmount` - User provided parameter `amount` is 0.",
            "- `InvalidSqrtPriceLimitDirection` - User provided parameter `sqrt_price_limit` does not match the direction of the trade.",
            "- `SqrtPriceOutOfBounds` - User provided parameter `sqrt_price_limit` is over Whirlppool's max/min bounds for sqrt-price.",
            "- `InvalidTickArraySequence` - User provided tick-arrays are not in sequential order required to proceed in this trade direction.",
            "- `TickArraySequenceInvalidIndex` - The swap loop attempted to access an invalid array index during the query of the next initialized tick.",
            "- `TickArrayIndexOutofBounds` - The swap loop attempted to access an invalid array index during tick crossing.",
            "- `LiquidityOverflow` - Liquidity value overflowed 128bits during tick crossing.",
            "- `InvalidTickSpacing` - The swap pool was initialized with tick-spacing of 0."
          ],
          accounts: [
            {
              name: "tokenProgram",
              isMut: false,
              isSigner: false
            },
            {
              name: "tokenAuthority",
              isMut: false,
              isSigner: true
            },
            {
              name: "whirlpool",
              isMut: true,
              isSigner: false
            },
            {
              name: "tokenOwnerAccountA",
              isMut: true,
              isSigner: false
            },
            {
              name: "tokenVaultA",
              isMut: true,
              isSigner: false
            },
            {
              name: "tokenOwnerAccountB",
              isMut: true,
              isSigner: false
            },
            {
              name: "tokenVaultB",
              isMut: true,
              isSigner: false
            },
            {
              name: "tickArray0",
              isMut: true,
              isSigner: false
            },
            {
              name: "tickArray1",
              isMut: true,
              isSigner: false
            },
            {
              name: "tickArray2",
              isMut: true,
              isSigner: false
            },
            {
              name: "oracle",
              isMut: false,
              isSigner: false
            }
          ],
          args: [
            {
              name: "amount",
              type: "u64"
            },
            {
              name: "otherAmountThreshold",
              type: "u64"
            },
            {
              name: "sqrtPriceLimit",
              type: "u128"
            },
            {
              name: "amountSpecifiedIsInput",
              type: "bool"
            },
            {
              name: "aToB",
              type: "bool"
            }
          ]
        },
        {
          name: "closePosition",
          docs: [
            "Close a position in a Whirlpool. Burns the position token in the owner's wallet.",
            "",
            "### Authority",
            '- "position_authority" - The authority that owns the position token.',
            "",
            "#### Special Errors",
            "- `ClosePositionNotEmpty` - The provided position account is not empty."
          ],
          accounts: [
            {
              name: "positionAuthority",
              isMut: false,
              isSigner: true
            },
            {
              name: "receiver",
              isMut: true,
              isSigner: false
            },
            {
              name: "position",
              isMut: true,
              isSigner: false
            },
            {
              name: "positionMint",
              isMut: true,
              isSigner: false
            },
            {
              name: "positionTokenAccount",
              isMut: true,
              isSigner: false
            },
            {
              name: "tokenProgram",
              isMut: false,
              isSigner: false
            }
          ],
          args: []
        },
        {
          name: "setDefaultFeeRate",
          docs: [
            "Set the default_fee_rate for a FeeTier",
            "Only the current fee authority has permission to invoke this instruction.",
            "",
            "### Authority",
            '- "fee_authority" - Set authority in the WhirlpoolConfig',
            "",
            "### Parameters",
            "- `default_fee_rate` - The default fee rate that a pool will use if the pool uses this",
            "fee tier during initialization.",
            "",
            "#### Special Errors",
            "- `FeeRateMaxExceeded` - If the provided default_fee_rate exceeds MAX_FEE_RATE."
          ],
          accounts: [
            {
              name: "whirlpoolsConfig",
              isMut: false,
              isSigner: false
            },
            {
              name: "feeTier",
              isMut: true,
              isSigner: false
            },
            {
              name: "feeAuthority",
              isMut: false,
              isSigner: true
            }
          ],
          args: [
            {
              name: "defaultFeeRate",
              type: "u16"
            }
          ]
        },
        {
          name: "setDefaultProtocolFeeRate",
          docs: [
            "Sets the default protocol fee rate for a WhirlpoolConfig",
            "Protocol fee rate is represented as a basis point.",
            "Only the current fee authority has permission to invoke this instruction.",
            "",
            "### Authority",
            '- "fee_authority" - Set authority that can modify pool fees in the WhirlpoolConfig',
            "",
            "### Parameters",
            "- `default_protocol_fee_rate` - Rate that is referenced during the initialization of a Whirlpool using this config.",
            "",
            "#### Special Errors",
            "- `ProtocolFeeRateMaxExceeded` - If the provided default_protocol_fee_rate exceeds MAX_PROTOCOL_FEE_RATE."
          ],
          accounts: [
            {
              name: "whirlpoolsConfig",
              isMut: true,
              isSigner: false
            },
            {
              name: "feeAuthority",
              isMut: false,
              isSigner: true
            }
          ],
          args: [
            {
              name: "defaultProtocolFeeRate",
              type: "u16"
            }
          ]
        },
        {
          name: "setFeeRate",
          docs: [
            "Sets the fee rate for a Whirlpool.",
            "Fee rate is represented as hundredths of a basis point.",
            "Only the current fee authority has permission to invoke this instruction.",
            "",
            "### Authority",
            '- "fee_authority" - Set authority that can modify pool fees in the WhirlpoolConfig',
            "",
            "### Parameters",
            "- `fee_rate` - The rate that the pool will use to calculate fees going onwards.",
            "",
            "#### Special Errors",
            "- `FeeRateMaxExceeded` - If the provided fee_rate exceeds MAX_FEE_RATE."
          ],
          accounts: [
            {
              name: "whirlpoolsConfig",
              isMut: false,
              isSigner: false
            },
            {
              name: "whirlpool",
              isMut: true,
              isSigner: false
            },
            {
              name: "feeAuthority",
              isMut: false,
              isSigner: true
            }
          ],
          args: [
            {
              name: "feeRate",
              type: "u16"
            }
          ]
        },
        {
          name: "setProtocolFeeRate",
          docs: [
            "Sets the protocol fee rate for a Whirlpool.",
            "Protocol fee rate is represented as a basis point.",
            "Only the current fee authority has permission to invoke this instruction.",
            "",
            "### Authority",
            '- "fee_authority" - Set authority that can modify pool fees in the WhirlpoolConfig',
            "",
            "### Parameters",
            "- `protocol_fee_rate` - The rate that the pool will use to calculate protocol fees going onwards.",
            "",
            "#### Special Errors",
            "- `ProtocolFeeRateMaxExceeded` - If the provided default_protocol_fee_rate exceeds MAX_PROTOCOL_FEE_RATE."
          ],
          accounts: [
            {
              name: "whirlpoolsConfig",
              isMut: false,
              isSigner: false
            },
            {
              name: "whirlpool",
              isMut: true,
              isSigner: false
            },
            {
              name: "feeAuthority",
              isMut: false,
              isSigner: true
            }
          ],
          args: [
            {
              name: "protocolFeeRate",
              type: "u16"
            }
          ]
        },
        {
          name: "setFeeAuthority",
          docs: [
            "Sets the fee authority for a WhirlpoolConfig.",
            "The fee authority can set the fee & protocol fee rate for individual pools or",
            "set the default fee rate for newly minted pools.",
            "Only the current fee authority has permission to invoke this instruction.",
            "",
            "### Authority",
            '- "fee_authority" - Set authority that can modify pool fees in the WhirlpoolConfig'
          ],
          accounts: [
            {
              name: "whirlpoolsConfig",
              isMut: true,
              isSigner: false
            },
            {
              name: "feeAuthority",
              isMut: false,
              isSigner: true
            },
            {
              name: "newFeeAuthority",
              isMut: false,
              isSigner: false
            }
          ],
          args: []
        },
        {
          name: "setCollectProtocolFeesAuthority",
          docs: [
            "Sets the fee authority to collect protocol fees for a WhirlpoolConfig.",
            "Only the current collect protocol fee authority has permission to invoke this instruction.",
            "",
            "### Authority",
            '- "fee_authority" - Set authority that can collect protocol fees in the WhirlpoolConfig'
          ],
          accounts: [
            {
              name: "whirlpoolsConfig",
              isMut: true,
              isSigner: false
            },
            {
              name: "collectProtocolFeesAuthority",
              isMut: false,
              isSigner: true
            },
            {
              name: "newCollectProtocolFeesAuthority",
              isMut: false,
              isSigner: false
            }
          ],
          args: []
        },
        {
          name: "setRewardAuthority",
          docs: [
            "Set the whirlpool reward authority at the provided `reward_index`.",
            "Only the current reward authority for this reward index has permission to invoke this instruction.",
            "",
            "### Authority",
            '- "reward_authority" - Set authority that can control reward emission for this particular reward.',
            "",
            "#### Special Errors",
            "- `InvalidRewardIndex` - If the provided reward index doesn't match the lowest uninitialized",
            "index in this pool, or exceeds NUM_REWARDS, or",
            "all reward slots for this pool has been initialized."
          ],
          accounts: [
            {
              name: "whirlpool",
              isMut: true,
              isSigner: false
            },
            {
              name: "rewardAuthority",
              isMut: false,
              isSigner: true
            },
            {
              name: "newRewardAuthority",
              isMut: false,
              isSigner: false
            }
          ],
          args: [
            {
              name: "rewardIndex",
              type: "u8"
            }
          ]
        },
        {
          name: "setRewardAuthorityBySuperAuthority",
          docs: [
            "Set the whirlpool reward authority at the provided `reward_index`.",
            "Only the current reward super authority has permission to invoke this instruction.",
            "",
            "### Authority",
            '- "reward_authority" - Set authority that can control reward emission for this particular reward.',
            "",
            "#### Special Errors",
            "- `InvalidRewardIndex` - If the provided reward index doesn't match the lowest uninitialized",
            "index in this pool, or exceeds NUM_REWARDS, or",
            "all reward slots for this pool has been initialized."
          ],
          accounts: [
            {
              name: "whirlpoolsConfig",
              isMut: false,
              isSigner: false
            },
            {
              name: "whirlpool",
              isMut: true,
              isSigner: false
            },
            {
              name: "rewardEmissionsSuperAuthority",
              isMut: false,
              isSigner: true
            },
            {
              name: "newRewardAuthority",
              isMut: false,
              isSigner: false
            }
          ],
          args: [
            {
              name: "rewardIndex",
              type: "u8"
            }
          ]
        },
        {
          name: "setRewardEmissionsSuperAuthority",
          docs: [
            "Set the whirlpool reward super authority for a WhirlpoolConfig",
            "Only the current reward super authority has permission to invoke this instruction.",
            "This instruction will not change the authority on any `WhirlpoolRewardInfo` whirlpool rewards.",
            "",
            "### Authority",
            '- "reward_emissions_super_authority" - Set authority that can control reward authorities for all pools in this config space.'
          ],
          accounts: [
            {
              name: "whirlpoolsConfig",
              isMut: true,
              isSigner: false
            },
            {
              name: "rewardEmissionsSuperAuthority",
              isMut: false,
              isSigner: true
            },
            {
              name: "newRewardEmissionsSuperAuthority",
              isMut: false,
              isSigner: false
            }
          ],
          args: []
        },
        {
          name: "twoHopSwap",
          docs: [
            "Perform a two-hop swap in this Whirlpool",
            "",
            "### Authority",
            '- "token_authority" - The authority to withdraw tokens from the input token account.',
            "",
            "### Parameters",
            "- `amount` - The amount of input or output token to swap from (depending on amount_specified_is_input).",
            "- `other_amount_threshold` - The maximum/minimum of input/output token to swap into (depending on amount_specified_is_input).",
            "- `amount_specified_is_input` - Specifies the token the parameter `amount`represents. If true, the amount represents the input token of the swap.",
            "- `a_to_b_one` - The direction of the swap of hop one. True if swapping from A to B. False if swapping from B to A.",
            "- `a_to_b_two` - The direction of the swap of hop two. True if swapping from A to B. False if swapping from B to A.",
            "- `sqrt_price_limit_one` - The maximum/minimum price the swap will swap to in the first hop.",
            "- `sqrt_price_limit_two` - The maximum/minimum price the swap will swap to in the second hop.",
            "",
            "#### Special Errors",
            "- `ZeroTradableAmount` - User provided parameter `amount` is 0.",
            "- `InvalidSqrtPriceLimitDirection` - User provided parameter `sqrt_price_limit` does not match the direction of the trade.",
            "- `SqrtPriceOutOfBounds` - User provided parameter `sqrt_price_limit` is over Whirlppool's max/min bounds for sqrt-price.",
            "- `InvalidTickArraySequence` - User provided tick-arrays are not in sequential order required to proceed in this trade direction.",
            "- `TickArraySequenceInvalidIndex` - The swap loop attempted to access an invalid array index during the query of the next initialized tick.",
            "- `TickArrayIndexOutofBounds` - The swap loop attempted to access an invalid array index during tick crossing.",
            "- `LiquidityOverflow` - Liquidity value overflowed 128bits during tick crossing.",
            "- `InvalidTickSpacing` - The swap pool was initialized with tick-spacing of 0.",
            "- `InvalidIntermediaryMint` - Error if the intermediary mint between hop one and two do not equal.",
            "- `DuplicateTwoHopPool` - Error if whirlpool one & two are the same pool."
          ],
          accounts: [
            {
              name: "tokenProgram",
              isMut: false,
              isSigner: false
            },
            {
              name: "tokenAuthority",
              isMut: false,
              isSigner: true
            },
            {
              name: "whirlpoolOne",
              isMut: true,
              isSigner: false
            },
            {
              name: "whirlpoolTwo",
              isMut: true,
              isSigner: false
            },
            {
              name: "tokenOwnerAccountOneA",
              isMut: true,
              isSigner: false
            },
            {
              name: "tokenVaultOneA",
              isMut: true,
              isSigner: false
            },
            {
              name: "tokenOwnerAccountOneB",
              isMut: true,
              isSigner: false
            },
            {
              name: "tokenVaultOneB",
              isMut: true,
              isSigner: false
            },
            {
              name: "tokenOwnerAccountTwoA",
              isMut: true,
              isSigner: false
            },
            {
              name: "tokenVaultTwoA",
              isMut: true,
              isSigner: false
            },
            {
              name: "tokenOwnerAccountTwoB",
              isMut: true,
              isSigner: false
            },
            {
              name: "tokenVaultTwoB",
              isMut: true,
              isSigner: false
            },
            {
              name: "tickArrayOne0",
              isMut: true,
              isSigner: false
            },
            {
              name: "tickArrayOne1",
              isMut: true,
              isSigner: false
            },
            {
              name: "tickArrayOne2",
              isMut: true,
              isSigner: false
            },
            {
              name: "tickArrayTwo0",
              isMut: true,
              isSigner: false
            },
            {
              name: "tickArrayTwo1",
              isMut: true,
              isSigner: false
            },
            {
              name: "tickArrayTwo2",
              isMut: true,
              isSigner: false
            },
            {
              name: "oracleOne",
              isMut: false,
              isSigner: false
            },
            {
              name: "oracleTwo",
              isMut: false,
              isSigner: false
            }
          ],
          args: [
            {
              name: "amount",
              type: "u64"
            },
            {
              name: "otherAmountThreshold",
              type: "u64"
            },
            {
              name: "amountSpecifiedIsInput",
              type: "bool"
            },
            {
              name: "aToBOne",
              type: "bool"
            },
            {
              name: "aToBTwo",
              type: "bool"
            },
            {
              name: "sqrtPriceLimitOne",
              type: "u128"
            },
            {
              name: "sqrtPriceLimitTwo",
              type: "u128"
            }
          ]
        },
        {
          name: "initializePositionBundle",
          docs: [
            "Initializes a PositionBundle account that bundles several positions.",
            "A unique token will be minted to represent the position bundle in the users wallet."
          ],
          accounts: [
            {
              name: "positionBundle",
              isMut: true,
              isSigner: false
            },
            {
              name: "positionBundleMint",
              isMut: true,
              isSigner: true
            },
            {
              name: "positionBundleTokenAccount",
              isMut: true,
              isSigner: false
            },
            {
              name: "positionBundleOwner",
              isMut: false,
              isSigner: false
            },
            {
              name: "funder",
              isMut: true,
              isSigner: true
            },
            {
              name: "tokenProgram",
              isMut: false,
              isSigner: false
            },
            {
              name: "systemProgram",
              isMut: false,
              isSigner: false
            },
            {
              name: "rent",
              isMut: false,
              isSigner: false
            },
            {
              name: "associatedTokenProgram",
              isMut: false,
              isSigner: false
            }
          ],
          args: []
        },
        {
          name: "initializePositionBundleWithMetadata",
          docs: [
            "Initializes a PositionBundle account that bundles several positions.",
            "A unique token will be minted to represent the position bundle in the users wallet.",
            "Additional Metaplex metadata is appended to identify the token."
          ],
          accounts: [
            {
              name: "positionBundle",
              isMut: true,
              isSigner: false
            },
            {
              name: "positionBundleMint",
              isMut: true,
              isSigner: true
            },
            {
              name: "positionBundleMetadata",
              isMut: true,
              isSigner: false,
              docs: [
                "https://github.com/metaplex-foundation/metaplex-program-library/blob/773a574c4b34e5b9f248a81306ec24db064e255f/token-metadata/program/src/utils/metadata.rs#L100"
              ]
            },
            {
              name: "positionBundleTokenAccount",
              isMut: true,
              isSigner: false
            },
            {
              name: "positionBundleOwner",
              isMut: false,
              isSigner: false
            },
            {
              name: "funder",
              isMut: true,
              isSigner: true
            },
            {
              name: "metadataUpdateAuth",
              isMut: false,
              isSigner: false
            },
            {
              name: "tokenProgram",
              isMut: false,
              isSigner: false
            },
            {
              name: "systemProgram",
              isMut: false,
              isSigner: false
            },
            {
              name: "rent",
              isMut: false,
              isSigner: false
            },
            {
              name: "associatedTokenProgram",
              isMut: false,
              isSigner: false
            },
            {
              name: "metadataProgram",
              isMut: false,
              isSigner: false
            }
          ],
          args: []
        },
        {
          name: "deletePositionBundle",
          docs: [
            "Delete a PositionBundle account. Burns the position bundle token in the owner's wallet.",
            "",
            "### Authority",
            "- `position_bundle_owner` - The owner that owns the position bundle token.",
            "",
            "### Special Errors",
            "- `PositionBundleNotDeletable` - The provided position bundle has open positions."
          ],
          accounts: [
            {
              name: "positionBundle",
              isMut: true,
              isSigner: false
            },
            {
              name: "positionBundleMint",
              isMut: true,
              isSigner: false
            },
            {
              name: "positionBundleTokenAccount",
              isMut: true,
              isSigner: false
            },
            {
              name: "positionBundleOwner",
              isMut: false,
              isSigner: true
            },
            {
              name: "receiver",
              isMut: true,
              isSigner: false
            },
            {
              name: "tokenProgram",
              isMut: false,
              isSigner: false
            }
          ],
          args: []
        },
        {
          name: "openBundledPosition",
          docs: [
            "Open a bundled position in a Whirlpool. No new tokens are issued",
            "because the owner of the position bundle becomes the owner of the position.",
            "The position will start off with 0 liquidity.",
            "",
            "### Authority",
            "- `position_bundle_authority` - authority that owns the token corresponding to this desired position bundle.",
            "",
            "### Parameters",
            "- `bundle_index` - The bundle index that we'd like to open.",
            "- `tick_lower_index` - The tick specifying the lower end of the position range.",
            "- `tick_upper_index` - The tick specifying the upper end of the position range.",
            "",
            "#### Special Errors",
            "- `InvalidBundleIndex` - If the provided bundle index is out of bounds.",
            "- `InvalidTickIndex` - If a provided tick is out of bounds, out of order or not a multiple of",
            "the tick-spacing in this pool."
          ],
          accounts: [
            {
              name: "bundledPosition",
              isMut: true,
              isSigner: false
            },
            {
              name: "positionBundle",
              isMut: true,
              isSigner: false
            },
            {
              name: "positionBundleTokenAccount",
              isMut: false,
              isSigner: false
            },
            {
              name: "positionBundleAuthority",
              isMut: false,
              isSigner: true
            },
            {
              name: "whirlpool",
              isMut: false,
              isSigner: false
            },
            {
              name: "funder",
              isMut: true,
              isSigner: true
            },
            {
              name: "systemProgram",
              isMut: false,
              isSigner: false
            },
            {
              name: "rent",
              isMut: false,
              isSigner: false
            }
          ],
          args: [
            {
              name: "bundleIndex",
              type: "u16"
            },
            {
              name: "tickLowerIndex",
              type: "i32"
            },
            {
              name: "tickUpperIndex",
              type: "i32"
            }
          ]
        },
        {
          name: "closeBundledPosition",
          docs: [
            "Close a bundled position in a Whirlpool.",
            "",
            "### Authority",
            "- `position_bundle_authority` - authority that owns the token corresponding to this desired position bundle.",
            "",
            "### Parameters",
            "- `bundle_index` - The bundle index that we'd like to close.",
            "",
            "#### Special Errors",
            "- `InvalidBundleIndex` - If the provided bundle index is out of bounds.",
            "- `ClosePositionNotEmpty` - The provided position account is not empty."
          ],
          accounts: [
            {
              name: "bundledPosition",
              isMut: true,
              isSigner: false
            },
            {
              name: "positionBundle",
              isMut: true,
              isSigner: false
            },
            {
              name: "positionBundleTokenAccount",
              isMut: false,
              isSigner: false
            },
            {
              name: "positionBundleAuthority",
              isMut: false,
              isSigner: true
            },
            {
              name: "receiver",
              isMut: true,
              isSigner: false
            }
          ],
          args: [
            {
              name: "bundleIndex",
              type: "u16"
            }
          ]
        },
        {
          name: "openPositionWithTokenExtensions",
          docs: [
            "Open a position in a Whirlpool. A unique token will be minted to represent the position",
            "in the users wallet. Additional TokenMetadata extension is initialized to identify the token.",
            "Mint and TokenAccount are based on Token-2022.",
            "The position will start off with 0 liquidity.",
            "",
            "### Parameters",
            "- `tick_lower_index` - The tick specifying the lower end of the position range.",
            "- `tick_upper_index` - The tick specifying the upper end of the position range.",
            "- `with_token_metadata_extension` - If true, the token metadata extension will be initialized.",
            "",
            "#### Special Errors",
            "- `InvalidTickIndex` - If a provided tick is out of bounds, out of order or not a multiple of",
            "the tick-spacing in this pool."
          ],
          accounts: [
            {
              name: "funder",
              isMut: true,
              isSigner: true
            },
            {
              name: "owner",
              isMut: false,
              isSigner: false
            },
            {
              name: "position",
              isMut: true,
              isSigner: false
            },
            {
              name: "positionMint",
              isMut: true,
              isSigner: true
            },
            {
              name: "positionTokenAccount",
              isMut: true,
              isSigner: false
            },
            {
              name: "whirlpool",
              isMut: false,
              isSigner: false
            },
            {
              name: "token2022Program",
              isMut: false,
              isSigner: false
            },
            {
              name: "systemProgram",
              isMut: false,
              isSigner: false
            },
            {
              name: "associatedTokenProgram",
              isMut: false,
              isSigner: false
            },
            {
              name: "metadataUpdateAuth",
              isMut: false,
              isSigner: false
            }
          ],
          args: [
            {
              name: "tickLowerIndex",
              type: "i32"
            },
            {
              name: "tickUpperIndex",
              type: "i32"
            },
            {
              name: "withTokenMetadataExtension",
              type: "bool"
            }
          ]
        },
        {
          name: "closePositionWithTokenExtensions",
          docs: [
            "Close a position in a Whirlpool. Burns the position token in the owner's wallet.",
            "Mint and TokenAccount are based on Token-2022. And Mint accout will be also closed.",
            "",
            "### Authority",
            '- "position_authority" - The authority that owns the position token.',
            "",
            "#### Special Errors",
            "- `ClosePositionNotEmpty` - The provided position account is not empty."
          ],
          accounts: [
            {
              name: "positionAuthority",
              isMut: false,
              isSigner: true
            },
            {
              name: "receiver",
              isMut: true,
              isSigner: false
            },
            {
              name: "position",
              isMut: true,
              isSigner: false
            },
            {
              name: "positionMint",
              isMut: true,
              isSigner: false
            },
            {
              name: "positionTokenAccount",
              isMut: true,
              isSigner: false
            },
            {
              name: "token2022Program",
              isMut: false,
              isSigner: false
            }
          ],
          args: []
        },
        {
          name: "lockPosition",
          docs: [
            "Lock the position to prevent any liquidity changes.",
            "",
            "### Authority",
            "- `position_authority` - The authority that owns the position token.",
            "",
            "#### Special Errors",
            "- `PositionAlreadyLocked` - The provided position is already locked.",
            "- `PositionNotLockable` - The provided position is not lockable (e.g. An empty position)."
          ],
          accounts: [
            {
              name: "funder",
              isMut: true,
              isSigner: true
            },
            {
              name: "positionAuthority",
              isMut: false,
              isSigner: true
            },
            {
              name: "position",
              isMut: false,
              isSigner: false
            },
            {
              name: "positionMint",
              isMut: false,
              isSigner: false
            },
            {
              name: "positionTokenAccount",
              isMut: true,
              isSigner: false
            },
            {
              name: "lockConfig",
              isMut: true,
              isSigner: false
            },
            {
              name: "whirlpool",
              isMut: false,
              isSigner: false
            },
            {
              name: "token2022Program",
              isMut: false,
              isSigner: false
            },
            {
              name: "systemProgram",
              isMut: false,
              isSigner: false
            }
          ],
          args: [
            {
              name: "lockType",
              type: {
                defined: "LockType"
              }
            }
          ]
        },
        {
          name: "resetPositionRange",
          docs: [
            "Reset the position range to a new range.",
            "",
            "### Authority",
            "- `position_authority` - The authority that owns the position token.",
            "",
            "### Parameters",
            "- `new_tick_lower_index` - The new tick specifying the lower end of the position range.",
            "- `new_tick_upper_index` - The new tick specifying the upper end of the position range.",
            "",
            "#### Special Errors",
            "- `InvalidTickIndex` - If a provided tick is out of bounds, out of order or not a multiple of",
            "the tick-spacing in this pool.",
            "- `ClosePositionNotEmpty` - The provided position account is not empty.",
            "- `SameTickRangeNotAllowed` - The provided tick range is the same as the current tick range."
          ],
          accounts: [
            {
              name: "funder",
              isMut: true,
              isSigner: true
            },
            {
              name: "positionAuthority",
              isMut: false,
              isSigner: true
            },
            {
              name: "whirlpool",
              isMut: false,
              isSigner: false
            },
            {
              name: "position",
              isMut: true,
              isSigner: false
            },
            {
              name: "positionTokenAccount",
              isMut: false,
              isSigner: false
            },
            {
              name: "systemProgram",
              isMut: false,
              isSigner: false
            }
          ],
          args: [
            {
              name: "newTickLowerIndex",
              type: "i32"
            },
            {
              name: "newTickUpperIndex",
              type: "i32"
            }
          ]
        },
        {
          name: "transferLockedPosition",
          docs: [
            "Transfer a locked position to to a different token account.",
            "",
            "### Authority",
            "- `position_authority` - The authority that owns the position token."
          ],
          accounts: [
            {
              name: "positionAuthority",
              isMut: false,
              isSigner: true
            },
            {
              name: "receiver",
              isMut: true,
              isSigner: false
            },
            {
              name: "position",
              isMut: false,
              isSigner: false
            },
            {
              name: "positionMint",
              isMut: false,
              isSigner: false
            },
            {
              name: "positionTokenAccount",
              isMut: true,
              isSigner: false
            },
            {
              name: "destinationTokenAccount",
              isMut: true,
              isSigner: false
            },
            {
              name: "lockConfig",
              isMut: true,
              isSigner: false
            },
            {
              name: "token2022Program",
              isMut: false,
              isSigner: false
            }
          ],
          args: []
        },
        {
          name: "initializeAdaptiveFeeTier",
          docs: [
            "Initializes an adaptive_fee_tier account usable by Whirlpools in a WhirlpoolConfig space.",
            "",
            "### Authority",
            '- "fee_authority" - Set authority in the WhirlpoolConfig',
            "",
            "### Parameters",
            "- `fee_tier_index` - The index of the fee-tier that this adaptive fee tier will be initialized.",
            "- `tick_spacing` - The tick-spacing that this fee-tier suggests the default_fee_rate for.",
            "- `initialize_pool_authority` - The authority that can initialize pools with this adaptive fee-tier.",
            "- `delegated_fee_authority` - The authority that can set the base fee rate for pools using this adaptive fee-tier.",
            "- `default_fee_rate` - The default fee rate that a pool will use if the pool uses this",
            "fee tier during initialization.",
            "- `filter_period` - Period determine high frequency trading time window. (seconds)",
            "- `decay_period` - Period determine when the adaptive fee start decrease. (seconds)",
            "- `reduction_factor` - Adaptive fee rate decrement rate.",
            "- `adaptive_fee_control_factor` - Adaptive fee control factor.",
            "- `max_volatility_accumulator` - Max volatility accumulator.",
            "- `tick_group_size` - Tick group size to define tick group index.",
            "- `major_swap_threshold_ticks` - Major swap threshold ticks to define major swap.",
            "",
            "#### Special Errors",
            "- `InvalidTickSpacing` - If the provided tick_spacing is 0.",
            "- `InvalidFeeTierIndex` - If the provided fee_tier_index is same to tick_spacing.",
            "- `FeeRateMaxExceeded` - If the provided default_fee_rate exceeds MAX_FEE_RATE.",
            "- `InvalidAdaptiveFeeConstants` - If the provided adaptive fee constants are invalid."
          ],
          accounts: [
            {
              name: "whirlpoolsConfig",
              isMut: false,
              isSigner: false
            },
            {
              name: "adaptiveFeeTier",
              isMut: true,
              isSigner: false
            },
            {
              name: "funder",
              isMut: true,
              isSigner: true
            },
            {
              name: "feeAuthority",
              isMut: false,
              isSigner: true
            },
            {
              name: "systemProgram",
              isMut: false,
              isSigner: false
            }
          ],
          args: [
            {
              name: "feeTierIndex",
              type: "u16"
            },
            {
              name: "tickSpacing",
              type: "u16"
            },
            {
              name: "initializePoolAuthority",
              type: "publicKey"
            },
            {
              name: "delegatedFeeAuthority",
              type: "publicKey"
            },
            {
              name: "defaultBaseFeeRate",
              type: "u16"
            },
            {
              name: "filterPeriod",
              type: "u16"
            },
            {
              name: "decayPeriod",
              type: "u16"
            },
            {
              name: "reductionFactor",
              type: "u16"
            },
            {
              name: "adaptiveFeeControlFactor",
              type: "u32"
            },
            {
              name: "maxVolatilityAccumulator",
              type: "u32"
            },
            {
              name: "tickGroupSize",
              type: "u16"
            },
            {
              name: "majorSwapThresholdTicks",
              type: "u16"
            }
          ]
        },
        {
          name: "setDefaultBaseFeeRate",
          docs: [
            "Set the default_base_fee_rate for an AdaptiveFeeTier",
            "Only the current fee authority in WhirlpoolsConfig has permission to invoke this instruction.",
            "",
            "### Authority",
            '- "fee_authority" - Set authority in the WhirlpoolConfig',
            "",
            "### Parameters",
            "- `default_base_fee_rate` - The default base fee rate that a pool will use if the pool uses this",
            "adaptive fee-tier during initialization.",
            "",
            "#### Special Errors",
            "- `FeeRateMaxExceeded` - If the provided default_fee_rate exceeds MAX_FEE_RATE."
          ],
          accounts: [
            {
              name: "whirlpoolsConfig",
              isMut: false,
              isSigner: false
            },
            {
              name: "adaptiveFeeTier",
              isMut: true,
              isSigner: false
            },
            {
              name: "feeAuthority",
              isMut: false,
              isSigner: true
            }
          ],
          args: [
            {
              name: "defaultBaseFeeRate",
              type: "u16"
            }
          ]
        },
        {
          name: "setDelegatedFeeAuthority",
          docs: [
            "Sets the delegated fee authority for an AdaptiveFeeTier.",
            "The delegated fee authority can set the fee rate for individual pools initialized with the adaptive fee-tier.",
            "Only the current fee authority in WhirlpoolsConfig has permission to invoke this instruction.",
            "",
            "### Authority",
            '- "fee_authority" - Set authority in the WhirlpoolConfig'
          ],
          accounts: [
            {
              name: "whirlpoolsConfig",
              isMut: false,
              isSigner: false
            },
            {
              name: "adaptiveFeeTier",
              isMut: true,
              isSigner: false
            },
            {
              name: "feeAuthority",
              isMut: false,
              isSigner: true
            },
            {
              name: "newDelegatedFeeAuthority",
              isMut: false,
              isSigner: false
            }
          ],
          args: []
        },
        {
          name: "setInitializePoolAuthority",
          docs: [
            "Sets the initialize pool authority for an AdaptiveFeeTier.",
            "Only the initialize pool authority can initialize pools with the adaptive fee-tier.",
            "Only the current fee authority in WhirlpoolsConfig has permission to invoke this instruction.",
            "",
            "### Authority",
            '- "fee_authority" - Set authority in the WhirlpoolConfig'
          ],
          accounts: [
            {
              name: "whirlpoolsConfig",
              isMut: false,
              isSigner: false
            },
            {
              name: "adaptiveFeeTier",
              isMut: true,
              isSigner: false
            },
            {
              name: "feeAuthority",
              isMut: false,
              isSigner: true
            },
            {
              name: "newInitializePoolAuthority",
              isMut: false,
              isSigner: false
            }
          ],
          args: []
        },
        {
          name: "setPresetAdaptiveFeeConstants",
          docs: [
            "Sets the adaptive fee constants for an AdaptiveFeeTier.",
            "Only the current fee authority in WhirlpoolsConfig has permission to invoke this instruction.",
            "",
            "### Authority",
            '- "fee_authority" - Set authority in the WhirlpoolConfig',
            "",
            "### Parameters",
            "- `filter_period` - Period determine high frequency trading time window. (seconds)",
            "- `decay_period` - Period determine when the adaptive fee start decrease. (seconds)",
            "- `reduction_factor` - Adaptive fee rate decrement rate.",
            "- `adaptive_fee_control_factor` - Adaptive fee control factor.",
            "- `max_volatility_accumulator` - Max volatility accumulator.",
            "- `tick_group_size` - Tick group size to define tick group index.",
            "- `major_swap_threshold_ticks` - Major swap threshold ticks to define major swap."
          ],
          accounts: [
            {
              name: "whirlpoolsConfig",
              isMut: false,
              isSigner: false
            },
            {
              name: "adaptiveFeeTier",
              isMut: true,
              isSigner: false
            },
            {
              name: "feeAuthority",
              isMut: false,
              isSigner: true
            }
          ],
          args: [
            {
              name: "filterPeriod",
              type: "u16"
            },
            {
              name: "decayPeriod",
              type: "u16"
            },
            {
              name: "reductionFactor",
              type: "u16"
            },
            {
              name: "adaptiveFeeControlFactor",
              type: "u32"
            },
            {
              name: "maxVolatilityAccumulator",
              type: "u32"
            },
            {
              name: "tickGroupSize",
              type: "u16"
            },
            {
              name: "majorSwapThresholdTicks",
              type: "u16"
            }
          ]
        },
        {
          name: "initializePoolWithAdaptiveFee",
          docs: [
            "Initializes a Whirlpool account and Oracle account with adaptive fee.",
            "",
            "### Parameters",
            "- `initial_sqrt_price` - The desired initial sqrt-price for this pool",
            "- `trade_enable_timestamp` - The timestamp when trading is enabled for this pool (within 72 hours)",
            "",
            "#### Special Errors",
            "`InvalidTokenMintOrder` - The order of mints have to be ordered by",
            "`SqrtPriceOutOfBounds` - provided initial_sqrt_price is not between 2^-64 to 2^64",
            "`InvalidTradeEnableTimestamp` - provided trade_enable_timestamp is not within 72 hours or the adaptive fee-tier is permission-less",
            "`UnsupportedTokenMint` - The provided token mint is not supported by the program (e.g. it has risky token extensions)",
            ""
          ],
          accounts: [
            {
              name: "whirlpoolsConfig",
              isMut: false,
              isSigner: false
            },
            {
              name: "tokenMintA",
              isMut: false,
              isSigner: false
            },
            {
              name: "tokenMintB",
              isMut: false,
              isSigner: false
            },
            {
              name: "tokenBadgeA",
              isMut: false,
              isSigner: false
            },
            {
              name: "tokenBadgeB",
              isMut: false,
              isSigner: false
            },
            {
              name: "funder",
              isMut: true,
              isSigner: true
            },
            {
              name: "initializePoolAuthority",
              isMut: false,
              isSigner: true
            },
            {
              name: "whirlpool",
              isMut: true,
              isSigner: false
            },
            {
              name: "oracle",
              isMut: true,
              isSigner: false
            },
            {
              name: "tokenVaultA",
              isMut: true,
              isSigner: true
            },
            {
              name: "tokenVaultB",
              isMut: true,
              isSigner: true
            },
            {
              name: "adaptiveFeeTier",
              isMut: false,
              isSigner: false
            },
            {
              name: "tokenProgramA",
              isMut: false,
              isSigner: false
            },
            {
              name: "tokenProgramB",
              isMut: false,
              isSigner: false
            },
            {
              name: "systemProgram",
              isMut: false,
              isSigner: false
            },
            {
              name: "rent",
              isMut: false,
              isSigner: false
            }
          ],
          args: [
            {
              name: "initialSqrtPrice",
              type: "u128"
            },
            {
              name: "tradeEnableTimestamp",
              type: {
                option: "u64"
              }
            }
          ]
        },
        {
          name: "setFeeRateByDelegatedFeeAuthority",
          docs: [
            "Sets the fee rate for a Whirlpool by the delegated fee authority in AdaptiveFeeTier.",
            "Fee rate is represented as hundredths of a basis point.",
            "",
            "### Authority",
            '- "delegated_fee_authority" - Set authority that can modify pool fees in the AdaptiveFeeTier',
            "",
            "### Parameters",
            "- `fee_rate` - The rate that the pool will use to calculate fees going onwards.",
            "",
            "#### Special Errors",
            "- `FeeRateMaxExceeded` - If the provided fee_rate exceeds MAX_FEE_RATE."
          ],
          accounts: [
            {
              name: "whirlpool",
              isMut: true,
              isSigner: false
            },
            {
              name: "adaptiveFeeTier",
              isMut: false,
              isSigner: false
            },
            {
              name: "delegatedFeeAuthority",
              isMut: false,
              isSigner: true
            }
          ],
          args: [
            {
              name: "feeRate",
              type: "u16"
            }
          ]
        },
        {
          name: "collectFeesV2",
          docs: [
            "Collect fees accrued for this position.",
            "",
            "### Authority",
            "- `position_authority` - authority that owns the token corresponding to this desired position."
          ],
          accounts: [
            {
              name: "whirlpool",
              isMut: false,
              isSigner: false
            },
            {
              name: "positionAuthority",
              isMut: false,
              isSigner: true
            },
            {
              name: "position",
              isMut: true,
              isSigner: false
            },
            {
              name: "positionTokenAccount",
              isMut: false,
              isSigner: false
            },
            {
              name: "tokenMintA",
              isMut: false,
              isSigner: false
            },
            {
              name: "tokenMintB",
              isMut: false,
              isSigner: false
            },
            {
              name: "tokenOwnerAccountA",
              isMut: true,
              isSigner: false
            },
            {
              name: "tokenVaultA",
              isMut: true,
              isSigner: false
            },
            {
              name: "tokenOwnerAccountB",
              isMut: true,
              isSigner: false
            },
            {
              name: "tokenVaultB",
              isMut: true,
              isSigner: false
            },
            {
              name: "tokenProgramA",
              isMut: false,
              isSigner: false
            },
            {
              name: "tokenProgramB",
              isMut: false,
              isSigner: false
            },
            {
              name: "memoProgram",
              isMut: false,
              isSigner: false
            }
          ],
          args: [
            {
              name: "remainingAccountsInfo",
              type: {
                option: {
                  defined: "RemainingAccountsInfo"
                }
              }
            }
          ]
        },
        {
          name: "collectProtocolFeesV2",
          docs: [
            "Collect the protocol fees accrued in this Whirlpool",
            "",
            "### Authority",
            "- `collect_protocol_fees_authority` - assigned authority in the WhirlpoolConfig that can collect protocol fees"
          ],
          accounts: [
            {
              name: "whirlpoolsConfig",
              isMut: false,
              isSigner: false
            },
            {
              name: "whirlpool",
              isMut: true,
              isSigner: false
            },
            {
              name: "collectProtocolFeesAuthority",
              isMut: false,
              isSigner: true
            },
            {
              name: "tokenMintA",
              isMut: false,
              isSigner: false
            },
            {
              name: "tokenMintB",
              isMut: false,
              isSigner: false
            },
            {
              name: "tokenVaultA",
              isMut: true,
              isSigner: false
            },
            {
              name: "tokenVaultB",
              isMut: true,
              isSigner: false
            },
            {
              name: "tokenDestinationA",
              isMut: true,
              isSigner: false
            },
            {
              name: "tokenDestinationB",
              isMut: true,
              isSigner: false
            },
            {
              name: "tokenProgramA",
              isMut: false,
              isSigner: false
            },
            {
              name: "tokenProgramB",
              isMut: false,
              isSigner: false
            },
            {
              name: "memoProgram",
              isMut: false,
              isSigner: false
            }
          ],
          args: [
            {
              name: "remainingAccountsInfo",
              type: {
                option: {
                  defined: "RemainingAccountsInfo"
                }
              }
            }
          ]
        },
        {
          name: "collectRewardV2",
          docs: [
            "Collect rewards accrued for this position.",
            "",
            "### Authority",
            "- `position_authority` - authority that owns the token corresponding to this desired position."
          ],
          accounts: [
            {
              name: "whirlpool",
              isMut: false,
              isSigner: false
            },
            {
              name: "positionAuthority",
              isMut: false,
              isSigner: true
            },
            {
              name: "position",
              isMut: true,
              isSigner: false
            },
            {
              name: "positionTokenAccount",
              isMut: false,
              isSigner: false
            },
            {
              name: "rewardOwnerAccount",
              isMut: true,
              isSigner: false
            },
            {
              name: "rewardMint",
              isMut: false,
              isSigner: false
            },
            {
              name: "rewardVault",
              isMut: true,
              isSigner: false
            },
            {
              name: "rewardTokenProgram",
              isMut: false,
              isSigner: false
            },
            {
              name: "memoProgram",
              isMut: false,
              isSigner: false
            }
          ],
          args: [
            {
              name: "rewardIndex",
              type: "u8"
            },
            {
              name: "remainingAccountsInfo",
              type: {
                option: {
                  defined: "RemainingAccountsInfo"
                }
              }
            }
          ]
        },
        {
          name: "decreaseLiquidityV2",
          docs: [
            "Withdraw liquidity from a position in the Whirlpool. This call also updates the position's accrued fees and rewards.",
            "",
            "### Authority",
            "- `position_authority` - authority that owns the token corresponding to this desired position.",
            "",
            "### Parameters",
            "- `liquidity_amount` - The total amount of Liquidity the user desires to withdraw.",
            "- `token_min_a` - The minimum amount of tokenA the user is willing to withdraw.",
            "- `token_min_b` - The minimum amount of tokenB the user is willing to withdraw.",
            "",
            "#### Special Errors",
            "- `LiquidityZero` - Provided liquidity amount is zero.",
            "- `LiquidityTooHigh` - Provided liquidity exceeds u128::max.",
            "- `TokenMinSubceeded` - The required token to perform this operation subceeds the user defined amount."
          ],
          accounts: [
            {
              name: "whirlpool",
              isMut: true,
              isSigner: false
            },
            {
              name: "tokenProgramA",
              isMut: false,
              isSigner: false
            },
            {
              name: "tokenProgramB",
              isMut: false,
              isSigner: false
            },
            {
              name: "memoProgram",
              isMut: false,
              isSigner: false
            },
            {
              name: "positionAuthority",
              isMut: false,
              isSigner: true
            },
            {
              name: "position",
              isMut: true,
              isSigner: false
            },
            {
              name: "positionTokenAccount",
              isMut: false,
              isSigner: false
            },
            {
              name: "tokenMintA",
              isMut: false,
              isSigner: false
            },
            {
              name: "tokenMintB",
              isMut: false,
              isSigner: false
            },
            {
              name: "tokenOwnerAccountA",
              isMut: true,
              isSigner: false
            },
            {
              name: "tokenOwnerAccountB",
              isMut: true,
              isSigner: false
            },
            {
              name: "tokenVaultA",
              isMut: true,
              isSigner: false
            },
            {
              name: "tokenVaultB",
              isMut: true,
              isSigner: false
            },
            {
              name: "tickArrayLower",
              isMut: true,
              isSigner: false
            },
            {
              name: "tickArrayUpper",
              isMut: true,
              isSigner: false
            }
          ],
          args: [
            {
              name: "liquidityAmount",
              type: "u128"
            },
            {
              name: "tokenMinA",
              type: "u64"
            },
            {
              name: "tokenMinB",
              type: "u64"
            },
            {
              name: "remainingAccountsInfo",
              type: {
                option: {
                  defined: "RemainingAccountsInfo"
                }
              }
            }
          ]
        },
        {
          name: "increaseLiquidityV2",
          docs: [
            "Add liquidity to a position in the Whirlpool. This call also updates the position's accrued fees and rewards.",
            "",
            "### Authority",
            "- `position_authority` - authority that owns the token corresponding to this desired position.",
            "",
            "### Parameters",
            "- `liquidity_amount` - The total amount of Liquidity the user is willing to deposit.",
            "- `token_max_a` - The maximum amount of tokenA the user is willing to deposit.",
            "- `token_max_b` - The maximum amount of tokenB the user is willing to deposit.",
            "",
            "#### Special Errors",
            "- `LiquidityZero` - Provided liquidity amount is zero.",
            "- `LiquidityTooHigh` - Provided liquidity exceeds u128::max.",
            "- `TokenMaxExceeded` - The required token to perform this operation exceeds the user defined amount."
          ],
          accounts: [
            {
              name: "whirlpool",
              isMut: true,
              isSigner: false
            },
            {
              name: "tokenProgramA",
              isMut: false,
              isSigner: false
            },
            {
              name: "tokenProgramB",
              isMut: false,
              isSigner: false
            },
            {
              name: "memoProgram",
              isMut: false,
              isSigner: false
            },
            {
              name: "positionAuthority",
              isMut: false,
              isSigner: true
            },
            {
              name: "position",
              isMut: true,
              isSigner: false
            },
            {
              name: "positionTokenAccount",
              isMut: false,
              isSigner: false
            },
            {
              name: "tokenMintA",
              isMut: false,
              isSigner: false
            },
            {
              name: "tokenMintB",
              isMut: false,
              isSigner: false
            },
            {
              name: "tokenOwnerAccountA",
              isMut: true,
              isSigner: false
            },
            {
              name: "tokenOwnerAccountB",
              isMut: true,
              isSigner: false
            },
            {
              name: "tokenVaultA",
              isMut: true,
              isSigner: false
            },
            {
              name: "tokenVaultB",
              isMut: true,
              isSigner: false
            },
            {
              name: "tickArrayLower",
              isMut: true,
              isSigner: false
            },
            {
              name: "tickArrayUpper",
              isMut: true,
              isSigner: false
            }
          ],
          args: [
            {
              name: "liquidityAmount",
              type: "u128"
            },
            {
              name: "tokenMaxA",
              type: "u64"
            },
            {
              name: "tokenMaxB",
              type: "u64"
            },
            {
              name: "remainingAccountsInfo",
              type: {
                option: {
                  defined: "RemainingAccountsInfo"
                }
              }
            }
          ]
        },
        {
          name: "initializePoolV2",
          docs: [
            "Initializes a Whirlpool account.",
            "Fee rate is set to the default values on the config and supplied fee_tier.",
            "",
            "### Parameters",
            "- `bumps` - The bump value when deriving the PDA of the Whirlpool address.",
            "- `tick_spacing` - The desired tick spacing for this pool.",
            "- `initial_sqrt_price` - The desired initial sqrt-price for this pool",
            "",
            "#### Special Errors",
            "`InvalidTokenMintOrder` - The order of mints have to be ordered by",
            "`SqrtPriceOutOfBounds` - provided initial_sqrt_price is not between 2^-64 to 2^64",
            ""
          ],
          accounts: [
            {
              name: "whirlpoolsConfig",
              isMut: false,
              isSigner: false
            },
            {
              name: "tokenMintA",
              isMut: false,
              isSigner: false
            },
            {
              name: "tokenMintB",
              isMut: false,
              isSigner: false
            },
            {
              name: "tokenBadgeA",
              isMut: false,
              isSigner: false
            },
            {
              name: "tokenBadgeB",
              isMut: false,
              isSigner: false
            },
            {
              name: "funder",
              isMut: true,
              isSigner: true
            },
            {
              name: "whirlpool",
              isMut: true,
              isSigner: false
            },
            {
              name: "tokenVaultA",
              isMut: true,
              isSigner: true
            },
            {
              name: "tokenVaultB",
              isMut: true,
              isSigner: true
            },
            {
              name: "feeTier",
              isMut: false,
              isSigner: false
            },
            {
              name: "tokenProgramA",
              isMut: false,
              isSigner: false
            },
            {
              name: "tokenProgramB",
              isMut: false,
              isSigner: false
            },
            {
              name: "systemProgram",
              isMut: false,
              isSigner: false
            },
            {
              name: "rent",
              isMut: false,
              isSigner: false
            }
          ],
          args: [
            {
              name: "tickSpacing",
              type: "u16"
            },
            {
              name: "initialSqrtPrice",
              type: "u128"
            }
          ]
        },
        {
          name: "initializeRewardV2",
          docs: [
            "Initialize reward for a Whirlpool. A pool can only support up to a set number of rewards.",
            "",
            "### Authority",
            '- "reward_authority" - assigned authority by the reward_super_authority for the specified',
            "reward-index in this Whirlpool",
            "",
            "### Parameters",
            "- `reward_index` - The reward index that we'd like to initialize. (0 <= index <= NUM_REWARDS)",
            "",
            "#### Special Errors",
            "- `InvalidRewardIndex` - If the provided reward index doesn't match the lowest uninitialized",
            "index in this pool, or exceeds NUM_REWARDS, or",
            "all reward slots for this pool has been initialized."
          ],
          accounts: [
            {
              name: "rewardAuthority",
              isMut: false,
              isSigner: true
            },
            {
              name: "funder",
              isMut: true,
              isSigner: true
            },
            {
              name: "whirlpool",
              isMut: true,
              isSigner: false
            },
            {
              name: "rewardMint",
              isMut: false,
              isSigner: false
            },
            {
              name: "rewardTokenBadge",
              isMut: false,
              isSigner: false
            },
            {
              name: "rewardVault",
              isMut: true,
              isSigner: true
            },
            {
              name: "rewardTokenProgram",
              isMut: false,
              isSigner: false
            },
            {
              name: "systemProgram",
              isMut: false,
              isSigner: false
            },
            {
              name: "rent",
              isMut: false,
              isSigner: false
            }
          ],
          args: [
            {
              name: "rewardIndex",
              type: "u8"
            }
          ]
        },
        {
          name: "setRewardEmissionsV2",
          docs: [
            "Set the reward emissions for a reward in a Whirlpool.",
            "",
            "### Authority",
            '- "reward_authority" - assigned authority by the reward_super_authority for the specified',
            "reward-index in this Whirlpool",
            "",
            "### Parameters",
            "- `reward_index` - The reward index (0 <= index <= NUM_REWARDS) that we'd like to modify.",
            "- `emissions_per_second_x64` - The amount of rewards emitted in this pool.",
            "",
            "#### Special Errors",
            "- `RewardVaultAmountInsufficient` - The amount of rewards in the reward vault cannot emit",
            "more than a day of desired emissions.",
            "- `InvalidTimestamp` - Provided timestamp is not in order with the previous timestamp.",
            "- `InvalidRewardIndex` - If the provided reward index doesn't match the lowest uninitialized",
            "index in this pool, or exceeds NUM_REWARDS, or",
            "all reward slots for this pool has been initialized."
          ],
          accounts: [
            {
              name: "whirlpool",
              isMut: true,
              isSigner: false
            },
            {
              name: "rewardAuthority",
              isMut: false,
              isSigner: true
            },
            {
              name: "rewardVault",
              isMut: false,
              isSigner: false
            }
          ],
          args: [
            {
              name: "rewardIndex",
              type: "u8"
            },
            {
              name: "emissionsPerSecondX64",
              type: "u128"
            }
          ]
        },
        {
          name: "swapV2",
          docs: [
            "Perform a swap in this Whirlpool",
            "",
            "### Authority",
            '- "token_authority" - The authority to withdraw tokens from the input token account.',
            "",
            "### Parameters",
            "- `amount` - The amount of input or output token to swap from (depending on amount_specified_is_input).",
            "- `other_amount_threshold` - The maximum/minimum of input/output token to swap into (depending on amount_specified_is_input).",
            "- `sqrt_price_limit` - The maximum/minimum price the swap will swap to.",
            "- `amount_specified_is_input` - Specifies the token the parameter `amount`represents. If true, the amount represents the input token of the swap.",
            "- `a_to_b` - The direction of the swap. True if swapping from A to B. False if swapping from B to A.",
            "",
            "#### Special Errors",
            "- `ZeroTradableAmount` - User provided parameter `amount` is 0.",
            "- `InvalidSqrtPriceLimitDirection` - User provided parameter `sqrt_price_limit` does not match the direction of the trade.",
            "- `SqrtPriceOutOfBounds` - User provided parameter `sqrt_price_limit` is over Whirlppool's max/min bounds for sqrt-price.",
            "- `InvalidTickArraySequence` - User provided tick-arrays are not in sequential order required to proceed in this trade direction.",
            "- `TickArraySequenceInvalidIndex` - The swap loop attempted to access an invalid array index during the query of the next initialized tick.",
            "- `TickArrayIndexOutofBounds` - The swap loop attempted to access an invalid array index during tick crossing.",
            "- `LiquidityOverflow` - Liquidity value overflowed 128bits during tick crossing.",
            "- `InvalidTickSpacing` - The swap pool was initialized with tick-spacing of 0."
          ],
          accounts: [
            {
              name: "tokenProgramA",
              isMut: false,
              isSigner: false
            },
            {
              name: "tokenProgramB",
              isMut: false,
              isSigner: false
            },
            {
              name: "memoProgram",
              isMut: false,
              isSigner: false
            },
            {
              name: "tokenAuthority",
              isMut: false,
              isSigner: true
            },
            {
              name: "whirlpool",
              isMut: true,
              isSigner: false
            },
            {
              name: "tokenMintA",
              isMut: false,
              isSigner: false
            },
            {
              name: "tokenMintB",
              isMut: false,
              isSigner: false
            },
            {
              name: "tokenOwnerAccountA",
              isMut: true,
              isSigner: false
            },
            {
              name: "tokenVaultA",
              isMut: true,
              isSigner: false
            },
            {
              name: "tokenOwnerAccountB",
              isMut: true,
              isSigner: false
            },
            {
              name: "tokenVaultB",
              isMut: true,
              isSigner: false
            },
            {
              name: "tickArray0",
              isMut: true,
              isSigner: false
            },
            {
              name: "tickArray1",
              isMut: true,
              isSigner: false
            },
            {
              name: "tickArray2",
              isMut: true,
              isSigner: false
            },
            {
              name: "oracle",
              isMut: true,
              isSigner: false
            }
          ],
          args: [
            {
              name: "amount",
              type: "u64"
            },
            {
              name: "otherAmountThreshold",
              type: "u64"
            },
            {
              name: "sqrtPriceLimit",
              type: "u128"
            },
            {
              name: "amountSpecifiedIsInput",
              type: "bool"
            },
            {
              name: "aToB",
              type: "bool"
            },
            {
              name: "remainingAccountsInfo",
              type: {
                option: {
                  defined: "RemainingAccountsInfo"
                }
              }
            }
          ]
        },
        {
          name: "twoHopSwapV2",
          docs: [
            "Perform a two-hop swap in this Whirlpool",
            "",
            "### Authority",
            '- "token_authority" - The authority to withdraw tokens from the input token account.',
            "",
            "### Parameters",
            "- `amount` - The amount of input or output token to swap from (depending on amount_specified_is_input).",
            "- `other_amount_threshold` - The maximum/minimum of input/output token to swap into (depending on amount_specified_is_input).",
            "- `amount_specified_is_input` - Specifies the token the parameter `amount`represents. If true, the amount represents the input token of the swap.",
            "- `a_to_b_one` - The direction of the swap of hop one. True if swapping from A to B. False if swapping from B to A.",
            "- `a_to_b_two` - The direction of the swap of hop two. True if swapping from A to B. False if swapping from B to A.",
            "- `sqrt_price_limit_one` - The maximum/minimum price the swap will swap to in the first hop.",
            "- `sqrt_price_limit_two` - The maximum/minimum price the swap will swap to in the second hop.",
            "",
            "#### Special Errors",
            "- `ZeroTradableAmount` - User provided parameter `amount` is 0.",
            "- `InvalidSqrtPriceLimitDirection` - User provided parameter `sqrt_price_limit` does not match the direction of the trade.",
            "- `SqrtPriceOutOfBounds` - User provided parameter `sqrt_price_limit` is over Whirlppool's max/min bounds for sqrt-price.",
            "- `InvalidTickArraySequence` - User provided tick-arrays are not in sequential order required to proceed in this trade direction.",
            "- `TickArraySequenceInvalidIndex` - The swap loop attempted to access an invalid array index during the query of the next initialized tick.",
            "- `TickArrayIndexOutofBounds` - The swap loop attempted to access an invalid array index during tick crossing.",
            "- `LiquidityOverflow` - Liquidity value overflowed 128bits during tick crossing.",
            "- `InvalidTickSpacing` - The swap pool was initialized with tick-spacing of 0.",
            "- `InvalidIntermediaryMint` - Error if the intermediary mint between hop one and two do not equal.",
            "- `DuplicateTwoHopPool` - Error if whirlpool one & two are the same pool."
          ],
          accounts: [
            {
              name: "whirlpoolOne",
              isMut: true,
              isSigner: false
            },
            {
              name: "whirlpoolTwo",
              isMut: true,
              isSigner: false
            },
            {
              name: "tokenMintInput",
              isMut: false,
              isSigner: false
            },
            {
              name: "tokenMintIntermediate",
              isMut: false,
              isSigner: false
            },
            {
              name: "tokenMintOutput",
              isMut: false,
              isSigner: false
            },
            {
              name: "tokenProgramInput",
              isMut: false,
              isSigner: false
            },
            {
              name: "tokenProgramIntermediate",
              isMut: false,
              isSigner: false
            },
            {
              name: "tokenProgramOutput",
              isMut: false,
              isSigner: false
            },
            {
              name: "tokenOwnerAccountInput",
              isMut: true,
              isSigner: false
            },
            {
              name: "tokenVaultOneInput",
              isMut: true,
              isSigner: false
            },
            {
              name: "tokenVaultOneIntermediate",
              isMut: true,
              isSigner: false
            },
            {
              name: "tokenVaultTwoIntermediate",
              isMut: true,
              isSigner: false
            },
            {
              name: "tokenVaultTwoOutput",
              isMut: true,
              isSigner: false
            },
            {
              name: "tokenOwnerAccountOutput",
              isMut: true,
              isSigner: false
            },
            {
              name: "tokenAuthority",
              isMut: false,
              isSigner: true
            },
            {
              name: "tickArrayOne0",
              isMut: true,
              isSigner: false
            },
            {
              name: "tickArrayOne1",
              isMut: true,
              isSigner: false
            },
            {
              name: "tickArrayOne2",
              isMut: true,
              isSigner: false
            },
            {
              name: "tickArrayTwo0",
              isMut: true,
              isSigner: false
            },
            {
              name: "tickArrayTwo1",
              isMut: true,
              isSigner: false
            },
            {
              name: "tickArrayTwo2",
              isMut: true,
              isSigner: false
            },
            {
              name: "oracleOne",
              isMut: true,
              isSigner: false
            },
            {
              name: "oracleTwo",
              isMut: true,
              isSigner: false
            },
            {
              name: "memoProgram",
              isMut: false,
              isSigner: false
            }
          ],
          args: [
            {
              name: "amount",
              type: "u64"
            },
            {
              name: "otherAmountThreshold",
              type: "u64"
            },
            {
              name: "amountSpecifiedIsInput",
              type: "bool"
            },
            {
              name: "aToBOne",
              type: "bool"
            },
            {
              name: "aToBTwo",
              type: "bool"
            },
            {
              name: "sqrtPriceLimitOne",
              type: "u128"
            },
            {
              name: "sqrtPriceLimitTwo",
              type: "u128"
            },
            {
              name: "remainingAccountsInfo",
              type: {
                option: {
                  defined: "RemainingAccountsInfo"
                }
              }
            }
          ]
        },
        {
          name: "initializeConfigExtension",
          accounts: [
            {
              name: "config",
              isMut: false,
              isSigner: false
            },
            {
              name: "configExtension",
              isMut: true,
              isSigner: false
            },
            {
              name: "funder",
              isMut: true,
              isSigner: true
            },
            {
              name: "feeAuthority",
              isMut: false,
              isSigner: true
            },
            {
              name: "systemProgram",
              isMut: false,
              isSigner: false
            }
          ],
          args: []
        },
        {
          name: "setConfigExtensionAuthority",
          accounts: [
            {
              name: "whirlpoolsConfig",
              isMut: false,
              isSigner: false
            },
            {
              name: "whirlpoolsConfigExtension",
              isMut: true,
              isSigner: false
            },
            {
              name: "configExtensionAuthority",
              isMut: false,
              isSigner: true
            },
            {
              name: "newConfigExtensionAuthority",
              isMut: false,
              isSigner: false
            }
          ],
          args: []
        },
        {
          name: "setTokenBadgeAuthority",
          accounts: [
            {
              name: "whirlpoolsConfig",
              isMut: false,
              isSigner: false
            },
            {
              name: "whirlpoolsConfigExtension",
              isMut: true,
              isSigner: false
            },
            {
              name: "configExtensionAuthority",
              isMut: false,
              isSigner: true
            },
            {
              name: "newTokenBadgeAuthority",
              isMut: false,
              isSigner: false
            }
          ],
          args: []
        },
        {
          name: "initializeTokenBadge",
          accounts: [
            {
              name: "whirlpoolsConfig",
              isMut: false,
              isSigner: false
            },
            {
              name: "whirlpoolsConfigExtension",
              isMut: false,
              isSigner: false
            },
            {
              name: "tokenBadgeAuthority",
              isMut: false,
              isSigner: true
            },
            {
              name: "tokenMint",
              isMut: false,
              isSigner: false
            },
            {
              name: "tokenBadge",
              isMut: true,
              isSigner: false
            },
            {
              name: "funder",
              isMut: true,
              isSigner: true
            },
            {
              name: "systemProgram",
              isMut: false,
              isSigner: false
            }
          ],
          args: []
        },
        {
          name: "deleteTokenBadge",
          accounts: [
            {
              name: "whirlpoolsConfig",
              isMut: false,
              isSigner: false
            },
            {
              name: "whirlpoolsConfigExtension",
              isMut: false,
              isSigner: false
            },
            {
              name: "tokenBadgeAuthority",
              isMut: false,
              isSigner: true
            },
            {
              name: "tokenMint",
              isMut: false,
              isSigner: false
            },
            {
              name: "tokenBadge",
              isMut: true,
              isSigner: false
            },
            {
              name: "receiver",
              isMut: true,
              isSigner: false
            }
          ],
          args: []
        }
      ],
      accounts: [
        {
          name: "AdaptiveFeeTier",
          type: {
            kind: "struct",
            fields: [
              {
                name: "whirlpoolsConfig",
                type: "publicKey"
              },
              {
                name: "feeTierIndex",
                type: "u16"
              },
              {
                name: "tickSpacing",
                type: "u16"
              },
              {
                name: "initializePoolAuthority",
                type: "publicKey"
              },
              {
                name: "delegatedFeeAuthority",
                type: "publicKey"
              },
              {
                name: "defaultBaseFeeRate",
                type: "u16"
              },
              {
                name: "filterPeriod",
                type: "u16"
              },
              {
                name: "decayPeriod",
                type: "u16"
              },
              {
                name: "reductionFactor",
                type: "u16"
              },
              {
                name: "adaptiveFeeControlFactor",
                type: "u32"
              },
              {
                name: "maxVolatilityAccumulator",
                type: "u32"
              },
              {
                name: "tickGroupSize",
                type: "u16"
              },
              {
                name: "majorSwapThresholdTicks",
                type: "u16"
              }
            ]
          }
        },
        {
          name: "WhirlpoolsConfig",
          type: {
            kind: "struct",
            fields: [
              {
                name: "feeAuthority",
                type: "publicKey"
              },
              {
                name: "collectProtocolFeesAuthority",
                type: "publicKey"
              },
              {
                name: "rewardEmissionsSuperAuthority",
                type: "publicKey"
              },
              {
                name: "defaultProtocolFeeRate",
                type: "u16"
              }
            ]
          }
        },
        {
          name: "WhirlpoolsConfigExtension",
          type: {
            kind: "struct",
            fields: [
              {
                name: "whirlpoolsConfig",
                type: "publicKey"
              },
              {
                name: "configExtensionAuthority",
                type: "publicKey"
              },
              {
                name: "tokenBadgeAuthority",
                type: "publicKey"
              }
            ]
          }
        },
        {
          name: "FeeTier",
          type: {
            kind: "struct",
            fields: [
              {
                name: "whirlpoolsConfig",
                type: "publicKey"
              },
              {
                name: "tickSpacing",
                type: "u16"
              },
              {
                name: "defaultFeeRate",
                type: "u16"
              }
            ]
          }
        },
        {
          name: "LockConfig",
          type: {
            kind: "struct",
            fields: [
              {
                name: "position",
                type: "publicKey"
              },
              {
                name: "positionOwner",
                type: "publicKey"
              },
              {
                name: "whirlpool",
                type: "publicKey"
              },
              {
                name: "lockedTimestamp",
                type: "u64"
              },
              {
                name: "lockType",
                type: {
                  defined: "LockTypeLabel"
                }
              }
            ]
          }
        },
        {
          name: "Oracle",
          type: {
            kind: "struct",
            fields: [
              {
                name: "whirlpool",
                type: "publicKey"
              },
              {
                name: "tradeEnableTimestamp",
                type: "u64"
              },
              {
                name: "adaptiveFeeConstants",
                type: {
                  defined: "AdaptiveFeeConstants"
                }
              },
              {
                name: "adaptiveFeeVariables",
                type: {
                  defined: "AdaptiveFeeVariables"
                }
              },
              {
                name: "reserved",
                type: {
                  array: [
                    "u8",
                    128
                  ]
                }
              }
            ]
          }
        },
        {
          name: "Position",
          type: {
            kind: "struct",
            fields: [
              {
                name: "whirlpool",
                type: "publicKey"
              },
              {
                name: "positionMint",
                type: "publicKey"
              },
              {
                name: "liquidity",
                type: "u128"
              },
              {
                name: "tickLowerIndex",
                type: "i32"
              },
              {
                name: "tickUpperIndex",
                type: "i32"
              },
              {
                name: "feeGrowthCheckpointA",
                type: "u128"
              },
              {
                name: "feeOwedA",
                type: "u64"
              },
              {
                name: "feeGrowthCheckpointB",
                type: "u128"
              },
              {
                name: "feeOwedB",
                type: "u64"
              },
              {
                name: "rewardInfos",
                type: {
                  array: [
                    {
                      defined: "PositionRewardInfo"
                    },
                    3
                  ]
                }
              }
            ]
          }
        },
        {
          name: "PositionBundle",
          type: {
            kind: "struct",
            fields: [
              {
                name: "positionBundleMint",
                type: "publicKey"
              },
              {
                name: "positionBitmap",
                type: {
                  array: [
                    "u8",
                    32
                  ]
                }
              }
            ]
          }
        },
        {
          name: "TickArray",
          type: {
            kind: "struct",
            fields: [
              {
                name: "startTickIndex",
                type: "i32"
              },
              {
                name: "ticks",
                type: {
                  array: [
                    {
                      defined: "Tick"
                    },
                    88
                  ]
                }
              },
              {
                name: "whirlpool",
                type: "publicKey"
              }
            ]
          }
        },
        {
          name: "TokenBadge",
          type: {
            kind: "struct",
            fields: [
              {
                name: "whirlpoolsConfig",
                type: "publicKey"
              },
              {
                name: "tokenMint",
                type: "publicKey"
              }
            ]
          }
        },
        {
          name: "Whirlpool",
          type: {
            kind: "struct",
            fields: [
              {
                name: "whirlpoolsConfig",
                type: "publicKey"
              },
              {
                name: "whirlpoolBump",
                type: {
                  array: [
                    "u8",
                    1
                  ]
                }
              },
              {
                name: "tickSpacing",
                type: "u16"
              },
              {
                name: "feeTierIndexSeed",
                type: {
                  array: [
                    "u8",
                    2
                  ]
                }
              },
              {
                name: "feeRate",
                type: "u16"
              },
              {
                name: "protocolFeeRate",
                type: "u16"
              },
              {
                name: "liquidity",
                type: "u128"
              },
              {
                name: "sqrtPrice",
                type: "u128"
              },
              {
                name: "tickCurrentIndex",
                type: "i32"
              },
              {
                name: "protocolFeeOwedA",
                type: "u64"
              },
              {
                name: "protocolFeeOwedB",
                type: "u64"
              },
              {
                name: "tokenMintA",
                type: "publicKey"
              },
              {
                name: "tokenVaultA",
                type: "publicKey"
              },
              {
                name: "feeGrowthGlobalA",
                type: "u128"
              },
              {
                name: "tokenMintB",
                type: "publicKey"
              },
              {
                name: "tokenVaultB",
                type: "publicKey"
              },
              {
                name: "feeGrowthGlobalB",
                type: "u128"
              },
              {
                name: "rewardLastUpdatedTimestamp",
                type: "u64"
              },
              {
                name: "rewardInfos",
                type: {
                  array: [
                    {
                      defined: "WhirlpoolRewardInfo"
                    },
                    3
                  ]
                }
              }
            ]
          }
        }
      ],
      types: [
        {
          name: "LockType",
          type: {
            kind: "enum",
            variants: [
              {
                name: "Permanent"
              }
            ]
          }
        },
        {
          name: "LockTypeLabel",
          type: {
            kind: "enum",
            variants: [
              {
                name: "Permanent"
              }
            ]
          }
        },
        {
          name: "AdaptiveFeeConstants",
          type: {
            kind: "struct",
            fields: [
              {
                name: "filterPeriod",
                type: "u16"
              },
              {
                name: "decayPeriod",
                type: "u16"
              },
              {
                name: "reductionFactor",
                type: "u16"
              },
              {
                name: "adaptiveFeeControlFactor",
                type: "u32"
              },
              {
                name: "maxVolatilityAccumulator",
                type: "u32"
              },
              {
                name: "tickGroupSize",
                type: "u16"
              },
              {
                name: "majorSwapThresholdTicks",
                type: "u16"
              },
              {
                name: "reserved",
                type: {
                  array: [
                    "u8",
                    16
                  ]
                }
              }
            ]
          }
        },
        {
          name: "AdaptiveFeeVariables",
          type: {
            kind: "struct",
            fields: [
              {
                name: "lastReferenceUpdateTimestamp",
                type: "u64"
              },
              {
                name: "lastMajorSwapTimestamp",
                type: "u64"
              },
              {
                name: "volatilityReference",
                type: "u32"
              },
              {
                name: "tickGroupIndexReference",
                type: "i32"
              },
              {
                name: "volatilityAccumulator",
                type: "u32"
              },
              {
                name: "reserved",
                type: {
                  array: [
                    "u8",
                    16
                  ]
                }
              }
            ]
          }
        },
        {
          name: "OpenPositionBumps",
          type: {
            kind: "struct",
            fields: [
              {
                name: "positionBump",
                type: "u8"
              }
            ]
          }
        },
        {
          name: "OpenPositionWithMetadataBumps",
          type: {
            kind: "struct",
            fields: [
              {
                name: "positionBump",
                type: "u8"
              },
              {
                name: "metadataBump",
                type: "u8"
              }
            ]
          }
        },
        {
          name: "PositionRewardInfo",
          type: {
            kind: "struct",
            fields: [
              {
                name: "growthInsideCheckpoint",
                type: "u128"
              },
              {
                name: "amountOwed",
                type: "u64"
              }
            ]
          }
        },
        {
          name: "Tick",
          type: {
            kind: "struct",
            fields: [
              {
                name: "initialized",
                type: "bool"
              },
              {
                name: "liquidityNet",
                type: "i128"
              },
              {
                name: "liquidityGross",
                type: "u128"
              },
              {
                name: "feeGrowthOutsideA",
                type: "u128"
              },
              {
                name: "feeGrowthOutsideB",
                type: "u128"
              },
              {
                name: "rewardGrowthsOutside",
                type: {
                  array: [
                    "u128",
                    3
                  ]
                }
              }
            ]
          }
        },
        {
          name: "WhirlpoolBumps",
          type: {
            kind: "struct",
            fields: [
              {
                name: "whirlpoolBump",
                type: "u8"
              }
            ]
          }
        },
        {
          name: "WhirlpoolRewardInfo",
          docs: [
            "Stores the state relevant for tracking liquidity mining rewards at the `Whirlpool` level.",
            "These values are used in conjunction with `PositionRewardInfo`, `Tick.reward_growths_outside`,",
            "and `Whirlpool.reward_last_updated_timestamp` to determine how many rewards are earned by open",
            "positions."
          ],
          type: {
            kind: "struct",
            fields: [
              {
                name: "mint",
                docs: [
                  "Reward token mint."
                ],
                type: "publicKey"
              },
              {
                name: "vault",
                docs: [
                  "Reward vault token account."
                ],
                type: "publicKey"
              },
              {
                name: "authority",
                docs: [
                  "Authority account that has permission to initialize the reward and set emissions."
                ],
                type: "publicKey"
              },
              {
                name: "emissionsPerSecondX64",
                docs: [
                  "Q64.64 number that indicates how many tokens per second are earned per unit of liquidity."
                ],
                type: "u128"
              },
              {
                name: "growthGlobalX64",
                docs: [
                  "Q64.64 number that tracks the total tokens earned per unit of liquidity since the reward",
                  "emissions were turned on."
                ],
                type: "u128"
              }
            ]
          }
        },
        {
          name: "AccountsType",
          type: {
            kind: "enum",
            variants: [
              {
                name: "TransferHookA"
              },
              {
                name: "TransferHookB"
              },
              {
                name: "TransferHookReward"
              },
              {
                name: "TransferHookInput"
              },
              {
                name: "TransferHookIntermediate"
              },
              {
                name: "TransferHookOutput"
              },
              {
                name: "SupplementalTickArrays"
              },
              {
                name: "SupplementalTickArraysOne"
              },
              {
                name: "SupplementalTickArraysTwo"
              }
            ]
          }
        },
        {
          name: "RemainingAccountsInfo",
          type: {
            kind: "struct",
            fields: [
              {
                name: "slices",
                type: {
                  vec: {
                    defined: "RemainingAccountsSlice"
                  }
                }
              }
            ]
          }
        },
        {
          name: "RemainingAccountsSlice",
          type: {
            kind: "struct",
            fields: [
              {
                name: "accountsType",
                type: {
                  defined: "AccountsType"
                }
              },
              {
                name: "length",
                type: "u8"
              }
            ]
          }
        }
      ],
      events: [
        {
          name: "LiquidityDecreased",
          fields: [
            {
              name: "whirlpool",
              type: "publicKey",
              index: false
            },
            {
              name: "position",
              type: "publicKey",
              index: false
            },
            {
              name: "tickLowerIndex",
              type: "i32",
              index: false
            },
            {
              name: "tickUpperIndex",
              type: "i32",
              index: false
            },
            {
              name: "liquidity",
              type: "u128",
              index: false
            },
            {
              name: "tokenAAmount",
              type: "u64",
              index: false
            },
            {
              name: "tokenBAmount",
              type: "u64",
              index: false
            },
            {
              name: "tokenATransferFee",
              type: "u64",
              index: false
            },
            {
              name: "tokenBTransferFee",
              type: "u64",
              index: false
            }
          ]
        },
        {
          name: "LiquidityIncreased",
          fields: [
            {
              name: "whirlpool",
              type: "publicKey",
              index: false
            },
            {
              name: "position",
              type: "publicKey",
              index: false
            },
            {
              name: "tickLowerIndex",
              type: "i32",
              index: false
            },
            {
              name: "tickUpperIndex",
              type: "i32",
              index: false
            },
            {
              name: "liquidity",
              type: "u128",
              index: false
            },
            {
              name: "tokenAAmount",
              type: "u64",
              index: false
            },
            {
              name: "tokenBAmount",
              type: "u64",
              index: false
            },
            {
              name: "tokenATransferFee",
              type: "u64",
              index: false
            },
            {
              name: "tokenBTransferFee",
              type: "u64",
              index: false
            }
          ]
        },
        {
          name: "PoolInitialized",
          fields: [
            {
              name: "whirlpool",
              type: "publicKey",
              index: false
            },
            {
              name: "whirlpoolsConfig",
              type: "publicKey",
              index: false
            },
            {
              name: "tokenMintA",
              type: "publicKey",
              index: false
            },
            {
              name: "tokenMintB",
              type: "publicKey",
              index: false
            },
            {
              name: "tickSpacing",
              type: "u16",
              index: false
            },
            {
              name: "tokenProgramA",
              type: "publicKey",
              index: false
            },
            {
              name: "tokenProgramB",
              type: "publicKey",
              index: false
            },
            {
              name: "decimalsA",
              type: "u8",
              index: false
            },
            {
              name: "decimalsB",
              type: "u8",
              index: false
            },
            {
              name: "initialSqrtPrice",
              type: "u128",
              index: false
            }
          ]
        },
        {
          name: "Traded",
          fields: [
            {
              name: "whirlpool",
              type: "publicKey",
              index: false
            },
            {
              name: "aToB",
              type: "bool",
              index: false
            },
            {
              name: "preSqrtPrice",
              type: "u128",
              index: false
            },
            {
              name: "postSqrtPrice",
              type: "u128",
              index: false
            },
            {
              name: "inputAmount",
              type: "u64",
              index: false
            },
            {
              name: "outputAmount",
              type: "u64",
              index: false
            },
            {
              name: "inputTransferFee",
              type: "u64",
              index: false
            },
            {
              name: "outputTransferFee",
              type: "u64",
              index: false
            },
            {
              name: "lpFee",
              type: "u64",
              index: false
            },
            {
              name: "protocolFee",
              type: "u64",
              index: false
            }
          ]
        }
      ],
      errors: [
        {
          code: 6e3,
          name: "InvalidEnum",
          msg: "Enum value could not be converted"
        },
        {
          code: 6001,
          name: "InvalidStartTick",
          msg: "Invalid start tick index provided."
        },
        {
          code: 6002,
          name: "TickArrayExistInPool",
          msg: "Tick-array already exists in this whirlpool"
        },
        {
          code: 6003,
          name: "TickArrayIndexOutofBounds",
          msg: "Attempt to search for a tick-array failed"
        },
        {
          code: 6004,
          name: "InvalidTickSpacing",
          msg: "Tick-spacing is not supported"
        },
        {
          code: 6005,
          name: "ClosePositionNotEmpty",
          msg: "Position is not empty It cannot be closed"
        },
        {
          code: 6006,
          name: "DivideByZero",
          msg: "Unable to divide by zero"
        },
        {
          code: 6007,
          name: "NumberCastError",
          msg: "Unable to cast number into BigInt"
        },
        {
          code: 6008,
          name: "NumberDownCastError",
          msg: "Unable to down cast number"
        },
        {
          code: 6009,
          name: "TickNotFound",
          msg: "Tick not found within tick array"
        },
        {
          code: 6010,
          name: "InvalidTickIndex",
          msg: "Provided tick index is either out of bounds or uninitializable"
        },
        {
          code: 6011,
          name: "SqrtPriceOutOfBounds",
          msg: "Provided sqrt price out of bounds"
        },
        {
          code: 6012,
          name: "LiquidityZero",
          msg: "Liquidity amount must be greater than zero"
        },
        {
          code: 6013,
          name: "LiquidityTooHigh",
          msg: "Liquidity amount must be less than i64::MAX"
        },
        {
          code: 6014,
          name: "LiquidityOverflow",
          msg: "Liquidity overflow"
        },
        {
          code: 6015,
          name: "LiquidityUnderflow",
          msg: "Liquidity underflow"
        },
        {
          code: 6016,
          name: "LiquidityNetError",
          msg: "Tick liquidity net underflowed or overflowed"
        },
        {
          code: 6017,
          name: "TokenMaxExceeded",
          msg: "Exceeded token max"
        },
        {
          code: 6018,
          name: "TokenMinSubceeded",
          msg: "Did not meet token min"
        },
        {
          code: 6019,
          name: "MissingOrInvalidDelegate",
          msg: "Position token account has a missing or invalid delegate"
        },
        {
          code: 6020,
          name: "InvalidPositionTokenAmount",
          msg: "Position token amount must be 1"
        },
        {
          code: 6021,
          name: "InvalidTimestampConversion",
          msg: "Timestamp should be convertible from i64 to u64"
        },
        {
          code: 6022,
          name: "InvalidTimestamp",
          msg: "Timestamp should be greater than the last updated timestamp"
        },
        {
          code: 6023,
          name: "InvalidTickArraySequence",
          msg: "Invalid tick array sequence provided for instruction."
        },
        {
          code: 6024,
          name: "InvalidTokenMintOrder",
          msg: "Token Mint in wrong order"
        },
        {
          code: 6025,
          name: "RewardNotInitialized",
          msg: "Reward not initialized"
        },
        {
          code: 6026,
          name: "InvalidRewardIndex",
          msg: "Invalid reward index"
        },
        {
          code: 6027,
          name: "RewardVaultAmountInsufficient",
          msg: "Reward vault requires amount to support emissions for at least one day"
        },
        {
          code: 6028,
          name: "FeeRateMaxExceeded",
          msg: "Exceeded max fee rate"
        },
        {
          code: 6029,
          name: "ProtocolFeeRateMaxExceeded",
          msg: "Exceeded max protocol fee rate"
        },
        {
          code: 6030,
          name: "MultiplicationShiftRightOverflow",
          msg: "Multiplication with shift right overflow"
        },
        {
          code: 6031,
          name: "MulDivOverflow",
          msg: "Muldiv overflow"
        },
        {
          code: 6032,
          name: "MulDivInvalidInput",
          msg: "Invalid div_u256 input"
        },
        {
          code: 6033,
          name: "MultiplicationOverflow",
          msg: "Multiplication overflow"
        },
        {
          code: 6034,
          name: "InvalidSqrtPriceLimitDirection",
          msg: "Provided SqrtPriceLimit not in the same direction as the swap."
        },
        {
          code: 6035,
          name: "ZeroTradableAmount",
          msg: "There are no tradable amount to swap."
        },
        {
          code: 6036,
          name: "AmountOutBelowMinimum",
          msg: "Amount out below minimum threshold"
        },
        {
          code: 6037,
          name: "AmountInAboveMaximum",
          msg: "Amount in above maximum threshold"
        },
        {
          code: 6038,
          name: "TickArraySequenceInvalidIndex",
          msg: "Invalid index for tick array sequence"
        },
        {
          code: 6039,
          name: "AmountCalcOverflow",
          msg: "Amount calculated overflows"
        },
        {
          code: 6040,
          name: "AmountRemainingOverflow",
          msg: "Amount remaining overflows"
        },
        {
          code: 6041,
          name: "InvalidIntermediaryMint",
          msg: "Invalid intermediary mint"
        },
        {
          code: 6042,
          name: "DuplicateTwoHopPool",
          msg: "Duplicate two hop pool"
        },
        {
          code: 6043,
          name: "InvalidBundleIndex",
          msg: "Bundle index is out of bounds"
        },
        {
          code: 6044,
          name: "BundledPositionAlreadyOpened",
          msg: "Position has already been opened"
        },
        {
          code: 6045,
          name: "BundledPositionAlreadyClosed",
          msg: "Position has already been closed"
        },
        {
          code: 6046,
          name: "PositionBundleNotDeletable",
          msg: "Unable to delete PositionBundle with open positions"
        },
        {
          code: 6047,
          name: "UnsupportedTokenMint",
          msg: "Token mint has unsupported attributes"
        },
        {
          code: 6048,
          name: "RemainingAccountsInvalidSlice",
          msg: "Invalid remaining accounts"
        },
        {
          code: 6049,
          name: "RemainingAccountsInsufficient",
          msg: "Insufficient remaining accounts"
        },
        {
          code: 6050,
          name: "NoExtraAccountsForTransferHook",
          msg: "Unable to call transfer hook without extra accounts"
        },
        {
          code: 6051,
          name: "IntermediateTokenAmountMismatch",
          msg: "Output and input amount mismatch"
        },
        {
          code: 6052,
          name: "TransferFeeCalculationError",
          msg: "Transfer fee calculation failed"
        },
        {
          code: 6053,
          name: "RemainingAccountsDuplicatedAccountsType",
          msg: "Same accounts type is provided more than once"
        },
        {
          code: 6054,
          name: "FullRangeOnlyPool",
          msg: "This whirlpool only supports full-range positions"
        },
        {
          code: 6055,
          name: "TooManySupplementalTickArrays",
          msg: "Too many supplemental tick arrays provided"
        },
        {
          code: 6056,
          name: "DifferentWhirlpoolTickArrayAccount",
          msg: "TickArray account for different whirlpool provided"
        },
        {
          code: 6057,
          name: "PartialFillError",
          msg: "Trade resulted in partial fill"
        },
        {
          code: 6058,
          name: "PositionNotLockable",
          msg: "Position is not lockable"
        },
        {
          code: 6059,
          name: "OperationNotAllowedOnLockedPosition",
          msg: "Operation not allowed on locked position"
        },
        {
          code: 6060,
          name: "SameTickRangeNotAllowed",
          msg: "Cannot reset position range with same tick range"
        },
        {
          code: 6061,
          name: "InvalidAdaptiveFeeConstants",
          msg: "Invalid adaptive fee constants"
        },
        {
          code: 6062,
          name: "InvalidFeeTierIndex",
          msg: "Invalid fee tier index"
        },
        {
          code: 6063,
          name: "InvalidTradeEnableTimestamp",
          msg: "Invalid trade enable timestamp"
        },
        {
          code: 6064,
          name: "TradeIsNotEnabled",
          msg: "Trade is not enabled yet"
        }
      ]
    };
  }
});

// node_modules/@orca-so/common-sdk/dist/math/decimal-util.js
var require_decimal_util = __commonJS({
  "node_modules/@orca-so/common-sdk/dist/math/decimal-util.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DecimalUtil = void 0;
    var bn_js_1 = __importDefault(require_bn());
    var decimal_js_1 = __importDefault(require_decimal());
    var DecimalUtil = class {
      static adjustDecimals(input, shift = 0) {
        return input.div(decimal_js_1.default.pow(10, shift));
      }
      static fromBN(input, shift = 0) {
        return new decimal_js_1.default(input.toString()).div(new decimal_js_1.default(10).pow(shift));
      }
      static fromNumber(input, shift = 0) {
        return new decimal_js_1.default(input).div(new decimal_js_1.default(10).pow(shift));
      }
      static toBN(input, shift = 0) {
        if (input.isNeg()) {
          throw new Error("Negative decimal value ${input} cannot be converted to BN.");
        }
        const shiftedValue = input.mul(new decimal_js_1.default(10).pow(shift));
        const zeroDecimalValue = shiftedValue.trunc();
        return new bn_js_1.default(zeroDecimalValue.toString());
      }
    };
    exports2.DecimalUtil = DecimalUtil;
  }
});

// node_modules/@orca-so/common-sdk/dist/math/math-util.js
var require_math_util = __commonJS({
  "node_modules/@orca-so/common-sdk/dist/math/math-util.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MathUtil = exports2.U64_MAX = exports2.U128 = exports2.TWO = exports2.ONE = exports2.ZERO = void 0;
    var bn_js_1 = __importDefault(require_bn());
    var decimal_js_1 = __importDefault(require_decimal());
    exports2.ZERO = new bn_js_1.default(0);
    exports2.ONE = new bn_js_1.default(1);
    exports2.TWO = new bn_js_1.default(2);
    exports2.U128 = exports2.TWO.pow(new bn_js_1.default(128));
    exports2.U64_MAX = exports2.TWO.pow(new bn_js_1.default(64)).sub(exports2.ONE);
    var MathUtil = class {
      static toX64_BN(num) {
        return num.mul(new bn_js_1.default(2).pow(new bn_js_1.default(64)));
      }
      static toX64_Decimal(num) {
        return num.mul(decimal_js_1.default.pow(2, 64));
      }
      static toX64(num) {
        return new bn_js_1.default(num.mul(decimal_js_1.default.pow(2, 64)).floor().toFixed());
      }
      static fromX64(num) {
        return new decimal_js_1.default(num.toString()).mul(decimal_js_1.default.pow(2, -64));
      }
      static fromX64_Decimal(num) {
        return num.mul(decimal_js_1.default.pow(2, -64));
      }
      static fromX64_BN(num) {
        return num.div(new bn_js_1.default(2).pow(new bn_js_1.default(64)));
      }
      static shiftRightRoundUp(n) {
        let result = n.shrn(64);
        if (n.mod(exports2.U64_MAX).gt(exports2.ZERO)) {
          result = result.add(exports2.ONE);
        }
        return result;
      }
      static divRoundUp(n0, n1) {
        const hasRemainder = !n0.mod(n1).eq(exports2.ZERO);
        if (hasRemainder) {
          return n0.div(n1).add(new bn_js_1.default(1));
        } else {
          return n0.div(n1);
        }
      }
      static subUnderflowU128(n0, n1) {
        return n0.add(exports2.U128).sub(n1).mod(exports2.U128);
      }
    };
    exports2.MathUtil = MathUtil;
  }
});

// node_modules/@orca-so/common-sdk/dist/math/percentage.js
var require_percentage = __commonJS({
  "node_modules/@orca-so/common-sdk/dist/math/percentage.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Percentage = void 0;
    var bn_js_1 = __importDefault(require_bn());
    var decimal_js_1 = __importDefault(require_decimal());
    var Percentage2 = class _Percentage {
      numerator;
      denominator;
      constructor(numerator, denominator) {
        this.numerator = numerator;
        this.denominator = denominator;
      }
      static fromDecimal(number) {
        return _Percentage.fromFraction(number.mul(1e5).toNumber(), 1e7);
      }
      static fromFraction(numerator, denominator) {
        const num = typeof numerator === "number" ? new bn_js_1.default(numerator.toString()) : numerator;
        const denom = typeof denominator === "number" ? new bn_js_1.default(denominator.toString()) : denominator;
        return new _Percentage(num, denom);
      }
      toString = () => {
        return `${this.numerator.toString()}/${this.denominator.toString()}`;
      };
      toDecimal() {
        if (this.denominator.eq(new bn_js_1.default(0))) {
          return new decimal_js_1.default(0);
        }
        return new decimal_js_1.default(this.numerator.toString()).div(new decimal_js_1.default(this.denominator.toString()));
      }
      add(p2) {
        const denomGcd = this.denominator.gcd(p2.denominator);
        const denomLcm = this.denominator.div(denomGcd).mul(p2.denominator);
        const p1DenomAdjustment = denomLcm.div(this.denominator);
        const p2DenomAdjustment = denomLcm.div(p2.denominator);
        const p1NumeratorAdjusted = this.numerator.mul(p1DenomAdjustment);
        const p2NumeratorAdjusted = p2.numerator.mul(p2DenomAdjustment);
        const newNumerator = p1NumeratorAdjusted.add(p2NumeratorAdjusted);
        return new _Percentage(new bn_js_1.default(newNumerator.toString()), new bn_js_1.default(denomLcm.toString()));
      }
    };
    exports2.Percentage = Percentage2;
  }
});

// node_modules/@orca-so/common-sdk/dist/math/index.js
var require_math = __commonJS({
  "node_modules/@orca-so/common-sdk/dist/math/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_decimal_util(), exports2);
    __exportStar(require_math_util(), exports2);
    __exportStar(require_percentage(), exports2);
  }
});

// node_modules/@orca-so/common-sdk/dist/web3/address-util.js
var require_address_util = __commonJS({
  "node_modules/@orca-so/common-sdk/dist/web3/address-util.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AddressUtil = void 0;
    var web3_js_1 = require("@solana/web3.js");
    var AddressUtil = class _AddressUtil {
      static toPubKey(address) {
        return address instanceof web3_js_1.PublicKey ? address : new web3_js_1.PublicKey(address);
      }
      static toPubKeys(addresses) {
        return addresses.map((address) => _AddressUtil.toPubKey(address));
      }
      static toString(address) {
        if (typeof address === "string") {
          return address;
        }
        return _AddressUtil.toPubKey(address).toBase58();
      }
      static toStrings(addresses) {
        return addresses.map((address) => _AddressUtil.toString(address));
      }
      static findProgramAddress(seeds, programId) {
        const [publicKey2, bump] = web3_js_1.PublicKey.findProgramAddressSync(seeds, programId);
        return { publicKey: publicKey2, bump };
      }
    };
    exports2.AddressUtil = AddressUtil;
  }
});

// node_modules/@solana/spl-token/lib/cjs/constants.js
var require_constants = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/constants.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.programSupportsExtensions = exports2.NATIVE_MINT_2022 = exports2.NATIVE_MINT = exports2.ASSOCIATED_TOKEN_PROGRAM_ID = exports2.TOKEN_2022_PROGRAM_ID = exports2.TOKEN_PROGRAM_ID = void 0;
    var web3_js_1 = require("@solana/web3.js");
    exports2.TOKEN_PROGRAM_ID = new web3_js_1.PublicKey("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA");
    exports2.TOKEN_2022_PROGRAM_ID = new web3_js_1.PublicKey("TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb");
    exports2.ASSOCIATED_TOKEN_PROGRAM_ID = new web3_js_1.PublicKey("ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL");
    exports2.NATIVE_MINT = new web3_js_1.PublicKey("So11111111111111111111111111111111111111112");
    exports2.NATIVE_MINT_2022 = new web3_js_1.PublicKey("9pan9bMn5HatX4EJdBwg9VgCa7Uz5HL8N1m5D3NdXejP");
    function programSupportsExtensions(programId) {
      if (programId === exports2.TOKEN_PROGRAM_ID) {
        return false;
      } else {
        return true;
      }
    }
    exports2.programSupportsExtensions = programSupportsExtensions;
  }
});

// node_modules/@solana/buffer-layout-utils/lib/cjs/base.js
var require_base = __commonJS({
  "node_modules/@solana/buffer-layout-utils/lib/cjs/base.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.encodeDecode = void 0;
    var encodeDecode2 = (layout) => {
      const decode = layout.decode.bind(layout);
      const encode = layout.encode.bind(layout);
      return { decode, encode };
    };
    exports2.encodeDecode = encodeDecode2;
  }
});

// node_modules/@solana/buffer-layout-utils/lib/cjs/bigint.js
var require_bigint = __commonJS({
  "node_modules/@solana/buffer-layout-utils/lib/cjs/bigint.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.u256be = exports2.u256 = exports2.u192be = exports2.u192 = exports2.u128be = exports2.u128 = exports2.u64be = exports2.u64 = exports2.bigIntBE = exports2.bigInt = void 0;
    var buffer_layout_1 = require_Layout();
    var bigint_buffer_1 = require_node();
    var base_1 = require_base();
    var bigInt2 = (length) => (property) => {
      const layout = (0, buffer_layout_1.blob)(length, property);
      const { encode, decode } = (0, base_1.encodeDecode)(layout);
      const bigIntLayout = layout;
      bigIntLayout.decode = (buffer, offset) => {
        const src = decode(buffer, offset);
        return (0, bigint_buffer_1.toBigIntLE)(Buffer.from(src));
      };
      bigIntLayout.encode = (bigInt3, buffer, offset) => {
        const src = (0, bigint_buffer_1.toBufferLE)(bigInt3, length);
        return encode(src, buffer, offset);
      };
      return bigIntLayout;
    };
    exports2.bigInt = bigInt2;
    var bigIntBE2 = (length) => (property) => {
      const layout = (0, buffer_layout_1.blob)(length, property);
      const { encode, decode } = (0, base_1.encodeDecode)(layout);
      const bigIntLayout = layout;
      bigIntLayout.decode = (buffer, offset) => {
        const src = decode(buffer, offset);
        return (0, bigint_buffer_1.toBigIntBE)(Buffer.from(src));
      };
      bigIntLayout.encode = (bigInt3, buffer, offset) => {
        const src = (0, bigint_buffer_1.toBufferBE)(bigInt3, length);
        return encode(src, buffer, offset);
      };
      return bigIntLayout;
    };
    exports2.bigIntBE = bigIntBE2;
    exports2.u64 = (0, exports2.bigInt)(8);
    exports2.u64be = (0, exports2.bigIntBE)(8);
    exports2.u128 = (0, exports2.bigInt)(16);
    exports2.u128be = (0, exports2.bigIntBE)(16);
    exports2.u192 = (0, exports2.bigInt)(24);
    exports2.u192be = (0, exports2.bigIntBE)(24);
    exports2.u256 = (0, exports2.bigInt)(32);
    exports2.u256be = (0, exports2.bigIntBE)(32);
  }
});

// node_modules/bignumber.js/bignumber.js
var require_bignumber = __commonJS({
  "node_modules/bignumber.js/bignumber.js"(exports2, module2) {
    (function(globalObject) {
      "use strict";
      var BigNumber2, isNumeric2 = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i, mathceil2 = Math.ceil, mathfloor3 = Math.floor, bignumberError2 = "[BigNumber Error] ", tooManyDigits2 = bignumberError2 + "Number primitive has more than 15 significant digits: ", BASE3 = 1e14, LOG_BASE3 = 14, MAX_SAFE_INTEGER3 = 9007199254740991, POWS_TEN2 = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13], SQRT_BASE2 = 1e7, MAX3 = 1e9;
      function clone3(configObject) {
        var div2, convertBase2, parseNumeric, P2 = BigNumber3.prototype = { constructor: BigNumber3, toString: null, valueOf: null }, ONE2 = new BigNumber3(1), DECIMAL_PLACES = 20, ROUNDING_MODE = 4, TO_EXP_NEG = -7, TO_EXP_POS = 21, MIN_EXP = -1e7, MAX_EXP = 1e7, CRYPTO = false, MODULO_MODE = 1, POW_PRECISION = 0, FORMAT = {
          prefix: "",
          groupSize: 3,
          secondaryGroupSize: 0,
          groupSeparator: ",",
          decimalSeparator: ".",
          fractionGroupSize: 0,
          fractionGroupSeparator: "\xA0",
          // non-breaking space
          suffix: ""
        }, ALPHABET = "0123456789abcdefghijklmnopqrstuvwxyz", alphabetHasNormalDecimalDigits = true;
        function BigNumber3(v, b) {
          var alphabet, c, caseChanged, e, i, isNum, len, str, x = this;
          if (!(x instanceof BigNumber3))
            return new BigNumber3(v, b);
          if (b == null) {
            if (v && v._isBigNumber === true) {
              x.s = v.s;
              if (!v.c || v.e > MAX_EXP) {
                x.c = x.e = null;
              } else if (v.e < MIN_EXP) {
                x.c = [x.e = 0];
              } else {
                x.e = v.e;
                x.c = v.c.slice();
              }
              return;
            }
            if ((isNum = typeof v == "number") && v * 0 == 0) {
              x.s = 1 / v < 0 ? (v = -v, -1) : 1;
              if (v === ~~v) {
                for (e = 0, i = v; i >= 10; i /= 10, e++)
                  ;
                if (e > MAX_EXP) {
                  x.c = x.e = null;
                } else {
                  x.e = e;
                  x.c = [v];
                }
                return;
              }
              str = String(v);
            } else {
              if (!isNumeric2.test(str = String(v)))
                return parseNumeric(x, str, isNum);
              x.s = str.charCodeAt(0) == 45 ? (str = str.slice(1), -1) : 1;
            }
            if ((e = str.indexOf(".")) > -1)
              str = str.replace(".", "");
            if ((i = str.search(/e/i)) > 0) {
              if (e < 0)
                e = i;
              e += +str.slice(i + 1);
              str = str.substring(0, i);
            } else if (e < 0) {
              e = str.length;
            }
          } else {
            intCheck2(b, 2, ALPHABET.length, "Base");
            if (b == 10 && alphabetHasNormalDecimalDigits) {
              x = new BigNumber3(v);
              return round2(x, DECIMAL_PLACES + x.e + 1, ROUNDING_MODE);
            }
            str = String(v);
            if (isNum = typeof v == "number") {
              if (v * 0 != 0)
                return parseNumeric(x, str, isNum, b);
              x.s = 1 / v < 0 ? (str = str.slice(1), -1) : 1;
              if (BigNumber3.DEBUG && str.replace(/^0\.0*|\./, "").length > 15) {
                throw Error(tooManyDigits2 + v);
              }
            } else {
              x.s = str.charCodeAt(0) === 45 ? (str = str.slice(1), -1) : 1;
            }
            alphabet = ALPHABET.slice(0, b);
            e = i = 0;
            for (len = str.length; i < len; i++) {
              if (alphabet.indexOf(c = str.charAt(i)) < 0) {
                if (c == ".") {
                  if (i > e) {
                    e = len;
                    continue;
                  }
                } else if (!caseChanged) {
                  if (str == str.toUpperCase() && (str = str.toLowerCase()) || str == str.toLowerCase() && (str = str.toUpperCase())) {
                    caseChanged = true;
                    i = -1;
                    e = 0;
                    continue;
                  }
                }
                return parseNumeric(x, String(v), isNum, b);
              }
            }
            isNum = false;
            str = convertBase2(str, b, 10, x.s);
            if ((e = str.indexOf(".")) > -1)
              str = str.replace(".", "");
            else
              e = str.length;
          }
          for (i = 0; str.charCodeAt(i) === 48; i++)
            ;
          for (len = str.length; str.charCodeAt(--len) === 48; )
            ;
          if (str = str.slice(i, ++len)) {
            len -= i;
            if (isNum && BigNumber3.DEBUG && len > 15 && (v > MAX_SAFE_INTEGER3 || v !== mathfloor3(v))) {
              throw Error(tooManyDigits2 + x.s * v);
            }
            if ((e = e - i - 1) > MAX_EXP) {
              x.c = x.e = null;
            } else if (e < MIN_EXP) {
              x.c = [x.e = 0];
            } else {
              x.e = e;
              x.c = [];
              i = (e + 1) % LOG_BASE3;
              if (e < 0)
                i += LOG_BASE3;
              if (i < len) {
                if (i)
                  x.c.push(+str.slice(0, i));
                for (len -= LOG_BASE3; i < len; ) {
                  x.c.push(+str.slice(i, i += LOG_BASE3));
                }
                i = LOG_BASE3 - (str = str.slice(i)).length;
              } else {
                i -= len;
              }
              for (; i--; str += "0")
                ;
              x.c.push(+str);
            }
          } else {
            x.c = [x.e = 0];
          }
        }
        BigNumber3.clone = clone3;
        BigNumber3.ROUND_UP = 0;
        BigNumber3.ROUND_DOWN = 1;
        BigNumber3.ROUND_CEIL = 2;
        BigNumber3.ROUND_FLOOR = 3;
        BigNumber3.ROUND_HALF_UP = 4;
        BigNumber3.ROUND_HALF_DOWN = 5;
        BigNumber3.ROUND_HALF_EVEN = 6;
        BigNumber3.ROUND_HALF_CEIL = 7;
        BigNumber3.ROUND_HALF_FLOOR = 8;
        BigNumber3.EUCLID = 9;
        BigNumber3.config = BigNumber3.set = function(obj) {
          var p, v;
          if (obj != null) {
            if (typeof obj == "object") {
              if (obj.hasOwnProperty(p = "DECIMAL_PLACES")) {
                v = obj[p];
                intCheck2(v, 0, MAX3, p);
                DECIMAL_PLACES = v;
              }
              if (obj.hasOwnProperty(p = "ROUNDING_MODE")) {
                v = obj[p];
                intCheck2(v, 0, 8, p);
                ROUNDING_MODE = v;
              }
              if (obj.hasOwnProperty(p = "EXPONENTIAL_AT")) {
                v = obj[p];
                if (v && v.pop) {
                  intCheck2(v[0], -MAX3, 0, p);
                  intCheck2(v[1], 0, MAX3, p);
                  TO_EXP_NEG = v[0];
                  TO_EXP_POS = v[1];
                } else {
                  intCheck2(v, -MAX3, MAX3, p);
                  TO_EXP_NEG = -(TO_EXP_POS = v < 0 ? -v : v);
                }
              }
              if (obj.hasOwnProperty(p = "RANGE")) {
                v = obj[p];
                if (v && v.pop) {
                  intCheck2(v[0], -MAX3, -1, p);
                  intCheck2(v[1], 1, MAX3, p);
                  MIN_EXP = v[0];
                  MAX_EXP = v[1];
                } else {
                  intCheck2(v, -MAX3, MAX3, p);
                  if (v) {
                    MIN_EXP = -(MAX_EXP = v < 0 ? -v : v);
                  } else {
                    throw Error(bignumberError2 + p + " cannot be zero: " + v);
                  }
                }
              }
              if (obj.hasOwnProperty(p = "CRYPTO")) {
                v = obj[p];
                if (v === !!v) {
                  if (v) {
                    if (typeof crypto != "undefined" && crypto && (crypto.getRandomValues || crypto.randomBytes)) {
                      CRYPTO = v;
                    } else {
                      CRYPTO = !v;
                      throw Error(bignumberError2 + "crypto unavailable");
                    }
                  } else {
                    CRYPTO = v;
                  }
                } else {
                  throw Error(bignumberError2 + p + " not true or false: " + v);
                }
              }
              if (obj.hasOwnProperty(p = "MODULO_MODE")) {
                v = obj[p];
                intCheck2(v, 0, 9, p);
                MODULO_MODE = v;
              }
              if (obj.hasOwnProperty(p = "POW_PRECISION")) {
                v = obj[p];
                intCheck2(v, 0, MAX3, p);
                POW_PRECISION = v;
              }
              if (obj.hasOwnProperty(p = "FORMAT")) {
                v = obj[p];
                if (typeof v == "object")
                  FORMAT = v;
                else
                  throw Error(bignumberError2 + p + " not an object: " + v);
              }
              if (obj.hasOwnProperty(p = "ALPHABET")) {
                v = obj[p];
                if (typeof v == "string" && !/^.?$|[+\-.\s]|(.).*\1/.test(v)) {
                  alphabetHasNormalDecimalDigits = v.slice(0, 10) == "0123456789";
                  ALPHABET = v;
                } else {
                  throw Error(bignumberError2 + p + " invalid: " + v);
                }
              }
            } else {
              throw Error(bignumberError2 + "Object expected: " + obj);
            }
          }
          return {
            DECIMAL_PLACES,
            ROUNDING_MODE,
            EXPONENTIAL_AT: [TO_EXP_NEG, TO_EXP_POS],
            RANGE: [MIN_EXP, MAX_EXP],
            CRYPTO,
            MODULO_MODE,
            POW_PRECISION,
            FORMAT,
            ALPHABET
          };
        };
        BigNumber3.isBigNumber = function(v) {
          if (!v || v._isBigNumber !== true)
            return false;
          if (!BigNumber3.DEBUG)
            return true;
          var i, n, c = v.c, e = v.e, s = v.s;
          out:
            if ({}.toString.call(c) == "[object Array]") {
              if ((s === 1 || s === -1) && e >= -MAX3 && e <= MAX3 && e === mathfloor3(e)) {
                if (c[0] === 0) {
                  if (e === 0 && c.length === 1)
                    return true;
                  break out;
                }
                i = (e + 1) % LOG_BASE3;
                if (i < 1)
                  i += LOG_BASE3;
                if (String(c[0]).length == i) {
                  for (i = 0; i < c.length; i++) {
                    n = c[i];
                    if (n < 0 || n >= BASE3 || n !== mathfloor3(n))
                      break out;
                  }
                  if (n !== 0)
                    return true;
                }
              }
            } else if (c === null && e === null && (s === null || s === 1 || s === -1)) {
              return true;
            }
          throw Error(bignumberError2 + "Invalid BigNumber: " + v);
        };
        BigNumber3.maximum = BigNumber3.max = function() {
          return maxOrMin2(arguments, -1);
        };
        BigNumber3.minimum = BigNumber3.min = function() {
          return maxOrMin2(arguments, 1);
        };
        BigNumber3.random = function() {
          var pow2_53 = 9007199254740992;
          var random53bitInt = Math.random() * pow2_53 & 2097151 ? function() {
            return mathfloor3(Math.random() * pow2_53);
          } : function() {
            return (Math.random() * 1073741824 | 0) * 8388608 + (Math.random() * 8388608 | 0);
          };
          return function(dp) {
            var a, b, e, k, v, i = 0, c = [], rand = new BigNumber3(ONE2);
            if (dp == null)
              dp = DECIMAL_PLACES;
            else
              intCheck2(dp, 0, MAX3);
            k = mathceil2(dp / LOG_BASE3);
            if (CRYPTO) {
              if (crypto.getRandomValues) {
                a = crypto.getRandomValues(new Uint32Array(k *= 2));
                for (; i < k; ) {
                  v = a[i] * 131072 + (a[i + 1] >>> 11);
                  if (v >= 9e15) {
                    b = crypto.getRandomValues(new Uint32Array(2));
                    a[i] = b[0];
                    a[i + 1] = b[1];
                  } else {
                    c.push(v % 1e14);
                    i += 2;
                  }
                }
                i = k / 2;
              } else if (crypto.randomBytes) {
                a = crypto.randomBytes(k *= 7);
                for (; i < k; ) {
                  v = (a[i] & 31) * 281474976710656 + a[i + 1] * 1099511627776 + a[i + 2] * 4294967296 + a[i + 3] * 16777216 + (a[i + 4] << 16) + (a[i + 5] << 8) + a[i + 6];
                  if (v >= 9e15) {
                    crypto.randomBytes(7).copy(a, i);
                  } else {
                    c.push(v % 1e14);
                    i += 7;
                  }
                }
                i = k / 7;
              } else {
                CRYPTO = false;
                throw Error(bignumberError2 + "crypto unavailable");
              }
            }
            if (!CRYPTO) {
              for (; i < k; ) {
                v = random53bitInt();
                if (v < 9e15)
                  c[i++] = v % 1e14;
              }
            }
            k = c[--i];
            dp %= LOG_BASE3;
            if (k && dp) {
              v = POWS_TEN2[LOG_BASE3 - dp];
              c[i] = mathfloor3(k / v) * v;
            }
            for (; c[i] === 0; c.pop(), i--)
              ;
            if (i < 0) {
              c = [e = 0];
            } else {
              for (e = -1; c[0] === 0; c.splice(0, 1), e -= LOG_BASE3)
                ;
              for (i = 1, v = c[0]; v >= 10; v /= 10, i++)
                ;
              if (i < LOG_BASE3)
                e -= LOG_BASE3 - i;
            }
            rand.e = e;
            rand.c = c;
            return rand;
          };
        }();
        BigNumber3.sum = function() {
          var i = 1, args = arguments, sum2 = new BigNumber3(args[0]);
          for (; i < args.length; )
            sum2 = sum2.plus(args[i++]);
          return sum2;
        };
        convertBase2 = /* @__PURE__ */ function() {
          var decimal = "0123456789";
          function toBaseOut(str, baseIn, baseOut, alphabet) {
            var j, arr = [0], arrL, i = 0, len = str.length;
            for (; i < len; ) {
              for (arrL = arr.length; arrL--; arr[arrL] *= baseIn)
                ;
              arr[0] += alphabet.indexOf(str.charAt(i++));
              for (j = 0; j < arr.length; j++) {
                if (arr[j] > baseOut - 1) {
                  if (arr[j + 1] == null)
                    arr[j + 1] = 0;
                  arr[j + 1] += arr[j] / baseOut | 0;
                  arr[j] %= baseOut;
                }
              }
            }
            return arr.reverse();
          }
          return function(str, baseIn, baseOut, sign2, callerIsToString) {
            var alphabet, d, e, k, r, x, xc, y, i = str.indexOf("."), dp = DECIMAL_PLACES, rm = ROUNDING_MODE;
            if (i >= 0) {
              k = POW_PRECISION;
              POW_PRECISION = 0;
              str = str.replace(".", "");
              y = new BigNumber3(baseIn);
              x = y.pow(str.length - i);
              POW_PRECISION = k;
              y.c = toBaseOut(
                toFixedPoint2(coeffToString2(x.c), x.e, "0"),
                10,
                baseOut,
                decimal
              );
              y.e = y.c.length;
            }
            xc = toBaseOut(str, baseIn, baseOut, callerIsToString ? (alphabet = ALPHABET, decimal) : (alphabet = decimal, ALPHABET));
            e = k = xc.length;
            for (; xc[--k] == 0; xc.pop())
              ;
            if (!xc[0])
              return alphabet.charAt(0);
            if (i < 0) {
              --e;
            } else {
              x.c = xc;
              x.e = e;
              x.s = sign2;
              x = div2(x, y, dp, rm, baseOut);
              xc = x.c;
              r = x.r;
              e = x.e;
            }
            d = e + dp + 1;
            i = xc[d];
            k = baseOut / 2;
            r = r || d < 0 || xc[d + 1] != null;
            r = rm < 4 ? (i != null || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : i > k || i == k && (rm == 4 || r || rm == 6 && xc[d - 1] & 1 || rm == (x.s < 0 ? 8 : 7));
            if (d < 1 || !xc[0]) {
              str = r ? toFixedPoint2(alphabet.charAt(1), -dp, alphabet.charAt(0)) : alphabet.charAt(0);
            } else {
              xc.length = d;
              if (r) {
                for (--baseOut; ++xc[--d] > baseOut; ) {
                  xc[d] = 0;
                  if (!d) {
                    ++e;
                    xc = [1].concat(xc);
                  }
                }
              }
              for (k = xc.length; !xc[--k]; )
                ;
              for (i = 0, str = ""; i <= k; str += alphabet.charAt(xc[i++]))
                ;
              str = toFixedPoint2(str, e, alphabet.charAt(0));
            }
            return str;
          };
        }();
        div2 = /* @__PURE__ */ function() {
          function multiply(x, k, base) {
            var m, temp, xlo, xhi, carry = 0, i = x.length, klo = k % SQRT_BASE2, khi = k / SQRT_BASE2 | 0;
            for (x = x.slice(); i--; ) {
              xlo = x[i] % SQRT_BASE2;
              xhi = x[i] / SQRT_BASE2 | 0;
              m = khi * xlo + xhi * klo;
              temp = klo * xlo + m % SQRT_BASE2 * SQRT_BASE2 + carry;
              carry = (temp / base | 0) + (m / SQRT_BASE2 | 0) + khi * xhi;
              x[i] = temp % base;
            }
            if (carry)
              x = [carry].concat(x);
            return x;
          }
          function compare3(a, b, aL, bL) {
            var i, cmp;
            if (aL != bL) {
              cmp = aL > bL ? 1 : -1;
            } else {
              for (i = cmp = 0; i < aL; i++) {
                if (a[i] != b[i]) {
                  cmp = a[i] > b[i] ? 1 : -1;
                  break;
                }
              }
            }
            return cmp;
          }
          function subtract(a, b, aL, base) {
            var i = 0;
            for (; aL--; ) {
              a[aL] -= i;
              i = a[aL] < b[aL] ? 1 : 0;
              a[aL] = i * base + a[aL] - b[aL];
            }
            for (; !a[0] && a.length > 1; a.splice(0, 1))
              ;
          }
          return function(x, y, dp, rm, base) {
            var cmp, e, i, more, n, prod, prodL, q, qc, rem, remL, rem0, xi, xL, yc0, yL, yz, s = x.s == y.s ? 1 : -1, xc = x.c, yc = y.c;
            if (!xc || !xc[0] || !yc || !yc[0]) {
              return new BigNumber3(
                // Return NaN if either NaN, or both Infinity or 0.
                !x.s || !y.s || (xc ? yc && xc[0] == yc[0] : !yc) ? NaN : (
                  // Return 0 if x is 0 or y is Infinity, or return Infinity as y is 0.
                  xc && xc[0] == 0 || !yc ? s * 0 : s / 0
                )
              );
            }
            q = new BigNumber3(s);
            qc = q.c = [];
            e = x.e - y.e;
            s = dp + e + 1;
            if (!base) {
              base = BASE3;
              e = bitFloor2(x.e / LOG_BASE3) - bitFloor2(y.e / LOG_BASE3);
              s = s / LOG_BASE3 | 0;
            }
            for (i = 0; yc[i] == (xc[i] || 0); i++)
              ;
            if (yc[i] > (xc[i] || 0))
              e--;
            if (s < 0) {
              qc.push(1);
              more = true;
            } else {
              xL = xc.length;
              yL = yc.length;
              i = 0;
              s += 2;
              n = mathfloor3(base / (yc[0] + 1));
              if (n > 1) {
                yc = multiply(yc, n, base);
                xc = multiply(xc, n, base);
                yL = yc.length;
                xL = xc.length;
              }
              xi = yL;
              rem = xc.slice(0, yL);
              remL = rem.length;
              for (; remL < yL; rem[remL++] = 0)
                ;
              yz = yc.slice();
              yz = [0].concat(yz);
              yc0 = yc[0];
              if (yc[1] >= base / 2)
                yc0++;
              do {
                n = 0;
                cmp = compare3(yc, rem, yL, remL);
                if (cmp < 0) {
                  rem0 = rem[0];
                  if (yL != remL)
                    rem0 = rem0 * base + (rem[1] || 0);
                  n = mathfloor3(rem0 / yc0);
                  if (n > 1) {
                    if (n >= base)
                      n = base - 1;
                    prod = multiply(yc, n, base);
                    prodL = prod.length;
                    remL = rem.length;
                    while (compare3(prod, rem, prodL, remL) == 1) {
                      n--;
                      subtract(prod, yL < prodL ? yz : yc, prodL, base);
                      prodL = prod.length;
                      cmp = 1;
                    }
                  } else {
                    if (n == 0) {
                      cmp = n = 1;
                    }
                    prod = yc.slice();
                    prodL = prod.length;
                  }
                  if (prodL < remL)
                    prod = [0].concat(prod);
                  subtract(rem, prod, remL, base);
                  remL = rem.length;
                  if (cmp == -1) {
                    while (compare3(yc, rem, yL, remL) < 1) {
                      n++;
                      subtract(rem, yL < remL ? yz : yc, remL, base);
                      remL = rem.length;
                    }
                  }
                } else if (cmp === 0) {
                  n++;
                  rem = [0];
                }
                qc[i++] = n;
                if (rem[0]) {
                  rem[remL++] = xc[xi] || 0;
                } else {
                  rem = [xc[xi]];
                  remL = 1;
                }
              } while ((xi++ < xL || rem[0] != null) && s--);
              more = rem[0] != null;
              if (!qc[0])
                qc.splice(0, 1);
            }
            if (base == BASE3) {
              for (i = 1, s = qc[0]; s >= 10; s /= 10, i++)
                ;
              round2(q, dp + (q.e = i + e * LOG_BASE3 - 1) + 1, rm, more);
            } else {
              q.e = e;
              q.r = +more;
            }
            return q;
          };
        }();
        function format(n, i, rm, id) {
          var c0, e, ne, len, str;
          if (rm == null)
            rm = ROUNDING_MODE;
          else
            intCheck2(rm, 0, 8);
          if (!n.c)
            return n.toString();
          c0 = n.c[0];
          ne = n.e;
          if (i == null) {
            str = coeffToString2(n.c);
            str = id == 1 || id == 2 && (ne <= TO_EXP_NEG || ne >= TO_EXP_POS) ? toExponential2(str, ne) : toFixedPoint2(str, ne, "0");
          } else {
            n = round2(new BigNumber3(n), i, rm);
            e = n.e;
            str = coeffToString2(n.c);
            len = str.length;
            if (id == 1 || id == 2 && (i <= e || e <= TO_EXP_NEG)) {
              for (; len < i; str += "0", len++)
                ;
              str = toExponential2(str, e);
            } else {
              i -= ne + (id === 2 && e > ne);
              str = toFixedPoint2(str, e, "0");
              if (e + 1 > len) {
                if (--i > 0)
                  for (str += "."; i--; str += "0")
                    ;
              } else {
                i += e - len;
                if (i > 0) {
                  if (e + 1 == len)
                    str += ".";
                  for (; i--; str += "0")
                    ;
                }
              }
            }
          }
          return n.s < 0 && c0 ? "-" + str : str;
        }
        function maxOrMin2(args, n) {
          var k, y, i = 1, x = new BigNumber3(args[0]);
          for (; i < args.length; i++) {
            y = new BigNumber3(args[i]);
            if (!y.s || (k = compare2(x, y)) === n || k === 0 && x.s === n) {
              x = y;
            }
          }
          return x;
        }
        function normalise(n, c, e) {
          var i = 1, j = c.length;
          for (; !c[--j]; c.pop())
            ;
          for (j = c[0]; j >= 10; j /= 10, i++)
            ;
          if ((e = i + e * LOG_BASE3 - 1) > MAX_EXP) {
            n.c = n.e = null;
          } else if (e < MIN_EXP) {
            n.c = [n.e = 0];
          } else {
            n.e = e;
            n.c = c;
          }
          return n;
        }
        parseNumeric = /* @__PURE__ */ function() {
          var basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i, dotAfter = /^([^.]+)\.$/, dotBefore = /^\.([^.]+)$/, isInfinityOrNaN = /^-?(Infinity|NaN)$/, whitespaceOrPlus = /^\s*\+(?=[\w.])|^\s+|\s+$/g;
          return function(x, str, isNum, b) {
            var base, s = isNum ? str : str.replace(whitespaceOrPlus, "");
            if (isInfinityOrNaN.test(s)) {
              x.s = isNaN(s) ? null : s < 0 ? -1 : 1;
            } else {
              if (!isNum) {
                s = s.replace(basePrefix, function(m, p1, p2) {
                  base = (p2 = p2.toLowerCase()) == "x" ? 16 : p2 == "b" ? 2 : 8;
                  return !b || b == base ? p1 : m;
                });
                if (b) {
                  base = b;
                  s = s.replace(dotAfter, "$1").replace(dotBefore, "0.$1");
                }
                if (str != s)
                  return new BigNumber3(s, base);
              }
              if (BigNumber3.DEBUG) {
                throw Error(bignumberError2 + "Not a" + (b ? " base " + b : "") + " number: " + str);
              }
              x.s = null;
            }
            x.c = x.e = null;
          };
        }();
        function round2(x, sd, rm, r) {
          var d, i, j, k, n, ni, rd, xc = x.c, pows10 = POWS_TEN2;
          if (xc) {
            out: {
              for (d = 1, k = xc[0]; k >= 10; k /= 10, d++)
                ;
              i = sd - d;
              if (i < 0) {
                i += LOG_BASE3;
                j = sd;
                n = xc[ni = 0];
                rd = mathfloor3(n / pows10[d - j - 1] % 10);
              } else {
                ni = mathceil2((i + 1) / LOG_BASE3);
                if (ni >= xc.length) {
                  if (r) {
                    for (; xc.length <= ni; xc.push(0))
                      ;
                    n = rd = 0;
                    d = 1;
                    i %= LOG_BASE3;
                    j = i - LOG_BASE3 + 1;
                  } else {
                    break out;
                  }
                } else {
                  n = k = xc[ni];
                  for (d = 1; k >= 10; k /= 10, d++)
                    ;
                  i %= LOG_BASE3;
                  j = i - LOG_BASE3 + d;
                  rd = j < 0 ? 0 : mathfloor3(n / pows10[d - j - 1] % 10);
                }
              }
              r = r || sd < 0 || // Are there any non-zero digits after the rounding digit?
              // The expression  n % pows10[d - j - 1]  returns all digits of n to the right
              // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.
              xc[ni + 1] != null || (j < 0 ? n : n % pows10[d - j - 1]);
              r = rm < 4 ? (rd || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : rd > 5 || rd == 5 && (rm == 4 || r || rm == 6 && // Check whether the digit to the left of the rounding digit is odd.
              (i > 0 ? j > 0 ? n / pows10[d - j] : 0 : xc[ni - 1]) % 10 & 1 || rm == (x.s < 0 ? 8 : 7));
              if (sd < 1 || !xc[0]) {
                xc.length = 0;
                if (r) {
                  sd -= x.e + 1;
                  xc[0] = pows10[(LOG_BASE3 - sd % LOG_BASE3) % LOG_BASE3];
                  x.e = -sd || 0;
                } else {
                  xc[0] = x.e = 0;
                }
                return x;
              }
              if (i == 0) {
                xc.length = ni;
                k = 1;
                ni--;
              } else {
                xc.length = ni + 1;
                k = pows10[LOG_BASE3 - i];
                xc[ni] = j > 0 ? mathfloor3(n / pows10[d - j] % pows10[j]) * k : 0;
              }
              if (r) {
                for (; ; ) {
                  if (ni == 0) {
                    for (i = 1, j = xc[0]; j >= 10; j /= 10, i++)
                      ;
                    j = xc[0] += k;
                    for (k = 1; j >= 10; j /= 10, k++)
                      ;
                    if (i != k) {
                      x.e++;
                      if (xc[0] == BASE3)
                        xc[0] = 1;
                    }
                    break;
                  } else {
                    xc[ni] += k;
                    if (xc[ni] != BASE3)
                      break;
                    xc[ni--] = 0;
                    k = 1;
                  }
                }
              }
              for (i = xc.length; xc[--i] === 0; xc.pop())
                ;
            }
            if (x.e > MAX_EXP) {
              x.c = x.e = null;
            } else if (x.e < MIN_EXP) {
              x.c = [x.e = 0];
            }
          }
          return x;
        }
        function valueOf(n) {
          var str, e = n.e;
          if (e === null)
            return n.toString();
          str = coeffToString2(n.c);
          str = e <= TO_EXP_NEG || e >= TO_EXP_POS ? toExponential2(str, e) : toFixedPoint2(str, e, "0");
          return n.s < 0 ? "-" + str : str;
        }
        P2.absoluteValue = P2.abs = function() {
          var x = new BigNumber3(this);
          if (x.s < 0)
            x.s = 1;
          return x;
        };
        P2.comparedTo = function(y, b) {
          return compare2(this, new BigNumber3(y, b));
        };
        P2.decimalPlaces = P2.dp = function(dp, rm) {
          var c, n, v, x = this;
          if (dp != null) {
            intCheck2(dp, 0, MAX3);
            if (rm == null)
              rm = ROUNDING_MODE;
            else
              intCheck2(rm, 0, 8);
            return round2(new BigNumber3(x), dp + x.e + 1, rm);
          }
          if (!(c = x.c))
            return null;
          n = ((v = c.length - 1) - bitFloor2(this.e / LOG_BASE3)) * LOG_BASE3;
          if (v = c[v])
            for (; v % 10 == 0; v /= 10, n--)
              ;
          if (n < 0)
            n = 0;
          return n;
        };
        P2.dividedBy = P2.div = function(y, b) {
          return div2(this, new BigNumber3(y, b), DECIMAL_PLACES, ROUNDING_MODE);
        };
        P2.dividedToIntegerBy = P2.idiv = function(y, b) {
          return div2(this, new BigNumber3(y, b), 0, 1);
        };
        P2.exponentiatedBy = P2.pow = function(n, m) {
          var half, isModExp, i, k, more, nIsBig, nIsNeg, nIsOdd, y, x = this;
          n = new BigNumber3(n);
          if (n.c && !n.isInteger()) {
            throw Error(bignumberError2 + "Exponent not an integer: " + valueOf(n));
          }
          if (m != null)
            m = new BigNumber3(m);
          nIsBig = n.e > 14;
          if (!x.c || !x.c[0] || x.c[0] == 1 && !x.e && x.c.length == 1 || !n.c || !n.c[0]) {
            y = new BigNumber3(Math.pow(+valueOf(x), nIsBig ? n.s * (2 - isOdd3(n)) : +valueOf(n)));
            return m ? y.mod(m) : y;
          }
          nIsNeg = n.s < 0;
          if (m) {
            if (m.c ? !m.c[0] : !m.s)
              return new BigNumber3(NaN);
            isModExp = !nIsNeg && x.isInteger() && m.isInteger();
            if (isModExp)
              x = x.mod(m);
          } else if (n.e > 9 && (x.e > 0 || x.e < -1 || (x.e == 0 ? x.c[0] > 1 || nIsBig && x.c[1] >= 24e7 : x.c[0] < 8e13 || nIsBig && x.c[0] <= 9999975e7))) {
            k = x.s < 0 && isOdd3(n) ? -0 : 0;
            if (x.e > -1)
              k = 1 / k;
            return new BigNumber3(nIsNeg ? 1 / k : k);
          } else if (POW_PRECISION) {
            k = mathceil2(POW_PRECISION / LOG_BASE3 + 2);
          }
          if (nIsBig) {
            half = new BigNumber3(0.5);
            if (nIsNeg)
              n.s = 1;
            nIsOdd = isOdd3(n);
          } else {
            i = Math.abs(+valueOf(n));
            nIsOdd = i % 2;
          }
          y = new BigNumber3(ONE2);
          for (; ; ) {
            if (nIsOdd) {
              y = y.times(x);
              if (!y.c)
                break;
              if (k) {
                if (y.c.length > k)
                  y.c.length = k;
              } else if (isModExp) {
                y = y.mod(m);
              }
            }
            if (i) {
              i = mathfloor3(i / 2);
              if (i === 0)
                break;
              nIsOdd = i % 2;
            } else {
              n = n.times(half);
              round2(n, n.e + 1, 1);
              if (n.e > 14) {
                nIsOdd = isOdd3(n);
              } else {
                i = +valueOf(n);
                if (i === 0)
                  break;
                nIsOdd = i % 2;
              }
            }
            x = x.times(x);
            if (k) {
              if (x.c && x.c.length > k)
                x.c.length = k;
            } else if (isModExp) {
              x = x.mod(m);
            }
          }
          if (isModExp)
            return y;
          if (nIsNeg)
            y = ONE2.div(y);
          return m ? y.mod(m) : k ? round2(y, POW_PRECISION, ROUNDING_MODE, more) : y;
        };
        P2.integerValue = function(rm) {
          var n = new BigNumber3(this);
          if (rm == null)
            rm = ROUNDING_MODE;
          else
            intCheck2(rm, 0, 8);
          return round2(n, n.e + 1, rm);
        };
        P2.isEqualTo = P2.eq = function(y, b) {
          return compare2(this, new BigNumber3(y, b)) === 0;
        };
        P2.isFinite = function() {
          return !!this.c;
        };
        P2.isGreaterThan = P2.gt = function(y, b) {
          return compare2(this, new BigNumber3(y, b)) > 0;
        };
        P2.isGreaterThanOrEqualTo = P2.gte = function(y, b) {
          return (b = compare2(this, new BigNumber3(y, b))) === 1 || b === 0;
        };
        P2.isInteger = function() {
          return !!this.c && bitFloor2(this.e / LOG_BASE3) > this.c.length - 2;
        };
        P2.isLessThan = P2.lt = function(y, b) {
          return compare2(this, new BigNumber3(y, b)) < 0;
        };
        P2.isLessThanOrEqualTo = P2.lte = function(y, b) {
          return (b = compare2(this, new BigNumber3(y, b))) === -1 || b === 0;
        };
        P2.isNaN = function() {
          return !this.s;
        };
        P2.isNegative = function() {
          return this.s < 0;
        };
        P2.isPositive = function() {
          return this.s > 0;
        };
        P2.isZero = function() {
          return !!this.c && this.c[0] == 0;
        };
        P2.minus = function(y, b) {
          var i, j, t, xLTy, x = this, a = x.s;
          y = new BigNumber3(y, b);
          b = y.s;
          if (!a || !b)
            return new BigNumber3(NaN);
          if (a != b) {
            y.s = -b;
            return x.plus(y);
          }
          var xe = x.e / LOG_BASE3, ye = y.e / LOG_BASE3, xc = x.c, yc = y.c;
          if (!xe || !ye) {
            if (!xc || !yc)
              return xc ? (y.s = -b, y) : new BigNumber3(yc ? x : NaN);
            if (!xc[0] || !yc[0]) {
              return yc[0] ? (y.s = -b, y) : new BigNumber3(xc[0] ? x : (
                // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity
                ROUNDING_MODE == 3 ? -0 : 0
              ));
            }
          }
          xe = bitFloor2(xe);
          ye = bitFloor2(ye);
          xc = xc.slice();
          if (a = xe - ye) {
            if (xLTy = a < 0) {
              a = -a;
              t = xc;
            } else {
              ye = xe;
              t = yc;
            }
            t.reverse();
            for (b = a; b--; t.push(0))
              ;
            t.reverse();
          } else {
            j = (xLTy = (a = xc.length) < (b = yc.length)) ? a : b;
            for (a = b = 0; b < j; b++) {
              if (xc[b] != yc[b]) {
                xLTy = xc[b] < yc[b];
                break;
              }
            }
          }
          if (xLTy) {
            t = xc;
            xc = yc;
            yc = t;
            y.s = -y.s;
          }
          b = (j = yc.length) - (i = xc.length);
          if (b > 0)
            for (; b--; xc[i++] = 0)
              ;
          b = BASE3 - 1;
          for (; j > a; ) {
            if (xc[--j] < yc[j]) {
              for (i = j; i && !xc[--i]; xc[i] = b)
                ;
              --xc[i];
              xc[j] += BASE3;
            }
            xc[j] -= yc[j];
          }
          for (; xc[0] == 0; xc.splice(0, 1), --ye)
            ;
          if (!xc[0]) {
            y.s = ROUNDING_MODE == 3 ? -1 : 1;
            y.c = [y.e = 0];
            return y;
          }
          return normalise(y, xc, ye);
        };
        P2.modulo = P2.mod = function(y, b) {
          var q, s, x = this;
          y = new BigNumber3(y, b);
          if (!x.c || !y.s || y.c && !y.c[0]) {
            return new BigNumber3(NaN);
          } else if (!y.c || x.c && !x.c[0]) {
            return new BigNumber3(x);
          }
          if (MODULO_MODE == 9) {
            s = y.s;
            y.s = 1;
            q = div2(x, y, 0, 3);
            y.s = s;
            q.s *= s;
          } else {
            q = div2(x, y, 0, MODULO_MODE);
          }
          y = x.minus(q.times(y));
          if (!y.c[0] && MODULO_MODE == 1)
            y.s = x.s;
          return y;
        };
        P2.multipliedBy = P2.times = function(y, b) {
          var c, e, i, j, k, m, xcL, xlo, xhi, ycL, ylo, yhi, zc, base, sqrtBase, x = this, xc = x.c, yc = (y = new BigNumber3(y, b)).c;
          if (!xc || !yc || !xc[0] || !yc[0]) {
            if (!x.s || !y.s || xc && !xc[0] && !yc || yc && !yc[0] && !xc) {
              y.c = y.e = y.s = null;
            } else {
              y.s *= x.s;
              if (!xc || !yc) {
                y.c = y.e = null;
              } else {
                y.c = [0];
                y.e = 0;
              }
            }
            return y;
          }
          e = bitFloor2(x.e / LOG_BASE3) + bitFloor2(y.e / LOG_BASE3);
          y.s *= x.s;
          xcL = xc.length;
          ycL = yc.length;
          if (xcL < ycL) {
            zc = xc;
            xc = yc;
            yc = zc;
            i = xcL;
            xcL = ycL;
            ycL = i;
          }
          for (i = xcL + ycL, zc = []; i--; zc.push(0))
            ;
          base = BASE3;
          sqrtBase = SQRT_BASE2;
          for (i = ycL; --i >= 0; ) {
            c = 0;
            ylo = yc[i] % sqrtBase;
            yhi = yc[i] / sqrtBase | 0;
            for (k = xcL, j = i + k; j > i; ) {
              xlo = xc[--k] % sqrtBase;
              xhi = xc[k] / sqrtBase | 0;
              m = yhi * xlo + xhi * ylo;
              xlo = ylo * xlo + m % sqrtBase * sqrtBase + zc[j] + c;
              c = (xlo / base | 0) + (m / sqrtBase | 0) + yhi * xhi;
              zc[j--] = xlo % base;
            }
            zc[j] = c;
          }
          if (c) {
            ++e;
          } else {
            zc.splice(0, 1);
          }
          return normalise(y, zc, e);
        };
        P2.negated = function() {
          var x = new BigNumber3(this);
          x.s = -x.s || null;
          return x;
        };
        P2.plus = function(y, b) {
          var t, x = this, a = x.s;
          y = new BigNumber3(y, b);
          b = y.s;
          if (!a || !b)
            return new BigNumber3(NaN);
          if (a != b) {
            y.s = -b;
            return x.minus(y);
          }
          var xe = x.e / LOG_BASE3, ye = y.e / LOG_BASE3, xc = x.c, yc = y.c;
          if (!xe || !ye) {
            if (!xc || !yc)
              return new BigNumber3(a / 0);
            if (!xc[0] || !yc[0])
              return yc[0] ? y : new BigNumber3(xc[0] ? x : a * 0);
          }
          xe = bitFloor2(xe);
          ye = bitFloor2(ye);
          xc = xc.slice();
          if (a = xe - ye) {
            if (a > 0) {
              ye = xe;
              t = yc;
            } else {
              a = -a;
              t = xc;
            }
            t.reverse();
            for (; a--; t.push(0))
              ;
            t.reverse();
          }
          a = xc.length;
          b = yc.length;
          if (a - b < 0) {
            t = yc;
            yc = xc;
            xc = t;
            b = a;
          }
          for (a = 0; b; ) {
            a = (xc[--b] = xc[b] + yc[b] + a) / BASE3 | 0;
            xc[b] = BASE3 === xc[b] ? 0 : xc[b] % BASE3;
          }
          if (a) {
            xc = [a].concat(xc);
            ++ye;
          }
          return normalise(y, xc, ye);
        };
        P2.precision = P2.sd = function(sd, rm) {
          var c, n, v, x = this;
          if (sd != null && sd !== !!sd) {
            intCheck2(sd, 1, MAX3);
            if (rm == null)
              rm = ROUNDING_MODE;
            else
              intCheck2(rm, 0, 8);
            return round2(new BigNumber3(x), sd, rm);
          }
          if (!(c = x.c))
            return null;
          v = c.length - 1;
          n = v * LOG_BASE3 + 1;
          if (v = c[v]) {
            for (; v % 10 == 0; v /= 10, n--)
              ;
            for (v = c[0]; v >= 10; v /= 10, n++)
              ;
          }
          if (sd && x.e + 1 > n)
            n = x.e + 1;
          return n;
        };
        P2.shiftedBy = function(k) {
          intCheck2(k, -MAX_SAFE_INTEGER3, MAX_SAFE_INTEGER3);
          return this.times("1e" + k);
        };
        P2.squareRoot = P2.sqrt = function() {
          var m, n, r, rep, t, x = this, c = x.c, s = x.s, e = x.e, dp = DECIMAL_PLACES + 4, half = new BigNumber3("0.5");
          if (s !== 1 || !c || !c[0]) {
            return new BigNumber3(!s || s < 0 && (!c || c[0]) ? NaN : c ? x : 1 / 0);
          }
          s = Math.sqrt(+valueOf(x));
          if (s == 0 || s == 1 / 0) {
            n = coeffToString2(c);
            if ((n.length + e) % 2 == 0)
              n += "0";
            s = Math.sqrt(+n);
            e = bitFloor2((e + 1) / 2) - (e < 0 || e % 2);
            if (s == 1 / 0) {
              n = "5e" + e;
            } else {
              n = s.toExponential();
              n = n.slice(0, n.indexOf("e") + 1) + e;
            }
            r = new BigNumber3(n);
          } else {
            r = new BigNumber3(s + "");
          }
          if (r.c[0]) {
            e = r.e;
            s = e + dp;
            if (s < 3)
              s = 0;
            for (; ; ) {
              t = r;
              r = half.times(t.plus(div2(x, t, dp, 1)));
              if (coeffToString2(t.c).slice(0, s) === (n = coeffToString2(r.c)).slice(0, s)) {
                if (r.e < e)
                  --s;
                n = n.slice(s - 3, s + 1);
                if (n == "9999" || !rep && n == "4999") {
                  if (!rep) {
                    round2(t, t.e + DECIMAL_PLACES + 2, 0);
                    if (t.times(t).eq(x)) {
                      r = t;
                      break;
                    }
                  }
                  dp += 4;
                  s += 4;
                  rep = 1;
                } else {
                  if (!+n || !+n.slice(1) && n.charAt(0) == "5") {
                    round2(r, r.e + DECIMAL_PLACES + 2, 1);
                    m = !r.times(r).eq(x);
                  }
                  break;
                }
              }
            }
          }
          return round2(r, r.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m);
        };
        P2.toExponential = function(dp, rm) {
          if (dp != null) {
            intCheck2(dp, 0, MAX3);
            dp++;
          }
          return format(this, dp, rm, 1);
        };
        P2.toFixed = function(dp, rm) {
          if (dp != null) {
            intCheck2(dp, 0, MAX3);
            dp = dp + this.e + 1;
          }
          return format(this, dp, rm);
        };
        P2.toFormat = function(dp, rm, format2) {
          var str, x = this;
          if (format2 == null) {
            if (dp != null && rm && typeof rm == "object") {
              format2 = rm;
              rm = null;
            } else if (dp && typeof dp == "object") {
              format2 = dp;
              dp = rm = null;
            } else {
              format2 = FORMAT;
            }
          } else if (typeof format2 != "object") {
            throw Error(bignumberError2 + "Argument not an object: " + format2);
          }
          str = x.toFixed(dp, rm);
          if (x.c) {
            var i, arr = str.split("."), g1 = +format2.groupSize, g2 = +format2.secondaryGroupSize, groupSeparator = format2.groupSeparator || "", intPart = arr[0], fractionPart = arr[1], isNeg = x.s < 0, intDigits = isNeg ? intPart.slice(1) : intPart, len = intDigits.length;
            if (g2) {
              i = g1;
              g1 = g2;
              g2 = i;
              len -= i;
            }
            if (g1 > 0 && len > 0) {
              i = len % g1 || g1;
              intPart = intDigits.substr(0, i);
              for (; i < len; i += g1)
                intPart += groupSeparator + intDigits.substr(i, g1);
              if (g2 > 0)
                intPart += groupSeparator + intDigits.slice(i);
              if (isNeg)
                intPart = "-" + intPart;
            }
            str = fractionPart ? intPart + (format2.decimalSeparator || "") + ((g2 = +format2.fractionGroupSize) ? fractionPart.replace(
              new RegExp("\\d{" + g2 + "}\\B", "g"),
              "$&" + (format2.fractionGroupSeparator || "")
            ) : fractionPart) : intPart;
          }
          return (format2.prefix || "") + str + (format2.suffix || "");
        };
        P2.toFraction = function(md) {
          var d, d0, d1, d2, e, exp2, n, n0, n1, q, r, s, x = this, xc = x.c;
          if (md != null) {
            n = new BigNumber3(md);
            if (!n.isInteger() && (n.c || n.s !== 1) || n.lt(ONE2)) {
              throw Error(bignumberError2 + "Argument " + (n.isInteger() ? "out of range: " : "not an integer: ") + valueOf(n));
            }
          }
          if (!xc)
            return new BigNumber3(x);
          d = new BigNumber3(ONE2);
          n1 = d0 = new BigNumber3(ONE2);
          d1 = n0 = new BigNumber3(ONE2);
          s = coeffToString2(xc);
          e = d.e = s.length - x.e - 1;
          d.c[0] = POWS_TEN2[(exp2 = e % LOG_BASE3) < 0 ? LOG_BASE3 + exp2 : exp2];
          md = !md || n.comparedTo(d) > 0 ? e > 0 ? d : n1 : n;
          exp2 = MAX_EXP;
          MAX_EXP = 1 / 0;
          n = new BigNumber3(s);
          n0.c[0] = 0;
          for (; ; ) {
            q = div2(n, d, 0, 1);
            d2 = d0.plus(q.times(d1));
            if (d2.comparedTo(md) == 1)
              break;
            d0 = d1;
            d1 = d2;
            n1 = n0.plus(q.times(d2 = n1));
            n0 = d2;
            d = n.minus(q.times(d2 = d));
            n = d2;
          }
          d2 = div2(md.minus(d0), d1, 0, 1);
          n0 = n0.plus(d2.times(n1));
          d0 = d0.plus(d2.times(d1));
          n0.s = n1.s = x.s;
          e = e * 2;
          r = div2(n1, d1, e, ROUNDING_MODE).minus(x).abs().comparedTo(
            div2(n0, d0, e, ROUNDING_MODE).minus(x).abs()
          ) < 1 ? [n1, d1] : [n0, d0];
          MAX_EXP = exp2;
          return r;
        };
        P2.toNumber = function() {
          return +valueOf(this);
        };
        P2.toPrecision = function(sd, rm) {
          if (sd != null)
            intCheck2(sd, 1, MAX3);
          return format(this, sd, rm, 2);
        };
        P2.toString = function(b) {
          var str, n = this, s = n.s, e = n.e;
          if (e === null) {
            if (s) {
              str = "Infinity";
              if (s < 0)
                str = "-" + str;
            } else {
              str = "NaN";
            }
          } else {
            if (b == null) {
              str = e <= TO_EXP_NEG || e >= TO_EXP_POS ? toExponential2(coeffToString2(n.c), e) : toFixedPoint2(coeffToString2(n.c), e, "0");
            } else if (b === 10 && alphabetHasNormalDecimalDigits) {
              n = round2(new BigNumber3(n), DECIMAL_PLACES + e + 1, ROUNDING_MODE);
              str = toFixedPoint2(coeffToString2(n.c), n.e, "0");
            } else {
              intCheck2(b, 2, ALPHABET.length, "Base");
              str = convertBase2(toFixedPoint2(coeffToString2(n.c), e, "0"), 10, b, s, true);
            }
            if (s < 0 && n.c[0])
              str = "-" + str;
          }
          return str;
        };
        P2.valueOf = P2.toJSON = function() {
          return valueOf(this);
        };
        P2._isBigNumber = true;
        if (configObject != null)
          BigNumber3.set(configObject);
        return BigNumber3;
      }
      function bitFloor2(n) {
        var i = n | 0;
        return n > 0 || n === i ? i : i - 1;
      }
      function coeffToString2(a) {
        var s, z, i = 1, j = a.length, r = a[0] + "";
        for (; i < j; ) {
          s = a[i++] + "";
          z = LOG_BASE3 - s.length;
          for (; z--; s = "0" + s)
            ;
          r += s;
        }
        for (j = r.length; r.charCodeAt(--j) === 48; )
          ;
        return r.slice(0, j + 1 || 1);
      }
      function compare2(x, y) {
        var a, b, xc = x.c, yc = y.c, i = x.s, j = y.s, k = x.e, l = y.e;
        if (!i || !j)
          return null;
        a = xc && !xc[0];
        b = yc && !yc[0];
        if (a || b)
          return a ? b ? 0 : -j : i;
        if (i != j)
          return i;
        a = i < 0;
        b = k == l;
        if (!xc || !yc)
          return b ? 0 : !xc ^ a ? 1 : -1;
        if (!b)
          return k > l ^ a ? 1 : -1;
        j = (k = xc.length) < (l = yc.length) ? k : l;
        for (i = 0; i < j; i++)
          if (xc[i] != yc[i])
            return xc[i] > yc[i] ^ a ? 1 : -1;
        return k == l ? 0 : k > l ^ a ? 1 : -1;
      }
      function intCheck2(n, min2, max2, name) {
        if (n < min2 || n > max2 || n !== mathfloor3(n)) {
          throw Error(bignumberError2 + (name || "Argument") + (typeof n == "number" ? n < min2 || n > max2 ? " out of range: " : " not an integer: " : " not a primitive number: ") + String(n));
        }
      }
      function isOdd3(n) {
        var k = n.c.length - 1;
        return bitFloor2(n.e / LOG_BASE3) == k && n.c[k] % 2 != 0;
      }
      function toExponential2(str, e) {
        return (str.length > 1 ? str.charAt(0) + "." + str.slice(1) : str) + (e < 0 ? "e" : "e+") + e;
      }
      function toFixedPoint2(str, e, z) {
        var len, zs;
        if (e < 0) {
          for (zs = z + "."; ++e; zs += z)
            ;
          str = zs + str;
        } else {
          len = str.length;
          if (++e > len) {
            for (zs = z, e -= len; --e; zs += z)
              ;
            str += zs;
          } else if (e < len) {
            str = str.slice(0, e) + "." + str.slice(e);
          }
        }
        return str;
      }
      BigNumber2 = clone3();
      BigNumber2["default"] = BigNumber2.BigNumber = BigNumber2;
      if (typeof define == "function" && define.amd) {
        define(function() {
          return BigNumber2;
        });
      } else if (typeof module2 != "undefined" && module2.exports) {
        module2.exports = BigNumber2;
      } else {
        if (!globalObject) {
          globalObject = typeof self != "undefined" && self ? self : window;
        }
        globalObject.BigNumber = BigNumber2;
      }
    })(exports2);
  }
});

// node_modules/@solana/buffer-layout-utils/lib/cjs/decimal.js
var require_decimal2 = __commonJS({
  "node_modules/@solana/buffer-layout-utils/lib/cjs/decimal.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.decimal = exports2.WAD = void 0;
    var bignumber_js_1 = __importDefault(require_bignumber());
    var base_1 = require_base();
    var bigint_1 = require_bigint();
    exports2.WAD = new bignumber_js_1.default("1e+18");
    var decimal = (property) => {
      const layout = (0, bigint_1.u128)(property);
      const { encode, decode } = (0, base_1.encodeDecode)(layout);
      const decimalLayout = layout;
      decimalLayout.decode = (buffer, offset) => {
        const src = decode(buffer, offset).toString();
        return new bignumber_js_1.default(src).div(exports2.WAD);
      };
      decimalLayout.encode = (decimal2, buffer, offset) => {
        const src = BigInt(decimal2.times(exports2.WAD).integerValue().toString());
        return encode(src, buffer, offset);
      };
      return decimalLayout;
    };
    exports2.decimal = decimal;
  }
});

// node_modules/@solana/buffer-layout-utils/lib/cjs/native.js
var require_native = __commonJS({
  "node_modules/@solana/buffer-layout-utils/lib/cjs/native.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.bool = void 0;
    var buffer_layout_1 = require_Layout();
    var base_1 = require_base();
    var bool2 = (property) => {
      const layout = (0, buffer_layout_1.u8)(property);
      const { encode, decode } = (0, base_1.encodeDecode)(layout);
      const boolLayout = layout;
      boolLayout.decode = (buffer, offset) => {
        const src = decode(buffer, offset);
        return !!src;
      };
      boolLayout.encode = (bool3, buffer, offset) => {
        const src = Number(bool3);
        return encode(src, buffer, offset);
      };
      return boolLayout;
    };
    exports2.bool = bool2;
  }
});

// node_modules/@solana/buffer-layout-utils/lib/cjs/web3.js
var require_web3 = __commonJS({
  "node_modules/@solana/buffer-layout-utils/lib/cjs/web3.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.publicKey = void 0;
    var buffer_layout_1 = require_Layout();
    var web3_js_1 = require("@solana/web3.js");
    var base_1 = require_base();
    var publicKey2 = (property) => {
      const layout = (0, buffer_layout_1.blob)(32, property);
      const { encode, decode } = (0, base_1.encodeDecode)(layout);
      const publicKeyLayout = layout;
      publicKeyLayout.decode = (buffer, offset) => {
        const src = decode(buffer, offset);
        return new web3_js_1.PublicKey(src);
      };
      publicKeyLayout.encode = (publicKey3, buffer, offset) => {
        const src = publicKey3.toBuffer();
        return encode(src, buffer, offset);
      };
      return publicKeyLayout;
    };
    exports2.publicKey = publicKey2;
  }
});

// node_modules/@solana/buffer-layout-utils/lib/cjs/index.js
var require_cjs = __commonJS({
  "node_modules/@solana/buffer-layout-utils/lib/cjs/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_base(), exports2);
    __exportStar(require_bigint(), exports2);
    __exportStar(require_decimal2(), exports2);
    __exportStar(require_native(), exports2);
    __exportStar(require_web3(), exports2);
  }
});

// node_modules/@solana/spl-token/lib/cjs/errors.js
var require_errors = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/errors.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TokenTransferHookAccountDataNotFound = exports2.TokenTransferHookInvalidSeed = exports2.TokenTransferHookAccountNotFound = exports2.TokenUnsupportedInstructionError = exports2.TokenInvalidInstructionTypeError = exports2.TokenInvalidInstructionDataError = exports2.TokenInvalidInstructionKeysError = exports2.TokenInvalidInstructionProgramError = exports2.TokenOwnerOffCurveError = exports2.TokenInvalidOwnerError = exports2.TokenInvalidMintError = exports2.TokenInvalidAccountSizeError = exports2.TokenInvalidAccountOwnerError = exports2.TokenInvalidAccountDataError = exports2.TokenInvalidAccountError = exports2.TokenAccountNotFoundError = exports2.TokenError = void 0;
    var TokenError2 = class extends Error {
      constructor(message) {
        super(message);
      }
    };
    exports2.TokenError = TokenError2;
    var TokenAccountNotFoundError2 = class extends TokenError2 {
      constructor() {
        super(...arguments);
        this.name = "TokenAccountNotFoundError";
      }
    };
    exports2.TokenAccountNotFoundError = TokenAccountNotFoundError2;
    var TokenInvalidAccountError2 = class extends TokenError2 {
      constructor() {
        super(...arguments);
        this.name = "TokenInvalidAccountError";
      }
    };
    exports2.TokenInvalidAccountError = TokenInvalidAccountError2;
    var TokenInvalidAccountDataError = class extends TokenError2 {
      constructor() {
        super(...arguments);
        this.name = "TokenInvalidAccountDataError";
      }
    };
    exports2.TokenInvalidAccountDataError = TokenInvalidAccountDataError;
    var TokenInvalidAccountOwnerError2 = class extends TokenError2 {
      constructor() {
        super(...arguments);
        this.name = "TokenInvalidAccountOwnerError";
      }
    };
    exports2.TokenInvalidAccountOwnerError = TokenInvalidAccountOwnerError2;
    var TokenInvalidAccountSizeError2 = class extends TokenError2 {
      constructor() {
        super(...arguments);
        this.name = "TokenInvalidAccountSizeError";
      }
    };
    exports2.TokenInvalidAccountSizeError = TokenInvalidAccountSizeError2;
    var TokenInvalidMintError2 = class extends TokenError2 {
      constructor() {
        super(...arguments);
        this.name = "TokenInvalidMintError";
      }
    };
    exports2.TokenInvalidMintError = TokenInvalidMintError2;
    var TokenInvalidOwnerError = class extends TokenError2 {
      constructor() {
        super(...arguments);
        this.name = "TokenInvalidOwnerError";
      }
    };
    exports2.TokenInvalidOwnerError = TokenInvalidOwnerError;
    var TokenOwnerOffCurveError2 = class extends TokenError2 {
      constructor() {
        super(...arguments);
        this.name = "TokenOwnerOffCurveError";
      }
    };
    exports2.TokenOwnerOffCurveError = TokenOwnerOffCurveError2;
    var TokenInvalidInstructionProgramError = class extends TokenError2 {
      constructor() {
        super(...arguments);
        this.name = "TokenInvalidInstructionProgramError";
      }
    };
    exports2.TokenInvalidInstructionProgramError = TokenInvalidInstructionProgramError;
    var TokenInvalidInstructionKeysError = class extends TokenError2 {
      constructor() {
        super(...arguments);
        this.name = "TokenInvalidInstructionKeysError";
      }
    };
    exports2.TokenInvalidInstructionKeysError = TokenInvalidInstructionKeysError;
    var TokenInvalidInstructionDataError = class extends TokenError2 {
      constructor() {
        super(...arguments);
        this.name = "TokenInvalidInstructionDataError";
      }
    };
    exports2.TokenInvalidInstructionDataError = TokenInvalidInstructionDataError;
    var TokenInvalidInstructionTypeError = class extends TokenError2 {
      constructor() {
        super(...arguments);
        this.name = "TokenInvalidInstructionTypeError";
      }
    };
    exports2.TokenInvalidInstructionTypeError = TokenInvalidInstructionTypeError;
    var TokenUnsupportedInstructionError = class extends TokenError2 {
      constructor() {
        super(...arguments);
        this.name = "TokenUnsupportedInstructionError";
      }
    };
    exports2.TokenUnsupportedInstructionError = TokenUnsupportedInstructionError;
    var TokenTransferHookAccountNotFound2 = class extends TokenError2 {
      constructor() {
        super(...arguments);
        this.name = "TokenTransferHookAccountNotFound";
      }
    };
    exports2.TokenTransferHookAccountNotFound = TokenTransferHookAccountNotFound2;
    var TokenTransferHookInvalidSeed2 = class extends TokenError2 {
      constructor() {
        super(...arguments);
        this.name = "TokenTransferHookInvalidSeed";
      }
    };
    exports2.TokenTransferHookInvalidSeed = TokenTransferHookInvalidSeed2;
    var TokenTransferHookAccountDataNotFound2 = class extends TokenError2 {
      constructor() {
        super(...arguments);
        this.name = "TokenTransferHookAccountDataNotFound";
      }
    };
    exports2.TokenTransferHookAccountDataNotFound = TokenTransferHookAccountDataNotFound2;
  }
});

// node_modules/@solana/spl-token/lib/cjs/instructions/types.js
var require_types = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/instructions/types.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TokenInstruction = void 0;
    var TokenInstruction2;
    (function(TokenInstruction3) {
      TokenInstruction3[TokenInstruction3["InitializeMint"] = 0] = "InitializeMint";
      TokenInstruction3[TokenInstruction3["InitializeAccount"] = 1] = "InitializeAccount";
      TokenInstruction3[TokenInstruction3["InitializeMultisig"] = 2] = "InitializeMultisig";
      TokenInstruction3[TokenInstruction3["Transfer"] = 3] = "Transfer";
      TokenInstruction3[TokenInstruction3["Approve"] = 4] = "Approve";
      TokenInstruction3[TokenInstruction3["Revoke"] = 5] = "Revoke";
      TokenInstruction3[TokenInstruction3["SetAuthority"] = 6] = "SetAuthority";
      TokenInstruction3[TokenInstruction3["MintTo"] = 7] = "MintTo";
      TokenInstruction3[TokenInstruction3["Burn"] = 8] = "Burn";
      TokenInstruction3[TokenInstruction3["CloseAccount"] = 9] = "CloseAccount";
      TokenInstruction3[TokenInstruction3["FreezeAccount"] = 10] = "FreezeAccount";
      TokenInstruction3[TokenInstruction3["ThawAccount"] = 11] = "ThawAccount";
      TokenInstruction3[TokenInstruction3["TransferChecked"] = 12] = "TransferChecked";
      TokenInstruction3[TokenInstruction3["ApproveChecked"] = 13] = "ApproveChecked";
      TokenInstruction3[TokenInstruction3["MintToChecked"] = 14] = "MintToChecked";
      TokenInstruction3[TokenInstruction3["BurnChecked"] = 15] = "BurnChecked";
      TokenInstruction3[TokenInstruction3["InitializeAccount2"] = 16] = "InitializeAccount2";
      TokenInstruction3[TokenInstruction3["SyncNative"] = 17] = "SyncNative";
      TokenInstruction3[TokenInstruction3["InitializeAccount3"] = 18] = "InitializeAccount3";
      TokenInstruction3[TokenInstruction3["InitializeMultisig2"] = 19] = "InitializeMultisig2";
      TokenInstruction3[TokenInstruction3["InitializeMint2"] = 20] = "InitializeMint2";
      TokenInstruction3[TokenInstruction3["GetAccountDataSize"] = 21] = "GetAccountDataSize";
      TokenInstruction3[TokenInstruction3["InitializeImmutableOwner"] = 22] = "InitializeImmutableOwner";
      TokenInstruction3[TokenInstruction3["AmountToUiAmount"] = 23] = "AmountToUiAmount";
      TokenInstruction3[TokenInstruction3["UiAmountToAmount"] = 24] = "UiAmountToAmount";
      TokenInstruction3[TokenInstruction3["InitializeMintCloseAuthority"] = 25] = "InitializeMintCloseAuthority";
      TokenInstruction3[TokenInstruction3["TransferFeeExtension"] = 26] = "TransferFeeExtension";
      TokenInstruction3[TokenInstruction3["ConfidentialTransferExtension"] = 27] = "ConfidentialTransferExtension";
      TokenInstruction3[TokenInstruction3["DefaultAccountStateExtension"] = 28] = "DefaultAccountStateExtension";
      TokenInstruction3[TokenInstruction3["Reallocate"] = 29] = "Reallocate";
      TokenInstruction3[TokenInstruction3["MemoTransferExtension"] = 30] = "MemoTransferExtension";
      TokenInstruction3[TokenInstruction3["CreateNativeMint"] = 31] = "CreateNativeMint";
      TokenInstruction3[TokenInstruction3["InitializeNonTransferableMint"] = 32] = "InitializeNonTransferableMint";
      TokenInstruction3[TokenInstruction3["InterestBearingMintExtension"] = 33] = "InterestBearingMintExtension";
      TokenInstruction3[TokenInstruction3["CpiGuardExtension"] = 34] = "CpiGuardExtension";
      TokenInstruction3[TokenInstruction3["InitializePermanentDelegate"] = 35] = "InitializePermanentDelegate";
      TokenInstruction3[TokenInstruction3["TransferHookExtension"] = 36] = "TransferHookExtension";
      TokenInstruction3[TokenInstruction3["MetadataPointerExtension"] = 39] = "MetadataPointerExtension";
    })(TokenInstruction2 || (exports2.TokenInstruction = TokenInstruction2 = {}));
  }
});

// node_modules/@solana/spl-token/lib/cjs/instructions/amountToUiAmount.js
var require_amountToUiAmount = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/instructions/amountToUiAmount.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.decodeAmountToUiAmountInstructionUnchecked = exports2.decodeAmountToUiAmountInstruction = exports2.createAmountToUiAmountInstruction = exports2.amountToUiAmountInstructionData = void 0;
    var buffer_layout_1 = require_Layout();
    var buffer_layout_utils_1 = require_cjs();
    var web3_js_1 = require("@solana/web3.js");
    var constants_js_1 = require_constants();
    var errors_js_1 = require_errors();
    var types_js_1 = require_types();
    exports2.amountToUiAmountInstructionData = (0, buffer_layout_1.struct)([
      (0, buffer_layout_1.u8)("instruction"),
      (0, buffer_layout_utils_1.u64)("amount")
    ]);
    function createAmountToUiAmountInstruction(mint, amount, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      const keys = [{ pubkey: mint, isSigner: false, isWritable: false }];
      const data = Buffer.alloc(exports2.amountToUiAmountInstructionData.span);
      exports2.amountToUiAmountInstructionData.encode({
        instruction: types_js_1.TokenInstruction.AmountToUiAmount,
        amount: BigInt(amount)
      }, data);
      return new web3_js_1.TransactionInstruction({ keys, programId, data });
    }
    exports2.createAmountToUiAmountInstruction = createAmountToUiAmountInstruction;
    function decodeAmountToUiAmountInstruction(instruction, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      if (!instruction.programId.equals(programId))
        throw new errors_js_1.TokenInvalidInstructionProgramError();
      if (instruction.data.length !== exports2.amountToUiAmountInstructionData.span)
        throw new errors_js_1.TokenInvalidInstructionDataError();
      const { keys: { mint }, data } = decodeAmountToUiAmountInstructionUnchecked(instruction);
      if (data.instruction !== types_js_1.TokenInstruction.AmountToUiAmount)
        throw new errors_js_1.TokenInvalidInstructionTypeError();
      if (!mint)
        throw new errors_js_1.TokenInvalidInstructionKeysError();
      return {
        programId,
        keys: {
          mint
        },
        data
      };
    }
    exports2.decodeAmountToUiAmountInstruction = decodeAmountToUiAmountInstruction;
    function decodeAmountToUiAmountInstructionUnchecked({ programId, keys: [mint], data }) {
      return {
        programId,
        keys: {
          mint
        },
        data: exports2.amountToUiAmountInstructionData.decode(data)
      };
    }
    exports2.decodeAmountToUiAmountInstructionUnchecked = decodeAmountToUiAmountInstructionUnchecked;
  }
});

// node_modules/@solana/spl-token/lib/cjs/actions/amountToUiAmount.js
var require_amountToUiAmount2 = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/actions/amountToUiAmount.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.amountToUiAmount = void 0;
    var web3_js_1 = require("@solana/web3.js");
    var constants_js_1 = require_constants();
    var amountToUiAmount_js_1 = require_amountToUiAmount();
    function amountToUiAmount(connection, payer, mint, amount, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      return __awaiter(this, void 0, void 0, function* () {
        const transaction = new web3_js_1.Transaction().add((0, amountToUiAmount_js_1.createAmountToUiAmountInstruction)(mint, amount, programId));
        const { returnData, err } = (yield connection.simulateTransaction(transaction, [payer], false)).value;
        if (returnData === null || returnData === void 0 ? void 0 : returnData.data) {
          return Buffer.from(returnData.data[0], returnData.data[1]).toString("utf-8");
        }
        return err;
      });
    }
    exports2.amountToUiAmount = amountToUiAmount;
  }
});

// node_modules/@solana/spl-token/lib/cjs/instructions/internal.js
var require_internal = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/instructions/internal.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.addSigners = void 0;
    var web3_js_1 = require("@solana/web3.js");
    function addSigners2(keys, ownerOrAuthority, multiSigners) {
      if (multiSigners.length) {
        keys.push({ pubkey: ownerOrAuthority, isSigner: false, isWritable: false });
        for (const signer of multiSigners) {
          keys.push({
            pubkey: signer instanceof web3_js_1.PublicKey ? signer : signer.publicKey,
            isSigner: true,
            isWritable: false
          });
        }
      } else {
        keys.push({ pubkey: ownerOrAuthority, isSigner: true, isWritable: false });
      }
      return keys;
    }
    exports2.addSigners = addSigners2;
  }
});

// node_modules/@solana/spl-token/lib/cjs/instructions/approve.js
var require_approve = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/instructions/approve.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.decodeApproveInstructionUnchecked = exports2.decodeApproveInstruction = exports2.createApproveInstruction = exports2.approveInstructionData = void 0;
    var buffer_layout_1 = require_Layout();
    var buffer_layout_utils_1 = require_cjs();
    var web3_js_1 = require("@solana/web3.js");
    var constants_js_1 = require_constants();
    var errors_js_1 = require_errors();
    var internal_js_1 = require_internal();
    var types_js_1 = require_types();
    exports2.approveInstructionData = (0, buffer_layout_1.struct)([(0, buffer_layout_1.u8)("instruction"), (0, buffer_layout_utils_1.u64)("amount")]);
    function createApproveInstruction(account, delegate, owner, amount, multiSigners = [], programId = constants_js_1.TOKEN_PROGRAM_ID) {
      const keys = (0, internal_js_1.addSigners)([
        { pubkey: account, isSigner: false, isWritable: true },
        { pubkey: delegate, isSigner: false, isWritable: false }
      ], owner, multiSigners);
      const data = Buffer.alloc(exports2.approveInstructionData.span);
      exports2.approveInstructionData.encode({
        instruction: types_js_1.TokenInstruction.Approve,
        amount: BigInt(amount)
      }, data);
      return new web3_js_1.TransactionInstruction({ keys, programId, data });
    }
    exports2.createApproveInstruction = createApproveInstruction;
    function decodeApproveInstruction(instruction, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      if (!instruction.programId.equals(programId))
        throw new errors_js_1.TokenInvalidInstructionProgramError();
      if (instruction.data.length !== exports2.approveInstructionData.span)
        throw new errors_js_1.TokenInvalidInstructionDataError();
      const { keys: { account, delegate, owner, multiSigners }, data } = decodeApproveInstructionUnchecked(instruction);
      if (data.instruction !== types_js_1.TokenInstruction.Approve)
        throw new errors_js_1.TokenInvalidInstructionTypeError();
      if (!account || !delegate || !owner)
        throw new errors_js_1.TokenInvalidInstructionKeysError();
      return {
        programId,
        keys: {
          account,
          delegate,
          owner,
          multiSigners
        },
        data
      };
    }
    exports2.decodeApproveInstruction = decodeApproveInstruction;
    function decodeApproveInstructionUnchecked({ programId, keys: [account, delegate, owner, ...multiSigners], data }) {
      return {
        programId,
        keys: {
          account,
          delegate,
          owner,
          multiSigners
        },
        data: exports2.approveInstructionData.decode(data)
      };
    }
    exports2.decodeApproveInstructionUnchecked = decodeApproveInstructionUnchecked;
  }
});

// node_modules/@solana/spl-token/lib/cjs/actions/internal.js
var require_internal2 = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/actions/internal.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getSigners = void 0;
    var web3_js_1 = require("@solana/web3.js");
    function getSigners(signerOrMultisig, multiSigners) {
      return signerOrMultisig instanceof web3_js_1.PublicKey ? [signerOrMultisig, multiSigners] : [signerOrMultisig.publicKey, [signerOrMultisig]];
    }
    exports2.getSigners = getSigners;
  }
});

// node_modules/@solana/spl-token/lib/cjs/actions/approve.js
var require_approve2 = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/actions/approve.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.approve = void 0;
    var web3_js_1 = require("@solana/web3.js");
    var constants_js_1 = require_constants();
    var approve_js_1 = require_approve();
    var internal_js_1 = require_internal2();
    function approve(connection, payer, account, delegate, owner, amount, multiSigners = [], confirmOptions, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      return __awaiter(this, void 0, void 0, function* () {
        const [ownerPublicKey, signers] = (0, internal_js_1.getSigners)(owner, multiSigners);
        const transaction = new web3_js_1.Transaction().add((0, approve_js_1.createApproveInstruction)(account, delegate, ownerPublicKey, amount, multiSigners, programId));
        return yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer, ...signers], confirmOptions);
      });
    }
    exports2.approve = approve;
  }
});

// node_modules/@solana/spl-token/lib/cjs/instructions/approveChecked.js
var require_approveChecked = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/instructions/approveChecked.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.decodeApproveCheckedInstructionUnchecked = exports2.decodeApproveCheckedInstruction = exports2.createApproveCheckedInstruction = exports2.approveCheckedInstructionData = void 0;
    var buffer_layout_1 = require_Layout();
    var buffer_layout_utils_1 = require_cjs();
    var web3_js_1 = require("@solana/web3.js");
    var constants_js_1 = require_constants();
    var errors_js_1 = require_errors();
    var internal_js_1 = require_internal();
    var types_js_1 = require_types();
    exports2.approveCheckedInstructionData = (0, buffer_layout_1.struct)([
      (0, buffer_layout_1.u8)("instruction"),
      (0, buffer_layout_utils_1.u64)("amount"),
      (0, buffer_layout_1.u8)("decimals")
    ]);
    function createApproveCheckedInstruction(account, mint, delegate, owner, amount, decimals, multiSigners = [], programId = constants_js_1.TOKEN_PROGRAM_ID) {
      const keys = (0, internal_js_1.addSigners)([
        { pubkey: account, isSigner: false, isWritable: true },
        { pubkey: mint, isSigner: false, isWritable: false },
        { pubkey: delegate, isSigner: false, isWritable: false }
      ], owner, multiSigners);
      const data = Buffer.alloc(exports2.approveCheckedInstructionData.span);
      exports2.approveCheckedInstructionData.encode({
        instruction: types_js_1.TokenInstruction.ApproveChecked,
        amount: BigInt(amount),
        decimals
      }, data);
      return new web3_js_1.TransactionInstruction({ keys, programId, data });
    }
    exports2.createApproveCheckedInstruction = createApproveCheckedInstruction;
    function decodeApproveCheckedInstruction(instruction, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      if (!instruction.programId.equals(programId))
        throw new errors_js_1.TokenInvalidInstructionProgramError();
      if (instruction.data.length !== exports2.approveCheckedInstructionData.span)
        throw new errors_js_1.TokenInvalidInstructionDataError();
      const { keys: { account, mint, delegate, owner, multiSigners }, data } = decodeApproveCheckedInstructionUnchecked(instruction);
      if (data.instruction !== types_js_1.TokenInstruction.ApproveChecked)
        throw new errors_js_1.TokenInvalidInstructionTypeError();
      if (!account || !mint || !delegate || !owner)
        throw new errors_js_1.TokenInvalidInstructionKeysError();
      return {
        programId,
        keys: {
          account,
          mint,
          delegate,
          owner,
          multiSigners
        },
        data
      };
    }
    exports2.decodeApproveCheckedInstruction = decodeApproveCheckedInstruction;
    function decodeApproveCheckedInstructionUnchecked({ programId, keys: [account, mint, delegate, owner, ...multiSigners], data }) {
      return {
        programId,
        keys: {
          account,
          mint,
          delegate,
          owner,
          multiSigners
        },
        data: exports2.approveCheckedInstructionData.decode(data)
      };
    }
    exports2.decodeApproveCheckedInstructionUnchecked = decodeApproveCheckedInstructionUnchecked;
  }
});

// node_modules/@solana/spl-token/lib/cjs/actions/approveChecked.js
var require_approveChecked2 = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/actions/approveChecked.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.approveChecked = void 0;
    var web3_js_1 = require("@solana/web3.js");
    var constants_js_1 = require_constants();
    var approveChecked_js_1 = require_approveChecked();
    var internal_js_1 = require_internal2();
    function approveChecked(connection, payer, mint, account, delegate, owner, amount, decimals, multiSigners = [], confirmOptions, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      return __awaiter(this, void 0, void 0, function* () {
        const [ownerPublicKey, signers] = (0, internal_js_1.getSigners)(owner, multiSigners);
        const transaction = new web3_js_1.Transaction().add((0, approveChecked_js_1.createApproveCheckedInstruction)(account, mint, delegate, ownerPublicKey, amount, decimals, multiSigners, programId));
        return yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer, ...signers], confirmOptions);
      });
    }
    exports2.approveChecked = approveChecked;
  }
});

// node_modules/@solana/spl-token/lib/cjs/instructions/burn.js
var require_burn = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/instructions/burn.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.decodeBurnInstructionUnchecked = exports2.decodeBurnInstruction = exports2.createBurnInstruction = exports2.burnInstructionData = void 0;
    var buffer_layout_1 = require_Layout();
    var buffer_layout_utils_1 = require_cjs();
    var web3_js_1 = require("@solana/web3.js");
    var constants_js_1 = require_constants();
    var errors_js_1 = require_errors();
    var internal_js_1 = require_internal();
    var types_js_1 = require_types();
    exports2.burnInstructionData = (0, buffer_layout_1.struct)([(0, buffer_layout_1.u8)("instruction"), (0, buffer_layout_utils_1.u64)("amount")]);
    function createBurnInstruction(account, mint, owner, amount, multiSigners = [], programId = constants_js_1.TOKEN_PROGRAM_ID) {
      const keys = (0, internal_js_1.addSigners)([
        { pubkey: account, isSigner: false, isWritable: true },
        { pubkey: mint, isSigner: false, isWritable: true }
      ], owner, multiSigners);
      const data = Buffer.alloc(exports2.burnInstructionData.span);
      exports2.burnInstructionData.encode({
        instruction: types_js_1.TokenInstruction.Burn,
        amount: BigInt(amount)
      }, data);
      return new web3_js_1.TransactionInstruction({ keys, programId, data });
    }
    exports2.createBurnInstruction = createBurnInstruction;
    function decodeBurnInstruction(instruction, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      if (!instruction.programId.equals(programId))
        throw new errors_js_1.TokenInvalidInstructionProgramError();
      if (instruction.data.length !== exports2.burnInstructionData.span)
        throw new errors_js_1.TokenInvalidInstructionDataError();
      const { keys: { account, mint, owner, multiSigners }, data } = decodeBurnInstructionUnchecked(instruction);
      if (data.instruction !== types_js_1.TokenInstruction.Burn)
        throw new errors_js_1.TokenInvalidInstructionTypeError();
      if (!account || !mint || !owner)
        throw new errors_js_1.TokenInvalidInstructionKeysError();
      return {
        programId,
        keys: {
          account,
          mint,
          owner,
          multiSigners
        },
        data
      };
    }
    exports2.decodeBurnInstruction = decodeBurnInstruction;
    function decodeBurnInstructionUnchecked({ programId, keys: [account, mint, owner, ...multiSigners], data }) {
      return {
        programId,
        keys: {
          account,
          mint,
          owner,
          multiSigners
        },
        data: exports2.burnInstructionData.decode(data)
      };
    }
    exports2.decodeBurnInstructionUnchecked = decodeBurnInstructionUnchecked;
  }
});

// node_modules/@solana/spl-token/lib/cjs/actions/burn.js
var require_burn2 = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/actions/burn.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.burn = void 0;
    var web3_js_1 = require("@solana/web3.js");
    var constants_js_1 = require_constants();
    var burn_js_1 = require_burn();
    var internal_js_1 = require_internal2();
    function burn(connection, payer, account, mint, owner, amount, multiSigners = [], confirmOptions, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      return __awaiter(this, void 0, void 0, function* () {
        const [ownerPublicKey, signers] = (0, internal_js_1.getSigners)(owner, multiSigners);
        const transaction = new web3_js_1.Transaction().add((0, burn_js_1.createBurnInstruction)(account, mint, ownerPublicKey, amount, multiSigners, programId));
        return yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer, ...signers], confirmOptions);
      });
    }
    exports2.burn = burn;
  }
});

// node_modules/@solana/spl-token/lib/cjs/instructions/burnChecked.js
var require_burnChecked = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/instructions/burnChecked.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.decodeBurnCheckedInstructionUnchecked = exports2.decodeBurnCheckedInstruction = exports2.createBurnCheckedInstruction = exports2.burnCheckedInstructionData = void 0;
    var buffer_layout_1 = require_Layout();
    var buffer_layout_utils_1 = require_cjs();
    var web3_js_1 = require("@solana/web3.js");
    var constants_js_1 = require_constants();
    var errors_js_1 = require_errors();
    var internal_js_1 = require_internal();
    var types_js_1 = require_types();
    exports2.burnCheckedInstructionData = (0, buffer_layout_1.struct)([
      (0, buffer_layout_1.u8)("instruction"),
      (0, buffer_layout_utils_1.u64)("amount"),
      (0, buffer_layout_1.u8)("decimals")
    ]);
    function createBurnCheckedInstruction(account, mint, owner, amount, decimals, multiSigners = [], programId = constants_js_1.TOKEN_PROGRAM_ID) {
      const keys = (0, internal_js_1.addSigners)([
        { pubkey: account, isSigner: false, isWritable: true },
        { pubkey: mint, isSigner: false, isWritable: true }
      ], owner, multiSigners);
      const data = Buffer.alloc(exports2.burnCheckedInstructionData.span);
      exports2.burnCheckedInstructionData.encode({
        instruction: types_js_1.TokenInstruction.BurnChecked,
        amount: BigInt(amount),
        decimals
      }, data);
      return new web3_js_1.TransactionInstruction({ keys, programId, data });
    }
    exports2.createBurnCheckedInstruction = createBurnCheckedInstruction;
    function decodeBurnCheckedInstruction(instruction, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      if (!instruction.programId.equals(programId))
        throw new errors_js_1.TokenInvalidInstructionProgramError();
      if (instruction.data.length !== exports2.burnCheckedInstructionData.span)
        throw new errors_js_1.TokenInvalidInstructionDataError();
      const { keys: { account, mint, owner, multiSigners }, data } = decodeBurnCheckedInstructionUnchecked(instruction);
      if (data.instruction !== types_js_1.TokenInstruction.BurnChecked)
        throw new errors_js_1.TokenInvalidInstructionTypeError();
      if (!account || !mint || !owner)
        throw new errors_js_1.TokenInvalidInstructionKeysError();
      return {
        programId,
        keys: {
          account,
          mint,
          owner,
          multiSigners
        },
        data
      };
    }
    exports2.decodeBurnCheckedInstruction = decodeBurnCheckedInstruction;
    function decodeBurnCheckedInstructionUnchecked({ programId, keys: [account, mint, owner, ...multiSigners], data }) {
      return {
        programId,
        keys: {
          account,
          mint,
          owner,
          multiSigners
        },
        data: exports2.burnCheckedInstructionData.decode(data)
      };
    }
    exports2.decodeBurnCheckedInstructionUnchecked = decodeBurnCheckedInstructionUnchecked;
  }
});

// node_modules/@solana/spl-token/lib/cjs/actions/burnChecked.js
var require_burnChecked2 = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/actions/burnChecked.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.burnChecked = void 0;
    var web3_js_1 = require("@solana/web3.js");
    var constants_js_1 = require_constants();
    var burnChecked_js_1 = require_burnChecked();
    var internal_js_1 = require_internal2();
    function burnChecked(connection, payer, account, mint, owner, amount, decimals, multiSigners = [], confirmOptions, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      return __awaiter(this, void 0, void 0, function* () {
        const [ownerPublicKey, signers] = (0, internal_js_1.getSigners)(owner, multiSigners);
        const transaction = new web3_js_1.Transaction().add((0, burnChecked_js_1.createBurnCheckedInstruction)(account, mint, ownerPublicKey, amount, decimals, multiSigners, programId));
        return yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer, ...signers], confirmOptions);
      });
    }
    exports2.burnChecked = burnChecked;
  }
});

// node_modules/@solana/spl-token/lib/cjs/instructions/closeAccount.js
var require_closeAccount = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/instructions/closeAccount.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.decodeCloseAccountInstructionUnchecked = exports2.decodeCloseAccountInstruction = exports2.createCloseAccountInstruction = exports2.closeAccountInstructionData = void 0;
    var buffer_layout_1 = require_Layout();
    var web3_js_1 = require("@solana/web3.js");
    var constants_js_1 = require_constants();
    var errors_js_1 = require_errors();
    var internal_js_1 = require_internal();
    var types_js_1 = require_types();
    exports2.closeAccountInstructionData = (0, buffer_layout_1.struct)([(0, buffer_layout_1.u8)("instruction")]);
    function createCloseAccountInstruction2(account, destination, authority, multiSigners = [], programId = constants_js_1.TOKEN_PROGRAM_ID) {
      const keys = (0, internal_js_1.addSigners)([
        { pubkey: account, isSigner: false, isWritable: true },
        { pubkey: destination, isSigner: false, isWritable: true }
      ], authority, multiSigners);
      const data = Buffer.alloc(exports2.closeAccountInstructionData.span);
      exports2.closeAccountInstructionData.encode({ instruction: types_js_1.TokenInstruction.CloseAccount }, data);
      return new web3_js_1.TransactionInstruction({ keys, programId, data });
    }
    exports2.createCloseAccountInstruction = createCloseAccountInstruction2;
    function decodeCloseAccountInstruction(instruction, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      if (!instruction.programId.equals(programId))
        throw new errors_js_1.TokenInvalidInstructionProgramError();
      if (instruction.data.length !== exports2.closeAccountInstructionData.span)
        throw new errors_js_1.TokenInvalidInstructionDataError();
      const { keys: { account, destination, authority, multiSigners }, data } = decodeCloseAccountInstructionUnchecked(instruction);
      if (data.instruction !== types_js_1.TokenInstruction.CloseAccount)
        throw new errors_js_1.TokenInvalidInstructionTypeError();
      if (!account || !destination || !authority)
        throw new errors_js_1.TokenInvalidInstructionKeysError();
      return {
        programId,
        keys: {
          account,
          destination,
          authority,
          multiSigners
        },
        data
      };
    }
    exports2.decodeCloseAccountInstruction = decodeCloseAccountInstruction;
    function decodeCloseAccountInstructionUnchecked({ programId, keys: [account, destination, authority, ...multiSigners], data }) {
      return {
        programId,
        keys: {
          account,
          destination,
          authority,
          multiSigners
        },
        data: exports2.closeAccountInstructionData.decode(data)
      };
    }
    exports2.decodeCloseAccountInstructionUnchecked = decodeCloseAccountInstructionUnchecked;
  }
});

// node_modules/@solana/spl-token/lib/cjs/actions/closeAccount.js
var require_closeAccount2 = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/actions/closeAccount.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.closeAccount = void 0;
    var web3_js_1 = require("@solana/web3.js");
    var constants_js_1 = require_constants();
    var closeAccount_js_1 = require_closeAccount();
    var internal_js_1 = require_internal2();
    function closeAccount(connection, payer, account, destination, authority, multiSigners = [], confirmOptions, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      return __awaiter(this, void 0, void 0, function* () {
        const [authorityPublicKey, signers] = (0, internal_js_1.getSigners)(authority, multiSigners);
        const transaction = new web3_js_1.Transaction().add((0, closeAccount_js_1.createCloseAccountInstruction)(account, destination, authorityPublicKey, multiSigners, programId));
        return yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer, ...signers], confirmOptions);
      });
    }
    exports2.closeAccount = closeAccount;
  }
});

// node_modules/@solana/spl-token/lib/cjs/extensions/accountType.js
var require_accountType = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/extensions/accountType.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ACCOUNT_TYPE_SIZE = exports2.AccountType = void 0;
    var AccountType2;
    (function(AccountType3) {
      AccountType3[AccountType3["Uninitialized"] = 0] = "Uninitialized";
      AccountType3[AccountType3["Mint"] = 1] = "Mint";
      AccountType3[AccountType3["Account"] = 2] = "Account";
    })(AccountType2 || (exports2.AccountType = AccountType2 = {}));
    exports2.ACCOUNT_TYPE_SIZE = 1;
  }
});

// node_modules/@solana/spl-token/lib/cjs/state/multisig.js
var require_multisig = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/state/multisig.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getMinimumBalanceForRentExemptMultisig = exports2.unpackMultisig = exports2.getMultisig = exports2.MULTISIG_SIZE = exports2.MultisigLayout = void 0;
    var buffer_layout_1 = require_Layout();
    var buffer_layout_utils_1 = require_cjs();
    var constants_js_1 = require_constants();
    var errors_js_1 = require_errors();
    exports2.MultisigLayout = (0, buffer_layout_1.struct)([
      (0, buffer_layout_1.u8)("m"),
      (0, buffer_layout_1.u8)("n"),
      (0, buffer_layout_utils_1.bool)("isInitialized"),
      (0, buffer_layout_utils_1.publicKey)("signer1"),
      (0, buffer_layout_utils_1.publicKey)("signer2"),
      (0, buffer_layout_utils_1.publicKey)("signer3"),
      (0, buffer_layout_utils_1.publicKey)("signer4"),
      (0, buffer_layout_utils_1.publicKey)("signer5"),
      (0, buffer_layout_utils_1.publicKey)("signer6"),
      (0, buffer_layout_utils_1.publicKey)("signer7"),
      (0, buffer_layout_utils_1.publicKey)("signer8"),
      (0, buffer_layout_utils_1.publicKey)("signer9"),
      (0, buffer_layout_utils_1.publicKey)("signer10"),
      (0, buffer_layout_utils_1.publicKey)("signer11")
    ]);
    exports2.MULTISIG_SIZE = exports2.MultisigLayout.span;
    function getMultisig(connection, address, commitment, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      return __awaiter(this, void 0, void 0, function* () {
        const info = yield connection.getAccountInfo(address, commitment);
        return unpackMultisig(address, info, programId);
      });
    }
    exports2.getMultisig = getMultisig;
    function unpackMultisig(address, info, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      if (!info)
        throw new errors_js_1.TokenAccountNotFoundError();
      if (!info.owner.equals(programId))
        throw new errors_js_1.TokenInvalidAccountOwnerError();
      if (info.data.length != exports2.MULTISIG_SIZE)
        throw new errors_js_1.TokenInvalidAccountSizeError();
      const multisig = exports2.MultisigLayout.decode(info.data);
      return Object.assign({ address }, multisig);
    }
    exports2.unpackMultisig = unpackMultisig;
    function getMinimumBalanceForRentExemptMultisig(connection, commitment) {
      return __awaiter(this, void 0, void 0, function* () {
        return yield connection.getMinimumBalanceForRentExemption(exports2.MULTISIG_SIZE, commitment);
      });
    }
    exports2.getMinimumBalanceForRentExemptMultisig = getMinimumBalanceForRentExemptMultisig;
  }
});

// node_modules/@solana/spl-token/lib/cjs/state/account.js
var require_account = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/state/account.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.unpackAccount = exports2.getMinimumBalanceForRentExemptAccountWithExtensions = exports2.getMinimumBalanceForRentExemptAccount = exports2.getMultipleAccounts = exports2.getAccount = exports2.ACCOUNT_SIZE = exports2.AccountLayout = exports2.AccountState = void 0;
    var buffer_layout_1 = require_Layout();
    var buffer_layout_utils_1 = require_cjs();
    var constants_js_1 = require_constants();
    var errors_js_1 = require_errors();
    var accountType_js_1 = require_accountType();
    var extensionType_js_1 = require_extensionType();
    var multisig_js_1 = require_multisig();
    var AccountState2;
    (function(AccountState3) {
      AccountState3[AccountState3["Uninitialized"] = 0] = "Uninitialized";
      AccountState3[AccountState3["Initialized"] = 1] = "Initialized";
      AccountState3[AccountState3["Frozen"] = 2] = "Frozen";
    })(AccountState2 || (exports2.AccountState = AccountState2 = {}));
    exports2.AccountLayout = (0, buffer_layout_1.struct)([
      (0, buffer_layout_utils_1.publicKey)("mint"),
      (0, buffer_layout_utils_1.publicKey)("owner"),
      (0, buffer_layout_utils_1.u64)("amount"),
      (0, buffer_layout_1.u32)("delegateOption"),
      (0, buffer_layout_utils_1.publicKey)("delegate"),
      (0, buffer_layout_1.u8)("state"),
      (0, buffer_layout_1.u32)("isNativeOption"),
      (0, buffer_layout_utils_1.u64)("isNative"),
      (0, buffer_layout_utils_1.u64)("delegatedAmount"),
      (0, buffer_layout_1.u32)("closeAuthorityOption"),
      (0, buffer_layout_utils_1.publicKey)("closeAuthority")
    ]);
    exports2.ACCOUNT_SIZE = exports2.AccountLayout.span;
    function getAccount2(connection, address, commitment, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      return __awaiter(this, void 0, void 0, function* () {
        const info = yield connection.getAccountInfo(address, commitment);
        return unpackAccount2(address, info, programId);
      });
    }
    exports2.getAccount = getAccount2;
    function getMultipleAccounts(connection, addresses, commitment, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      return __awaiter(this, void 0, void 0, function* () {
        const infos = yield connection.getMultipleAccountsInfo(addresses, commitment);
        return addresses.map((address, i) => unpackAccount2(address, infos[i], programId));
      });
    }
    exports2.getMultipleAccounts = getMultipleAccounts;
    function getMinimumBalanceForRentExemptAccount(connection, commitment) {
      return __awaiter(this, void 0, void 0, function* () {
        return yield getMinimumBalanceForRentExemptAccountWithExtensions(connection, [], commitment);
      });
    }
    exports2.getMinimumBalanceForRentExemptAccount = getMinimumBalanceForRentExemptAccount;
    function getMinimumBalanceForRentExemptAccountWithExtensions(connection, extensions, commitment) {
      return __awaiter(this, void 0, void 0, function* () {
        const accountLen = (0, extensionType_js_1.getAccountLen)(extensions);
        return yield connection.getMinimumBalanceForRentExemption(accountLen, commitment);
      });
    }
    exports2.getMinimumBalanceForRentExemptAccountWithExtensions = getMinimumBalanceForRentExemptAccountWithExtensions;
    function unpackAccount2(address, info, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      if (!info)
        throw new errors_js_1.TokenAccountNotFoundError();
      if (!info.owner.equals(programId))
        throw new errors_js_1.TokenInvalidAccountOwnerError();
      if (info.data.length < exports2.ACCOUNT_SIZE)
        throw new errors_js_1.TokenInvalidAccountSizeError();
      const rawAccount = exports2.AccountLayout.decode(info.data.slice(0, exports2.ACCOUNT_SIZE));
      let tlvData = Buffer.alloc(0);
      if (info.data.length > exports2.ACCOUNT_SIZE) {
        if (info.data.length === multisig_js_1.MULTISIG_SIZE)
          throw new errors_js_1.TokenInvalidAccountSizeError();
        if (info.data[exports2.ACCOUNT_SIZE] != accountType_js_1.AccountType.Account)
          throw new errors_js_1.TokenInvalidAccountError();
        tlvData = info.data.slice(exports2.ACCOUNT_SIZE + accountType_js_1.ACCOUNT_TYPE_SIZE);
      }
      return {
        address,
        mint: rawAccount.mint,
        owner: rawAccount.owner,
        amount: rawAccount.amount,
        delegate: rawAccount.delegateOption ? rawAccount.delegate : null,
        delegatedAmount: rawAccount.delegatedAmount,
        isInitialized: rawAccount.state !== AccountState2.Uninitialized,
        isFrozen: rawAccount.state === AccountState2.Frozen,
        isNative: !!rawAccount.isNativeOption,
        rentExemptReserve: rawAccount.isNativeOption ? rawAccount.isNative : null,
        closeAuthority: rawAccount.closeAuthorityOption ? rawAccount.closeAuthority : null,
        tlvData
      };
    }
    exports2.unpackAccount = unpackAccount2;
  }
});

// node_modules/@solana/spl-token/lib/cjs/state/mint.js
var require_mint = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/state/mint.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getAssociatedTokenAddressSync = exports2.getAssociatedTokenAddress = exports2.getMinimumBalanceForRentExemptMintWithExtensions = exports2.getMinimumBalanceForRentExemptMint = exports2.unpackMint = exports2.getMint = exports2.MINT_SIZE = exports2.MintLayout = void 0;
    var buffer_layout_1 = require_Layout();
    var buffer_layout_utils_1 = require_cjs();
    var web3_js_1 = require("@solana/web3.js");
    var constants_js_1 = require_constants();
    var errors_js_1 = require_errors();
    var accountType_js_1 = require_accountType();
    var extensionType_js_1 = require_extensionType();
    var account_js_1 = require_account();
    var multisig_js_1 = require_multisig();
    exports2.MintLayout = (0, buffer_layout_1.struct)([
      (0, buffer_layout_1.u32)("mintAuthorityOption"),
      (0, buffer_layout_utils_1.publicKey)("mintAuthority"),
      (0, buffer_layout_utils_1.u64)("supply"),
      (0, buffer_layout_1.u8)("decimals"),
      (0, buffer_layout_utils_1.bool)("isInitialized"),
      (0, buffer_layout_1.u32)("freezeAuthorityOption"),
      (0, buffer_layout_utils_1.publicKey)("freezeAuthority")
    ]);
    exports2.MINT_SIZE = exports2.MintLayout.span;
    function getMint2(connection, address, commitment, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      return __awaiter(this, void 0, void 0, function* () {
        const info = yield connection.getAccountInfo(address, commitment);
        return unpackMint2(address, info, programId);
      });
    }
    exports2.getMint = getMint2;
    function unpackMint2(address, info, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      if (!info)
        throw new errors_js_1.TokenAccountNotFoundError();
      if (!info.owner.equals(programId))
        throw new errors_js_1.TokenInvalidAccountOwnerError();
      if (info.data.length < exports2.MINT_SIZE)
        throw new errors_js_1.TokenInvalidAccountSizeError();
      const rawMint = exports2.MintLayout.decode(info.data.slice(0, exports2.MINT_SIZE));
      let tlvData = Buffer.alloc(0);
      if (info.data.length > exports2.MINT_SIZE) {
        if (info.data.length <= account_js_1.ACCOUNT_SIZE)
          throw new errors_js_1.TokenInvalidAccountSizeError();
        if (info.data.length === multisig_js_1.MULTISIG_SIZE)
          throw new errors_js_1.TokenInvalidAccountSizeError();
        if (info.data[account_js_1.ACCOUNT_SIZE] != accountType_js_1.AccountType.Mint)
          throw new errors_js_1.TokenInvalidMintError();
        tlvData = info.data.slice(account_js_1.ACCOUNT_SIZE + accountType_js_1.ACCOUNT_TYPE_SIZE);
      }
      return {
        address,
        mintAuthority: rawMint.mintAuthorityOption ? rawMint.mintAuthority : null,
        supply: rawMint.supply,
        decimals: rawMint.decimals,
        isInitialized: rawMint.isInitialized,
        freezeAuthority: rawMint.freezeAuthorityOption ? rawMint.freezeAuthority : null,
        tlvData
      };
    }
    exports2.unpackMint = unpackMint2;
    function getMinimumBalanceForRentExemptMint(connection, commitment) {
      return __awaiter(this, void 0, void 0, function* () {
        return yield getMinimumBalanceForRentExemptMintWithExtensions(connection, [], commitment);
      });
    }
    exports2.getMinimumBalanceForRentExemptMint = getMinimumBalanceForRentExemptMint;
    function getMinimumBalanceForRentExemptMintWithExtensions(connection, extensions, commitment) {
      return __awaiter(this, void 0, void 0, function* () {
        const mintLen = (0, extensionType_js_1.getMintLen)(extensions);
        return yield connection.getMinimumBalanceForRentExemption(mintLen, commitment);
      });
    }
    exports2.getMinimumBalanceForRentExemptMintWithExtensions = getMinimumBalanceForRentExemptMintWithExtensions;
    function getAssociatedTokenAddress(mint, owner, allowOwnerOffCurve = false, programId = constants_js_1.TOKEN_PROGRAM_ID, associatedTokenProgramId = constants_js_1.ASSOCIATED_TOKEN_PROGRAM_ID) {
      return __awaiter(this, void 0, void 0, function* () {
        if (!allowOwnerOffCurve && !web3_js_1.PublicKey.isOnCurve(owner.toBuffer()))
          throw new errors_js_1.TokenOwnerOffCurveError();
        const [address] = yield web3_js_1.PublicKey.findProgramAddress([owner.toBuffer(), programId.toBuffer(), mint.toBuffer()], associatedTokenProgramId);
        return address;
      });
    }
    exports2.getAssociatedTokenAddress = getAssociatedTokenAddress;
    function getAssociatedTokenAddressSync2(mint, owner, allowOwnerOffCurve = false, programId = constants_js_1.TOKEN_PROGRAM_ID, associatedTokenProgramId = constants_js_1.ASSOCIATED_TOKEN_PROGRAM_ID) {
      if (!allowOwnerOffCurve && !web3_js_1.PublicKey.isOnCurve(owner.toBuffer()))
        throw new errors_js_1.TokenOwnerOffCurveError();
      const [address] = web3_js_1.PublicKey.findProgramAddressSync([owner.toBuffer(), programId.toBuffer(), mint.toBuffer()], associatedTokenProgramId);
      return address;
    }
    exports2.getAssociatedTokenAddressSync = getAssociatedTokenAddressSync2;
  }
});

// node_modules/@solana/spl-token/lib/cjs/extensions/cpiGuard/instructions.js
var require_instructions = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/extensions/cpiGuard/instructions.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createDisableCpiGuardInstruction = exports2.createEnableCpiGuardInstruction = exports2.cpiGuardInstructionData = exports2.CpiGuardInstruction = void 0;
    var buffer_layout_1 = require_Layout();
    var web3_js_1 = require("@solana/web3.js");
    var constants_js_1 = require_constants();
    var errors_js_1 = require_errors();
    var internal_js_1 = require_internal();
    var types_js_1 = require_types();
    var CpiGuardInstruction;
    (function(CpiGuardInstruction2) {
      CpiGuardInstruction2[CpiGuardInstruction2["Enable"] = 0] = "Enable";
      CpiGuardInstruction2[CpiGuardInstruction2["Disable"] = 1] = "Disable";
    })(CpiGuardInstruction || (exports2.CpiGuardInstruction = CpiGuardInstruction = {}));
    exports2.cpiGuardInstructionData = (0, buffer_layout_1.struct)([(0, buffer_layout_1.u8)("instruction"), (0, buffer_layout_1.u8)("cpiGuardInstruction")]);
    function createEnableCpiGuardInstruction(account, authority, multiSigners = [], programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
      return createCpiGuardInstruction(CpiGuardInstruction.Enable, account, authority, multiSigners, programId);
    }
    exports2.createEnableCpiGuardInstruction = createEnableCpiGuardInstruction;
    function createDisableCpiGuardInstruction(account, authority, multiSigners = [], programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
      return createCpiGuardInstruction(CpiGuardInstruction.Disable, account, authority, multiSigners, programId);
    }
    exports2.createDisableCpiGuardInstruction = createDisableCpiGuardInstruction;
    function createCpiGuardInstruction(cpiGuardInstruction, account, authority, multiSigners, programId) {
      if (!(0, constants_js_1.programSupportsExtensions)(programId)) {
        throw new errors_js_1.TokenUnsupportedInstructionError();
      }
      const keys = (0, internal_js_1.addSigners)([{ pubkey: account, isSigner: false, isWritable: true }], authority, multiSigners);
      const data = Buffer.alloc(exports2.cpiGuardInstructionData.span);
      exports2.cpiGuardInstructionData.encode({
        instruction: types_js_1.TokenInstruction.CpiGuardExtension,
        cpiGuardInstruction
      }, data);
      return new web3_js_1.TransactionInstruction({ keys, programId, data });
    }
  }
});

// node_modules/@solana/spl-token/lib/cjs/extensions/cpiGuard/actions.js
var require_actions = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/extensions/cpiGuard/actions.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.disableCpiGuard = exports2.enableCpiGuard = void 0;
    var web3_js_1 = require("@solana/web3.js");
    var internal_js_1 = require_internal2();
    var constants_js_1 = require_constants();
    var instructions_js_1 = require_instructions();
    function enableCpiGuard(connection, payer, account, owner, multiSigners = [], confirmOptions, programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
      return __awaiter(this, void 0, void 0, function* () {
        const [ownerPublicKey, signers] = (0, internal_js_1.getSigners)(owner, multiSigners);
        const transaction = new web3_js_1.Transaction().add((0, instructions_js_1.createEnableCpiGuardInstruction)(account, ownerPublicKey, signers, programId));
        return yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer, ...signers], confirmOptions);
      });
    }
    exports2.enableCpiGuard = enableCpiGuard;
    function disableCpiGuard(connection, payer, account, owner, multiSigners = [], confirmOptions, programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
      return __awaiter(this, void 0, void 0, function* () {
        const [ownerPublicKey, signers] = (0, internal_js_1.getSigners)(owner, multiSigners);
        const transaction = new web3_js_1.Transaction().add((0, instructions_js_1.createDisableCpiGuardInstruction)(account, ownerPublicKey, signers, programId));
        return yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer, ...signers], confirmOptions);
      });
    }
    exports2.disableCpiGuard = disableCpiGuard;
  }
});

// node_modules/@solana/spl-token/lib/cjs/extensions/cpiGuard/state.js
var require_state = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/extensions/cpiGuard/state.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getCpiGuard = exports2.CPI_GUARD_SIZE = exports2.CpiGuardLayout = void 0;
    var buffer_layout_1 = require_Layout();
    var buffer_layout_utils_1 = require_cjs();
    var extensionType_js_1 = require_extensionType();
    exports2.CpiGuardLayout = (0, buffer_layout_1.struct)([(0, buffer_layout_utils_1.bool)("lockCpi")]);
    exports2.CPI_GUARD_SIZE = exports2.CpiGuardLayout.span;
    function getCpiGuard(account) {
      const extensionData = (0, extensionType_js_1.getExtensionData)(extensionType_js_1.ExtensionType.CpiGuard, account.tlvData);
      if (extensionData !== null) {
        return exports2.CpiGuardLayout.decode(extensionData);
      } else {
        return null;
      }
    }
    exports2.getCpiGuard = getCpiGuard;
  }
});

// node_modules/@solana/spl-token/lib/cjs/extensions/cpiGuard/index.js
var require_cpiGuard = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/extensions/cpiGuard/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_actions(), exports2);
    __exportStar(require_instructions(), exports2);
    __exportStar(require_state(), exports2);
  }
});

// node_modules/@solana/spl-token/lib/cjs/extensions/defaultAccountState/instructions.js
var require_instructions2 = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/extensions/defaultAccountState/instructions.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createUpdateDefaultAccountStateInstruction = exports2.createInitializeDefaultAccountStateInstruction = exports2.defaultAccountStateInstructionData = exports2.DefaultAccountStateInstruction = void 0;
    var buffer_layout_1 = require_Layout();
    var web3_js_1 = require("@solana/web3.js");
    var constants_js_1 = require_constants();
    var errors_js_1 = require_errors();
    var internal_js_1 = require_internal();
    var types_js_1 = require_types();
    var DefaultAccountStateInstruction;
    (function(DefaultAccountStateInstruction2) {
      DefaultAccountStateInstruction2[DefaultAccountStateInstruction2["Initialize"] = 0] = "Initialize";
      DefaultAccountStateInstruction2[DefaultAccountStateInstruction2["Update"] = 1] = "Update";
    })(DefaultAccountStateInstruction || (exports2.DefaultAccountStateInstruction = DefaultAccountStateInstruction = {}));
    exports2.defaultAccountStateInstructionData = (0, buffer_layout_1.struct)([
      (0, buffer_layout_1.u8)("instruction"),
      (0, buffer_layout_1.u8)("defaultAccountStateInstruction"),
      (0, buffer_layout_1.u8)("accountState")
    ]);
    function createInitializeDefaultAccountStateInstruction(mint, accountState, programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
      if (!(0, constants_js_1.programSupportsExtensions)(programId)) {
        throw new errors_js_1.TokenUnsupportedInstructionError();
      }
      const keys = [{ pubkey: mint, isSigner: false, isWritable: true }];
      const data = Buffer.alloc(exports2.defaultAccountStateInstructionData.span);
      exports2.defaultAccountStateInstructionData.encode({
        instruction: types_js_1.TokenInstruction.DefaultAccountStateExtension,
        defaultAccountStateInstruction: DefaultAccountStateInstruction.Initialize,
        accountState
      }, data);
      return new web3_js_1.TransactionInstruction({ keys, programId, data });
    }
    exports2.createInitializeDefaultAccountStateInstruction = createInitializeDefaultAccountStateInstruction;
    function createUpdateDefaultAccountStateInstruction(mint, accountState, freezeAuthority, multiSigners = [], programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
      if (!(0, constants_js_1.programSupportsExtensions)(programId)) {
        throw new errors_js_1.TokenUnsupportedInstructionError();
      }
      const keys = (0, internal_js_1.addSigners)([{ pubkey: mint, isSigner: false, isWritable: true }], freezeAuthority, multiSigners);
      const data = Buffer.alloc(exports2.defaultAccountStateInstructionData.span);
      exports2.defaultAccountStateInstructionData.encode({
        instruction: types_js_1.TokenInstruction.DefaultAccountStateExtension,
        defaultAccountStateInstruction: DefaultAccountStateInstruction.Update,
        accountState
      }, data);
      return new web3_js_1.TransactionInstruction({ keys, programId, data });
    }
    exports2.createUpdateDefaultAccountStateInstruction = createUpdateDefaultAccountStateInstruction;
  }
});

// node_modules/@solana/spl-token/lib/cjs/extensions/defaultAccountState/actions.js
var require_actions2 = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/extensions/defaultAccountState/actions.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.updateDefaultAccountState = exports2.initializeDefaultAccountState = void 0;
    var web3_js_1 = require("@solana/web3.js");
    var internal_js_1 = require_internal2();
    var constants_js_1 = require_constants();
    var instructions_js_1 = require_instructions2();
    function initializeDefaultAccountState(connection, payer, mint, state, confirmOptions, programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
      return __awaiter(this, void 0, void 0, function* () {
        const transaction = new web3_js_1.Transaction().add((0, instructions_js_1.createInitializeDefaultAccountStateInstruction)(mint, state, programId));
        return yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer], confirmOptions);
      });
    }
    exports2.initializeDefaultAccountState = initializeDefaultAccountState;
    function updateDefaultAccountState(connection, payer, mint, state, freezeAuthority, multiSigners = [], confirmOptions, programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
      return __awaiter(this, void 0, void 0, function* () {
        const [freezeAuthorityPublicKey, signers] = (0, internal_js_1.getSigners)(freezeAuthority, multiSigners);
        const transaction = new web3_js_1.Transaction().add((0, instructions_js_1.createUpdateDefaultAccountStateInstruction)(mint, state, freezeAuthorityPublicKey, signers, programId));
        return yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer, ...signers], confirmOptions);
      });
    }
    exports2.updateDefaultAccountState = updateDefaultAccountState;
  }
});

// node_modules/@solana/spl-token/lib/cjs/extensions/defaultAccountState/state.js
var require_state2 = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/extensions/defaultAccountState/state.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getDefaultAccountState = exports2.DEFAULT_ACCOUNT_STATE_SIZE = exports2.DefaultAccountStateLayout = void 0;
    var buffer_layout_1 = require_Layout();
    var extensionType_js_1 = require_extensionType();
    exports2.DefaultAccountStateLayout = (0, buffer_layout_1.struct)([(0, buffer_layout_1.u8)("state")]);
    exports2.DEFAULT_ACCOUNT_STATE_SIZE = exports2.DefaultAccountStateLayout.span;
    function getDefaultAccountState(mint) {
      const extensionData = (0, extensionType_js_1.getExtensionData)(extensionType_js_1.ExtensionType.DefaultAccountState, mint.tlvData);
      if (extensionData !== null) {
        return exports2.DefaultAccountStateLayout.decode(extensionData);
      } else {
        return null;
      }
    }
    exports2.getDefaultAccountState = getDefaultAccountState;
  }
});

// node_modules/@solana/spl-token/lib/cjs/extensions/defaultAccountState/index.js
var require_defaultAccountState = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/extensions/defaultAccountState/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_actions2(), exports2);
    __exportStar(require_instructions2(), exports2);
    __exportStar(require_state2(), exports2);
  }
});

// node_modules/@solana/spl-token/lib/cjs/extensions/immutableOwner.js
var require_immutableOwner = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/extensions/immutableOwner.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getImmutableOwner = exports2.IMMUTABLE_OWNER_SIZE = exports2.ImmutableOwnerLayout = void 0;
    var buffer_layout_1 = require_Layout();
    var extensionType_js_1 = require_extensionType();
    exports2.ImmutableOwnerLayout = (0, buffer_layout_1.struct)([]);
    exports2.IMMUTABLE_OWNER_SIZE = exports2.ImmutableOwnerLayout.span;
    function getImmutableOwner(account) {
      const extensionData = (0, extensionType_js_1.getExtensionData)(extensionType_js_1.ExtensionType.ImmutableOwner, account.tlvData);
      if (extensionData !== null) {
        return exports2.ImmutableOwnerLayout.decode(extensionData);
      } else {
        return null;
      }
    }
    exports2.getImmutableOwner = getImmutableOwner;
  }
});

// node_modules/@solana/spl-token/lib/cjs/extensions/interestBearingMint/state.js
var require_state3 = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/extensions/interestBearingMint/state.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getInterestBearingMintConfigState = exports2.INTEREST_BEARING_MINT_CONFIG_STATE_SIZE = exports2.InterestBearingMintConfigStateLayout = void 0;
    var buffer_layout_1 = require_Layout();
    var buffer_layout_utils_1 = require_cjs();
    var extensionType_js_1 = require_extensionType();
    exports2.InterestBearingMintConfigStateLayout = (0, buffer_layout_1.struct)([
      (0, buffer_layout_utils_1.publicKey)("rateAuthority"),
      (0, buffer_layout_1.ns64)("initializationTimestamp"),
      (0, buffer_layout_1.s16)("preUpdateAverageRate"),
      (0, buffer_layout_1.ns64)("lastUpdateTimestamp"),
      (0, buffer_layout_1.s16)("currentRate")
    ]);
    exports2.INTEREST_BEARING_MINT_CONFIG_STATE_SIZE = exports2.InterestBearingMintConfigStateLayout.span;
    function getInterestBearingMintConfigState(mint) {
      const extensionData = (0, extensionType_js_1.getExtensionData)(extensionType_js_1.ExtensionType.InterestBearingConfig, mint.tlvData);
      if (extensionData !== null) {
        return exports2.InterestBearingMintConfigStateLayout.decode(extensionData);
      }
      return null;
    }
    exports2.getInterestBearingMintConfigState = getInterestBearingMintConfigState;
  }
});

// node_modules/@solana/spl-token/lib/cjs/extensions/memoTransfer/instructions.js
var require_instructions3 = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/extensions/memoTransfer/instructions.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createDisableRequiredMemoTransfersInstruction = exports2.createEnableRequiredMemoTransfersInstruction = exports2.memoTransferInstructionData = exports2.MemoTransferInstruction = void 0;
    var buffer_layout_1 = require_Layout();
    var web3_js_1 = require("@solana/web3.js");
    var constants_js_1 = require_constants();
    var errors_js_1 = require_errors();
    var internal_js_1 = require_internal();
    var types_js_1 = require_types();
    var MemoTransferInstruction;
    (function(MemoTransferInstruction2) {
      MemoTransferInstruction2[MemoTransferInstruction2["Enable"] = 0] = "Enable";
      MemoTransferInstruction2[MemoTransferInstruction2["Disable"] = 1] = "Disable";
    })(MemoTransferInstruction || (exports2.MemoTransferInstruction = MemoTransferInstruction = {}));
    exports2.memoTransferInstructionData = (0, buffer_layout_1.struct)([
      (0, buffer_layout_1.u8)("instruction"),
      (0, buffer_layout_1.u8)("memoTransferInstruction")
    ]);
    function createEnableRequiredMemoTransfersInstruction(account, authority, multiSigners = [], programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
      return createMemoTransferInstruction(MemoTransferInstruction.Enable, account, authority, multiSigners, programId);
    }
    exports2.createEnableRequiredMemoTransfersInstruction = createEnableRequiredMemoTransfersInstruction;
    function createDisableRequiredMemoTransfersInstruction(account, authority, multiSigners = [], programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
      return createMemoTransferInstruction(MemoTransferInstruction.Disable, account, authority, multiSigners, programId);
    }
    exports2.createDisableRequiredMemoTransfersInstruction = createDisableRequiredMemoTransfersInstruction;
    function createMemoTransferInstruction(memoTransferInstruction, account, authority, multiSigners, programId) {
      if (!(0, constants_js_1.programSupportsExtensions)(programId)) {
        throw new errors_js_1.TokenUnsupportedInstructionError();
      }
      const keys = (0, internal_js_1.addSigners)([{ pubkey: account, isSigner: false, isWritable: true }], authority, multiSigners);
      const data = Buffer.alloc(exports2.memoTransferInstructionData.span);
      exports2.memoTransferInstructionData.encode({
        instruction: types_js_1.TokenInstruction.MemoTransferExtension,
        memoTransferInstruction
      }, data);
      return new web3_js_1.TransactionInstruction({ keys, programId, data });
    }
  }
});

// node_modules/@solana/spl-token/lib/cjs/extensions/memoTransfer/actions.js
var require_actions3 = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/extensions/memoTransfer/actions.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.disableRequiredMemoTransfers = exports2.enableRequiredMemoTransfers = void 0;
    var web3_js_1 = require("@solana/web3.js");
    var internal_js_1 = require_internal2();
    var constants_js_1 = require_constants();
    var instructions_js_1 = require_instructions3();
    function enableRequiredMemoTransfers(connection, payer, account, owner, multiSigners = [], confirmOptions, programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
      return __awaiter(this, void 0, void 0, function* () {
        const [ownerPublicKey, signers] = (0, internal_js_1.getSigners)(owner, multiSigners);
        const transaction = new web3_js_1.Transaction().add((0, instructions_js_1.createEnableRequiredMemoTransfersInstruction)(account, ownerPublicKey, signers, programId));
        return yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer, ...signers], confirmOptions);
      });
    }
    exports2.enableRequiredMemoTransfers = enableRequiredMemoTransfers;
    function disableRequiredMemoTransfers(connection, payer, account, owner, multiSigners = [], confirmOptions, programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
      return __awaiter(this, void 0, void 0, function* () {
        const [ownerPublicKey, signers] = (0, internal_js_1.getSigners)(owner, multiSigners);
        const transaction = new web3_js_1.Transaction().add((0, instructions_js_1.createDisableRequiredMemoTransfersInstruction)(account, ownerPublicKey, signers, programId));
        return yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer, ...signers], confirmOptions);
      });
    }
    exports2.disableRequiredMemoTransfers = disableRequiredMemoTransfers;
  }
});

// node_modules/@solana/spl-token/lib/cjs/extensions/memoTransfer/state.js
var require_state4 = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/extensions/memoTransfer/state.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getMemoTransfer = exports2.MEMO_TRANSFER_SIZE = exports2.MemoTransferLayout = void 0;
    var buffer_layout_1 = require_Layout();
    var buffer_layout_utils_1 = require_cjs();
    var extensionType_js_1 = require_extensionType();
    exports2.MemoTransferLayout = (0, buffer_layout_1.struct)([(0, buffer_layout_utils_1.bool)("requireIncomingTransferMemos")]);
    exports2.MEMO_TRANSFER_SIZE = exports2.MemoTransferLayout.span;
    function getMemoTransfer(account) {
      const extensionData = (0, extensionType_js_1.getExtensionData)(extensionType_js_1.ExtensionType.MemoTransfer, account.tlvData);
      if (extensionData !== null) {
        return exports2.MemoTransferLayout.decode(extensionData);
      } else {
        return null;
      }
    }
    exports2.getMemoTransfer = getMemoTransfer;
  }
});

// node_modules/@solana/spl-token/lib/cjs/extensions/memoTransfer/index.js
var require_memoTransfer = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/extensions/memoTransfer/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_actions3(), exports2);
    __exportStar(require_instructions3(), exports2);
    __exportStar(require_state4(), exports2);
  }
});

// node_modules/@solana/spl-token/lib/cjs/extensions/metadataPointer/state.js
var require_state5 = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/extensions/metadataPointer/state.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getMetadataPointerState = exports2.METADATA_POINTER_SIZE = exports2.MetadataPointerLayout = void 0;
    var buffer_layout_1 = require_Layout();
    var buffer_layout_utils_1 = require_cjs();
    var web3_js_1 = require("@solana/web3.js");
    var extensionType_js_1 = require_extensionType();
    exports2.MetadataPointerLayout = (0, buffer_layout_1.struct)([
      (0, buffer_layout_utils_1.publicKey)("authority"),
      (0, buffer_layout_utils_1.publicKey)("metadataAddress")
    ]);
    exports2.METADATA_POINTER_SIZE = exports2.MetadataPointerLayout.span;
    function getMetadataPointerState(mint) {
      const extensionData = (0, extensionType_js_1.getExtensionData)(extensionType_js_1.ExtensionType.MetadataPointer, mint.tlvData);
      if (extensionData !== null) {
        const { authority, metadataAddress } = exports2.MetadataPointerLayout.decode(extensionData);
        return {
          authority: authority.equals(web3_js_1.PublicKey.default) ? null : authority,
          metadataAddress: metadataAddress.equals(web3_js_1.PublicKey.default) ? null : metadataAddress
        };
      } else {
        return null;
      }
    }
    exports2.getMetadataPointerState = getMetadataPointerState;
  }
});

// node_modules/@solana/spl-token/lib/cjs/extensions/mintCloseAuthority.js
var require_mintCloseAuthority = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/extensions/mintCloseAuthority.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getMintCloseAuthority = exports2.MINT_CLOSE_AUTHORITY_SIZE = exports2.MintCloseAuthorityLayout = void 0;
    var buffer_layout_1 = require_Layout();
    var buffer_layout_utils_1 = require_cjs();
    var extensionType_js_1 = require_extensionType();
    exports2.MintCloseAuthorityLayout = (0, buffer_layout_1.struct)([(0, buffer_layout_utils_1.publicKey)("closeAuthority")]);
    exports2.MINT_CLOSE_AUTHORITY_SIZE = exports2.MintCloseAuthorityLayout.span;
    function getMintCloseAuthority(mint) {
      const extensionData = (0, extensionType_js_1.getExtensionData)(extensionType_js_1.ExtensionType.MintCloseAuthority, mint.tlvData);
      if (extensionData !== null) {
        return exports2.MintCloseAuthorityLayout.decode(extensionData);
      } else {
        return null;
      }
    }
    exports2.getMintCloseAuthority = getMintCloseAuthority;
  }
});

// node_modules/@solana/spl-token/lib/cjs/extensions/nonTransferable.js
var require_nonTransferable = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/extensions/nonTransferable.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getNonTransferableAccount = exports2.getNonTransferable = exports2.NON_TRANSFERABLE_ACCOUNT_SIZE = exports2.NON_TRANSFERABLE_SIZE = exports2.NonTransferableLayout = void 0;
    var buffer_layout_1 = require_Layout();
    var extensionType_js_1 = require_extensionType();
    exports2.NonTransferableLayout = (0, buffer_layout_1.struct)([]);
    exports2.NON_TRANSFERABLE_SIZE = exports2.NonTransferableLayout.span;
    exports2.NON_TRANSFERABLE_ACCOUNT_SIZE = exports2.NonTransferableLayout.span;
    function getNonTransferable(mint) {
      const extensionData = (0, extensionType_js_1.getExtensionData)(extensionType_js_1.ExtensionType.NonTransferable, mint.tlvData);
      if (extensionData !== null) {
        return exports2.NonTransferableLayout.decode(extensionData);
      } else {
        return null;
      }
    }
    exports2.getNonTransferable = getNonTransferable;
    function getNonTransferableAccount(account) {
      const extensionData = (0, extensionType_js_1.getExtensionData)(extensionType_js_1.ExtensionType.NonTransferableAccount, account.tlvData);
      if (extensionData !== null) {
        return exports2.NonTransferableLayout.decode(extensionData);
      } else {
        return null;
      }
    }
    exports2.getNonTransferableAccount = getNonTransferableAccount;
  }
});

// node_modules/@solana/spl-token/lib/cjs/extensions/permanentDelegate.js
var require_permanentDelegate = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/extensions/permanentDelegate.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getPermanentDelegate = exports2.PERMANENT_DELEGATE_SIZE = exports2.PermanentDelegateLayout = void 0;
    var buffer_layout_1 = require_Layout();
    var buffer_layout_utils_1 = require_cjs();
    var extensionType_js_1 = require_extensionType();
    exports2.PermanentDelegateLayout = (0, buffer_layout_1.struct)([(0, buffer_layout_utils_1.publicKey)("delegate")]);
    exports2.PERMANENT_DELEGATE_SIZE = exports2.PermanentDelegateLayout.span;
    function getPermanentDelegate(mint) {
      const extensionData = (0, extensionType_js_1.getExtensionData)(extensionType_js_1.ExtensionType.PermanentDelegate, mint.tlvData);
      if (extensionData !== null) {
        return exports2.PermanentDelegateLayout.decode(extensionData);
      } else {
        return null;
      }
    }
    exports2.getPermanentDelegate = getPermanentDelegate;
  }
});

// node_modules/@solana/spl-token/lib/cjs/extensions/transferFee/instructions.js
var require_instructions4 = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/extensions/transferFee/instructions.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.decodeHarvestWithheldTokensToMintInstructionUnchecked = exports2.decodeHarvestWithheldTokensToMintInstruction = exports2.createHarvestWithheldTokensToMintInstruction = exports2.harvestWithheldTokensToMintInstructionData = exports2.decodeWithdrawWithheldTokensFromAccountsInstructionUnchecked = exports2.decodeWithdrawWithheldTokensFromAccountsInstruction = exports2.createWithdrawWithheldTokensFromAccountsInstruction = exports2.withdrawWithheldTokensFromAccountsInstructionData = exports2.decodeWithdrawWithheldTokensFromMintInstructionUnchecked = exports2.decodeWithdrawWithheldTokensFromMintInstruction = exports2.createWithdrawWithheldTokensFromMintInstruction = exports2.withdrawWithheldTokensFromMintInstructionData = exports2.decodeTransferCheckedWithFeeInstructionUnchecked = exports2.decodeTransferCheckedWithFeeInstruction = exports2.createTransferCheckedWithFeeInstruction = exports2.transferCheckedWithFeeInstructionData = exports2.decodeInitializeTransferFeeConfigInstructionUnchecked = exports2.decodeInitializeTransferFeeConfigInstruction = exports2.createInitializeTransferFeeConfigInstruction = exports2.initializeTransferFeeConfigInstructionData = exports2.TransferFeeInstruction = void 0;
    var buffer_layout_1 = require_Layout();
    var buffer_layout_utils_1 = require_cjs();
    var web3_js_1 = require("@solana/web3.js");
    var constants_js_1 = require_constants();
    var errors_js_1 = require_errors();
    var internal_js_1 = require_internal();
    var types_js_1 = require_types();
    var TransferFeeInstruction;
    (function(TransferFeeInstruction2) {
      TransferFeeInstruction2[TransferFeeInstruction2["InitializeTransferFeeConfig"] = 0] = "InitializeTransferFeeConfig";
      TransferFeeInstruction2[TransferFeeInstruction2["TransferCheckedWithFee"] = 1] = "TransferCheckedWithFee";
      TransferFeeInstruction2[TransferFeeInstruction2["WithdrawWithheldTokensFromMint"] = 2] = "WithdrawWithheldTokensFromMint";
      TransferFeeInstruction2[TransferFeeInstruction2["WithdrawWithheldTokensFromAccounts"] = 3] = "WithdrawWithheldTokensFromAccounts";
      TransferFeeInstruction2[TransferFeeInstruction2["HarvestWithheldTokensToMint"] = 4] = "HarvestWithheldTokensToMint";
      TransferFeeInstruction2[TransferFeeInstruction2["SetTransferFee"] = 5] = "SetTransferFee";
    })(TransferFeeInstruction || (exports2.TransferFeeInstruction = TransferFeeInstruction = {}));
    exports2.initializeTransferFeeConfigInstructionData = (0, buffer_layout_1.struct)([
      (0, buffer_layout_1.u8)("instruction"),
      (0, buffer_layout_1.u8)("transferFeeInstruction"),
      (0, buffer_layout_1.u8)("transferFeeConfigAuthorityOption"),
      (0, buffer_layout_utils_1.publicKey)("transferFeeConfigAuthority"),
      (0, buffer_layout_1.u8)("withdrawWithheldAuthorityOption"),
      (0, buffer_layout_utils_1.publicKey)("withdrawWithheldAuthority"),
      (0, buffer_layout_1.u16)("transferFeeBasisPoints"),
      (0, buffer_layout_utils_1.u64)("maximumFee")
    ]);
    function createInitializeTransferFeeConfigInstruction(mint, transferFeeConfigAuthority, withdrawWithheldAuthority, transferFeeBasisPoints, maximumFee, programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
      if (!(0, constants_js_1.programSupportsExtensions)(programId)) {
        throw new errors_js_1.TokenUnsupportedInstructionError();
      }
      const keys = [{ pubkey: mint, isSigner: false, isWritable: true }];
      const data = Buffer.alloc(exports2.initializeTransferFeeConfigInstructionData.span);
      exports2.initializeTransferFeeConfigInstructionData.encode({
        instruction: types_js_1.TokenInstruction.TransferFeeExtension,
        transferFeeInstruction: TransferFeeInstruction.InitializeTransferFeeConfig,
        transferFeeConfigAuthorityOption: transferFeeConfigAuthority ? 1 : 0,
        transferFeeConfigAuthority: transferFeeConfigAuthority || new web3_js_1.PublicKey(0),
        withdrawWithheldAuthorityOption: withdrawWithheldAuthority ? 1 : 0,
        withdrawWithheldAuthority: withdrawWithheldAuthority || new web3_js_1.PublicKey(0),
        transferFeeBasisPoints,
        maximumFee
      }, data);
      return new web3_js_1.TransactionInstruction({ keys, programId, data });
    }
    exports2.createInitializeTransferFeeConfigInstruction = createInitializeTransferFeeConfigInstruction;
    function decodeInitializeTransferFeeConfigInstruction(instruction, programId) {
      if (!instruction.programId.equals(programId))
        throw new errors_js_1.TokenInvalidInstructionProgramError();
      if (instruction.data.length !== exports2.initializeTransferFeeConfigInstructionData.span)
        throw new errors_js_1.TokenInvalidInstructionDataError();
      const { keys: { mint }, data } = decodeInitializeTransferFeeConfigInstructionUnchecked(instruction);
      if (data.instruction !== types_js_1.TokenInstruction.TransferFeeExtension || data.transferFeeInstruction !== TransferFeeInstruction.InitializeTransferFeeConfig)
        throw new errors_js_1.TokenInvalidInstructionTypeError();
      if (!mint)
        throw new errors_js_1.TokenInvalidInstructionKeysError();
      return {
        programId,
        keys: {
          mint
        },
        data
      };
    }
    exports2.decodeInitializeTransferFeeConfigInstruction = decodeInitializeTransferFeeConfigInstruction;
    function decodeInitializeTransferFeeConfigInstructionUnchecked({ programId, keys: [mint], data }) {
      const { instruction, transferFeeInstruction, transferFeeConfigAuthorityOption, transferFeeConfigAuthority, withdrawWithheldAuthorityOption, withdrawWithheldAuthority, transferFeeBasisPoints, maximumFee } = exports2.initializeTransferFeeConfigInstructionData.decode(data);
      return {
        programId,
        keys: {
          mint
        },
        data: {
          instruction,
          transferFeeInstruction,
          transferFeeConfigAuthority: transferFeeConfigAuthorityOption ? transferFeeConfigAuthority : null,
          withdrawWithheldAuthority: withdrawWithheldAuthorityOption ? withdrawWithheldAuthority : null,
          transferFeeBasisPoints,
          maximumFee
        }
      };
    }
    exports2.decodeInitializeTransferFeeConfigInstructionUnchecked = decodeInitializeTransferFeeConfigInstructionUnchecked;
    exports2.transferCheckedWithFeeInstructionData = (0, buffer_layout_1.struct)([
      (0, buffer_layout_1.u8)("instruction"),
      (0, buffer_layout_1.u8)("transferFeeInstruction"),
      (0, buffer_layout_utils_1.u64)("amount"),
      (0, buffer_layout_1.u8)("decimals"),
      (0, buffer_layout_utils_1.u64)("fee")
    ]);
    function createTransferCheckedWithFeeInstruction(source, mint, destination, authority, amount, decimals, fee, multiSigners = [], programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
      if (!(0, constants_js_1.programSupportsExtensions)(programId)) {
        throw new errors_js_1.TokenUnsupportedInstructionError();
      }
      const data = Buffer.alloc(exports2.transferCheckedWithFeeInstructionData.span);
      exports2.transferCheckedWithFeeInstructionData.encode({
        instruction: types_js_1.TokenInstruction.TransferFeeExtension,
        transferFeeInstruction: TransferFeeInstruction.TransferCheckedWithFee,
        amount,
        decimals,
        fee
      }, data);
      const keys = (0, internal_js_1.addSigners)([
        { pubkey: source, isSigner: false, isWritable: true },
        { pubkey: mint, isSigner: false, isWritable: false },
        { pubkey: destination, isSigner: false, isWritable: true }
      ], authority, multiSigners);
      return new web3_js_1.TransactionInstruction({ keys, programId, data });
    }
    exports2.createTransferCheckedWithFeeInstruction = createTransferCheckedWithFeeInstruction;
    function decodeTransferCheckedWithFeeInstruction(instruction, programId) {
      if (!instruction.programId.equals(programId))
        throw new errors_js_1.TokenInvalidInstructionProgramError();
      if (instruction.data.length !== exports2.transferCheckedWithFeeInstructionData.span)
        throw new errors_js_1.TokenInvalidInstructionDataError();
      const { keys: { source, mint, destination, authority, signers }, data } = decodeTransferCheckedWithFeeInstructionUnchecked(instruction);
      if (data.instruction !== types_js_1.TokenInstruction.TransferFeeExtension || data.transferFeeInstruction !== TransferFeeInstruction.TransferCheckedWithFee)
        throw new errors_js_1.TokenInvalidInstructionTypeError();
      if (!mint)
        throw new errors_js_1.TokenInvalidInstructionKeysError();
      return {
        programId,
        keys: {
          source,
          mint,
          destination,
          authority,
          signers: signers ? signers : null
        },
        data
      };
    }
    exports2.decodeTransferCheckedWithFeeInstruction = decodeTransferCheckedWithFeeInstruction;
    function decodeTransferCheckedWithFeeInstructionUnchecked({ programId, keys: [source, mint, destination, authority, ...signers], data }) {
      const { instruction, transferFeeInstruction, amount, decimals, fee } = exports2.transferCheckedWithFeeInstructionData.decode(data);
      return {
        programId,
        keys: {
          source,
          mint,
          destination,
          authority,
          signers
        },
        data: {
          instruction,
          transferFeeInstruction,
          amount,
          decimals,
          fee
        }
      };
    }
    exports2.decodeTransferCheckedWithFeeInstructionUnchecked = decodeTransferCheckedWithFeeInstructionUnchecked;
    exports2.withdrawWithheldTokensFromMintInstructionData = (0, buffer_layout_1.struct)([
      (0, buffer_layout_1.u8)("instruction"),
      (0, buffer_layout_1.u8)("transferFeeInstruction")
    ]);
    function createWithdrawWithheldTokensFromMintInstruction(mint, destination, authority, signers = [], programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
      if (!(0, constants_js_1.programSupportsExtensions)(programId)) {
        throw new errors_js_1.TokenUnsupportedInstructionError();
      }
      const data = Buffer.alloc(exports2.withdrawWithheldTokensFromMintInstructionData.span);
      exports2.withdrawWithheldTokensFromMintInstructionData.encode({
        instruction: types_js_1.TokenInstruction.TransferFeeExtension,
        transferFeeInstruction: TransferFeeInstruction.WithdrawWithheldTokensFromMint
      }, data);
      const keys = (0, internal_js_1.addSigners)([
        { pubkey: mint, isSigner: false, isWritable: true },
        { pubkey: destination, isSigner: false, isWritable: true }
      ], authority, signers);
      return new web3_js_1.TransactionInstruction({ keys, programId, data });
    }
    exports2.createWithdrawWithheldTokensFromMintInstruction = createWithdrawWithheldTokensFromMintInstruction;
    function decodeWithdrawWithheldTokensFromMintInstruction(instruction, programId) {
      if (!instruction.programId.equals(programId))
        throw new errors_js_1.TokenInvalidInstructionProgramError();
      if (instruction.data.length !== exports2.withdrawWithheldTokensFromMintInstructionData.span)
        throw new errors_js_1.TokenInvalidInstructionDataError();
      const { keys: { mint, destination, authority, signers }, data } = decodeWithdrawWithheldTokensFromMintInstructionUnchecked(instruction);
      if (data.instruction !== types_js_1.TokenInstruction.TransferFeeExtension || data.transferFeeInstruction !== TransferFeeInstruction.WithdrawWithheldTokensFromMint)
        throw new errors_js_1.TokenInvalidInstructionTypeError();
      if (!mint)
        throw new errors_js_1.TokenInvalidInstructionKeysError();
      return {
        programId,
        keys: {
          mint,
          destination,
          authority,
          signers: signers ? signers : null
        },
        data
      };
    }
    exports2.decodeWithdrawWithheldTokensFromMintInstruction = decodeWithdrawWithheldTokensFromMintInstruction;
    function decodeWithdrawWithheldTokensFromMintInstructionUnchecked({ programId, keys: [mint, destination, authority, ...signers], data }) {
      const { instruction, transferFeeInstruction } = exports2.withdrawWithheldTokensFromMintInstructionData.decode(data);
      return {
        programId,
        keys: {
          mint,
          destination,
          authority,
          signers
        },
        data: {
          instruction,
          transferFeeInstruction
        }
      };
    }
    exports2.decodeWithdrawWithheldTokensFromMintInstructionUnchecked = decodeWithdrawWithheldTokensFromMintInstructionUnchecked;
    exports2.withdrawWithheldTokensFromAccountsInstructionData = (0, buffer_layout_1.struct)([
      (0, buffer_layout_1.u8)("instruction"),
      (0, buffer_layout_1.u8)("transferFeeInstruction"),
      (0, buffer_layout_1.u8)("numTokenAccounts")
    ]);
    function createWithdrawWithheldTokensFromAccountsInstruction(mint, destination, authority, signers, sources, programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
      if (!(0, constants_js_1.programSupportsExtensions)(programId)) {
        throw new errors_js_1.TokenUnsupportedInstructionError();
      }
      const data = Buffer.alloc(exports2.withdrawWithheldTokensFromAccountsInstructionData.span);
      exports2.withdrawWithheldTokensFromAccountsInstructionData.encode({
        instruction: types_js_1.TokenInstruction.TransferFeeExtension,
        transferFeeInstruction: TransferFeeInstruction.WithdrawWithheldTokensFromAccounts,
        numTokenAccounts: sources.length
      }, data);
      const keys = (0, internal_js_1.addSigners)([
        { pubkey: mint, isSigner: false, isWritable: true },
        { pubkey: destination, isSigner: false, isWritable: true }
      ], authority, signers);
      for (const source of sources) {
        keys.push({ pubkey: source, isSigner: false, isWritable: true });
      }
      return new web3_js_1.TransactionInstruction({ keys, programId, data });
    }
    exports2.createWithdrawWithheldTokensFromAccountsInstruction = createWithdrawWithheldTokensFromAccountsInstruction;
    function decodeWithdrawWithheldTokensFromAccountsInstruction(instruction, programId) {
      if (!instruction.programId.equals(programId))
        throw new errors_js_1.TokenInvalidInstructionProgramError();
      if (instruction.data.length !== exports2.withdrawWithheldTokensFromAccountsInstructionData.span)
        throw new errors_js_1.TokenInvalidInstructionDataError();
      const { keys: { mint, destination, authority, signers, sources }, data } = decodeWithdrawWithheldTokensFromAccountsInstructionUnchecked(instruction);
      if (data.instruction !== types_js_1.TokenInstruction.TransferFeeExtension || data.transferFeeInstruction !== TransferFeeInstruction.WithdrawWithheldTokensFromAccounts)
        throw new errors_js_1.TokenInvalidInstructionTypeError();
      if (!mint)
        throw new errors_js_1.TokenInvalidInstructionKeysError();
      return {
        programId,
        keys: {
          mint,
          destination,
          authority,
          signers: signers ? signers : null,
          sources: sources ? sources : null
        },
        data
      };
    }
    exports2.decodeWithdrawWithheldTokensFromAccountsInstruction = decodeWithdrawWithheldTokensFromAccountsInstruction;
    function decodeWithdrawWithheldTokensFromAccountsInstructionUnchecked({ programId, keys, data }) {
      const { instruction, transferFeeInstruction, numTokenAccounts } = exports2.withdrawWithheldTokensFromAccountsInstructionData.decode(data);
      const [mint, destination, authority, signers, sources] = [
        keys[0],
        keys[1],
        keys[2],
        keys.slice(3, 3 + numTokenAccounts),
        keys.slice(-1 * numTokenAccounts)
      ];
      return {
        programId,
        keys: {
          mint,
          destination,
          authority,
          signers,
          sources
        },
        data: {
          instruction,
          transferFeeInstruction,
          numTokenAccounts
        }
      };
    }
    exports2.decodeWithdrawWithheldTokensFromAccountsInstructionUnchecked = decodeWithdrawWithheldTokensFromAccountsInstructionUnchecked;
    exports2.harvestWithheldTokensToMintInstructionData = (0, buffer_layout_1.struct)([
      (0, buffer_layout_1.u8)("instruction"),
      (0, buffer_layout_1.u8)("transferFeeInstruction")
    ]);
    function createHarvestWithheldTokensToMintInstruction(mint, sources, programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
      if (!(0, constants_js_1.programSupportsExtensions)(programId)) {
        throw new errors_js_1.TokenUnsupportedInstructionError();
      }
      const data = Buffer.alloc(exports2.harvestWithheldTokensToMintInstructionData.span);
      exports2.harvestWithheldTokensToMintInstructionData.encode({
        instruction: types_js_1.TokenInstruction.TransferFeeExtension,
        transferFeeInstruction: TransferFeeInstruction.HarvestWithheldTokensToMint
      }, data);
      const keys = [];
      keys.push({ pubkey: mint, isSigner: false, isWritable: true });
      for (const source of sources) {
        keys.push({ pubkey: source, isSigner: false, isWritable: true });
      }
      return new web3_js_1.TransactionInstruction({ keys, programId, data });
    }
    exports2.createHarvestWithheldTokensToMintInstruction = createHarvestWithheldTokensToMintInstruction;
    function decodeHarvestWithheldTokensToMintInstruction(instruction, programId) {
      if (!instruction.programId.equals(programId))
        throw new errors_js_1.TokenInvalidInstructionProgramError();
      if (instruction.data.length !== exports2.harvestWithheldTokensToMintInstructionData.span)
        throw new errors_js_1.TokenInvalidInstructionDataError();
      const { keys: { mint, sources }, data } = decodeHarvestWithheldTokensToMintInstructionUnchecked(instruction);
      if (data.instruction !== types_js_1.TokenInstruction.TransferFeeExtension || data.transferFeeInstruction !== TransferFeeInstruction.HarvestWithheldTokensToMint)
        throw new errors_js_1.TokenInvalidInstructionTypeError();
      if (!mint)
        throw new errors_js_1.TokenInvalidInstructionKeysError();
      return {
        programId,
        keys: {
          mint,
          sources
        },
        data
      };
    }
    exports2.decodeHarvestWithheldTokensToMintInstruction = decodeHarvestWithheldTokensToMintInstruction;
    function decodeHarvestWithheldTokensToMintInstructionUnchecked({ programId, keys: [mint, ...sources], data }) {
      const { instruction, transferFeeInstruction } = exports2.harvestWithheldTokensToMintInstructionData.decode(data);
      return {
        programId,
        keys: {
          mint,
          sources
        },
        data: {
          instruction,
          transferFeeInstruction
        }
      };
    }
    exports2.decodeHarvestWithheldTokensToMintInstructionUnchecked = decodeHarvestWithheldTokensToMintInstructionUnchecked;
  }
});

// node_modules/@solana/spl-token/lib/cjs/extensions/transferFee/actions.js
var require_actions4 = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/extensions/transferFee/actions.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.harvestWithheldTokensToMint = exports2.withdrawWithheldTokensFromAccounts = exports2.withdrawWithheldTokensFromMint = exports2.transferCheckedWithFee = void 0;
    var web3_js_1 = require("@solana/web3.js");
    var internal_js_1 = require_internal2();
    var constants_js_1 = require_constants();
    var instructions_js_1 = require_instructions4();
    function transferCheckedWithFee(connection, payer, source, mint, destination, owner, amount, decimals, fee, multiSigners = [], confirmOptions, programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
      return __awaiter(this, void 0, void 0, function* () {
        const [ownerPublicKey, signers] = (0, internal_js_1.getSigners)(owner, multiSigners);
        const transaction = new web3_js_1.Transaction().add((0, instructions_js_1.createTransferCheckedWithFeeInstruction)(source, mint, destination, ownerPublicKey, amount, decimals, fee, multiSigners, programId));
        return yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer, ...signers], confirmOptions);
      });
    }
    exports2.transferCheckedWithFee = transferCheckedWithFee;
    function withdrawWithheldTokensFromMint(connection, payer, mint, destination, authority, multiSigners = [], confirmOptions, programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
      return __awaiter(this, void 0, void 0, function* () {
        const [authorityPublicKey, signers] = (0, internal_js_1.getSigners)(authority, multiSigners);
        const transaction = new web3_js_1.Transaction().add((0, instructions_js_1.createWithdrawWithheldTokensFromMintInstruction)(mint, destination, authorityPublicKey, signers, programId));
        return yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer, ...signers], confirmOptions);
      });
    }
    exports2.withdrawWithheldTokensFromMint = withdrawWithheldTokensFromMint;
    function withdrawWithheldTokensFromAccounts(connection, payer, mint, destination, authority, multiSigners, sources, confirmOptions, programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
      return __awaiter(this, void 0, void 0, function* () {
        const [authorityPublicKey, signers] = (0, internal_js_1.getSigners)(authority, multiSigners);
        const transaction = new web3_js_1.Transaction().add((0, instructions_js_1.createWithdrawWithheldTokensFromAccountsInstruction)(mint, destination, authorityPublicKey, signers, sources, programId));
        return yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer, ...signers], confirmOptions);
      });
    }
    exports2.withdrawWithheldTokensFromAccounts = withdrawWithheldTokensFromAccounts;
    function harvestWithheldTokensToMint(connection, payer, mint, sources, confirmOptions, programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
      return __awaiter(this, void 0, void 0, function* () {
        const transaction = new web3_js_1.Transaction().add((0, instructions_js_1.createHarvestWithheldTokensToMintInstruction)(mint, sources, programId));
        return yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer], confirmOptions);
      });
    }
    exports2.harvestWithheldTokensToMint = harvestWithheldTokensToMint;
  }
});

// node_modules/@solana/spl-token/lib/cjs/extensions/transferFee/state.js
var require_state6 = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/extensions/transferFee/state.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getTransferFeeAmount = exports2.getTransferFeeConfig = exports2.TRANSFER_FEE_AMOUNT_SIZE = exports2.TransferFeeAmountLayout = exports2.calculateEpochFee = exports2.getEpochFee = exports2.TRANSFER_FEE_CONFIG_SIZE = exports2.TransferFeeConfigLayout = exports2.calculateFee = exports2.transferFeeLayout = exports2.ONE_IN_BASIS_POINTS = exports2.MAX_FEE_BASIS_POINTS = void 0;
    var buffer_layout_1 = require_Layout();
    var buffer_layout_utils_1 = require_cjs();
    var extensionType_js_1 = require_extensionType();
    exports2.MAX_FEE_BASIS_POINTS = 1e4;
    exports2.ONE_IN_BASIS_POINTS = BigInt(exports2.MAX_FEE_BASIS_POINTS);
    function transferFeeLayout2(property) {
      return (0, buffer_layout_1.struct)([(0, buffer_layout_utils_1.u64)("epoch"), (0, buffer_layout_utils_1.u64)("maximumFee"), (0, buffer_layout_1.u16)("transferFeeBasisPoints")], property);
    }
    exports2.transferFeeLayout = transferFeeLayout2;
    function calculateFee2(transferFee, preFeeAmount) {
      const transferFeeBasisPoints = transferFee.transferFeeBasisPoints;
      if (transferFeeBasisPoints === 0 || preFeeAmount === BigInt(0)) {
        return BigInt(0);
      } else {
        const numerator = preFeeAmount * BigInt(transferFeeBasisPoints);
        const rawFee = (numerator + exports2.ONE_IN_BASIS_POINTS - BigInt(1)) / exports2.ONE_IN_BASIS_POINTS;
        const fee = rawFee > transferFee.maximumFee ? transferFee.maximumFee : rawFee;
        return BigInt(fee);
      }
    }
    exports2.calculateFee = calculateFee2;
    exports2.TransferFeeConfigLayout = (0, buffer_layout_1.struct)([
      (0, buffer_layout_utils_1.publicKey)("transferFeeConfigAuthority"),
      (0, buffer_layout_utils_1.publicKey)("withdrawWithheldAuthority"),
      (0, buffer_layout_utils_1.u64)("withheldAmount"),
      transferFeeLayout2("olderTransferFee"),
      transferFeeLayout2("newerTransferFee")
    ]);
    exports2.TRANSFER_FEE_CONFIG_SIZE = exports2.TransferFeeConfigLayout.span;
    function getEpochFee2(transferFeeConfig, epoch) {
      if (epoch >= transferFeeConfig.newerTransferFee.epoch) {
        return transferFeeConfig.newerTransferFee;
      } else {
        return transferFeeConfig.olderTransferFee;
      }
    }
    exports2.getEpochFee = getEpochFee2;
    function calculateEpochFee(transferFeeConfig, epoch, preFeeAmount) {
      const transferFee = getEpochFee2(transferFeeConfig, epoch);
      return calculateFee2(transferFee, preFeeAmount);
    }
    exports2.calculateEpochFee = calculateEpochFee;
    exports2.TransferFeeAmountLayout = (0, buffer_layout_1.struct)([(0, buffer_layout_utils_1.u64)("withheldAmount")]);
    exports2.TRANSFER_FEE_AMOUNT_SIZE = exports2.TransferFeeAmountLayout.span;
    function getTransferFeeConfig2(mint) {
      const extensionData = (0, extensionType_js_1.getExtensionData)(extensionType_js_1.ExtensionType.TransferFeeConfig, mint.tlvData);
      if (extensionData !== null) {
        return exports2.TransferFeeConfigLayout.decode(extensionData);
      } else {
        return null;
      }
    }
    exports2.getTransferFeeConfig = getTransferFeeConfig2;
    function getTransferFeeAmount(account) {
      const extensionData = (0, extensionType_js_1.getExtensionData)(extensionType_js_1.ExtensionType.TransferFeeAmount, account.tlvData);
      if (extensionData !== null) {
        return exports2.TransferFeeAmountLayout.decode(extensionData);
      } else {
        return null;
      }
    }
    exports2.getTransferFeeAmount = getTransferFeeAmount;
  }
});

// node_modules/@solana/spl-token/lib/cjs/extensions/transferFee/index.js
var require_transferFee = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/extensions/transferFee/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_actions4(), exports2);
    __exportStar(require_instructions4(), exports2);
    __exportStar(require_state6(), exports2);
  }
});

// node_modules/@solana/spl-token/lib/cjs/instructions/transferChecked.js
var require_transferChecked = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/instructions/transferChecked.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.decodeTransferCheckedInstructionUnchecked = exports2.decodeTransferCheckedInstruction = exports2.createTransferCheckedInstruction = exports2.transferCheckedInstructionData = void 0;
    var buffer_layout_1 = require_Layout();
    var buffer_layout_utils_1 = require_cjs();
    var web3_js_1 = require("@solana/web3.js");
    var constants_js_1 = require_constants();
    var errors_js_1 = require_errors();
    var internal_js_1 = require_internal();
    var types_js_1 = require_types();
    exports2.transferCheckedInstructionData = (0, buffer_layout_1.struct)([
      (0, buffer_layout_1.u8)("instruction"),
      (0, buffer_layout_utils_1.u64)("amount"),
      (0, buffer_layout_1.u8)("decimals")
    ]);
    function createTransferCheckedInstruction2(source, mint, destination, owner, amount, decimals, multiSigners = [], programId = constants_js_1.TOKEN_PROGRAM_ID) {
      const keys = (0, internal_js_1.addSigners)([
        { pubkey: source, isSigner: false, isWritable: true },
        { pubkey: mint, isSigner: false, isWritable: false },
        { pubkey: destination, isSigner: false, isWritable: true }
      ], owner, multiSigners);
      const data = Buffer.alloc(exports2.transferCheckedInstructionData.span);
      exports2.transferCheckedInstructionData.encode({
        instruction: types_js_1.TokenInstruction.TransferChecked,
        amount: BigInt(amount),
        decimals
      }, data);
      return new web3_js_1.TransactionInstruction({ keys, programId, data });
    }
    exports2.createTransferCheckedInstruction = createTransferCheckedInstruction2;
    function decodeTransferCheckedInstruction(instruction, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      if (!instruction.programId.equals(programId))
        throw new errors_js_1.TokenInvalidInstructionProgramError();
      if (instruction.data.length !== exports2.transferCheckedInstructionData.span)
        throw new errors_js_1.TokenInvalidInstructionDataError();
      const { keys: { source, mint, destination, owner, multiSigners }, data } = decodeTransferCheckedInstructionUnchecked(instruction);
      if (data.instruction !== types_js_1.TokenInstruction.TransferChecked)
        throw new errors_js_1.TokenInvalidInstructionTypeError();
      if (!source || !mint || !destination || !owner)
        throw new errors_js_1.TokenInvalidInstructionKeysError();
      return {
        programId,
        keys: {
          source,
          mint,
          destination,
          owner,
          multiSigners
        },
        data
      };
    }
    exports2.decodeTransferCheckedInstruction = decodeTransferCheckedInstruction;
    function decodeTransferCheckedInstructionUnchecked({ programId, keys: [source, mint, destination, owner, ...multiSigners], data }) {
      return {
        programId,
        keys: {
          source,
          mint,
          destination,
          owner,
          multiSigners
        },
        data: exports2.transferCheckedInstructionData.decode(data)
      };
    }
    exports2.decodeTransferCheckedInstructionUnchecked = decodeTransferCheckedInstructionUnchecked;
  }
});

// node_modules/@solana/spl-token/lib/cjs/extensions/transferHook/seeds.js
var require_seeds = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/extensions/transferHook/seeds.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.unpackSeeds = void 0;
    var errors_js_1 = require_errors();
    var DISCRIMINATOR_SPAN2 = 1;
    var LITERAL_LENGTH_SPAN2 = 1;
    var INSTRUCTION_ARG_OFFSET_SPAN2 = 1;
    var INSTRUCTION_ARG_LENGTH_SPAN2 = 1;
    var ACCOUNT_KEY_INDEX_SPAN2 = 1;
    var ACCOUNT_DATA_ACCOUNT_INDEX_SPAN2 = 1;
    var ACCOUNT_DATA_OFFSET_SPAN2 = 1;
    var ACCOUNT_DATA_LENGTH_SPAN2 = 1;
    function unpackSeedLiteral2(seeds) {
      if (seeds.length < 1) {
        throw new errors_js_1.TokenTransferHookInvalidSeed();
      }
      const [length, ...rest] = seeds;
      if (rest.length < length) {
        throw new errors_js_1.TokenTransferHookInvalidSeed();
      }
      return {
        data: Buffer.from(rest.slice(0, length)),
        packedLength: DISCRIMINATOR_SPAN2 + LITERAL_LENGTH_SPAN2 + length
      };
    }
    function unpackSeedInstructionArg2(seeds, instructionData) {
      if (seeds.length < 2) {
        throw new errors_js_1.TokenTransferHookInvalidSeed();
      }
      const [index, length] = seeds;
      if (instructionData.length < length + index) {
        throw new errors_js_1.TokenTransferHookInvalidSeed();
      }
      return {
        data: instructionData.subarray(index, index + length),
        packedLength: DISCRIMINATOR_SPAN2 + INSTRUCTION_ARG_OFFSET_SPAN2 + INSTRUCTION_ARG_LENGTH_SPAN2
      };
    }
    function unpackSeedAccountKey2(seeds, previousMetas) {
      if (seeds.length < 1) {
        throw new errors_js_1.TokenTransferHookInvalidSeed();
      }
      const [index] = seeds;
      if (previousMetas.length <= index) {
        throw new errors_js_1.TokenTransferHookInvalidSeed();
      }
      return {
        data: previousMetas[index].pubkey.toBuffer(),
        packedLength: DISCRIMINATOR_SPAN2 + ACCOUNT_KEY_INDEX_SPAN2
      };
    }
    function unpackSeedAccountData2(seeds, previousMetas, connection) {
      return __awaiter(this, void 0, void 0, function* () {
        if (seeds.length < 3) {
          throw new errors_js_1.TokenTransferHookInvalidSeed();
        }
        const [accountIndex, dataIndex, length] = seeds;
        if (previousMetas.length <= accountIndex) {
          throw new errors_js_1.TokenTransferHookInvalidSeed();
        }
        const accountInfo = yield connection.getAccountInfo(previousMetas[accountIndex].pubkey);
        if (accountInfo == null) {
          throw new errors_js_1.TokenTransferHookAccountDataNotFound();
        }
        if (accountInfo.data.length < dataIndex + length) {
          throw new errors_js_1.TokenTransferHookInvalidSeed();
        }
        return {
          data: accountInfo.data.subarray(dataIndex, dataIndex + length),
          packedLength: DISCRIMINATOR_SPAN2 + ACCOUNT_DATA_ACCOUNT_INDEX_SPAN2 + ACCOUNT_DATA_OFFSET_SPAN2 + ACCOUNT_DATA_LENGTH_SPAN2
        };
      });
    }
    function unpackFirstSeed2(seeds, previousMetas, instructionData, connection) {
      return __awaiter(this, void 0, void 0, function* () {
        const [discriminator, ...rest] = seeds;
        const remaining = new Uint8Array(rest);
        switch (discriminator) {
          case 0:
            return null;
          case 1:
            return unpackSeedLiteral2(remaining);
          case 2:
            return unpackSeedInstructionArg2(remaining, instructionData);
          case 3:
            return unpackSeedAccountKey2(remaining, previousMetas);
          case 4:
            return unpackSeedAccountData2(remaining, previousMetas, connection);
          default:
            throw new errors_js_1.TokenTransferHookInvalidSeed();
        }
      });
    }
    function unpackSeeds2(seeds, previousMetas, instructionData, connection) {
      return __awaiter(this, void 0, void 0, function* () {
        const unpackedSeeds = [];
        let i = 0;
        while (i < 32) {
          const seed = yield unpackFirstSeed2(seeds.slice(i), previousMetas, instructionData, connection);
          if (seed == null) {
            break;
          }
          unpackedSeeds.push(seed.data);
          i += seed.packedLength;
        }
        return unpackedSeeds;
      });
    }
    exports2.unpackSeeds = unpackSeeds2;
  }
});

// node_modules/@solana/spl-token/lib/cjs/extensions/transferHook/state.js
var require_state7 = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/extensions/transferHook/state.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.resolveExtraAccountMeta = exports2.getExtraAccountMetas = exports2.ExtraAccountMetaAccountDataLayout = exports2.ExtraAccountMetaListLayout = exports2.ExtraAccountMetaLayout = exports2.getExtraAccountMetaAddress = exports2.getTransferHookAccount = exports2.TRANSFER_HOOK_ACCOUNT_SIZE = exports2.TransferHookAccountLayout = exports2.getTransferHook = exports2.TRANSFER_HOOK_SIZE = exports2.TransferHookLayout = void 0;
    var buffer_layout_1 = require_Layout();
    var extensionType_js_1 = require_extensionType();
    var web3_js_1 = require("@solana/web3.js");
    var buffer_layout_utils_1 = require_cjs();
    var errors_js_1 = require_errors();
    var seeds_js_1 = require_seeds();
    exports2.TransferHookLayout = (0, buffer_layout_1.struct)([(0, buffer_layout_utils_1.publicKey)("authority"), (0, buffer_layout_utils_1.publicKey)("programId")]);
    exports2.TRANSFER_HOOK_SIZE = exports2.TransferHookLayout.span;
    function getTransferHook2(mint) {
      const extensionData = (0, extensionType_js_1.getExtensionData)(extensionType_js_1.ExtensionType.TransferHook, mint.tlvData);
      if (extensionData !== null) {
        return exports2.TransferHookLayout.decode(extensionData);
      } else {
        return null;
      }
    }
    exports2.getTransferHook = getTransferHook2;
    exports2.TransferHookAccountLayout = (0, buffer_layout_1.struct)([(0, buffer_layout_utils_1.bool)("transferring")]);
    exports2.TRANSFER_HOOK_ACCOUNT_SIZE = exports2.TransferHookAccountLayout.span;
    function getTransferHookAccount(account) {
      const extensionData = (0, extensionType_js_1.getExtensionData)(extensionType_js_1.ExtensionType.TransferHookAccount, account.tlvData);
      if (extensionData !== null) {
        return exports2.TransferHookAccountLayout.decode(extensionData);
      } else {
        return null;
      }
    }
    exports2.getTransferHookAccount = getTransferHookAccount;
    function getExtraAccountMetaAddress2(mint, programId) {
      const seeds = [Buffer.from("extra-account-metas"), mint.toBuffer()];
      return web3_js_1.PublicKey.findProgramAddressSync(seeds, programId)[0];
    }
    exports2.getExtraAccountMetaAddress = getExtraAccountMetaAddress2;
    exports2.ExtraAccountMetaLayout = (0, buffer_layout_1.struct)([
      (0, buffer_layout_1.u8)("discriminator"),
      (0, buffer_layout_1.blob)(32, "addressConfig"),
      (0, buffer_layout_utils_1.bool)("isSigner"),
      (0, buffer_layout_utils_1.bool)("isWritable")
    ]);
    exports2.ExtraAccountMetaListLayout = (0, buffer_layout_1.struct)([
      (0, buffer_layout_1.u32)("count"),
      (0, buffer_layout_1.seq)(exports2.ExtraAccountMetaLayout, (0, buffer_layout_1.greedy)(exports2.ExtraAccountMetaLayout.span), "extraAccounts")
    ]);
    exports2.ExtraAccountMetaAccountDataLayout = (0, buffer_layout_1.struct)([
      (0, buffer_layout_utils_1.u64)("instructionDiscriminator"),
      (0, buffer_layout_1.u32)("length"),
      exports2.ExtraAccountMetaListLayout.replicate("extraAccountsList")
    ]);
    function getExtraAccountMetas2(account) {
      const extraAccountsList = exports2.ExtraAccountMetaAccountDataLayout.decode(account.data).extraAccountsList;
      return extraAccountsList.extraAccounts.slice(0, extraAccountsList.count);
    }
    exports2.getExtraAccountMetas = getExtraAccountMetas2;
    function resolveExtraAccountMeta2(connection, extraMeta, previousMetas, instructionData, transferHookProgramId) {
      return __awaiter(this, void 0, void 0, function* () {
        if (extraMeta.discriminator === 0) {
          return {
            pubkey: new web3_js_1.PublicKey(extraMeta.addressConfig),
            isSigner: extraMeta.isSigner,
            isWritable: extraMeta.isWritable
          };
        }
        let programId = web3_js_1.PublicKey.default;
        if (extraMeta.discriminator === 1) {
          programId = transferHookProgramId;
        } else {
          const accountIndex = extraMeta.discriminator - (1 << 7);
          if (previousMetas.length <= accountIndex) {
            throw new errors_js_1.TokenTransferHookAccountNotFound();
          }
          programId = previousMetas[accountIndex].pubkey;
        }
        const seeds = yield (0, seeds_js_1.unpackSeeds)(extraMeta.addressConfig, previousMetas, instructionData, connection);
        const pubkey = web3_js_1.PublicKey.findProgramAddressSync(seeds, programId)[0];
        return { pubkey, isSigner: extraMeta.isSigner, isWritable: extraMeta.isWritable };
      });
    }
    exports2.resolveExtraAccountMeta = resolveExtraAccountMeta2;
  }
});

// node_modules/@solana/spl-token/lib/cjs/extensions/transferHook/instructions.js
var require_instructions5 = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/extensions/transferHook/instructions.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createTransferCheckedWithFeeAndTransferHookInstruction = exports2.createTransferCheckedWithTransferHookInstruction = exports2.addExtraAccountsToInstruction = exports2.createUpdateTransferHookInstruction = exports2.updateTransferHookInstructionData = exports2.createInitializeTransferHookInstruction = exports2.initializeTransferHookInstructionData = exports2.TransferHookInstruction = void 0;
    var buffer_layout_1 = require_Layout();
    var web3_js_1 = require("@solana/web3.js");
    var constants_js_1 = require_constants();
    var errors_js_1 = require_errors();
    var internal_js_1 = require_internal();
    var types_js_1 = require_types();
    var buffer_layout_utils_1 = require_cjs();
    var transferChecked_js_1 = require_transferChecked();
    var instructions_js_1 = require_instructions4();
    var mint_js_1 = require_mint();
    var state_js_1 = require_state7();
    var TransferHookInstruction2;
    (function(TransferHookInstruction3) {
      TransferHookInstruction3[TransferHookInstruction3["Initialize"] = 0] = "Initialize";
      TransferHookInstruction3[TransferHookInstruction3["Update"] = 1] = "Update";
    })(TransferHookInstruction2 || (exports2.TransferHookInstruction = TransferHookInstruction2 = {}));
    exports2.initializeTransferHookInstructionData = (0, buffer_layout_1.struct)([
      (0, buffer_layout_1.u8)("instruction"),
      (0, buffer_layout_1.u8)("transferHookInstruction"),
      (0, buffer_layout_utils_1.publicKey)("authority"),
      (0, buffer_layout_utils_1.publicKey)("transferHookProgramId")
    ]);
    function createInitializeTransferHookInstruction(mint, authority, transferHookProgramId, programId) {
      if (!(0, constants_js_1.programSupportsExtensions)(programId)) {
        throw new errors_js_1.TokenUnsupportedInstructionError();
      }
      const keys = [{ pubkey: mint, isSigner: false, isWritable: true }];
      const data = Buffer.alloc(exports2.initializeTransferHookInstructionData.span);
      exports2.initializeTransferHookInstructionData.encode({
        instruction: types_js_1.TokenInstruction.TransferHookExtension,
        transferHookInstruction: TransferHookInstruction2.Initialize,
        authority,
        transferHookProgramId
      }, data);
      return new web3_js_1.TransactionInstruction({ keys, programId, data });
    }
    exports2.createInitializeTransferHookInstruction = createInitializeTransferHookInstruction;
    exports2.updateTransferHookInstructionData = (0, buffer_layout_1.struct)([
      (0, buffer_layout_1.u8)("instruction"),
      (0, buffer_layout_1.u8)("transferHookInstruction"),
      (0, buffer_layout_utils_1.publicKey)("transferHookProgramId")
    ]);
    function createUpdateTransferHookInstruction(mint, authority, transferHookProgramId, multiSigners = [], programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
      if (!(0, constants_js_1.programSupportsExtensions)(programId)) {
        throw new errors_js_1.TokenUnsupportedInstructionError();
      }
      const keys = (0, internal_js_1.addSigners)([{ pubkey: mint, isSigner: false, isWritable: true }], authority, multiSigners);
      const data = Buffer.alloc(exports2.updateTransferHookInstructionData.span);
      exports2.updateTransferHookInstructionData.encode({
        instruction: types_js_1.TokenInstruction.TransferHookExtension,
        transferHookInstruction: TransferHookInstruction2.Update,
        transferHookProgramId
      }, data);
      return new web3_js_1.TransactionInstruction({ keys, programId, data });
    }
    exports2.createUpdateTransferHookInstruction = createUpdateTransferHookInstruction;
    function deEscalateAccountMeta2(accountMeta, accountMetas) {
      const maybeHighestPrivileges = accountMetas.filter((x) => x.pubkey === accountMeta.pubkey).reduce((acc, x) => {
        if (!acc)
          return { isSigner: x.isSigner, isWritable: x.isWritable };
        return { isSigner: acc.isSigner || x.isSigner, isWritable: acc.isWritable || x.isWritable };
      }, void 0);
      if (maybeHighestPrivileges) {
        const { isSigner, isWritable } = maybeHighestPrivileges;
        if (!isSigner && isSigner !== accountMeta.isSigner) {
          accountMeta.isSigner = false;
        }
        if (!isWritable && isWritable !== accountMeta.isWritable) {
          accountMeta.isWritable = false;
        }
      }
      return accountMeta;
    }
    function addExtraAccountsToInstruction(connection, instruction, mint, commitment, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      return __awaiter(this, void 0, void 0, function* () {
        if (!(0, constants_js_1.programSupportsExtensions)(programId)) {
          throw new errors_js_1.TokenUnsupportedInstructionError();
        }
        const mintInfo = yield (0, mint_js_1.getMint)(connection, mint, commitment, programId);
        const transferHook = (0, state_js_1.getTransferHook)(mintInfo);
        if (transferHook == null) {
          return instruction;
        }
        const extraAccountsAccount = (0, state_js_1.getExtraAccountMetaAddress)(mint, transferHook.programId);
        const extraAccountsInfo = yield connection.getAccountInfo(extraAccountsAccount, commitment);
        if (extraAccountsInfo == null) {
          return instruction;
        }
        const extraAccountMetas = (0, state_js_1.getExtraAccountMetas)(extraAccountsInfo);
        const accountMetas = instruction.keys;
        for (const extraAccountMeta of extraAccountMetas) {
          const accountMetaUnchecked = yield (0, state_js_1.resolveExtraAccountMeta)(connection, extraAccountMeta, accountMetas, instruction.data, transferHook.programId);
          const accountMeta = deEscalateAccountMeta2(accountMetaUnchecked, accountMetas);
          accountMetas.push(accountMeta);
        }
        accountMetas.push({ pubkey: transferHook.programId, isSigner: false, isWritable: false });
        accountMetas.push({ pubkey: extraAccountsAccount, isSigner: false, isWritable: false });
        return new web3_js_1.TransactionInstruction({ keys: accountMetas, programId, data: instruction.data });
      });
    }
    exports2.addExtraAccountsToInstruction = addExtraAccountsToInstruction;
    function createTransferCheckedWithTransferHookInstruction(connection, source, mint, destination, authority, amount, decimals, multiSigners = [], commitment, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      return __awaiter(this, void 0, void 0, function* () {
        const rawInstruction = (0, transferChecked_js_1.createTransferCheckedInstruction)(source, mint, destination, authority, amount, decimals, multiSigners, programId);
        const hydratedInstruction = yield addExtraAccountsToInstruction(connection, rawInstruction, mint, commitment, programId);
        return hydratedInstruction;
      });
    }
    exports2.createTransferCheckedWithTransferHookInstruction = createTransferCheckedWithTransferHookInstruction;
    function createTransferCheckedWithFeeAndTransferHookInstruction(connection, source, mint, destination, authority, amount, decimals, fee, multiSigners = [], commitment, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      return __awaiter(this, void 0, void 0, function* () {
        const rawInstruction = (0, instructions_js_1.createTransferCheckedWithFeeInstruction)(source, mint, destination, authority, amount, decimals, fee, multiSigners, programId);
        const hydratedInstruction = yield addExtraAccountsToInstruction(connection, rawInstruction, mint, commitment, programId);
        return hydratedInstruction;
      });
    }
    exports2.createTransferCheckedWithFeeAndTransferHookInstruction = createTransferCheckedWithFeeAndTransferHookInstruction;
  }
});

// node_modules/@solana/spl-token/lib/cjs/extensions/transferHook/actions.js
var require_actions5 = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/extensions/transferHook/actions.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.transferCheckedWithFeeAndTransferHook = exports2.transferCheckedWithTransferHook = exports2.updateTransferHook = exports2.initializeTransferHook = void 0;
    var web3_js_1 = require("@solana/web3.js");
    var internal_js_1 = require_internal2();
    var constants_js_1 = require_constants();
    var instructions_js_1 = require_instructions5();
    function initializeTransferHook(connection, payer, mint, authority, transferHookProgramId, confirmOptions, programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
      return __awaiter(this, void 0, void 0, function* () {
        const transaction = new web3_js_1.Transaction().add((0, instructions_js_1.createInitializeTransferHookInstruction)(mint, authority, transferHookProgramId, programId));
        return yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer], confirmOptions);
      });
    }
    exports2.initializeTransferHook = initializeTransferHook;
    function updateTransferHook(connection, payer, mint, transferHookProgramId, authority, multiSigners = [], confirmOptions, programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
      return __awaiter(this, void 0, void 0, function* () {
        const [authorityPublicKey, signers] = (0, internal_js_1.getSigners)(authority, multiSigners);
        const transaction = new web3_js_1.Transaction().add((0, instructions_js_1.createUpdateTransferHookInstruction)(mint, authorityPublicKey, transferHookProgramId, signers, programId));
        return yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer, ...signers], confirmOptions);
      });
    }
    exports2.updateTransferHook = updateTransferHook;
    function transferCheckedWithTransferHook(connection, payer, source, mint, destination, authority, amount, decimals, multiSigners = [], confirmOptions, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      return __awaiter(this, void 0, void 0, function* () {
        const [authorityPublicKey, signers] = (0, internal_js_1.getSigners)(authority, multiSigners);
        const transaction = new web3_js_1.Transaction().add(yield (0, instructions_js_1.createTransferCheckedWithTransferHookInstruction)(connection, source, mint, destination, authorityPublicKey, amount, decimals, signers, confirmOptions === null || confirmOptions === void 0 ? void 0 : confirmOptions.commitment, programId));
        return yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer, ...signers], confirmOptions);
      });
    }
    exports2.transferCheckedWithTransferHook = transferCheckedWithTransferHook;
    function transferCheckedWithFeeAndTransferHook(connection, payer, source, mint, destination, authority, amount, decimals, fee, multiSigners = [], confirmOptions, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      return __awaiter(this, void 0, void 0, function* () {
        const [authorityPublicKey, signers] = (0, internal_js_1.getSigners)(authority, multiSigners);
        const transaction = new web3_js_1.Transaction().add(yield (0, instructions_js_1.createTransferCheckedWithFeeAndTransferHookInstruction)(connection, source, mint, destination, authorityPublicKey, amount, decimals, fee, signers, confirmOptions === null || confirmOptions === void 0 ? void 0 : confirmOptions.commitment, programId));
        return yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer, ...signers], confirmOptions);
      });
    }
    exports2.transferCheckedWithFeeAndTransferHook = transferCheckedWithFeeAndTransferHook;
  }
});

// node_modules/@solana/spl-token/lib/cjs/extensions/transferHook/index.js
var require_transferHook = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/extensions/transferHook/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_actions5(), exports2);
    __exportStar(require_instructions5(), exports2);
    __exportStar(require_seeds(), exports2);
    __exportStar(require_state7(), exports2);
  }
});

// node_modules/@solana/spl-token/lib/cjs/extensions/extensionType.js
var require_extensionType = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/extensions/extensionType.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getNewAccountLenForExtensionLen = exports2.getAccountLenForMint = exports2.getExtensionTypes = exports2.getExtensionData = exports2.getAccountLen = exports2.getMintLen = exports2.getAccountTypeOfMintType = exports2.isAccountExtension = exports2.isMintExtension = exports2.getTypeLen = exports2.LENGTH_SIZE = exports2.TYPE_SIZE = exports2.ExtensionType = void 0;
    var account_js_1 = require_account();
    var mint_js_1 = require_mint();
    var multisig_js_1 = require_multisig();
    var accountType_js_1 = require_accountType();
    var index_js_1 = require_cpiGuard();
    var index_js_2 = require_defaultAccountState();
    var immutableOwner_js_1 = require_immutableOwner();
    var state_js_1 = require_state3();
    var index_js_3 = require_memoTransfer();
    var state_js_2 = require_state5();
    var mintCloseAuthority_js_1 = require_mintCloseAuthority();
    var nonTransferable_js_1 = require_nonTransferable();
    var permanentDelegate_js_1 = require_permanentDelegate();
    var index_js_4 = require_transferFee();
    var index_js_5 = require_transferHook();
    var constants_js_1 = require_constants();
    var ExtensionType2;
    (function(ExtensionType3) {
      ExtensionType3[ExtensionType3["Uninitialized"] = 0] = "Uninitialized";
      ExtensionType3[ExtensionType3["TransferFeeConfig"] = 1] = "TransferFeeConfig";
      ExtensionType3[ExtensionType3["TransferFeeAmount"] = 2] = "TransferFeeAmount";
      ExtensionType3[ExtensionType3["MintCloseAuthority"] = 3] = "MintCloseAuthority";
      ExtensionType3[ExtensionType3["ConfidentialTransferMint"] = 4] = "ConfidentialTransferMint";
      ExtensionType3[ExtensionType3["ConfidentialTransferAccount"] = 5] = "ConfidentialTransferAccount";
      ExtensionType3[ExtensionType3["DefaultAccountState"] = 6] = "DefaultAccountState";
      ExtensionType3[ExtensionType3["ImmutableOwner"] = 7] = "ImmutableOwner";
      ExtensionType3[ExtensionType3["MemoTransfer"] = 8] = "MemoTransfer";
      ExtensionType3[ExtensionType3["NonTransferable"] = 9] = "NonTransferable";
      ExtensionType3[ExtensionType3["InterestBearingConfig"] = 10] = "InterestBearingConfig";
      ExtensionType3[ExtensionType3["CpiGuard"] = 11] = "CpiGuard";
      ExtensionType3[ExtensionType3["PermanentDelegate"] = 12] = "PermanentDelegate";
      ExtensionType3[ExtensionType3["NonTransferableAccount"] = 13] = "NonTransferableAccount";
      ExtensionType3[ExtensionType3["TransferHook"] = 14] = "TransferHook";
      ExtensionType3[ExtensionType3["TransferHookAccount"] = 15] = "TransferHookAccount";
      ExtensionType3[ExtensionType3["MetadataPointer"] = 18] = "MetadataPointer";
      ExtensionType3[ExtensionType3["TokenMetadata"] = 19] = "TokenMetadata";
    })(ExtensionType2 || (exports2.ExtensionType = ExtensionType2 = {}));
    exports2.TYPE_SIZE = 2;
    exports2.LENGTH_SIZE = 2;
    function addTypeAndLengthToLen2(len) {
      return len + exports2.TYPE_SIZE + exports2.LENGTH_SIZE;
    }
    function isVariableLengthExtension(e) {
      switch (e) {
        case ExtensionType2.TokenMetadata:
          return true;
        default:
          return false;
      }
    }
    function getTypeLen(e) {
      switch (e) {
        case ExtensionType2.Uninitialized:
          return 0;
        case ExtensionType2.TransferFeeConfig:
          return index_js_4.TRANSFER_FEE_CONFIG_SIZE;
        case ExtensionType2.TransferFeeAmount:
          return index_js_4.TRANSFER_FEE_AMOUNT_SIZE;
        case ExtensionType2.MintCloseAuthority:
          return mintCloseAuthority_js_1.MINT_CLOSE_AUTHORITY_SIZE;
        case ExtensionType2.ConfidentialTransferMint:
          return 97;
        case ExtensionType2.ConfidentialTransferAccount:
          return 286;
        case ExtensionType2.CpiGuard:
          return index_js_1.CPI_GUARD_SIZE;
        case ExtensionType2.DefaultAccountState:
          return index_js_2.DEFAULT_ACCOUNT_STATE_SIZE;
        case ExtensionType2.ImmutableOwner:
          return immutableOwner_js_1.IMMUTABLE_OWNER_SIZE;
        case ExtensionType2.MemoTransfer:
          return index_js_3.MEMO_TRANSFER_SIZE;
        case ExtensionType2.MetadataPointer:
          return state_js_2.METADATA_POINTER_SIZE;
        case ExtensionType2.NonTransferable:
          return nonTransferable_js_1.NON_TRANSFERABLE_SIZE;
        case ExtensionType2.InterestBearingConfig:
          return state_js_1.INTEREST_BEARING_MINT_CONFIG_STATE_SIZE;
        case ExtensionType2.PermanentDelegate:
          return permanentDelegate_js_1.PERMANENT_DELEGATE_SIZE;
        case ExtensionType2.NonTransferableAccount:
          return nonTransferable_js_1.NON_TRANSFERABLE_ACCOUNT_SIZE;
        case ExtensionType2.TransferHook:
          return index_js_5.TRANSFER_HOOK_SIZE;
        case ExtensionType2.TransferHookAccount:
          return index_js_5.TRANSFER_HOOK_ACCOUNT_SIZE;
        case ExtensionType2.TokenMetadata:
          throw Error(`Cannot get type length for variable extension type: ${e}`);
        default:
          throw Error(`Unknown extension type: ${e}`);
      }
    }
    exports2.getTypeLen = getTypeLen;
    function isMintExtension(e) {
      switch (e) {
        case ExtensionType2.TransferFeeConfig:
        case ExtensionType2.MintCloseAuthority:
        case ExtensionType2.ConfidentialTransferMint:
        case ExtensionType2.DefaultAccountState:
        case ExtensionType2.NonTransferable:
        case ExtensionType2.InterestBearingConfig:
        case ExtensionType2.PermanentDelegate:
        case ExtensionType2.TransferHook:
        case ExtensionType2.MetadataPointer:
        case ExtensionType2.TokenMetadata:
          return true;
        case ExtensionType2.Uninitialized:
        case ExtensionType2.TransferFeeAmount:
        case ExtensionType2.ConfidentialTransferAccount:
        case ExtensionType2.ImmutableOwner:
        case ExtensionType2.MemoTransfer:
        case ExtensionType2.CpiGuard:
        case ExtensionType2.NonTransferableAccount:
        case ExtensionType2.TransferHookAccount:
          return false;
        default:
          throw Error(`Unknown extension type: ${e}`);
      }
    }
    exports2.isMintExtension = isMintExtension;
    function isAccountExtension(e) {
      switch (e) {
        case ExtensionType2.TransferFeeAmount:
        case ExtensionType2.ConfidentialTransferAccount:
        case ExtensionType2.ImmutableOwner:
        case ExtensionType2.MemoTransfer:
        case ExtensionType2.CpiGuard:
        case ExtensionType2.NonTransferableAccount:
        case ExtensionType2.TransferHookAccount:
          return true;
        case ExtensionType2.Uninitialized:
        case ExtensionType2.TransferFeeConfig:
        case ExtensionType2.MintCloseAuthority:
        case ExtensionType2.ConfidentialTransferMint:
        case ExtensionType2.DefaultAccountState:
        case ExtensionType2.NonTransferable:
        case ExtensionType2.InterestBearingConfig:
        case ExtensionType2.PermanentDelegate:
        case ExtensionType2.TransferHook:
        case ExtensionType2.MetadataPointer:
        case ExtensionType2.TokenMetadata:
          return false;
        default:
          throw Error(`Unknown extension type: ${e}`);
      }
    }
    exports2.isAccountExtension = isAccountExtension;
    function getAccountTypeOfMintType(e) {
      switch (e) {
        case ExtensionType2.TransferFeeConfig:
          return ExtensionType2.TransferFeeAmount;
        case ExtensionType2.ConfidentialTransferMint:
          return ExtensionType2.ConfidentialTransferAccount;
        case ExtensionType2.NonTransferable:
          return ExtensionType2.NonTransferableAccount;
        case ExtensionType2.TransferHook:
          return ExtensionType2.TransferHookAccount;
        case ExtensionType2.TransferFeeAmount:
        case ExtensionType2.ConfidentialTransferAccount:
        case ExtensionType2.CpiGuard:
        case ExtensionType2.DefaultAccountState:
        case ExtensionType2.ImmutableOwner:
        case ExtensionType2.MemoTransfer:
        case ExtensionType2.MintCloseAuthority:
        case ExtensionType2.MetadataPointer:
        case ExtensionType2.TokenMetadata:
        case ExtensionType2.Uninitialized:
        case ExtensionType2.InterestBearingConfig:
        case ExtensionType2.PermanentDelegate:
        case ExtensionType2.NonTransferableAccount:
        case ExtensionType2.TransferHookAccount:
          return ExtensionType2.Uninitialized;
      }
    }
    exports2.getAccountTypeOfMintType = getAccountTypeOfMintType;
    function getLen(extensionTypes, baseSize, variableLengthExtensions = {}) {
      if (extensionTypes.length === 0 && Object.keys(variableLengthExtensions).length === 0) {
        return baseSize;
      } else {
        const accountLength = account_js_1.ACCOUNT_SIZE + accountType_js_1.ACCOUNT_TYPE_SIZE + extensionTypes.filter((element, i) => i === extensionTypes.indexOf(element)).map((element) => addTypeAndLengthToLen2(getTypeLen(element))).reduce((a, b) => a + b, 0) + Object.entries(variableLengthExtensions).map(([extension, len]) => {
          if (!isVariableLengthExtension(Number(extension))) {
            throw Error(`Extension ${extension} is not variable length`);
          }
          return addTypeAndLengthToLen2(len);
        }).reduce((a, b) => a + b, 0);
        if (accountLength === multisig_js_1.MULTISIG_SIZE) {
          return accountLength + exports2.TYPE_SIZE;
        } else {
          return accountLength;
        }
      }
    }
    function getMintLen(extensionTypes, variableLengthExtensions = {}) {
      return getLen(extensionTypes, mint_js_1.MINT_SIZE, variableLengthExtensions);
    }
    exports2.getMintLen = getMintLen;
    function getAccountLen(extensionTypes) {
      return getLen(extensionTypes, account_js_1.ACCOUNT_SIZE);
    }
    exports2.getAccountLen = getAccountLen;
    function getExtensionData2(extension, tlvData) {
      let extensionTypeIndex = 0;
      while (addTypeAndLengthToLen2(extensionTypeIndex) <= tlvData.length) {
        const entryType = tlvData.readUInt16LE(extensionTypeIndex);
        const entryLength = tlvData.readUInt16LE(extensionTypeIndex + exports2.TYPE_SIZE);
        const typeIndex = addTypeAndLengthToLen2(extensionTypeIndex);
        if (entryType == extension) {
          return tlvData.slice(typeIndex, typeIndex + entryLength);
        }
        extensionTypeIndex = typeIndex + entryLength;
      }
      return null;
    }
    exports2.getExtensionData = getExtensionData2;
    function getExtensionTypes(tlvData) {
      const extensionTypes = [];
      let extensionTypeIndex = 0;
      while (extensionTypeIndex < tlvData.length) {
        const entryType = tlvData.readUInt16LE(extensionTypeIndex);
        extensionTypes.push(entryType);
        const entryLength = tlvData.readUInt16LE(extensionTypeIndex + exports2.TYPE_SIZE);
        extensionTypeIndex += addTypeAndLengthToLen2(entryLength);
      }
      return extensionTypes;
    }
    exports2.getExtensionTypes = getExtensionTypes;
    function getAccountLenForMint(mint) {
      const extensionTypes = getExtensionTypes(mint.tlvData);
      const accountExtensions = extensionTypes.map(getAccountTypeOfMintType);
      return getAccountLen(accountExtensions);
    }
    exports2.getAccountLenForMint = getAccountLenForMint;
    function getNewAccountLenForExtensionLen(info, address, extensionType, extensionLen, programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
      const mint = (0, mint_js_1.unpackMint)(address, info, programId);
      const extensionData = getExtensionData2(extensionType, mint.tlvData);
      const currentExtensionLen = extensionData ? addTypeAndLengthToLen2(extensionData.length) : 0;
      const newExtensionLen = addTypeAndLengthToLen2(extensionLen);
      return info.data.length + newExtensionLen - currentExtensionLen;
    }
    exports2.getNewAccountLenForExtensionLen = getNewAccountLenForExtensionLen;
  }
});

// node_modules/@solana/spl-token/lib/cjs/instructions/initializeAccount.js
var require_initializeAccount = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/instructions/initializeAccount.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.decodeInitializeAccountInstructionUnchecked = exports2.decodeInitializeAccountInstruction = exports2.createInitializeAccountInstruction = exports2.initializeAccountInstructionData = void 0;
    var buffer_layout_1 = require_Layout();
    var web3_js_1 = require("@solana/web3.js");
    var constants_js_1 = require_constants();
    var errors_js_1 = require_errors();
    var types_js_1 = require_types();
    exports2.initializeAccountInstructionData = (0, buffer_layout_1.struct)([(0, buffer_layout_1.u8)("instruction")]);
    function createInitializeAccountInstruction(account, mint, owner, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      const keys = [
        { pubkey: account, isSigner: false, isWritable: true },
        { pubkey: mint, isSigner: false, isWritable: false },
        { pubkey: owner, isSigner: false, isWritable: false },
        { pubkey: web3_js_1.SYSVAR_RENT_PUBKEY, isSigner: false, isWritable: false }
      ];
      const data = Buffer.alloc(exports2.initializeAccountInstructionData.span);
      exports2.initializeAccountInstructionData.encode({ instruction: types_js_1.TokenInstruction.InitializeAccount }, data);
      return new web3_js_1.TransactionInstruction({ keys, programId, data });
    }
    exports2.createInitializeAccountInstruction = createInitializeAccountInstruction;
    function decodeInitializeAccountInstruction(instruction, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      if (!instruction.programId.equals(programId))
        throw new errors_js_1.TokenInvalidInstructionProgramError();
      if (instruction.data.length !== exports2.initializeAccountInstructionData.span)
        throw new errors_js_1.TokenInvalidInstructionDataError();
      const { keys: { account, mint, owner, rent }, data } = decodeInitializeAccountInstructionUnchecked(instruction);
      if (data.instruction !== types_js_1.TokenInstruction.InitializeAccount)
        throw new errors_js_1.TokenInvalidInstructionTypeError();
      if (!account || !mint || !owner || !rent)
        throw new errors_js_1.TokenInvalidInstructionKeysError();
      return {
        programId,
        keys: {
          account,
          mint,
          owner,
          rent
        },
        data
      };
    }
    exports2.decodeInitializeAccountInstruction = decodeInitializeAccountInstruction;
    function decodeInitializeAccountInstructionUnchecked({ programId, keys: [account, mint, owner, rent], data }) {
      return {
        programId,
        keys: {
          account,
          mint,
          owner,
          rent
        },
        data: exports2.initializeAccountInstructionData.decode(data)
      };
    }
    exports2.decodeInitializeAccountInstructionUnchecked = decodeInitializeAccountInstructionUnchecked;
  }
});

// node_modules/@solana/spl-token/lib/cjs/instructions/associatedTokenAccount.js
var require_associatedTokenAccount = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/instructions/associatedTokenAccount.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createRecoverNestedInstruction = exports2.createAssociatedTokenAccountIdempotentInstruction = exports2.createAssociatedTokenAccountInstruction = void 0;
    var web3_js_1 = require("@solana/web3.js");
    var constants_js_1 = require_constants();
    function createAssociatedTokenAccountInstruction(payer, associatedToken, owner, mint, programId = constants_js_1.TOKEN_PROGRAM_ID, associatedTokenProgramId = constants_js_1.ASSOCIATED_TOKEN_PROGRAM_ID) {
      return buildAssociatedTokenAccountInstruction2(payer, associatedToken, owner, mint, Buffer.alloc(0), programId, associatedTokenProgramId);
    }
    exports2.createAssociatedTokenAccountInstruction = createAssociatedTokenAccountInstruction;
    function createAssociatedTokenAccountIdempotentInstruction2(payer, associatedToken, owner, mint, programId = constants_js_1.TOKEN_PROGRAM_ID, associatedTokenProgramId = constants_js_1.ASSOCIATED_TOKEN_PROGRAM_ID) {
      return buildAssociatedTokenAccountInstruction2(payer, associatedToken, owner, mint, Buffer.from([1]), programId, associatedTokenProgramId);
    }
    exports2.createAssociatedTokenAccountIdempotentInstruction = createAssociatedTokenAccountIdempotentInstruction2;
    function buildAssociatedTokenAccountInstruction2(payer, associatedToken, owner, mint, instructionData, programId = constants_js_1.TOKEN_PROGRAM_ID, associatedTokenProgramId = constants_js_1.ASSOCIATED_TOKEN_PROGRAM_ID) {
      const keys = [
        { pubkey: payer, isSigner: true, isWritable: true },
        { pubkey: associatedToken, isSigner: false, isWritable: true },
        { pubkey: owner, isSigner: false, isWritable: false },
        { pubkey: mint, isSigner: false, isWritable: false },
        { pubkey: web3_js_1.SystemProgram.programId, isSigner: false, isWritable: false },
        { pubkey: programId, isSigner: false, isWritable: false }
      ];
      return new web3_js_1.TransactionInstruction({
        keys,
        programId: associatedTokenProgramId,
        data: instructionData
      });
    }
    function createRecoverNestedInstruction(nestedAssociatedToken, nestedMint, destinationAssociatedToken, ownerAssociatedToken, ownerMint, owner, programId = constants_js_1.TOKEN_PROGRAM_ID, associatedTokenProgramId = constants_js_1.ASSOCIATED_TOKEN_PROGRAM_ID) {
      const keys = [
        { pubkey: nestedAssociatedToken, isSigner: false, isWritable: true },
        { pubkey: nestedMint, isSigner: false, isWritable: false },
        { pubkey: destinationAssociatedToken, isSigner: false, isWritable: true },
        { pubkey: ownerAssociatedToken, isSigner: false, isWritable: true },
        { pubkey: ownerMint, isSigner: false, isWritable: false },
        { pubkey: owner, isSigner: true, isWritable: true },
        { pubkey: programId, isSigner: false, isWritable: false }
      ];
      return new web3_js_1.TransactionInstruction({
        keys,
        programId: associatedTokenProgramId,
        data: Buffer.from([2])
      });
    }
    exports2.createRecoverNestedInstruction = createRecoverNestedInstruction;
  }
});

// node_modules/@solana/spl-token/lib/cjs/actions/createAssociatedTokenAccount.js
var require_createAssociatedTokenAccount = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/actions/createAssociatedTokenAccount.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createAssociatedTokenAccount = void 0;
    var web3_js_1 = require("@solana/web3.js");
    var constants_js_1 = require_constants();
    var associatedTokenAccount_js_1 = require_associatedTokenAccount();
    var mint_js_1 = require_mint();
    function createAssociatedTokenAccount(connection, payer, mint, owner, confirmOptions, programId = constants_js_1.TOKEN_PROGRAM_ID, associatedTokenProgramId = constants_js_1.ASSOCIATED_TOKEN_PROGRAM_ID) {
      return __awaiter(this, void 0, void 0, function* () {
        const associatedToken = (0, mint_js_1.getAssociatedTokenAddressSync)(mint, owner, false, programId, associatedTokenProgramId);
        const transaction = new web3_js_1.Transaction().add((0, associatedTokenAccount_js_1.createAssociatedTokenAccountInstruction)(payer.publicKey, associatedToken, owner, mint, programId, associatedTokenProgramId));
        yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer], confirmOptions);
        return associatedToken;
      });
    }
    exports2.createAssociatedTokenAccount = createAssociatedTokenAccount;
  }
});

// node_modules/@solana/spl-token/lib/cjs/actions/createAccount.js
var require_createAccount = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/actions/createAccount.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createAccount = void 0;
    var web3_js_1 = require("@solana/web3.js");
    var constants_js_1 = require_constants();
    var extensionType_js_1 = require_extensionType();
    var initializeAccount_js_1 = require_initializeAccount();
    var mint_js_1 = require_mint();
    var createAssociatedTokenAccount_js_1 = require_createAssociatedTokenAccount();
    function createAccount(connection, payer, mint, owner, keypair, confirmOptions, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      return __awaiter(this, void 0, void 0, function* () {
        if (!keypair)
          return yield (0, createAssociatedTokenAccount_js_1.createAssociatedTokenAccount)(connection, payer, mint, owner, confirmOptions, programId);
        const mintState = yield (0, mint_js_1.getMint)(connection, mint, confirmOptions === null || confirmOptions === void 0 ? void 0 : confirmOptions.commitment, programId);
        const space = (0, extensionType_js_1.getAccountLenForMint)(mintState);
        const lamports = yield connection.getMinimumBalanceForRentExemption(space);
        const transaction = new web3_js_1.Transaction().add(web3_js_1.SystemProgram.createAccount({
          fromPubkey: payer.publicKey,
          newAccountPubkey: keypair.publicKey,
          space,
          lamports,
          programId
        }), (0, initializeAccount_js_1.createInitializeAccountInstruction)(keypair.publicKey, mint, owner, programId));
        yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer, keypair], confirmOptions);
        return keypair.publicKey;
      });
    }
    exports2.createAccount = createAccount;
  }
});

// node_modules/@solana/spl-token/lib/cjs/actions/createAssociatedTokenAccountIdempotent.js
var require_createAssociatedTokenAccountIdempotent = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/actions/createAssociatedTokenAccountIdempotent.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createAssociatedTokenAccountIdempotent = void 0;
    var web3_js_1 = require("@solana/web3.js");
    var constants_js_1 = require_constants();
    var associatedTokenAccount_js_1 = require_associatedTokenAccount();
    var mint_js_1 = require_mint();
    function createAssociatedTokenAccountIdempotent(connection, payer, mint, owner, confirmOptions, programId = constants_js_1.TOKEN_PROGRAM_ID, associatedTokenProgramId = constants_js_1.ASSOCIATED_TOKEN_PROGRAM_ID) {
      return __awaiter(this, void 0, void 0, function* () {
        const associatedToken = (0, mint_js_1.getAssociatedTokenAddressSync)(mint, owner, false, programId, associatedTokenProgramId);
        const transaction = new web3_js_1.Transaction().add((0, associatedTokenAccount_js_1.createAssociatedTokenAccountIdempotentInstruction)(payer.publicKey, associatedToken, owner, mint, programId, associatedTokenProgramId));
        yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer], confirmOptions);
        return associatedToken;
      });
    }
    exports2.createAssociatedTokenAccountIdempotent = createAssociatedTokenAccountIdempotent;
  }
});

// node_modules/@solana/spl-token/lib/cjs/instructions/initializeMint2.js
var require_initializeMint2 = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/instructions/initializeMint2.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.decodeInitializeMint2InstructionUnchecked = exports2.decodeInitializeMint2Instruction = exports2.createInitializeMint2Instruction = exports2.initializeMint2InstructionData = void 0;
    var buffer_layout_1 = require_Layout();
    var buffer_layout_utils_1 = require_cjs();
    var web3_js_1 = require("@solana/web3.js");
    var constants_js_1 = require_constants();
    var errors_js_1 = require_errors();
    var types_js_1 = require_types();
    exports2.initializeMint2InstructionData = (0, buffer_layout_1.struct)([
      (0, buffer_layout_1.u8)("instruction"),
      (0, buffer_layout_1.u8)("decimals"),
      (0, buffer_layout_utils_1.publicKey)("mintAuthority"),
      (0, buffer_layout_1.u8)("freezeAuthorityOption"),
      (0, buffer_layout_utils_1.publicKey)("freezeAuthority")
    ]);
    function createInitializeMint2Instruction(mint, decimals, mintAuthority, freezeAuthority, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      const keys = [{ pubkey: mint, isSigner: false, isWritable: true }];
      const data = Buffer.alloc(exports2.initializeMint2InstructionData.span);
      exports2.initializeMint2InstructionData.encode({
        instruction: types_js_1.TokenInstruction.InitializeMint2,
        decimals,
        mintAuthority,
        freezeAuthorityOption: freezeAuthority ? 1 : 0,
        freezeAuthority: freezeAuthority || new web3_js_1.PublicKey(0)
      }, data);
      return new web3_js_1.TransactionInstruction({ keys, programId, data });
    }
    exports2.createInitializeMint2Instruction = createInitializeMint2Instruction;
    function decodeInitializeMint2Instruction(instruction, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      if (!instruction.programId.equals(programId))
        throw new errors_js_1.TokenInvalidInstructionProgramError();
      if (instruction.data.length !== exports2.initializeMint2InstructionData.span)
        throw new errors_js_1.TokenInvalidInstructionDataError();
      const { keys: { mint }, data } = decodeInitializeMint2InstructionUnchecked(instruction);
      if (data.instruction !== types_js_1.TokenInstruction.InitializeMint2)
        throw new errors_js_1.TokenInvalidInstructionTypeError();
      if (!mint)
        throw new errors_js_1.TokenInvalidInstructionKeysError();
      return {
        programId,
        keys: {
          mint
        },
        data
      };
    }
    exports2.decodeInitializeMint2Instruction = decodeInitializeMint2Instruction;
    function decodeInitializeMint2InstructionUnchecked({ programId, keys: [mint], data }) {
      const { instruction, decimals, mintAuthority, freezeAuthorityOption, freezeAuthority } = exports2.initializeMint2InstructionData.decode(data);
      return {
        programId,
        keys: {
          mint
        },
        data: {
          instruction,
          decimals,
          mintAuthority,
          freezeAuthority: freezeAuthorityOption ? freezeAuthority : null
        }
      };
    }
    exports2.decodeInitializeMint2InstructionUnchecked = decodeInitializeMint2InstructionUnchecked;
  }
});

// node_modules/@solana/spl-token/lib/cjs/actions/createMint.js
var require_createMint = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/actions/createMint.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createMint = void 0;
    var web3_js_1 = require("@solana/web3.js");
    var constants_js_1 = require_constants();
    var initializeMint2_js_1 = require_initializeMint2();
    var mint_js_1 = require_mint();
    function createMint(connection, payer, mintAuthority, freezeAuthority, decimals, keypair = web3_js_1.Keypair.generate(), confirmOptions, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      return __awaiter(this, void 0, void 0, function* () {
        const lamports = yield (0, mint_js_1.getMinimumBalanceForRentExemptMint)(connection);
        const transaction = new web3_js_1.Transaction().add(web3_js_1.SystemProgram.createAccount({
          fromPubkey: payer.publicKey,
          newAccountPubkey: keypair.publicKey,
          space: mint_js_1.MINT_SIZE,
          lamports,
          programId
        }), (0, initializeMint2_js_1.createInitializeMint2Instruction)(keypair.publicKey, decimals, mintAuthority, freezeAuthority, programId));
        yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer, keypair], confirmOptions);
        return keypair.publicKey;
      });
    }
    exports2.createMint = createMint;
  }
});

// node_modules/@solana/spl-token/lib/cjs/instructions/initializeMultisig.js
var require_initializeMultisig = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/instructions/initializeMultisig.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.decodeInitializeMultisigInstructionUnchecked = exports2.decodeInitializeMultisigInstruction = exports2.createInitializeMultisigInstruction = exports2.initializeMultisigInstructionData = void 0;
    var buffer_layout_1 = require_Layout();
    var web3_js_1 = require("@solana/web3.js");
    var constants_js_1 = require_constants();
    var errors_js_1 = require_errors();
    var types_js_1 = require_types();
    exports2.initializeMultisigInstructionData = (0, buffer_layout_1.struct)([
      (0, buffer_layout_1.u8)("instruction"),
      (0, buffer_layout_1.u8)("m")
    ]);
    function createInitializeMultisigInstruction(account, signers, m, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      const keys = [
        { pubkey: account, isSigner: false, isWritable: true },
        { pubkey: web3_js_1.SYSVAR_RENT_PUBKEY, isSigner: false, isWritable: false }
      ];
      for (const signer of signers) {
        keys.push({
          pubkey: signer instanceof web3_js_1.PublicKey ? signer : signer.publicKey,
          isSigner: false,
          isWritable: false
        });
      }
      const data = Buffer.alloc(exports2.initializeMultisigInstructionData.span);
      exports2.initializeMultisigInstructionData.encode({
        instruction: types_js_1.TokenInstruction.InitializeMultisig,
        m
      }, data);
      return new web3_js_1.TransactionInstruction({ keys, programId, data });
    }
    exports2.createInitializeMultisigInstruction = createInitializeMultisigInstruction;
    function decodeInitializeMultisigInstruction(instruction, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      if (!instruction.programId.equals(programId))
        throw new errors_js_1.TokenInvalidInstructionProgramError();
      if (instruction.data.length !== exports2.initializeMultisigInstructionData.span)
        throw new errors_js_1.TokenInvalidInstructionDataError();
      const { keys: { account, rent, signers }, data } = decodeInitializeMultisigInstructionUnchecked(instruction);
      if (data.instruction !== types_js_1.TokenInstruction.InitializeMultisig)
        throw new errors_js_1.TokenInvalidInstructionTypeError();
      if (!account || !rent || !signers.length)
        throw new errors_js_1.TokenInvalidInstructionKeysError();
      return {
        programId,
        keys: {
          account,
          rent,
          signers
        },
        data
      };
    }
    exports2.decodeInitializeMultisigInstruction = decodeInitializeMultisigInstruction;
    function decodeInitializeMultisigInstructionUnchecked({ programId, keys: [account, rent, ...signers], data }) {
      return {
        programId,
        keys: {
          account,
          rent,
          signers
        },
        data: exports2.initializeMultisigInstructionData.decode(data)
      };
    }
    exports2.decodeInitializeMultisigInstructionUnchecked = decodeInitializeMultisigInstructionUnchecked;
  }
});

// node_modules/@solana/spl-token/lib/cjs/actions/createMultisig.js
var require_createMultisig = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/actions/createMultisig.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createMultisig = void 0;
    var web3_js_1 = require("@solana/web3.js");
    var constants_js_1 = require_constants();
    var initializeMultisig_js_1 = require_initializeMultisig();
    var multisig_js_1 = require_multisig();
    function createMultisig(connection, payer, signers, m, keypair = web3_js_1.Keypair.generate(), confirmOptions, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      return __awaiter(this, void 0, void 0, function* () {
        const lamports = yield (0, multisig_js_1.getMinimumBalanceForRentExemptMultisig)(connection);
        const transaction = new web3_js_1.Transaction().add(web3_js_1.SystemProgram.createAccount({
          fromPubkey: payer.publicKey,
          newAccountPubkey: keypair.publicKey,
          space: multisig_js_1.MULTISIG_SIZE,
          lamports,
          programId
        }), (0, initializeMultisig_js_1.createInitializeMultisigInstruction)(keypair.publicKey, signers, m, programId));
        yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer, keypair], confirmOptions);
        return keypair.publicKey;
      });
    }
    exports2.createMultisig = createMultisig;
  }
});

// node_modules/@solana/spl-token/lib/cjs/instructions/createNativeMint.js
var require_createNativeMint = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/instructions/createNativeMint.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createCreateNativeMintInstruction = exports2.createNativeMintInstructionData = void 0;
    var buffer_layout_1 = require_Layout();
    var web3_js_1 = require("@solana/web3.js");
    var constants_js_1 = require_constants();
    var errors_js_1 = require_errors();
    var types_js_1 = require_types();
    exports2.createNativeMintInstructionData = (0, buffer_layout_1.struct)([(0, buffer_layout_1.u8)("instruction")]);
    function createCreateNativeMintInstruction(payer, nativeMintId = constants_js_1.NATIVE_MINT_2022, programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
      if (!(0, constants_js_1.programSupportsExtensions)(programId)) {
        throw new errors_js_1.TokenUnsupportedInstructionError();
      }
      const keys = [
        { pubkey: payer, isSigner: true, isWritable: true },
        { pubkey: nativeMintId, isSigner: false, isWritable: true },
        { pubkey: web3_js_1.SystemProgram.programId, isSigner: false, isWritable: false }
      ];
      const data = Buffer.alloc(exports2.createNativeMintInstructionData.span);
      exports2.createNativeMintInstructionData.encode({ instruction: types_js_1.TokenInstruction.CreateNativeMint }, data);
      return new web3_js_1.TransactionInstruction({ keys, programId, data });
    }
    exports2.createCreateNativeMintInstruction = createCreateNativeMintInstruction;
  }
});

// node_modules/@solana/spl-token/lib/cjs/actions/createNativeMint.js
var require_createNativeMint2 = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/actions/createNativeMint.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createNativeMint = void 0;
    var web3_js_1 = require("@solana/web3.js");
    var constants_js_1 = require_constants();
    var createNativeMint_js_1 = require_createNativeMint();
    function createNativeMint(connection, payer, confirmOptions, nativeMint = constants_js_1.NATIVE_MINT_2022, programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
      return __awaiter(this, void 0, void 0, function* () {
        const transaction = new web3_js_1.Transaction().add((0, createNativeMint_js_1.createCreateNativeMintInstruction)(payer.publicKey, nativeMint, programId));
        yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer], confirmOptions);
      });
    }
    exports2.createNativeMint = createNativeMint;
  }
});

// node_modules/@solana/spl-token/lib/cjs/instructions/syncNative.js
var require_syncNative = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/instructions/syncNative.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.decodeSyncNativeInstructionUnchecked = exports2.decodeSyncNativeInstruction = exports2.createSyncNativeInstruction = exports2.syncNativeInstructionData = void 0;
    var buffer_layout_1 = require_Layout();
    var web3_js_1 = require("@solana/web3.js");
    var constants_js_1 = require_constants();
    var errors_js_1 = require_errors();
    var types_js_1 = require_types();
    exports2.syncNativeInstructionData = (0, buffer_layout_1.struct)([(0, buffer_layout_1.u8)("instruction")]);
    function createSyncNativeInstruction(account, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      const keys = [{ pubkey: account, isSigner: false, isWritable: true }];
      const data = Buffer.alloc(exports2.syncNativeInstructionData.span);
      exports2.syncNativeInstructionData.encode({ instruction: types_js_1.TokenInstruction.SyncNative }, data);
      return new web3_js_1.TransactionInstruction({ keys, programId, data });
    }
    exports2.createSyncNativeInstruction = createSyncNativeInstruction;
    function decodeSyncNativeInstruction(instruction, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      if (!instruction.programId.equals(programId))
        throw new errors_js_1.TokenInvalidInstructionProgramError();
      if (instruction.data.length !== exports2.syncNativeInstructionData.span)
        throw new errors_js_1.TokenInvalidInstructionDataError();
      const { keys: { account }, data } = decodeSyncNativeInstructionUnchecked(instruction);
      if (data.instruction !== types_js_1.TokenInstruction.SyncNative)
        throw new errors_js_1.TokenInvalidInstructionTypeError();
      if (!account)
        throw new errors_js_1.TokenInvalidInstructionKeysError();
      return {
        programId,
        keys: {
          account
        },
        data
      };
    }
    exports2.decodeSyncNativeInstruction = decodeSyncNativeInstruction;
    function decodeSyncNativeInstructionUnchecked({ programId, keys: [account], data }) {
      return {
        programId,
        keys: {
          account
        },
        data: exports2.syncNativeInstructionData.decode(data)
      };
    }
    exports2.decodeSyncNativeInstructionUnchecked = decodeSyncNativeInstructionUnchecked;
  }
});

// node_modules/@solana/spl-token/lib/cjs/actions/createWrappedNativeAccount.js
var require_createWrappedNativeAccount = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/actions/createWrappedNativeAccount.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createWrappedNativeAccount = void 0;
    var web3_js_1 = require("@solana/web3.js");
    var constants_js_1 = require_constants();
    var associatedTokenAccount_js_1 = require_associatedTokenAccount();
    var initializeAccount_js_1 = require_initializeAccount();
    var syncNative_js_1 = require_syncNative();
    var account_js_1 = require_account();
    var mint_js_1 = require_mint();
    var createAccount_js_1 = require_createAccount();
    function createWrappedNativeAccount(connection, payer, owner, amount, keypair, confirmOptions, programId = constants_js_1.TOKEN_PROGRAM_ID, nativeMint = constants_js_1.NATIVE_MINT) {
      return __awaiter(this, void 0, void 0, function* () {
        if (!amount)
          return yield (0, createAccount_js_1.createAccount)(connection, payer, nativeMint, owner, keypair, confirmOptions, programId);
        if (!keypair) {
          const associatedToken = (0, mint_js_1.getAssociatedTokenAddressSync)(nativeMint, owner, false, programId, constants_js_1.ASSOCIATED_TOKEN_PROGRAM_ID);
          const transaction2 = new web3_js_1.Transaction().add((0, associatedTokenAccount_js_1.createAssociatedTokenAccountInstruction)(payer.publicKey, associatedToken, owner, nativeMint, programId, constants_js_1.ASSOCIATED_TOKEN_PROGRAM_ID), web3_js_1.SystemProgram.transfer({
            fromPubkey: payer.publicKey,
            toPubkey: associatedToken,
            lamports: amount
          }), (0, syncNative_js_1.createSyncNativeInstruction)(associatedToken, programId));
          yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction2, [payer], confirmOptions);
          return associatedToken;
        }
        const lamports = yield (0, account_js_1.getMinimumBalanceForRentExemptAccount)(connection);
        const transaction = new web3_js_1.Transaction().add(web3_js_1.SystemProgram.createAccount({
          fromPubkey: payer.publicKey,
          newAccountPubkey: keypair.publicKey,
          space: account_js_1.ACCOUNT_SIZE,
          lamports,
          programId
        }), web3_js_1.SystemProgram.transfer({
          fromPubkey: payer.publicKey,
          toPubkey: keypair.publicKey,
          lamports: amount
        }), (0, initializeAccount_js_1.createInitializeAccountInstruction)(keypair.publicKey, nativeMint, owner, programId));
        yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer, keypair], confirmOptions);
        return keypair.publicKey;
      });
    }
    exports2.createWrappedNativeAccount = createWrappedNativeAccount;
  }
});

// node_modules/@solana/spl-token/lib/cjs/instructions/freezeAccount.js
var require_freezeAccount = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/instructions/freezeAccount.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.decodeFreezeAccountInstructionUnchecked = exports2.decodeFreezeAccountInstruction = exports2.createFreezeAccountInstruction = exports2.freezeAccountInstructionData = void 0;
    var buffer_layout_1 = require_Layout();
    var web3_js_1 = require("@solana/web3.js");
    var constants_js_1 = require_constants();
    var errors_js_1 = require_errors();
    var internal_js_1 = require_internal();
    var types_js_1 = require_types();
    exports2.freezeAccountInstructionData = (0, buffer_layout_1.struct)([(0, buffer_layout_1.u8)("instruction")]);
    function createFreezeAccountInstruction(account, mint, authority, multiSigners = [], programId = constants_js_1.TOKEN_PROGRAM_ID) {
      const keys = (0, internal_js_1.addSigners)([
        { pubkey: account, isSigner: false, isWritable: true },
        { pubkey: mint, isSigner: false, isWritable: false }
      ], authority, multiSigners);
      const data = Buffer.alloc(exports2.freezeAccountInstructionData.span);
      exports2.freezeAccountInstructionData.encode({ instruction: types_js_1.TokenInstruction.FreezeAccount }, data);
      return new web3_js_1.TransactionInstruction({ keys, programId, data });
    }
    exports2.createFreezeAccountInstruction = createFreezeAccountInstruction;
    function decodeFreezeAccountInstruction(instruction, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      if (!instruction.programId.equals(programId))
        throw new errors_js_1.TokenInvalidInstructionProgramError();
      if (instruction.data.length !== exports2.freezeAccountInstructionData.span)
        throw new errors_js_1.TokenInvalidInstructionDataError();
      const { keys: { account, mint, authority, multiSigners }, data } = decodeFreezeAccountInstructionUnchecked(instruction);
      if (data.instruction !== types_js_1.TokenInstruction.FreezeAccount)
        throw new errors_js_1.TokenInvalidInstructionTypeError();
      if (!account || !mint || !authority)
        throw new errors_js_1.TokenInvalidInstructionKeysError();
      return {
        programId,
        keys: {
          account,
          mint,
          authority,
          multiSigners
        },
        data
      };
    }
    exports2.decodeFreezeAccountInstruction = decodeFreezeAccountInstruction;
    function decodeFreezeAccountInstructionUnchecked({ programId, keys: [account, mint, authority, ...multiSigners], data }) {
      return {
        programId,
        keys: {
          account,
          mint,
          authority,
          multiSigners
        },
        data: exports2.freezeAccountInstructionData.decode(data)
      };
    }
    exports2.decodeFreezeAccountInstructionUnchecked = decodeFreezeAccountInstructionUnchecked;
  }
});

// node_modules/@solana/spl-token/lib/cjs/actions/freezeAccount.js
var require_freezeAccount2 = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/actions/freezeAccount.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.freezeAccount = void 0;
    var web3_js_1 = require("@solana/web3.js");
    var constants_js_1 = require_constants();
    var freezeAccount_js_1 = require_freezeAccount();
    var internal_js_1 = require_internal2();
    function freezeAccount(connection, payer, account, mint, authority, multiSigners = [], confirmOptions, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      return __awaiter(this, void 0, void 0, function* () {
        const [authorityPublicKey, signers] = (0, internal_js_1.getSigners)(authority, multiSigners);
        const transaction = new web3_js_1.Transaction().add((0, freezeAccount_js_1.createFreezeAccountInstruction)(account, mint, authorityPublicKey, multiSigners, programId));
        return yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer, ...signers], confirmOptions);
      });
    }
    exports2.freezeAccount = freezeAccount;
  }
});

// node_modules/@solana/spl-token/lib/cjs/actions/getOrCreateAssociatedTokenAccount.js
var require_getOrCreateAssociatedTokenAccount = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/actions/getOrCreateAssociatedTokenAccount.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getOrCreateAssociatedTokenAccount = void 0;
    var web3_js_1 = require("@solana/web3.js");
    var constants_js_1 = require_constants();
    var errors_js_1 = require_errors();
    var associatedTokenAccount_js_1 = require_associatedTokenAccount();
    var account_js_1 = require_account();
    var mint_js_1 = require_mint();
    function getOrCreateAssociatedTokenAccount(connection, payer, mint, owner, allowOwnerOffCurve = false, commitment, confirmOptions, programId = constants_js_1.TOKEN_PROGRAM_ID, associatedTokenProgramId = constants_js_1.ASSOCIATED_TOKEN_PROGRAM_ID) {
      return __awaiter(this, void 0, void 0, function* () {
        const associatedToken = (0, mint_js_1.getAssociatedTokenAddressSync)(mint, owner, allowOwnerOffCurve, programId, associatedTokenProgramId);
        let account;
        try {
          account = yield (0, account_js_1.getAccount)(connection, associatedToken, commitment, programId);
        } catch (error) {
          if (error instanceof errors_js_1.TokenAccountNotFoundError || error instanceof errors_js_1.TokenInvalidAccountOwnerError) {
            try {
              const transaction = new web3_js_1.Transaction().add((0, associatedTokenAccount_js_1.createAssociatedTokenAccountInstruction)(payer.publicKey, associatedToken, owner, mint, programId, associatedTokenProgramId));
              yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer], confirmOptions);
            } catch (error2) {
            }
            account = yield (0, account_js_1.getAccount)(connection, associatedToken, commitment, programId);
          } else {
            throw error;
          }
        }
        if (!account.mint.equals(mint))
          throw new errors_js_1.TokenInvalidMintError();
        if (!account.owner.equals(owner))
          throw new errors_js_1.TokenInvalidOwnerError();
        return account;
      });
    }
    exports2.getOrCreateAssociatedTokenAccount = getOrCreateAssociatedTokenAccount;
  }
});

// node_modules/@solana/spl-token/lib/cjs/instructions/mintTo.js
var require_mintTo = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/instructions/mintTo.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.decodeMintToInstructionUnchecked = exports2.decodeMintToInstruction = exports2.createMintToInstruction = exports2.mintToInstructionData = void 0;
    var buffer_layout_1 = require_Layout();
    var buffer_layout_utils_1 = require_cjs();
    var web3_js_1 = require("@solana/web3.js");
    var constants_js_1 = require_constants();
    var errors_js_1 = require_errors();
    var internal_js_1 = require_internal();
    var types_js_1 = require_types();
    exports2.mintToInstructionData = (0, buffer_layout_1.struct)([(0, buffer_layout_1.u8)("instruction"), (0, buffer_layout_utils_1.u64)("amount")]);
    function createMintToInstruction(mint, destination, authority, amount, multiSigners = [], programId = constants_js_1.TOKEN_PROGRAM_ID) {
      const keys = (0, internal_js_1.addSigners)([
        { pubkey: mint, isSigner: false, isWritable: true },
        { pubkey: destination, isSigner: false, isWritable: true }
      ], authority, multiSigners);
      const data = Buffer.alloc(exports2.mintToInstructionData.span);
      exports2.mintToInstructionData.encode({
        instruction: types_js_1.TokenInstruction.MintTo,
        amount: BigInt(amount)
      }, data);
      return new web3_js_1.TransactionInstruction({ keys, programId, data });
    }
    exports2.createMintToInstruction = createMintToInstruction;
    function decodeMintToInstruction(instruction, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      if (!instruction.programId.equals(programId))
        throw new errors_js_1.TokenInvalidInstructionProgramError();
      if (instruction.data.length !== exports2.mintToInstructionData.span)
        throw new errors_js_1.TokenInvalidInstructionDataError();
      const { keys: { mint, destination, authority, multiSigners }, data } = decodeMintToInstructionUnchecked(instruction);
      if (data.instruction !== types_js_1.TokenInstruction.MintTo)
        throw new errors_js_1.TokenInvalidInstructionTypeError();
      if (!mint || !destination || !authority)
        throw new errors_js_1.TokenInvalidInstructionKeysError();
      return {
        programId,
        keys: {
          mint,
          destination,
          authority,
          multiSigners
        },
        data
      };
    }
    exports2.decodeMintToInstruction = decodeMintToInstruction;
    function decodeMintToInstructionUnchecked({ programId, keys: [mint, destination, authority, ...multiSigners], data }) {
      return {
        programId,
        keys: {
          mint,
          destination,
          authority,
          multiSigners
        },
        data: exports2.mintToInstructionData.decode(data)
      };
    }
    exports2.decodeMintToInstructionUnchecked = decodeMintToInstructionUnchecked;
  }
});

// node_modules/@solana/spl-token/lib/cjs/actions/mintTo.js
var require_mintTo2 = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/actions/mintTo.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.mintTo = void 0;
    var web3_js_1 = require("@solana/web3.js");
    var constants_js_1 = require_constants();
    var mintTo_js_1 = require_mintTo();
    var internal_js_1 = require_internal2();
    function mintTo(connection, payer, mint, destination, authority, amount, multiSigners = [], confirmOptions, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      return __awaiter(this, void 0, void 0, function* () {
        const [authorityPublicKey, signers] = (0, internal_js_1.getSigners)(authority, multiSigners);
        const transaction = new web3_js_1.Transaction().add((0, mintTo_js_1.createMintToInstruction)(mint, destination, authorityPublicKey, amount, multiSigners, programId));
        return yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer, ...signers], confirmOptions);
      });
    }
    exports2.mintTo = mintTo;
  }
});

// node_modules/@solana/spl-token/lib/cjs/instructions/mintToChecked.js
var require_mintToChecked = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/instructions/mintToChecked.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.decodeMintToCheckedInstructionUnchecked = exports2.decodeMintToCheckedInstruction = exports2.createMintToCheckedInstruction = exports2.mintToCheckedInstructionData = void 0;
    var buffer_layout_1 = require_Layout();
    var buffer_layout_utils_1 = require_cjs();
    var web3_js_1 = require("@solana/web3.js");
    var constants_js_1 = require_constants();
    var errors_js_1 = require_errors();
    var internal_js_1 = require_internal();
    var types_js_1 = require_types();
    exports2.mintToCheckedInstructionData = (0, buffer_layout_1.struct)([
      (0, buffer_layout_1.u8)("instruction"),
      (0, buffer_layout_utils_1.u64)("amount"),
      (0, buffer_layout_1.u8)("decimals")
    ]);
    function createMintToCheckedInstruction(mint, destination, authority, amount, decimals, multiSigners = [], programId = constants_js_1.TOKEN_PROGRAM_ID) {
      const keys = (0, internal_js_1.addSigners)([
        { pubkey: mint, isSigner: false, isWritable: true },
        { pubkey: destination, isSigner: false, isWritable: true }
      ], authority, multiSigners);
      const data = Buffer.alloc(exports2.mintToCheckedInstructionData.span);
      exports2.mintToCheckedInstructionData.encode({
        instruction: types_js_1.TokenInstruction.MintToChecked,
        amount: BigInt(amount),
        decimals
      }, data);
      return new web3_js_1.TransactionInstruction({ keys, programId, data });
    }
    exports2.createMintToCheckedInstruction = createMintToCheckedInstruction;
    function decodeMintToCheckedInstruction(instruction, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      if (!instruction.programId.equals(programId))
        throw new errors_js_1.TokenInvalidInstructionProgramError();
      if (instruction.data.length !== exports2.mintToCheckedInstructionData.span)
        throw new errors_js_1.TokenInvalidInstructionDataError();
      const { keys: { mint, destination, authority, multiSigners }, data } = decodeMintToCheckedInstructionUnchecked(instruction);
      if (data.instruction !== types_js_1.TokenInstruction.MintToChecked)
        throw new errors_js_1.TokenInvalidInstructionTypeError();
      if (!mint || !destination || !authority)
        throw new errors_js_1.TokenInvalidInstructionKeysError();
      return {
        programId,
        keys: {
          mint,
          destination,
          authority,
          multiSigners
        },
        data
      };
    }
    exports2.decodeMintToCheckedInstruction = decodeMintToCheckedInstruction;
    function decodeMintToCheckedInstructionUnchecked({ programId, keys: [mint, destination, authority, ...multiSigners], data }) {
      return {
        programId,
        keys: {
          mint,
          destination,
          authority,
          multiSigners
        },
        data: exports2.mintToCheckedInstructionData.decode(data)
      };
    }
    exports2.decodeMintToCheckedInstructionUnchecked = decodeMintToCheckedInstructionUnchecked;
  }
});

// node_modules/@solana/spl-token/lib/cjs/actions/mintToChecked.js
var require_mintToChecked2 = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/actions/mintToChecked.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.mintToChecked = void 0;
    var web3_js_1 = require("@solana/web3.js");
    var constants_js_1 = require_constants();
    var mintToChecked_js_1 = require_mintToChecked();
    var internal_js_1 = require_internal2();
    function mintToChecked(connection, payer, mint, destination, authority, amount, decimals, multiSigners = [], confirmOptions, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      return __awaiter(this, void 0, void 0, function* () {
        const [authorityPublicKey, signers] = (0, internal_js_1.getSigners)(authority, multiSigners);
        const transaction = new web3_js_1.Transaction().add((0, mintToChecked_js_1.createMintToCheckedInstruction)(mint, destination, authorityPublicKey, amount, decimals, multiSigners, programId));
        return yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer, ...signers], confirmOptions);
      });
    }
    exports2.mintToChecked = mintToChecked;
  }
});

// node_modules/@solana/spl-token/lib/cjs/actions/recoverNested.js
var require_recoverNested = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/actions/recoverNested.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.recoverNested = void 0;
    var web3_js_1 = require("@solana/web3.js");
    var constants_js_1 = require_constants();
    var associatedTokenAccount_js_1 = require_associatedTokenAccount();
    var mint_js_1 = require_mint();
    function recoverNested(connection, payer, owner, mint, nestedMint, confirmOptions, programId = constants_js_1.TOKEN_PROGRAM_ID, associatedTokenProgramId = constants_js_1.ASSOCIATED_TOKEN_PROGRAM_ID) {
      return __awaiter(this, void 0, void 0, function* () {
        const ownerAssociatedToken = (0, mint_js_1.getAssociatedTokenAddressSync)(mint, owner.publicKey, false, programId, associatedTokenProgramId);
        const destinationAssociatedToken = (0, mint_js_1.getAssociatedTokenAddressSync)(nestedMint, owner.publicKey, false, programId, associatedTokenProgramId);
        const nestedAssociatedToken = (0, mint_js_1.getAssociatedTokenAddressSync)(nestedMint, ownerAssociatedToken, true, programId, associatedTokenProgramId);
        const transaction = new web3_js_1.Transaction().add((0, associatedTokenAccount_js_1.createRecoverNestedInstruction)(nestedAssociatedToken, nestedMint, destinationAssociatedToken, ownerAssociatedToken, mint, owner.publicKey, programId, associatedTokenProgramId));
        return yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer, owner], confirmOptions);
      });
    }
    exports2.recoverNested = recoverNested;
  }
});

// node_modules/@solana/spl-token/lib/cjs/instructions/revoke.js
var require_revoke = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/instructions/revoke.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.decodeRevokeInstructionUnchecked = exports2.decodeRevokeInstruction = exports2.createRevokeInstruction = exports2.revokeInstructionData = void 0;
    var buffer_layout_1 = require_Layout();
    var web3_js_1 = require("@solana/web3.js");
    var constants_js_1 = require_constants();
    var errors_js_1 = require_errors();
    var internal_js_1 = require_internal();
    var types_js_1 = require_types();
    exports2.revokeInstructionData = (0, buffer_layout_1.struct)([(0, buffer_layout_1.u8)("instruction")]);
    function createRevokeInstruction(account, owner, multiSigners = [], programId = constants_js_1.TOKEN_PROGRAM_ID) {
      const keys = (0, internal_js_1.addSigners)([{ pubkey: account, isSigner: false, isWritable: true }], owner, multiSigners);
      const data = Buffer.alloc(exports2.revokeInstructionData.span);
      exports2.revokeInstructionData.encode({ instruction: types_js_1.TokenInstruction.Revoke }, data);
      return new web3_js_1.TransactionInstruction({ keys, programId, data });
    }
    exports2.createRevokeInstruction = createRevokeInstruction;
    function decodeRevokeInstruction(instruction, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      if (!instruction.programId.equals(programId))
        throw new errors_js_1.TokenInvalidInstructionProgramError();
      if (instruction.data.length !== exports2.revokeInstructionData.span)
        throw new errors_js_1.TokenInvalidInstructionDataError();
      const { keys: { account, owner, multiSigners }, data } = decodeRevokeInstructionUnchecked(instruction);
      if (data.instruction !== types_js_1.TokenInstruction.Revoke)
        throw new errors_js_1.TokenInvalidInstructionTypeError();
      if (!account || !owner)
        throw new errors_js_1.TokenInvalidInstructionKeysError();
      return {
        programId,
        keys: {
          account,
          owner,
          multiSigners
        },
        data
      };
    }
    exports2.decodeRevokeInstruction = decodeRevokeInstruction;
    function decodeRevokeInstructionUnchecked({ programId, keys: [account, owner, ...multiSigners], data }) {
      return {
        programId,
        keys: {
          account,
          owner,
          multiSigners
        },
        data: exports2.revokeInstructionData.decode(data)
      };
    }
    exports2.decodeRevokeInstructionUnchecked = decodeRevokeInstructionUnchecked;
  }
});

// node_modules/@solana/spl-token/lib/cjs/actions/revoke.js
var require_revoke2 = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/actions/revoke.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.revoke = void 0;
    var web3_js_1 = require("@solana/web3.js");
    var constants_js_1 = require_constants();
    var revoke_js_1 = require_revoke();
    var internal_js_1 = require_internal2();
    function revoke(connection, payer, account, owner, multiSigners = [], confirmOptions, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      return __awaiter(this, void 0, void 0, function* () {
        const [ownerPublicKey, signers] = (0, internal_js_1.getSigners)(owner, multiSigners);
        const transaction = new web3_js_1.Transaction().add((0, revoke_js_1.createRevokeInstruction)(account, ownerPublicKey, multiSigners, programId));
        return yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer, ...signers], confirmOptions);
      });
    }
    exports2.revoke = revoke;
  }
});

// node_modules/@solana/spl-token/lib/cjs/instructions/setAuthority.js
var require_setAuthority = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/instructions/setAuthority.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.decodeSetAuthorityInstructionUnchecked = exports2.decodeSetAuthorityInstruction = exports2.createSetAuthorityInstruction = exports2.setAuthorityInstructionData = exports2.AuthorityType = void 0;
    var buffer_layout_1 = require_Layout();
    var buffer_layout_utils_1 = require_cjs();
    var web3_js_1 = require("@solana/web3.js");
    var constants_js_1 = require_constants();
    var errors_js_1 = require_errors();
    var internal_js_1 = require_internal();
    var types_js_1 = require_types();
    var AuthorityType;
    (function(AuthorityType2) {
      AuthorityType2[AuthorityType2["MintTokens"] = 0] = "MintTokens";
      AuthorityType2[AuthorityType2["FreezeAccount"] = 1] = "FreezeAccount";
      AuthorityType2[AuthorityType2["AccountOwner"] = 2] = "AccountOwner";
      AuthorityType2[AuthorityType2["CloseAccount"] = 3] = "CloseAccount";
      AuthorityType2[AuthorityType2["TransferFeeConfig"] = 4] = "TransferFeeConfig";
      AuthorityType2[AuthorityType2["WithheldWithdraw"] = 5] = "WithheldWithdraw";
      AuthorityType2[AuthorityType2["CloseMint"] = 6] = "CloseMint";
      AuthorityType2[AuthorityType2["InterestRate"] = 7] = "InterestRate";
      AuthorityType2[AuthorityType2["PermanentDelegate"] = 8] = "PermanentDelegate";
      AuthorityType2[AuthorityType2["ConfidentialTransferMint"] = 9] = "ConfidentialTransferMint";
      AuthorityType2[AuthorityType2["TransferHookProgramId"] = 10] = "TransferHookProgramId";
      AuthorityType2[AuthorityType2["ConfidentialTransferFeeConfig"] = 11] = "ConfidentialTransferFeeConfig";
      AuthorityType2[AuthorityType2["MetadataPointer"] = 12] = "MetadataPointer";
    })(AuthorityType || (exports2.AuthorityType = AuthorityType = {}));
    exports2.setAuthorityInstructionData = (0, buffer_layout_1.struct)([
      (0, buffer_layout_1.u8)("instruction"),
      (0, buffer_layout_1.u8)("authorityType"),
      (0, buffer_layout_1.u8)("newAuthorityOption"),
      (0, buffer_layout_utils_1.publicKey)("newAuthority")
    ]);
    function createSetAuthorityInstruction(account, currentAuthority, authorityType, newAuthority, multiSigners = [], programId = constants_js_1.TOKEN_PROGRAM_ID) {
      const keys = (0, internal_js_1.addSigners)([{ pubkey: account, isSigner: false, isWritable: true }], currentAuthority, multiSigners);
      const data = Buffer.alloc(exports2.setAuthorityInstructionData.span);
      exports2.setAuthorityInstructionData.encode({
        instruction: types_js_1.TokenInstruction.SetAuthority,
        authorityType,
        newAuthorityOption: newAuthority ? 1 : 0,
        newAuthority: newAuthority || new web3_js_1.PublicKey(0)
      }, data);
      return new web3_js_1.TransactionInstruction({ keys, programId, data });
    }
    exports2.createSetAuthorityInstruction = createSetAuthorityInstruction;
    function decodeSetAuthorityInstruction(instruction, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      if (!instruction.programId.equals(programId))
        throw new errors_js_1.TokenInvalidInstructionProgramError();
      if (instruction.data.length !== exports2.setAuthorityInstructionData.span)
        throw new errors_js_1.TokenInvalidInstructionDataError();
      const { keys: { account, currentAuthority, multiSigners }, data } = decodeSetAuthorityInstructionUnchecked(instruction);
      if (data.instruction !== types_js_1.TokenInstruction.SetAuthority)
        throw new errors_js_1.TokenInvalidInstructionTypeError();
      if (!account || !currentAuthority)
        throw new errors_js_1.TokenInvalidInstructionKeysError();
      return {
        programId,
        keys: {
          account,
          currentAuthority,
          multiSigners
        },
        data
      };
    }
    exports2.decodeSetAuthorityInstruction = decodeSetAuthorityInstruction;
    function decodeSetAuthorityInstructionUnchecked({ programId, keys: [account, currentAuthority, ...multiSigners], data }) {
      const { instruction, authorityType, newAuthorityOption, newAuthority } = exports2.setAuthorityInstructionData.decode(data);
      return {
        programId,
        keys: {
          account,
          currentAuthority,
          multiSigners
        },
        data: {
          instruction,
          authorityType,
          newAuthority: newAuthorityOption ? newAuthority : null
        }
      };
    }
    exports2.decodeSetAuthorityInstructionUnchecked = decodeSetAuthorityInstructionUnchecked;
  }
});

// node_modules/@solana/spl-token/lib/cjs/actions/setAuthority.js
var require_setAuthority2 = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/actions/setAuthority.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.setAuthority = void 0;
    var web3_js_1 = require("@solana/web3.js");
    var constants_js_1 = require_constants();
    var setAuthority_js_1 = require_setAuthority();
    var internal_js_1 = require_internal2();
    function setAuthority(connection, payer, account, currentAuthority, authorityType, newAuthority, multiSigners = [], confirmOptions, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      return __awaiter(this, void 0, void 0, function* () {
        const [currentAuthorityPublicKey, signers] = (0, internal_js_1.getSigners)(currentAuthority, multiSigners);
        const transaction = new web3_js_1.Transaction().add((0, setAuthority_js_1.createSetAuthorityInstruction)(account, currentAuthorityPublicKey, authorityType, newAuthority, multiSigners, programId));
        return yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer, ...signers], confirmOptions);
      });
    }
    exports2.setAuthority = setAuthority;
  }
});

// node_modules/@solana/spl-token/lib/cjs/actions/syncNative.js
var require_syncNative2 = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/actions/syncNative.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.syncNative = void 0;
    var web3_js_1 = require("@solana/web3.js");
    var constants_js_1 = require_constants();
    var syncNative_js_1 = require_syncNative();
    function syncNative(connection, payer, account, confirmOptions, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      return __awaiter(this, void 0, void 0, function* () {
        const transaction = new web3_js_1.Transaction().add((0, syncNative_js_1.createSyncNativeInstruction)(account, programId));
        return yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer], confirmOptions);
      });
    }
    exports2.syncNative = syncNative;
  }
});

// node_modules/@solana/spl-token/lib/cjs/instructions/thawAccount.js
var require_thawAccount = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/instructions/thawAccount.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.decodeThawAccountInstructionUnchecked = exports2.decodeThawAccountInstruction = exports2.createThawAccountInstruction = exports2.thawAccountInstructionData = void 0;
    var buffer_layout_1 = require_Layout();
    var web3_js_1 = require("@solana/web3.js");
    var constants_js_1 = require_constants();
    var errors_js_1 = require_errors();
    var internal_js_1 = require_internal();
    var types_js_1 = require_types();
    exports2.thawAccountInstructionData = (0, buffer_layout_1.struct)([(0, buffer_layout_1.u8)("instruction")]);
    function createThawAccountInstruction(account, mint, authority, multiSigners = [], programId = constants_js_1.TOKEN_PROGRAM_ID) {
      const keys = (0, internal_js_1.addSigners)([
        { pubkey: account, isSigner: false, isWritable: true },
        { pubkey: mint, isSigner: false, isWritable: false }
      ], authority, multiSigners);
      const data = Buffer.alloc(exports2.thawAccountInstructionData.span);
      exports2.thawAccountInstructionData.encode({ instruction: types_js_1.TokenInstruction.ThawAccount }, data);
      return new web3_js_1.TransactionInstruction({ keys, programId, data });
    }
    exports2.createThawAccountInstruction = createThawAccountInstruction;
    function decodeThawAccountInstruction(instruction, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      if (!instruction.programId.equals(programId))
        throw new errors_js_1.TokenInvalidInstructionProgramError();
      if (instruction.data.length !== exports2.thawAccountInstructionData.span)
        throw new errors_js_1.TokenInvalidInstructionDataError();
      const { keys: { account, mint, authority, multiSigners }, data } = decodeThawAccountInstructionUnchecked(instruction);
      if (data.instruction !== types_js_1.TokenInstruction.ThawAccount)
        throw new errors_js_1.TokenInvalidInstructionTypeError();
      if (!account || !mint || !authority)
        throw new errors_js_1.TokenInvalidInstructionKeysError();
      return {
        programId,
        keys: {
          account,
          mint,
          authority,
          multiSigners
        },
        data
      };
    }
    exports2.decodeThawAccountInstruction = decodeThawAccountInstruction;
    function decodeThawAccountInstructionUnchecked({ programId, keys: [account, mint, authority, ...multiSigners], data }) {
      return {
        programId,
        keys: {
          account,
          mint,
          authority,
          multiSigners
        },
        data: exports2.thawAccountInstructionData.decode(data)
      };
    }
    exports2.decodeThawAccountInstructionUnchecked = decodeThawAccountInstructionUnchecked;
  }
});

// node_modules/@solana/spl-token/lib/cjs/actions/thawAccount.js
var require_thawAccount2 = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/actions/thawAccount.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.thawAccount = void 0;
    var web3_js_1 = require("@solana/web3.js");
    var constants_js_1 = require_constants();
    var thawAccount_js_1 = require_thawAccount();
    var internal_js_1 = require_internal2();
    function thawAccount(connection, payer, account, mint, authority, multiSigners = [], confirmOptions, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      return __awaiter(this, void 0, void 0, function* () {
        const [authorityPublicKey, signers] = (0, internal_js_1.getSigners)(authority, multiSigners);
        const transaction = new web3_js_1.Transaction().add((0, thawAccount_js_1.createThawAccountInstruction)(account, mint, authorityPublicKey, multiSigners, programId));
        return yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer, ...signers], confirmOptions);
      });
    }
    exports2.thawAccount = thawAccount;
  }
});

// node_modules/@solana/spl-token/lib/cjs/instructions/transfer.js
var require_transfer = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/instructions/transfer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.decodeTransferInstructionUnchecked = exports2.decodeTransferInstruction = exports2.createTransferInstruction = exports2.transferInstructionData = void 0;
    var buffer_layout_1 = require_Layout();
    var buffer_layout_utils_1 = require_cjs();
    var web3_js_1 = require("@solana/web3.js");
    var constants_js_1 = require_constants();
    var errors_js_1 = require_errors();
    var internal_js_1 = require_internal();
    var types_js_1 = require_types();
    exports2.transferInstructionData = (0, buffer_layout_1.struct)([(0, buffer_layout_1.u8)("instruction"), (0, buffer_layout_utils_1.u64)("amount")]);
    function createTransferInstruction(source, destination, owner, amount, multiSigners = [], programId = constants_js_1.TOKEN_PROGRAM_ID) {
      const keys = (0, internal_js_1.addSigners)([
        { pubkey: source, isSigner: false, isWritable: true },
        { pubkey: destination, isSigner: false, isWritable: true }
      ], owner, multiSigners);
      const data = Buffer.alloc(exports2.transferInstructionData.span);
      exports2.transferInstructionData.encode({
        instruction: types_js_1.TokenInstruction.Transfer,
        amount: BigInt(amount)
      }, data);
      return new web3_js_1.TransactionInstruction({ keys, programId, data });
    }
    exports2.createTransferInstruction = createTransferInstruction;
    function decodeTransferInstruction(instruction, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      if (!instruction.programId.equals(programId))
        throw new errors_js_1.TokenInvalidInstructionProgramError();
      if (instruction.data.length !== exports2.transferInstructionData.span)
        throw new errors_js_1.TokenInvalidInstructionDataError();
      const { keys: { source, destination, owner, multiSigners }, data } = decodeTransferInstructionUnchecked(instruction);
      if (data.instruction !== types_js_1.TokenInstruction.Transfer)
        throw new errors_js_1.TokenInvalidInstructionTypeError();
      if (!source || !destination || !owner)
        throw new errors_js_1.TokenInvalidInstructionKeysError();
      return {
        programId,
        keys: {
          source,
          destination,
          owner,
          multiSigners
        },
        data
      };
    }
    exports2.decodeTransferInstruction = decodeTransferInstruction;
    function decodeTransferInstructionUnchecked({ programId, keys: [source, destination, owner, ...multiSigners], data }) {
      return {
        programId,
        keys: {
          source,
          destination,
          owner,
          multiSigners
        },
        data: exports2.transferInstructionData.decode(data)
      };
    }
    exports2.decodeTransferInstructionUnchecked = decodeTransferInstructionUnchecked;
  }
});

// node_modules/@solana/spl-token/lib/cjs/actions/transfer.js
var require_transfer2 = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/actions/transfer.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.transfer = void 0;
    var web3_js_1 = require("@solana/web3.js");
    var constants_js_1 = require_constants();
    var transfer_js_1 = require_transfer();
    var internal_js_1 = require_internal2();
    function transfer(connection, payer, source, destination, owner, amount, multiSigners = [], confirmOptions, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      return __awaiter(this, void 0, void 0, function* () {
        const [ownerPublicKey, signers] = (0, internal_js_1.getSigners)(owner, multiSigners);
        const transaction = new web3_js_1.Transaction().add((0, transfer_js_1.createTransferInstruction)(source, destination, ownerPublicKey, amount, multiSigners, programId));
        return yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer, ...signers], confirmOptions);
      });
    }
    exports2.transfer = transfer;
  }
});

// node_modules/@solana/spl-token/lib/cjs/actions/transferChecked.js
var require_transferChecked2 = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/actions/transferChecked.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.transferChecked = void 0;
    var web3_js_1 = require("@solana/web3.js");
    var constants_js_1 = require_constants();
    var transferChecked_js_1 = require_transferChecked();
    var internal_js_1 = require_internal2();
    function transferChecked(connection, payer, source, mint, destination, owner, amount, decimals, multiSigners = [], confirmOptions, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      return __awaiter(this, void 0, void 0, function* () {
        const [ownerPublicKey, signers] = (0, internal_js_1.getSigners)(owner, multiSigners);
        const transaction = new web3_js_1.Transaction().add((0, transferChecked_js_1.createTransferCheckedInstruction)(source, mint, destination, ownerPublicKey, amount, decimals, multiSigners, programId));
        return yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer, ...signers], confirmOptions);
      });
    }
    exports2.transferChecked = transferChecked;
  }
});

// node_modules/@solana/spl-token/lib/cjs/instructions/uiAmountToAmount.js
var require_uiAmountToAmount = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/instructions/uiAmountToAmount.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.decodeUiAmountToAmountInstructionUnchecked = exports2.decodeUiAmountToAmountInstruction = exports2.createUiAmountToAmountInstruction = void 0;
    var buffer_layout_1 = require_Layout();
    var web3_js_1 = require("@solana/web3.js");
    var constants_js_1 = require_constants();
    var errors_js_1 = require_errors();
    var types_js_1 = require_types();
    function createUiAmountToAmountInstruction(mint, amount, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      const keys = [{ pubkey: mint, isSigner: false, isWritable: false }];
      const buf = Buffer.from(amount, "utf8");
      const uiAmountToAmountInstructionData = (0, buffer_layout_1.struct)([
        (0, buffer_layout_1.u8)("instruction"),
        (0, buffer_layout_1.blob)(buf.length, "amount")
      ]);
      const data = Buffer.alloc(uiAmountToAmountInstructionData.span);
      uiAmountToAmountInstructionData.encode({
        instruction: types_js_1.TokenInstruction.UiAmountToAmount,
        amount: buf
      }, data);
      return new web3_js_1.TransactionInstruction({ keys, programId, data });
    }
    exports2.createUiAmountToAmountInstruction = createUiAmountToAmountInstruction;
    function decodeUiAmountToAmountInstruction(instruction, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      if (!instruction.programId.equals(programId))
        throw new errors_js_1.TokenInvalidInstructionProgramError();
      const uiAmountToAmountInstructionData = (0, buffer_layout_1.struct)([
        (0, buffer_layout_1.u8)("instruction"),
        (0, buffer_layout_1.blob)(instruction.data.length - 1, "amount")
      ]);
      if (instruction.data.length !== uiAmountToAmountInstructionData.span)
        throw new errors_js_1.TokenInvalidInstructionDataError();
      const { keys: { mint }, data } = decodeUiAmountToAmountInstructionUnchecked(instruction);
      if (data.instruction !== types_js_1.TokenInstruction.UiAmountToAmount)
        throw new errors_js_1.TokenInvalidInstructionTypeError();
      if (!mint)
        throw new errors_js_1.TokenInvalidInstructionKeysError();
      return {
        programId,
        keys: {
          mint
        },
        data
      };
    }
    exports2.decodeUiAmountToAmountInstruction = decodeUiAmountToAmountInstruction;
    function decodeUiAmountToAmountInstructionUnchecked({ programId, keys: [mint], data }) {
      const uiAmountToAmountInstructionData = (0, buffer_layout_1.struct)([
        (0, buffer_layout_1.u8)("instruction"),
        (0, buffer_layout_1.blob)(data.length - 1, "amount")
      ]);
      return {
        programId,
        keys: {
          mint
        },
        data: uiAmountToAmountInstructionData.decode(data)
      };
    }
    exports2.decodeUiAmountToAmountInstructionUnchecked = decodeUiAmountToAmountInstructionUnchecked;
  }
});

// node_modules/@solana/spl-token/lib/cjs/actions/uiAmountToAmount.js
var require_uiAmountToAmount2 = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/actions/uiAmountToAmount.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.uiAmountToAmount = void 0;
    var buffer_layout_utils_1 = require_cjs();
    var web3_js_1 = require("@solana/web3.js");
    var constants_js_1 = require_constants();
    var uiAmountToAmount_js_1 = require_uiAmountToAmount();
    function uiAmountToAmount(connection, payer, mint, amount, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      return __awaiter(this, void 0, void 0, function* () {
        const transaction = new web3_js_1.Transaction().add((0, uiAmountToAmount_js_1.createUiAmountToAmountInstruction)(mint, amount, programId));
        const { returnData, err } = (yield connection.simulateTransaction(transaction, [payer], false)).value;
        if (returnData) {
          const data = Buffer.from(returnData.data[0], returnData.data[1]);
          return (0, buffer_layout_utils_1.u64)().decode(data);
        }
        return err;
      });
    }
    exports2.uiAmountToAmount = uiAmountToAmount;
  }
});

// node_modules/@solana/spl-token/lib/cjs/actions/index.js
var require_actions6 = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/actions/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_amountToUiAmount2(), exports2);
    __exportStar(require_approve2(), exports2);
    __exportStar(require_approveChecked2(), exports2);
    __exportStar(require_burn2(), exports2);
    __exportStar(require_burnChecked2(), exports2);
    __exportStar(require_closeAccount2(), exports2);
    __exportStar(require_createAccount(), exports2);
    __exportStar(require_createAssociatedTokenAccount(), exports2);
    __exportStar(require_createAssociatedTokenAccountIdempotent(), exports2);
    __exportStar(require_createMint(), exports2);
    __exportStar(require_createMultisig(), exports2);
    __exportStar(require_createNativeMint2(), exports2);
    __exportStar(require_createWrappedNativeAccount(), exports2);
    __exportStar(require_freezeAccount2(), exports2);
    __exportStar(require_getOrCreateAssociatedTokenAccount(), exports2);
    __exportStar(require_mintTo2(), exports2);
    __exportStar(require_mintToChecked2(), exports2);
    __exportStar(require_recoverNested(), exports2);
    __exportStar(require_revoke2(), exports2);
    __exportStar(require_setAuthority2(), exports2);
    __exportStar(require_syncNative2(), exports2);
    __exportStar(require_thawAccount2(), exports2);
    __exportStar(require_transfer2(), exports2);
    __exportStar(require_transferChecked2(), exports2);
    __exportStar(require_uiAmountToAmount2(), exports2);
  }
});

// node_modules/@solana/spl-token/lib/cjs/instructions/initializeMint.js
var require_initializeMint = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/instructions/initializeMint.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.decodeInitializeMintInstructionUnchecked = exports2.decodeInitializeMintInstruction = exports2.createInitializeMintInstruction = exports2.initializeMintInstructionData = void 0;
    var buffer_layout_1 = require_Layout();
    var buffer_layout_utils_1 = require_cjs();
    var web3_js_1 = require("@solana/web3.js");
    var constants_js_1 = require_constants();
    var errors_js_1 = require_errors();
    var types_js_1 = require_types();
    exports2.initializeMintInstructionData = (0, buffer_layout_1.struct)([
      (0, buffer_layout_1.u8)("instruction"),
      (0, buffer_layout_1.u8)("decimals"),
      (0, buffer_layout_utils_1.publicKey)("mintAuthority"),
      (0, buffer_layout_1.u8)("freezeAuthorityOption"),
      (0, buffer_layout_utils_1.publicKey)("freezeAuthority")
    ]);
    function createInitializeMintInstruction(mint, decimals, mintAuthority, freezeAuthority, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      const keys = [
        { pubkey: mint, isSigner: false, isWritable: true },
        { pubkey: web3_js_1.SYSVAR_RENT_PUBKEY, isSigner: false, isWritable: false }
      ];
      const data = Buffer.alloc(exports2.initializeMintInstructionData.span);
      exports2.initializeMintInstructionData.encode({
        instruction: types_js_1.TokenInstruction.InitializeMint,
        decimals,
        mintAuthority,
        freezeAuthorityOption: freezeAuthority ? 1 : 0,
        freezeAuthority: freezeAuthority || new web3_js_1.PublicKey(0)
      }, data);
      return new web3_js_1.TransactionInstruction({ keys, programId, data });
    }
    exports2.createInitializeMintInstruction = createInitializeMintInstruction;
    function decodeInitializeMintInstruction(instruction, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      if (!instruction.programId.equals(programId))
        throw new errors_js_1.TokenInvalidInstructionProgramError();
      if (instruction.data.length !== exports2.initializeMintInstructionData.span)
        throw new errors_js_1.TokenInvalidInstructionDataError();
      const { keys: { mint, rent }, data } = decodeInitializeMintInstructionUnchecked(instruction);
      if (data.instruction !== types_js_1.TokenInstruction.InitializeMint)
        throw new errors_js_1.TokenInvalidInstructionTypeError();
      if (!mint || !rent)
        throw new errors_js_1.TokenInvalidInstructionKeysError();
      return {
        programId,
        keys: {
          mint,
          rent
        },
        data
      };
    }
    exports2.decodeInitializeMintInstruction = decodeInitializeMintInstruction;
    function decodeInitializeMintInstructionUnchecked({ programId, keys: [mint, rent], data }) {
      const { instruction, decimals, mintAuthority, freezeAuthorityOption, freezeAuthority } = exports2.initializeMintInstructionData.decode(data);
      return {
        programId,
        keys: {
          mint,
          rent
        },
        data: {
          instruction,
          decimals,
          mintAuthority,
          freezeAuthority: freezeAuthorityOption ? freezeAuthority : null
        }
      };
    }
    exports2.decodeInitializeMintInstructionUnchecked = decodeInitializeMintInstructionUnchecked;
  }
});

// node_modules/@solana/spl-token/lib/cjs/extensions/interestBearingMint/instructions.js
var require_instructions6 = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/extensions/interestBearingMint/instructions.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createUpdateRateInterestBearingMintInstruction = exports2.createInitializeInterestBearingMintInstruction = exports2.interestBearingMintUpdateRateInstructionData = exports2.interestBearingMintInitializeInstructionData = exports2.InterestBearingMintInstruction = void 0;
    var buffer_layout_1 = require_Layout();
    var buffer_layout_utils_1 = require_cjs();
    var web3_js_1 = require("@solana/web3.js");
    var constants_js_1 = require_constants();
    var internal_js_1 = require_internal();
    var types_js_1 = require_types();
    var InterestBearingMintInstruction;
    (function(InterestBearingMintInstruction2) {
      InterestBearingMintInstruction2[InterestBearingMintInstruction2["Initialize"] = 0] = "Initialize";
      InterestBearingMintInstruction2[InterestBearingMintInstruction2["UpdateRate"] = 1] = "UpdateRate";
    })(InterestBearingMintInstruction || (exports2.InterestBearingMintInstruction = InterestBearingMintInstruction = {}));
    exports2.interestBearingMintInitializeInstructionData = (0, buffer_layout_1.struct)([
      (0, buffer_layout_1.u8)("instruction"),
      (0, buffer_layout_1.u8)("interestBearingMintInstruction"),
      // TODO: Make this an optional public key
      (0, buffer_layout_utils_1.publicKey)("rateAuthority"),
      (0, buffer_layout_1.s16)("rate")
    ]);
    exports2.interestBearingMintUpdateRateInstructionData = (0, buffer_layout_1.struct)([
      (0, buffer_layout_1.u8)("instruction"),
      (0, buffer_layout_1.u8)("interestBearingMintInstruction"),
      (0, buffer_layout_1.s16)("rate")
    ]);
    function createInitializeInterestBearingMintInstruction(mint, rateAuthority, rate, programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
      const keys = [{ pubkey: mint, isSigner: false, isWritable: true }];
      const data = Buffer.alloc(exports2.interestBearingMintInitializeInstructionData.span);
      exports2.interestBearingMintInitializeInstructionData.encode({
        instruction: types_js_1.TokenInstruction.InterestBearingMintExtension,
        interestBearingMintInstruction: InterestBearingMintInstruction.Initialize,
        rateAuthority,
        rate
      }, data);
      return new web3_js_1.TransactionInstruction({ keys, programId, data });
    }
    exports2.createInitializeInterestBearingMintInstruction = createInitializeInterestBearingMintInstruction;
    function createUpdateRateInterestBearingMintInstruction(mint, rateAuthority, rate, multiSigners = [], programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
      const keys = (0, internal_js_1.addSigners)([
        { pubkey: mint, isSigner: false, isWritable: true },
        { pubkey: rateAuthority, isSigner: !multiSigners.length, isWritable: false }
      ], rateAuthority, multiSigners);
      const data = Buffer.alloc(exports2.interestBearingMintUpdateRateInstructionData.span);
      exports2.interestBearingMintUpdateRateInstructionData.encode({
        instruction: types_js_1.TokenInstruction.InterestBearingMintExtension,
        interestBearingMintInstruction: InterestBearingMintInstruction.UpdateRate,
        rate
      }, data);
      return new web3_js_1.TransactionInstruction({ keys, programId, data });
    }
    exports2.createUpdateRateInterestBearingMintInstruction = createUpdateRateInterestBearingMintInstruction;
  }
});

// node_modules/@solana/spl-token/lib/cjs/extensions/interestBearingMint/actions.js
var require_actions7 = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/extensions/interestBearingMint/actions.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.updateRateInterestBearingMint = exports2.createInterestBearingMint = void 0;
    var web3_js_1 = require("@solana/web3.js");
    var internal_js_1 = require_internal2();
    var constants_js_1 = require_constants();
    var initializeMint_js_1 = require_initializeMint();
    var extensionType_js_1 = require_extensionType();
    var instructions_js_1 = require_instructions6();
    function createInterestBearingMint(connection, payer, mintAuthority, freezeAuthority, rateAuthority, rate, decimals, keypair = web3_js_1.Keypair.generate(), confirmOptions, programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
      return __awaiter(this, void 0, void 0, function* () {
        const mintLen = (0, extensionType_js_1.getMintLen)([extensionType_js_1.ExtensionType.InterestBearingConfig]);
        const lamports = yield connection.getMinimumBalanceForRentExemption(mintLen);
        const transaction = new web3_js_1.Transaction().add(web3_js_1.SystemProgram.createAccount({
          fromPubkey: payer.publicKey,
          newAccountPubkey: keypair.publicKey,
          space: mintLen,
          lamports,
          programId
        }), (0, instructions_js_1.createInitializeInterestBearingMintInstruction)(keypair.publicKey, rateAuthority, rate, programId), (0, initializeMint_js_1.createInitializeMintInstruction)(keypair.publicKey, decimals, mintAuthority, freezeAuthority, programId));
        yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer, keypair], confirmOptions);
        return keypair.publicKey;
      });
    }
    exports2.createInterestBearingMint = createInterestBearingMint;
    function updateRateInterestBearingMint(connection, payer, mint, rateAuthority, rate, multiSigners = [], confirmOptions, programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
      return __awaiter(this, void 0, void 0, function* () {
        const [rateAuthorityPublicKey, signers] = (0, internal_js_1.getSigners)(rateAuthority, multiSigners);
        const transaction = new web3_js_1.Transaction().add((0, instructions_js_1.createUpdateRateInterestBearingMintInstruction)(mint, rateAuthorityPublicKey, rate, signers, programId));
        return yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer, rateAuthority, ...signers], confirmOptions);
      });
    }
    exports2.updateRateInterestBearingMint = updateRateInterestBearingMint;
  }
});

// node_modules/@solana/spl-token/lib/cjs/extensions/interestBearingMint/index.js
var require_interestBearingMint = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/extensions/interestBearingMint/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_actions7(), exports2);
    __exportStar(require_instructions6(), exports2);
    __exportStar(require_state3(), exports2);
  }
});

// node_modules/@solana/spl-token/lib/cjs/extensions/metadataPointer/instructions.js
var require_instructions7 = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/extensions/metadataPointer/instructions.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createUpdateMetadataPointerInstruction = exports2.updateMetadataPointerData = exports2.createInitializeMetadataPointerInstruction = exports2.initializeMetadataPointerData = exports2.MetadataPointerInstruction = void 0;
    var buffer_layout_1 = require_Layout();
    var buffer_layout_utils_1 = require_cjs();
    var web3_js_1 = require("@solana/web3.js");
    var constants_js_1 = require_constants();
    var errors_js_1 = require_errors();
    var types_js_1 = require_types();
    var internal_js_1 = require_internal();
    var MetadataPointerInstruction;
    (function(MetadataPointerInstruction2) {
      MetadataPointerInstruction2[MetadataPointerInstruction2["Initialize"] = 0] = "Initialize";
      MetadataPointerInstruction2[MetadataPointerInstruction2["Update"] = 1] = "Update";
    })(MetadataPointerInstruction || (exports2.MetadataPointerInstruction = MetadataPointerInstruction = {}));
    exports2.initializeMetadataPointerData = (0, buffer_layout_1.struct)([
      // prettier-ignore
      (0, buffer_layout_1.u8)("instruction"),
      (0, buffer_layout_1.u8)("metadataPointerInstruction"),
      (0, buffer_layout_utils_1.publicKey)("authority"),
      (0, buffer_layout_utils_1.publicKey)("metadataAddress")
    ]);
    function createInitializeMetadataPointerInstruction(mint, authority, metadataAddress, programId) {
      if (!(0, constants_js_1.programSupportsExtensions)(programId)) {
        throw new errors_js_1.TokenUnsupportedInstructionError();
      }
      const keys = [{ pubkey: mint, isSigner: false, isWritable: true }];
      const data = Buffer.alloc(exports2.initializeMetadataPointerData.span);
      exports2.initializeMetadataPointerData.encode({
        instruction: types_js_1.TokenInstruction.MetadataPointerExtension,
        metadataPointerInstruction: MetadataPointerInstruction.Initialize,
        authority: authority !== null && authority !== void 0 ? authority : web3_js_1.PublicKey.default,
        metadataAddress: metadataAddress !== null && metadataAddress !== void 0 ? metadataAddress : web3_js_1.PublicKey.default
      }, data);
      return new web3_js_1.TransactionInstruction({ keys, programId, data });
    }
    exports2.createInitializeMetadataPointerInstruction = createInitializeMetadataPointerInstruction;
    exports2.updateMetadataPointerData = (0, buffer_layout_1.struct)([
      // prettier-ignore
      (0, buffer_layout_1.u8)("instruction"),
      (0, buffer_layout_1.u8)("metadataPointerInstruction"),
      (0, buffer_layout_utils_1.publicKey)("metadataAddress")
    ]);
    function createUpdateMetadataPointerInstruction(mint, authority, metadataAddress, multiSigners = [], programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
      if (!(0, constants_js_1.programSupportsExtensions)(programId)) {
        throw new errors_js_1.TokenUnsupportedInstructionError();
      }
      const keys = (0, internal_js_1.addSigners)([{ pubkey: mint, isSigner: false, isWritable: true }], authority, multiSigners);
      const data = Buffer.alloc(exports2.updateMetadataPointerData.span);
      exports2.updateMetadataPointerData.encode({
        instruction: types_js_1.TokenInstruction.MetadataPointerExtension,
        metadataPointerInstruction: MetadataPointerInstruction.Update,
        metadataAddress: metadataAddress !== null && metadataAddress !== void 0 ? metadataAddress : web3_js_1.PublicKey.default
      }, data);
      return new web3_js_1.TransactionInstruction({ keys, programId, data });
    }
    exports2.createUpdateMetadataPointerInstruction = createUpdateMetadataPointerInstruction;
  }
});

// node_modules/@solana/spl-token/lib/cjs/extensions/metadataPointer/index.js
var require_metadataPointer = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/extensions/metadataPointer/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_instructions7(), exports2);
    __exportStar(require_state5(), exports2);
  }
});

// node_modules/@solana/spl-token-metadata/lib/cjs/errors.js
var require_errors2 = __commonJS({
  "node_modules/@solana/spl-token-metadata/lib/cjs/errors.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.KeyNotFoundError = exports2.ImmutableMetadataError = exports2.IncorrectUpdateAuthorityError = exports2.IncorrectMintAuthorityError = exports2.MintHasNoMintAuthorityError = exports2.IncorrectAccountError = exports2.TokenMetadataError = void 0;
    var TokenMetadataError = class extends Error {
      constructor(message) {
        super(message);
      }
    };
    exports2.TokenMetadataError = TokenMetadataError;
    var IncorrectAccountError = class extends TokenMetadataError {
      constructor() {
        super(...arguments);
        this.name = "IncorrectAccountError";
      }
    };
    exports2.IncorrectAccountError = IncorrectAccountError;
    var MintHasNoMintAuthorityError = class extends TokenMetadataError {
      constructor() {
        super(...arguments);
        this.name = "MintHasNoMintAuthorityError";
      }
    };
    exports2.MintHasNoMintAuthorityError = MintHasNoMintAuthorityError;
    var IncorrectMintAuthorityError = class extends TokenMetadataError {
      constructor() {
        super(...arguments);
        this.name = "IncorrectMintAuthorityError";
      }
    };
    exports2.IncorrectMintAuthorityError = IncorrectMintAuthorityError;
    var IncorrectUpdateAuthorityError = class extends TokenMetadataError {
      constructor() {
        super(...arguments);
        this.name = "IncorrectUpdateAuthorityError";
      }
    };
    exports2.IncorrectUpdateAuthorityError = IncorrectUpdateAuthorityError;
    var ImmutableMetadataError = class extends TokenMetadataError {
      constructor() {
        super(...arguments);
        this.name = "ImmutableMetadataError";
      }
    };
    exports2.ImmutableMetadataError = ImmutableMetadataError;
    var KeyNotFoundError = class extends TokenMetadataError {
      constructor() {
        super(...arguments);
        this.name = "KeyNotFoundError";
      }
    };
    exports2.KeyNotFoundError = KeyNotFoundError;
  }
});

// node_modules/@solana/errors/dist/index.node.cjs
var require_index_node = __commonJS({
  "node_modules/@solana/errors/dist/index.node.cjs"(exports2) {
    "use strict";
    var SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED = 1;
    var SOLANA_ERROR__INVALID_NONCE = 2;
    var SOLANA_ERROR__NONCE_ACCOUNT_NOT_FOUND = 3;
    var SOLANA_ERROR__BLOCKHASH_STRING_LENGTH_OUT_OF_RANGE = 4;
    var SOLANA_ERROR__INVALID_BLOCKHASH_BYTE_LENGTH = 5;
    var SOLANA_ERROR__LAMPORTS_OUT_OF_RANGE = 6;
    var SOLANA_ERROR__MALFORMED_BIGINT_STRING = 7;
    var SOLANA_ERROR__MALFORMED_NUMBER_STRING = 8;
    var SOLANA_ERROR__TIMESTAMP_OUT_OF_RANGE = 9;
    var SOLANA_ERROR__JSON_RPC__PARSE_ERROR = -32700;
    var SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR = -32603;
    var SOLANA_ERROR__JSON_RPC__INVALID_PARAMS = -32602;
    var SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND = -32601;
    var SOLANA_ERROR__JSON_RPC__INVALID_REQUEST = -32600;
    var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED = -32016;
    var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION = -32015;
    var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET = -32014;
    var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH = -32013;
    var SOLANA_ERROR__JSON_RPC__SCAN_ERROR = -32012;
    var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE = -32011;
    var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX = -32010;
    var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED = -32009;
    var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NO_SNAPSHOT = -32008;
    var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED = -32007;
    var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE = -32006;
    var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NODE_UNHEALTHY = -32005;
    var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE = -32004;
    var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE = -32003;
    var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE = -32002;
    var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP = -32001;
    var SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH = 28e5;
    var SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE = 2800001;
    var SOLANA_ERROR__ADDRESSES__INVALID_BASE58_ENCODED_ADDRESS = 2800002;
    var SOLANA_ERROR__ADDRESSES__INVALID_ED25519_PUBLIC_KEY = 2800003;
    var SOLANA_ERROR__ADDRESSES__MALFORMED_PDA = 2800004;
    var SOLANA_ERROR__ADDRESSES__PDA_BUMP_SEED_OUT_OF_RANGE = 2800005;
    var SOLANA_ERROR__ADDRESSES__MAX_NUMBER_OF_PDA_SEEDS_EXCEEDED = 2800006;
    var SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED = 2800007;
    var SOLANA_ERROR__ADDRESSES__INVALID_SEEDS_POINT_ON_CURVE = 2800008;
    var SOLANA_ERROR__ADDRESSES__FAILED_TO_FIND_VIABLE_PDA_BUMP_SEED = 2800009;
    var SOLANA_ERROR__ADDRESSES__PDA_ENDS_WITH_PDA_MARKER = 2800010;
    var SOLANA_ERROR__ACCOUNTS__ACCOUNT_NOT_FOUND = 323e4;
    var SOLANA_ERROR__ACCOUNTS__ONE_OR_MORE_ACCOUNTS_NOT_FOUND = 32300001;
    var SOLANA_ERROR__ACCOUNTS__FAILED_TO_DECODE_ACCOUNT = 3230002;
    var SOLANA_ERROR__ACCOUNTS__EXPECTED_DECODED_ACCOUNT = 3230003;
    var SOLANA_ERROR__ACCOUNTS__EXPECTED_ALL_ACCOUNTS_TO_BE_DECODED = 3230004;
    var SOLANA_ERROR__SUBTLE_CRYPTO__DISALLOWED_IN_INSECURE_CONTEXT = 361e4;
    var SOLANA_ERROR__SUBTLE_CRYPTO__DIGEST_UNIMPLEMENTED = 3610001;
    var SOLANA_ERROR__SUBTLE_CRYPTO__ED25519_ALGORITHM_UNIMPLEMENTED = 3610002;
    var SOLANA_ERROR__SUBTLE_CRYPTO__EXPORT_FUNCTION_UNIMPLEMENTED = 3610003;
    var SOLANA_ERROR__SUBTLE_CRYPTO__GENERATE_FUNCTION_UNIMPLEMENTED = 3610004;
    var SOLANA_ERROR__SUBTLE_CRYPTO__SIGN_FUNCTION_UNIMPLEMENTED = 3610005;
    var SOLANA_ERROR__SUBTLE_CRYPTO__VERIFY_FUNCTION_UNIMPLEMENTED = 3610006;
    var SOLANA_ERROR__SUBTLE_CRYPTO__CANNOT_EXPORT_NON_EXTRACTABLE_KEY = 3610007;
    var SOLANA_ERROR__CRYPTO__RANDOM_VALUES_FUNCTION_UNIMPLEMENTED = 3611e3;
    var SOLANA_ERROR__KEYS__INVALID_KEY_PAIR_BYTE_LENGTH = 3704e3;
    var SOLANA_ERROR__KEYS__INVALID_PRIVATE_KEY_BYTE_LENGTH = 3704001;
    var SOLANA_ERROR__KEYS__INVALID_SIGNATURE_BYTE_LENGTH = 3704002;
    var SOLANA_ERROR__KEYS__SIGNATURE_STRING_LENGTH_OUT_OF_RANGE = 3704003;
    var SOLANA_ERROR__KEYS__PUBLIC_KEY_MUST_MATCH_PRIVATE_KEY = 3704004;
    var SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_ACCOUNTS = 4128e3;
    var SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_DATA = 4128001;
    var SOLANA_ERROR__INSTRUCTION__PROGRAM_ID_MISMATCH = 4128002;
    var SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN = 4615e3;
    var SOLANA_ERROR__INSTRUCTION_ERROR__GENERIC_ERROR = 4615001;
    var SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ARGUMENT = 4615002;
    var SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_INSTRUCTION_DATA = 4615003;
    var SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_DATA = 4615004;
    var SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_TOO_SMALL = 4615005;
    var SOLANA_ERROR__INSTRUCTION_ERROR__INSUFFICIENT_FUNDS = 4615006;
    var SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_PROGRAM_ID = 4615007;
    var SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_REQUIRED_SIGNATURE = 4615008;
    var SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_ALREADY_INITIALIZED = 4615009;
    var SOLANA_ERROR__INSTRUCTION_ERROR__UNINITIALIZED_ACCOUNT = 4615010;
    var SOLANA_ERROR__INSTRUCTION_ERROR__UNBALANCED_INSTRUCTION = 4615011;
    var SOLANA_ERROR__INSTRUCTION_ERROR__MODIFIED_PROGRAM_ID = 4615012;
    var SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_LAMPORT_SPEND = 4615013;
    var SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_DATA_MODIFIED = 4615014;
    var SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_LAMPORT_CHANGE = 4615015;
    var SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_DATA_MODIFIED = 4615016;
    var SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_INDEX = 4615017;
    var SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_MODIFIED = 4615018;
    var SOLANA_ERROR__INSTRUCTION_ERROR__RENT_EPOCH_MODIFIED = 4615019;
    var SOLANA_ERROR__INSTRUCTION_ERROR__NOT_ENOUGH_ACCOUNT_KEYS = 4615020;
    var SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_SIZE_CHANGED = 4615021;
    var SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_EXECUTABLE = 4615022;
    var SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_FAILED = 4615023;
    var SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_OUTSTANDING = 4615024;
    var SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_OUT_OF_SYNC = 4615025;
    var SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM = 4615026;
    var SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ERROR = 4615027;
    var SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_DATA_MODIFIED = 4615028;
    var SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_LAMPORT_CHANGE = 4615029;
    var SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_ACCOUNT_NOT_RENT_EXEMPT = 4615030;
    var SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_PROGRAM_ID = 4615031;
    var SOLANA_ERROR__INSTRUCTION_ERROR__CALL_DEPTH = 4615032;
    var SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_ACCOUNT = 4615033;
    var SOLANA_ERROR__INSTRUCTION_ERROR__REENTRANCY_NOT_ALLOWED = 4615034;
    var SOLANA_ERROR__INSTRUCTION_ERROR__MAX_SEED_LENGTH_EXCEEDED = 4615035;
    var SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_SEEDS = 4615036;
    var SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_REALLOC = 4615037;
    var SOLANA_ERROR__INSTRUCTION_ERROR__COMPUTATIONAL_BUDGET_EXCEEDED = 4615038;
    var SOLANA_ERROR__INSTRUCTION_ERROR__PRIVILEGE_ESCALATION = 4615039;
    var SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_ENVIRONMENT_SETUP_FAILURE = 4615040;
    var SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPLETE = 4615041;
    var SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPILE = 4615042;
    var SOLANA_ERROR__INSTRUCTION_ERROR__IMMUTABLE = 4615043;
    var SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_AUTHORITY = 4615044;
    var SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR = 4615045;
    var SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_RENT_EXEMPT = 4615046;
    var SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_OWNER = 4615047;
    var SOLANA_ERROR__INSTRUCTION_ERROR__ARITHMETIC_OVERFLOW = 4615048;
    var SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_SYSVAR = 4615049;
    var SOLANA_ERROR__INSTRUCTION_ERROR__ILLEGAL_OWNER = 4615050;
    var SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_DATA_ALLOCATIONS_EXCEEDED = 4615051;
    var SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_EXCEEDED = 4615052;
    var SOLANA_ERROR__INSTRUCTION_ERROR__MAX_INSTRUCTION_TRACE_LENGTH_EXCEEDED = 4615053;
    var SOLANA_ERROR__INSTRUCTION_ERROR__BUILTIN_PROGRAMS_MUST_CONSUME_COMPUTE_UNITS = 4615054;
    var SOLANA_ERROR__SIGNER__ADDRESS_CANNOT_HAVE_MULTIPLE_SIGNERS = 5508e3;
    var SOLANA_ERROR__SIGNER__EXPECTED_KEY_PAIR_SIGNER = 5508001;
    var SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_SIGNER = 5508002;
    var SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_MODIFYING_SIGNER = 5508003;
    var SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_PARTIAL_SIGNER = 5508004;
    var SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SIGNER = 5508005;
    var SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_MODIFYING_SIGNER = 5508006;
    var SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_PARTIAL_SIGNER = 5508007;
    var SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SENDING_SIGNER = 5508008;
    var SOLANA_ERROR__SIGNER__TRANSACTION_CANNOT_HAVE_MULTIPLE_SENDING_SIGNERS = 5508009;
    var SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING = 5508010;
    var SOLANA_ERROR__SIGNER__WALLET_MULTISIGN_UNIMPLEMENTED = 5508011;
    var SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES = 5663e3;
    var SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE = 5663001;
    var SOLANA_ERROR__TRANSACTION__EXPECTED_BLOCKHASH_LIFETIME = 5663002;
    var SOLANA_ERROR__TRANSACTION__EXPECTED_NONCE_LIFETIME = 5663003;
    var SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE = 5663004;
    var SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING = 5663005;
    var SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE = 5663006;
    var SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND = 5663007;
    var SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_FEE_PAYER_MISSING = 5663008;
    var SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING = 5663009;
    var SOLANA_ERROR__TRANSACTION__ADDRESS_MISSING = 5663010;
    var SOLANA_ERROR__TRANSACTION__FEE_PAYER_MISSING = 5663011;
    var SOLANA_ERROR__TRANSACTION__FEE_PAYER_SIGNATURE_MISSING = 5663012;
    var SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_INSTRUCTIONS_MISSING = 5663013;
    var SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_FIRST_INSTRUCTION_MUST_BE_ADVANCE_NONCE = 5663014;
    var SOLANA_ERROR__TRANSACTION__ADDRESSES_CANNOT_SIGN_TRANSACTION = 5663015;
    var SOLANA_ERROR__TRANSACTION__CANNOT_ENCODE_WITH_EMPTY_SIGNATURES = 5663016;
    var SOLANA_ERROR__TRANSACTION__MESSAGE_SIGNATURES_MISMATCH = 5663017;
    var SOLANA_ERROR__TRANSACTION__FAILED_TO_ESTIMATE_COMPUTE_LIMIT = 5663018;
    var SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN = 705e4;
    var SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_IN_USE = 7050001;
    var SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_LOADED_TWICE = 7050002;
    var SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_NOT_FOUND = 7050003;
    var SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_ACCOUNT_NOT_FOUND = 7050004;
    var SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_FEE = 7050005;
    var SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_FOR_FEE = 7050006;
    var SOLANA_ERROR__TRANSACTION_ERROR__ALREADY_PROCESSED = 7050007;
    var SOLANA_ERROR__TRANSACTION_ERROR__BLOCKHASH_NOT_FOUND = 7050008;
    var SOLANA_ERROR__TRANSACTION_ERROR__CALL_CHAIN_TOO_DEEP = 7050009;
    var SOLANA_ERROR__TRANSACTION_ERROR__MISSING_SIGNATURE_FOR_FEE = 7050010;
    var SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_INDEX = 7050011;
    var SOLANA_ERROR__TRANSACTION_ERROR__SIGNATURE_FAILURE = 7050012;
    var SOLANA_ERROR__TRANSACTION_ERROR__INVALID_PROGRAM_FOR_EXECUTION = 7050013;
    var SOLANA_ERROR__TRANSACTION_ERROR__SANITIZE_FAILURE = 7050014;
    var SOLANA_ERROR__TRANSACTION_ERROR__CLUSTER_MAINTENANCE = 7050015;
    var SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_BORROW_OUTSTANDING = 7050016;
    var SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_BLOCK_COST_LIMIT = 7050017;
    var SOLANA_ERROR__TRANSACTION_ERROR__UNSUPPORTED_VERSION = 7050018;
    var SOLANA_ERROR__TRANSACTION_ERROR__INVALID_WRITABLE_ACCOUNT = 7050019;
    var SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_ACCOUNT_COST_LIMIT = 7050020;
    var SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_BLOCK_LIMIT = 7050021;
    var SOLANA_ERROR__TRANSACTION_ERROR__TOO_MANY_ACCOUNT_LOCKS = 7050022;
    var SOLANA_ERROR__TRANSACTION_ERROR__ADDRESS_LOOKUP_TABLE_NOT_FOUND = 7050023;
    var SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_OWNER = 7050024;
    var SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_DATA = 7050025;
    var SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_INDEX = 7050026;
    var SOLANA_ERROR__TRANSACTION_ERROR__INVALID_RENT_PAYING_ACCOUNT = 7050027;
    var SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_VOTE_COST_LIMIT = 7050028;
    var SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_TOTAL_LIMIT = 7050029;
    var SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION = 7050030;
    var SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT = 7050031;
    var SOLANA_ERROR__TRANSACTION_ERROR__MAX_LOADED_ACCOUNTS_DATA_SIZE_EXCEEDED = 7050032;
    var SOLANA_ERROR__TRANSACTION_ERROR__INVALID_LOADED_ACCOUNTS_DATA_SIZE_LIMIT = 7050033;
    var SOLANA_ERROR__TRANSACTION_ERROR__RESANITIZATION_NEEDED = 7050034;
    var SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED = 7050035;
    var SOLANA_ERROR__TRANSACTION_ERROR__UNBALANCED_TRANSACTION = 7050036;
    var SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY = 8078e3;
    var SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH = 8078001;
    var SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH = 8078002;
    var SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH = 8078003;
    var SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH = 8078004;
    var SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH = 8078005;
    var SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH = 8078006;
    var SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS = 8078007;
    var SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE = 8078008;
    var SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT = 8078009;
    var SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT = 8078010;
    var SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE = 8078011;
    var SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE = 8078012;
    var SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH = 8078013;
    var SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE = 8078014;
    var SOLANA_ERROR__CODECS__INVALID_LITERAL_UNION_VARIANT = 8078015;
    var SOLANA_ERROR__CODECS__LITERAL_UNION_DISCRIMINATOR_OUT_OF_RANGE = 8078016;
    var SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE = 8078017;
    var SOLANA_ERROR__CODECS__INVALID_CONSTANT = 8078018;
    var SOLANA_ERROR__CODECS__EXPECTED_ZERO_VALUE_TO_MATCH_ITEM_FIXED_SIZE = 8078019;
    var SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL = 8078020;
    var SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES = 8078021;
    var SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS = 8078022;
    var SOLANA_ERROR__RPC__INTEGER_OVERFLOW = 81e5;
    var SOLANA_ERROR__RPC__TRANSPORT_HTTP_HEADER_FORBIDDEN = 8100001;
    var SOLANA_ERROR__RPC__TRANSPORT_HTTP_ERROR = 8100002;
    var SOLANA_ERROR__RPC_SUBSCRIPTIONS__CANNOT_CREATE_SUBSCRIPTION_REQUEST = 819e4;
    var SOLANA_ERROR__RPC_SUBSCRIPTIONS__EXPECTED_SERVER_SUBSCRIPTION_ID = 8190001;
    var SOLANA_ERROR__RPC_SUBSCRIPTIONS__TRANSPORT_CLOSED_BEFORE_MESSAGE_BUFFERED = 8190002;
    var SOLANA_ERROR__RPC_SUBSCRIPTIONS__TRANSPORT_CONNECTION_CLOSED = 8190003;
    var SOLANA_ERROR__RPC_SUBSCRIPTIONS__TRANSPORT_FAILED_TO_CONNECT = 8190004;
    var SOLANA_ERROR__INVARIANT_VIOLATION__WEBSOCKET_MESSAGE_ITERATOR_STATE_MISSING = 99e5;
    var SOLANA_ERROR__INVARIANT_VIOLATION__WEBSOCKET_MESSAGE_ITERATOR_MUST_NOT_POLL_BEFORE_RESOLVING_EXISTING_MESSAGE_PROMISE = 9900001;
    var SOLANA_ERROR__INVARIANT_VIOLATION__CACHED_ABORTABLE_ITERABLE_CACHE_ENTRY_MISSING = 9900002;
    var SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE = 9900003;
    function encodeValue(value) {
      if (Array.isArray(value)) {
        const commaSeparatedValues = value.map(encodeValue).join(
          "%2C%20"
          /* ", " */
        );
        return "%5B" + commaSeparatedValues + /* "]" */
        "%5D";
      } else if (typeof value === "bigint") {
        return `${value}n`;
      } else {
        return encodeURIComponent(
          String(
            value != null && Object.getPrototypeOf(value) === null ? (
              // Plain objects with no prototype don't have a `toString` method.
              // Convert them before stringifying them.
              { ...value }
            ) : value
          )
        );
      }
    }
    function encodeObjectContextEntry([key, value]) {
      return `${key}=${encodeValue(value)}`;
    }
    function encodeContextObject(context) {
      const searchParamsString = Object.entries(context).map(encodeObjectContextEntry).join("&");
      return Buffer.from(searchParamsString, "utf8").toString("base64");
    }
    var SolanaErrorMessages = {
      [SOLANA_ERROR__ACCOUNTS__ACCOUNT_NOT_FOUND]: "Account not found at address: $address",
      [SOLANA_ERROR__ACCOUNTS__EXPECTED_ALL_ACCOUNTS_TO_BE_DECODED]: "Not all accounts were decoded. Encoded accounts found at addresses: $addresses.",
      [SOLANA_ERROR__ACCOUNTS__EXPECTED_DECODED_ACCOUNT]: "Expected decoded account at address: $address",
      [SOLANA_ERROR__ACCOUNTS__FAILED_TO_DECODE_ACCOUNT]: "Failed to decode account data at address: $address",
      [SOLANA_ERROR__ACCOUNTS__ONE_OR_MORE_ACCOUNTS_NOT_FOUND]: "Accounts not found at addresses: $addresses",
      [SOLANA_ERROR__ADDRESSES__FAILED_TO_FIND_VIABLE_PDA_BUMP_SEED]: "Unable to find a viable program address bump seed.",
      [SOLANA_ERROR__ADDRESSES__INVALID_BASE58_ENCODED_ADDRESS]: "$putativeAddress is not a base58-encoded address.",
      [SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH]: "Expected base58 encoded address to decode to a byte array of length 32. Actual length: $actualLength.",
      [SOLANA_ERROR__ADDRESSES__INVALID_ED25519_PUBLIC_KEY]: "The `CryptoKey` must be an `Ed25519` public key.",
      [SOLANA_ERROR__ADDRESSES__INVALID_SEEDS_POINT_ON_CURVE]: "Invalid seeds; point must fall off the Ed25519 curve.",
      [SOLANA_ERROR__ADDRESSES__MALFORMED_PDA]: "Expected given program derived address to have the following format: [Address, ProgramDerivedAddressBump].",
      [SOLANA_ERROR__ADDRESSES__MAX_NUMBER_OF_PDA_SEEDS_EXCEEDED]: "A maximum of $maxSeeds seeds, including the bump seed, may be supplied when creating an address. Received: $actual.",
      [SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED]: "The seed at index $index with length $actual exceeds the maximum length of $maxSeedLength bytes.",
      [SOLANA_ERROR__ADDRESSES__PDA_BUMP_SEED_OUT_OF_RANGE]: "Expected program derived address bump to be in the range [0, 255], got: $bump.",
      [SOLANA_ERROR__ADDRESSES__PDA_ENDS_WITH_PDA_MARKER]: "Program address cannot end with PDA marker.",
      [SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE]: "Expected base58-encoded address string of length in the range [32, 44]. Actual length: $actualLength.",
      [SOLANA_ERROR__BLOCKHASH_STRING_LENGTH_OUT_OF_RANGE]: "Expected base58-encoded blockash string of length in the range [32, 44]. Actual length: $actualLength.",
      [SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED]: "The network has progressed past the last block for which this transaction could have been committed.",
      [SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY]: "Codec [$codecDescription] cannot decode empty byte arrays.",
      [SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS]: "Enum codec cannot use lexical values [$stringValues] as discriminators. Either remove all lexical values or set `useValuesAsDiscriminators` to `false`.",
      [SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL]: "Sentinel [$hexSentinel] must not be present in encoded bytes [$hexEncodedBytes].",
      [SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH]: "Encoder and decoder must have the same fixed size, got [$encoderFixedSize] and [$decoderFixedSize].",
      [SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH]: "Encoder and decoder must have the same max size, got [$encoderMaxSize] and [$decoderMaxSize].",
      [SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH]: "Encoder and decoder must either both be fixed-size or variable-size.",
      [SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE]: "Enum discriminator out of range. Expected a number in [$formattedValidDiscriminators], got $discriminator.",
      [SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH]: "Expected a fixed-size codec, got a variable-size one.",
      [SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH]: "Codec [$codecDescription] expected a positive byte length, got $bytesLength.",
      [SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH]: "Expected a variable-size codec, got a fixed-size one.",
      [SOLANA_ERROR__CODECS__EXPECTED_ZERO_VALUE_TO_MATCH_ITEM_FIXED_SIZE]: "Codec [$codecDescription] expected zero-value [$hexZeroValue] to have the same size as the provided fixed-size item [$expectedSize bytes].",
      [SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH]: "Codec [$codecDescription] expected $expected bytes, got $bytesLength.",
      [SOLANA_ERROR__CODECS__INVALID_CONSTANT]: "Expected byte array constant [$hexConstant] to be present in data [$hexData] at offset [$offset].",
      [SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT]: "Invalid discriminated union variant. Expected one of [$variants], got $value.",
      [SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT]: "Invalid enum variant. Expected one of [$stringValues] or a number in [$formattedNumericalValues], got $variant.",
      [SOLANA_ERROR__CODECS__INVALID_LITERAL_UNION_VARIANT]: "Invalid literal union variant. Expected one of [$variants], got $value.",
      [SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS]: "Expected [$codecDescription] to have $expected items, got $actual.",
      [SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE]: "Invalid value $value for base $base with alphabet $alphabet.",
      [SOLANA_ERROR__CODECS__LITERAL_UNION_DISCRIMINATOR_OUT_OF_RANGE]: "Literal union discriminator out of range. Expected a number between $minRange and $maxRange, got $discriminator.",
      [SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE]: "Codec [$codecDescription] expected number to be in the range [$min, $max], got $value.",
      [SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE]: "Codec [$codecDescription] expected offset to be in the range [0, $bytesLength], got $offset.",
      [SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES]: "Expected sentinel [$hexSentinel] to be present in decoded bytes [$hexDecodedBytes].",
      [SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE]: "Union variant out of range. Expected an index between $minRange and $maxRange, got $variant.",
      [SOLANA_ERROR__CRYPTO__RANDOM_VALUES_FUNCTION_UNIMPLEMENTED]: "No random values implementation could be found.",
      [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_ALREADY_INITIALIZED]: "instruction requires an uninitialized account",
      [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_FAILED]: "instruction tries to borrow reference for an account which is already borrowed",
      [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_OUTSTANDING]: "instruction left account with an outstanding borrowed reference",
      [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_SIZE_CHANGED]: "program other than the account's owner changed the size of the account data",
      [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_TOO_SMALL]: "account data too small for instruction",
      [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_EXECUTABLE]: "instruction expected an executable account",
      [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_RENT_EXEMPT]: "An account does not have enough lamports to be rent-exempt",
      [SOLANA_ERROR__INSTRUCTION_ERROR__ARITHMETIC_OVERFLOW]: "Program arithmetic overflowed",
      [SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR]: "Failed to serialize or deserialize account data: $encodedData",
      [SOLANA_ERROR__INSTRUCTION_ERROR__BUILTIN_PROGRAMS_MUST_CONSUME_COMPUTE_UNITS]: "Builtin programs must consume compute units",
      [SOLANA_ERROR__INSTRUCTION_ERROR__CALL_DEPTH]: "Cross-program invocation call depth too deep",
      [SOLANA_ERROR__INSTRUCTION_ERROR__COMPUTATIONAL_BUDGET_EXCEEDED]: "Computational budget exceeded",
      [SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM]: "custom program error: #$code",
      [SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_INDEX]: "instruction contains duplicate accounts",
      [SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_OUT_OF_SYNC]: "instruction modifications of multiply-passed account differ",
      [SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_ACCOUNT_NOT_RENT_EXEMPT]: "executable accounts must be rent exempt",
      [SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_DATA_MODIFIED]: "instruction changed executable accounts data",
      [SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_LAMPORT_CHANGE]: "instruction changed the balance of an executable account",
      [SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_MODIFIED]: "instruction changed executable bit of an account",
      [SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_DATA_MODIFIED]: "instruction modified data of an account it does not own",
      [SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_LAMPORT_SPEND]: "instruction spent from the balance of an account it does not own",
      [SOLANA_ERROR__INSTRUCTION_ERROR__GENERIC_ERROR]: "generic instruction error",
      [SOLANA_ERROR__INSTRUCTION_ERROR__ILLEGAL_OWNER]: "Provided owner is not allowed",
      [SOLANA_ERROR__INSTRUCTION_ERROR__IMMUTABLE]: "Account is immutable",
      [SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_AUTHORITY]: "Incorrect authority provided",
      [SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_PROGRAM_ID]: "incorrect program id for instruction",
      [SOLANA_ERROR__INSTRUCTION_ERROR__INSUFFICIENT_FUNDS]: "insufficient funds for instruction",
      [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_DATA]: "invalid account data for instruction",
      [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_OWNER]: "Invalid account owner",
      [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ARGUMENT]: "invalid program argument",
      [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ERROR]: "program returned invalid error code",
      [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_INSTRUCTION_DATA]: "invalid instruction data",
      [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_REALLOC]: "Failed to reallocate account data",
      [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_SEEDS]: "Provided seeds do not result in a valid address",
      [SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_DATA_ALLOCATIONS_EXCEEDED]: "Accounts data allocations exceeded the maximum allowed per transaction",
      [SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_EXCEEDED]: "Max accounts exceeded",
      [SOLANA_ERROR__INSTRUCTION_ERROR__MAX_INSTRUCTION_TRACE_LENGTH_EXCEEDED]: "Max instruction trace length exceeded",
      [SOLANA_ERROR__INSTRUCTION_ERROR__MAX_SEED_LENGTH_EXCEEDED]: "Length of the seed is too long for address generation",
      [SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_ACCOUNT]: "An account required by the instruction is missing",
      [SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_REQUIRED_SIGNATURE]: "missing required signature for instruction",
      [SOLANA_ERROR__INSTRUCTION_ERROR__MODIFIED_PROGRAM_ID]: "instruction illegally modified the program id of an account",
      [SOLANA_ERROR__INSTRUCTION_ERROR__NOT_ENOUGH_ACCOUNT_KEYS]: "insufficient account keys for instruction",
      [SOLANA_ERROR__INSTRUCTION_ERROR__PRIVILEGE_ESCALATION]: "Cross-program invocation with unauthorized signer or writable account",
      [SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_ENVIRONMENT_SETUP_FAILURE]: "Failed to create program execution environment",
      [SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPILE]: "Program failed to compile",
      [SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPLETE]: "Program failed to complete",
      [SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_DATA_MODIFIED]: "instruction modified data of a read-only account",
      [SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_LAMPORT_CHANGE]: "instruction changed the balance of a read-only account",
      [SOLANA_ERROR__INSTRUCTION_ERROR__REENTRANCY_NOT_ALLOWED]: "Cross-program invocation reentrancy not allowed for this instruction",
      [SOLANA_ERROR__INSTRUCTION_ERROR__RENT_EPOCH_MODIFIED]: "instruction modified rent epoch of an account",
      [SOLANA_ERROR__INSTRUCTION_ERROR__UNBALANCED_INSTRUCTION]: "sum of account balances before and after instruction do not match",
      [SOLANA_ERROR__INSTRUCTION_ERROR__UNINITIALIZED_ACCOUNT]: "instruction requires an initialized account",
      [SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN]: "",
      [SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_PROGRAM_ID]: "Unsupported program id",
      [SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_SYSVAR]: "Unsupported sysvar",
      [SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_ACCOUNTS]: "The instruction does not have any accounts.",
      [SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_DATA]: "The instruction does not have any data.",
      [SOLANA_ERROR__INSTRUCTION__PROGRAM_ID_MISMATCH]: "Expected instruction to have progress address $expectedProgramAddress, got $actualProgramAddress.",
      [SOLANA_ERROR__INVALID_BLOCKHASH_BYTE_LENGTH]: "Expected base58 encoded blockhash to decode to a byte array of length 32. Actual length: $actualLength.",
      [SOLANA_ERROR__INVALID_NONCE]: "The nonce `$expectedNonceValue` is no longer valid. It has advanced to `$actualNonceValue`",
      [SOLANA_ERROR__INVARIANT_VIOLATION__CACHED_ABORTABLE_ITERABLE_CACHE_ENTRY_MISSING]: "Invariant violation: Found no abortable iterable cache entry for key `$cacheKey`. It should be impossible to hit this error; please file an issue at https://sola.na/web3invariant",
      [SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE]: "Invariant violation: Switch statement non-exhaustive. Received unexpected value `$unexpectedValue`. It should be impossible to hit this error; please file an issue at https://sola.na/web3invariant",
      [SOLANA_ERROR__INVARIANT_VIOLATION__WEBSOCKET_MESSAGE_ITERATOR_MUST_NOT_POLL_BEFORE_RESOLVING_EXISTING_MESSAGE_PROMISE]: "Invariant violation: WebSocket message iterator state is corrupt; iterated without first resolving existing message promise. It should be impossible to hit this error; please file an issue at https://sola.na/web3invariant",
      [SOLANA_ERROR__INVARIANT_VIOLATION__WEBSOCKET_MESSAGE_ITERATOR_STATE_MISSING]: "Invariant violation: WebSocket message iterator is missing state storage. It should be impossible to hit this error; please file an issue at https://sola.na/web3invariant",
      [SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR]: "JSON-RPC error: Internal JSON-RPC error ($__serverMessage)",
      [SOLANA_ERROR__JSON_RPC__INVALID_PARAMS]: "JSON-RPC error: Invalid method parameter(s) ($__serverMessage)",
      [SOLANA_ERROR__JSON_RPC__INVALID_REQUEST]: "JSON-RPC error: The JSON sent is not a valid `Request` object ($__serverMessage)",
      [SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND]: "JSON-RPC error: The method does not exist / is not available ($__serverMessage)",
      [SOLANA_ERROR__JSON_RPC__PARSE_ERROR]: "JSON-RPC error: An error occurred on the server while parsing the JSON text ($__serverMessage)",
      [SOLANA_ERROR__JSON_RPC__SCAN_ERROR]: "$__serverMessage",
      [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP]: "$__serverMessage",
      [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE]: "$__serverMessage",
      [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET]: "$__serverMessage",
      [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX]: "$__serverMessage",
      [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED]: "$__serverMessage",
      [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED]: "Minimum context slot has not been reached",
      [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NODE_UNHEALTHY]: "Node is unhealthy; behind by $numSlotsBehind slots",
      [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NO_SNAPSHOT]: "No snapshot",
      [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE]: "Transaction simulation failed",
      [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED]: "$__serverMessage",
      [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE]: "Transaction history is not available from this node",
      [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE]: "$__serverMessage",
      [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH]: "Transaction signature length mismatch",
      [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE]: "Transaction signature verification failure",
      [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION]: "$__serverMessage",
      [SOLANA_ERROR__KEYS__INVALID_KEY_PAIR_BYTE_LENGTH]: "Key pair bytes must be of length 64, got $byteLength.",
      [SOLANA_ERROR__KEYS__INVALID_PRIVATE_KEY_BYTE_LENGTH]: "Expected private key bytes with length 32. Actual length: $actualLength.",
      [SOLANA_ERROR__KEYS__INVALID_SIGNATURE_BYTE_LENGTH]: "Expected base58-encoded signature to decode to a byte array of length 64. Actual length: $actualLength.",
      [SOLANA_ERROR__KEYS__PUBLIC_KEY_MUST_MATCH_PRIVATE_KEY]: "The provided private key does not match the provided public key.",
      [SOLANA_ERROR__KEYS__SIGNATURE_STRING_LENGTH_OUT_OF_RANGE]: "Expected base58-encoded signature string of length in the range [64, 88]. Actual length: $actualLength.",
      [SOLANA_ERROR__LAMPORTS_OUT_OF_RANGE]: "Lamports value must be in the range [0, 2e64-1]",
      [SOLANA_ERROR__MALFORMED_BIGINT_STRING]: "`$value` cannot be parsed as a `BigInt`",
      [SOLANA_ERROR__MALFORMED_NUMBER_STRING]: "`$value` cannot be parsed as a `Number`",
      [SOLANA_ERROR__NONCE_ACCOUNT_NOT_FOUND]: "No nonce account could be found at address `$nonceAccountAddress`",
      [SOLANA_ERROR__RPC_SUBSCRIPTIONS__CANNOT_CREATE_SUBSCRIPTION_REQUEST]: "Either the notification name must end in 'Notifications' or the API must supply a subscription creator function for the notification '$notificationName' to map between the notification name and the subscribe/unsubscribe method names.",
      [SOLANA_ERROR__RPC_SUBSCRIPTIONS__EXPECTED_SERVER_SUBSCRIPTION_ID]: "Failed to obtain a subscription id from the server",
      [SOLANA_ERROR__RPC_SUBSCRIPTIONS__TRANSPORT_CLOSED_BEFORE_MESSAGE_BUFFERED]: "WebSocket was closed before payload could be added to the send buffer",
      [SOLANA_ERROR__RPC_SUBSCRIPTIONS__TRANSPORT_CONNECTION_CLOSED]: "WebSocket connection closed",
      [SOLANA_ERROR__RPC_SUBSCRIPTIONS__TRANSPORT_FAILED_TO_CONNECT]: "WebSocket failed to connect",
      [SOLANA_ERROR__RPC__INTEGER_OVERFLOW]: "The $argumentLabel argument to the `$methodName` RPC method$optionalPathLabel was `$value`. This number is unsafe for use with the Solana JSON-RPC because it exceeds `Number.MAX_SAFE_INTEGER`.",
      [SOLANA_ERROR__RPC__TRANSPORT_HTTP_ERROR]: "HTTP error ($statusCode): $message",
      [SOLANA_ERROR__RPC__TRANSPORT_HTTP_HEADER_FORBIDDEN]: "HTTP header(s) forbidden: $headers. Learn more at https://developer.mozilla.org/en-US/docs/Glossary/Forbidden_header_name.",
      [SOLANA_ERROR__SIGNER__ADDRESS_CANNOT_HAVE_MULTIPLE_SIGNERS]: "Multiple distinct signers were identified for address `$address`. Please ensure that you are using the same signer instance for each address.",
      [SOLANA_ERROR__SIGNER__EXPECTED_KEY_PAIR_SIGNER]: "The provided value does not implement the `KeyPairSigner` interface",
      [SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_MODIFYING_SIGNER]: "The provided value does not implement the `MessageModifyingSigner` interface",
      [SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_PARTIAL_SIGNER]: "The provided value does not implement the `MessagePartialSigner` interface",
      [SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_SIGNER]: "The provided value does not implement any of the `MessageSigner` interfaces",
      [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_MODIFYING_SIGNER]: "The provided value does not implement the `TransactionModifyingSigner` interface",
      [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_PARTIAL_SIGNER]: "The provided value does not implement the `TransactionPartialSigner` interface",
      [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SENDING_SIGNER]: "The provided value does not implement the `TransactionSendingSigner` interface",
      [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SIGNER]: "The provided value does not implement any of the `TransactionSigner` interfaces",
      [SOLANA_ERROR__SIGNER__TRANSACTION_CANNOT_HAVE_MULTIPLE_SENDING_SIGNERS]: "More than one `TransactionSendingSigner` was identified.",
      [SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING]: "No `TransactionSendingSigner` was identified. Please provide a valid `ITransactionWithSingleSendingSigner` transaction.",
      [SOLANA_ERROR__SIGNER__WALLET_MULTISIGN_UNIMPLEMENTED]: "Wallet account signers do not support signing multiple messages/transactions in a single operation",
      [SOLANA_ERROR__SUBTLE_CRYPTO__CANNOT_EXPORT_NON_EXTRACTABLE_KEY]: "Cannot export a non-extractable key.",
      [SOLANA_ERROR__SUBTLE_CRYPTO__DIGEST_UNIMPLEMENTED]: "No digest implementation could be found.",
      [SOLANA_ERROR__SUBTLE_CRYPTO__DISALLOWED_IN_INSECURE_CONTEXT]: "Cryptographic operations are only allowed in secure browser contexts. Read more here: https://developer.mozilla.org/en-US/docs/Web/Security/Secure_Contexts.",
      [SOLANA_ERROR__SUBTLE_CRYPTO__ED25519_ALGORITHM_UNIMPLEMENTED]: "This runtime does not support the generation of Ed25519 key pairs.\n\nInstall @solana/webcrypto-ed25519-polyfill and call its `install` function before generating keys in environments that do not support Ed25519.\n\nFor a list of runtimes that currently support Ed25519 operations, visit https://github.com/WICG/webcrypto-secure-curves/issues/20.",
      [SOLANA_ERROR__SUBTLE_CRYPTO__EXPORT_FUNCTION_UNIMPLEMENTED]: "No signature verification implementation could be found.",
      [SOLANA_ERROR__SUBTLE_CRYPTO__GENERATE_FUNCTION_UNIMPLEMENTED]: "No key generation implementation could be found.",
      [SOLANA_ERROR__SUBTLE_CRYPTO__SIGN_FUNCTION_UNIMPLEMENTED]: "No signing implementation could be found.",
      [SOLANA_ERROR__SUBTLE_CRYPTO__VERIFY_FUNCTION_UNIMPLEMENTED]: "No key export implementation could be found.",
      [SOLANA_ERROR__TIMESTAMP_OUT_OF_RANGE]: "Timestamp value must be in the range [-8.64e15, 8.64e15]. `$value` given",
      [SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_BORROW_OUTSTANDING]: "Transaction processing left an account with an outstanding borrowed reference",
      [SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_IN_USE]: "Account in use",
      [SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_LOADED_TWICE]: "Account loaded twice",
      [SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_NOT_FOUND]: "Attempt to debit an account but found no record of a prior credit.",
      [SOLANA_ERROR__TRANSACTION_ERROR__ADDRESS_LOOKUP_TABLE_NOT_FOUND]: "Transaction loads an address table account that doesn't exist",
      [SOLANA_ERROR__TRANSACTION_ERROR__ALREADY_PROCESSED]: "This transaction has already been processed",
      [SOLANA_ERROR__TRANSACTION_ERROR__BLOCKHASH_NOT_FOUND]: "Blockhash not found",
      [SOLANA_ERROR__TRANSACTION_ERROR__CALL_CHAIN_TOO_DEEP]: "Loader call chain is too deep",
      [SOLANA_ERROR__TRANSACTION_ERROR__CLUSTER_MAINTENANCE]: "Transactions are currently disabled due to cluster maintenance",
      [SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION]: "Transaction contains a duplicate instruction ($index) that is not allowed",
      [SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_FEE]: "Insufficient funds for fee",
      [SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT]: "Transaction results in an account ($accountIndex) with insufficient funds for rent",
      [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_FOR_FEE]: "This account may not be used to pay transaction fees",
      [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_INDEX]: "Transaction contains an invalid account reference",
      [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_DATA]: "Transaction loads an address table account with invalid data",
      [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_INDEX]: "Transaction address table lookup uses an invalid index",
      [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_OWNER]: "Transaction loads an address table account with an invalid owner",
      [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_LOADED_ACCOUNTS_DATA_SIZE_LIMIT]: "LoadedAccountsDataSizeLimit set for transaction must be greater than 0.",
      [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_PROGRAM_FOR_EXECUTION]: "This program may not be used for executing instructions",
      [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_RENT_PAYING_ACCOUNT]: "Transaction leaves an account with a lower balance than rent-exempt minimum",
      [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_WRITABLE_ACCOUNT]: "Transaction loads a writable account that cannot be written",
      [SOLANA_ERROR__TRANSACTION_ERROR__MAX_LOADED_ACCOUNTS_DATA_SIZE_EXCEEDED]: "Transaction exceeded max loaded accounts data size cap",
      [SOLANA_ERROR__TRANSACTION_ERROR__MISSING_SIGNATURE_FOR_FEE]: "Transaction requires a fee but has no signature present",
      [SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_ACCOUNT_NOT_FOUND]: "Attempt to load a program that does not exist",
      [SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED]: "Execution of the program referenced by account at index $accountIndex is temporarily restricted.",
      [SOLANA_ERROR__TRANSACTION_ERROR__RESANITIZATION_NEEDED]: "ResanitizationNeeded",
      [SOLANA_ERROR__TRANSACTION_ERROR__SANITIZE_FAILURE]: "Transaction failed to sanitize accounts offsets correctly",
      [SOLANA_ERROR__TRANSACTION_ERROR__SIGNATURE_FAILURE]: "Transaction did not pass signature verification",
      [SOLANA_ERROR__TRANSACTION_ERROR__TOO_MANY_ACCOUNT_LOCKS]: "Transaction locked too many accounts",
      [SOLANA_ERROR__TRANSACTION_ERROR__UNBALANCED_TRANSACTION]: "Sum of account balances before and after transaction do not match",
      [SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN]: "The transaction failed with the error `$errorName`",
      [SOLANA_ERROR__TRANSACTION_ERROR__UNSUPPORTED_VERSION]: "Transaction version is unsupported",
      [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_BLOCK_LIMIT]: "Transaction would exceed account data limit within the block",
      [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_TOTAL_LIMIT]: "Transaction would exceed total account data limit",
      [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_ACCOUNT_COST_LIMIT]: "Transaction would exceed max account limit within the block",
      [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_BLOCK_COST_LIMIT]: "Transaction would exceed max Block Cost Limit",
      [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_VOTE_COST_LIMIT]: "Transaction would exceed max Vote Cost Limit",
      [SOLANA_ERROR__TRANSACTION__ADDRESSES_CANNOT_SIGN_TRANSACTION]: "Attempted to sign a transaction with an address that is not a signer for it",
      [SOLANA_ERROR__TRANSACTION__ADDRESS_MISSING]: "Transaction is missing an address at index: $index.",
      [SOLANA_ERROR__TRANSACTION__CANNOT_ENCODE_WITH_EMPTY_SIGNATURES]: "Transaction has no expected signers therefore it cannot be encoded",
      [SOLANA_ERROR__TRANSACTION__EXPECTED_BLOCKHASH_LIFETIME]: "Transaction does not have a blockhash lifetime",
      [SOLANA_ERROR__TRANSACTION__EXPECTED_NONCE_LIFETIME]: "Transaction is not a durable nonce transaction",
      [SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING]: "Contents of these address lookup tables unknown: $lookupTableAddresses",
      [SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE]: "Lookup of address at index $highestRequestedIndex failed for lookup table `$lookupTableAddress`. Highest known index is $highestKnownIndex. The lookup table may have been extended since its contents were retrieved",
      [SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_FEE_PAYER_MISSING]: "No fee payer set in CompiledTransaction",
      [SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND]: "Could not find program address at index $index",
      [SOLANA_ERROR__TRANSACTION__FAILED_TO_ESTIMATE_COMPUTE_LIMIT]: "Failed to estimate the compute unit consumption for this transaction message. This is likely because simulating the transaction failed. Inspect the `cause` property of this error to learn more",
      [SOLANA_ERROR__TRANSACTION__FEE_PAYER_MISSING]: "Transaction is missing a fee payer.",
      [SOLANA_ERROR__TRANSACTION__FEE_PAYER_SIGNATURE_MISSING]: "Could not determine this transaction's signature. Make sure that the transaction has been signed by its fee payer.",
      [SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_FIRST_INSTRUCTION_MUST_BE_ADVANCE_NONCE]: "Transaction first instruction is not advance nonce account instruction.",
      [SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_INSTRUCTIONS_MISSING]: "Transaction with no instructions cannot be durable nonce transaction.",
      [SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES]: "This transaction includes an address (`$programAddress`) which is both invoked and set as the fee payer. Program addresses may not pay fees",
      [SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE]: "This transaction includes an address (`$programAddress`) which is both invoked and marked writable. Program addresses may not be writable",
      [SOLANA_ERROR__TRANSACTION__MESSAGE_SIGNATURES_MISMATCH]: "The transaction message expected the transaction to have $signerAddressesLength signatures, got $signaturesLength.",
      [SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING]: "Transaction is missing signatures for addresses: $addresses.",
      [SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE]: "Transaction version must be in the range [0, 127]. `$actualVersion` given"
    };
    var START_INDEX = "i";
    var TYPE = "t";
    function getHumanReadableErrorMessage(code, context = {}) {
      const messageFormatString = SolanaErrorMessages[code];
      if (messageFormatString.length === 0) {
        return "";
      }
      let state;
      function commitStateUpTo(endIndex) {
        if (state[TYPE] === 2) {
          const variableName = messageFormatString.slice(state[START_INDEX] + 1, endIndex);
          fragments.push(
            variableName in context ? `${context[variableName]}` : `$${variableName}`
          );
        } else if (state[TYPE] === 1) {
          fragments.push(messageFormatString.slice(state[START_INDEX], endIndex));
        }
      }
      const fragments = [];
      messageFormatString.split("").forEach((char, ii) => {
        if (ii === 0) {
          state = {
            [START_INDEX]: 0,
            [TYPE]: messageFormatString[0] === "\\" ? 0 : messageFormatString[0] === "$" ? 2 : 1
            /* Text */
          };
          return;
        }
        let nextState;
        switch (state[TYPE]) {
          case 0:
            nextState = {
              [START_INDEX]: ii,
              [TYPE]: 1
              /* Text */
            };
            break;
          case 1:
            if (char === "\\") {
              nextState = {
                [START_INDEX]: ii,
                [TYPE]: 0
                /* EscapeSequence */
              };
            } else if (char === "$") {
              nextState = {
                [START_INDEX]: ii,
                [TYPE]: 2
                /* Variable */
              };
            }
            break;
          case 2:
            if (char === "\\") {
              nextState = {
                [START_INDEX]: ii,
                [TYPE]: 0
                /* EscapeSequence */
              };
            } else if (char === "$") {
              nextState = {
                [START_INDEX]: ii,
                [TYPE]: 2
                /* Variable */
              };
            } else if (!char.match(/\w/)) {
              nextState = {
                [START_INDEX]: ii,
                [TYPE]: 1
                /* Text */
              };
            }
            break;
        }
        if (nextState) {
          if (state !== nextState) {
            commitStateUpTo(ii);
          }
          state = nextState;
        }
      });
      commitStateUpTo();
      return fragments.join("");
    }
    function getErrorMessage(code, context = {}) {
      if (process.env.NODE_ENV !== "production") {
        return getHumanReadableErrorMessage(code, context);
      } else {
        let decodingAdviceMessage = `Solana error #${code}; Decode this error by running \`npx @solana/errors decode -- ${code}`;
        if (Object.keys(context).length) {
          decodingAdviceMessage += ` '${encodeContextObject(context)}'`;
        }
        return `${decodingAdviceMessage}\``;
      }
    }
    function isSolanaError(e, code) {
      const isSolanaError2 = e instanceof Error && e.name === "SolanaError";
      if (isSolanaError2) {
        if (code !== void 0) {
          return e.context.__code === code;
        }
        return true;
      }
      return false;
    }
    var SolanaError = class extends Error {
      cause = this.cause;
      context;
      constructor(...[code, contextAndErrorOptions]) {
        let context;
        let errorOptions;
        if (contextAndErrorOptions) {
          const { cause, ...contextRest } = contextAndErrorOptions;
          if (cause) {
            errorOptions = { cause };
          }
          if (Object.keys(contextRest).length > 0) {
            context = contextRest;
          }
        }
        const message = getErrorMessage(code, context);
        super(message, errorOptions);
        this.context = {
          __code: code,
          ...context
        };
        this.name = "SolanaError";
      }
    };
    function safeCaptureStackTrace(...args) {
      if ("captureStackTrace" in Error && typeof Error.captureStackTrace === "function") {
        Error.captureStackTrace(...args);
      }
    }
    function getSolanaErrorFromRpcError({ errorCodeBaseOffset, getErrorContext, orderedErrorNames, rpcEnumError }, constructorOpt) {
      let rpcErrorName;
      let rpcErrorContext;
      if (typeof rpcEnumError === "string") {
        rpcErrorName = rpcEnumError;
      } else {
        rpcErrorName = Object.keys(rpcEnumError)[0];
        rpcErrorContext = rpcEnumError[rpcErrorName];
      }
      const codeOffset = orderedErrorNames.indexOf(rpcErrorName);
      const errorCode = errorCodeBaseOffset + codeOffset;
      const errorContext = getErrorContext(errorCode, rpcErrorName, rpcErrorContext);
      const err = new SolanaError(errorCode, errorContext);
      safeCaptureStackTrace(err, constructorOpt);
      return err;
    }
    var ORDERED_ERROR_NAMES = [
      // Keep synced with RPC source: https://github.com/anza-xyz/agave/blob/master/sdk/program/src/instruction.rs
      // If this list ever gets too large, consider implementing a compression strategy like this:
      // https://gist.github.com/steveluscher/aaa7cbbb5433b1197983908a40860c47
      "GenericError",
      "InvalidArgument",
      "InvalidInstructionData",
      "InvalidAccountData",
      "AccountDataTooSmall",
      "InsufficientFunds",
      "IncorrectProgramId",
      "MissingRequiredSignature",
      "AccountAlreadyInitialized",
      "UninitializedAccount",
      "UnbalancedInstruction",
      "ModifiedProgramId",
      "ExternalAccountLamportSpend",
      "ExternalAccountDataModified",
      "ReadonlyLamportChange",
      "ReadonlyDataModified",
      "DuplicateAccountIndex",
      "ExecutableModified",
      "RentEpochModified",
      "NotEnoughAccountKeys",
      "AccountDataSizeChanged",
      "AccountNotExecutable",
      "AccountBorrowFailed",
      "AccountBorrowOutstanding",
      "DuplicateAccountOutOfSync",
      "Custom",
      "InvalidError",
      "ExecutableDataModified",
      "ExecutableLamportChange",
      "ExecutableAccountNotRentExempt",
      "UnsupportedProgramId",
      "CallDepth",
      "MissingAccount",
      "ReentrancyNotAllowed",
      "MaxSeedLengthExceeded",
      "InvalidSeeds",
      "InvalidRealloc",
      "ComputationalBudgetExceeded",
      "PrivilegeEscalation",
      "ProgramEnvironmentSetupFailure",
      "ProgramFailedToComplete",
      "ProgramFailedToCompile",
      "Immutable",
      "IncorrectAuthority",
      "BorshIoError",
      "AccountNotRentExempt",
      "InvalidAccountOwner",
      "ArithmeticOverflow",
      "UnsupportedSysvar",
      "IllegalOwner",
      "MaxAccountsDataAllocationsExceeded",
      "MaxAccountsExceeded",
      "MaxInstructionTraceLengthExceeded",
      "BuiltinProgramsMustConsumeComputeUnits"
    ];
    function getSolanaErrorFromInstructionError(index, instructionError) {
      return getSolanaErrorFromRpcError(
        {
          errorCodeBaseOffset: 4615001,
          getErrorContext(errorCode, rpcErrorName, rpcErrorContext) {
            if (errorCode === SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN) {
              return {
                errorName: rpcErrorName,
                index,
                ...rpcErrorContext !== void 0 ? { instructionErrorContext: rpcErrorContext } : null
              };
            } else if (errorCode === SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM) {
              return {
                code: rpcErrorContext,
                index
              };
            } else if (errorCode === SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR) {
              return {
                encodedData: rpcErrorContext,
                index
              };
            }
            return { index };
          },
          orderedErrorNames: ORDERED_ERROR_NAMES,
          rpcEnumError: instructionError
        },
        getSolanaErrorFromInstructionError
      );
    }
    var ORDERED_ERROR_NAMES2 = [
      // Keep synced with RPC source: https://github.com/anza-xyz/agave/blob/master/sdk/src/transaction/error.rs
      // If this list ever gets too large, consider implementing a compression strategy like this:
      // https://gist.github.com/steveluscher/aaa7cbbb5433b1197983908a40860c47
      "AccountInUse",
      "AccountLoadedTwice",
      "AccountNotFound",
      "ProgramAccountNotFound",
      "InsufficientFundsForFee",
      "InvalidAccountForFee",
      "AlreadyProcessed",
      "BlockhashNotFound",
      // `InstructionError` intentionally omitted; delegated to `getSolanaErrorFromInstructionError`
      "CallChainTooDeep",
      "MissingSignatureForFee",
      "InvalidAccountIndex",
      "SignatureFailure",
      "InvalidProgramForExecution",
      "SanitizeFailure",
      "ClusterMaintenance",
      "AccountBorrowOutstanding",
      "WouldExceedMaxBlockCostLimit",
      "UnsupportedVersion",
      "InvalidWritableAccount",
      "WouldExceedMaxAccountCostLimit",
      "WouldExceedAccountDataBlockLimit",
      "TooManyAccountLocks",
      "AddressLookupTableNotFound",
      "InvalidAddressLookupTableOwner",
      "InvalidAddressLookupTableData",
      "InvalidAddressLookupTableIndex",
      "InvalidRentPayingAccount",
      "WouldExceedMaxVoteCostLimit",
      "WouldExceedAccountDataTotalLimit",
      "DuplicateInstruction",
      "InsufficientFundsForRent",
      "MaxLoadedAccountsDataSizeExceeded",
      "InvalidLoadedAccountsDataSizeLimit",
      "ResanitizationNeeded",
      "ProgramExecutionTemporarilyRestricted",
      "UnbalancedTransaction"
    ];
    function getSolanaErrorFromTransactionError(transactionError) {
      if (typeof transactionError === "object" && "InstructionError" in transactionError) {
        return getSolanaErrorFromInstructionError(
          ...transactionError.InstructionError
        );
      }
      return getSolanaErrorFromRpcError(
        {
          errorCodeBaseOffset: 7050001,
          getErrorContext(errorCode, rpcErrorName, rpcErrorContext) {
            if (errorCode === SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN) {
              return {
                errorName: rpcErrorName,
                ...rpcErrorContext !== void 0 ? { transactionErrorContext: rpcErrorContext } : null
              };
            } else if (errorCode === SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION) {
              return {
                index: rpcErrorContext
              };
            } else if (errorCode === SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT || errorCode === SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED) {
              return {
                accountIndex: rpcErrorContext.account_index
              };
            }
          },
          orderedErrorNames: ORDERED_ERROR_NAMES2,
          rpcEnumError: transactionError
        },
        getSolanaErrorFromTransactionError
      );
    }
    function getSolanaErrorFromJsonRpcError({ code, data, message }) {
      let out;
      if (code === SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE) {
        const { err, ...preflightErrorContext } = data;
        const causeObject = err ? { cause: getSolanaErrorFromTransactionError(err) } : null;
        out = new SolanaError(SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE, {
          ...preflightErrorContext,
          ...causeObject
        });
      } else {
        let errorContext;
        switch (code) {
          case SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR:
          case SOLANA_ERROR__JSON_RPC__INVALID_PARAMS:
          case SOLANA_ERROR__JSON_RPC__INVALID_REQUEST:
          case SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND:
          case SOLANA_ERROR__JSON_RPC__PARSE_ERROR:
          case SOLANA_ERROR__JSON_RPC__SCAN_ERROR:
          case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP:
          case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE:
          case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET:
          case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX:
          case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED:
          case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED:
          case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE:
          case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION:
            errorContext = { __serverMessage: message };
            break;
          default:
            if (typeof data === "object" && !Array.isArray(data)) {
              errorContext = data;
            }
        }
        out = new SolanaError(code, errorContext);
      }
      safeCaptureStackTrace(out, getSolanaErrorFromJsonRpcError);
      return out;
    }
    exports2.SOLANA_ERROR__ACCOUNTS__ACCOUNT_NOT_FOUND = SOLANA_ERROR__ACCOUNTS__ACCOUNT_NOT_FOUND;
    exports2.SOLANA_ERROR__ACCOUNTS__EXPECTED_ALL_ACCOUNTS_TO_BE_DECODED = SOLANA_ERROR__ACCOUNTS__EXPECTED_ALL_ACCOUNTS_TO_BE_DECODED;
    exports2.SOLANA_ERROR__ACCOUNTS__EXPECTED_DECODED_ACCOUNT = SOLANA_ERROR__ACCOUNTS__EXPECTED_DECODED_ACCOUNT;
    exports2.SOLANA_ERROR__ACCOUNTS__FAILED_TO_DECODE_ACCOUNT = SOLANA_ERROR__ACCOUNTS__FAILED_TO_DECODE_ACCOUNT;
    exports2.SOLANA_ERROR__ACCOUNTS__ONE_OR_MORE_ACCOUNTS_NOT_FOUND = SOLANA_ERROR__ACCOUNTS__ONE_OR_MORE_ACCOUNTS_NOT_FOUND;
    exports2.SOLANA_ERROR__ADDRESSES__FAILED_TO_FIND_VIABLE_PDA_BUMP_SEED = SOLANA_ERROR__ADDRESSES__FAILED_TO_FIND_VIABLE_PDA_BUMP_SEED;
    exports2.SOLANA_ERROR__ADDRESSES__INVALID_BASE58_ENCODED_ADDRESS = SOLANA_ERROR__ADDRESSES__INVALID_BASE58_ENCODED_ADDRESS;
    exports2.SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH = SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH;
    exports2.SOLANA_ERROR__ADDRESSES__INVALID_ED25519_PUBLIC_KEY = SOLANA_ERROR__ADDRESSES__INVALID_ED25519_PUBLIC_KEY;
    exports2.SOLANA_ERROR__ADDRESSES__INVALID_SEEDS_POINT_ON_CURVE = SOLANA_ERROR__ADDRESSES__INVALID_SEEDS_POINT_ON_CURVE;
    exports2.SOLANA_ERROR__ADDRESSES__MALFORMED_PDA = SOLANA_ERROR__ADDRESSES__MALFORMED_PDA;
    exports2.SOLANA_ERROR__ADDRESSES__MAX_NUMBER_OF_PDA_SEEDS_EXCEEDED = SOLANA_ERROR__ADDRESSES__MAX_NUMBER_OF_PDA_SEEDS_EXCEEDED;
    exports2.SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED = SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED;
    exports2.SOLANA_ERROR__ADDRESSES__PDA_BUMP_SEED_OUT_OF_RANGE = SOLANA_ERROR__ADDRESSES__PDA_BUMP_SEED_OUT_OF_RANGE;
    exports2.SOLANA_ERROR__ADDRESSES__PDA_ENDS_WITH_PDA_MARKER = SOLANA_ERROR__ADDRESSES__PDA_ENDS_WITH_PDA_MARKER;
    exports2.SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE = SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE;
    exports2.SOLANA_ERROR__BLOCKHASH_STRING_LENGTH_OUT_OF_RANGE = SOLANA_ERROR__BLOCKHASH_STRING_LENGTH_OUT_OF_RANGE;
    exports2.SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED = SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED;
    exports2.SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY = SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY;
    exports2.SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS = SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS;
    exports2.SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL = SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL;
    exports2.SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH = SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH;
    exports2.SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH = SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH;
    exports2.SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH = SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH;
    exports2.SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE = SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE;
    exports2.SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH = SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH;
    exports2.SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH = SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH;
    exports2.SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH = SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH;
    exports2.SOLANA_ERROR__CODECS__EXPECTED_ZERO_VALUE_TO_MATCH_ITEM_FIXED_SIZE = SOLANA_ERROR__CODECS__EXPECTED_ZERO_VALUE_TO_MATCH_ITEM_FIXED_SIZE;
    exports2.SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH = SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH;
    exports2.SOLANA_ERROR__CODECS__INVALID_CONSTANT = SOLANA_ERROR__CODECS__INVALID_CONSTANT;
    exports2.SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT = SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT;
    exports2.SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT = SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT;
    exports2.SOLANA_ERROR__CODECS__INVALID_LITERAL_UNION_VARIANT = SOLANA_ERROR__CODECS__INVALID_LITERAL_UNION_VARIANT;
    exports2.SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS = SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS;
    exports2.SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE = SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE;
    exports2.SOLANA_ERROR__CODECS__LITERAL_UNION_DISCRIMINATOR_OUT_OF_RANGE = SOLANA_ERROR__CODECS__LITERAL_UNION_DISCRIMINATOR_OUT_OF_RANGE;
    exports2.SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE = SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE;
    exports2.SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE = SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE;
    exports2.SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES = SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES;
    exports2.SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE = SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE;
    exports2.SOLANA_ERROR__CRYPTO__RANDOM_VALUES_FUNCTION_UNIMPLEMENTED = SOLANA_ERROR__CRYPTO__RANDOM_VALUES_FUNCTION_UNIMPLEMENTED;
    exports2.SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_ALREADY_INITIALIZED = SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_ALREADY_INITIALIZED;
    exports2.SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_FAILED = SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_FAILED;
    exports2.SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_OUTSTANDING = SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_OUTSTANDING;
    exports2.SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_SIZE_CHANGED = SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_SIZE_CHANGED;
    exports2.SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_TOO_SMALL = SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_TOO_SMALL;
    exports2.SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_EXECUTABLE = SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_EXECUTABLE;
    exports2.SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_RENT_EXEMPT = SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_RENT_EXEMPT;
    exports2.SOLANA_ERROR__INSTRUCTION_ERROR__ARITHMETIC_OVERFLOW = SOLANA_ERROR__INSTRUCTION_ERROR__ARITHMETIC_OVERFLOW;
    exports2.SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR = SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR;
    exports2.SOLANA_ERROR__INSTRUCTION_ERROR__BUILTIN_PROGRAMS_MUST_CONSUME_COMPUTE_UNITS = SOLANA_ERROR__INSTRUCTION_ERROR__BUILTIN_PROGRAMS_MUST_CONSUME_COMPUTE_UNITS;
    exports2.SOLANA_ERROR__INSTRUCTION_ERROR__CALL_DEPTH = SOLANA_ERROR__INSTRUCTION_ERROR__CALL_DEPTH;
    exports2.SOLANA_ERROR__INSTRUCTION_ERROR__COMPUTATIONAL_BUDGET_EXCEEDED = SOLANA_ERROR__INSTRUCTION_ERROR__COMPUTATIONAL_BUDGET_EXCEEDED;
    exports2.SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM = SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM;
    exports2.SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_INDEX = SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_INDEX;
    exports2.SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_OUT_OF_SYNC = SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_OUT_OF_SYNC;
    exports2.SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_ACCOUNT_NOT_RENT_EXEMPT = SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_ACCOUNT_NOT_RENT_EXEMPT;
    exports2.SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_DATA_MODIFIED = SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_DATA_MODIFIED;
    exports2.SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_LAMPORT_CHANGE = SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_LAMPORT_CHANGE;
    exports2.SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_MODIFIED = SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_MODIFIED;
    exports2.SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_DATA_MODIFIED = SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_DATA_MODIFIED;
    exports2.SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_LAMPORT_SPEND = SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_LAMPORT_SPEND;
    exports2.SOLANA_ERROR__INSTRUCTION_ERROR__GENERIC_ERROR = SOLANA_ERROR__INSTRUCTION_ERROR__GENERIC_ERROR;
    exports2.SOLANA_ERROR__INSTRUCTION_ERROR__ILLEGAL_OWNER = SOLANA_ERROR__INSTRUCTION_ERROR__ILLEGAL_OWNER;
    exports2.SOLANA_ERROR__INSTRUCTION_ERROR__IMMUTABLE = SOLANA_ERROR__INSTRUCTION_ERROR__IMMUTABLE;
    exports2.SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_AUTHORITY = SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_AUTHORITY;
    exports2.SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_PROGRAM_ID = SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_PROGRAM_ID;
    exports2.SOLANA_ERROR__INSTRUCTION_ERROR__INSUFFICIENT_FUNDS = SOLANA_ERROR__INSTRUCTION_ERROR__INSUFFICIENT_FUNDS;
    exports2.SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_DATA = SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_DATA;
    exports2.SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_OWNER = SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_OWNER;
    exports2.SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ARGUMENT = SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ARGUMENT;
    exports2.SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ERROR = SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ERROR;
    exports2.SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_INSTRUCTION_DATA = SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_INSTRUCTION_DATA;
    exports2.SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_REALLOC = SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_REALLOC;
    exports2.SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_SEEDS = SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_SEEDS;
    exports2.SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_DATA_ALLOCATIONS_EXCEEDED = SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_DATA_ALLOCATIONS_EXCEEDED;
    exports2.SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_EXCEEDED = SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_EXCEEDED;
    exports2.SOLANA_ERROR__INSTRUCTION_ERROR__MAX_INSTRUCTION_TRACE_LENGTH_EXCEEDED = SOLANA_ERROR__INSTRUCTION_ERROR__MAX_INSTRUCTION_TRACE_LENGTH_EXCEEDED;
    exports2.SOLANA_ERROR__INSTRUCTION_ERROR__MAX_SEED_LENGTH_EXCEEDED = SOLANA_ERROR__INSTRUCTION_ERROR__MAX_SEED_LENGTH_EXCEEDED;
    exports2.SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_ACCOUNT = SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_ACCOUNT;
    exports2.SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_REQUIRED_SIGNATURE = SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_REQUIRED_SIGNATURE;
    exports2.SOLANA_ERROR__INSTRUCTION_ERROR__MODIFIED_PROGRAM_ID = SOLANA_ERROR__INSTRUCTION_ERROR__MODIFIED_PROGRAM_ID;
    exports2.SOLANA_ERROR__INSTRUCTION_ERROR__NOT_ENOUGH_ACCOUNT_KEYS = SOLANA_ERROR__INSTRUCTION_ERROR__NOT_ENOUGH_ACCOUNT_KEYS;
    exports2.SOLANA_ERROR__INSTRUCTION_ERROR__PRIVILEGE_ESCALATION = SOLANA_ERROR__INSTRUCTION_ERROR__PRIVILEGE_ESCALATION;
    exports2.SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_ENVIRONMENT_SETUP_FAILURE = SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_ENVIRONMENT_SETUP_FAILURE;
    exports2.SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPILE = SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPILE;
    exports2.SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPLETE = SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPLETE;
    exports2.SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_DATA_MODIFIED = SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_DATA_MODIFIED;
    exports2.SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_LAMPORT_CHANGE = SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_LAMPORT_CHANGE;
    exports2.SOLANA_ERROR__INSTRUCTION_ERROR__REENTRANCY_NOT_ALLOWED = SOLANA_ERROR__INSTRUCTION_ERROR__REENTRANCY_NOT_ALLOWED;
    exports2.SOLANA_ERROR__INSTRUCTION_ERROR__RENT_EPOCH_MODIFIED = SOLANA_ERROR__INSTRUCTION_ERROR__RENT_EPOCH_MODIFIED;
    exports2.SOLANA_ERROR__INSTRUCTION_ERROR__UNBALANCED_INSTRUCTION = SOLANA_ERROR__INSTRUCTION_ERROR__UNBALANCED_INSTRUCTION;
    exports2.SOLANA_ERROR__INSTRUCTION_ERROR__UNINITIALIZED_ACCOUNT = SOLANA_ERROR__INSTRUCTION_ERROR__UNINITIALIZED_ACCOUNT;
    exports2.SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN = SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN;
    exports2.SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_PROGRAM_ID = SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_PROGRAM_ID;
    exports2.SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_SYSVAR = SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_SYSVAR;
    exports2.SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_ACCOUNTS = SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_ACCOUNTS;
    exports2.SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_DATA = SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_DATA;
    exports2.SOLANA_ERROR__INSTRUCTION__PROGRAM_ID_MISMATCH = SOLANA_ERROR__INSTRUCTION__PROGRAM_ID_MISMATCH;
    exports2.SOLANA_ERROR__INVALID_BLOCKHASH_BYTE_LENGTH = SOLANA_ERROR__INVALID_BLOCKHASH_BYTE_LENGTH;
    exports2.SOLANA_ERROR__INVALID_NONCE = SOLANA_ERROR__INVALID_NONCE;
    exports2.SOLANA_ERROR__INVARIANT_VIOLATION__CACHED_ABORTABLE_ITERABLE_CACHE_ENTRY_MISSING = SOLANA_ERROR__INVARIANT_VIOLATION__CACHED_ABORTABLE_ITERABLE_CACHE_ENTRY_MISSING;
    exports2.SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE = SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE;
    exports2.SOLANA_ERROR__INVARIANT_VIOLATION__WEBSOCKET_MESSAGE_ITERATOR_MUST_NOT_POLL_BEFORE_RESOLVING_EXISTING_MESSAGE_PROMISE = SOLANA_ERROR__INVARIANT_VIOLATION__WEBSOCKET_MESSAGE_ITERATOR_MUST_NOT_POLL_BEFORE_RESOLVING_EXISTING_MESSAGE_PROMISE;
    exports2.SOLANA_ERROR__INVARIANT_VIOLATION__WEBSOCKET_MESSAGE_ITERATOR_STATE_MISSING = SOLANA_ERROR__INVARIANT_VIOLATION__WEBSOCKET_MESSAGE_ITERATOR_STATE_MISSING;
    exports2.SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR = SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR;
    exports2.SOLANA_ERROR__JSON_RPC__INVALID_PARAMS = SOLANA_ERROR__JSON_RPC__INVALID_PARAMS;
    exports2.SOLANA_ERROR__JSON_RPC__INVALID_REQUEST = SOLANA_ERROR__JSON_RPC__INVALID_REQUEST;
    exports2.SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND = SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND;
    exports2.SOLANA_ERROR__JSON_RPC__PARSE_ERROR = SOLANA_ERROR__JSON_RPC__PARSE_ERROR;
    exports2.SOLANA_ERROR__JSON_RPC__SCAN_ERROR = SOLANA_ERROR__JSON_RPC__SCAN_ERROR;
    exports2.SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP = SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP;
    exports2.SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE = SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE;
    exports2.SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET = SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET;
    exports2.SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX = SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX;
    exports2.SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED = SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED;
    exports2.SOLANA_ERROR__JSON_RPC__SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED = SOLANA_ERROR__JSON_RPC__SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED;
    exports2.SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NODE_UNHEALTHY = SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NODE_UNHEALTHY;
    exports2.SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NO_SNAPSHOT = SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NO_SNAPSHOT;
    exports2.SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE = SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE;
    exports2.SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED = SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED;
    exports2.SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE = SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE;
    exports2.SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE = SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE;
    exports2.SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH = SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH;
    exports2.SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE = SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE;
    exports2.SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION = SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION;
    exports2.SOLANA_ERROR__KEYS__INVALID_KEY_PAIR_BYTE_LENGTH = SOLANA_ERROR__KEYS__INVALID_KEY_PAIR_BYTE_LENGTH;
    exports2.SOLANA_ERROR__KEYS__INVALID_PRIVATE_KEY_BYTE_LENGTH = SOLANA_ERROR__KEYS__INVALID_PRIVATE_KEY_BYTE_LENGTH;
    exports2.SOLANA_ERROR__KEYS__INVALID_SIGNATURE_BYTE_LENGTH = SOLANA_ERROR__KEYS__INVALID_SIGNATURE_BYTE_LENGTH;
    exports2.SOLANA_ERROR__KEYS__PUBLIC_KEY_MUST_MATCH_PRIVATE_KEY = SOLANA_ERROR__KEYS__PUBLIC_KEY_MUST_MATCH_PRIVATE_KEY;
    exports2.SOLANA_ERROR__KEYS__SIGNATURE_STRING_LENGTH_OUT_OF_RANGE = SOLANA_ERROR__KEYS__SIGNATURE_STRING_LENGTH_OUT_OF_RANGE;
    exports2.SOLANA_ERROR__LAMPORTS_OUT_OF_RANGE = SOLANA_ERROR__LAMPORTS_OUT_OF_RANGE;
    exports2.SOLANA_ERROR__MALFORMED_BIGINT_STRING = SOLANA_ERROR__MALFORMED_BIGINT_STRING;
    exports2.SOLANA_ERROR__MALFORMED_NUMBER_STRING = SOLANA_ERROR__MALFORMED_NUMBER_STRING;
    exports2.SOLANA_ERROR__NONCE_ACCOUNT_NOT_FOUND = SOLANA_ERROR__NONCE_ACCOUNT_NOT_FOUND;
    exports2.SOLANA_ERROR__RPC_SUBSCRIPTIONS__CANNOT_CREATE_SUBSCRIPTION_REQUEST = SOLANA_ERROR__RPC_SUBSCRIPTIONS__CANNOT_CREATE_SUBSCRIPTION_REQUEST;
    exports2.SOLANA_ERROR__RPC_SUBSCRIPTIONS__EXPECTED_SERVER_SUBSCRIPTION_ID = SOLANA_ERROR__RPC_SUBSCRIPTIONS__EXPECTED_SERVER_SUBSCRIPTION_ID;
    exports2.SOLANA_ERROR__RPC_SUBSCRIPTIONS__TRANSPORT_CLOSED_BEFORE_MESSAGE_BUFFERED = SOLANA_ERROR__RPC_SUBSCRIPTIONS__TRANSPORT_CLOSED_BEFORE_MESSAGE_BUFFERED;
    exports2.SOLANA_ERROR__RPC_SUBSCRIPTIONS__TRANSPORT_CONNECTION_CLOSED = SOLANA_ERROR__RPC_SUBSCRIPTIONS__TRANSPORT_CONNECTION_CLOSED;
    exports2.SOLANA_ERROR__RPC_SUBSCRIPTIONS__TRANSPORT_FAILED_TO_CONNECT = SOLANA_ERROR__RPC_SUBSCRIPTIONS__TRANSPORT_FAILED_TO_CONNECT;
    exports2.SOLANA_ERROR__RPC__INTEGER_OVERFLOW = SOLANA_ERROR__RPC__INTEGER_OVERFLOW;
    exports2.SOLANA_ERROR__RPC__TRANSPORT_HTTP_ERROR = SOLANA_ERROR__RPC__TRANSPORT_HTTP_ERROR;
    exports2.SOLANA_ERROR__RPC__TRANSPORT_HTTP_HEADER_FORBIDDEN = SOLANA_ERROR__RPC__TRANSPORT_HTTP_HEADER_FORBIDDEN;
    exports2.SOLANA_ERROR__SIGNER__ADDRESS_CANNOT_HAVE_MULTIPLE_SIGNERS = SOLANA_ERROR__SIGNER__ADDRESS_CANNOT_HAVE_MULTIPLE_SIGNERS;
    exports2.SOLANA_ERROR__SIGNER__EXPECTED_KEY_PAIR_SIGNER = SOLANA_ERROR__SIGNER__EXPECTED_KEY_PAIR_SIGNER;
    exports2.SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_MODIFYING_SIGNER = SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_MODIFYING_SIGNER;
    exports2.SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_PARTIAL_SIGNER = SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_PARTIAL_SIGNER;
    exports2.SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_SIGNER = SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_SIGNER;
    exports2.SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_MODIFYING_SIGNER = SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_MODIFYING_SIGNER;
    exports2.SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_PARTIAL_SIGNER = SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_PARTIAL_SIGNER;
    exports2.SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SENDING_SIGNER = SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SENDING_SIGNER;
    exports2.SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SIGNER = SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SIGNER;
    exports2.SOLANA_ERROR__SIGNER__TRANSACTION_CANNOT_HAVE_MULTIPLE_SENDING_SIGNERS = SOLANA_ERROR__SIGNER__TRANSACTION_CANNOT_HAVE_MULTIPLE_SENDING_SIGNERS;
    exports2.SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING = SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING;
    exports2.SOLANA_ERROR__SIGNER__WALLET_MULTISIGN_UNIMPLEMENTED = SOLANA_ERROR__SIGNER__WALLET_MULTISIGN_UNIMPLEMENTED;
    exports2.SOLANA_ERROR__SUBTLE_CRYPTO__CANNOT_EXPORT_NON_EXTRACTABLE_KEY = SOLANA_ERROR__SUBTLE_CRYPTO__CANNOT_EXPORT_NON_EXTRACTABLE_KEY;
    exports2.SOLANA_ERROR__SUBTLE_CRYPTO__DIGEST_UNIMPLEMENTED = SOLANA_ERROR__SUBTLE_CRYPTO__DIGEST_UNIMPLEMENTED;
    exports2.SOLANA_ERROR__SUBTLE_CRYPTO__DISALLOWED_IN_INSECURE_CONTEXT = SOLANA_ERROR__SUBTLE_CRYPTO__DISALLOWED_IN_INSECURE_CONTEXT;
    exports2.SOLANA_ERROR__SUBTLE_CRYPTO__ED25519_ALGORITHM_UNIMPLEMENTED = SOLANA_ERROR__SUBTLE_CRYPTO__ED25519_ALGORITHM_UNIMPLEMENTED;
    exports2.SOLANA_ERROR__SUBTLE_CRYPTO__EXPORT_FUNCTION_UNIMPLEMENTED = SOLANA_ERROR__SUBTLE_CRYPTO__EXPORT_FUNCTION_UNIMPLEMENTED;
    exports2.SOLANA_ERROR__SUBTLE_CRYPTO__GENERATE_FUNCTION_UNIMPLEMENTED = SOLANA_ERROR__SUBTLE_CRYPTO__GENERATE_FUNCTION_UNIMPLEMENTED;
    exports2.SOLANA_ERROR__SUBTLE_CRYPTO__SIGN_FUNCTION_UNIMPLEMENTED = SOLANA_ERROR__SUBTLE_CRYPTO__SIGN_FUNCTION_UNIMPLEMENTED;
    exports2.SOLANA_ERROR__SUBTLE_CRYPTO__VERIFY_FUNCTION_UNIMPLEMENTED = SOLANA_ERROR__SUBTLE_CRYPTO__VERIFY_FUNCTION_UNIMPLEMENTED;
    exports2.SOLANA_ERROR__TIMESTAMP_OUT_OF_RANGE = SOLANA_ERROR__TIMESTAMP_OUT_OF_RANGE;
    exports2.SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_BORROW_OUTSTANDING = SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_BORROW_OUTSTANDING;
    exports2.SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_IN_USE = SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_IN_USE;
    exports2.SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_LOADED_TWICE = SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_LOADED_TWICE;
    exports2.SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_NOT_FOUND = SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_NOT_FOUND;
    exports2.SOLANA_ERROR__TRANSACTION_ERROR__ADDRESS_LOOKUP_TABLE_NOT_FOUND = SOLANA_ERROR__TRANSACTION_ERROR__ADDRESS_LOOKUP_TABLE_NOT_FOUND;
    exports2.SOLANA_ERROR__TRANSACTION_ERROR__ALREADY_PROCESSED = SOLANA_ERROR__TRANSACTION_ERROR__ALREADY_PROCESSED;
    exports2.SOLANA_ERROR__TRANSACTION_ERROR__BLOCKHASH_NOT_FOUND = SOLANA_ERROR__TRANSACTION_ERROR__BLOCKHASH_NOT_FOUND;
    exports2.SOLANA_ERROR__TRANSACTION_ERROR__CALL_CHAIN_TOO_DEEP = SOLANA_ERROR__TRANSACTION_ERROR__CALL_CHAIN_TOO_DEEP;
    exports2.SOLANA_ERROR__TRANSACTION_ERROR__CLUSTER_MAINTENANCE = SOLANA_ERROR__TRANSACTION_ERROR__CLUSTER_MAINTENANCE;
    exports2.SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION = SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION;
    exports2.SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_FEE = SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_FEE;
    exports2.SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT = SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT;
    exports2.SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_FOR_FEE = SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_FOR_FEE;
    exports2.SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_INDEX = SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_INDEX;
    exports2.SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_DATA = SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_DATA;
    exports2.SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_INDEX = SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_INDEX;
    exports2.SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_OWNER = SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_OWNER;
    exports2.SOLANA_ERROR__TRANSACTION_ERROR__INVALID_LOADED_ACCOUNTS_DATA_SIZE_LIMIT = SOLANA_ERROR__TRANSACTION_ERROR__INVALID_LOADED_ACCOUNTS_DATA_SIZE_LIMIT;
    exports2.SOLANA_ERROR__TRANSACTION_ERROR__INVALID_PROGRAM_FOR_EXECUTION = SOLANA_ERROR__TRANSACTION_ERROR__INVALID_PROGRAM_FOR_EXECUTION;
    exports2.SOLANA_ERROR__TRANSACTION_ERROR__INVALID_RENT_PAYING_ACCOUNT = SOLANA_ERROR__TRANSACTION_ERROR__INVALID_RENT_PAYING_ACCOUNT;
    exports2.SOLANA_ERROR__TRANSACTION_ERROR__INVALID_WRITABLE_ACCOUNT = SOLANA_ERROR__TRANSACTION_ERROR__INVALID_WRITABLE_ACCOUNT;
    exports2.SOLANA_ERROR__TRANSACTION_ERROR__MAX_LOADED_ACCOUNTS_DATA_SIZE_EXCEEDED = SOLANA_ERROR__TRANSACTION_ERROR__MAX_LOADED_ACCOUNTS_DATA_SIZE_EXCEEDED;
    exports2.SOLANA_ERROR__TRANSACTION_ERROR__MISSING_SIGNATURE_FOR_FEE = SOLANA_ERROR__TRANSACTION_ERROR__MISSING_SIGNATURE_FOR_FEE;
    exports2.SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_ACCOUNT_NOT_FOUND = SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_ACCOUNT_NOT_FOUND;
    exports2.SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED = SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED;
    exports2.SOLANA_ERROR__TRANSACTION_ERROR__RESANITIZATION_NEEDED = SOLANA_ERROR__TRANSACTION_ERROR__RESANITIZATION_NEEDED;
    exports2.SOLANA_ERROR__TRANSACTION_ERROR__SANITIZE_FAILURE = SOLANA_ERROR__TRANSACTION_ERROR__SANITIZE_FAILURE;
    exports2.SOLANA_ERROR__TRANSACTION_ERROR__SIGNATURE_FAILURE = SOLANA_ERROR__TRANSACTION_ERROR__SIGNATURE_FAILURE;
    exports2.SOLANA_ERROR__TRANSACTION_ERROR__TOO_MANY_ACCOUNT_LOCKS = SOLANA_ERROR__TRANSACTION_ERROR__TOO_MANY_ACCOUNT_LOCKS;
    exports2.SOLANA_ERROR__TRANSACTION_ERROR__UNBALANCED_TRANSACTION = SOLANA_ERROR__TRANSACTION_ERROR__UNBALANCED_TRANSACTION;
    exports2.SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN = SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN;
    exports2.SOLANA_ERROR__TRANSACTION_ERROR__UNSUPPORTED_VERSION = SOLANA_ERROR__TRANSACTION_ERROR__UNSUPPORTED_VERSION;
    exports2.SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_BLOCK_LIMIT = SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_BLOCK_LIMIT;
    exports2.SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_TOTAL_LIMIT = SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_TOTAL_LIMIT;
    exports2.SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_ACCOUNT_COST_LIMIT = SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_ACCOUNT_COST_LIMIT;
    exports2.SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_BLOCK_COST_LIMIT = SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_BLOCK_COST_LIMIT;
    exports2.SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_VOTE_COST_LIMIT = SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_VOTE_COST_LIMIT;
    exports2.SOLANA_ERROR__TRANSACTION__ADDRESSES_CANNOT_SIGN_TRANSACTION = SOLANA_ERROR__TRANSACTION__ADDRESSES_CANNOT_SIGN_TRANSACTION;
    exports2.SOLANA_ERROR__TRANSACTION__ADDRESS_MISSING = SOLANA_ERROR__TRANSACTION__ADDRESS_MISSING;
    exports2.SOLANA_ERROR__TRANSACTION__CANNOT_ENCODE_WITH_EMPTY_SIGNATURES = SOLANA_ERROR__TRANSACTION__CANNOT_ENCODE_WITH_EMPTY_SIGNATURES;
    exports2.SOLANA_ERROR__TRANSACTION__EXPECTED_BLOCKHASH_LIFETIME = SOLANA_ERROR__TRANSACTION__EXPECTED_BLOCKHASH_LIFETIME;
    exports2.SOLANA_ERROR__TRANSACTION__EXPECTED_NONCE_LIFETIME = SOLANA_ERROR__TRANSACTION__EXPECTED_NONCE_LIFETIME;
    exports2.SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING = SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING;
    exports2.SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE = SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE;
    exports2.SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_FEE_PAYER_MISSING = SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_FEE_PAYER_MISSING;
    exports2.SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND = SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND;
    exports2.SOLANA_ERROR__TRANSACTION__FAILED_TO_ESTIMATE_COMPUTE_LIMIT = SOLANA_ERROR__TRANSACTION__FAILED_TO_ESTIMATE_COMPUTE_LIMIT;
    exports2.SOLANA_ERROR__TRANSACTION__FEE_PAYER_MISSING = SOLANA_ERROR__TRANSACTION__FEE_PAYER_MISSING;
    exports2.SOLANA_ERROR__TRANSACTION__FEE_PAYER_SIGNATURE_MISSING = SOLANA_ERROR__TRANSACTION__FEE_PAYER_SIGNATURE_MISSING;
    exports2.SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_FIRST_INSTRUCTION_MUST_BE_ADVANCE_NONCE = SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_FIRST_INSTRUCTION_MUST_BE_ADVANCE_NONCE;
    exports2.SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_INSTRUCTIONS_MISSING = SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_INSTRUCTIONS_MISSING;
    exports2.SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES = SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES;
    exports2.SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE = SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE;
    exports2.SOLANA_ERROR__TRANSACTION__MESSAGE_SIGNATURES_MISMATCH = SOLANA_ERROR__TRANSACTION__MESSAGE_SIGNATURES_MISMATCH;
    exports2.SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING = SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING;
    exports2.SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE = SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE;
    exports2.SolanaError = SolanaError;
    exports2.getSolanaErrorFromInstructionError = getSolanaErrorFromInstructionError;
    exports2.getSolanaErrorFromJsonRpcError = getSolanaErrorFromJsonRpcError;
    exports2.getSolanaErrorFromTransactionError = getSolanaErrorFromTransactionError;
    exports2.isSolanaError = isSolanaError;
    exports2.safeCaptureStackTrace = safeCaptureStackTrace;
  }
});

// node_modules/@solana/codecs-core/dist/index.node.cjs
var require_index_node2 = __commonJS({
  "node_modules/@solana/codecs-core/dist/index.node.cjs"(exports2) {
    "use strict";
    var errors = require_index_node();
    var mergeBytes = (byteArrays) => {
      const nonEmptyByteArrays = byteArrays.filter((arr) => arr.length);
      if (nonEmptyByteArrays.length === 0) {
        return byteArrays.length ? byteArrays[0] : new Uint8Array();
      }
      if (nonEmptyByteArrays.length === 1) {
        return nonEmptyByteArrays[0];
      }
      const totalLength = nonEmptyByteArrays.reduce((total, arr) => total + arr.length, 0);
      const result = new Uint8Array(totalLength);
      let offset = 0;
      nonEmptyByteArrays.forEach((arr) => {
        result.set(arr, offset);
        offset += arr.length;
      });
      return result;
    };
    var padBytes = (bytes, length) => {
      if (bytes.length >= length)
        return bytes;
      const paddedBytes = new Uint8Array(length).fill(0);
      paddedBytes.set(bytes);
      return paddedBytes;
    };
    var fixBytes = (bytes, length) => padBytes(bytes.length <= length ? bytes : bytes.slice(0, length), length);
    function containsBytes(data, bytes, offset) {
      const slice = offset === 0 && data.length === bytes.length ? data : data.slice(offset, offset + bytes.length);
      if (slice.length !== bytes.length)
        return false;
      return bytes.every((b, i) => b === slice[i]);
    }
    function getEncodedSize(value, encoder) {
      return "fixedSize" in encoder ? encoder.fixedSize : encoder.getSizeFromValue(value);
    }
    function createEncoder(encoder) {
      return Object.freeze({
        ...encoder,
        encode: (value) => {
          const bytes = new Uint8Array(getEncodedSize(value, encoder));
          encoder.write(value, bytes, 0);
          return bytes;
        }
      });
    }
    function createDecoder(decoder) {
      return Object.freeze({
        ...decoder,
        decode: (bytes, offset = 0) => decoder.read(bytes, offset)[0]
      });
    }
    function createCodec(codec) {
      return Object.freeze({
        ...codec,
        decode: (bytes, offset = 0) => codec.read(bytes, offset)[0],
        encode: (value) => {
          const bytes = new Uint8Array(getEncodedSize(value, codec));
          codec.write(value, bytes, 0);
          return bytes;
        }
      });
    }
    function isFixedSize(codec) {
      return "fixedSize" in codec && typeof codec.fixedSize === "number";
    }
    function assertIsFixedSize(codec) {
      if (!isFixedSize(codec)) {
        throw new errors.SolanaError(errors.SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH);
      }
    }
    function isVariableSize(codec) {
      return !isFixedSize(codec);
    }
    function assertIsVariableSize(codec) {
      if (!isVariableSize(codec)) {
        throw new errors.SolanaError(errors.SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH);
      }
    }
    function combineCodec(encoder, decoder) {
      if (isFixedSize(encoder) !== isFixedSize(decoder)) {
        throw new errors.SolanaError(errors.SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH);
      }
      if (isFixedSize(encoder) && isFixedSize(decoder) && encoder.fixedSize !== decoder.fixedSize) {
        throw new errors.SolanaError(errors.SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH, {
          decoderFixedSize: decoder.fixedSize,
          encoderFixedSize: encoder.fixedSize
        });
      }
      if (!isFixedSize(encoder) && !isFixedSize(decoder) && encoder.maxSize !== decoder.maxSize) {
        throw new errors.SolanaError(errors.SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH, {
          decoderMaxSize: decoder.maxSize,
          encoderMaxSize: encoder.maxSize
        });
      }
      return {
        ...decoder,
        ...encoder,
        decode: decoder.decode,
        encode: encoder.encode,
        read: decoder.read,
        write: encoder.write
      };
    }
    function addEncoderSentinel(encoder, sentinel) {
      const write = (value, bytes, offset) => {
        const encoderBytes = encoder.encode(value);
        if (findSentinelIndex(encoderBytes, sentinel) >= 0) {
          throw new errors.SolanaError(errors.SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL, {
            encodedBytes: encoderBytes,
            hexEncodedBytes: hexBytes(encoderBytes),
            hexSentinel: hexBytes(sentinel),
            sentinel
          });
        }
        bytes.set(encoderBytes, offset);
        offset += encoderBytes.length;
        bytes.set(sentinel, offset);
        offset += sentinel.length;
        return offset;
      };
      if (isFixedSize(encoder)) {
        return createEncoder({ ...encoder, fixedSize: encoder.fixedSize + sentinel.length, write });
      }
      return createEncoder({
        ...encoder,
        ...encoder.maxSize != null ? { maxSize: encoder.maxSize + sentinel.length } : {},
        getSizeFromValue: (value) => encoder.getSizeFromValue(value) + sentinel.length,
        write
      });
    }
    function addDecoderSentinel(decoder, sentinel) {
      const read = (bytes, offset) => {
        const candidateBytes = offset === 0 ? bytes : bytes.slice(offset);
        const sentinelIndex = findSentinelIndex(candidateBytes, sentinel);
        if (sentinelIndex === -1) {
          throw new errors.SolanaError(errors.SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES, {
            decodedBytes: candidateBytes,
            hexDecodedBytes: hexBytes(candidateBytes),
            hexSentinel: hexBytes(sentinel),
            sentinel
          });
        }
        const preSentinelBytes = candidateBytes.slice(0, sentinelIndex);
        return [decoder.decode(preSentinelBytes), offset + preSentinelBytes.length + sentinel.length];
      };
      if (isFixedSize(decoder)) {
        return createDecoder({ ...decoder, fixedSize: decoder.fixedSize + sentinel.length, read });
      }
      return createDecoder({
        ...decoder,
        ...decoder.maxSize != null ? { maxSize: decoder.maxSize + sentinel.length } : {},
        read
      });
    }
    function addCodecSentinel(codec, sentinel) {
      return combineCodec(addEncoderSentinel(codec, sentinel), addDecoderSentinel(codec, sentinel));
    }
    function findSentinelIndex(bytes, sentinel) {
      return bytes.findIndex((byte, index, arr) => {
        if (sentinel.length === 1)
          return byte === sentinel[0];
        return containsBytes(arr, sentinel, index);
      });
    }
    function hexBytes(bytes) {
      return bytes.reduce((str, byte) => str + byte.toString(16).padStart(2, "0"), "");
    }
    function assertByteArrayIsNotEmptyForCodec(codecDescription, bytes, offset = 0) {
      if (bytes.length - offset <= 0) {
        throw new errors.SolanaError(errors.SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY, {
          codecDescription
        });
      }
    }
    function assertByteArrayHasEnoughBytesForCodec(codecDescription, expected, bytes, offset = 0) {
      const bytesLength = bytes.length - offset;
      if (bytesLength < expected) {
        throw new errors.SolanaError(errors.SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH, {
          bytesLength,
          codecDescription,
          expected
        });
      }
    }
    function assertByteArrayOffsetIsNotOutOfRange(codecDescription, offset, bytesLength) {
      if (offset < 0 || offset > bytesLength) {
        throw new errors.SolanaError(errors.SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE, {
          bytesLength,
          codecDescription,
          offset
        });
      }
    }
    function addEncoderSizePrefix(encoder, prefix) {
      const write = (value, bytes, offset) => {
        const encoderBytes = encoder.encode(value);
        offset = prefix.write(encoderBytes.length, bytes, offset);
        bytes.set(encoderBytes, offset);
        return offset + encoderBytes.length;
      };
      if (isFixedSize(prefix) && isFixedSize(encoder)) {
        return createEncoder({ ...encoder, fixedSize: prefix.fixedSize + encoder.fixedSize, write });
      }
      const prefixMaxSize = isFixedSize(prefix) ? prefix.fixedSize : prefix.maxSize ?? null;
      const encoderMaxSize = isFixedSize(encoder) ? encoder.fixedSize : encoder.maxSize ?? null;
      const maxSize = prefixMaxSize !== null && encoderMaxSize !== null ? prefixMaxSize + encoderMaxSize : null;
      return createEncoder({
        ...encoder,
        ...maxSize !== null ? { maxSize } : {},
        getSizeFromValue: (value) => {
          const encoderSize = getEncodedSize(value, encoder);
          return getEncodedSize(encoderSize, prefix) + encoderSize;
        },
        write
      });
    }
    function addDecoderSizePrefix(decoder, prefix) {
      const read = (bytes, offset) => {
        const [bigintSize, decoderOffset] = prefix.read(bytes, offset);
        const size = Number(bigintSize);
        offset = decoderOffset;
        if (offset > 0 || bytes.length > size) {
          bytes = bytes.slice(offset, offset + size);
        }
        assertByteArrayHasEnoughBytesForCodec("addDecoderSizePrefix", size, bytes);
        return [decoder.decode(bytes), offset + size];
      };
      if (isFixedSize(prefix) && isFixedSize(decoder)) {
        return createDecoder({ ...decoder, fixedSize: prefix.fixedSize + decoder.fixedSize, read });
      }
      const prefixMaxSize = isFixedSize(prefix) ? prefix.fixedSize : prefix.maxSize ?? null;
      const decoderMaxSize = isFixedSize(decoder) ? decoder.fixedSize : decoder.maxSize ?? null;
      const maxSize = prefixMaxSize !== null && decoderMaxSize !== null ? prefixMaxSize + decoderMaxSize : null;
      return createDecoder({ ...decoder, ...maxSize !== null ? { maxSize } : {}, read });
    }
    function addCodecSizePrefix(codec, prefix) {
      return combineCodec(addEncoderSizePrefix(codec, prefix), addDecoderSizePrefix(codec, prefix));
    }
    function fixEncoderSize(encoder, fixedBytes) {
      return createEncoder({
        fixedSize: fixedBytes,
        write: (value, bytes, offset) => {
          const variableByteArray = encoder.encode(value);
          const fixedByteArray = variableByteArray.length > fixedBytes ? variableByteArray.slice(0, fixedBytes) : variableByteArray;
          bytes.set(fixedByteArray, offset);
          return offset + fixedBytes;
        }
      });
    }
    function fixDecoderSize(decoder, fixedBytes) {
      return createDecoder({
        fixedSize: fixedBytes,
        read: (bytes, offset) => {
          assertByteArrayHasEnoughBytesForCodec("fixCodecSize", fixedBytes, bytes, offset);
          if (offset > 0 || bytes.length > fixedBytes) {
            bytes = bytes.slice(offset, offset + fixedBytes);
          }
          if (isFixedSize(decoder)) {
            bytes = fixBytes(bytes, decoder.fixedSize);
          }
          const [value] = decoder.read(bytes, 0);
          return [value, offset + fixedBytes];
        }
      });
    }
    function fixCodecSize(codec, fixedBytes) {
      return combineCodec(fixEncoderSize(codec, fixedBytes), fixDecoderSize(codec, fixedBytes));
    }
    function offsetEncoder(encoder, config2) {
      return createEncoder({
        ...encoder,
        write: (value, bytes, preOffset) => {
          const wrapBytes = (offset) => modulo(offset, bytes.length);
          const newPreOffset = config2.preOffset ? config2.preOffset({ bytes, preOffset, wrapBytes }) : preOffset;
          assertByteArrayOffsetIsNotOutOfRange("offsetEncoder", newPreOffset, bytes.length);
          const postOffset = encoder.write(value, bytes, newPreOffset);
          const newPostOffset = config2.postOffset ? config2.postOffset({ bytes, newPreOffset, postOffset, preOffset, wrapBytes }) : postOffset;
          assertByteArrayOffsetIsNotOutOfRange("offsetEncoder", newPostOffset, bytes.length);
          return newPostOffset;
        }
      });
    }
    function offsetDecoder(decoder, config2) {
      return createDecoder({
        ...decoder,
        read: (bytes, preOffset) => {
          const wrapBytes = (offset) => modulo(offset, bytes.length);
          const newPreOffset = config2.preOffset ? config2.preOffset({ bytes, preOffset, wrapBytes }) : preOffset;
          assertByteArrayOffsetIsNotOutOfRange("offsetDecoder", newPreOffset, bytes.length);
          const [value, postOffset] = decoder.read(bytes, newPreOffset);
          const newPostOffset = config2.postOffset ? config2.postOffset({ bytes, newPreOffset, postOffset, preOffset, wrapBytes }) : postOffset;
          assertByteArrayOffsetIsNotOutOfRange("offsetDecoder", newPostOffset, bytes.length);
          return [value, newPostOffset];
        }
      });
    }
    function offsetCodec(codec, config2) {
      return combineCodec(offsetEncoder(codec, config2), offsetDecoder(codec, config2));
    }
    function modulo(dividend, divisor) {
      if (divisor === 0)
        return 0;
      return (dividend % divisor + divisor) % divisor;
    }
    function resizeEncoder(encoder, resize) {
      if (isFixedSize(encoder)) {
        const fixedSize = resize(encoder.fixedSize);
        if (fixedSize < 0) {
          throw new errors.SolanaError(errors.SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH, {
            bytesLength: fixedSize,
            codecDescription: "resizeEncoder"
          });
        }
        return createEncoder({ ...encoder, fixedSize });
      }
      return createEncoder({
        ...encoder,
        getSizeFromValue: (value) => {
          const newSize = resize(encoder.getSizeFromValue(value));
          if (newSize < 0) {
            throw new errors.SolanaError(errors.SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH, {
              bytesLength: newSize,
              codecDescription: "resizeEncoder"
            });
          }
          return newSize;
        }
      });
    }
    function resizeDecoder(decoder, resize) {
      if (isFixedSize(decoder)) {
        const fixedSize = resize(decoder.fixedSize);
        if (fixedSize < 0) {
          throw new errors.SolanaError(errors.SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH, {
            bytesLength: fixedSize,
            codecDescription: "resizeDecoder"
          });
        }
        return createDecoder({ ...decoder, fixedSize });
      }
      return decoder;
    }
    function resizeCodec(codec, resize) {
      return combineCodec(resizeEncoder(codec, resize), resizeDecoder(codec, resize));
    }
    function padLeftEncoder(encoder, offset) {
      return offsetEncoder(
        resizeEncoder(encoder, (size) => size + offset),
        { preOffset: ({ preOffset }) => preOffset + offset }
      );
    }
    function padRightEncoder(encoder, offset) {
      return offsetEncoder(
        resizeEncoder(encoder, (size) => size + offset),
        { postOffset: ({ postOffset }) => postOffset + offset }
      );
    }
    function padLeftDecoder(decoder, offset) {
      return offsetDecoder(
        resizeDecoder(decoder, (size) => size + offset),
        { preOffset: ({ preOffset }) => preOffset + offset }
      );
    }
    function padRightDecoder(decoder, offset) {
      return offsetDecoder(
        resizeDecoder(decoder, (size) => size + offset),
        { postOffset: ({ postOffset }) => postOffset + offset }
      );
    }
    function padLeftCodec(codec, offset) {
      return combineCodec(padLeftEncoder(codec, offset), padLeftDecoder(codec, offset));
    }
    function padRightCodec(codec, offset) {
      return combineCodec(padRightEncoder(codec, offset), padRightDecoder(codec, offset));
    }
    function copySourceToTargetInReverse(source, target_WILL_MUTATE, sourceOffset, sourceLength, targetOffset = 0) {
      while (sourceOffset < --sourceLength) {
        const leftValue = source[sourceOffset];
        target_WILL_MUTATE[sourceOffset + targetOffset] = source[sourceLength];
        target_WILL_MUTATE[sourceLength + targetOffset] = leftValue;
        sourceOffset++;
      }
      if (sourceOffset === sourceLength) {
        target_WILL_MUTATE[sourceOffset + targetOffset] = source[sourceOffset];
      }
    }
    function reverseEncoder(encoder) {
      assertIsFixedSize(encoder);
      return createEncoder({
        ...encoder,
        write: (value, bytes, offset) => {
          const newOffset = encoder.write(value, bytes, offset);
          copySourceToTargetInReverse(
            bytes,
            bytes,
            offset,
            offset + encoder.fixedSize
          );
          return newOffset;
        }
      });
    }
    function reverseDecoder(decoder) {
      assertIsFixedSize(decoder);
      return createDecoder({
        ...decoder,
        read: (bytes, offset) => {
          const reversedBytes = bytes.slice();
          copySourceToTargetInReverse(
            bytes,
            reversedBytes,
            offset,
            offset + decoder.fixedSize
          );
          return decoder.read(reversedBytes, offset);
        }
      });
    }
    function reverseCodec(codec) {
      return combineCodec(reverseEncoder(codec), reverseDecoder(codec));
    }
    function transformEncoder(encoder, unmap) {
      return createEncoder({
        ...isVariableSize(encoder) ? { ...encoder, getSizeFromValue: (value) => encoder.getSizeFromValue(unmap(value)) } : encoder,
        write: (value, bytes, offset) => encoder.write(unmap(value), bytes, offset)
      });
    }
    function transformDecoder(decoder, map) {
      return createDecoder({
        ...decoder,
        read: (bytes, offset) => {
          const [value, newOffset] = decoder.read(bytes, offset);
          return [map(value, bytes, offset), newOffset];
        }
      });
    }
    function transformCodec(codec, unmap, map) {
      return createCodec({
        ...transformEncoder(codec, unmap),
        read: map ? transformDecoder(codec, map).read : codec.read
      });
    }
    exports2.addCodecSentinel = addCodecSentinel;
    exports2.addCodecSizePrefix = addCodecSizePrefix;
    exports2.addDecoderSentinel = addDecoderSentinel;
    exports2.addDecoderSizePrefix = addDecoderSizePrefix;
    exports2.addEncoderSentinel = addEncoderSentinel;
    exports2.addEncoderSizePrefix = addEncoderSizePrefix;
    exports2.assertByteArrayHasEnoughBytesForCodec = assertByteArrayHasEnoughBytesForCodec;
    exports2.assertByteArrayIsNotEmptyForCodec = assertByteArrayIsNotEmptyForCodec;
    exports2.assertByteArrayOffsetIsNotOutOfRange = assertByteArrayOffsetIsNotOutOfRange;
    exports2.assertIsFixedSize = assertIsFixedSize;
    exports2.assertIsVariableSize = assertIsVariableSize;
    exports2.combineCodec = combineCodec;
    exports2.containsBytes = containsBytes;
    exports2.createCodec = createCodec;
    exports2.createDecoder = createDecoder;
    exports2.createEncoder = createEncoder;
    exports2.fixBytes = fixBytes;
    exports2.fixCodecSize = fixCodecSize;
    exports2.fixDecoderSize = fixDecoderSize;
    exports2.fixEncoderSize = fixEncoderSize;
    exports2.getEncodedSize = getEncodedSize;
    exports2.isFixedSize = isFixedSize;
    exports2.isVariableSize = isVariableSize;
    exports2.mergeBytes = mergeBytes;
    exports2.offsetCodec = offsetCodec;
    exports2.offsetDecoder = offsetDecoder;
    exports2.offsetEncoder = offsetEncoder;
    exports2.padBytes = padBytes;
    exports2.padLeftCodec = padLeftCodec;
    exports2.padLeftDecoder = padLeftDecoder;
    exports2.padLeftEncoder = padLeftEncoder;
    exports2.padRightCodec = padRightCodec;
    exports2.padRightDecoder = padRightDecoder;
    exports2.padRightEncoder = padRightEncoder;
    exports2.resizeCodec = resizeCodec;
    exports2.resizeDecoder = resizeDecoder;
    exports2.resizeEncoder = resizeEncoder;
    exports2.reverseCodec = reverseCodec;
    exports2.reverseDecoder = reverseDecoder;
    exports2.reverseEncoder = reverseEncoder;
    exports2.transformCodec = transformCodec;
    exports2.transformDecoder = transformDecoder;
    exports2.transformEncoder = transformEncoder;
  }
});

// node_modules/@solana/codecs-numbers/dist/index.node.cjs
var require_index_node3 = __commonJS({
  "node_modules/@solana/codecs-numbers/dist/index.node.cjs"(exports2) {
    "use strict";
    var errors = require_index_node();
    var codecsCore = require_index_node2();
    function assertNumberIsBetweenForCodec(codecDescription, min2, max2, value) {
      if (value < min2 || value > max2) {
        throw new errors.SolanaError(errors.SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE, {
          codecDescription,
          max: max2,
          min: min2,
          value
        });
      }
    }
    var Endian = /* @__PURE__ */ ((Endian2) => {
      Endian2[Endian2["Little"] = 0] = "Little";
      Endian2[Endian2["Big"] = 1] = "Big";
      return Endian2;
    })(Endian || {});
    function isLittleEndian(config2) {
      return config2?.endian === 1 ? false : true;
    }
    function numberEncoderFactory(input) {
      return codecsCore.createEncoder({
        fixedSize: input.size,
        write(value, bytes, offset) {
          if (input.range) {
            assertNumberIsBetweenForCodec(input.name, input.range[0], input.range[1], value);
          }
          const arrayBuffer = new ArrayBuffer(input.size);
          input.set(new DataView(arrayBuffer), value, isLittleEndian(input.config));
          bytes.set(new Uint8Array(arrayBuffer), offset);
          return offset + input.size;
        }
      });
    }
    function numberDecoderFactory(input) {
      return codecsCore.createDecoder({
        fixedSize: input.size,
        read(bytes, offset = 0) {
          codecsCore.assertByteArrayIsNotEmptyForCodec(input.name, bytes, offset);
          codecsCore.assertByteArrayHasEnoughBytesForCodec(input.name, input.size, bytes, offset);
          const view = new DataView(toArrayBuffer(bytes, offset, input.size));
          return [input.get(view, isLittleEndian(input.config)), offset + input.size];
        }
      });
    }
    function toArrayBuffer(bytes, offset, length) {
      const bytesOffset = bytes.byteOffset + (offset ?? 0);
      const bytesLength = length ?? bytes.byteLength;
      return bytes.buffer.slice(bytesOffset, bytesOffset + bytesLength);
    }
    var getF32Encoder = (config2 = {}) => numberEncoderFactory({
      config: config2,
      name: "f32",
      set: (view, value, le) => view.setFloat32(0, Number(value), le),
      size: 4
    });
    var getF32Decoder = (config2 = {}) => numberDecoderFactory({
      config: config2,
      get: (view, le) => view.getFloat32(0, le),
      name: "f32",
      size: 4
    });
    var getF32Codec = (config2 = {}) => codecsCore.combineCodec(getF32Encoder(config2), getF32Decoder(config2));
    var getF64Encoder = (config2 = {}) => numberEncoderFactory({
      config: config2,
      name: "f64",
      set: (view, value, le) => view.setFloat64(0, Number(value), le),
      size: 8
    });
    var getF64Decoder = (config2 = {}) => numberDecoderFactory({
      config: config2,
      get: (view, le) => view.getFloat64(0, le),
      name: "f64",
      size: 8
    });
    var getF64Codec = (config2 = {}) => codecsCore.combineCodec(getF64Encoder(config2), getF64Decoder(config2));
    var getI128Encoder = (config2 = {}) => numberEncoderFactory({
      config: config2,
      name: "i128",
      range: [-BigInt("0x7fffffffffffffffffffffffffffffff") - 1n, BigInt("0x7fffffffffffffffffffffffffffffff")],
      set: (view, value, le) => {
        const leftOffset = le ? 8 : 0;
        const rightOffset = le ? 0 : 8;
        const rightMask = 0xffffffffffffffffn;
        view.setBigInt64(leftOffset, BigInt(value) >> 64n, le);
        view.setBigUint64(rightOffset, BigInt(value) & rightMask, le);
      },
      size: 16
    });
    var getI128Decoder = (config2 = {}) => numberDecoderFactory({
      config: config2,
      get: (view, le) => {
        const leftOffset = le ? 8 : 0;
        const rightOffset = le ? 0 : 8;
        const left = view.getBigInt64(leftOffset, le);
        const right = view.getBigUint64(rightOffset, le);
        return (left << 64n) + right;
      },
      name: "i128",
      size: 16
    });
    var getI128Codec = (config2 = {}) => codecsCore.combineCodec(getI128Encoder(config2), getI128Decoder(config2));
    var getI16Encoder = (config2 = {}) => numberEncoderFactory({
      config: config2,
      name: "i16",
      range: [-Number("0x7fff") - 1, Number("0x7fff")],
      set: (view, value, le) => view.setInt16(0, Number(value), le),
      size: 2
    });
    var getI16Decoder = (config2 = {}) => numberDecoderFactory({
      config: config2,
      get: (view, le) => view.getInt16(0, le),
      name: "i16",
      size: 2
    });
    var getI16Codec = (config2 = {}) => codecsCore.combineCodec(getI16Encoder(config2), getI16Decoder(config2));
    var getI32Encoder = (config2 = {}) => numberEncoderFactory({
      config: config2,
      name: "i32",
      range: [-Number("0x7fffffff") - 1, Number("0x7fffffff")],
      set: (view, value, le) => view.setInt32(0, Number(value), le),
      size: 4
    });
    var getI32Decoder = (config2 = {}) => numberDecoderFactory({
      config: config2,
      get: (view, le) => view.getInt32(0, le),
      name: "i32",
      size: 4
    });
    var getI32Codec = (config2 = {}) => codecsCore.combineCodec(getI32Encoder(config2), getI32Decoder(config2));
    var getI64Encoder = (config2 = {}) => numberEncoderFactory({
      config: config2,
      name: "i64",
      range: [-BigInt("0x7fffffffffffffff") - 1n, BigInt("0x7fffffffffffffff")],
      set: (view, value, le) => view.setBigInt64(0, BigInt(value), le),
      size: 8
    });
    var getI64Decoder = (config2 = {}) => numberDecoderFactory({
      config: config2,
      get: (view, le) => view.getBigInt64(0, le),
      name: "i64",
      size: 8
    });
    var getI64Codec = (config2 = {}) => codecsCore.combineCodec(getI64Encoder(config2), getI64Decoder(config2));
    var getI8Encoder = () => numberEncoderFactory({
      name: "i8",
      range: [-Number("0x7f") - 1, Number("0x7f")],
      set: (view, value) => view.setInt8(0, Number(value)),
      size: 1
    });
    var getI8Decoder = () => numberDecoderFactory({
      get: (view) => view.getInt8(0),
      name: "i8",
      size: 1
    });
    var getI8Codec = () => codecsCore.combineCodec(getI8Encoder(), getI8Decoder());
    var getShortU16Encoder = () => codecsCore.createEncoder({
      getSizeFromValue: (value) => {
        if (value <= 127)
          return 1;
        if (value <= 16383)
          return 2;
        return 3;
      },
      maxSize: 3,
      write: (value, bytes, offset) => {
        assertNumberIsBetweenForCodec("shortU16", 0, 65535, value);
        const shortU16Bytes = [0];
        for (let ii = 0; ; ii += 1) {
          const alignedValue = Number(value) >> ii * 7;
          if (alignedValue === 0) {
            break;
          }
          const nextSevenBits = 127 & alignedValue;
          shortU16Bytes[ii] = nextSevenBits;
          if (ii > 0) {
            shortU16Bytes[ii - 1] |= 128;
          }
        }
        bytes.set(shortU16Bytes, offset);
        return offset + shortU16Bytes.length;
      }
    });
    var getShortU16Decoder = () => codecsCore.createDecoder({
      maxSize: 3,
      read: (bytes, offset) => {
        let value = 0;
        let byteCount = 0;
        while (++byteCount) {
          const byteIndex = byteCount - 1;
          const currentByte = bytes[offset + byteIndex];
          const nextSevenBits = 127 & currentByte;
          value |= nextSevenBits << byteIndex * 7;
          if ((currentByte & 128) === 0) {
            break;
          }
        }
        return [value, offset + byteCount];
      }
    });
    var getShortU16Codec = () => codecsCore.combineCodec(getShortU16Encoder(), getShortU16Decoder());
    var getU128Encoder = (config2 = {}) => numberEncoderFactory({
      config: config2,
      name: "u128",
      range: [0n, BigInt("0xffffffffffffffffffffffffffffffff")],
      set: (view, value, le) => {
        const leftOffset = le ? 8 : 0;
        const rightOffset = le ? 0 : 8;
        const rightMask = 0xffffffffffffffffn;
        view.setBigUint64(leftOffset, BigInt(value) >> 64n, le);
        view.setBigUint64(rightOffset, BigInt(value) & rightMask, le);
      },
      size: 16
    });
    var getU128Decoder = (config2 = {}) => numberDecoderFactory({
      config: config2,
      get: (view, le) => {
        const leftOffset = le ? 8 : 0;
        const rightOffset = le ? 0 : 8;
        const left = view.getBigUint64(leftOffset, le);
        const right = view.getBigUint64(rightOffset, le);
        return (left << 64n) + right;
      },
      name: "u128",
      size: 16
    });
    var getU128Codec = (config2 = {}) => codecsCore.combineCodec(getU128Encoder(config2), getU128Decoder(config2));
    var getU16Encoder = (config2 = {}) => numberEncoderFactory({
      config: config2,
      name: "u16",
      range: [0, Number("0xffff")],
      set: (view, value, le) => view.setUint16(0, Number(value), le),
      size: 2
    });
    var getU16Decoder = (config2 = {}) => numberDecoderFactory({
      config: config2,
      get: (view, le) => view.getUint16(0, le),
      name: "u16",
      size: 2
    });
    var getU16Codec = (config2 = {}) => codecsCore.combineCodec(getU16Encoder(config2), getU16Decoder(config2));
    var getU32Encoder = (config2 = {}) => numberEncoderFactory({
      config: config2,
      name: "u32",
      range: [0, Number("0xffffffff")],
      set: (view, value, le) => view.setUint32(0, Number(value), le),
      size: 4
    });
    var getU32Decoder = (config2 = {}) => numberDecoderFactory({
      config: config2,
      get: (view, le) => view.getUint32(0, le),
      name: "u32",
      size: 4
    });
    var getU32Codec = (config2 = {}) => codecsCore.combineCodec(getU32Encoder(config2), getU32Decoder(config2));
    var getU64Encoder = (config2 = {}) => numberEncoderFactory({
      config: config2,
      name: "u64",
      range: [0n, BigInt("0xffffffffffffffff")],
      set: (view, value, le) => view.setBigUint64(0, BigInt(value), le),
      size: 8
    });
    var getU64Decoder = (config2 = {}) => numberDecoderFactory({
      config: config2,
      get: (view, le) => view.getBigUint64(0, le),
      name: "u64",
      size: 8
    });
    var getU64Codec = (config2 = {}) => codecsCore.combineCodec(getU64Encoder(config2), getU64Decoder(config2));
    var getU8Encoder = () => numberEncoderFactory({
      name: "u8",
      range: [0, Number("0xff")],
      set: (view, value) => view.setUint8(0, Number(value)),
      size: 1
    });
    var getU8Decoder = () => numberDecoderFactory({
      get: (view) => view.getUint8(0),
      name: "u8",
      size: 1
    });
    var getU8Codec = () => codecsCore.combineCodec(getU8Encoder(), getU8Decoder());
    exports2.Endian = Endian;
    exports2.assertNumberIsBetweenForCodec = assertNumberIsBetweenForCodec;
    exports2.getF32Codec = getF32Codec;
    exports2.getF32Decoder = getF32Decoder;
    exports2.getF32Encoder = getF32Encoder;
    exports2.getF64Codec = getF64Codec;
    exports2.getF64Decoder = getF64Decoder;
    exports2.getF64Encoder = getF64Encoder;
    exports2.getI128Codec = getI128Codec;
    exports2.getI128Decoder = getI128Decoder;
    exports2.getI128Encoder = getI128Encoder;
    exports2.getI16Codec = getI16Codec;
    exports2.getI16Decoder = getI16Decoder;
    exports2.getI16Encoder = getI16Encoder;
    exports2.getI32Codec = getI32Codec;
    exports2.getI32Decoder = getI32Decoder;
    exports2.getI32Encoder = getI32Encoder;
    exports2.getI64Codec = getI64Codec;
    exports2.getI64Decoder = getI64Decoder;
    exports2.getI64Encoder = getI64Encoder;
    exports2.getI8Codec = getI8Codec;
    exports2.getI8Decoder = getI8Decoder;
    exports2.getI8Encoder = getI8Encoder;
    exports2.getShortU16Codec = getShortU16Codec;
    exports2.getShortU16Decoder = getShortU16Decoder;
    exports2.getShortU16Encoder = getShortU16Encoder;
    exports2.getU128Codec = getU128Codec;
    exports2.getU128Decoder = getU128Decoder;
    exports2.getU128Encoder = getU128Encoder;
    exports2.getU16Codec = getU16Codec;
    exports2.getU16Decoder = getU16Decoder;
    exports2.getU16Encoder = getU16Encoder;
    exports2.getU32Codec = getU32Codec;
    exports2.getU32Decoder = getU32Decoder;
    exports2.getU32Encoder = getU32Encoder;
    exports2.getU64Codec = getU64Codec;
    exports2.getU64Decoder = getU64Decoder;
    exports2.getU64Encoder = getU64Encoder;
    exports2.getU8Codec = getU8Codec;
    exports2.getU8Decoder = getU8Decoder;
    exports2.getU8Encoder = getU8Encoder;
  }
});

// node_modules/@solana/codecs-data-structures/dist/index.node.cjs
var require_index_node4 = __commonJS({
  "node_modules/@solana/codecs-data-structures/dist/index.node.cjs"(exports2) {
    "use strict";
    var codecsCore = require_index_node2();
    var codecsNumbers = require_index_node3();
    var errors = require_index_node();
    function assertValidNumberOfItemsForCodec(codecDescription, expected, actual) {
      if (expected !== actual) {
        throw new errors.SolanaError(errors.SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS, {
          actual,
          codecDescription,
          expected
        });
      }
    }
    function maxCodecSizes(sizes) {
      return sizes.reduce(
        (all, size) => all === null || size === null ? null : Math.max(all, size),
        0
      );
    }
    function sumCodecSizes(sizes) {
      return sizes.reduce((all, size) => all === null || size === null ? null : all + size, 0);
    }
    function getFixedSize(codec) {
      return codecsCore.isFixedSize(codec) ? codec.fixedSize : null;
    }
    function getMaxSize(codec) {
      return codecsCore.isFixedSize(codec) ? codec.fixedSize : codec.maxSize ?? null;
    }
    function getArrayEncoder(item, config2 = {}) {
      const size = config2.size ?? codecsNumbers.getU32Encoder();
      const fixedSize = computeArrayLikeCodecSize(size, getFixedSize(item));
      const maxSize = computeArrayLikeCodecSize(size, getMaxSize(item)) ?? void 0;
      return codecsCore.createEncoder({
        ...fixedSize !== null ? { fixedSize } : {
          getSizeFromValue: (array) => {
            const prefixSize = typeof size === "object" ? codecsCore.getEncodedSize(array.length, size) : 0;
            return prefixSize + [...array].reduce((all, value) => all + codecsCore.getEncodedSize(value, item), 0);
          },
          maxSize
        },
        write: (array, bytes, offset) => {
          if (typeof size === "number") {
            assertValidNumberOfItemsForCodec("array", size, array.length);
          }
          if (typeof size === "object") {
            offset = size.write(array.length, bytes, offset);
          }
          array.forEach((value) => {
            offset = item.write(value, bytes, offset);
          });
          return offset;
        }
      });
    }
    function getArrayDecoder(item, config2 = {}) {
      const size = config2.size ?? codecsNumbers.getU32Decoder();
      const itemSize = getFixedSize(item);
      const fixedSize = computeArrayLikeCodecSize(size, itemSize);
      const maxSize = computeArrayLikeCodecSize(size, getMaxSize(item)) ?? void 0;
      return codecsCore.createDecoder({
        ...fixedSize !== null ? { fixedSize } : { maxSize },
        read: (bytes, offset) => {
          const array = [];
          if (typeof size === "object" && bytes.slice(offset).length === 0) {
            return [array, offset];
          }
          if (size === "remainder") {
            while (offset < bytes.length) {
              const [value, newOffset2] = item.read(bytes, offset);
              offset = newOffset2;
              array.push(value);
            }
            return [array, offset];
          }
          const [resolvedSize, newOffset] = typeof size === "number" ? [size, offset] : size.read(bytes, offset);
          offset = newOffset;
          for (let i = 0; i < resolvedSize; i += 1) {
            const [value, newOffset2] = item.read(bytes, offset);
            offset = newOffset2;
            array.push(value);
          }
          return [array, offset];
        }
      });
    }
    function getArrayCodec(item, config2 = {}) {
      return codecsCore.combineCodec(getArrayEncoder(item, config2), getArrayDecoder(item, config2));
    }
    function computeArrayLikeCodecSize(size, itemSize) {
      if (typeof size !== "number")
        return null;
      if (size === 0)
        return 0;
      return itemSize === null ? null : itemSize * size;
    }
    function getBitArrayEncoder(size, config2 = {}) {
      const parsedConfig = typeof config2 === "boolean" ? { backward: config2 } : config2;
      const backward = parsedConfig.backward ?? false;
      return codecsCore.createEncoder({
        fixedSize: size,
        write(value, bytes, offset) {
          const bytesToAdd = [];
          for (let i = 0; i < size; i += 1) {
            let byte = 0;
            for (let j = 0; j < 8; j += 1) {
              const feature = Number(value[i * 8 + j] ?? 0);
              byte |= feature << (backward ? j : 7 - j);
            }
            if (backward) {
              bytesToAdd.unshift(byte);
            } else {
              bytesToAdd.push(byte);
            }
          }
          bytes.set(bytesToAdd, offset);
          return size;
        }
      });
    }
    function getBitArrayDecoder(size, config2 = {}) {
      const parsedConfig = typeof config2 === "boolean" ? { backward: config2 } : config2;
      const backward = parsedConfig.backward ?? false;
      return codecsCore.createDecoder({
        fixedSize: size,
        read(bytes, offset) {
          codecsCore.assertByteArrayHasEnoughBytesForCodec("bitArray", size, bytes, offset);
          const booleans = [];
          let slice = bytes.slice(offset, offset + size);
          slice = backward ? slice.reverse() : slice;
          slice.forEach((byte) => {
            for (let i = 0; i < 8; i += 1) {
              if (backward) {
                booleans.push(Boolean(byte & 1));
                byte >>= 1;
              } else {
                booleans.push(Boolean(byte & 128));
                byte <<= 1;
              }
            }
          });
          return [booleans, offset + size];
        }
      });
    }
    function getBitArrayCodec(size, config2 = {}) {
      return codecsCore.combineCodec(getBitArrayEncoder(size, config2), getBitArrayDecoder(size, config2));
    }
    function getBooleanEncoder(config2 = {}) {
      return codecsCore.transformEncoder(config2.size ?? codecsNumbers.getU8Encoder(), (value) => value ? 1 : 0);
    }
    function getBooleanDecoder(config2 = {}) {
      return codecsCore.transformDecoder(config2.size ?? codecsNumbers.getU8Decoder(), (value) => Number(value) === 1);
    }
    function getBooleanCodec(config2 = {}) {
      return codecsCore.combineCodec(getBooleanEncoder(config2), getBooleanDecoder(config2));
    }
    function getBytesEncoder() {
      return codecsCore.createEncoder({
        getSizeFromValue: (value) => value.length,
        write: (value, bytes, offset) => {
          bytes.set(value, offset);
          return offset + value.length;
        }
      });
    }
    function getBytesDecoder() {
      return codecsCore.createDecoder({
        read: (bytes, offset) => {
          const slice = bytes.slice(offset);
          return [slice, offset + slice.length];
        }
      });
    }
    function getBytesCodec() {
      return codecsCore.combineCodec(getBytesEncoder(), getBytesDecoder());
    }
    var getBase16Decoder = () => codecsCore.createDecoder({
      read(bytes, offset) {
        const value = bytes.slice(offset).reduce((str, byte) => str + byte.toString(16).padStart(2, "0"), "");
        return [value, bytes.length];
      }
    });
    function getConstantEncoder(constant) {
      return codecsCore.createEncoder({
        fixedSize: constant.length,
        write: (_, bytes, offset) => {
          bytes.set(constant, offset);
          return offset + constant.length;
        }
      });
    }
    function getConstantDecoder(constant) {
      return codecsCore.createDecoder({
        fixedSize: constant.length,
        read: (bytes, offset) => {
          const base16 = getBase16Decoder();
          if (!codecsCore.containsBytes(bytes, constant, offset)) {
            throw new errors.SolanaError(errors.SOLANA_ERROR__CODECS__INVALID_CONSTANT, {
              constant,
              data: bytes,
              hexConstant: base16.decode(constant),
              hexData: base16.decode(bytes),
              offset
            });
          }
          return [void 0, offset + constant.length];
        }
      });
    }
    function getConstantCodec(constant) {
      return codecsCore.combineCodec(getConstantEncoder(constant), getConstantDecoder(constant));
    }
    function getTupleEncoder(items) {
      const fixedSize = sumCodecSizes(items.map(getFixedSize));
      const maxSize = sumCodecSizes(items.map(getMaxSize)) ?? void 0;
      return codecsCore.createEncoder({
        ...fixedSize === null ? {
          getSizeFromValue: (value) => items.map((item, index) => codecsCore.getEncodedSize(value[index], item)).reduce((all, one) => all + one, 0),
          maxSize
        } : { fixedSize },
        write: (value, bytes, offset) => {
          assertValidNumberOfItemsForCodec("tuple", items.length, value.length);
          items.forEach((item, index) => {
            offset = item.write(value[index], bytes, offset);
          });
          return offset;
        }
      });
    }
    function getTupleDecoder(items) {
      const fixedSize = sumCodecSizes(items.map(getFixedSize));
      const maxSize = sumCodecSizes(items.map(getMaxSize)) ?? void 0;
      return codecsCore.createDecoder({
        ...fixedSize === null ? { maxSize } : { fixedSize },
        read: (bytes, offset) => {
          const values = [];
          items.forEach((item) => {
            const [newValue, newOffset] = item.read(bytes, offset);
            values.push(newValue);
            offset = newOffset;
          });
          return [values, offset];
        }
      });
    }
    function getTupleCodec(items) {
      return codecsCore.combineCodec(
        getTupleEncoder(items),
        getTupleDecoder(items)
      );
    }
    function getUnionEncoder(variants, getIndexFromValue) {
      const fixedSize = getUnionFixedSize(variants);
      const write = (variant, bytes, offset) => {
        const index = getIndexFromValue(variant);
        assertValidVariantIndex(variants, index);
        return variants[index].write(variant, bytes, offset);
      };
      if (fixedSize !== null) {
        return codecsCore.createEncoder({ fixedSize, write });
      }
      const maxSize = getUnionMaxSize(variants);
      return codecsCore.createEncoder({
        ...maxSize !== null ? { maxSize } : {},
        getSizeFromValue: (variant) => {
          const index = getIndexFromValue(variant);
          assertValidVariantIndex(variants, index);
          return codecsCore.getEncodedSize(variant, variants[index]);
        },
        write
      });
    }
    function getUnionDecoder(variants, getIndexFromBytes) {
      const fixedSize = getUnionFixedSize(variants);
      const read = (bytes, offset) => {
        const index = getIndexFromBytes(bytes, offset);
        assertValidVariantIndex(variants, index);
        return variants[index].read(bytes, offset);
      };
      if (fixedSize !== null) {
        return codecsCore.createDecoder({ fixedSize, read });
      }
      const maxSize = getUnionMaxSize(variants);
      return codecsCore.createDecoder({ ...maxSize !== null ? { maxSize } : {}, read });
    }
    function getUnionCodec(variants, getIndexFromValue, getIndexFromBytes) {
      return codecsCore.combineCodec(
        getUnionEncoder(variants, getIndexFromValue),
        getUnionDecoder(variants, getIndexFromBytes)
      );
    }
    function assertValidVariantIndex(variants, index) {
      if (typeof variants[index] === "undefined") {
        throw new errors.SolanaError(errors.SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE, {
          maxRange: variants.length - 1,
          minRange: 0,
          variant: index
        });
      }
    }
    function getUnionFixedSize(variants) {
      if (variants.length === 0)
        return 0;
      if (!codecsCore.isFixedSize(variants[0]))
        return null;
      const variantSize = variants[0].fixedSize;
      const sameSizedVariants = variants.every((variant) => codecsCore.isFixedSize(variant) && variant.fixedSize === variantSize);
      return sameSizedVariants ? variantSize : null;
    }
    function getUnionMaxSize(variants) {
      return maxCodecSizes(variants.map((variant) => getMaxSize(variant)));
    }
    function getDiscriminatedUnionEncoder(variants, config2 = {}) {
      const discriminatorProperty = config2.discriminator ?? "__kind";
      const prefix = config2.size ?? codecsNumbers.getU8Encoder();
      return getUnionEncoder(
        variants.map(
          ([, variant], index) => codecsCore.transformEncoder(getTupleEncoder([prefix, variant]), (value) => [index, value])
        ),
        (value) => getVariantDiscriminator(variants, value[discriminatorProperty])
      );
    }
    function getDiscriminatedUnionDecoder(variants, config2 = {}) {
      const discriminatorProperty = config2.discriminator ?? "__kind";
      const prefix = config2.size ?? codecsNumbers.getU8Decoder();
      return getUnionDecoder(
        variants.map(
          ([discriminator, variant]) => codecsCore.transformDecoder(getTupleDecoder([prefix, variant]), ([, value]) => ({
            [discriminatorProperty]: discriminator,
            ...value
          }))
        ),
        (bytes, offset) => Number(prefix.read(bytes, offset)[0])
      );
    }
    function getDiscriminatedUnionCodec(variants, config2 = {}) {
      return codecsCore.combineCodec(
        getDiscriminatedUnionEncoder(variants, config2),
        getDiscriminatedUnionDecoder(variants, config2)
      );
    }
    function getVariantDiscriminator(variants, discriminatorValue) {
      const discriminator = variants.findIndex(([key]) => discriminatorValue === key);
      if (discriminator < 0) {
        throw new errors.SolanaError(errors.SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT, {
          value: discriminatorValue,
          variants: variants.map(([key]) => key)
        });
      }
      return discriminator;
    }
    var getDataEnumEncoder = getDiscriminatedUnionEncoder;
    var getDataEnumDecoder = getDiscriminatedUnionDecoder;
    var getDataEnumCodec = getDiscriminatedUnionCodec;
    function getEnumStats(constructor) {
      const numericalValues = [
        ...new Set(Object.values(constructor).filter((v) => typeof v === "number"))
      ].sort();
      const enumRecord = Object.fromEntries(Object.entries(constructor).slice(numericalValues.length));
      const enumKeys = Object.keys(enumRecord);
      const enumValues = Object.values(enumRecord);
      const stringValues = [
        .../* @__PURE__ */ new Set([...enumKeys, ...enumValues.filter((v) => typeof v === "string")])
      ];
      return { enumKeys, enumRecord, enumValues, numericalValues, stringValues };
    }
    function getEnumIndexFromVariant({
      enumKeys,
      enumValues,
      variant
    }) {
      const valueIndex = findLastIndex(enumValues, (value) => value === variant);
      if (valueIndex >= 0)
        return valueIndex;
      return enumKeys.findIndex((key) => key === variant);
    }
    function getEnumIndexFromDiscriminator({
      discriminator,
      enumKeys,
      enumValues,
      useValuesAsDiscriminators
    }) {
      if (!useValuesAsDiscriminators) {
        return discriminator >= 0 && discriminator < enumKeys.length ? discriminator : -1;
      }
      return findLastIndex(enumValues, (value) => value === discriminator);
    }
    function findLastIndex(array, predicate) {
      let l = array.length;
      while (l--) {
        if (predicate(array[l], l, array))
          return l;
      }
      return -1;
    }
    function formatNumericalValues(values) {
      if (values.length === 0)
        return "";
      let range2 = [values[0], values[0]];
      const ranges = [];
      for (let index = 1; index < values.length; index++) {
        const value = values[index];
        if (range2[1] + 1 === value) {
          range2[1] = value;
        } else {
          ranges.push(range2[0] === range2[1] ? `${range2[0]}` : `${range2[0]}-${range2[1]}`);
          range2 = [value, value];
        }
      }
      ranges.push(range2[0] === range2[1] ? `${range2[0]}` : `${range2[0]}-${range2[1]}`);
      return ranges.join(", ");
    }
    function getEnumEncoder(constructor, config2 = {}) {
      const prefix = config2.size ?? codecsNumbers.getU8Encoder();
      const useValuesAsDiscriminators = config2.useValuesAsDiscriminators ?? false;
      const { enumKeys, enumValues, numericalValues, stringValues } = getEnumStats(constructor);
      if (useValuesAsDiscriminators && enumValues.some((value) => typeof value === "string")) {
        throw new errors.SolanaError(errors.SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS, {
          stringValues: enumValues.filter((v) => typeof v === "string")
        });
      }
      return codecsCore.transformEncoder(prefix, (variant) => {
        const index = getEnumIndexFromVariant({ enumKeys, enumValues, variant });
        if (index < 0) {
          throw new errors.SolanaError(errors.SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT, {
            formattedNumericalValues: formatNumericalValues(numericalValues),
            numericalValues,
            stringValues,
            variant
          });
        }
        return useValuesAsDiscriminators ? enumValues[index] : index;
      });
    }
    function getEnumDecoder(constructor, config2 = {}) {
      const prefix = config2.size ?? codecsNumbers.getU8Decoder();
      const useValuesAsDiscriminators = config2.useValuesAsDiscriminators ?? false;
      const { enumKeys, enumValues, numericalValues } = getEnumStats(constructor);
      if (useValuesAsDiscriminators && enumValues.some((value) => typeof value === "string")) {
        throw new errors.SolanaError(errors.SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS, {
          stringValues: enumValues.filter((v) => typeof v === "string")
        });
      }
      return codecsCore.transformDecoder(prefix, (value) => {
        const discriminator = Number(value);
        const index = getEnumIndexFromDiscriminator({
          discriminator,
          enumKeys,
          enumValues,
          useValuesAsDiscriminators
        });
        if (index < 0) {
          const validDiscriminators = useValuesAsDiscriminators ? numericalValues : [...Array(enumKeys.length).keys()];
          throw new errors.SolanaError(errors.SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE, {
            discriminator,
            formattedValidDiscriminators: formatNumericalValues(validDiscriminators),
            validDiscriminators
          });
        }
        return enumValues[index];
      });
    }
    function getEnumCodec(constructor, config2 = {}) {
      return codecsCore.combineCodec(getEnumEncoder(constructor, config2), getEnumDecoder(constructor, config2));
    }
    var getScalarEnumEncoder = getEnumEncoder;
    var getScalarEnumDecoder = getEnumDecoder;
    var getScalarEnumCodec = getEnumCodec;
    function getHiddenPrefixEncoder(encoder, prefixedEncoders) {
      return codecsCore.transformEncoder(
        getTupleEncoder([...prefixedEncoders, encoder]),
        (value) => [...prefixedEncoders.map(() => void 0), value]
      );
    }
    function getHiddenPrefixDecoder(decoder, prefixedDecoders) {
      return codecsCore.transformDecoder(
        getTupleDecoder([...prefixedDecoders, decoder]),
        (tuple) => tuple[tuple.length - 1]
      );
    }
    function getHiddenPrefixCodec(codec, prefixedCodecs) {
      return codecsCore.combineCodec(getHiddenPrefixEncoder(codec, prefixedCodecs), getHiddenPrefixDecoder(codec, prefixedCodecs));
    }
    function getHiddenSuffixEncoder(encoder, suffixedEncoders) {
      return codecsCore.transformEncoder(
        getTupleEncoder([encoder, ...suffixedEncoders]),
        (value) => [value, ...suffixedEncoders.map(() => void 0)]
      );
    }
    function getHiddenSuffixDecoder(decoder, suffixedDecoders) {
      return codecsCore.transformDecoder(
        getTupleDecoder([decoder, ...suffixedDecoders]),
        (tuple) => tuple[0]
      );
    }
    function getHiddenSuffixCodec(codec, suffixedCodecs) {
      return codecsCore.combineCodec(getHiddenSuffixEncoder(codec, suffixedCodecs), getHiddenSuffixDecoder(codec, suffixedCodecs));
    }
    function getMapEncoder(key, value, config2 = {}) {
      return codecsCore.transformEncoder(
        getArrayEncoder(getTupleEncoder([key, value]), config2),
        (map) => [...map.entries()]
      );
    }
    function getMapDecoder(key, value, config2 = {}) {
      return codecsCore.transformDecoder(
        getArrayDecoder(getTupleDecoder([key, value]), config2),
        (entries) => new Map(entries)
      );
    }
    function getMapCodec(key, value, config2 = {}) {
      return codecsCore.combineCodec(getMapEncoder(key, value, config2), getMapDecoder(key, value, config2));
    }
    function getUnitEncoder() {
      return codecsCore.createEncoder({
        fixedSize: 0,
        write: (_value, _bytes, offset) => offset
      });
    }
    function getUnitDecoder() {
      return codecsCore.createDecoder({
        fixedSize: 0,
        read: (_bytes, offset) => [void 0, offset]
      });
    }
    function getUnitCodec() {
      return codecsCore.combineCodec(getUnitEncoder(), getUnitDecoder());
    }
    function getNullableEncoder(item, config2 = {}) {
      const prefix = (() => {
        if (config2.prefix === null) {
          return codecsCore.transformEncoder(getUnitEncoder(), (_boolean) => void 0);
        }
        return getBooleanEncoder({ size: config2.prefix ?? codecsNumbers.getU8Encoder() });
      })();
      const noneValue = (() => {
        if (config2.noneValue === "zeroes") {
          codecsCore.assertIsFixedSize(item);
          return codecsCore.fixEncoderSize(getUnitEncoder(), item.fixedSize);
        }
        if (!config2.noneValue) {
          return getUnitEncoder();
        }
        return getConstantEncoder(config2.noneValue);
      })();
      return getUnionEncoder(
        [
          codecsCore.transformEncoder(getTupleEncoder([prefix, noneValue]), (_value) => [
            false,
            void 0
          ]),
          codecsCore.transformEncoder(getTupleEncoder([prefix, item]), (value) => [true, value])
        ],
        (variant) => Number(variant !== null)
      );
    }
    function getNullableDecoder(item, config2 = {}) {
      const prefix = (() => {
        if (config2.prefix === null) {
          return codecsCore.transformDecoder(getUnitDecoder(), () => false);
        }
        return getBooleanDecoder({ size: config2.prefix ?? codecsNumbers.getU8Decoder() });
      })();
      const noneValue = (() => {
        if (config2.noneValue === "zeroes") {
          codecsCore.assertIsFixedSize(item);
          return codecsCore.fixDecoderSize(getUnitDecoder(), item.fixedSize);
        }
        if (!config2.noneValue) {
          return getUnitDecoder();
        }
        return getConstantDecoder(config2.noneValue);
      })();
      return getUnionDecoder(
        [
          codecsCore.transformDecoder(getTupleDecoder([prefix, noneValue]), () => null),
          codecsCore.transformDecoder(getTupleDecoder([prefix, item]), ([, value]) => value)
        ],
        (bytes, offset) => {
          if (config2.prefix === null && !config2.noneValue) {
            return Number(offset < bytes.length);
          }
          if (config2.prefix === null && config2.noneValue != null) {
            const zeroValue = config2.noneValue === "zeroes" ? new Uint8Array(noneValue.fixedSize).fill(0) : config2.noneValue;
            return codecsCore.containsBytes(bytes, zeroValue, offset) ? 0 : 1;
          }
          return Number(prefix.read(bytes, offset)[0]);
        }
      );
    }
    function getNullableCodec(item, config2 = {}) {
      return codecsCore.combineCodec(
        getNullableEncoder(item, config2),
        getNullableDecoder(item, config2)
      );
    }
    function getSetEncoder(item, config2 = {}) {
      return codecsCore.transformEncoder(getArrayEncoder(item, config2), (set) => [...set]);
    }
    function getSetDecoder(item, config2 = {}) {
      return codecsCore.transformDecoder(getArrayDecoder(item, config2), (entries) => new Set(entries));
    }
    function getSetCodec(item, config2 = {}) {
      return codecsCore.combineCodec(getSetEncoder(item, config2), getSetDecoder(item, config2));
    }
    function getStructEncoder(fields) {
      const fieldCodecs = fields.map(([, codec]) => codec);
      const fixedSize = sumCodecSizes(fieldCodecs.map(getFixedSize));
      const maxSize = sumCodecSizes(fieldCodecs.map(getMaxSize)) ?? void 0;
      return codecsCore.createEncoder({
        ...fixedSize === null ? {
          getSizeFromValue: (value) => fields.map(([key, codec]) => codecsCore.getEncodedSize(value[key], codec)).reduce((all, one) => all + one, 0),
          maxSize
        } : { fixedSize },
        write: (struct10, bytes, offset) => {
          fields.forEach(([key, codec]) => {
            offset = codec.write(struct10[key], bytes, offset);
          });
          return offset;
        }
      });
    }
    function getStructDecoder(fields) {
      const fieldCodecs = fields.map(([, codec]) => codec);
      const fixedSize = sumCodecSizes(fieldCodecs.map(getFixedSize));
      const maxSize = sumCodecSizes(fieldCodecs.map(getMaxSize)) ?? void 0;
      return codecsCore.createDecoder({
        ...fixedSize === null ? { maxSize } : { fixedSize },
        read: (bytes, offset) => {
          const struct10 = {};
          fields.forEach(([key, codec]) => {
            const [value, newOffset] = codec.read(bytes, offset);
            offset = newOffset;
            struct10[key] = value;
          });
          return [struct10, offset];
        }
      });
    }
    function getStructCodec(fields) {
      return codecsCore.combineCodec(
        getStructEncoder(fields),
        getStructDecoder(fields)
      );
    }
    exports2.assertValidNumberOfItemsForCodec = assertValidNumberOfItemsForCodec;
    exports2.getArrayCodec = getArrayCodec;
    exports2.getArrayDecoder = getArrayDecoder;
    exports2.getArrayEncoder = getArrayEncoder;
    exports2.getBitArrayCodec = getBitArrayCodec;
    exports2.getBitArrayDecoder = getBitArrayDecoder;
    exports2.getBitArrayEncoder = getBitArrayEncoder;
    exports2.getBooleanCodec = getBooleanCodec;
    exports2.getBooleanDecoder = getBooleanDecoder;
    exports2.getBooleanEncoder = getBooleanEncoder;
    exports2.getBytesCodec = getBytesCodec;
    exports2.getBytesDecoder = getBytesDecoder;
    exports2.getBytesEncoder = getBytesEncoder;
    exports2.getConstantCodec = getConstantCodec;
    exports2.getConstantDecoder = getConstantDecoder;
    exports2.getConstantEncoder = getConstantEncoder;
    exports2.getDataEnumCodec = getDataEnumCodec;
    exports2.getDataEnumDecoder = getDataEnumDecoder;
    exports2.getDataEnumEncoder = getDataEnumEncoder;
    exports2.getDiscriminatedUnionCodec = getDiscriminatedUnionCodec;
    exports2.getDiscriminatedUnionDecoder = getDiscriminatedUnionDecoder;
    exports2.getDiscriminatedUnionEncoder = getDiscriminatedUnionEncoder;
    exports2.getEnumCodec = getEnumCodec;
    exports2.getEnumDecoder = getEnumDecoder;
    exports2.getEnumEncoder = getEnumEncoder;
    exports2.getHiddenPrefixCodec = getHiddenPrefixCodec;
    exports2.getHiddenPrefixDecoder = getHiddenPrefixDecoder;
    exports2.getHiddenPrefixEncoder = getHiddenPrefixEncoder;
    exports2.getHiddenSuffixCodec = getHiddenSuffixCodec;
    exports2.getHiddenSuffixDecoder = getHiddenSuffixDecoder;
    exports2.getHiddenSuffixEncoder = getHiddenSuffixEncoder;
    exports2.getMapCodec = getMapCodec;
    exports2.getMapDecoder = getMapDecoder;
    exports2.getMapEncoder = getMapEncoder;
    exports2.getNullableCodec = getNullableCodec;
    exports2.getNullableDecoder = getNullableDecoder;
    exports2.getNullableEncoder = getNullableEncoder;
    exports2.getScalarEnumCodec = getScalarEnumCodec;
    exports2.getScalarEnumDecoder = getScalarEnumDecoder;
    exports2.getScalarEnumEncoder = getScalarEnumEncoder;
    exports2.getSetCodec = getSetCodec;
    exports2.getSetDecoder = getSetDecoder;
    exports2.getSetEncoder = getSetEncoder;
    exports2.getStructCodec = getStructCodec;
    exports2.getStructDecoder = getStructDecoder;
    exports2.getStructEncoder = getStructEncoder;
    exports2.getTupleCodec = getTupleCodec;
    exports2.getTupleDecoder = getTupleDecoder;
    exports2.getTupleEncoder = getTupleEncoder;
    exports2.getUnionCodec = getUnionCodec;
    exports2.getUnionDecoder = getUnionDecoder;
    exports2.getUnionEncoder = getUnionEncoder;
    exports2.getUnitCodec = getUnitCodec;
    exports2.getUnitDecoder = getUnitDecoder;
    exports2.getUnitEncoder = getUnitEncoder;
  }
});

// node_modules/@solana/codecs-strings/dist/index.node.cjs
var require_index_node5 = __commonJS({
  "node_modules/@solana/codecs-strings/dist/index.node.cjs"(exports2) {
    "use strict";
    var errors = require_index_node();
    var codecsCore = require_index_node2();
    function assertValidBaseString(alphabet4, testValue, givenValue = testValue) {
      if (!testValue.match(new RegExp(`^[${alphabet4}]*$`))) {
        throw new errors.SolanaError(errors.SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {
          alphabet: alphabet4,
          base: alphabet4.length,
          value: givenValue
        });
      }
    }
    var getBaseXEncoder = (alphabet4) => {
      return codecsCore.createEncoder({
        getSizeFromValue: (value) => {
          const [leadingZeroes, tailChars] = partitionLeadingZeroes(value, alphabet4[0]);
          if (!tailChars)
            return value.length;
          const base10Number = getBigIntFromBaseX(tailChars, alphabet4);
          return leadingZeroes.length + Math.ceil(base10Number.toString(16).length / 2);
        },
        write(value, bytes, offset) {
          assertValidBaseString(alphabet4, value);
          if (value === "")
            return offset;
          const [leadingZeroes, tailChars] = partitionLeadingZeroes(value, alphabet4[0]);
          if (!tailChars) {
            bytes.set(new Uint8Array(leadingZeroes.length).fill(0), offset);
            return offset + leadingZeroes.length;
          }
          let base10Number = getBigIntFromBaseX(tailChars, alphabet4);
          const tailBytes = [];
          while (base10Number > 0n) {
            tailBytes.unshift(Number(base10Number % 256n));
            base10Number /= 256n;
          }
          const bytesToAdd = [...Array(leadingZeroes.length).fill(0), ...tailBytes];
          bytes.set(bytesToAdd, offset);
          return offset + bytesToAdd.length;
        }
      });
    };
    var getBaseXDecoder = (alphabet4) => {
      return codecsCore.createDecoder({
        read(rawBytes, offset) {
          const bytes = offset === 0 ? rawBytes : rawBytes.slice(offset);
          if (bytes.length === 0)
            return ["", 0];
          let trailIndex = bytes.findIndex((n) => n !== 0);
          trailIndex = trailIndex === -1 ? bytes.length : trailIndex;
          const leadingZeroes = alphabet4[0].repeat(trailIndex);
          if (trailIndex === bytes.length)
            return [leadingZeroes, rawBytes.length];
          const base10Number = bytes.slice(trailIndex).reduce((sum2, byte) => sum2 * 256n + BigInt(byte), 0n);
          const tailChars = getBaseXFromBigInt(base10Number, alphabet4);
          return [leadingZeroes + tailChars, rawBytes.length];
        }
      });
    };
    var getBaseXCodec = (alphabet4) => codecsCore.combineCodec(getBaseXEncoder(alphabet4), getBaseXDecoder(alphabet4));
    function partitionLeadingZeroes(value, zeroCharacter) {
      const [leadingZeros, tailChars] = value.split(new RegExp(`((?!${zeroCharacter}).*)`));
      return [leadingZeros, tailChars];
    }
    function getBigIntFromBaseX(value, alphabet4) {
      const base = BigInt(alphabet4.length);
      let sum2 = 0n;
      for (const char of value) {
        sum2 *= base;
        sum2 += BigInt(alphabet4.indexOf(char));
      }
      return sum2;
    }
    function getBaseXFromBigInt(value, alphabet4) {
      const base = BigInt(alphabet4.length);
      const tailChars = [];
      while (value > 0n) {
        tailChars.unshift(alphabet4[Number(value % base)]);
        value /= base;
      }
      return tailChars.join("");
    }
    var alphabet = "0123456789";
    var getBase10Encoder = () => getBaseXEncoder(alphabet);
    var getBase10Decoder = () => getBaseXDecoder(alphabet);
    var getBase10Codec = () => getBaseXCodec(alphabet);
    var INVALID_STRING_ERROR_BASE_CONFIG = {
      alphabet: "0123456789abcdef",
      base: 16
    };
    function charCodeToBase16(char) {
      if (char >= 48 && char <= 57)
        return char - 48;
      if (char >= 65 && char <= 70)
        return char - (65 - 10);
      if (char >= 97 && char <= 102)
        return char - (97 - 10);
    }
    var getBase16Encoder = () => codecsCore.createEncoder({
      getSizeFromValue: (value) => Math.ceil(value.length / 2),
      write(value, bytes, offset) {
        const len = value.length;
        const al = len / 2;
        if (len === 1) {
          const c = value.charCodeAt(0);
          const n = charCodeToBase16(c);
          if (n === void 0) {
            throw new errors.SolanaError(errors.SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {
              ...INVALID_STRING_ERROR_BASE_CONFIG,
              value
            });
          }
          bytes.set([n], offset);
          return 1 + offset;
        }
        const hexBytes = new Uint8Array(al);
        for (let i = 0, j = 0; i < al; i++) {
          const c1 = value.charCodeAt(j++);
          const c2 = value.charCodeAt(j++);
          const n1 = charCodeToBase16(c1);
          const n2 = charCodeToBase16(c2);
          if (n1 === void 0 || n2 === void 0 && !Number.isNaN(c2)) {
            throw new errors.SolanaError(errors.SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {
              ...INVALID_STRING_ERROR_BASE_CONFIG,
              value
            });
          }
          hexBytes[i] = !Number.isNaN(c2) ? n1 << 4 | (n2 ?? 0) : n1;
        }
        bytes.set(hexBytes, offset);
        return hexBytes.length + offset;
      }
    });
    var getBase16Decoder = () => codecsCore.createDecoder({
      read(bytes, offset) {
        const value = bytes.slice(offset).reduce((str, byte) => str + byte.toString(16).padStart(2, "0"), "");
        return [value, bytes.length];
      }
    });
    var getBase16Codec = () => codecsCore.combineCodec(getBase16Encoder(), getBase16Decoder());
    var alphabet2 = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
    var getBase58Encoder = () => getBaseXEncoder(alphabet2);
    var getBase58Decoder = () => getBaseXDecoder(alphabet2);
    var getBase58Codec = () => getBaseXCodec(alphabet2);
    var getBaseXResliceEncoder = (alphabet4, bits) => codecsCore.createEncoder({
      getSizeFromValue: (value) => Math.floor(value.length * bits / 8),
      write(value, bytes, offset) {
        assertValidBaseString(alphabet4, value);
        if (value === "")
          return offset;
        const charIndices = [...value].map((c) => alphabet4.indexOf(c));
        const reslicedBytes = reslice(charIndices, bits, 8, false);
        bytes.set(reslicedBytes, offset);
        return reslicedBytes.length + offset;
      }
    });
    var getBaseXResliceDecoder = (alphabet4, bits) => codecsCore.createDecoder({
      read(rawBytes, offset = 0) {
        const bytes = offset === 0 ? rawBytes : rawBytes.slice(offset);
        if (bytes.length === 0)
          return ["", rawBytes.length];
        const charIndices = reslice([...bytes], 8, bits, true);
        return [charIndices.map((i) => alphabet4[i]).join(""), rawBytes.length];
      }
    });
    var getBaseXResliceCodec = (alphabet4, bits) => codecsCore.combineCodec(getBaseXResliceEncoder(alphabet4, bits), getBaseXResliceDecoder(alphabet4, bits));
    function reslice(input, inputBits, outputBits, useRemainder) {
      const output = [];
      let accumulator = 0;
      let bitsInAccumulator = 0;
      const mask = (1 << outputBits) - 1;
      for (const value of input) {
        accumulator = accumulator << inputBits | value;
        bitsInAccumulator += inputBits;
        while (bitsInAccumulator >= outputBits) {
          bitsInAccumulator -= outputBits;
          output.push(accumulator >> bitsInAccumulator & mask);
        }
      }
      if (useRemainder && bitsInAccumulator > 0) {
        output.push(accumulator << outputBits - bitsInAccumulator & mask);
      }
      return output;
    }
    var alphabet3 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    var getBase64Encoder = () => {
      {
        return codecsCore.createEncoder({
          getSizeFromValue: (value) => Buffer.from(value, "base64").length,
          write(value, bytes, offset) {
            assertValidBaseString(alphabet3, value.replace(/=/g, ""));
            const buffer = Buffer.from(value, "base64");
            bytes.set(buffer, offset);
            return buffer.length + offset;
          }
        });
      }
    };
    var getBase64Decoder = () => {
      {
        return codecsCore.createDecoder({
          read: (bytes, offset = 0) => [Buffer.from(bytes, offset).toString("base64"), bytes.length]
        });
      }
    };
    var getBase64Codec = () => codecsCore.combineCodec(getBase64Encoder(), getBase64Decoder());
    var removeNullCharacters = (value) => (
      // eslint-disable-next-line no-control-regex
      value.replace(/\u0000/g, "")
    );
    var padNullCharacters = (value, chars) => value.padEnd(chars, "\0");
    var e = globalThis.TextDecoder;
    var o = globalThis.TextEncoder;
    var getUtf8Encoder = () => {
      let textEncoder;
      return codecsCore.createEncoder({
        getSizeFromValue: (value) => (textEncoder ||= new o()).encode(value).length,
        write: (value, bytes, offset) => {
          const bytesToAdd = (textEncoder ||= new o()).encode(value);
          bytes.set(bytesToAdd, offset);
          return offset + bytesToAdd.length;
        }
      });
    };
    var getUtf8Decoder = () => {
      let textDecoder;
      return codecsCore.createDecoder({
        read(bytes, offset) {
          const value = (textDecoder ||= new e()).decode(bytes.slice(offset));
          return [removeNullCharacters(value), bytes.length];
        }
      });
    };
    var getUtf8Codec = () => codecsCore.combineCodec(getUtf8Encoder(), getUtf8Decoder());
    exports2.assertValidBaseString = assertValidBaseString;
    exports2.getBase10Codec = getBase10Codec;
    exports2.getBase10Decoder = getBase10Decoder;
    exports2.getBase10Encoder = getBase10Encoder;
    exports2.getBase16Codec = getBase16Codec;
    exports2.getBase16Decoder = getBase16Decoder;
    exports2.getBase16Encoder = getBase16Encoder;
    exports2.getBase58Codec = getBase58Codec;
    exports2.getBase58Decoder = getBase58Decoder;
    exports2.getBase58Encoder = getBase58Encoder;
    exports2.getBase64Codec = getBase64Codec;
    exports2.getBase64Decoder = getBase64Decoder;
    exports2.getBase64Encoder = getBase64Encoder;
    exports2.getBaseXCodec = getBaseXCodec;
    exports2.getBaseXDecoder = getBaseXDecoder;
    exports2.getBaseXEncoder = getBaseXEncoder;
    exports2.getBaseXResliceCodec = getBaseXResliceCodec;
    exports2.getBaseXResliceDecoder = getBaseXResliceDecoder;
    exports2.getBaseXResliceEncoder = getBaseXResliceEncoder;
    exports2.getUtf8Codec = getUtf8Codec;
    exports2.getUtf8Decoder = getUtf8Decoder;
    exports2.getUtf8Encoder = getUtf8Encoder;
    exports2.padNullCharacters = padNullCharacters;
    exports2.removeNullCharacters = removeNullCharacters;
  }
});

// node_modules/@solana/options/dist/index.node.cjs
var require_index_node6 = __commonJS({
  "node_modules/@solana/options/dist/index.node.cjs"(exports2) {
    "use strict";
    var codecsCore = require_index_node2();
    var codecsDataStructures = require_index_node4();
    var codecsNumbers = require_index_node3();
    var some = (value) => ({ __option: "Some", value });
    var none = () => ({ __option: "None" });
    var isOption = (input) => !!(input && typeof input === "object" && "__option" in input && (input.__option === "Some" && "value" in input || input.__option === "None"));
    var isSome = (option) => option.__option === "Some";
    var isNone = (option) => option.__option === "None";
    function unwrapOption(option, fallback) {
      if (isSome(option))
        return option.value;
      return fallback ? fallback() : null;
    }
    var wrapNullable = (nullable) => nullable !== null ? some(nullable) : none();
    function getOptionEncoder(item, config2 = {}) {
      const prefix = (() => {
        if (config2.prefix === null) {
          return codecsCore.transformEncoder(codecsDataStructures.getUnitEncoder(), (_boolean) => void 0);
        }
        return codecsDataStructures.getBooleanEncoder({ size: config2.prefix ?? codecsNumbers.getU8Encoder() });
      })();
      const noneValue = (() => {
        if (config2.noneValue === "zeroes") {
          codecsCore.assertIsFixedSize(item);
          return codecsCore.fixEncoderSize(codecsDataStructures.getUnitEncoder(), item.fixedSize);
        }
        if (!config2.noneValue) {
          return codecsDataStructures.getUnitEncoder();
        }
        return codecsDataStructures.getConstantEncoder(config2.noneValue);
      })();
      return codecsDataStructures.getUnionEncoder(
        [
          codecsCore.transformEncoder(codecsDataStructures.getTupleEncoder([prefix, noneValue]), (_value) => [
            false,
            void 0
          ]),
          codecsCore.transformEncoder(codecsDataStructures.getTupleEncoder([prefix, item]), (value) => [
            true,
            isOption(value) && isSome(value) ? value.value : value
          ])
        ],
        (variant) => {
          const option = isOption(variant) ? variant : wrapNullable(variant);
          return Number(isSome(option));
        }
      );
    }
    function getOptionDecoder(item, config2 = {}) {
      const prefix = (() => {
        if (config2.prefix === null) {
          return codecsCore.transformDecoder(codecsDataStructures.getUnitDecoder(), () => false);
        }
        return codecsDataStructures.getBooleanDecoder({ size: config2.prefix ?? codecsNumbers.getU8Decoder() });
      })();
      const noneValue = (() => {
        if (config2.noneValue === "zeroes") {
          codecsCore.assertIsFixedSize(item);
          return codecsCore.fixDecoderSize(codecsDataStructures.getUnitDecoder(), item.fixedSize);
        }
        if (!config2.noneValue) {
          return codecsDataStructures.getUnitDecoder();
        }
        return codecsDataStructures.getConstantDecoder(config2.noneValue);
      })();
      return codecsDataStructures.getUnionDecoder(
        [
          codecsCore.transformDecoder(codecsDataStructures.getTupleDecoder([prefix, noneValue]), () => none()),
          codecsCore.transformDecoder(codecsDataStructures.getTupleDecoder([prefix, item]), ([, value]) => some(value))
        ],
        (bytes, offset) => {
          if (config2.prefix === null && !config2.noneValue) {
            return Number(offset < bytes.length);
          }
          if (config2.prefix === null && config2.noneValue != null) {
            const zeroValue = config2.noneValue === "zeroes" ? new Uint8Array(noneValue.fixedSize).fill(0) : config2.noneValue;
            return codecsCore.containsBytes(bytes, zeroValue, offset) ? 0 : 1;
          }
          return Number(prefix.read(bytes, offset)[0]);
        }
      );
    }
    function getOptionCodec(item, config2 = {}) {
      return codecsCore.combineCodec(
        getOptionEncoder(item, config2),
        getOptionDecoder(item, config2)
      );
    }
    function unwrapOptionRecursively(input, fallback) {
      if (!input || ArrayBuffer.isView(input)) {
        return input;
      }
      const next = (x) => fallback ? unwrapOptionRecursively(x, fallback) : unwrapOptionRecursively(x);
      if (isOption(input)) {
        if (isSome(input))
          return next(input.value);
        return fallback ? fallback() : null;
      }
      if (Array.isArray(input)) {
        return input.map(next);
      }
      if (typeof input === "object") {
        return Object.fromEntries(Object.entries(input).map(([k, v]) => [k, next(v)]));
      }
      return input;
    }
    exports2.getOptionCodec = getOptionCodec;
    exports2.getOptionDecoder = getOptionDecoder;
    exports2.getOptionEncoder = getOptionEncoder;
    exports2.isNone = isNone;
    exports2.isOption = isOption;
    exports2.isSome = isSome;
    exports2.none = none;
    exports2.some = some;
    exports2.unwrapOption = unwrapOption;
    exports2.unwrapOptionRecursively = unwrapOptionRecursively;
    exports2.wrapNullable = wrapNullable;
  }
});

// node_modules/@solana/codecs/dist/index.node.cjs
var require_index_node7 = __commonJS({
  "node_modules/@solana/codecs/dist/index.node.cjs"(exports2) {
    "use strict";
    var codecsCore = require_index_node2();
    var codecsDataStructures = require_index_node4();
    var codecsNumbers = require_index_node3();
    var codecsStrings = require_index_node5();
    var options = require_index_node6();
    Object.keys(codecsCore).forEach(function(k) {
      if (k !== "default" && !Object.prototype.hasOwnProperty.call(exports2, k))
        Object.defineProperty(exports2, k, {
          enumerable: true,
          get: function() {
            return codecsCore[k];
          }
        });
    });
    Object.keys(codecsDataStructures).forEach(function(k) {
      if (k !== "default" && !Object.prototype.hasOwnProperty.call(exports2, k))
        Object.defineProperty(exports2, k, {
          enumerable: true,
          get: function() {
            return codecsDataStructures[k];
          }
        });
    });
    Object.keys(codecsNumbers).forEach(function(k) {
      if (k !== "default" && !Object.prototype.hasOwnProperty.call(exports2, k))
        Object.defineProperty(exports2, k, {
          enumerable: true,
          get: function() {
            return codecsNumbers[k];
          }
        });
    });
    Object.keys(codecsStrings).forEach(function(k) {
      if (k !== "default" && !Object.prototype.hasOwnProperty.call(exports2, k))
        Object.defineProperty(exports2, k, {
          enumerable: true,
          get: function() {
            return codecsStrings[k];
          }
        });
    });
    Object.keys(options).forEach(function(k) {
      if (k !== "default" && !Object.prototype.hasOwnProperty.call(exports2, k))
        Object.defineProperty(exports2, k, {
          enumerable: true,
          get: function() {
            return options[k];
          }
        });
    });
  }
});

// node_modules/@solana/spl-token-metadata/lib/cjs/field.js
var require_field = __commonJS({
  "node_modules/@solana/spl-token-metadata/lib/cjs/field.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getFieldCodec = exports2.Field = void 0;
    exports2.getFieldConfig = getFieldConfig;
    var codecs_1 = require_index_node7();
    var Field;
    (function(Field2) {
      Field2[Field2["Name"] = 0] = "Name";
      Field2[Field2["Symbol"] = 1] = "Symbol";
      Field2[Field2["Uri"] = 2] = "Uri";
    })(Field || (exports2.Field = Field = {}));
    var getFieldCodec = () => [
      ["Name", (0, codecs_1.getUnitCodec)()],
      ["Symbol", (0, codecs_1.getUnitCodec)()],
      ["Uri", (0, codecs_1.getUnitCodec)()],
      ["Key", (0, codecs_1.getStructCodec)([["value", (0, codecs_1.getTupleCodec)([(0, codecs_1.addCodecSizePrefix)((0, codecs_1.getUtf8Codec)(), (0, codecs_1.getU32Codec)())])]])]
    ];
    exports2.getFieldCodec = getFieldCodec;
    function getFieldConfig(field) {
      if (field === Field.Name || field === "Name" || field === "name") {
        return { __kind: "Name" };
      } else if (field === Field.Symbol || field === "Symbol" || field === "symbol") {
        return { __kind: "Symbol" };
      } else if (field === Field.Uri || field === "Uri" || field === "uri") {
        return { __kind: "Uri" };
      } else {
        return { __kind: "Key", value: [field] };
      }
    }
  }
});

// node_modules/@solana/spl-token-metadata/lib/cjs/instruction.js
var require_instruction = __commonJS({
  "node_modules/@solana/spl-token-metadata/lib/cjs/instruction.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createInitializeInstruction = createInitializeInstruction;
    exports2.createUpdateFieldInstruction = createUpdateFieldInstruction;
    exports2.createRemoveKeyInstruction = createRemoveKeyInstruction;
    exports2.createUpdateAuthorityInstruction = createUpdateAuthorityInstruction;
    exports2.createEmitInstruction = createEmitInstruction;
    var codecs_1 = require_index_node7();
    var web3_js_1 = require("@solana/web3.js");
    var field_js_1 = require_field();
    function getInstructionEncoder(discriminator, dataEncoder) {
      return (0, codecs_1.transformEncoder)((0, codecs_1.getTupleEncoder)([(0, codecs_1.getBytesEncoder)(), dataEncoder]), (data) => [
        discriminator,
        data
      ]);
    }
    function getPublicKeyEncoder() {
      return (0, codecs_1.transformEncoder)((0, codecs_1.fixEncoderSize)((0, codecs_1.getBytesEncoder)(), 32), (publicKey2) => publicKey2.toBytes());
    }
    function getStringEncoder() {
      return (0, codecs_1.addEncoderSizePrefix)((0, codecs_1.getUtf8Encoder)(), (0, codecs_1.getU32Encoder)());
    }
    function createInitializeInstruction(args) {
      const { programId, metadata, updateAuthority, mint, mintAuthority, name, symbol, uri } = args;
      return new web3_js_1.TransactionInstruction({
        programId,
        keys: [
          { isSigner: false, isWritable: true, pubkey: metadata },
          { isSigner: false, isWritable: false, pubkey: updateAuthority },
          { isSigner: false, isWritable: false, pubkey: mint },
          { isSigner: true, isWritable: false, pubkey: mintAuthority }
        ],
        data: Buffer.from(getInstructionEncoder(new Uint8Array([
          /* await splDiscriminate('spl_token_metadata_interface:initialize_account') */
          210,
          225,
          30,
          162,
          88,
          184,
          77,
          141
        ]), (0, codecs_1.getStructEncoder)([
          ["name", getStringEncoder()],
          ["symbol", getStringEncoder()],
          ["uri", getStringEncoder()]
        ])).encode({ name, symbol, uri }))
      });
    }
    function createUpdateFieldInstruction(args) {
      const { programId, metadata, updateAuthority, field, value } = args;
      return new web3_js_1.TransactionInstruction({
        programId,
        keys: [
          { isSigner: false, isWritable: true, pubkey: metadata },
          { isSigner: true, isWritable: false, pubkey: updateAuthority }
        ],
        data: Buffer.from(getInstructionEncoder(new Uint8Array([
          /* await splDiscriminate('spl_token_metadata_interface:updating_field') */
          221,
          233,
          49,
          45,
          181,
          202,
          220,
          200
        ]), (0, codecs_1.getStructEncoder)([
          ["field", (0, codecs_1.getDataEnumCodec)((0, field_js_1.getFieldCodec)())],
          ["value", getStringEncoder()]
        ])).encode({ field: (0, field_js_1.getFieldConfig)(field), value }))
      });
    }
    function createRemoveKeyInstruction(args) {
      const { programId, metadata, updateAuthority, key, idempotent } = args;
      return new web3_js_1.TransactionInstruction({
        programId,
        keys: [
          { isSigner: false, isWritable: true, pubkey: metadata },
          { isSigner: true, isWritable: false, pubkey: updateAuthority }
        ],
        data: Buffer.from(getInstructionEncoder(new Uint8Array([
          /* await splDiscriminate('spl_token_metadata_interface:remove_key_ix') */
          234,
          18,
          32,
          56,
          89,
          141,
          37,
          181
        ]), (0, codecs_1.getStructEncoder)([
          ["idempotent", (0, codecs_1.getBooleanEncoder)()],
          ["key", getStringEncoder()]
        ])).encode({ idempotent, key }))
      });
    }
    function createUpdateAuthorityInstruction(args) {
      const { programId, metadata, oldAuthority, newAuthority } = args;
      return new web3_js_1.TransactionInstruction({
        programId,
        keys: [
          { isSigner: false, isWritable: true, pubkey: metadata },
          { isSigner: true, isWritable: false, pubkey: oldAuthority }
        ],
        data: Buffer.from(getInstructionEncoder(new Uint8Array([
          /* await splDiscriminate('spl_token_metadata_interface:update_the_authority') */
          215,
          228,
          166,
          228,
          84,
          100,
          86,
          123
        ]), (0, codecs_1.getStructEncoder)([["newAuthority", getPublicKeyEncoder()]])).encode({ newAuthority: newAuthority !== null && newAuthority !== void 0 ? newAuthority : web3_js_1.SystemProgram.programId }))
      });
    }
    function createEmitInstruction(args) {
      const { programId, metadata, start, end } = args;
      return new web3_js_1.TransactionInstruction({
        programId,
        keys: [{ isSigner: false, isWritable: false, pubkey: metadata }],
        data: Buffer.from(getInstructionEncoder(new Uint8Array([
          /* await splDiscriminate('spl_token_metadata_interface:emitter') */
          250,
          166,
          180,
          250,
          13,
          12,
          184,
          70
        ]), (0, codecs_1.getStructEncoder)([
          ["start", (0, codecs_1.getOptionEncoder)((0, codecs_1.getU64Encoder)())],
          ["end", (0, codecs_1.getOptionEncoder)((0, codecs_1.getU64Encoder)())]
        ])).encode({ start: start !== null && start !== void 0 ? start : null, end: end !== null && end !== void 0 ? end : null }))
      });
    }
  }
});

// node_modules/@solana/spl-token-metadata/lib/cjs/state.js
var require_state8 = __commonJS({
  "node_modules/@solana/spl-token-metadata/lib/cjs/state.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TOKEN_METADATA_DISCRIMINATOR = void 0;
    exports2.pack = pack;
    exports2.unpack = unpack;
    var web3_js_1 = require("@solana/web3.js");
    var codecs_1 = require_index_node7();
    exports2.TOKEN_METADATA_DISCRIMINATOR = Buffer.from([112, 132, 90, 90, 11, 88, 157, 87]);
    function getStringCodec() {
      return (0, codecs_1.addCodecSizePrefix)((0, codecs_1.getUtf8Codec)(), (0, codecs_1.getU32Codec)());
    }
    var tokenMetadataCodec = (0, codecs_1.getStructCodec)([
      ["updateAuthority", (0, codecs_1.fixCodecSize)((0, codecs_1.getBytesCodec)(), 32)],
      ["mint", (0, codecs_1.fixCodecSize)((0, codecs_1.getBytesCodec)(), 32)],
      ["name", getStringCodec()],
      ["symbol", getStringCodec()],
      ["uri", getStringCodec()],
      ["additionalMetadata", (0, codecs_1.getArrayCodec)((0, codecs_1.getTupleCodec)([getStringCodec(), getStringCodec()]))]
    ]);
    function isNonePubkey(buffer) {
      for (let i = 0; i < buffer.length; i++) {
        if (buffer[i] !== 0) {
          return false;
        }
      }
      return true;
    }
    function pack(meta) {
      var _a;
      const updateAuthority = (_a = meta.updateAuthority) !== null && _a !== void 0 ? _a : web3_js_1.PublicKey.default;
      return tokenMetadataCodec.encode(Object.assign(Object.assign({}, meta), { updateAuthority: updateAuthority.toBuffer(), mint: meta.mint.toBuffer() }));
    }
    function unpack(buffer) {
      const data = tokenMetadataCodec.decode(buffer);
      return isNonePubkey(data.updateAuthority) ? {
        mint: new web3_js_1.PublicKey(data.mint),
        name: data.name,
        symbol: data.symbol,
        uri: data.uri,
        additionalMetadata: data.additionalMetadata
      } : {
        updateAuthority: new web3_js_1.PublicKey(data.updateAuthority),
        mint: new web3_js_1.PublicKey(data.mint),
        name: data.name,
        symbol: data.symbol,
        uri: data.uri,
        additionalMetadata: data.additionalMetadata
      };
    }
  }
});

// node_modules/@solana/spl-token-metadata/lib/cjs/index.js
var require_cjs2 = __commonJS({
  "node_modules/@solana/spl-token-metadata/lib/cjs/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_errors2(), exports2);
    __exportStar(require_field(), exports2);
    __exportStar(require_instruction(), exports2);
    __exportStar(require_state8(), exports2);
  }
});

// node_modules/@solana/spl-token/lib/cjs/extensions/tokenMetadata/state.js
var require_state9 = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/extensions/tokenMetadata/state.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getTokenMetadata = exports2.updateTokenMetadata = void 0;
    var spl_token_metadata_1 = require_cjs2();
    var constants_js_1 = require_constants();
    var extensionType_js_1 = require_extensionType();
    var mint_js_1 = require_mint();
    var getNormalizedTokenMetadataField = (field) => {
      if (field === spl_token_metadata_1.Field.Name || field === "Name" || field === "name") {
        return "name";
      }
      if (field === spl_token_metadata_1.Field.Symbol || field === "Symbol" || field === "symbol") {
        return "symbol";
      }
      if (field === spl_token_metadata_1.Field.Uri || field === "Uri" || field === "uri") {
        return "uri";
      }
      return field;
    };
    function updateTokenMetadata(current, key, value) {
      const field = getNormalizedTokenMetadataField(key);
      if (field === "mint" || field === "updateAuthority") {
        throw new Error(`Cannot update ${field} via this instruction`);
      }
      if (["name", "symbol", "uri"].includes(field)) {
        return Object.assign(Object.assign({}, current), { [field]: value });
      }
      const additionalMetadata = [...current.additionalMetadata];
      const i = current.additionalMetadata.findIndex((x) => x[0] === field);
      if (i === -1) {
        additionalMetadata.push([field, value]);
      } else {
        additionalMetadata[i] = [field, value];
      }
      return Object.assign(Object.assign({}, current), { additionalMetadata });
    }
    exports2.updateTokenMetadata = updateTokenMetadata;
    function getTokenMetadata(connection, address, commitment, programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
      return __awaiter(this, void 0, void 0, function* () {
        const mintInfo = yield (0, mint_js_1.getMint)(connection, address, commitment, programId);
        const data = (0, extensionType_js_1.getExtensionData)(extensionType_js_1.ExtensionType.TokenMetadata, mintInfo.tlvData);
        if (data === null) {
          return null;
        }
        return (0, spl_token_metadata_1.unpack)(data);
      });
    }
    exports2.getTokenMetadata = getTokenMetadata;
  }
});

// node_modules/@solana/spl-token/lib/cjs/state/index.js
var require_state10 = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/state/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_account(), exports2);
    __exportStar(require_mint(), exports2);
    __exportStar(require_multisig(), exports2);
  }
});

// node_modules/@solana/spl-token/lib/cjs/extensions/tokenMetadata/actions.js
var require_actions8 = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/extensions/tokenMetadata/actions.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.tokenMetadataUpdateAuthority = exports2.tokenMetadataRemoveKey = exports2.tokenMetadataUpdateFieldWithRentTransfer = exports2.tokenMetadataUpdateField = exports2.tokenMetadataInitializeWithRentTransfer = exports2.tokenMetadataInitialize = void 0;
    var web3_js_1 = require("@solana/web3.js");
    var spl_token_metadata_1 = require_cjs2();
    var constants_js_1 = require_constants();
    var internal_js_1 = require_internal2();
    var extensionType_js_1 = require_extensionType();
    var state_js_1 = require_state9();
    var errors_js_1 = require_errors();
    var index_js_1 = require_state10();
    function getAdditionalRentForNewMetadata(connection, address, tokenMetadata, programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
      return __awaiter(this, void 0, void 0, function* () {
        const info = yield connection.getAccountInfo(address);
        if (!info) {
          throw new errors_js_1.TokenAccountNotFoundError();
        }
        const extensionLen = (0, spl_token_metadata_1.pack)(tokenMetadata).length;
        const newAccountLen = (0, extensionType_js_1.getNewAccountLenForExtensionLen)(info, address, extensionType_js_1.ExtensionType.TokenMetadata, extensionLen, programId);
        if (newAccountLen <= info.data.length) {
          return 0;
        }
        const newRentExemptMinimum = yield connection.getMinimumBalanceForRentExemption(newAccountLen);
        return newRentExemptMinimum - info.lamports;
      });
    }
    function getAdditionalRentForUpdatedMetadata(connection, address, field, value, programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
      return __awaiter(this, void 0, void 0, function* () {
        const info = yield connection.getAccountInfo(address);
        if (!info) {
          throw new errors_js_1.TokenAccountNotFoundError();
        }
        const mint = (0, index_js_1.unpackMint)(address, info, programId);
        const extensionData = (0, extensionType_js_1.getExtensionData)(extensionType_js_1.ExtensionType.TokenMetadata, mint.tlvData);
        if (extensionData === null) {
          throw new Error("TokenMetadata extension not initialized");
        }
        const updatedTokenMetadata = (0, state_js_1.updateTokenMetadata)((0, spl_token_metadata_1.unpack)(extensionData), field, value);
        const extensionLen = (0, spl_token_metadata_1.pack)(updatedTokenMetadata).length;
        const newAccountLen = (0, extensionType_js_1.getNewAccountLenForExtensionLen)(info, address, extensionType_js_1.ExtensionType.TokenMetadata, extensionLen, programId);
        if (newAccountLen <= info.data.length) {
          return 0;
        }
        const newRentExemptMinimum = yield connection.getMinimumBalanceForRentExemption(newAccountLen);
        return newRentExemptMinimum - info.lamports;
      });
    }
    function tokenMetadataInitialize(connection, payer, mint, updateAuthority, mintAuthority, name, symbol, uri, multiSigners = [], confirmOptions, programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
      return __awaiter(this, void 0, void 0, function* () {
        const [mintAuthorityPublicKey, signers] = (0, internal_js_1.getSigners)(mintAuthority, multiSigners);
        const transaction = new web3_js_1.Transaction().add((0, spl_token_metadata_1.createInitializeInstruction)({
          programId,
          metadata: mint,
          updateAuthority,
          mint,
          mintAuthority: mintAuthorityPublicKey,
          name,
          symbol,
          uri
        }));
        return yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer, ...signers], confirmOptions);
      });
    }
    exports2.tokenMetadataInitialize = tokenMetadataInitialize;
    function tokenMetadataInitializeWithRentTransfer(connection, payer, mint, updateAuthority, mintAuthority, name, symbol, uri, multiSigners = [], confirmOptions, programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
      return __awaiter(this, void 0, void 0, function* () {
        const [mintAuthorityPublicKey, signers] = (0, internal_js_1.getSigners)(mintAuthority, multiSigners);
        const transaction = new web3_js_1.Transaction();
        const lamports = yield getAdditionalRentForNewMetadata(connection, mint, {
          updateAuthority,
          mint,
          name,
          symbol,
          uri,
          additionalMetadata: []
        }, programId);
        if (lamports > 0) {
          transaction.add(web3_js_1.SystemProgram.transfer({ fromPubkey: payer.publicKey, toPubkey: mint, lamports }));
        }
        transaction.add((0, spl_token_metadata_1.createInitializeInstruction)({
          programId,
          metadata: mint,
          updateAuthority,
          mint,
          mintAuthority: mintAuthorityPublicKey,
          name,
          symbol,
          uri
        }));
        return yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer, ...signers], confirmOptions);
      });
    }
    exports2.tokenMetadataInitializeWithRentTransfer = tokenMetadataInitializeWithRentTransfer;
    function tokenMetadataUpdateField(connection, payer, mint, updateAuthority, field, value, multiSigners = [], confirmOptions, programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
      return __awaiter(this, void 0, void 0, function* () {
        const [updateAuthorityPublicKey, signers] = (0, internal_js_1.getSigners)(updateAuthority, multiSigners);
        const transaction = new web3_js_1.Transaction().add((0, spl_token_metadata_1.createUpdateFieldInstruction)({
          programId,
          metadata: mint,
          updateAuthority: updateAuthorityPublicKey,
          field,
          value
        }));
        return yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer, ...signers], confirmOptions);
      });
    }
    exports2.tokenMetadataUpdateField = tokenMetadataUpdateField;
    function tokenMetadataUpdateFieldWithRentTransfer(connection, payer, mint, updateAuthority, field, value, multiSigners = [], confirmOptions, programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
      return __awaiter(this, void 0, void 0, function* () {
        const [updateAuthorityPublicKey, signers] = (0, internal_js_1.getSigners)(updateAuthority, multiSigners);
        const transaction = new web3_js_1.Transaction();
        const lamports = yield getAdditionalRentForUpdatedMetadata(connection, mint, field, value, programId);
        if (lamports > 0) {
          transaction.add(web3_js_1.SystemProgram.transfer({ fromPubkey: payer.publicKey, toPubkey: mint, lamports }));
        }
        transaction.add((0, spl_token_metadata_1.createUpdateFieldInstruction)({
          programId,
          metadata: mint,
          updateAuthority: updateAuthorityPublicKey,
          field,
          value
        }));
        return yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer, ...signers], confirmOptions);
      });
    }
    exports2.tokenMetadataUpdateFieldWithRentTransfer = tokenMetadataUpdateFieldWithRentTransfer;
    function tokenMetadataRemoveKey(connection, payer, mint, updateAuthority, key, idempotent, multiSigners = [], confirmOptions, programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
      return __awaiter(this, void 0, void 0, function* () {
        const [updateAuthorityPublicKey, signers] = (0, internal_js_1.getSigners)(updateAuthority, multiSigners);
        const transaction = new web3_js_1.Transaction().add((0, spl_token_metadata_1.createRemoveKeyInstruction)({
          programId,
          metadata: mint,
          updateAuthority: updateAuthorityPublicKey,
          key,
          idempotent
        }));
        return yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer, ...signers], confirmOptions);
      });
    }
    exports2.tokenMetadataRemoveKey = tokenMetadataRemoveKey;
    function tokenMetadataUpdateAuthority(connection, payer, mint, updateAuthority, newAuthority, multiSigners = [], confirmOptions, programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
      return __awaiter(this, void 0, void 0, function* () {
        const [updateAuthorityPublicKey, signers] = (0, internal_js_1.getSigners)(updateAuthority, multiSigners);
        const transaction = new web3_js_1.Transaction().add((0, spl_token_metadata_1.createUpdateAuthorityInstruction)({
          programId,
          metadata: mint,
          oldAuthority: updateAuthorityPublicKey,
          newAuthority
        }));
        return yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer, ...signers], confirmOptions);
      });
    }
    exports2.tokenMetadataUpdateAuthority = tokenMetadataUpdateAuthority;
  }
});

// node_modules/@solana/spl-token/lib/cjs/extensions/tokenMetadata/index.js
var require_tokenMetadata = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/extensions/tokenMetadata/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_actions8(), exports2);
    __exportStar(require_state9(), exports2);
  }
});

// node_modules/@solana/spl-token/lib/cjs/extensions/index.js
var require_extensions = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/extensions/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_accountType(), exports2);
    __exportStar(require_cpiGuard(), exports2);
    __exportStar(require_defaultAccountState(), exports2);
    __exportStar(require_extensionType(), exports2);
    __exportStar(require_immutableOwner(), exports2);
    __exportStar(require_interestBearingMint(), exports2);
    __exportStar(require_memoTransfer(), exports2);
    __exportStar(require_metadataPointer(), exports2);
    __exportStar(require_tokenMetadata(), exports2);
    __exportStar(require_mintCloseAuthority(), exports2);
    __exportStar(require_nonTransferable(), exports2);
    __exportStar(require_transferFee(), exports2);
    __exportStar(require_permanentDelegate(), exports2);
    __exportStar(require_transferHook(), exports2);
  }
});

// node_modules/@solana/spl-token/lib/cjs/instructions/initializeAccount2.js
var require_initializeAccount2 = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/instructions/initializeAccount2.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.decodeInitializeAccount2InstructionUnchecked = exports2.decodeInitializeAccount2Instruction = exports2.createInitializeAccount2Instruction = exports2.initializeAccount2InstructionData = void 0;
    var buffer_layout_1 = require_Layout();
    var buffer_layout_utils_1 = require_cjs();
    var web3_js_1 = require("@solana/web3.js");
    var constants_js_1 = require_constants();
    var errors_js_1 = require_errors();
    var types_js_1 = require_types();
    exports2.initializeAccount2InstructionData = (0, buffer_layout_1.struct)([
      (0, buffer_layout_1.u8)("instruction"),
      (0, buffer_layout_utils_1.publicKey)("owner")
    ]);
    function createInitializeAccount2Instruction(account, mint, owner, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      const keys = [
        { pubkey: account, isSigner: false, isWritable: true },
        { pubkey: mint, isSigner: false, isWritable: false },
        { pubkey: web3_js_1.SYSVAR_RENT_PUBKEY, isSigner: false, isWritable: false }
      ];
      const data = Buffer.alloc(exports2.initializeAccount2InstructionData.span);
      exports2.initializeAccount2InstructionData.encode({ instruction: types_js_1.TokenInstruction.InitializeAccount2, owner }, data);
      return new web3_js_1.TransactionInstruction({ keys, programId, data });
    }
    exports2.createInitializeAccount2Instruction = createInitializeAccount2Instruction;
    function decodeInitializeAccount2Instruction(instruction, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      if (!instruction.programId.equals(programId))
        throw new errors_js_1.TokenInvalidInstructionProgramError();
      if (instruction.data.length !== exports2.initializeAccount2InstructionData.span)
        throw new errors_js_1.TokenInvalidInstructionDataError();
      const { keys: { account, mint, rent }, data } = decodeInitializeAccount2InstructionUnchecked(instruction);
      if (data.instruction !== types_js_1.TokenInstruction.InitializeAccount2)
        throw new errors_js_1.TokenInvalidInstructionTypeError();
      if (!account || !mint || !rent)
        throw new errors_js_1.TokenInvalidInstructionKeysError();
      return {
        programId,
        keys: {
          account,
          mint,
          rent
        },
        data
      };
    }
    exports2.decodeInitializeAccount2Instruction = decodeInitializeAccount2Instruction;
    function decodeInitializeAccount2InstructionUnchecked({ programId, keys: [account, mint, rent], data }) {
      return {
        programId,
        keys: {
          account,
          mint,
          rent
        },
        data: exports2.initializeAccount2InstructionData.decode(data)
      };
    }
    exports2.decodeInitializeAccount2InstructionUnchecked = decodeInitializeAccount2InstructionUnchecked;
  }
});

// node_modules/@solana/spl-token/lib/cjs/instructions/initializeAccount3.js
var require_initializeAccount3 = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/instructions/initializeAccount3.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.decodeInitializeAccount3InstructionUnchecked = exports2.decodeInitializeAccount3Instruction = exports2.createInitializeAccount3Instruction = exports2.initializeAccount3InstructionData = void 0;
    var buffer_layout_1 = require_Layout();
    var buffer_layout_utils_1 = require_cjs();
    var web3_js_1 = require("@solana/web3.js");
    var constants_js_1 = require_constants();
    var errors_js_1 = require_errors();
    var types_js_1 = require_types();
    exports2.initializeAccount3InstructionData = (0, buffer_layout_1.struct)([
      (0, buffer_layout_1.u8)("instruction"),
      (0, buffer_layout_utils_1.publicKey)("owner")
    ]);
    function createInitializeAccount3Instruction(account, mint, owner, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      const keys = [
        { pubkey: account, isSigner: false, isWritable: true },
        { pubkey: mint, isSigner: false, isWritable: false }
      ];
      const data = Buffer.alloc(exports2.initializeAccount3InstructionData.span);
      exports2.initializeAccount3InstructionData.encode({ instruction: types_js_1.TokenInstruction.InitializeAccount3, owner }, data);
      return new web3_js_1.TransactionInstruction({ keys, programId, data });
    }
    exports2.createInitializeAccount3Instruction = createInitializeAccount3Instruction;
    function decodeInitializeAccount3Instruction(instruction, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      if (!instruction.programId.equals(programId))
        throw new errors_js_1.TokenInvalidInstructionProgramError();
      if (instruction.data.length !== exports2.initializeAccount3InstructionData.span)
        throw new errors_js_1.TokenInvalidInstructionDataError();
      const { keys: { account, mint }, data } = decodeInitializeAccount3InstructionUnchecked(instruction);
      if (data.instruction !== types_js_1.TokenInstruction.InitializeAccount3)
        throw new errors_js_1.TokenInvalidInstructionTypeError();
      if (!account || !mint)
        throw new errors_js_1.TokenInvalidInstructionKeysError();
      return {
        programId,
        keys: {
          account,
          mint
        },
        data
      };
    }
    exports2.decodeInitializeAccount3Instruction = decodeInitializeAccount3Instruction;
    function decodeInitializeAccount3InstructionUnchecked({ programId, keys: [account, mint], data }) {
      return {
        programId,
        keys: {
          account,
          mint
        },
        data: exports2.initializeAccount3InstructionData.decode(data)
      };
    }
    exports2.decodeInitializeAccount3InstructionUnchecked = decodeInitializeAccount3InstructionUnchecked;
  }
});

// node_modules/@solana/spl-token/lib/cjs/instructions/decode.js
var require_decode = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/instructions/decode.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isUiamountToAmountInstruction = exports2.isAmountToUiAmountInstruction = exports2.isInitializeMint2Instruction = exports2.isInitializeAccount3Instruction = exports2.isSyncNativeInstruction = exports2.isInitializeAccount2Instruction = exports2.isBurnCheckedInstruction = exports2.isMintToCheckedInstruction = exports2.isApproveCheckedInstruction = exports2.isTransferCheckedInstruction = exports2.isThawAccountInstruction = exports2.isFreezeAccountInstruction = exports2.isCloseAccountInstruction = exports2.isBurnInstruction = exports2.isMintToInstruction = exports2.isSetAuthorityInstruction = exports2.isRevokeInstruction = exports2.isApproveInstruction = exports2.isTransferInstruction = exports2.isInitializeMultisigInstruction = exports2.isInitializeAccountInstruction = exports2.isInitializeMintInstruction = exports2.decodeInstruction = void 0;
    var buffer_layout_1 = require_Layout();
    var constants_js_1 = require_constants();
    var errors_js_1 = require_errors();
    var amountToUiAmount_js_1 = require_amountToUiAmount();
    var approve_js_1 = require_approve();
    var approveChecked_js_1 = require_approveChecked();
    var burn_js_1 = require_burn();
    var burnChecked_js_1 = require_burnChecked();
    var closeAccount_js_1 = require_closeAccount();
    var freezeAccount_js_1 = require_freezeAccount();
    var initializeAccount_js_1 = require_initializeAccount();
    var initializeAccount2_js_1 = require_initializeAccount2();
    var initializeAccount3_js_1 = require_initializeAccount3();
    var initializeMint_js_1 = require_initializeMint();
    var initializeMint2_js_1 = require_initializeMint2();
    var initializeMultisig_js_1 = require_initializeMultisig();
    var mintTo_js_1 = require_mintTo();
    var mintToChecked_js_1 = require_mintToChecked();
    var revoke_js_1 = require_revoke();
    var setAuthority_js_1 = require_setAuthority();
    var syncNative_js_1 = require_syncNative();
    var thawAccount_js_1 = require_thawAccount();
    var transfer_js_1 = require_transfer();
    var transferChecked_js_1 = require_transferChecked();
    var types_js_1 = require_types();
    var uiAmountToAmount_js_1 = require_uiAmountToAmount();
    function decodeInstruction(instruction, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      if (!instruction.data.length)
        throw new errors_js_1.TokenInvalidInstructionDataError();
      const type = (0, buffer_layout_1.u8)().decode(instruction.data);
      if (type === types_js_1.TokenInstruction.InitializeMint)
        return (0, initializeMint_js_1.decodeInitializeMintInstruction)(instruction, programId);
      if (type === types_js_1.TokenInstruction.InitializeAccount)
        return (0, initializeAccount_js_1.decodeInitializeAccountInstruction)(instruction, programId);
      if (type === types_js_1.TokenInstruction.InitializeMultisig)
        return (0, initializeMultisig_js_1.decodeInitializeMultisigInstruction)(instruction, programId);
      if (type === types_js_1.TokenInstruction.Transfer)
        return (0, transfer_js_1.decodeTransferInstruction)(instruction, programId);
      if (type === types_js_1.TokenInstruction.Approve)
        return (0, approve_js_1.decodeApproveInstruction)(instruction, programId);
      if (type === types_js_1.TokenInstruction.Revoke)
        return (0, revoke_js_1.decodeRevokeInstruction)(instruction, programId);
      if (type === types_js_1.TokenInstruction.SetAuthority)
        return (0, setAuthority_js_1.decodeSetAuthorityInstruction)(instruction, programId);
      if (type === types_js_1.TokenInstruction.MintTo)
        return (0, mintTo_js_1.decodeMintToInstruction)(instruction, programId);
      if (type === types_js_1.TokenInstruction.Burn)
        return (0, burn_js_1.decodeBurnInstruction)(instruction, programId);
      if (type === types_js_1.TokenInstruction.CloseAccount)
        return (0, closeAccount_js_1.decodeCloseAccountInstruction)(instruction, programId);
      if (type === types_js_1.TokenInstruction.FreezeAccount)
        return (0, freezeAccount_js_1.decodeFreezeAccountInstruction)(instruction, programId);
      if (type === types_js_1.TokenInstruction.ThawAccount)
        return (0, thawAccount_js_1.decodeThawAccountInstruction)(instruction, programId);
      if (type === types_js_1.TokenInstruction.TransferChecked)
        return (0, transferChecked_js_1.decodeTransferCheckedInstruction)(instruction, programId);
      if (type === types_js_1.TokenInstruction.ApproveChecked)
        return (0, approveChecked_js_1.decodeApproveCheckedInstruction)(instruction, programId);
      if (type === types_js_1.TokenInstruction.MintToChecked)
        return (0, mintToChecked_js_1.decodeMintToCheckedInstruction)(instruction, programId);
      if (type === types_js_1.TokenInstruction.BurnChecked)
        return (0, burnChecked_js_1.decodeBurnCheckedInstruction)(instruction, programId);
      if (type === types_js_1.TokenInstruction.InitializeAccount2)
        return (0, initializeAccount2_js_1.decodeInitializeAccount2Instruction)(instruction, programId);
      if (type === types_js_1.TokenInstruction.SyncNative)
        return (0, syncNative_js_1.decodeSyncNativeInstruction)(instruction, programId);
      if (type === types_js_1.TokenInstruction.InitializeAccount3)
        return (0, initializeAccount3_js_1.decodeInitializeAccount3Instruction)(instruction, programId);
      if (type === types_js_1.TokenInstruction.InitializeMint2)
        return (0, initializeMint2_js_1.decodeInitializeMint2Instruction)(instruction, programId);
      if (type === types_js_1.TokenInstruction.AmountToUiAmount)
        return (0, amountToUiAmount_js_1.decodeAmountToUiAmountInstruction)(instruction, programId);
      if (type === types_js_1.TokenInstruction.UiAmountToAmount)
        return (0, uiAmountToAmount_js_1.decodeUiAmountToAmountInstruction)(instruction, programId);
      if (type === types_js_1.TokenInstruction.InitializeMultisig2)
        throw new errors_js_1.TokenInvalidInstructionTypeError();
      throw new errors_js_1.TokenInvalidInstructionTypeError();
    }
    exports2.decodeInstruction = decodeInstruction;
    function isInitializeMintInstruction(decoded) {
      return decoded.data.instruction === types_js_1.TokenInstruction.InitializeMint;
    }
    exports2.isInitializeMintInstruction = isInitializeMintInstruction;
    function isInitializeAccountInstruction(decoded) {
      return decoded.data.instruction === types_js_1.TokenInstruction.InitializeAccount;
    }
    exports2.isInitializeAccountInstruction = isInitializeAccountInstruction;
    function isInitializeMultisigInstruction(decoded) {
      return decoded.data.instruction === types_js_1.TokenInstruction.InitializeMultisig;
    }
    exports2.isInitializeMultisigInstruction = isInitializeMultisigInstruction;
    function isTransferInstruction(decoded) {
      return decoded.data.instruction === types_js_1.TokenInstruction.Transfer;
    }
    exports2.isTransferInstruction = isTransferInstruction;
    function isApproveInstruction(decoded) {
      return decoded.data.instruction === types_js_1.TokenInstruction.Approve;
    }
    exports2.isApproveInstruction = isApproveInstruction;
    function isRevokeInstruction(decoded) {
      return decoded.data.instruction === types_js_1.TokenInstruction.Revoke;
    }
    exports2.isRevokeInstruction = isRevokeInstruction;
    function isSetAuthorityInstruction(decoded) {
      return decoded.data.instruction === types_js_1.TokenInstruction.SetAuthority;
    }
    exports2.isSetAuthorityInstruction = isSetAuthorityInstruction;
    function isMintToInstruction(decoded) {
      return decoded.data.instruction === types_js_1.TokenInstruction.MintTo;
    }
    exports2.isMintToInstruction = isMintToInstruction;
    function isBurnInstruction(decoded) {
      return decoded.data.instruction === types_js_1.TokenInstruction.Burn;
    }
    exports2.isBurnInstruction = isBurnInstruction;
    function isCloseAccountInstruction(decoded) {
      return decoded.data.instruction === types_js_1.TokenInstruction.CloseAccount;
    }
    exports2.isCloseAccountInstruction = isCloseAccountInstruction;
    function isFreezeAccountInstruction(decoded) {
      return decoded.data.instruction === types_js_1.TokenInstruction.FreezeAccount;
    }
    exports2.isFreezeAccountInstruction = isFreezeAccountInstruction;
    function isThawAccountInstruction(decoded) {
      return decoded.data.instruction === types_js_1.TokenInstruction.ThawAccount;
    }
    exports2.isThawAccountInstruction = isThawAccountInstruction;
    function isTransferCheckedInstruction(decoded) {
      return decoded.data.instruction === types_js_1.TokenInstruction.TransferChecked;
    }
    exports2.isTransferCheckedInstruction = isTransferCheckedInstruction;
    function isApproveCheckedInstruction(decoded) {
      return decoded.data.instruction === types_js_1.TokenInstruction.ApproveChecked;
    }
    exports2.isApproveCheckedInstruction = isApproveCheckedInstruction;
    function isMintToCheckedInstruction(decoded) {
      return decoded.data.instruction === types_js_1.TokenInstruction.MintToChecked;
    }
    exports2.isMintToCheckedInstruction = isMintToCheckedInstruction;
    function isBurnCheckedInstruction(decoded) {
      return decoded.data.instruction === types_js_1.TokenInstruction.BurnChecked;
    }
    exports2.isBurnCheckedInstruction = isBurnCheckedInstruction;
    function isInitializeAccount2Instruction(decoded) {
      return decoded.data.instruction === types_js_1.TokenInstruction.InitializeAccount2;
    }
    exports2.isInitializeAccount2Instruction = isInitializeAccount2Instruction;
    function isSyncNativeInstruction(decoded) {
      return decoded.data.instruction === types_js_1.TokenInstruction.SyncNative;
    }
    exports2.isSyncNativeInstruction = isSyncNativeInstruction;
    function isInitializeAccount3Instruction(decoded) {
      return decoded.data.instruction === types_js_1.TokenInstruction.InitializeAccount3;
    }
    exports2.isInitializeAccount3Instruction = isInitializeAccount3Instruction;
    function isInitializeMint2Instruction(decoded) {
      return decoded.data.instruction === types_js_1.TokenInstruction.InitializeMint2;
    }
    exports2.isInitializeMint2Instruction = isInitializeMint2Instruction;
    function isAmountToUiAmountInstruction(decoded) {
      return decoded.data.instruction === types_js_1.TokenInstruction.AmountToUiAmount;
    }
    exports2.isAmountToUiAmountInstruction = isAmountToUiAmountInstruction;
    function isUiamountToAmountInstruction(decoded) {
      return decoded.data.instruction === types_js_1.TokenInstruction.UiAmountToAmount;
    }
    exports2.isUiamountToAmountInstruction = isUiamountToAmountInstruction;
  }
});

// node_modules/@solana/spl-token/lib/cjs/instructions/initializeMultisig2.js
var require_initializeMultisig2 = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/instructions/initializeMultisig2.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/@solana/spl-token/lib/cjs/instructions/initializeImmutableOwner.js
var require_initializeImmutableOwner = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/instructions/initializeImmutableOwner.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.decodeInitializeImmutableOwnerInstructionUnchecked = exports2.decodeInitializeImmutableOwnerInstruction = exports2.createInitializeImmutableOwnerInstruction = exports2.initializeImmutableOwnerInstructionData = void 0;
    var buffer_layout_1 = require_Layout();
    var web3_js_1 = require("@solana/web3.js");
    var errors_js_1 = require_errors();
    var types_js_1 = require_types();
    exports2.initializeImmutableOwnerInstructionData = (0, buffer_layout_1.struct)([
      (0, buffer_layout_1.u8)("instruction")
    ]);
    function createInitializeImmutableOwnerInstruction(account, programId) {
      const keys = [{ pubkey: account, isSigner: false, isWritable: true }];
      const data = Buffer.alloc(exports2.initializeImmutableOwnerInstructionData.span);
      exports2.initializeImmutableOwnerInstructionData.encode({
        instruction: types_js_1.TokenInstruction.InitializeImmutableOwner
      }, data);
      return new web3_js_1.TransactionInstruction({ keys, programId, data });
    }
    exports2.createInitializeImmutableOwnerInstruction = createInitializeImmutableOwnerInstruction;
    function decodeInitializeImmutableOwnerInstruction(instruction, programId) {
      if (!instruction.programId.equals(programId))
        throw new errors_js_1.TokenInvalidInstructionProgramError();
      if (instruction.data.length !== exports2.initializeImmutableOwnerInstructionData.span)
        throw new errors_js_1.TokenInvalidInstructionDataError();
      const { keys: { account }, data } = decodeInitializeImmutableOwnerInstructionUnchecked(instruction);
      if (data.instruction !== types_js_1.TokenInstruction.InitializeImmutableOwner)
        throw new errors_js_1.TokenInvalidInstructionTypeError();
      if (!account)
        throw new errors_js_1.TokenInvalidInstructionKeysError();
      return {
        programId,
        keys: {
          account
        },
        data
      };
    }
    exports2.decodeInitializeImmutableOwnerInstruction = decodeInitializeImmutableOwnerInstruction;
    function decodeInitializeImmutableOwnerInstructionUnchecked({ programId, keys: [account], data }) {
      const { instruction } = exports2.initializeImmutableOwnerInstructionData.decode(data);
      return {
        programId,
        keys: {
          account
        },
        data: {
          instruction
        }
      };
    }
    exports2.decodeInitializeImmutableOwnerInstructionUnchecked = decodeInitializeImmutableOwnerInstructionUnchecked;
  }
});

// node_modules/@solana/spl-token/lib/cjs/instructions/initializeMintCloseAuthority.js
var require_initializeMintCloseAuthority = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/instructions/initializeMintCloseAuthority.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.decodeInitializeMintCloseAuthorityInstructionUnchecked = exports2.decodeInitializeMintCloseAuthorityInstruction = exports2.createInitializeMintCloseAuthorityInstruction = exports2.initializeMintCloseAuthorityInstructionData = void 0;
    var buffer_layout_1 = require_Layout();
    var buffer_layout_utils_1 = require_cjs();
    var web3_js_1 = require("@solana/web3.js");
    var constants_js_1 = require_constants();
    var errors_js_1 = require_errors();
    var types_js_1 = require_types();
    exports2.initializeMintCloseAuthorityInstructionData = (0, buffer_layout_1.struct)([
      (0, buffer_layout_1.u8)("instruction"),
      (0, buffer_layout_1.u8)("closeAuthorityOption"),
      (0, buffer_layout_utils_1.publicKey)("closeAuthority")
    ]);
    function createInitializeMintCloseAuthorityInstruction(mint, closeAuthority, programId) {
      if (!(0, constants_js_1.programSupportsExtensions)(programId)) {
        throw new errors_js_1.TokenUnsupportedInstructionError();
      }
      const keys = [{ pubkey: mint, isSigner: false, isWritable: true }];
      const data = Buffer.alloc(exports2.initializeMintCloseAuthorityInstructionData.span);
      exports2.initializeMintCloseAuthorityInstructionData.encode({
        instruction: types_js_1.TokenInstruction.InitializeMintCloseAuthority,
        closeAuthorityOption: closeAuthority ? 1 : 0,
        closeAuthority: closeAuthority || new web3_js_1.PublicKey(0)
      }, data);
      return new web3_js_1.TransactionInstruction({ keys, programId, data });
    }
    exports2.createInitializeMintCloseAuthorityInstruction = createInitializeMintCloseAuthorityInstruction;
    function decodeInitializeMintCloseAuthorityInstruction(instruction, programId) {
      if (!instruction.programId.equals(programId))
        throw new errors_js_1.TokenInvalidInstructionProgramError();
      if (instruction.data.length !== exports2.initializeMintCloseAuthorityInstructionData.span)
        throw new errors_js_1.TokenInvalidInstructionDataError();
      const { keys: { mint }, data } = decodeInitializeMintCloseAuthorityInstructionUnchecked(instruction);
      if (data.instruction !== types_js_1.TokenInstruction.InitializeMintCloseAuthority)
        throw new errors_js_1.TokenInvalidInstructionTypeError();
      if (!mint)
        throw new errors_js_1.TokenInvalidInstructionKeysError();
      return {
        programId,
        keys: {
          mint
        },
        data
      };
    }
    exports2.decodeInitializeMintCloseAuthorityInstruction = decodeInitializeMintCloseAuthorityInstruction;
    function decodeInitializeMintCloseAuthorityInstructionUnchecked({ programId, keys: [mint], data }) {
      const { instruction, closeAuthorityOption, closeAuthority } = exports2.initializeMintCloseAuthorityInstructionData.decode(data);
      return {
        programId,
        keys: {
          mint
        },
        data: {
          instruction,
          closeAuthority: closeAuthorityOption ? closeAuthority : null
        }
      };
    }
    exports2.decodeInitializeMintCloseAuthorityInstructionUnchecked = decodeInitializeMintCloseAuthorityInstructionUnchecked;
  }
});

// node_modules/@solana/spl-token/lib/cjs/instructions/reallocate.js
var require_reallocate = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/instructions/reallocate.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createReallocateInstruction = void 0;
    var buffer_layout_1 = require_Layout();
    var web3_js_1 = require("@solana/web3.js");
    var constants_js_1 = require_constants();
    var errors_js_1 = require_errors();
    var internal_js_1 = require_internal();
    var types_js_1 = require_types();
    function createReallocateInstruction(account, payer, extensionTypes, owner, multiSigners = [], programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
      if (!(0, constants_js_1.programSupportsExtensions)(programId)) {
        throw new errors_js_1.TokenUnsupportedInstructionError();
      }
      const baseKeys = [
        { pubkey: account, isSigner: false, isWritable: true },
        { pubkey: payer, isSigner: true, isWritable: true },
        { pubkey: web3_js_1.SystemProgram.programId, isSigner: false, isWritable: false }
      ];
      const keys = (0, internal_js_1.addSigners)(baseKeys, owner, multiSigners);
      const reallocateInstructionData = (0, buffer_layout_1.struct)([
        (0, buffer_layout_1.u8)("instruction"),
        (0, buffer_layout_1.seq)((0, buffer_layout_1.u16)(), extensionTypes.length, "extensionTypes")
      ]);
      const data = Buffer.alloc(reallocateInstructionData.span);
      reallocateInstructionData.encode({ instruction: types_js_1.TokenInstruction.Reallocate, extensionTypes }, data);
      return new web3_js_1.TransactionInstruction({ keys, programId, data });
    }
    exports2.createReallocateInstruction = createReallocateInstruction;
  }
});

// node_modules/@solana/spl-token/lib/cjs/instructions/initializeNonTransferableMint.js
var require_initializeNonTransferableMint = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/instructions/initializeNonTransferableMint.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createInitializeNonTransferableMintInstruction = exports2.initializeNonTransferableMintInstructionData = void 0;
    var buffer_layout_1 = require_Layout();
    var web3_js_1 = require("@solana/web3.js");
    var constants_js_1 = require_constants();
    var errors_js_1 = require_errors();
    var types_js_1 = require_types();
    exports2.initializeNonTransferableMintInstructionData = (0, buffer_layout_1.struct)([
      (0, buffer_layout_1.u8)("instruction")
    ]);
    function createInitializeNonTransferableMintInstruction(mint, programId) {
      if (!(0, constants_js_1.programSupportsExtensions)(programId)) {
        throw new errors_js_1.TokenUnsupportedInstructionError();
      }
      const keys = [{ pubkey: mint, isSigner: false, isWritable: true }];
      const data = Buffer.alloc(exports2.initializeNonTransferableMintInstructionData.span);
      exports2.initializeNonTransferableMintInstructionData.encode({
        instruction: types_js_1.TokenInstruction.InitializeNonTransferableMint
      }, data);
      return new web3_js_1.TransactionInstruction({ keys, programId, data });
    }
    exports2.createInitializeNonTransferableMintInstruction = createInitializeNonTransferableMintInstruction;
  }
});

// node_modules/@solana/spl-token/lib/cjs/instructions/initializePermanentDelegate.js
var require_initializePermanentDelegate = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/instructions/initializePermanentDelegate.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.decodeInitializePermanentDelegateInstructionUnchecked = exports2.decodeInitializePermanentDelegateInstruction = exports2.createInitializePermanentDelegateInstruction = exports2.initializePermanentDelegateInstructionData = void 0;
    var buffer_layout_1 = require_Layout();
    var buffer_layout_utils_1 = require_cjs();
    var web3_js_1 = require("@solana/web3.js");
    var web3_js_2 = require("@solana/web3.js");
    var constants_js_1 = require_constants();
    var errors_js_1 = require_errors();
    var types_js_1 = require_types();
    exports2.initializePermanentDelegateInstructionData = (0, buffer_layout_1.struct)([
      (0, buffer_layout_1.u8)("instruction"),
      (0, buffer_layout_utils_1.publicKey)("delegate")
    ]);
    function createInitializePermanentDelegateInstruction(mint, permanentDelegate, programId) {
      if (!(0, constants_js_1.programSupportsExtensions)(programId)) {
        throw new errors_js_1.TokenUnsupportedInstructionError();
      }
      const keys = [{ pubkey: mint, isSigner: false, isWritable: true }];
      const data = Buffer.alloc(exports2.initializePermanentDelegateInstructionData.span);
      exports2.initializePermanentDelegateInstructionData.encode({
        instruction: types_js_1.TokenInstruction.InitializePermanentDelegate,
        delegate: permanentDelegate || new web3_js_1.PublicKey(0)
      }, data);
      return new web3_js_2.TransactionInstruction({ keys, programId, data });
    }
    exports2.createInitializePermanentDelegateInstruction = createInitializePermanentDelegateInstruction;
    function decodeInitializePermanentDelegateInstruction(instruction, programId) {
      if (!instruction.programId.equals(programId))
        throw new errors_js_1.TokenInvalidInstructionProgramError();
      if (instruction.data.length !== exports2.initializePermanentDelegateInstructionData.span)
        throw new errors_js_1.TokenInvalidInstructionDataError();
      const { keys: { mint }, data } = decodeInitializePermanentDelegateInstructionUnchecked(instruction);
      if (data.instruction !== types_js_1.TokenInstruction.InitializePermanentDelegate)
        throw new errors_js_1.TokenInvalidInstructionTypeError();
      if (!mint)
        throw new errors_js_1.TokenInvalidInstructionKeysError();
      return {
        programId,
        keys: {
          mint
        },
        data
      };
    }
    exports2.decodeInitializePermanentDelegateInstruction = decodeInitializePermanentDelegateInstruction;
    function decodeInitializePermanentDelegateInstructionUnchecked({ programId, keys: [mint], data }) {
      const { instruction, delegate } = exports2.initializePermanentDelegateInstructionData.decode(data);
      return {
        programId,
        keys: {
          mint
        },
        data: {
          instruction,
          delegate
        }
      };
    }
    exports2.decodeInitializePermanentDelegateInstructionUnchecked = decodeInitializePermanentDelegateInstructionUnchecked;
  }
});

// node_modules/@solana/spl-token/lib/cjs/instructions/index.js
var require_instructions8 = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/instructions/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createEmitInstruction = exports2.createUpdateAuthorityInstruction = exports2.createRemoveKeyInstruction = exports2.createUpdateFieldInstruction = exports2.createInitializeInstruction = void 0;
    var spl_token_metadata_1 = require_cjs2();
    Object.defineProperty(exports2, "createInitializeInstruction", { enumerable: true, get: function() {
      return spl_token_metadata_1.createInitializeInstruction;
    } });
    Object.defineProperty(exports2, "createUpdateFieldInstruction", { enumerable: true, get: function() {
      return spl_token_metadata_1.createUpdateFieldInstruction;
    } });
    Object.defineProperty(exports2, "createRemoveKeyInstruction", { enumerable: true, get: function() {
      return spl_token_metadata_1.createRemoveKeyInstruction;
    } });
    Object.defineProperty(exports2, "createUpdateAuthorityInstruction", { enumerable: true, get: function() {
      return spl_token_metadata_1.createUpdateAuthorityInstruction;
    } });
    Object.defineProperty(exports2, "createEmitInstruction", { enumerable: true, get: function() {
      return spl_token_metadata_1.createEmitInstruction;
    } });
    __exportStar(require_associatedTokenAccount(), exports2);
    __exportStar(require_decode(), exports2);
    __exportStar(require_types(), exports2);
    __exportStar(require_initializeMint(), exports2);
    __exportStar(require_initializeAccount(), exports2);
    __exportStar(require_initializeMultisig(), exports2);
    __exportStar(require_transfer(), exports2);
    __exportStar(require_approve(), exports2);
    __exportStar(require_revoke(), exports2);
    __exportStar(require_setAuthority(), exports2);
    __exportStar(require_mintTo(), exports2);
    __exportStar(require_burn(), exports2);
    __exportStar(require_closeAccount(), exports2);
    __exportStar(require_freezeAccount(), exports2);
    __exportStar(require_thawAccount(), exports2);
    __exportStar(require_transferChecked(), exports2);
    __exportStar(require_approveChecked(), exports2);
    __exportStar(require_mintToChecked(), exports2);
    __exportStar(require_burnChecked(), exports2);
    __exportStar(require_initializeAccount2(), exports2);
    __exportStar(require_syncNative(), exports2);
    __exportStar(require_initializeAccount3(), exports2);
    __exportStar(require_initializeMultisig2(), exports2);
    __exportStar(require_initializeMint2(), exports2);
    __exportStar(require_initializeImmutableOwner(), exports2);
    __exportStar(require_amountToUiAmount(), exports2);
    __exportStar(require_uiAmountToAmount(), exports2);
    __exportStar(require_initializeMintCloseAuthority(), exports2);
    __exportStar(require_reallocate(), exports2);
    __exportStar(require_createNativeMint(), exports2);
    __exportStar(require_initializeNonTransferableMint(), exports2);
    __exportStar(require_initializePermanentDelegate(), exports2);
  }
});

// node_modules/@solana/spl-token/lib/cjs/index.js
var require_cjs3 = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_actions6(), exports2);
    __exportStar(require_constants(), exports2);
    __exportStar(require_errors(), exports2);
    __exportStar(require_extensions(), exports2);
    __exportStar(require_instructions8(), exports2);
    __exportStar(require_state10(), exports2);
  }
});

// node_modules/tiny-invariant/dist/tiny-invariant.cjs.js
var require_tiny_invariant_cjs = __commonJS({
  "node_modules/tiny-invariant/dist/tiny-invariant.cjs.js"(exports2, module2) {
    "use strict";
    var isProduction = process.env.NODE_ENV === "production";
    var prefix = "Invariant failed";
    function invariant(condition, message) {
      if (condition) {
        return;
      }
      if (isProduction) {
        throw new Error(prefix);
      }
      var provided = typeof message === "function" ? message() : message;
      var value = provided ? "".concat(prefix, ": ").concat(provided) : prefix;
      throw new Error(value);
    }
    module2.exports = invariant;
  }
});

// node_modules/@orca-so/common-sdk/dist/web3/network/account-requests.js
var require_account_requests = __commonJS({
  "node_modules/@orca-so/common-sdk/dist/web3/network/account-requests.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getParsedAccount = getParsedAccount;
    exports2.getMultipleParsedAccounts = getMultipleParsedAccounts;
    exports2.getMultipleAccountsInMap = getMultipleAccountsInMap;
    exports2.getMultipleAccounts = getMultipleAccounts;
    var tiny_invariant_1 = __importDefault(require_tiny_invariant_cjs());
    var address_util_1 = require_address_util();
    async function getParsedAccount(connection, address, parser) {
      const value = await connection.getAccountInfo(address_util_1.AddressUtil.toPubKey(address));
      const key = address_util_1.AddressUtil.toPubKey(address);
      return parser.parse(key, value);
    }
    async function getMultipleParsedAccounts(connection, addresses, parser, chunkSize = 100) {
      if (addresses.length === 0) {
        return [];
      }
      const values = await getMultipleAccounts(connection, address_util_1.AddressUtil.toPubKeys(addresses), 10, chunkSize);
      const results = values.map((val) => {
        if (val[1] === null) {
          return null;
        }
        return parser.parse(val[0], val[1]);
      });
      (0, tiny_invariant_1.default)(results.length === addresses.length, "not enough results fetched");
      return results;
    }
    async function getMultipleAccountsInMap(connection, addresses, timeoutAfterSeconds = 10, chunkSize = 100) {
      const results = await getMultipleAccounts(connection, addresses, timeoutAfterSeconds, chunkSize);
      return results.reduce((map, [key, value]) => {
        map.set(key.toBase58(), value);
        return map;
      }, /* @__PURE__ */ new Map());
    }
    async function getMultipleAccounts(connection, addresses, timeoutAfterSeconds = 10, chunkSize = 100) {
      if (addresses.length === 0) {
        return [];
      }
      const promises = [];
      const chunks2 = Math.ceil(addresses.length / chunkSize);
      const result = new Array(chunks2);
      for (let i = 0; i < result.length; i++) {
        const slice = addresses.slice(i * chunkSize, (i + 1) * chunkSize);
        const addressChunk = address_util_1.AddressUtil.toPubKeys(slice);
        const promise = new Promise(async (resolve) => {
          const res = await connection.getMultipleAccountsInfo(addressChunk);
          const fetchedAccountChunk = res.map((result2, index) => {
            return [addressChunk[index], result2];
          });
          result[i] = fetchedAccountChunk;
          resolve();
        });
        promises.push(promise);
      }
      await Promise.race([
        Promise.all(promises),
        timeoutAfter(timeoutAfterSeconds, "connection.getMultipleAccountsInfo timeout")
      ]);
      const flattenedResult = result.flat();
      (0, tiny_invariant_1.default)(flattenedResult.length === addresses.length, "getMultipleAccounts not enough results");
      return flattenedResult;
    }
    function timeoutAfter(seconds, message) {
      return new Promise((_, reject) => {
        setTimeout(() => {
          reject(new Error(message));
        }, seconds * 1e3);
      });
    }
  }
});

// node_modules/@orca-so/common-sdk/dist/web3/network/fetcher/simple-fetcher-impl.js
var require_simple_fetcher_impl = __commonJS({
  "node_modules/@orca-so/common-sdk/dist/web3/network/fetcher/simple-fetcher-impl.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SimpleAccountFetcher = void 0;
    var address_util_1 = require_address_util();
    var account_requests_1 = require_account_requests();
    var SimpleAccountFetcher = class {
      connection;
      retentionPolicy;
      cache = /* @__PURE__ */ new Map();
      constructor(connection, retentionPolicy) {
        this.connection = connection;
        this.retentionPolicy = retentionPolicy;
        this.cache = /* @__PURE__ */ new Map();
      }
      async getAccount(address, parser, opts, now = Date.now()) {
        const addressKey = address_util_1.AddressUtil.toPubKey(address);
        const addressStr = address_util_1.AddressUtil.toString(address);
        const cached = this.cache.get(addressStr);
        const maxAge = this.getMaxAge(this.retentionPolicy.get(parser), opts);
        const elapsed = !!cached ? now - (cached?.fetchedAt ?? 0) : Number.NEGATIVE_INFINITY;
        const expired = elapsed > maxAge;
        if (!!cached && !expired) {
          return cached.value;
        }
        try {
          const accountInfo = await this.connection.getAccountInfo(addressKey);
          const value = parser.parse(addressKey, accountInfo);
          this.cache.set(addressStr, { parser, value, fetchedAt: now });
          return value;
        } catch {
          this.cache.set(addressStr, { parser, value: null, fetchedAt: now });
          return null;
        }
      }
      getMaxAge(parserMaxAge, opts) {
        if (opts?.maxAge !== void 0) {
          return opts.maxAge;
        }
        return parserMaxAge === void 0 ? Number.POSITIVE_INFINITY : parserMaxAge;
      }
      async getAccounts(addresses, parser, opts, now = Date.now()) {
        const addressStrs = address_util_1.AddressUtil.toStrings(addresses);
        await this.fetchAndPopulateCache(addressStrs, parser, opts, now);
        const result = /* @__PURE__ */ new Map();
        addressStrs.forEach((addressStr) => {
          const cached = this.cache.get(addressStr);
          const value = cached?.value;
          result.set(addressStr, value);
        });
        return result;
      }
      async getAccountsAsArray(addresses, parser, opts, now = Date.now()) {
        const addressStrs = address_util_1.AddressUtil.toStrings(addresses);
        await this.fetchAndPopulateCache(addressStrs, parser, opts, now);
        const result = new Array();
        addressStrs.forEach((addressStr) => {
          const cached = this.cache.get(addressStr);
          const value = cached?.value;
          result.push(value);
        });
        return result;
      }
      populateAccounts(accounts, parser, now) {
        Array.from(accounts.entries()).forEach(([key, value]) => {
          this.cache.set(key, { parser, value, fetchedAt: now });
        });
      }
      async refreshAll(now = Date.now(), timeoutInSeconds) {
        const addresses = Array.from(this.cache.keys());
        const fetchedAccountsMap = await (0, account_requests_1.getMultipleAccountsInMap)(this.connection, addresses, timeoutInSeconds);
        for (const [key, cachedContent] of this.cache.entries()) {
          const parser = cachedContent.parser;
          const fetchedEntry = fetchedAccountsMap.get(key);
          const value = parser.parse(address_util_1.AddressUtil.toPubKey(key), fetchedEntry);
          this.cache.set(key, { parser, value, fetchedAt: now });
        }
      }
      async fetchAndPopulateCache(addresses, parser, opts, now = Date.now()) {
        const addressStrs = address_util_1.AddressUtil.toStrings(addresses);
        const maxAge = this.getMaxAge(this.retentionPolicy.get(parser), opts);
        const undefinedAccounts = addressStrs.filter((addressStr) => {
          const cached = this.cache.get(addressStr);
          const elapsed = !!cached ? now - (cached?.fetchedAt ?? 0) : Number.NEGATIVE_INFINITY;
          const expired = elapsed > maxAge;
          return !cached || expired;
        });
        if (undefinedAccounts.length > 0) {
          const fetchedAccountsMap = await (0, account_requests_1.getMultipleAccountsInMap)(this.connection, undefinedAccounts, opts?.timeoutInSeconds);
          undefinedAccounts.forEach((key) => {
            const fetchedEntry = fetchedAccountsMap.get(key);
            const value = parser.parse(address_util_1.AddressUtil.toPubKey(key), fetchedEntry);
            this.cache.set(key, { parser, value, fetchedAt: now });
          });
        }
      }
    };
    exports2.SimpleAccountFetcher = SimpleAccountFetcher;
  }
});

// node_modules/@orca-so/common-sdk/dist/web3/network/fetcher/index.js
var require_fetcher = __commonJS({
  "node_modules/@orca-so/common-sdk/dist/web3/network/fetcher/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_simple_fetcher_impl(), exports2);
  }
});

// node_modules/@orca-so/common-sdk/dist/web3/network/parsing.js
var require_parsing = __commonJS({
  "node_modules/@orca-so/common-sdk/dist/web3/network/parsing.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ParsableMintInfo = exports2.ParsableTokenAccountInfo = void 0;
    exports2.staticImplements = staticImplements;
    var spl_token_1 = require_cjs3();
    var ParsableTokenAccountInfo = class ParsableTokenAccountInfo {
      constructor() {
      }
      static parse(address, data) {
        if (!data) {
          return null;
        }
        try {
          return {
            ...(0, spl_token_1.unpackAccount)(address, data, data.owner),
            tokenProgram: data.owner
          };
        } catch (e) {
          console.error(`error while parsing TokenAccount ${address.toBase58()}: ${e}`);
          return null;
        }
      }
    };
    exports2.ParsableTokenAccountInfo = ParsableTokenAccountInfo;
    exports2.ParsableTokenAccountInfo = ParsableTokenAccountInfo = __decorate([
      staticImplements()
    ], ParsableTokenAccountInfo);
    var ParsableMintInfo = class ParsableMintInfo {
      constructor() {
      }
      static parse(address, data) {
        if (!data) {
          return null;
        }
        try {
          return {
            ...(0, spl_token_1.unpackMint)(address, data, data.owner),
            tokenProgram: data.owner
          };
        } catch (e) {
          console.error(`error while parsing Mint ${address.toBase58()}: ${e}`);
          return null;
        }
      }
    };
    exports2.ParsableMintInfo = ParsableMintInfo;
    exports2.ParsableMintInfo = ParsableMintInfo = __decorate([
      staticImplements()
    ], ParsableMintInfo);
    function staticImplements() {
      return (constructor) => {
        constructor;
      };
    }
  }
});

// node_modules/@orca-so/common-sdk/dist/web3/network/index.js
var require_network = __commonJS({
  "node_modules/@orca-so/common-sdk/dist/web3/network/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_account_requests(), exports2);
    __exportStar(require_fetcher(), exports2);
    __exportStar(require_parsing(), exports2);
  }
});

// node_modules/@noble/hashes/cryptoNode.js
var require_cryptoNode = __commonJS({
  "node_modules/@noble/hashes/cryptoNode.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.crypto = void 0;
    var nc = require("node:crypto");
    exports2.crypto = nc && typeof nc === "object" && "webcrypto" in nc ? nc.webcrypto : nc && typeof nc === "object" && "randomBytes" in nc ? nc : void 0;
  }
});

// node_modules/@noble/hashes/utils.js
var require_utils = __commonJS({
  "node_modules/@noble/hashes/utils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.wrapXOFConstructorWithOpts = exports2.wrapConstructorWithOpts = exports2.wrapConstructor = exports2.Hash = exports2.nextTick = exports2.swap32IfBE = exports2.byteSwapIfBE = exports2.swap8IfBE = exports2.isLE = void 0;
    exports2.isBytes = isBytes;
    exports2.anumber = anumber;
    exports2.abytes = abytes;
    exports2.ahash = ahash;
    exports2.aexists = aexists;
    exports2.aoutput = aoutput;
    exports2.u8 = u89;
    exports2.u32 = u324;
    exports2.clean = clean;
    exports2.createView = createView;
    exports2.rotr = rotr;
    exports2.rotl = rotl;
    exports2.byteSwap = byteSwap;
    exports2.byteSwap32 = byteSwap32;
    exports2.bytesToHex = bytesToHex;
    exports2.hexToBytes = hexToBytes;
    exports2.asyncLoop = asyncLoop;
    exports2.utf8ToBytes = utf8ToBytes;
    exports2.bytesToUtf8 = bytesToUtf8;
    exports2.toBytes = toBytes;
    exports2.kdfInputToBytes = kdfInputToBytes;
    exports2.concatBytes = concatBytes;
    exports2.checkOpts = checkOpts;
    exports2.createHasher = createHasher;
    exports2.createOptHasher = createOptHasher;
    exports2.createXOFer = createXOFer;
    exports2.randomBytes = randomBytes;
    var crypto_1 = require_cryptoNode();
    function isBytes(a) {
      return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === "Uint8Array";
    }
    function anumber(n) {
      if (!Number.isSafeInteger(n) || n < 0)
        throw new Error("positive integer expected, got " + n);
    }
    function abytes(b, ...lengths) {
      if (!isBytes(b))
        throw new Error("Uint8Array expected");
      if (lengths.length > 0 && !lengths.includes(b.length))
        throw new Error("Uint8Array expected of length " + lengths + ", got length=" + b.length);
    }
    function ahash(h) {
      if (typeof h !== "function" || typeof h.create !== "function")
        throw new Error("Hash should be wrapped by utils.createHasher");
      anumber(h.outputLen);
      anumber(h.blockLen);
    }
    function aexists(instance, checkFinished = true) {
      if (instance.destroyed)
        throw new Error("Hash instance has been destroyed");
      if (checkFinished && instance.finished)
        throw new Error("Hash#digest() has already been called");
    }
    function aoutput(out, instance) {
      abytes(out);
      const min2 = instance.outputLen;
      if (out.length < min2) {
        throw new Error("digestInto() expects output buffer of length at least " + min2);
      }
    }
    function u89(arr) {
      return new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
    }
    function u324(arr) {
      return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
    }
    function clean(...arrays) {
      for (let i = 0; i < arrays.length; i++) {
        arrays[i].fill(0);
      }
    }
    function createView(arr) {
      return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
    }
    function rotr(word, shift) {
      return word << 32 - shift | word >>> shift;
    }
    function rotl(word, shift) {
      return word << shift | word >>> 32 - shift >>> 0;
    }
    exports2.isLE = (() => new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68)();
    function byteSwap(word) {
      return word << 24 & 4278190080 | word << 8 & 16711680 | word >>> 8 & 65280 | word >>> 24 & 255;
    }
    exports2.swap8IfBE = exports2.isLE ? (n) => n : (n) => byteSwap(n);
    exports2.byteSwapIfBE = exports2.swap8IfBE;
    function byteSwap32(arr) {
      for (let i = 0; i < arr.length; i++) {
        arr[i] = byteSwap(arr[i]);
      }
      return arr;
    }
    exports2.swap32IfBE = exports2.isLE ? (u) => u : byteSwap32;
    var hasHexBuiltin = /* @__PURE__ */ (() => (
      // @ts-ignore
      typeof Uint8Array.from([]).toHex === "function" && typeof Uint8Array.fromHex === "function"
    ))();
    var hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
    function bytesToHex(bytes) {
      abytes(bytes);
      if (hasHexBuiltin)
        return bytes.toHex();
      let hex = "";
      for (let i = 0; i < bytes.length; i++) {
        hex += hexes[bytes[i]];
      }
      return hex;
    }
    var asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
    function asciiToBase16(ch) {
      if (ch >= asciis._0 && ch <= asciis._9)
        return ch - asciis._0;
      if (ch >= asciis.A && ch <= asciis.F)
        return ch - (asciis.A - 10);
      if (ch >= asciis.a && ch <= asciis.f)
        return ch - (asciis.a - 10);
      return;
    }
    function hexToBytes(hex) {
      if (typeof hex !== "string")
        throw new Error("hex string expected, got " + typeof hex);
      if (hasHexBuiltin)
        return Uint8Array.fromHex(hex);
      const hl = hex.length;
      const al = hl / 2;
      if (hl % 2)
        throw new Error("hex string expected, got unpadded hex of length " + hl);
      const array = new Uint8Array(al);
      for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {
        const n1 = asciiToBase16(hex.charCodeAt(hi));
        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));
        if (n1 === void 0 || n2 === void 0) {
          const char = hex[hi] + hex[hi + 1];
          throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
        }
        array[ai] = n1 * 16 + n2;
      }
      return array;
    }
    var nextTick = async () => {
    };
    exports2.nextTick = nextTick;
    async function asyncLoop(iters, tick, cb) {
      let ts = Date.now();
      for (let i = 0; i < iters; i++) {
        cb(i);
        const diff = Date.now() - ts;
        if (diff >= 0 && diff < tick)
          continue;
        await (0, exports2.nextTick)();
        ts += diff;
      }
    }
    function utf8ToBytes(str) {
      if (typeof str !== "string")
        throw new Error("string expected");
      return new Uint8Array(new TextEncoder().encode(str));
    }
    function bytesToUtf8(bytes) {
      return new TextDecoder().decode(bytes);
    }
    function toBytes(data) {
      if (typeof data === "string")
        data = utf8ToBytes(data);
      abytes(data);
      return data;
    }
    function kdfInputToBytes(data) {
      if (typeof data === "string")
        data = utf8ToBytes(data);
      abytes(data);
      return data;
    }
    function concatBytes(...arrays) {
      let sum2 = 0;
      for (let i = 0; i < arrays.length; i++) {
        const a = arrays[i];
        abytes(a);
        sum2 += a.length;
      }
      const res = new Uint8Array(sum2);
      for (let i = 0, pad = 0; i < arrays.length; i++) {
        const a = arrays[i];
        res.set(a, pad);
        pad += a.length;
      }
      return res;
    }
    function checkOpts(defaults, opts) {
      if (opts !== void 0 && {}.toString.call(opts) !== "[object Object]")
        throw new Error("options should be object or undefined");
      const merged = Object.assign(defaults, opts);
      return merged;
    }
    var Hash = class {
    };
    exports2.Hash = Hash;
    function createHasher(hashCons) {
      const hashC = (msg) => hashCons().update(toBytes(msg)).digest();
      const tmp = hashCons();
      hashC.outputLen = tmp.outputLen;
      hashC.blockLen = tmp.blockLen;
      hashC.create = () => hashCons();
      return hashC;
    }
    function createOptHasher(hashCons) {
      const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
      const tmp = hashCons({});
      hashC.outputLen = tmp.outputLen;
      hashC.blockLen = tmp.blockLen;
      hashC.create = (opts) => hashCons(opts);
      return hashC;
    }
    function createXOFer(hashCons) {
      const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
      const tmp = hashCons({});
      hashC.outputLen = tmp.outputLen;
      hashC.blockLen = tmp.blockLen;
      hashC.create = (opts) => hashCons(opts);
      return hashC;
    }
    exports2.wrapConstructor = createHasher;
    exports2.wrapConstructorWithOpts = createOptHasher;
    exports2.wrapXOFConstructorWithOpts = createXOFer;
    function randomBytes(bytesLength = 32) {
      if (crypto_1.crypto && typeof crypto_1.crypto.getRandomValues === "function") {
        return crypto_1.crypto.getRandomValues(new Uint8Array(bytesLength));
      }
      if (crypto_1.crypto && typeof crypto_1.crypto.randomBytes === "function") {
        return Uint8Array.from(crypto_1.crypto.randomBytes(bytesLength));
      }
      throw new Error("crypto.getRandomValues must be defined");
    }
  }
});

// node_modules/@noble/hashes/_md.js
var require_md = __commonJS({
  "node_modules/@noble/hashes/_md.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SHA512_IV = exports2.SHA384_IV = exports2.SHA224_IV = exports2.SHA256_IV = exports2.HashMD = void 0;
    exports2.setBigUint64 = setBigUint64;
    exports2.Chi = Chi;
    exports2.Maj = Maj;
    var utils_ts_1 = require_utils();
    function setBigUint64(view, byteOffset, value, isLE) {
      if (typeof view.setBigUint64 === "function")
        return view.setBigUint64(byteOffset, value, isLE);
      const _32n = BigInt(32);
      const _u32_max = BigInt(4294967295);
      const wh = Number(value >> _32n & _u32_max);
      const wl = Number(value & _u32_max);
      const h = isLE ? 4 : 0;
      const l = isLE ? 0 : 4;
      view.setUint32(byteOffset + h, wh, isLE);
      view.setUint32(byteOffset + l, wl, isLE);
    }
    function Chi(a, b, c) {
      return a & b ^ ~a & c;
    }
    function Maj(a, b, c) {
      return a & b ^ a & c ^ b & c;
    }
    var HashMD = class extends utils_ts_1.Hash {
      constructor(blockLen, outputLen, padOffset, isLE) {
        super();
        this.finished = false;
        this.length = 0;
        this.pos = 0;
        this.destroyed = false;
        this.blockLen = blockLen;
        this.outputLen = outputLen;
        this.padOffset = padOffset;
        this.isLE = isLE;
        this.buffer = new Uint8Array(blockLen);
        this.view = (0, utils_ts_1.createView)(this.buffer);
      }
      update(data) {
        (0, utils_ts_1.aexists)(this);
        data = (0, utils_ts_1.toBytes)(data);
        (0, utils_ts_1.abytes)(data);
        const { view, buffer, blockLen } = this;
        const len = data.length;
        for (let pos = 0; pos < len; ) {
          const take = Math.min(blockLen - this.pos, len - pos);
          if (take === blockLen) {
            const dataView = (0, utils_ts_1.createView)(data);
            for (; blockLen <= len - pos; pos += blockLen)
              this.process(dataView, pos);
            continue;
          }
          buffer.set(data.subarray(pos, pos + take), this.pos);
          this.pos += take;
          pos += take;
          if (this.pos === blockLen) {
            this.process(view, 0);
            this.pos = 0;
          }
        }
        this.length += data.length;
        this.roundClean();
        return this;
      }
      digestInto(out) {
        (0, utils_ts_1.aexists)(this);
        (0, utils_ts_1.aoutput)(out, this);
        this.finished = true;
        const { buffer, view, blockLen, isLE } = this;
        let { pos } = this;
        buffer[pos++] = 128;
        (0, utils_ts_1.clean)(this.buffer.subarray(pos));
        if (this.padOffset > blockLen - pos) {
          this.process(view, 0);
          pos = 0;
        }
        for (let i = pos; i < blockLen; i++)
          buffer[i] = 0;
        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);
        this.process(view, 0);
        const oview = (0, utils_ts_1.createView)(out);
        const len = this.outputLen;
        if (len % 4)
          throw new Error("_sha2: outputLen should be aligned to 32bit");
        const outLen = len / 4;
        const state = this.get();
        if (outLen > state.length)
          throw new Error("_sha2: outputLen bigger than state");
        for (let i = 0; i < outLen; i++)
          oview.setUint32(4 * i, state[i], isLE);
      }
      digest() {
        const { buffer, outputLen } = this;
        this.digestInto(buffer);
        const res = buffer.slice(0, outputLen);
        this.destroy();
        return res;
      }
      _cloneInto(to) {
        to || (to = new this.constructor());
        to.set(...this.get());
        const { blockLen, buffer, length, finished, destroyed, pos } = this;
        to.destroyed = destroyed;
        to.finished = finished;
        to.length = length;
        to.pos = pos;
        if (length % blockLen)
          to.buffer.set(buffer);
        return to;
      }
      clone() {
        return this._cloneInto();
      }
    };
    exports2.HashMD = HashMD;
    exports2.SHA256_IV = Uint32Array.from([
      1779033703,
      3144134277,
      1013904242,
      2773480762,
      1359893119,
      2600822924,
      528734635,
      1541459225
    ]);
    exports2.SHA224_IV = Uint32Array.from([
      3238371032,
      914150663,
      812702999,
      4144912697,
      4290775857,
      1750603025,
      1694076839,
      3204075428
    ]);
    exports2.SHA384_IV = Uint32Array.from([
      3418070365,
      3238371032,
      1654270250,
      914150663,
      2438529370,
      812702999,
      355462360,
      4144912697,
      1731405415,
      4290775857,
      2394180231,
      1750603025,
      3675008525,
      1694076839,
      1203062813,
      3204075428
    ]);
    exports2.SHA512_IV = Uint32Array.from([
      1779033703,
      4089235720,
      3144134277,
      2227873595,
      1013904242,
      4271175723,
      2773480762,
      1595750129,
      1359893119,
      2917565137,
      2600822924,
      725511199,
      528734635,
      4215389547,
      1541459225,
      327033209
    ]);
  }
});

// node_modules/@noble/hashes/_u64.js
var require_u64 = __commonJS({
  "node_modules/@noble/hashes/_u64.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.toBig = exports2.shrSL = exports2.shrSH = exports2.rotrSL = exports2.rotrSH = exports2.rotrBL = exports2.rotrBH = exports2.rotr32L = exports2.rotr32H = exports2.rotlSL = exports2.rotlSH = exports2.rotlBL = exports2.rotlBH = exports2.add5L = exports2.add5H = exports2.add4L = exports2.add4H = exports2.add3L = exports2.add3H = void 0;
    exports2.add = add2;
    exports2.fromBig = fromBig;
    exports2.split = split;
    var U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);
    var _32n = /* @__PURE__ */ BigInt(32);
    function fromBig(n, le = false) {
      if (le)
        return { h: Number(n & U32_MASK64), l: Number(n >> _32n & U32_MASK64) };
      return { h: Number(n >> _32n & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };
    }
    function split(lst, le = false) {
      const len = lst.length;
      let Ah = new Uint32Array(len);
      let Al = new Uint32Array(len);
      for (let i = 0; i < len; i++) {
        const { h, l } = fromBig(lst[i], le);
        [Ah[i], Al[i]] = [h, l];
      }
      return [Ah, Al];
    }
    var toBig = (h, l) => BigInt(h >>> 0) << _32n | BigInt(l >>> 0);
    exports2.toBig = toBig;
    var shrSH = (h, _l, s) => h >>> s;
    exports2.shrSH = shrSH;
    var shrSL = (h, l, s) => h << 32 - s | l >>> s;
    exports2.shrSL = shrSL;
    var rotrSH = (h, l, s) => h >>> s | l << 32 - s;
    exports2.rotrSH = rotrSH;
    var rotrSL = (h, l, s) => h << 32 - s | l >>> s;
    exports2.rotrSL = rotrSL;
    var rotrBH = (h, l, s) => h << 64 - s | l >>> s - 32;
    exports2.rotrBH = rotrBH;
    var rotrBL = (h, l, s) => h >>> s - 32 | l << 64 - s;
    exports2.rotrBL = rotrBL;
    var rotr32H = (_h, l) => l;
    exports2.rotr32H = rotr32H;
    var rotr32L = (h, _l) => h;
    exports2.rotr32L = rotr32L;
    var rotlSH = (h, l, s) => h << s | l >>> 32 - s;
    exports2.rotlSH = rotlSH;
    var rotlSL = (h, l, s) => l << s | h >>> 32 - s;
    exports2.rotlSL = rotlSL;
    var rotlBH = (h, l, s) => l << s - 32 | h >>> 64 - s;
    exports2.rotlBH = rotlBH;
    var rotlBL = (h, l, s) => h << s - 32 | l >>> 64 - s;
    exports2.rotlBL = rotlBL;
    function add2(Ah, Al, Bh, Bl) {
      const l = (Al >>> 0) + (Bl >>> 0);
      return { h: Ah + Bh + (l / 2 ** 32 | 0) | 0, l: l | 0 };
    }
    var add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
    exports2.add3L = add3L;
    var add3H = (low, Ah, Bh, Ch) => Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;
    exports2.add3H = add3H;
    var add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
    exports2.add4L = add4L;
    var add4H = (low, Ah, Bh, Ch, Dh) => Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;
    exports2.add4H = add4H;
    var add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
    exports2.add5L = add5L;
    var add5H = (low, Ah, Bh, Ch, Dh, Eh) => Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;
    exports2.add5H = add5H;
    var u643 = {
      fromBig,
      split,
      toBig,
      shrSH,
      shrSL,
      rotrSH,
      rotrSL,
      rotrBH,
      rotrBL,
      rotr32H,
      rotr32L,
      rotlSH,
      rotlSL,
      rotlBH,
      rotlBL,
      add: add2,
      add3L,
      add3H,
      add4L,
      add4H,
      add5H,
      add5L
    };
    exports2.default = u643;
  }
});

// node_modules/@noble/hashes/sha2.js
var require_sha2 = __commonJS({
  "node_modules/@noble/hashes/sha2.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.sha512_224 = exports2.sha512_256 = exports2.sha384 = exports2.sha512 = exports2.sha224 = exports2.sha256 = exports2.SHA512_256 = exports2.SHA512_224 = exports2.SHA384 = exports2.SHA512 = exports2.SHA224 = exports2.SHA256 = void 0;
    var _md_ts_1 = require_md();
    var u643 = require_u64();
    var utils_ts_1 = require_utils();
    var SHA256_K = /* @__PURE__ */ Uint32Array.from([
      1116352408,
      1899447441,
      3049323471,
      3921009573,
      961987163,
      1508970993,
      2453635748,
      2870763221,
      3624381080,
      310598401,
      607225278,
      1426881987,
      1925078388,
      2162078206,
      2614888103,
      3248222580,
      3835390401,
      4022224774,
      264347078,
      604807628,
      770255983,
      1249150122,
      1555081692,
      1996064986,
      2554220882,
      2821834349,
      2952996808,
      3210313671,
      3336571891,
      3584528711,
      113926993,
      338241895,
      666307205,
      773529912,
      1294757372,
      1396182291,
      1695183700,
      1986661051,
      2177026350,
      2456956037,
      2730485921,
      2820302411,
      3259730800,
      3345764771,
      3516065817,
      3600352804,
      4094571909,
      275423344,
      430227734,
      506948616,
      659060556,
      883997877,
      958139571,
      1322822218,
      1537002063,
      1747873779,
      1955562222,
      2024104815,
      2227730452,
      2361852424,
      2428436474,
      2756734187,
      3204031479,
      3329325298
    ]);
    var SHA256_W = /* @__PURE__ */ new Uint32Array(64);
    var SHA256 = class extends _md_ts_1.HashMD {
      constructor(outputLen = 32) {
        super(64, outputLen, 8, false);
        this.A = _md_ts_1.SHA256_IV[0] | 0;
        this.B = _md_ts_1.SHA256_IV[1] | 0;
        this.C = _md_ts_1.SHA256_IV[2] | 0;
        this.D = _md_ts_1.SHA256_IV[3] | 0;
        this.E = _md_ts_1.SHA256_IV[4] | 0;
        this.F = _md_ts_1.SHA256_IV[5] | 0;
        this.G = _md_ts_1.SHA256_IV[6] | 0;
        this.H = _md_ts_1.SHA256_IV[7] | 0;
      }
      get() {
        const { A, B, C, D, E, F, G, H } = this;
        return [A, B, C, D, E, F, G, H];
      }
      // prettier-ignore
      set(A, B, C, D, E, F, G, H) {
        this.A = A | 0;
        this.B = B | 0;
        this.C = C | 0;
        this.D = D | 0;
        this.E = E | 0;
        this.F = F | 0;
        this.G = G | 0;
        this.H = H | 0;
      }
      process(view, offset) {
        for (let i = 0; i < 16; i++, offset += 4)
          SHA256_W[i] = view.getUint32(offset, false);
        for (let i = 16; i < 64; i++) {
          const W15 = SHA256_W[i - 15];
          const W2 = SHA256_W[i - 2];
          const s0 = (0, utils_ts_1.rotr)(W15, 7) ^ (0, utils_ts_1.rotr)(W15, 18) ^ W15 >>> 3;
          const s1 = (0, utils_ts_1.rotr)(W2, 17) ^ (0, utils_ts_1.rotr)(W2, 19) ^ W2 >>> 10;
          SHA256_W[i] = s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16] | 0;
        }
        let { A, B, C, D, E, F, G, H } = this;
        for (let i = 0; i < 64; i++) {
          const sigma1 = (0, utils_ts_1.rotr)(E, 6) ^ (0, utils_ts_1.rotr)(E, 11) ^ (0, utils_ts_1.rotr)(E, 25);
          const T1 = H + sigma1 + (0, _md_ts_1.Chi)(E, F, G) + SHA256_K[i] + SHA256_W[i] | 0;
          const sigma0 = (0, utils_ts_1.rotr)(A, 2) ^ (0, utils_ts_1.rotr)(A, 13) ^ (0, utils_ts_1.rotr)(A, 22);
          const T2 = sigma0 + (0, _md_ts_1.Maj)(A, B, C) | 0;
          H = G;
          G = F;
          F = E;
          E = D + T1 | 0;
          D = C;
          C = B;
          B = A;
          A = T1 + T2 | 0;
        }
        A = A + this.A | 0;
        B = B + this.B | 0;
        C = C + this.C | 0;
        D = D + this.D | 0;
        E = E + this.E | 0;
        F = F + this.F | 0;
        G = G + this.G | 0;
        H = H + this.H | 0;
        this.set(A, B, C, D, E, F, G, H);
      }
      roundClean() {
        (0, utils_ts_1.clean)(SHA256_W);
      }
      destroy() {
        this.set(0, 0, 0, 0, 0, 0, 0, 0);
        (0, utils_ts_1.clean)(this.buffer);
      }
    };
    exports2.SHA256 = SHA256;
    var SHA224 = class extends SHA256 {
      constructor() {
        super(28);
        this.A = _md_ts_1.SHA224_IV[0] | 0;
        this.B = _md_ts_1.SHA224_IV[1] | 0;
        this.C = _md_ts_1.SHA224_IV[2] | 0;
        this.D = _md_ts_1.SHA224_IV[3] | 0;
        this.E = _md_ts_1.SHA224_IV[4] | 0;
        this.F = _md_ts_1.SHA224_IV[5] | 0;
        this.G = _md_ts_1.SHA224_IV[6] | 0;
        this.H = _md_ts_1.SHA224_IV[7] | 0;
      }
    };
    exports2.SHA224 = SHA224;
    var K512 = /* @__PURE__ */ (() => u643.split([
      "0x428a2f98d728ae22",
      "0x7137449123ef65cd",
      "0xb5c0fbcfec4d3b2f",
      "0xe9b5dba58189dbbc",
      "0x3956c25bf348b538",
      "0x59f111f1b605d019",
      "0x923f82a4af194f9b",
      "0xab1c5ed5da6d8118",
      "0xd807aa98a3030242",
      "0x12835b0145706fbe",
      "0x243185be4ee4b28c",
      "0x550c7dc3d5ffb4e2",
      "0x72be5d74f27b896f",
      "0x80deb1fe3b1696b1",
      "0x9bdc06a725c71235",
      "0xc19bf174cf692694",
      "0xe49b69c19ef14ad2",
      "0xefbe4786384f25e3",
      "0x0fc19dc68b8cd5b5",
      "0x240ca1cc77ac9c65",
      "0x2de92c6f592b0275",
      "0x4a7484aa6ea6e483",
      "0x5cb0a9dcbd41fbd4",
      "0x76f988da831153b5",
      "0x983e5152ee66dfab",
      "0xa831c66d2db43210",
      "0xb00327c898fb213f",
      "0xbf597fc7beef0ee4",
      "0xc6e00bf33da88fc2",
      "0xd5a79147930aa725",
      "0x06ca6351e003826f",
      "0x142929670a0e6e70",
      "0x27b70a8546d22ffc",
      "0x2e1b21385c26c926",
      "0x4d2c6dfc5ac42aed",
      "0x53380d139d95b3df",
      "0x650a73548baf63de",
      "0x766a0abb3c77b2a8",
      "0x81c2c92e47edaee6",
      "0x92722c851482353b",
      "0xa2bfe8a14cf10364",
      "0xa81a664bbc423001",
      "0xc24b8b70d0f89791",
      "0xc76c51a30654be30",
      "0xd192e819d6ef5218",
      "0xd69906245565a910",
      "0xf40e35855771202a",
      "0x106aa07032bbd1b8",
      "0x19a4c116b8d2d0c8",
      "0x1e376c085141ab53",
      "0x2748774cdf8eeb99",
      "0x34b0bcb5e19b48a8",
      "0x391c0cb3c5c95a63",
      "0x4ed8aa4ae3418acb",
      "0x5b9cca4f7763e373",
      "0x682e6ff3d6b2b8a3",
      "0x748f82ee5defb2fc",
      "0x78a5636f43172f60",
      "0x84c87814a1f0ab72",
      "0x8cc702081a6439ec",
      "0x90befffa23631e28",
      "0xa4506cebde82bde9",
      "0xbef9a3f7b2c67915",
      "0xc67178f2e372532b",
      "0xca273eceea26619c",
      "0xd186b8c721c0c207",
      "0xeada7dd6cde0eb1e",
      "0xf57d4f7fee6ed178",
      "0x06f067aa72176fba",
      "0x0a637dc5a2c898a6",
      "0x113f9804bef90dae",
      "0x1b710b35131c471b",
      "0x28db77f523047d84",
      "0x32caab7b40c72493",
      "0x3c9ebe0a15c9bebc",
      "0x431d67c49c100d4c",
      "0x4cc5d4becb3e42b6",
      "0x597f299cfc657e2a",
      "0x5fcb6fab3ad6faec",
      "0x6c44198c4a475817"
    ].map((n) => BigInt(n))))();
    var SHA512_Kh = /* @__PURE__ */ (() => K512[0])();
    var SHA512_Kl = /* @__PURE__ */ (() => K512[1])();
    var SHA512_W_H = /* @__PURE__ */ new Uint32Array(80);
    var SHA512_W_L = /* @__PURE__ */ new Uint32Array(80);
    var SHA512 = class extends _md_ts_1.HashMD {
      constructor(outputLen = 64) {
        super(128, outputLen, 16, false);
        this.Ah = _md_ts_1.SHA512_IV[0] | 0;
        this.Al = _md_ts_1.SHA512_IV[1] | 0;
        this.Bh = _md_ts_1.SHA512_IV[2] | 0;
        this.Bl = _md_ts_1.SHA512_IV[3] | 0;
        this.Ch = _md_ts_1.SHA512_IV[4] | 0;
        this.Cl = _md_ts_1.SHA512_IV[5] | 0;
        this.Dh = _md_ts_1.SHA512_IV[6] | 0;
        this.Dl = _md_ts_1.SHA512_IV[7] | 0;
        this.Eh = _md_ts_1.SHA512_IV[8] | 0;
        this.El = _md_ts_1.SHA512_IV[9] | 0;
        this.Fh = _md_ts_1.SHA512_IV[10] | 0;
        this.Fl = _md_ts_1.SHA512_IV[11] | 0;
        this.Gh = _md_ts_1.SHA512_IV[12] | 0;
        this.Gl = _md_ts_1.SHA512_IV[13] | 0;
        this.Hh = _md_ts_1.SHA512_IV[14] | 0;
        this.Hl = _md_ts_1.SHA512_IV[15] | 0;
      }
      // prettier-ignore
      get() {
        const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
        return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];
      }
      // prettier-ignore
      set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {
        this.Ah = Ah | 0;
        this.Al = Al | 0;
        this.Bh = Bh | 0;
        this.Bl = Bl | 0;
        this.Ch = Ch | 0;
        this.Cl = Cl | 0;
        this.Dh = Dh | 0;
        this.Dl = Dl | 0;
        this.Eh = Eh | 0;
        this.El = El | 0;
        this.Fh = Fh | 0;
        this.Fl = Fl | 0;
        this.Gh = Gh | 0;
        this.Gl = Gl | 0;
        this.Hh = Hh | 0;
        this.Hl = Hl | 0;
      }
      process(view, offset) {
        for (let i = 0; i < 16; i++, offset += 4) {
          SHA512_W_H[i] = view.getUint32(offset);
          SHA512_W_L[i] = view.getUint32(offset += 4);
        }
        for (let i = 16; i < 80; i++) {
          const W15h = SHA512_W_H[i - 15] | 0;
          const W15l = SHA512_W_L[i - 15] | 0;
          const s0h = u643.rotrSH(W15h, W15l, 1) ^ u643.rotrSH(W15h, W15l, 8) ^ u643.shrSH(W15h, W15l, 7);
          const s0l = u643.rotrSL(W15h, W15l, 1) ^ u643.rotrSL(W15h, W15l, 8) ^ u643.shrSL(W15h, W15l, 7);
          const W2h = SHA512_W_H[i - 2] | 0;
          const W2l = SHA512_W_L[i - 2] | 0;
          const s1h = u643.rotrSH(W2h, W2l, 19) ^ u643.rotrBH(W2h, W2l, 61) ^ u643.shrSH(W2h, W2l, 6);
          const s1l = u643.rotrSL(W2h, W2l, 19) ^ u643.rotrBL(W2h, W2l, 61) ^ u643.shrSL(W2h, W2l, 6);
          const SUMl = u643.add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);
          const SUMh = u643.add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);
          SHA512_W_H[i] = SUMh | 0;
          SHA512_W_L[i] = SUMl | 0;
        }
        let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
        for (let i = 0; i < 80; i++) {
          const sigma1h = u643.rotrSH(Eh, El, 14) ^ u643.rotrSH(Eh, El, 18) ^ u643.rotrBH(Eh, El, 41);
          const sigma1l = u643.rotrSL(Eh, El, 14) ^ u643.rotrSL(Eh, El, 18) ^ u643.rotrBL(Eh, El, 41);
          const CHIh = Eh & Fh ^ ~Eh & Gh;
          const CHIl = El & Fl ^ ~El & Gl;
          const T1ll = u643.add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);
          const T1h = u643.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);
          const T1l = T1ll | 0;
          const sigma0h = u643.rotrSH(Ah, Al, 28) ^ u643.rotrBH(Ah, Al, 34) ^ u643.rotrBH(Ah, Al, 39);
          const sigma0l = u643.rotrSL(Ah, Al, 28) ^ u643.rotrBL(Ah, Al, 34) ^ u643.rotrBL(Ah, Al, 39);
          const MAJh = Ah & Bh ^ Ah & Ch ^ Bh & Ch;
          const MAJl = Al & Bl ^ Al & Cl ^ Bl & Cl;
          Hh = Gh | 0;
          Hl = Gl | 0;
          Gh = Fh | 0;
          Gl = Fl | 0;
          Fh = Eh | 0;
          Fl = El | 0;
          ({ h: Eh, l: El } = u643.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));
          Dh = Ch | 0;
          Dl = Cl | 0;
          Ch = Bh | 0;
          Cl = Bl | 0;
          Bh = Ah | 0;
          Bl = Al | 0;
          const All = u643.add3L(T1l, sigma0l, MAJl);
          Ah = u643.add3H(All, T1h, sigma0h, MAJh);
          Al = All | 0;
        }
        ({ h: Ah, l: Al } = u643.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));
        ({ h: Bh, l: Bl } = u643.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));
        ({ h: Ch, l: Cl } = u643.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));
        ({ h: Dh, l: Dl } = u643.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));
        ({ h: Eh, l: El } = u643.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));
        ({ h: Fh, l: Fl } = u643.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));
        ({ h: Gh, l: Gl } = u643.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));
        ({ h: Hh, l: Hl } = u643.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));
        this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);
      }
      roundClean() {
        (0, utils_ts_1.clean)(SHA512_W_H, SHA512_W_L);
      }
      destroy() {
        (0, utils_ts_1.clean)(this.buffer);
        this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
      }
    };
    exports2.SHA512 = SHA512;
    var SHA384 = class extends SHA512 {
      constructor() {
        super(48);
        this.Ah = _md_ts_1.SHA384_IV[0] | 0;
        this.Al = _md_ts_1.SHA384_IV[1] | 0;
        this.Bh = _md_ts_1.SHA384_IV[2] | 0;
        this.Bl = _md_ts_1.SHA384_IV[3] | 0;
        this.Ch = _md_ts_1.SHA384_IV[4] | 0;
        this.Cl = _md_ts_1.SHA384_IV[5] | 0;
        this.Dh = _md_ts_1.SHA384_IV[6] | 0;
        this.Dl = _md_ts_1.SHA384_IV[7] | 0;
        this.Eh = _md_ts_1.SHA384_IV[8] | 0;
        this.El = _md_ts_1.SHA384_IV[9] | 0;
        this.Fh = _md_ts_1.SHA384_IV[10] | 0;
        this.Fl = _md_ts_1.SHA384_IV[11] | 0;
        this.Gh = _md_ts_1.SHA384_IV[12] | 0;
        this.Gl = _md_ts_1.SHA384_IV[13] | 0;
        this.Hh = _md_ts_1.SHA384_IV[14] | 0;
        this.Hl = _md_ts_1.SHA384_IV[15] | 0;
      }
    };
    exports2.SHA384 = SHA384;
    var T224_IV = /* @__PURE__ */ Uint32Array.from([
      2352822216,
      424955298,
      1944164710,
      2312950998,
      502970286,
      855612546,
      1738396948,
      1479516111,
      258812777,
      2077511080,
      2011393907,
      79989058,
      1067287976,
      1780299464,
      286451373,
      2446758561
    ]);
    var T256_IV = /* @__PURE__ */ Uint32Array.from([
      573645204,
      4230739756,
      2673172387,
      3360449730,
      596883563,
      1867755857,
      2520282905,
      1497426621,
      2519219938,
      2827943907,
      3193839141,
      1401305490,
      721525244,
      746961066,
      246885852,
      2177182882
    ]);
    var SHA512_224 = class extends SHA512 {
      constructor() {
        super(28);
        this.Ah = T224_IV[0] | 0;
        this.Al = T224_IV[1] | 0;
        this.Bh = T224_IV[2] | 0;
        this.Bl = T224_IV[3] | 0;
        this.Ch = T224_IV[4] | 0;
        this.Cl = T224_IV[5] | 0;
        this.Dh = T224_IV[6] | 0;
        this.Dl = T224_IV[7] | 0;
        this.Eh = T224_IV[8] | 0;
        this.El = T224_IV[9] | 0;
        this.Fh = T224_IV[10] | 0;
        this.Fl = T224_IV[11] | 0;
        this.Gh = T224_IV[12] | 0;
        this.Gl = T224_IV[13] | 0;
        this.Hh = T224_IV[14] | 0;
        this.Hl = T224_IV[15] | 0;
      }
    };
    exports2.SHA512_224 = SHA512_224;
    var SHA512_256 = class extends SHA512 {
      constructor() {
        super(32);
        this.Ah = T256_IV[0] | 0;
        this.Al = T256_IV[1] | 0;
        this.Bh = T256_IV[2] | 0;
        this.Bl = T256_IV[3] | 0;
        this.Ch = T256_IV[4] | 0;
        this.Cl = T256_IV[5] | 0;
        this.Dh = T256_IV[6] | 0;
        this.Dl = T256_IV[7] | 0;
        this.Eh = T256_IV[8] | 0;
        this.El = T256_IV[9] | 0;
        this.Fh = T256_IV[10] | 0;
        this.Fl = T256_IV[11] | 0;
        this.Gh = T256_IV[12] | 0;
        this.Gl = T256_IV[13] | 0;
        this.Hh = T256_IV[14] | 0;
        this.Hl = T256_IV[15] | 0;
      }
    };
    exports2.SHA512_256 = SHA512_256;
    exports2.sha256 = (0, utils_ts_1.createHasher)(() => new SHA256());
    exports2.sha224 = (0, utils_ts_1.createHasher)(() => new SHA224());
    exports2.sha512 = (0, utils_ts_1.createHasher)(() => new SHA512());
    exports2.sha384 = (0, utils_ts_1.createHasher)(() => new SHA384());
    exports2.sha512_256 = (0, utils_ts_1.createHasher)(() => new SHA512_256());
    exports2.sha512_224 = (0, utils_ts_1.createHasher)(() => new SHA512_224());
  }
});

// node_modules/@noble/hashes/sha256.js
var require_sha256 = __commonJS({
  "node_modules/@noble/hashes/sha256.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.sha224 = exports2.SHA224 = exports2.sha256 = exports2.SHA256 = void 0;
    var sha2_ts_1 = require_sha2();
    exports2.SHA256 = sha2_ts_1.SHA256;
    exports2.sha256 = sha2_ts_1.sha256;
    exports2.SHA224 = sha2_ts_1.SHA224;
    exports2.sha224 = sha2_ts_1.sha224;
  }
});

// node_modules/@orca-so/common-sdk/dist/web3/token-util.js
var require_token_util = __commonJS({
  "node_modules/@orca-so/common-sdk/dist/web3/token-util.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TokenUtil = void 0;
    var spl_token_1 = require_cjs3();
    var web3_js_1 = require("@solana/web3.js");
    var sha256_1 = require_sha256();
    var tiny_invariant_1 = __importDefault(require_tiny_invariant_cjs());
    var math_1 = require_math();
    var web3_1 = require_web32();
    var TokenUtil = class {
      static isNativeMint(mint) {
        return mint.equals(spl_token_1.NATIVE_MINT);
      }
      static createWrappedNativeAccountInstruction(owner, amountIn, rentExemptLamports, payer, unwrapDestination, createAccountMethod = "keypair") {
        const payerKey = payer ?? owner;
        const unwrapDestinationKey = unwrapDestination ?? owner;
        switch (createAccountMethod) {
          case "ata":
            return createWrappedNativeAccountInstructionWithATA(owner, amountIn, rentExemptLamports, payerKey, unwrapDestinationKey);
          case "keypair":
            return createWrappedNativeAccountInstructionWithKeypair(owner, amountIn, rentExemptLamports, payerKey, unwrapDestinationKey);
          case "withSeed":
            return createWrappedNativeAccountInstructionWithSeed(owner, amountIn, rentExemptLamports, payerKey, unwrapDestinationKey);
          default:
            throw new Error(`Invalid createAccountMethod: ${createAccountMethod}`);
        }
      }
      static async createSendTokensToWalletInstruction(connection, sourceWallet, destinationWallet, tokenMint, tokenDecimals, amount, getAccountRentExempt, payer, allowPDASourceWallet = false) {
        (0, tiny_invariant_1.default)(!amount.eq(math_1.ZERO), "SendToken transaction must send more than 0 tokens.");
        (0, tiny_invariant_1.default)(!tokenMint.equals(spl_token_1.NATIVE_MINT_2022), "NATIVE_MINT_2022 is not supported.");
        if (tokenMint.equals(spl_token_1.NATIVE_MINT)) {
          const sendSolTxn = web3_js_1.SystemProgram.transfer({
            fromPubkey: sourceWallet,
            toPubkey: destinationWallet,
            lamports: BigInt(amount.toString())
          });
          return {
            instructions: [sendSolTxn],
            cleanupInstructions: [],
            signers: []
          };
        }
        const mintAccountInfo = await connection.getAccountInfo(tokenMint);
        if (mintAccountInfo === null)
          throw Error("Cannot fetch tokenMint.");
        const tokenProgram = mintAccountInfo.owner;
        const sourceTokenAccount = (0, spl_token_1.getAssociatedTokenAddressSync)(tokenMint, sourceWallet, allowPDASourceWallet, tokenProgram);
        const { address: destinationTokenAccount, ...destinationAtaIx } = await (0, web3_1.resolveOrCreateATA)(connection, destinationWallet, tokenMint, getAccountRentExempt, amount, payer, void 0, true);
        const transferIx = await (0, spl_token_1.createTransferCheckedWithTransferHookInstruction)(connection, sourceTokenAccount, tokenMint, destinationTokenAccount, sourceWallet, BigInt(amount.toString()), tokenDecimals, void 0, void 0, tokenProgram);
        return {
          instructions: destinationAtaIx.instructions.concat(transferIx),
          cleanupInstructions: destinationAtaIx.cleanupInstructions,
          signers: destinationAtaIx.signers
        };
      }
    };
    exports2.TokenUtil = TokenUtil;
    function createWrappedNativeAccountInstructionWithATA(owner, amountIn, _rentExemptLamports, payerKey, unwrapDestinationKey) {
      const tempAccount = (0, spl_token_1.getAssociatedTokenAddressSync)(spl_token_1.NATIVE_MINT, owner);
      const instructions = [
        (0, spl_token_1.createAssociatedTokenAccountIdempotentInstruction)(payerKey, tempAccount, owner, spl_token_1.NATIVE_MINT)
      ];
      if (amountIn.gt(math_1.ZERO)) {
        instructions.push(web3_js_1.SystemProgram.transfer({
          fromPubkey: payerKey,
          toPubkey: tempAccount,
          lamports: amountIn.toNumber()
        }));
        instructions.push((0, spl_token_1.createSyncNativeInstruction)(tempAccount));
      }
      const closeWSOLAccountInstruction = (0, spl_token_1.createCloseAccountInstruction)(tempAccount, unwrapDestinationKey, owner);
      return {
        address: tempAccount,
        tokenProgram: spl_token_1.TOKEN_PROGRAM_ID,
        instructions,
        cleanupInstructions: [closeWSOLAccountInstruction],
        signers: []
      };
    }
    function createWrappedNativeAccountInstructionWithKeypair(owner, amountIn, rentExemptLamports, payerKey, unwrapDestinationKey) {
      const tempAccount = new web3_js_1.Keypair();
      const createAccountInstruction = web3_js_1.SystemProgram.createAccount({
        fromPubkey: payerKey,
        newAccountPubkey: tempAccount.publicKey,
        lamports: amountIn.toNumber() + rentExemptLamports,
        space: spl_token_1.AccountLayout.span,
        programId: spl_token_1.TOKEN_PROGRAM_ID
      });
      const initAccountInstruction = (0, spl_token_1.createInitializeAccountInstruction)(tempAccount.publicKey, spl_token_1.NATIVE_MINT, owner);
      const closeWSOLAccountInstruction = (0, spl_token_1.createCloseAccountInstruction)(tempAccount.publicKey, unwrapDestinationKey, owner);
      return {
        address: tempAccount.publicKey,
        tokenProgram: spl_token_1.TOKEN_PROGRAM_ID,
        instructions: [createAccountInstruction, initAccountInstruction],
        cleanupInstructions: [closeWSOLAccountInstruction],
        signers: [tempAccount]
      };
    }
    function createWrappedNativeAccountInstructionWithSeed(owner, amountIn, rentExemptLamports, payerKey, unwrapDestinationKey) {
      const seed = web3_js_1.Keypair.generate().publicKey.toBase58().slice(0, 32);
      const tempAccount = (() => {
        const fromPublicKey = owner;
        const programId = spl_token_1.TOKEN_PROGRAM_ID;
        const buffer = Buffer.concat([
          fromPublicKey.toBuffer(),
          Buffer.from(seed),
          programId.toBuffer()
        ]);
        const publicKeyBytes = (0, sha256_1.sha256)(buffer);
        return new web3_js_1.PublicKey(publicKeyBytes);
      })();
      const createAccountInstruction = web3_js_1.SystemProgram.createAccountWithSeed({
        fromPubkey: payerKey,
        basePubkey: owner,
        seed,
        newAccountPubkey: tempAccount,
        lamports: amountIn.toNumber() + rentExemptLamports,
        space: spl_token_1.AccountLayout.span,
        programId: spl_token_1.TOKEN_PROGRAM_ID
      });
      const initAccountInstruction = (0, spl_token_1.createInitializeAccountInstruction)(tempAccount, spl_token_1.NATIVE_MINT, owner);
      const closeWSOLAccountInstruction = (0, spl_token_1.createCloseAccountInstruction)(tempAccount, unwrapDestinationKey, owner);
      return {
        address: tempAccount,
        tokenProgram: spl_token_1.TOKEN_PROGRAM_ID,
        instructions: [createAccountInstruction, initAccountInstruction],
        cleanupInstructions: [closeWSOLAccountInstruction],
        signers: []
      };
    }
  }
});

// node_modules/@orca-so/common-sdk/dist/web3/transactions/types.js
var require_types2 = __commonJS({
  "node_modules/@orca-so/common-sdk/dist/web3/transactions/types.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.EMPTY_INSTRUCTION = void 0;
    exports2.EMPTY_INSTRUCTION = {
      instructions: [],
      cleanupInstructions: [],
      signers: []
    };
  }
});

// node_modules/@orca-so/common-sdk/dist/web3/ata-util.js
var require_ata_util = __commonJS({
  "node_modules/@orca-so/common-sdk/dist/web3/ata-util.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.resolveOrCreateATA = resolveOrCreateATA;
    exports2.resolveOrCreateATAs = resolveOrCreateATAs;
    var spl_token_1 = require_cjs3();
    var math_1 = require_math();
    var network_1 = require_network();
    var token_util_1 = require_token_util();
    var types_1 = require_types2();
    async function resolveOrCreateATA(connection, ownerAddress, tokenMint, getAccountRentExempt, wrappedSolAmountIn = math_1.ZERO, payer = ownerAddress, modeIdempotent = false, allowPDAOwnerAddress = false, wrappedSolAccountCreateMethod = "keypair") {
      const instructions = await resolveOrCreateATAs(connection, ownerAddress, [{ tokenMint, wrappedSolAmountIn }], getAccountRentExempt, payer, modeIdempotent, allowPDAOwnerAddress, wrappedSolAccountCreateMethod);
      return instructions[0];
    }
    async function resolveOrCreateATAs(connection, ownerAddress, requests, getAccountRentExempt, payer = ownerAddress, modeIdempotent = false, allowPDAOwnerAddress = false, wrappedSolAccountCreateMethod = "keypair") {
      const nonNativeMints = requests.filter(({ tokenMint }) => !tokenMint.equals(spl_token_1.NATIVE_MINT));
      const nativeMints = requests.filter(({ tokenMint }) => tokenMint.equals(spl_token_1.NATIVE_MINT));
      const nativeMint2022 = requests.filter(({ tokenMint }) => tokenMint.equals(spl_token_1.NATIVE_MINT_2022));
      if (nativeMints.length > 1) {
        throw new Error("Cannot resolve multiple WSolAccounts");
      }
      if (nativeMint2022.length > 0) {
        throw new Error("NATIVE_MINT_2022 is not supported");
      }
      let instructionMap = {};
      if (nonNativeMints.length > 0) {
        const mints = await (0, network_1.getMultipleParsedAccounts)(connection, nonNativeMints.map((a) => a.tokenMint), network_1.ParsableMintInfo);
        const nonNativeAddresses = nonNativeMints.map(({ tokenMint }, index) => (0, spl_token_1.getAssociatedTokenAddressSync)(tokenMint, ownerAddress, allowPDAOwnerAddress, mints[index].tokenProgram));
        const tokenAccounts = await (0, network_1.getMultipleParsedAccounts)(connection, nonNativeAddresses, network_1.ParsableTokenAccountInfo);
        tokenAccounts.forEach((tokenAccount, index) => {
          const ataAddress = nonNativeAddresses[index];
          let resolvedInstruction;
          if (tokenAccount) {
            if (!tokenAccount.owner.equals(ownerAddress)) {
              throw new Error(`ATA with change of ownership detected: ${ataAddress.toBase58()}`);
            }
            resolvedInstruction = {
              address: ataAddress,
              tokenProgram: tokenAccount.tokenProgram,
              ...types_1.EMPTY_INSTRUCTION
            };
          } else {
            const createAtaInstruction = modeIdempotent ? (0, spl_token_1.createAssociatedTokenAccountIdempotentInstruction)(payer, ataAddress, ownerAddress, nonNativeMints[index].tokenMint, mints[index].tokenProgram) : (0, spl_token_1.createAssociatedTokenAccountInstruction)(payer, ataAddress, ownerAddress, nonNativeMints[index].tokenMint, mints[index].tokenProgram);
            resolvedInstruction = {
              address: ataAddress,
              tokenProgram: mints[index].tokenProgram,
              instructions: [createAtaInstruction],
              cleanupInstructions: [],
              signers: []
            };
          }
          instructionMap[nonNativeMints[index].tokenMint.toBase58()] = resolvedInstruction;
        });
      }
      if (nativeMints.length > 0) {
        const accountRentExempt = await getAccountRentExempt();
        const wrappedSolAmountIn = nativeMints[0]?.wrappedSolAmountIn || math_1.ZERO;
        instructionMap[spl_token_1.NATIVE_MINT.toBase58()] = token_util_1.TokenUtil.createWrappedNativeAccountInstruction(ownerAddress, wrappedSolAmountIn, accountRentExempt, payer, void 0, wrappedSolAccountCreateMethod);
      }
      return requests.map(({ tokenMint }) => instructionMap[tokenMint.toBase58()]);
    }
  }
});

// node_modules/@orca-so/common-sdk/dist/web3/public-key-utils.js
var require_public_key_utils = __commonJS({
  "node_modules/@orca-so/common-sdk/dist/web3/public-key-utils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PublicKeyUtils = void 0;
    var PublicKeyUtils = class {
      static isBase58(value) {
        return /^[A-HJ-NP-Za-km-z1-9]*$/.test(value);
      }
      static orderKeys(...keys) {
        return keys.sort(comparePublicKeys);
      }
    };
    exports2.PublicKeyUtils = PublicKeyUtils;
    function comparePublicKeys(key1, key2) {
      const bytes1 = key1.toBytes();
      const bytes2 = key2.toBytes();
      if (bytes1.byteLength !== bytes2.byteLength) {
        return bytes1.byteLength - bytes2.byteLength;
      }
      for (let i = 0; i < bytes1.byteLength; i++) {
        let byte1 = bytes1[i];
        let byte2 = bytes2[i];
        if (byte1 !== byte2) {
          return byte1 - byte2;
        }
      }
      return 0;
    }
  }
});

// node_modules/@orca-so/common-sdk/dist/web3/transactions/compute-budget.js
var require_compute_budget = __commonJS({
  "node_modules/@orca-so/common-sdk/dist/web3/transactions/compute-budget.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DEFAULT_MAX_COMPUTE_UNIT_LIMIT = exports2.DEFAULT_MIN_PRIORITY_FEE_LAMPORTS = exports2.DEFAULT_MAX_PRIORITY_FEE_LAMPORTS = exports2.DEFAULT_PRIORITY_FEE_PERCENTILE = exports2.MICROLAMPORTS_PER_LAMPORT = void 0;
    exports2.estimateComputeBudgetLimit = estimateComputeBudgetLimit;
    exports2.getPriorityFeeInLamports = getPriorityFeeInLamports;
    exports2.getLockWritableAccounts = getLockWritableAccounts;
    exports2.setLoadedAccountsDataSizeLimitInstruction = setLoadedAccountsDataSizeLimitInstruction;
    var web3_js_1 = require("@solana/web3.js");
    var bn_js_1 = __importDefault(require_bn());
    exports2.MICROLAMPORTS_PER_LAMPORT = 1e6;
    exports2.DEFAULT_PRIORITY_FEE_PERCENTILE = 0.9;
    exports2.DEFAULT_MAX_PRIORITY_FEE_LAMPORTS = 1e6;
    exports2.DEFAULT_MIN_PRIORITY_FEE_LAMPORTS = 0;
    exports2.DEFAULT_MAX_COMPUTE_UNIT_LIMIT = 14e5;
    async function estimateComputeBudgetLimit(connection, instructions, lookupTableAccounts, payer, margin) {
      try {
        const txMainInstructions = instructions.flatMap((instruction) => instruction.instructions);
        const txCleanupInstruction = instructions.flatMap((instruction) => instruction.cleanupInstructions);
        const txMessage = new web3_js_1.TransactionMessage({
          recentBlockhash: web3_js_1.PublicKey.default.toBase58(),
          payerKey: payer,
          instructions: [...txMainInstructions, ...txCleanupInstruction]
        }).compileToV0Message(lookupTableAccounts);
        const tx = new web3_js_1.VersionedTransaction(txMessage);
        const simulation = await connection.simulateTransaction(tx, {
          sigVerify: false,
          replaceRecentBlockhash: true
        });
        if (!simulation.value.unitsConsumed) {
          return exports2.DEFAULT_MAX_COMPUTE_UNIT_LIMIT;
        }
        const marginUnits = Math.max(1e5, margin * simulation.value.unitsConsumed);
        const estimatedUnits = Math.ceil(simulation.value.unitsConsumed + marginUnits);
        return Math.min(exports2.DEFAULT_MAX_COMPUTE_UNIT_LIMIT, estimatedUnits);
      } catch {
        return exports2.DEFAULT_MAX_COMPUTE_UNIT_LIMIT;
      }
    }
    async function getPriorityFeeInLamports(connection, computeBudgetLimit, lockedWritableAccounts, percentile = exports2.DEFAULT_PRIORITY_FEE_PERCENTILE, getRecentPrioritizationFees) {
      const recentPriorityFees = await (getRecentPrioritizationFees ? getRecentPrioritizationFees(lockedWritableAccounts) : connection.getRecentPrioritizationFees({
        lockedWritableAccounts
      }));
      const priorityFee = getPriorityFeeSuggestion(recentPriorityFees, percentile);
      return priorityFee * computeBudgetLimit / exports2.MICROLAMPORTS_PER_LAMPORT;
    }
    function getPriorityFeeSuggestion(recentPriorityFees, percentile) {
      const sortedPriorityFees = recentPriorityFees.sort((a, b) => a.prioritizationFee - b.prioritizationFee);
      const percentileIndex = Math.min(Math.max(Math.floor(sortedPriorityFees.length * percentile), 0), sortedPriorityFees.length - 1);
      return sortedPriorityFees[percentileIndex].prioritizationFee;
    }
    function getLockWritableAccounts(instructions) {
      return instructions.flatMap((instruction) => [
        ...instruction.instructions,
        ...instruction.cleanupInstructions
      ]).flatMap((instruction) => instruction.keys).filter((key) => key.isWritable).map((key) => key.pubkey);
    }
    var SET_LOADED_ACCOUNTS_DATA_SIZE_LIMIT_INSTRUCTION_DISCRIMINATOR = Buffer.from([4]);
    function setLoadedAccountsDataSizeLimitInstruction(dataSizeLimit) {
      const dataSizeLimitBn = new bn_js_1.default(dataSizeLimit);
      return new web3_js_1.TransactionInstruction({
        programId: web3_js_1.ComputeBudgetProgram.programId,
        data: Buffer.concat([
          SET_LOADED_ACCOUNTS_DATA_SIZE_LIMIT_INSTRUCTION_DISCRIMINATOR,
          dataSizeLimitBn.toArrayLike(Buffer, "le", 4)
        ]),
        keys: []
      });
    }
  }
});

// node_modules/@orca-so/common-sdk/dist/web3/transactions/constants.js
var require_constants2 = __commonJS({
  "node_modules/@orca-so/common-sdk/dist/web3/transactions/constants.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MEASUREMENT_BLOCKHASH = exports2.TX_BASE64_ENCODED_SIZE_LIMIT = exports2.TX_SIZE_LIMIT = void 0;
    var web3_js_1 = require("@solana/web3.js");
    exports2.TX_SIZE_LIMIT = web3_js_1.PACKET_DATA_SIZE;
    exports2.TX_BASE64_ENCODED_SIZE_LIMIT = Math.ceil(exports2.TX_SIZE_LIMIT / 3) * 4;
    exports2.MEASUREMENT_BLOCKHASH = {
      blockhash: "65FJ2gp6jC2x87bycfdZpxDyjiodcAoymxR6PMZzfavY",
      lastValidBlockHeight: 160381350
    };
  }
});

// node_modules/@orca-so/common-sdk/dist/web3/transactions/jito-tip.js
var require_jito_tip = __commonJS({
  "node_modules/@orca-so/common-sdk/dist/web3/transactions/jito-tip.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getJitoTipAddress = getJitoTipAddress;
    var web3_js_1 = require("@solana/web3.js");
    var jitoTipAddresses = [
      "96gYZGLnJYVFmbjzopPSU6QiEV5fGqZNyN9nmNhvrZU5",
      "HFqU5x63VTqvQss8hp11i4wVV8bD44PvwucfZ2bU7gRe",
      "Cw8CFyM9FkoMi7K7Crf6HNQqf4uEMzpKw6QNghXLvLkY",
      "ADaUMid9yfUytqMBgopwjb2DTLSokTSzL1zt6iGPaS49",
      "DfXygSm4jCyNCybVYYK6DwvWqjKee8pbDmJGcLWNDXjh",
      "ADuUkR4vqLUMWXxW9gh6D6L8pMSawimctcNZ5pGwDcEt",
      "DttWaMuVvTiduZRnguLF7jNxTgiMBZ1hyAumKUiL2KRL",
      "3AVi9Tg9Uo68tJfuvoKvqKNWKkC5wPdSSdeBnizKZ6jT"
    ];
    function getJitoTipAddress() {
      return new web3_js_1.PublicKey(jitoTipAddresses[Math.floor(Math.random() * jitoTipAddresses.length)]);
    }
  }
});

// node_modules/@orca-so/common-sdk/dist/web3/transactions/transactions-builder.js
var require_transactions_builder = __commonJS({
  "node_modules/@orca-so/common-sdk/dist/web3/transactions/transactions-builder.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isVersionedTransaction = exports2.TransactionBuilder = exports2.defaultTransactionBuilderOptions = void 0;
    var web3_js_1 = require("@solana/web3.js");
    var compute_budget_1 = require_compute_budget();
    var constants_1 = require_constants2();
    var jito_tip_1 = require_jito_tip();
    var LEGACY_TX_UNIQUE_KEYS_LIMIT = 35;
    exports2.defaultTransactionBuilderOptions = {
      defaultBuildOption: {
        maxSupportedTransactionVersion: 0,
        blockhashCommitment: "confirmed"
      },
      defaultSendOption: {
        skipPreflight: false,
        preflightCommitment: "confirmed",
        maxRetries: 3
      },
      defaultConfirmationCommitment: "confirmed"
    };
    var TransactionBuilder = class {
      connection;
      wallet;
      instructions;
      signers;
      opts;
      constructor(connection, wallet, defaultOpts) {
        this.connection = connection;
        this.wallet = wallet;
        this.instructions = [];
        this.signers = [];
        this.opts = defaultOpts ?? exports2.defaultTransactionBuilderOptions;
      }
      addInstruction(instruction) {
        this.instructions.push(instruction);
        return this;
      }
      addInstructions(instructions) {
        this.instructions = this.instructions.concat(instructions);
        return this;
      }
      prependInstruction(instruction) {
        this.instructions.unshift(instruction);
        return this;
      }
      prependInstructions(instructions) {
        this.instructions = instructions.concat(this.instructions);
        return this;
      }
      addSigner(signer) {
        this.signers.push(signer);
        return this;
      }
      isEmpty() {
        return this.instructions.length == 0;
      }
      compressIx(compressPost) {
        let instructions = [];
        let cleanupInstructions = [];
        let signers = [];
        this.instructions.forEach((curr) => {
          instructions = instructions.concat(curr.instructions);
          cleanupInstructions = curr.cleanupInstructions.concat(cleanupInstructions);
          signers = signers.concat(curr.signers);
        });
        if (compressPost) {
          instructions = instructions.concat(cleanupInstructions);
          cleanupInstructions = [];
        }
        return {
          instructions: [...instructions],
          cleanupInstructions: [...cleanupInstructions],
          signers
        };
      }
      txnSize(userOptions) {
        const finalOptions = {
          ...this.opts.defaultBuildOption,
          ...userOptions,
          latestBlockhash: constants_1.MEASUREMENT_BLOCKHASH,
          computeBudgetOption: this.opts.defaultBuildOption.computeBudgetOption ?? {
            type: "none"
          }
        };
        if (this.isEmpty()) {
          return 0;
        }
        const request = this.buildSync(finalOptions);
        const tx = request.transaction;
        return (0, exports2.isVersionedTransaction)(tx) ? measureV0Tx(tx) : measureLegacyTx(tx);
      }
      buildSync(options) {
        const { latestBlockhash, maxSupportedTransactionVersion, computeBudgetOption } = options;
        const ix = this.compressIx(true);
        let prependInstructions = [];
        if (computeBudgetOption.type === "fixed") {
          const computeLimit = computeBudgetOption.computeBudgetLimit ?? compute_budget_1.DEFAULT_MAX_COMPUTE_UNIT_LIMIT;
          const microLamports = Math.floor(computeBudgetOption.priorityFeeLamports * compute_budget_1.MICROLAMPORTS_PER_LAMPORT / computeLimit);
          prependInstructions = [
            web3_js_1.ComputeBudgetProgram.setComputeUnitLimit({
              units: computeLimit
            })
          ];
          if (microLamports > 0) {
            prependInstructions.push(web3_js_1.ComputeBudgetProgram.setComputeUnitPrice({
              microLamports
            }));
          }
          if (computeBudgetOption.accountDataSizeLimit) {
            prependInstructions.push((0, compute_budget_1.setLoadedAccountsDataSizeLimitInstruction)(computeBudgetOption.accountDataSizeLimit));
          }
          if (computeBudgetOption.jitoTipLamports && computeBudgetOption.jitoTipLamports > 0) {
            prependInstructions.push(web3_js_1.SystemProgram.transfer({
              fromPubkey: this.wallet.publicKey,
              toPubkey: (0, jito_tip_1.getJitoTipAddress)(),
              lamports: computeBudgetOption.jitoTipLamports
            }));
          }
        }
        if (computeBudgetOption.type === "auto") {
          prependInstructions = [
            web3_js_1.ComputeBudgetProgram.setComputeUnitLimit({
              units: compute_budget_1.DEFAULT_MAX_COMPUTE_UNIT_LIMIT
            }),
            web3_js_1.ComputeBudgetProgram.setComputeUnitPrice({
              microLamports: 0
            })
          ];
          if (computeBudgetOption.accountDataSizeLimit) {
            prependInstructions.push((0, compute_budget_1.setLoadedAccountsDataSizeLimitInstruction)(computeBudgetOption.accountDataSizeLimit));
          }
          if (computeBudgetOption.jitoTipLamports && computeBudgetOption.jitoTipLamports > 0) {
            prependInstructions.push(web3_js_1.SystemProgram.transfer({
              fromPubkey: this.wallet.publicKey,
              toPubkey: (0, jito_tip_1.getJitoTipAddress)(),
              lamports: computeBudgetOption.jitoTipLamports
            }));
          }
        }
        const allSigners = ix.signers.concat(this.signers);
        const recentBlockhash = latestBlockhash;
        if (maxSupportedTransactionVersion === "legacy") {
          const transaction = new web3_js_1.Transaction({
            ...recentBlockhash,
            feePayer: this.wallet.publicKey
          });
          if (prependInstructions.length > 0) {
            transaction.add(...prependInstructions);
          }
          transaction.add(...ix.instructions);
          transaction.feePayer = this.wallet.publicKey;
          return {
            transaction,
            signers: allSigners,
            recentBlockhash
          };
        }
        const txnMsg = new web3_js_1.TransactionMessage({
          recentBlockhash: recentBlockhash.blockhash,
          payerKey: this.wallet.publicKey,
          instructions: [...prependInstructions, ...ix.instructions]
        });
        const { lookupTableAccounts } = options;
        const msg = txnMsg.compileToV0Message(lookupTableAccounts);
        const v0txn = new web3_js_1.VersionedTransaction(msg);
        return {
          transaction: v0txn,
          signers: allSigners,
          recentBlockhash
        };
      }
      async estimateFee(getPriorityFeePerUnit, computeLimitMargin, selectionPercentile, lookupTableAccounts) {
        const estConsumedComputeUnits = await (0, compute_budget_1.estimateComputeBudgetLimit)(this.connection, this.instructions, lookupTableAccounts, this.wallet.publicKey, computeLimitMargin ?? 0.1);
        const lockedWritableAccounts = (0, compute_budget_1.getLockWritableAccounts)(this.instructions);
        const estPriorityFeePerUnitInLamports = await (getPriorityFeePerUnit ? getPriorityFeePerUnit(lockedWritableAccounts) : this.connection.getRecentPrioritizationFees({
          lockedWritableAccounts
        }));
        const estPriorityFeeInLamports = await (0, compute_budget_1.getPriorityFeeInLamports)(this.connection, estConsumedComputeUnits, lockedWritableAccounts, selectionPercentile ?? compute_budget_1.DEFAULT_PRIORITY_FEE_PERCENTILE, getPriorityFeePerUnit);
        return {
          estConsumedComputeUnits,
          estPriorityFeePerUnitInLamports,
          estPriorityFeeInLamports
        };
      }
      async build(userOptions) {
        const finalOptions = { ...this.opts.defaultBuildOption, ...userOptions };
        const { latestBlockhash, blockhashCommitment, computeBudgetOption } = finalOptions;
        let recentBlockhash = latestBlockhash;
        if (!recentBlockhash) {
          recentBlockhash = await this.connection.getLatestBlockhash(blockhashCommitment);
        }
        let finalComputeBudgetOption = computeBudgetOption ?? { type: "none" };
        const lookupTableAccounts = finalOptions.maxSupportedTransactionVersion === "legacy" ? void 0 : finalOptions.lookupTableAccounts;
        if (finalComputeBudgetOption.type === "auto") {
          const computeBudgetLimit = await (0, compute_budget_1.estimateComputeBudgetLimit)(this.connection, this.instructions, lookupTableAccounts, this.wallet.publicKey, finalComputeBudgetOption.computeLimitMargin ?? 0.1);
          const percentile = finalComputeBudgetOption.computePricePercentile ?? compute_budget_1.DEFAULT_PRIORITY_FEE_PERCENTILE;
          const priorityFee = await (0, compute_budget_1.getPriorityFeeInLamports)(this.connection, computeBudgetLimit, (0, compute_budget_1.getLockWritableAccounts)(this.instructions), percentile, finalComputeBudgetOption.getPriorityFeePerUnit);
          const maxPriorityFeeLamports = finalComputeBudgetOption.maxPriorityFeeLamports ?? compute_budget_1.DEFAULT_MAX_PRIORITY_FEE_LAMPORTS;
          const minPriorityFeeLamports = finalComputeBudgetOption.minPriorityFeeLamports ?? compute_budget_1.DEFAULT_MIN_PRIORITY_FEE_LAMPORTS;
          const priorityFeeLamports = Math.max(Math.min(priorityFee, maxPriorityFeeLamports), minPriorityFeeLamports);
          finalComputeBudgetOption = {
            type: "fixed",
            priorityFeeLamports,
            computeBudgetLimit,
            accountDataSizeLimit: finalComputeBudgetOption.accountDataSizeLimit,
            jitoTipLamports: finalComputeBudgetOption.jitoTipLamports
          };
        } else if (finalComputeBudgetOption.type === "fixed" && finalComputeBudgetOption.computeBudgetLimit === void 0) {
          const computeBudgetLimit = await (0, compute_budget_1.estimateComputeBudgetLimit)(this.connection, this.instructions, lookupTableAccounts, this.wallet.publicKey, 0.1);
          finalComputeBudgetOption = {
            ...finalComputeBudgetOption,
            computeBudgetLimit
          };
        }
        return this.buildSync({
          ...finalOptions,
          latestBlockhash: recentBlockhash,
          computeBudgetOption: finalComputeBudgetOption
        });
      }
      async buildAndExecute(options, sendOptions, confirmCommitment) {
        const sendOpts = { ...this.opts.defaultSendOption, ...sendOptions };
        const btx = await this.build(options);
        const txn = btx.transaction;
        const resolvedConfirmCommitment = confirmCommitment ?? this.opts.defaultConfirmationCommitment;
        let txId;
        if ((0, exports2.isVersionedTransaction)(txn)) {
          const signedTxn = await this.wallet.signTransaction(txn);
          signedTxn.sign(btx.signers);
          txId = await this.connection.sendTransaction(signedTxn, sendOpts);
        } else {
          const signedTxn = await this.wallet.signTransaction(txn);
          btx.signers.filter((s) => s !== void 0).forEach((keypair) => signedTxn.partialSign(keypair));
          txId = await this.connection.sendRawTransaction(signedTxn.serialize(), sendOpts);
        }
        const result = await this.connection.confirmTransaction({
          signature: txId,
          ...btx.recentBlockhash
        }, resolvedConfirmCommitment);
        const confirmTxErr = result.value.err;
        if (confirmTxErr) {
          throw new Error(confirmTxErr.toString());
        }
        return txId;
      }
    };
    exports2.TransactionBuilder = TransactionBuilder;
    var isVersionedTransaction = (tx) => {
      return "version" in tx;
    };
    exports2.isVersionedTransaction = isVersionedTransaction;
    function measureLegacyTx(tx) {
      const uniqueKeys = /* @__PURE__ */ new Set();
      for (const instruction of tx.instructions) {
        for (const key of instruction.keys) {
          uniqueKeys.add(key.pubkey.toBase58());
        }
        uniqueKeys.add(instruction.programId.toBase58());
      }
      if (uniqueKeys.size > LEGACY_TX_UNIQUE_KEYS_LIMIT) {
        throw new Error("Unable to measure transaction size. Too many unique keys in transaction.");
      }
      try {
        const serialized = tx.serialize({ requireAllSignatures: false });
        return serialized.length;
      } catch {
        throw new Error("Unable to measure transaction size. Unable to serialize transaction.");
      }
    }
    function measureV0Tx(tx) {
      let serialized;
      try {
        serialized = tx.serialize();
      } catch {
        throw new Error("Unable to measure transaction size. Unable to serialize transaction.");
      }
      if (serialized.length > web3_js_1.PACKET_DATA_SIZE) {
        throw new Error("Unable to measure transaction size. Transaction too large.");
      }
      return serialized.length;
    }
  }
});

// node_modules/@orca-so/common-sdk/dist/web3/transactions/transactions-processor.js
var require_transactions_processor = __commonJS({
  "node_modules/@orca-so/common-sdk/dist/web3/transactions/transactions-processor.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TransactionProcessor = void 0;
    var transactions_builder_1 = require_transactions_builder();
    var TransactionProcessor = class {
      connection;
      wallet;
      commitment;
      constructor(connection, wallet, commitment = "confirmed") {
        this.connection = connection;
        this.wallet = wallet;
        this.commitment = commitment;
      }
      async signTransaction(txRequest) {
        const { transactions, lastValidBlockHeight, blockhash } = await this.signTransactions([txRequest]);
        return { transaction: transactions[0], lastValidBlockHeight, blockhash };
      }
      async signTransactions(txRequests) {
        const { blockhash, lastValidBlockHeight } = await this.connection.getLatestBlockhash(this.commitment);
        const feePayer = this.wallet.publicKey;
        const pSignedTxs = txRequests.map((txRequest) => {
          return rewriteTransaction(txRequest, feePayer, blockhash);
        });
        const transactions = await this.wallet.signAllTransactions(pSignedTxs);
        return {
          transactions,
          lastValidBlockHeight,
          blockhash
        };
      }
      async sendTransaction(transaction, lastValidBlockHeight, blockhash) {
        const execute = this.constructSendTransactions([transaction], lastValidBlockHeight, blockhash);
        const txs = await execute();
        const ex = txs[0];
        if (ex.status === "fulfilled") {
          return ex.value;
        } else {
          throw ex.reason;
        }
      }
      constructSendTransactions(transactions, lastValidBlockHeight, blockhash, parallel = true) {
        const executeTx = async (tx) => {
          const rawTxs = tx.serialize();
          return this.connection.sendRawTransaction(rawTxs, {
            preflightCommitment: this.commitment
          });
        };
        const confirmTx = async (txId) => {
          const result = await this.connection.confirmTransaction({
            signature: txId,
            lastValidBlockHeight,
            blockhash
          }, this.commitment);
          if (result.value.err) {
            throw new Error(`Transaction failed: ${JSON.stringify(result.value)}`);
          }
        };
        return async () => {
          if (parallel) {
            const results = transactions.map(async (tx) => {
              const txId = await executeTx(tx);
              await confirmTx(txId);
              return txId;
            });
            return Promise.allSettled(results);
          } else {
            const results = [];
            for (const tx of transactions) {
              const txId = await executeTx(tx);
              await confirmTx(txId);
              results.push(txId);
            }
            return Promise.allSettled(results);
          }
        };
      }
      async signAndConstructTransaction(txRequest) {
        const { transaction, lastValidBlockHeight, blockhash } = await this.signTransaction(txRequest);
        return {
          signedTx: transaction,
          execute: async () => this.sendTransaction(transaction, lastValidBlockHeight, blockhash)
        };
      }
      async signAndConstructTransactions(txRequests, parallel = true) {
        const { transactions, lastValidBlockHeight, blockhash } = await this.signTransactions(txRequests);
        const execute = this.constructSendTransactions(transactions, lastValidBlockHeight, blockhash, parallel);
        return { signedTxs: transactions, execute };
      }
    };
    exports2.TransactionProcessor = TransactionProcessor;
    function rewriteTransaction(txRequest, feePayer, blockhash) {
      if ((0, transactions_builder_1.isVersionedTransaction)(txRequest.transaction)) {
        let tx = txRequest.transaction;
        if (txRequest.signers) {
          tx.sign(txRequest.signers ?? []);
        }
        return tx;
      } else {
        let tx = txRequest.transaction;
        let signers = txRequest.signers ?? [];
        tx.feePayer = feePayer;
        tx.recentBlockhash = blockhash;
        signers.forEach((kp) => {
          tx.partialSign(kp);
        });
        return tx;
      }
    }
  }
});

// node_modules/@orca-so/common-sdk/dist/web3/transactions/index.js
var require_transactions = __commonJS({
  "node_modules/@orca-so/common-sdk/dist/web3/transactions/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_compute_budget(), exports2);
    __exportStar(require_constants2(), exports2);
    __exportStar(require_transactions_builder(), exports2);
    __exportStar(require_transactions_processor(), exports2);
    __exportStar(require_types2(), exports2);
  }
});

// node_modules/@orca-so/common-sdk/dist/web3/wallet.js
var require_wallet = __commonJS({
  "node_modules/@orca-so/common-sdk/dist/web3/wallet.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ReadOnlyWallet = void 0;
    var web3_js_1 = require("@solana/web3.js");
    var ReadOnlyWallet = class {
      publicKey;
      constructor(publicKey2 = web3_js_1.PublicKey.default) {
        this.publicKey = publicKey2;
      }
      signTransaction(_transaction) {
        throw new Error("Read only wallet cannot sign transaction.");
      }
      signAllTransactions(_transactions) {
        throw new Error("Read only wallet cannot sign transactions.");
      }
    };
    exports2.ReadOnlyWallet = ReadOnlyWallet;
  }
});

// node_modules/@orca-so/common-sdk/dist/web3/index.js
var require_web32 = __commonJS({
  "node_modules/@orca-so/common-sdk/dist/web3/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_address_util(), exports2);
    __exportStar(require_ata_util(), exports2);
    __exportStar(require_network(), exports2);
    __exportStar(require_public_key_utils(), exports2);
    __exportStar(require_token_util(), exports2);
    __exportStar(require_transactions(), exports2);
    __exportStar(require_wallet(), exports2);
  }
});

// node_modules/@orca-so/common-sdk/dist/index.js
var require_dist2 = __commonJS({
  "node_modules/@orca-so/common-sdk/dist/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_math(), exports2);
    __exportStar(require_web32(), exports2);
  }
});

// node_modules/@orca-so/whirlpools-sdk/dist/types/public/anchor-types.js
var require_anchor_types = __commonJS({
  "node_modules/@orca-so/whirlpools-sdk/dist/types/public/anchor-types.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.WHIRLPOOL_ACCOUNT_SIZE = exports2.WHIRLPOOL_CODER = exports2.WHIRLPOOL_IDL = exports2.AccountName = void 0;
    exports2.getAccountSize = getAccountSize;
    var anchor_1 = require("@coral-xyz/anchor");
    var whirlpool_json_1 = __importDefault(require_whirlpool());
    var AccountName;
    (function(AccountName2) {
      AccountName2["WhirlpoolsConfig"] = "WhirlpoolsConfig";
      AccountName2["Position"] = "Position";
      AccountName2["TickArray"] = "TickArray";
      AccountName2["Whirlpool"] = "Whirlpool";
      AccountName2["FeeTier"] = "FeeTier";
      AccountName2["PositionBundle"] = "PositionBundle";
      AccountName2["WhirlpoolsConfigExtension"] = "WhirlpoolsConfigExtension";
      AccountName2["TokenBadge"] = "TokenBadge";
      AccountName2["LockConfig"] = "LockConfig";
      AccountName2["Oracle"] = "Oracle";
      AccountName2["AdaptiveFeeTier"] = "AdaptiveFeeTier";
    })(AccountName || (exports2.AccountName = AccountName = {}));
    exports2.WHIRLPOOL_IDL = whirlpool_json_1.default;
    exports2.WHIRLPOOL_CODER = new anchor_1.BorshAccountsCoder(exports2.WHIRLPOOL_IDL);
    function getAccountSize(accountName) {
      const size = exports2.WHIRLPOOL_CODER.size(exports2.WHIRLPOOL_IDL.accounts.find((account) => account.name === accountName));
      return size + RESERVED_BYTES[accountName];
    }
    var RESERVED_BYTES = {
      [AccountName.WhirlpoolsConfig]: 2,
      [AccountName.Position]: 0,
      [AccountName.TickArray]: 0,
      [AccountName.Whirlpool]: 0,
      [AccountName.FeeTier]: 0,
      [AccountName.PositionBundle]: 64,
      [AccountName.WhirlpoolsConfigExtension]: 512,
      [AccountName.TokenBadge]: 128,
      [AccountName.LockConfig]: 128,
      [AccountName.Oracle]: 0,
      [AccountName.AdaptiveFeeTier]: 128
    };
    exports2.WHIRLPOOL_ACCOUNT_SIZE = getAccountSize(AccountName.Whirlpool);
  }
});

// node_modules/@orca-so/whirlpools-sdk/dist/types/public/constants.js
var require_constants3 = __commonJS({
  "node_modules/@orca-so/whirlpools-sdk/dist/types/public/constants.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SPLASH_POOL_TICK_SPACING = exports2.FULL_RANGE_ONLY_TICK_SPACING_THRESHOLD = exports2.WHIRLPOOL_NFT_UPDATE_AUTH = exports2.FEE_RATE_MUL_VALUE = exports2.PROTOCOL_FEE_RATE_MUL_VALUE = exports2.MAX_SUPPLEMENTAL_TICK_ARRAYS = exports2.MAX_SWAP_TICK_ARRAYS = exports2.MEMO_PROGRAM_ADDRESS = exports2.METADATA_PROGRAM_ADDRESS = exports2.POSITION_BUNDLE_SIZE = exports2.TICK_ARRAY_SIZE = exports2.MAX_SQRT_PRICE_BN = exports2.MIN_SQRT_PRICE_BN = exports2.MIN_SQRT_PRICE = exports2.MAX_SQRT_PRICE = exports2.MIN_TICK_INDEX = exports2.MAX_TICK_INDEX = exports2.NUM_REWARDS = exports2.ORCA_SUPPORTED_TICK_SPACINGS = exports2.ORCA_WHIRLPOOLS_CONFIG_EXTENSION = exports2.ORCA_WHIRLPOOLS_CONFIG_ECLIPSE = exports2.ORCA_WHIRLPOOLS_CONFIG = exports2.ORCA_WHIRLPOOL_PROGRAM_ID = void 0;
    var anchor_1 = require("@coral-xyz/anchor");
    var web3_js_1 = require("@solana/web3.js");
    exports2.ORCA_WHIRLPOOL_PROGRAM_ID = new web3_js_1.PublicKey("whirLbMiicVdio4qvUfM5KAg6Ct8VwpYzGff3uctyCc");
    exports2.ORCA_WHIRLPOOLS_CONFIG = new web3_js_1.PublicKey("2LecshUwdy9xi7meFgHtFJQNSKk4KdTrcpvaB56dP2NQ");
    exports2.ORCA_WHIRLPOOLS_CONFIG_ECLIPSE = new web3_js_1.PublicKey("FVG4oDbGv16hqTUbovjyGmtYikn6UBEnazz6RVDMEFwv");
    exports2.ORCA_WHIRLPOOLS_CONFIG_EXTENSION = new web3_js_1.PublicKey("777H5H3Tp9U11uRVRzFwM8BinfiakbaLT8vQpeuhvEiH");
    exports2.ORCA_SUPPORTED_TICK_SPACINGS = [
      1,
      2,
      4,
      8,
      16,
      64,
      96,
      128,
      256,
      32896
    ];
    exports2.NUM_REWARDS = 3;
    exports2.MAX_TICK_INDEX = 443636;
    exports2.MIN_TICK_INDEX = -443636;
    exports2.MAX_SQRT_PRICE = "79226673515401279992447579055";
    exports2.MIN_SQRT_PRICE = "4295048016";
    exports2.MIN_SQRT_PRICE_BN = new anchor_1.BN(exports2.MIN_SQRT_PRICE);
    exports2.MAX_SQRT_PRICE_BN = new anchor_1.BN(exports2.MAX_SQRT_PRICE);
    exports2.TICK_ARRAY_SIZE = 88;
    exports2.POSITION_BUNDLE_SIZE = 256;
    exports2.METADATA_PROGRAM_ADDRESS = new web3_js_1.PublicKey("metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s");
    exports2.MEMO_PROGRAM_ADDRESS = new web3_js_1.PublicKey("MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr");
    exports2.MAX_SWAP_TICK_ARRAYS = 3;
    exports2.MAX_SUPPLEMENTAL_TICK_ARRAYS = 3;
    exports2.PROTOCOL_FEE_RATE_MUL_VALUE = new anchor_1.BN(1e4);
    exports2.FEE_RATE_MUL_VALUE = new anchor_1.BN(1e6);
    exports2.WHIRLPOOL_NFT_UPDATE_AUTH = new web3_js_1.PublicKey("3axbTs2z5GBy6usVbNVoqEgZMng3vZvMnAoX29BFfwhr");
    exports2.FULL_RANGE_ONLY_TICK_SPACING_THRESHOLD = 32768;
    exports2.SPLASH_POOL_TICK_SPACING = 32896;
  }
});

// node_modules/@orca-so/whirlpools-sdk/dist/types/public/index.js
var require_public = __commonJS({
  "node_modules/@orca-so/whirlpools-sdk/dist/types/public/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_anchor_types(), exports2);
    __exportStar(require_constants3(), exports2);
  }
});

// node_modules/@orca-so/whirlpools-sdk/dist/network/public/parsing.js
var require_parsing2 = __commonJS({
  "node_modules/@orca-so/whirlpools-sdk/dist/network/public/parsing.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __importStar = exports2 && exports2.__importStar || /* @__PURE__ */ function() {
      var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2)
            if (Object.prototype.hasOwnProperty.call(o2, k))
              ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      };
      return function(mod2) {
        if (mod2 && mod2.__esModule)
          return mod2;
        var result = {};
        if (mod2 != null) {
          for (var k = ownKeys(mod2), i = 0; i < k.length; i++)
            if (k[i] !== "default")
              __createBinding(result, mod2, k[i]);
        }
        __setModuleDefault(result, mod2);
        return result;
      };
    }();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ParsableOracle = exports2.ParsableAdaptiveFeeTier = exports2.ParsableLockConfig = exports2.ParsableTokenBadge = exports2.ParsableWhirlpoolsConfigExtension = exports2.ParsablePositionBundle = exports2.ParsableFeeTier = exports2.ParsableTickArray = exports2.ParsablePosition = exports2.ParsableWhirlpool = exports2.ParsableWhirlpoolsConfig = void 0;
    var anchor_1 = require("@coral-xyz/anchor");
    var common_sdk_1 = require_dist2();
    var WhirlpoolIDL = __importStar(require_whirlpool());
    var public_1 = require_public();
    var ParsableWhirlpoolsConfig = class ParsableWhirlpoolsConfig {
      static parse(address, accountData) {
        if (!accountData?.data) {
          return null;
        }
        try {
          return parseAnchorAccount(public_1.AccountName.WhirlpoolsConfig, accountData);
        } catch (e) {
          console.error(`error while parsing WhirlpoolsConfig: ${e}`);
          return null;
        }
      }
    };
    exports2.ParsableWhirlpoolsConfig = ParsableWhirlpoolsConfig;
    exports2.ParsableWhirlpoolsConfig = ParsableWhirlpoolsConfig = __decorate([
      (0, common_sdk_1.staticImplements)()
    ], ParsableWhirlpoolsConfig);
    var ParsableWhirlpool = class ParsableWhirlpool {
      static parse(address, accountData) {
        if (!accountData?.data) {
          return null;
        }
        try {
          return parseAnchorAccount(public_1.AccountName.Whirlpool, accountData);
        } catch (e) {
          console.error(`error while parsing Whirlpool: ${e}`);
          return null;
        }
      }
    };
    exports2.ParsableWhirlpool = ParsableWhirlpool;
    exports2.ParsableWhirlpool = ParsableWhirlpool = __decorate([
      (0, common_sdk_1.staticImplements)()
    ], ParsableWhirlpool);
    var ParsablePosition = class ParsablePosition {
      static parse(address, accountData) {
        if (!accountData?.data) {
          return null;
        }
        try {
          return parseAnchorAccount(public_1.AccountName.Position, accountData);
        } catch (e) {
          console.error(`error while parsing Position: ${e}`);
          return null;
        }
      }
    };
    exports2.ParsablePosition = ParsablePosition;
    exports2.ParsablePosition = ParsablePosition = __decorate([
      (0, common_sdk_1.staticImplements)()
    ], ParsablePosition);
    var ParsableTickArray = class ParsableTickArray {
      static parse(address, accountData) {
        if (!accountData?.data) {
          return null;
        }
        try {
          return parseAnchorAccount(public_1.AccountName.TickArray, accountData);
        } catch (e) {
          console.error(`error while parsing TickArray: ${e}`);
          return null;
        }
      }
    };
    exports2.ParsableTickArray = ParsableTickArray;
    exports2.ParsableTickArray = ParsableTickArray = __decorate([
      (0, common_sdk_1.staticImplements)()
    ], ParsableTickArray);
    var ParsableFeeTier = class ParsableFeeTier {
      static parse(address, accountData) {
        if (!accountData?.data) {
          return null;
        }
        try {
          return parseAnchorAccount(public_1.AccountName.FeeTier, accountData);
        } catch (e) {
          console.error(`error while parsing FeeTier: ${e}`);
          return null;
        }
      }
    };
    exports2.ParsableFeeTier = ParsableFeeTier;
    exports2.ParsableFeeTier = ParsableFeeTier = __decorate([
      (0, common_sdk_1.staticImplements)()
    ], ParsableFeeTier);
    var ParsablePositionBundle = class ParsablePositionBundle {
      static parse(address, accountData) {
        if (!accountData?.data) {
          return null;
        }
        try {
          return parseAnchorAccount(public_1.AccountName.PositionBundle, accountData);
        } catch (e) {
          console.error(`error while parsing PositionBundle: ${e}`);
          return null;
        }
      }
    };
    exports2.ParsablePositionBundle = ParsablePositionBundle;
    exports2.ParsablePositionBundle = ParsablePositionBundle = __decorate([
      (0, common_sdk_1.staticImplements)()
    ], ParsablePositionBundle);
    var ParsableWhirlpoolsConfigExtension = class ParsableWhirlpoolsConfigExtension {
      static parse(address, accountData) {
        if (!accountData?.data) {
          return null;
        }
        try {
          return parseAnchorAccount(public_1.AccountName.WhirlpoolsConfigExtension, accountData);
        } catch (e) {
          console.error(`error while parsing WhirlpoolsConfigExtension: ${e}`);
          return null;
        }
      }
    };
    exports2.ParsableWhirlpoolsConfigExtension = ParsableWhirlpoolsConfigExtension;
    exports2.ParsableWhirlpoolsConfigExtension = ParsableWhirlpoolsConfigExtension = __decorate([
      (0, common_sdk_1.staticImplements)()
    ], ParsableWhirlpoolsConfigExtension);
    var ParsableTokenBadge = class ParsableTokenBadge {
      static parse(address, accountData) {
        if (!accountData?.data) {
          return null;
        }
        try {
          return parseAnchorAccount(public_1.AccountName.TokenBadge, accountData);
        } catch (e) {
          console.error(`error while parsing TokenBadge: ${e}`);
          return null;
        }
      }
    };
    exports2.ParsableTokenBadge = ParsableTokenBadge;
    exports2.ParsableTokenBadge = ParsableTokenBadge = __decorate([
      (0, common_sdk_1.staticImplements)()
    ], ParsableTokenBadge);
    var ParsableLockConfig = class ParsableLockConfig {
      static parse(address, accountData) {
        if (!accountData?.data) {
          return null;
        }
        try {
          return parseAnchorAccount(public_1.AccountName.LockConfig, accountData);
        } catch (e) {
          console.error(`error while parsing LockConfig: ${e}`);
          return null;
        }
      }
    };
    exports2.ParsableLockConfig = ParsableLockConfig;
    exports2.ParsableLockConfig = ParsableLockConfig = __decorate([
      (0, common_sdk_1.staticImplements)()
    ], ParsableLockConfig);
    var ParsableAdaptiveFeeTier = class ParsableAdaptiveFeeTier {
      static parse(address, accountData) {
        if (!accountData?.data) {
          return null;
        }
        try {
          return parseAnchorAccount(public_1.AccountName.AdaptiveFeeTier, accountData);
        } catch (e) {
          console.error(`error while parsing AdaptiveFeeTier: ${e}`);
          return null;
        }
      }
    };
    exports2.ParsableAdaptiveFeeTier = ParsableAdaptiveFeeTier;
    exports2.ParsableAdaptiveFeeTier = ParsableAdaptiveFeeTier = __decorate([
      (0, common_sdk_1.staticImplements)()
    ], ParsableAdaptiveFeeTier);
    var ParsableOracle = class ParsableOracle {
      static parse(address, accountData) {
        if (!accountData?.data) {
          return null;
        }
        try {
          return parseAnchorAccount(public_1.AccountName.Oracle, accountData);
        } catch (e) {
          console.error(`error while parsing Oracle: ${e}`);
          return null;
        }
      }
    };
    exports2.ParsableOracle = ParsableOracle;
    exports2.ParsableOracle = ParsableOracle = __decorate([
      (0, common_sdk_1.staticImplements)()
    ], ParsableOracle);
    var WhirlpoolCoder = new anchor_1.BorshAccountsCoder(WhirlpoolIDL);
    function parseAnchorAccount(accountName, accountData) {
      const data = accountData.data;
      const discriminator = anchor_1.BorshAccountsCoder.accountDiscriminator(accountName);
      if (discriminator.compare(data.slice(0, 8))) {
        console.error("incorrect account name during parsing");
        return null;
      }
      try {
        return WhirlpoolCoder.decode(accountName, data);
      } catch (_e) {
        console.error("unknown account name during parsing");
        return null;
      }
    }
  }
});

// node_modules/@orca-so/whirlpools-sdk/dist/network/public/fetcher/fetcher-impl.js
var require_fetcher_impl = __commonJS({
  "node_modules/@orca-so/whirlpools-sdk/dist/network/public/fetcher/fetcher-impl.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.WhirlpoolAccountFetcher = exports2.buildDefaultAccountFetcher = void 0;
    var common_sdk_1 = require_dist2();
    var spl_token_1 = require_cjs3();
    var __1 = require_public4();
    var parsing_1 = require_parsing2();
    var buildDefaultAccountFetcher = (connection) => {
      return new WhirlpoolAccountFetcher(connection, new common_sdk_1.SimpleAccountFetcher(connection, __1.DEFAULT_WHIRLPOOL_RETENTION_POLICY));
    };
    exports2.buildDefaultAccountFetcher = buildDefaultAccountFetcher;
    var WhirlpoolAccountFetcher = class {
      connection;
      fetcher;
      _accountRentExempt;
      _epochInfo;
      _epochInfoNextFetchTime = 0;
      constructor(connection, fetcher) {
        this.connection = connection;
        this.fetcher = fetcher;
      }
      async getAccountRentExempt(refresh = false) {
        if (!this._accountRentExempt || refresh) {
          this._accountRentExempt = await this.connection.getMinimumBalanceForRentExemption(spl_token_1.AccountLayout.span);
        }
        return this._accountRentExempt;
      }
      async getEpoch(refresh = false) {
        if (!this._epochInfo || Date.now() >= this._epochInfoNextFetchTime || refresh) {
          const epochInfo = await this.connection.getEpochInfo();
          const remainingSlotsInEpoch = Math.max(epochInfo.slotsInEpoch - epochInfo.slotIndex, 0);
          const nextFetchTime = Date.now() + remainingSlotsInEpoch * 320;
          this._epochInfo = epochInfo;
          this._epochInfoNextFetchTime = nextFetchTime;
        }
        return this._epochInfo.epoch;
      }
      getPool(address, opts) {
        return this.fetcher.getAccount(address, parsing_1.ParsableWhirlpool, opts);
      }
      getPools(addresses, opts) {
        return this.fetcher.getAccounts(addresses, parsing_1.ParsableWhirlpool, opts);
      }
      getPosition(address, opts) {
        return this.fetcher.getAccount(address, parsing_1.ParsablePosition, opts);
      }
      getPositions(addresses, opts) {
        return this.fetcher.getAccounts(addresses, parsing_1.ParsablePosition, opts);
      }
      getTickArray(address, opts) {
        return this.fetcher.getAccount(address, parsing_1.ParsableTickArray, opts);
      }
      getTickArrays(addresses, opts) {
        return this.fetcher.getAccountsAsArray(addresses, parsing_1.ParsableTickArray, opts);
      }
      getFeeTier(address, opts) {
        return this.fetcher.getAccount(address, parsing_1.ParsableFeeTier, opts);
      }
      getFeeTiers(addresses, opts) {
        return this.fetcher.getAccounts(addresses, parsing_1.ParsableFeeTier, opts);
      }
      getTokenInfo(address, opts) {
        return this.fetcher.getAccount(address, common_sdk_1.ParsableTokenAccountInfo, opts);
      }
      getTokenInfos(addresses, opts) {
        return this.fetcher.getAccounts(addresses, common_sdk_1.ParsableTokenAccountInfo, opts);
      }
      getMintInfo(address, opts) {
        return this.fetcher.getAccount(address, common_sdk_1.ParsableMintInfo, opts);
      }
      getMintInfos(addresses, opts) {
        return this.fetcher.getAccounts(addresses, common_sdk_1.ParsableMintInfo, opts);
      }
      getConfig(address, opts) {
        return this.fetcher.getAccount(address, parsing_1.ParsableWhirlpoolsConfig, opts);
      }
      getConfigs(addresses, opts) {
        return this.fetcher.getAccounts(addresses, parsing_1.ParsableWhirlpoolsConfig, opts);
      }
      getPositionBundle(address, opts) {
        return this.fetcher.getAccount(address, parsing_1.ParsablePositionBundle, opts);
      }
      getPositionBundles(addresses, opts) {
        return this.fetcher.getAccounts(addresses, parsing_1.ParsablePositionBundle, opts);
      }
      getConfigExtension(address, opts) {
        return this.fetcher.getAccount(address, parsing_1.ParsableWhirlpoolsConfigExtension, opts);
      }
      getConfigExtensions(addresses, opts) {
        return this.fetcher.getAccounts(addresses, parsing_1.ParsableWhirlpoolsConfigExtension, opts);
      }
      getTokenBadge(address, opts) {
        return this.fetcher.getAccount(address, parsing_1.ParsableTokenBadge, opts);
      }
      getTokenBadges(addresses, opts) {
        return this.fetcher.getAccounts(addresses, parsing_1.ParsableTokenBadge, opts);
      }
      getLockConfig(address, opts) {
        return this.fetcher.getAccount(address, parsing_1.ParsableLockConfig, opts);
      }
      getLockConfigs(addresses, opts) {
        return this.fetcher.getAccounts(addresses, parsing_1.ParsableLockConfig, opts);
      }
      getAdaptiveFeeTier(address, opts) {
        return this.fetcher.getAccount(address, parsing_1.ParsableAdaptiveFeeTier, opts);
      }
      getAdaptiveFeeTiers(addresses, opts) {
        return this.fetcher.getAccounts(addresses, parsing_1.ParsableAdaptiveFeeTier, opts);
      }
      getOracle(address, opts) {
        return this.fetcher.getAccount(address, parsing_1.ParsableOracle, opts);
      }
      getOracles(addresses, opts) {
        return this.fetcher.getAccounts(addresses, parsing_1.ParsableOracle, opts);
      }
      populateCache(accounts, parser, now = Date.now()) {
        this.fetcher.populateAccounts(accounts, parser, now);
      }
    };
    exports2.WhirlpoolAccountFetcher = WhirlpoolAccountFetcher;
  }
});

// node_modules/@orca-so/whirlpools-sdk/dist/network/public/fetcher/fetcher-types.js
var require_fetcher_types = __commonJS({
  "node_modules/@orca-so/whirlpools-sdk/dist/network/public/fetcher/fetcher-types.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PREFER_CACHE = exports2.IGNORE_CACHE = exports2.DEFAULT_WHIRLPOOL_RETENTION_POLICY = void 0;
    exports2.DEFAULT_WHIRLPOOL_RETENTION_POLICY = /* @__PURE__ */ new Map([]);
    exports2.IGNORE_CACHE = { maxAge: 0 };
    exports2.PREFER_CACHE = {
      maxAge: Number.POSITIVE_INFINITY
    };
  }
});

// node_modules/@orca-so/whirlpools-sdk/dist/utils/graphs/public/pool-graph-utils.js
var require_pool_graph_utils = __commonJS({
  "node_modules/@orca-so/whirlpools-sdk/dist/utils/graphs/public/pool-graph-utils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PoolGraphUtils = void 0;
    var common_sdk_1 = require_dist2();
    var PoolGraphUtils = class _PoolGraphUtils {
      static PATH_ID_DELIMITER = "-";
      static getSearchPathId(tokenA, tokenB) {
        return `${common_sdk_1.AddressUtil.toString(tokenA)}${_PoolGraphUtils.PATH_ID_DELIMITER}${common_sdk_1.AddressUtil.toString(tokenB)}`;
      }
      static deconstructPathId(pathId) {
        const split = pathId.split(_PoolGraphUtils.PATH_ID_DELIMITER);
        if (split.length !== 2) {
          throw new Error(`Invalid path id: ${pathId}`);
        }
        const [tokenA, tokenB] = split;
        return [tokenA, tokenB];
      }
    };
    exports2.PoolGraphUtils = PoolGraphUtils;
  }
});

// node_modules/@orca-so/whirlpools-sdk/dist/utils/graphs/adjacency-list-pool-graph.js
var require_adjacency_list_pool_graph = __commonJS({
  "node_modules/@orca-so/whirlpools-sdk/dist/utils/graphs/adjacency-list-pool-graph.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AdjacencyListPoolGraph = void 0;
    var common_sdk_1 = require_dist2();
    var pool_graph_utils_1 = require_pool_graph_utils();
    var AdjacencyListPoolGraph = class {
      graph;
      tokens;
      constructor(pools) {
        const [adjacencyListGraphMap, insertedTokens] = buildPoolGraph(pools);
        this.graph = adjacencyListGraphMap;
        this.tokens = Array.from(insertedTokens);
      }
      getPath(startMint, endMint, options) {
        const results = this.getPathsForPairs([[startMint, endMint]], options);
        return results[0][1];
      }
      getPathsForPairs(searchTokenPairs, options) {
        const searchTokenPairsInString = searchTokenPairs.map(([startMint, endMint]) => {
          return [
            common_sdk_1.AddressUtil.toString(startMint),
            common_sdk_1.AddressUtil.toString(endMint)
          ];
        });
        const searchTokenPairsToFind = searchTokenPairsInString.filter(([startMint, endMint]) => {
          return startMint !== endMint;
        });
        const walkMap = findWalks(searchTokenPairsToFind, this.graph, options?.intermediateTokens.map((token) => common_sdk_1.AddressUtil.toString(token)));
        const results = searchTokenPairsInString.map(([startMint, endMint]) => {
          const searchRouteId = pool_graph_utils_1.PoolGraphUtils.getSearchPathId(startMint, endMint);
          const [internalStartMint, internalEndMint] = [startMint, endMint].sort();
          const internalRouteId = getInternalRouteId(internalStartMint, internalEndMint, false);
          const reversed = internalStartMint !== startMint;
          const pathsForSearchPair = walkMap[internalRouteId];
          const paths = pathsForSearchPair ? pathsForSearchPair.map((path) => {
            return {
              startTokenMint: startMint,
              endTokenMint: endMint,
              edges: getHopsFromRoute(path, reversed)
            };
          }) : [];
          return [searchRouteId, paths];
        });
        return results;
      }
      getAllPaths(options) {
        const tokenPairCombinations = combinations2(this.tokens);
        const searchTokenPairsInString = tokenPairCombinations.map(([startMint, endMint]) => {
          return [startMint, endMint];
        });
        const searchTokenPairsToFind = searchTokenPairsInString.filter(([startMint, endMint]) => {
          return startMint !== endMint;
        });
        const walkMap = findWalks(searchTokenPairsToFind, this.graph, options?.intermediateTokens.map((token) => common_sdk_1.AddressUtil.toString(token)));
        const results = searchTokenPairsInString.reduce((acc, [startMint, endMint]) => {
          const searchRouteId = pool_graph_utils_1.PoolGraphUtils.getSearchPathId(startMint, endMint);
          if (startMint === endMint) {
            acc.push([searchRouteId, []]);
            return acc;
          }
          const [internalStartMint, internalEndMint] = [
            startMint,
            endMint
          ].sort();
          const internalRouteId = getInternalRouteId(internalStartMint, internalEndMint, false);
          const reversed = internalStartMint !== startMint;
          const pathsForSearchPair = walkMap[internalRouteId];
          const paths = pathsForSearchPair ? pathsForSearchPair.map((path) => {
            return {
              startTokenMint: startMint,
              endTokenMint: endMint,
              edges: getHopsFromRoute(path, reversed)
            };
          }) : [];
          acc.push([searchRouteId, paths]);
          const reversedSearchRouteId = pool_graph_utils_1.PoolGraphUtils.getSearchPathId(endMint, startMint);
          const reversedPaths = pathsForSearchPair ? pathsForSearchPair.map((path) => {
            return {
              startTokenMint: endMint,
              endTokenMint: startMint,
              edges: getHopsFromRoute(path, !reversed)
            };
          }) : [];
          acc.push([reversedSearchRouteId, reversedPaths]);
          return acc;
        }, []);
        return results;
      }
    };
    exports2.AdjacencyListPoolGraph = AdjacencyListPoolGraph;
    function getHopsFromRoute(path, reversed) {
      const finalRoutes = reversed ? path.slice().reverse() : path;
      return finalRoutes.map((hopStr) => {
        return { poolAddress: hopStr };
      });
    }
    function buildPoolGraph(pools) {
      const insertedPoolCache = {};
      const insertedTokens = /* @__PURE__ */ new Set();
      const poolGraphSet = pools.reduce((poolGraph, pool) => {
        const { address, tokenMintA, tokenMintB } = pool;
        const [addr, mintA, mintB] = common_sdk_1.AddressUtil.toStrings([
          address,
          tokenMintA,
          tokenMintB
        ]);
        insertedTokens.add(mintA);
        insertedTokens.add(mintB);
        if (poolGraph[mintA] === void 0) {
          poolGraph[mintA] = [];
          insertedPoolCache[mintA] = /* @__PURE__ */ new Set();
        }
        if (poolGraph[mintB] === void 0) {
          poolGraph[mintB] = [];
          insertedPoolCache[mintB] = /* @__PURE__ */ new Set();
        }
        const [insertedPoolsForA, insertedPoolsForB] = [
          insertedPoolCache[mintA],
          insertedPoolCache[mintB]
        ];
        if (!insertedPoolsForA.has(addr)) {
          poolGraph[mintA].push({ address: addr, otherToken: mintB });
          insertedPoolsForA.add(addr);
        }
        if (!insertedPoolsForB.has(addr)) {
          poolGraph[mintB].push({ address: addr, otherToken: mintA });
          insertedPoolsForB.add(addr);
        }
        return poolGraph;
      }, {});
      return [poolGraphSet, insertedTokens];
    }
    function findWalks(tokenPairs, poolGraph, intermediateTokens) {
      const walks = {};
      tokenPairs.forEach(([tokenMintFrom, tokenMintTo]) => {
        let paths = [];
        const [internalTokenMintFrom, internalTokenMintTo] = [
          tokenMintFrom,
          tokenMintTo
        ].sort();
        const internalPathId = getInternalRouteId(internalTokenMintFrom, internalTokenMintTo, false);
        const poolsForTokenFrom = poolGraph[internalTokenMintFrom] || [];
        const poolsForTokenTo = poolGraph[internalTokenMintTo] || [];
        if (!!walks[internalPathId]) {
          return;
        }
        const singleHop = poolsForTokenFrom.filter(({ address }) => poolsForTokenTo.some((p) => p.address === address)).map((op) => [op.address]);
        paths.push(...singleHop);
        const firstHop = poolsForTokenFrom.filter(({ address }) => !poolsForTokenTo.some((p) => p.address === address));
        firstHop.forEach((firstPool) => {
          const intermediateToken = firstPool.otherToken;
          if (!intermediateTokens || intermediateTokens.indexOf(intermediateToken) > -1) {
            const secondHops = poolsForTokenTo.filter((secondPool) => secondPool.otherToken === intermediateToken).map((secondPool) => [firstPool.address, secondPool.address]);
            paths.push(...secondHops);
          }
        });
        if (paths.length > 0) {
          walks[internalPathId] = paths;
        }
      });
      return walks;
    }
    function getInternalRouteId(tokenA, tokenB, sort = true) {
      const mints = [common_sdk_1.AddressUtil.toString(tokenA), common_sdk_1.AddressUtil.toString(tokenB)];
      const sortedMints = sort ? mints.sort() : mints;
      return `${sortedMints[0]}${pool_graph_utils_1.PoolGraphUtils.PATH_ID_DELIMITER}${sortedMints[1]}`;
    }
    function combinations2(array) {
      const result = [];
      for (let i = 0; i < array.length - 1; i++) {
        for (let j = i + 1; j < array.length; j++) {
          result.push([array[i], array[j]]);
        }
      }
      return result;
    }
  }
});

// node_modules/@orca-so/whirlpools-sdk/dist/utils/graphs/public/pool-graph-builder.js
var require_pool_graph_builder = __commonJS({
  "node_modules/@orca-so/whirlpools-sdk/dist/utils/graphs/public/pool-graph-builder.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PoolGraphBuilder = void 0;
    var fetcher_1 = require_fetcher2();
    var adjacency_list_pool_graph_1 = require_adjacency_list_pool_graph();
    var PoolGraphBuilder = class {
      static async buildPoolGraphWithFetch(pools, fetcher) {
        const poolAccounts = await fetcher.getPools(pools, fetcher_1.PREFER_CACHE);
        const poolTokenPairs = Array.from(poolAccounts.entries()).map(([addr, pool]) => {
          if (pool) {
            return {
              address: addr,
              tokenMintA: pool.tokenMintA,
              tokenMintB: pool.tokenMintB
            };
          }
          return null;
        }).flatMap((pool) => pool ? pool : []);
        return new adjacency_list_pool_graph_1.AdjacencyListPoolGraph(poolTokenPairs);
      }
      static buildPoolGraph(poolTokenPairs) {
        return new adjacency_list_pool_graph_1.AdjacencyListPoolGraph(poolTokenPairs);
      }
    };
    exports2.PoolGraphBuilder = PoolGraphBuilder;
  }
});

// node_modules/@orca-so/whirlpools-sdk/dist/utils/graphs/public/index.js
var require_public2 = __commonJS({
  "node_modules/@orca-so/whirlpools-sdk/dist/utils/graphs/public/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_pool_graph_builder(), exports2);
    __exportStar(require_pool_graph_utils(), exports2);
  }
});

// node_modules/@orca-so/whirlpools-sdk/dist/utils/public/ix-utils.js
var require_ix_utils = __commonJS({
  "node_modules/@orca-so/whirlpools-sdk/dist/utils/public/ix-utils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.toTx = toTx;
    var common_sdk_1 = require_dist2();
    function toTx(ctx, ix) {
      return new common_sdk_1.TransactionBuilder(ctx.provider.connection, ctx.provider.wallet, ctx.txBuilderOpts).addInstruction(ix);
    }
  }
});

// node_modules/@orca-so/whirlpools-sdk/dist/utils/public/lock-config-util.js
var require_lock_config_util = __commonJS({
  "node_modules/@orca-so/whirlpools-sdk/dist/utils/public/lock-config-util.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LockConfigUtil = void 0;
    var LockConfigUtil = class {
      static getPermanentLockType() {
        return { permanent: {} };
      }
    };
    exports2.LockConfigUtil = LockConfigUtil;
  }
});

// node_modules/@orca-so/whirlpools-sdk/dist/utils/public/tick-utils.js
var require_tick_utils = __commonJS({
  "node_modules/@orca-so/whirlpools-sdk/dist/utils/public/tick-utils.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TickArrayUtil = exports2.TickUtil = void 0;
    var common_sdk_1 = require_dist2();
    var tiny_invariant_1 = __importDefault(require_tiny_invariant_cjs());
    var public_1 = require_public();
    var pda_utils_1 = require_pda_utils();
    var TickSearchDirection;
    (function(TickSearchDirection2) {
      TickSearchDirection2[TickSearchDirection2["Left"] = 0] = "Left";
      TickSearchDirection2[TickSearchDirection2["Right"] = 1] = "Right";
    })(TickSearchDirection || (TickSearchDirection = {}));
    var TickUtil = class _TickUtil {
      static getOffsetIndex(tickIndex, arrayStartIndex, tickSpacing) {
        return Math.floor((tickIndex - arrayStartIndex) / tickSpacing);
      }
      static getStartTickIndex(tickIndex, tickSpacing, offset = 0) {
        const realIndex = Math.floor(tickIndex / tickSpacing / public_1.TICK_ARRAY_SIZE);
        const startTickIndex = (realIndex + offset) * tickSpacing * public_1.TICK_ARRAY_SIZE;
        const ticksInArray = public_1.TICK_ARRAY_SIZE * tickSpacing;
        const minTickIndex = public_1.MIN_TICK_INDEX - (public_1.MIN_TICK_INDEX % ticksInArray + ticksInArray);
        (0, tiny_invariant_1.default)(startTickIndex >= minTickIndex, `startTickIndex is too small - - ${startTickIndex}`);
        (0, tiny_invariant_1.default)(startTickIndex <= public_1.MAX_TICK_INDEX, `startTickIndex is too large - ${startTickIndex}`);
        return startTickIndex;
      }
      static getInitializableTickIndex(tickIndex, tickSpacing) {
        return tickIndex - tickIndex % tickSpacing;
      }
      static getNextInitializableTickIndex(tickIndex, tickSpacing) {
        return _TickUtil.getInitializableTickIndex(tickIndex, tickSpacing) + tickSpacing;
      }
      static getPrevInitializableTickIndex(tickIndex, tickSpacing) {
        return _TickUtil.getInitializableTickIndex(tickIndex, tickSpacing) - tickSpacing;
      }
      static findPreviousInitializedTickIndex(account, currentTickIndex, tickSpacing) {
        return _TickUtil.findInitializedTick(account, currentTickIndex, tickSpacing, TickSearchDirection.Left);
      }
      static findNextInitializedTickIndex(account, currentTickIndex, tickSpacing) {
        return _TickUtil.findInitializedTick(account, currentTickIndex, tickSpacing, TickSearchDirection.Right);
      }
      static findInitializedTick(account, currentTickIndex, tickSpacing, searchDirection) {
        const currentTickArrayIndex = tickIndexToInnerIndex(account.startTickIndex, currentTickIndex, tickSpacing);
        const increment = searchDirection === TickSearchDirection.Right ? 1 : -1;
        let stepInitializedTickArrayIndex = searchDirection === TickSearchDirection.Right ? currentTickArrayIndex + increment : currentTickArrayIndex;
        while (stepInitializedTickArrayIndex >= 0 && stepInitializedTickArrayIndex < account.ticks.length) {
          if (account.ticks[stepInitializedTickArrayIndex]?.initialized) {
            return innerIndexToTickIndex(account.startTickIndex, stepInitializedTickArrayIndex, tickSpacing);
          }
          stepInitializedTickArrayIndex += increment;
        }
        return null;
      }
      static checkTickInBounds(tick) {
        return tick <= public_1.MAX_TICK_INDEX && tick >= public_1.MIN_TICK_INDEX;
      }
      static isTickInitializable(tick, tickSpacing) {
        return tick % tickSpacing === 0;
      }
      static invertTick(tick) {
        return -tick;
      }
      static getFullRangeTickIndex(tickSpacing) {
        return [
          Math.ceil(public_1.MIN_TICK_INDEX / tickSpacing) * tickSpacing,
          Math.floor(public_1.MAX_TICK_INDEX / tickSpacing) * tickSpacing
        ];
      }
      static isFullRange(tickSpacing, tickLowerIndex, tickUpperIndex) {
        const [min2, max2] = _TickUtil.getFullRangeTickIndex(tickSpacing);
        return tickLowerIndex === min2 && tickUpperIndex === max2;
      }
      static isFullRangeOnly(tickSpacing) {
        return tickSpacing >= public_1.FULL_RANGE_ONLY_TICK_SPACING_THRESHOLD;
      }
    };
    exports2.TickUtil = TickUtil;
    var TickArrayUtil = class _TickArrayUtil {
      static getTickFromArray(tickArray, tickIndex, tickSpacing) {
        const realIndex = tickIndexToInnerIndex(tickArray.startTickIndex, tickIndex, tickSpacing);
        const tick = tickArray.ticks[realIndex];
        (0, tiny_invariant_1.default)(!!tick, `tick realIndex out of range - start - ${tickArray.startTickIndex} index - ${tickIndex}, realIndex - ${realIndex}`);
        return tick;
      }
      static getTickArrayPDAs(tick, tickSpacing, numOfTickArrays, programId, whirlpoolAddress, aToB) {
        let arrayIndexList = [...Array(numOfTickArrays).keys()];
        if (aToB) {
          arrayIndexList = arrayIndexList.map((value) => -value);
        }
        return arrayIndexList.map((value) => {
          const startTick = TickUtil.getStartTickIndex(tick, tickSpacing, value);
          return pda_utils_1.PDAUtil.getTickArray(programId, whirlpoolAddress, startTick);
        });
      }
      static async getUninitializedArraysString(tickArrayAddrs, fetcher, opts) {
        const taAddrs = common_sdk_1.AddressUtil.toPubKeys(tickArrayAddrs);
        const tickArrayData = await fetcher.getTickArrays(taAddrs, opts);
        if (tickArrayData) {
          const uninitializedIndices = _TickArrayUtil.getUninitializedArrays(tickArrayData);
          if (uninitializedIndices.length > 0) {
            const uninitializedArrays = uninitializedIndices.map((index) => taAddrs[index].toBase58()).join(", ");
            return uninitializedArrays;
          }
        }
        return null;
      }
      static async getUninitializedArraysPDAs(ticks, programId, whirlpoolAddress, tickSpacing, fetcher, opts) {
        const startTicks = ticks.map((tick) => TickUtil.getStartTickIndex(tick, tickSpacing));
        const removeDupeTicks = [...new Set(startTicks)];
        const tickArrayPDAs = removeDupeTicks.map((tick) => pda_utils_1.PDAUtil.getTickArray(programId, whirlpoolAddress, tick));
        const fetchedArrays = await fetcher.getTickArrays(tickArrayPDAs.map((pda) => pda.publicKey), opts);
        const uninitializedIndices = _TickArrayUtil.getUninitializedArrays(fetchedArrays);
        return uninitializedIndices.map((index) => {
          return {
            startIndex: removeDupeTicks[index],
            pda: tickArrayPDAs[index]
          };
        });
      }
      static getUninitializedArrays(tickArrays) {
        return tickArrays.map((value, index) => {
          if (!value) {
            return index;
          }
          return -1;
        }).filter((index) => index >= 0);
      }
    };
    exports2.TickArrayUtil = TickArrayUtil;
    function tickIndexToInnerIndex(startTickIndex, tickIndex, tickSpacing) {
      return Math.floor((tickIndex - startTickIndex) / tickSpacing);
    }
    function innerIndexToTickIndex(startTickIndex, tickArrayIndex, tickSpacing) {
      return startTickIndex + tickArrayIndex * tickSpacing;
    }
  }
});

// node_modules/@orca-so/whirlpools-sdk/dist/utils/public/price-math.js
var require_price_math = __commonJS({
  "node_modules/@orca-so/whirlpools-sdk/dist/utils/public/price-math.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PriceMath = void 0;
    var anchor_1 = require("@coral-xyz/anchor");
    var common_sdk_1 = require_dist2();
    var decimal_js_1 = __importDefault(require_decimal());
    var public_1 = require_public();
    var tick_utils_1 = require_tick_utils();
    var BIT_PRECISION = 14;
    var LOG_B_2_X32 = "59543866431248";
    var LOG_B_P_ERR_MARGIN_LOWER_X64 = "184467440737095516";
    var LOG_B_P_ERR_MARGIN_UPPER_X64 = "15793534762490258745";
    var PriceMath = class _PriceMath {
      static priceToSqrtPriceX64(price, decimalsA, decimalsB) {
        return common_sdk_1.MathUtil.toX64(price.mul(decimal_js_1.default.pow(10, decimalsB - decimalsA)).sqrt());
      }
      static sqrtPriceX64ToPrice(sqrtPriceX64, decimalsA, decimalsB) {
        return common_sdk_1.MathUtil.fromX64(sqrtPriceX64).pow(2).mul(decimal_js_1.default.pow(10, decimalsA - decimalsB));
      }
      static tickIndexToSqrtPriceX64(tickIndex) {
        if (tickIndex > 0) {
          return new anchor_1.BN(tickIndexToSqrtPricePositive(tickIndex));
        } else {
          return new anchor_1.BN(tickIndexToSqrtPriceNegative(tickIndex));
        }
      }
      static sqrtPriceX64ToTickIndex(sqrtPriceX64) {
        if (sqrtPriceX64.gt(new anchor_1.BN(public_1.MAX_SQRT_PRICE)) || sqrtPriceX64.lt(new anchor_1.BN(public_1.MIN_SQRT_PRICE))) {
          throw new Error("Provided sqrtPrice is not within the supported sqrtPrice range.");
        }
        const msb = sqrtPriceX64.bitLength() - 1;
        const adjustedMsb = new anchor_1.BN(msb - 64);
        const log2pIntegerX32 = signedShiftLeft(adjustedMsb, 32, 128);
        let bit = new anchor_1.BN("8000000000000000", "hex");
        let precision = 0;
        let log2pFractionX64 = new anchor_1.BN(0);
        let r = msb >= 64 ? sqrtPriceX64.shrn(msb - 63) : sqrtPriceX64.shln(63 - msb);
        while (bit.gt(new anchor_1.BN(0)) && precision < BIT_PRECISION) {
          r = r.mul(r);
          let rMoreThanTwo = r.shrn(127);
          r = r.shrn(63 + rMoreThanTwo.toNumber());
          log2pFractionX64 = log2pFractionX64.add(bit.mul(rMoreThanTwo));
          bit = bit.shrn(1);
          precision += 1;
        }
        const log2pFractionX32 = log2pFractionX64.shrn(32);
        const log2pX32 = log2pIntegerX32.add(log2pFractionX32);
        const logbpX64 = log2pX32.mul(new anchor_1.BN(LOG_B_2_X32));
        const tickLow = signedShiftRight(logbpX64.sub(new anchor_1.BN(LOG_B_P_ERR_MARGIN_LOWER_X64)), 64, 128).toNumber();
        const tickHigh = signedShiftRight(logbpX64.add(new anchor_1.BN(LOG_B_P_ERR_MARGIN_UPPER_X64)), 64, 128).toNumber();
        if (tickLow == tickHigh) {
          return tickLow;
        } else {
          const derivedTickHighSqrtPriceX64 = _PriceMath.tickIndexToSqrtPriceX64(tickHigh);
          if (derivedTickHighSqrtPriceX64.lte(sqrtPriceX64)) {
            return tickHigh;
          } else {
            return tickLow;
          }
        }
      }
      static tickIndexToPrice(tickIndex, decimalsA, decimalsB) {
        return _PriceMath.sqrtPriceX64ToPrice(_PriceMath.tickIndexToSqrtPriceX64(tickIndex), decimalsA, decimalsB);
      }
      static priceToTickIndex(price, decimalsA, decimalsB) {
        return _PriceMath.sqrtPriceX64ToTickIndex(_PriceMath.priceToSqrtPriceX64(price, decimalsA, decimalsB));
      }
      static priceToInitializableTickIndex(price, decimalsA, decimalsB, tickSpacing) {
        return tick_utils_1.TickUtil.getInitializableTickIndex(_PriceMath.priceToTickIndex(price, decimalsA, decimalsB), tickSpacing);
      }
      static invertPrice(price, decimalsA, decimalsB) {
        const tick = _PriceMath.priceToTickIndex(price, decimalsA, decimalsB);
        const invTick = tick_utils_1.TickUtil.invertTick(tick);
        return _PriceMath.tickIndexToPrice(invTick, decimalsB, decimalsA);
      }
      static invertSqrtPriceX64(sqrtPriceX64) {
        const tick = _PriceMath.sqrtPriceX64ToTickIndex(sqrtPriceX64);
        const invTick = tick_utils_1.TickUtil.invertTick(tick);
        return _PriceMath.tickIndexToSqrtPriceX64(invTick);
      }
      static getSlippageBoundForSqrtPrice(sqrtPriceX64, slippage) {
        const sqrtPriceX64Decimal = common_sdk_1.DecimalUtil.fromBN(sqrtPriceX64);
        const slippageNumerator = new decimal_js_1.default(slippage.numerator.toString());
        const slippageDenominator = new decimal_js_1.default(slippage.denominator.toString());
        const lowerBoundSqrtPriceDecimal = sqrtPriceX64Decimal.mul(slippageDenominator.sub(slippageNumerator).sqrt()).div(slippageDenominator.sqrt()).toDecimalPlaces(0);
        const upperBoundSqrtPriceDecimal = sqrtPriceX64Decimal.mul(slippageDenominator.add(slippageNumerator).sqrt()).div(slippageDenominator.sqrt()).toDecimalPlaces(0);
        const lowerBoundSqrtPrice = anchor_1.BN.min(anchor_1.BN.max(new anchor_1.BN(lowerBoundSqrtPriceDecimal.toFixed(0)), public_1.MIN_SQRT_PRICE_BN), public_1.MAX_SQRT_PRICE_BN);
        const upperBoundSqrtPrice = anchor_1.BN.min(anchor_1.BN.max(new anchor_1.BN(upperBoundSqrtPriceDecimal.toFixed(0)), public_1.MIN_SQRT_PRICE_BN), public_1.MAX_SQRT_PRICE_BN);
        const lowerTickCurrentIndex = _PriceMath.sqrtPriceX64ToTickIndex(lowerBoundSqrtPrice);
        const upperTickCurrentIndex = _PriceMath.sqrtPriceX64ToTickIndex(upperBoundSqrtPrice);
        return {
          lowerBound: [lowerBoundSqrtPrice, lowerTickCurrentIndex],
          upperBound: [upperBoundSqrtPrice, upperTickCurrentIndex]
        };
      }
    };
    exports2.PriceMath = PriceMath;
    function tickIndexToSqrtPricePositive(tick) {
      let ratio;
      if ((tick & 1) != 0) {
        ratio = new anchor_1.BN("79232123823359799118286999567");
      } else {
        ratio = new anchor_1.BN("79228162514264337593543950336");
      }
      if ((tick & 2) != 0) {
        ratio = signedShiftRight(ratio.mul(new anchor_1.BN("79236085330515764027303304731")), 96, 256);
      }
      if ((tick & 4) != 0) {
        ratio = signedShiftRight(ratio.mul(new anchor_1.BN("79244008939048815603706035061")), 96, 256);
      }
      if ((tick & 8) != 0) {
        ratio = signedShiftRight(ratio.mul(new anchor_1.BN("79259858533276714757314932305")), 96, 256);
      }
      if ((tick & 16) != 0) {
        ratio = signedShiftRight(ratio.mul(new anchor_1.BN("79291567232598584799939703904")), 96, 256);
      }
      if ((tick & 32) != 0) {
        ratio = signedShiftRight(ratio.mul(new anchor_1.BN("79355022692464371645785046466")), 96, 256);
      }
      if ((tick & 64) != 0) {
        ratio = signedShiftRight(ratio.mul(new anchor_1.BN("79482085999252804386437311141")), 96, 256);
      }
      if ((tick & 128) != 0) {
        ratio = signedShiftRight(ratio.mul(new anchor_1.BN("79736823300114093921829183326")), 96, 256);
      }
      if ((tick & 256) != 0) {
        ratio = signedShiftRight(ratio.mul(new anchor_1.BN("80248749790819932309965073892")), 96, 256);
      }
      if ((tick & 512) != 0) {
        ratio = signedShiftRight(ratio.mul(new anchor_1.BN("81282483887344747381513967011")), 96, 256);
      }
      if ((tick & 1024) != 0) {
        ratio = signedShiftRight(ratio.mul(new anchor_1.BN("83390072131320151908154831281")), 96, 256);
      }
      if ((tick & 2048) != 0) {
        ratio = signedShiftRight(ratio.mul(new anchor_1.BN("87770609709833776024991924138")), 96, 256);
      }
      if ((tick & 4096) != 0) {
        ratio = signedShiftRight(ratio.mul(new anchor_1.BN("97234110755111693312479820773")), 96, 256);
      }
      if ((tick & 8192) != 0) {
        ratio = signedShiftRight(ratio.mul(new anchor_1.BN("119332217159966728226237229890")), 96, 256);
      }
      if ((tick & 16384) != 0) {
        ratio = signedShiftRight(ratio.mul(new anchor_1.BN("179736315981702064433883588727")), 96, 256);
      }
      if ((tick & 32768) != 0) {
        ratio = signedShiftRight(ratio.mul(new anchor_1.BN("407748233172238350107850275304")), 96, 256);
      }
      if ((tick & 65536) != 0) {
        ratio = signedShiftRight(ratio.mul(new anchor_1.BN("2098478828474011932436660412517")), 96, 256);
      }
      if ((tick & 131072) != 0) {
        ratio = signedShiftRight(ratio.mul(new anchor_1.BN("55581415166113811149459800483533")), 96, 256);
      }
      if ((tick & 262144) != 0) {
        ratio = signedShiftRight(ratio.mul(new anchor_1.BN("38992368544603139932233054999993551")), 96, 256);
      }
      return signedShiftRight(ratio, 32, 256);
    }
    function tickIndexToSqrtPriceNegative(tickIndex) {
      let tick = Math.abs(tickIndex);
      let ratio;
      if ((tick & 1) != 0) {
        ratio = new anchor_1.BN("18445821805675392311");
      } else {
        ratio = new anchor_1.BN("18446744073709551616");
      }
      if ((tick & 2) != 0) {
        ratio = signedShiftRight(ratio.mul(new anchor_1.BN("18444899583751176498")), 64, 256);
      }
      if ((tick & 4) != 0) {
        ratio = signedShiftRight(ratio.mul(new anchor_1.BN("18443055278223354162")), 64, 256);
      }
      if ((tick & 8) != 0) {
        ratio = signedShiftRight(ratio.mul(new anchor_1.BN("18439367220385604838")), 64, 256);
      }
      if ((tick & 16) != 0) {
        ratio = signedShiftRight(ratio.mul(new anchor_1.BN("18431993317065449817")), 64, 256);
      }
      if ((tick & 32) != 0) {
        ratio = signedShiftRight(ratio.mul(new anchor_1.BN("18417254355718160513")), 64, 256);
      }
      if ((tick & 64) != 0) {
        ratio = signedShiftRight(ratio.mul(new anchor_1.BN("18387811781193591352")), 64, 256);
      }
      if ((tick & 128) != 0) {
        ratio = signedShiftRight(ratio.mul(new anchor_1.BN("18329067761203520168")), 64, 256);
      }
      if ((tick & 256) != 0) {
        ratio = signedShiftRight(ratio.mul(new anchor_1.BN("18212142134806087854")), 64, 256);
      }
      if ((tick & 512) != 0) {
        ratio = signedShiftRight(ratio.mul(new anchor_1.BN("17980523815641551639")), 64, 256);
      }
      if ((tick & 1024) != 0) {
        ratio = signedShiftRight(ratio.mul(new anchor_1.BN("17526086738831147013")), 64, 256);
      }
      if ((tick & 2048) != 0) {
        ratio = signedShiftRight(ratio.mul(new anchor_1.BN("16651378430235024244")), 64, 256);
      }
      if ((tick & 4096) != 0) {
        ratio = signedShiftRight(ratio.mul(new anchor_1.BN("15030750278693429944")), 64, 256);
      }
      if ((tick & 8192) != 0) {
        ratio = signedShiftRight(ratio.mul(new anchor_1.BN("12247334978882834399")), 64, 256);
      }
      if ((tick & 16384) != 0) {
        ratio = signedShiftRight(ratio.mul(new anchor_1.BN("8131365268884726200")), 64, 256);
      }
      if ((tick & 32768) != 0) {
        ratio = signedShiftRight(ratio.mul(new anchor_1.BN("3584323654723342297")), 64, 256);
      }
      if ((tick & 65536) != 0) {
        ratio = signedShiftRight(ratio.mul(new anchor_1.BN("696457651847595233")), 64, 256);
      }
      if ((tick & 131072) != 0) {
        ratio = signedShiftRight(ratio.mul(new anchor_1.BN("26294789957452057")), 64, 256);
      }
      if ((tick & 262144) != 0) {
        ratio = signedShiftRight(ratio.mul(new anchor_1.BN("37481735321082")), 64, 256);
      }
      return ratio;
    }
    function signedShiftLeft(n0, shiftBy, bitWidth) {
      let twosN0 = n0.toTwos(bitWidth).shln(shiftBy);
      twosN0.imaskn(bitWidth + 1);
      return twosN0.fromTwos(bitWidth);
    }
    function signedShiftRight(n0, shiftBy, bitWidth) {
      let twoN0 = n0.toTwos(bitWidth).shrn(shiftBy);
      twoN0.imaskn(bitWidth - shiftBy + 1);
      return twoN0.fromTwos(bitWidth - shiftBy);
    }
  }
});

// node_modules/@orca-so/whirlpools-sdk/dist/utils/public/pda-utils.js
var require_pda_utils = __commonJS({
  "node_modules/@orca-so/whirlpools-sdk/dist/utils/public/pda-utils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PDAUtil = void 0;
    var anchor_1 = require("@coral-xyz/anchor");
    var common_sdk_1 = require_dist2();
    var public_1 = require_public();
    var price_math_1 = require_price_math();
    var tick_utils_1 = require_tick_utils();
    var PDA_WHIRLPOOL_SEED = "whirlpool";
    var PDA_POSITION_SEED = "position";
    var PDA_METADATA_SEED = "metadata";
    var PDA_TICK_ARRAY_SEED = "tick_array";
    var PDA_FEE_TIER_SEED = "fee_tier";
    var PDA_ORACLE_SEED = "oracle";
    var PDA_POSITION_BUNDLE_SEED = "position_bundle";
    var PDA_BUNDLED_POSITION_SEED = "bundled_position";
    var PDA_CONFIG_EXTENSION_SEED = "config_extension";
    var PDA_TOKEN_BADGE_SEED = "token_badge";
    var PDA_LOCK_CONFIG_SEED = "lock_config";
    var PDAUtil2 = class _PDAUtil {
      static getWhirlpool(programId, whirlpoolsConfigKey, tokenMintAKey, tokenMintBKey, feeTierIndex) {
        return common_sdk_1.AddressUtil.findProgramAddress([
          Buffer.from(PDA_WHIRLPOOL_SEED),
          whirlpoolsConfigKey.toBuffer(),
          tokenMintAKey.toBuffer(),
          tokenMintBKey.toBuffer(),
          new anchor_1.BN(feeTierIndex).toArrayLike(Buffer, "le", 2)
        ], programId);
      }
      static getPosition(programId, positionMintKey) {
        return common_sdk_1.AddressUtil.findProgramAddress([Buffer.from(PDA_POSITION_SEED), positionMintKey.toBuffer()], programId);
      }
      static getPositionMetadata(positionMintKey) {
        return common_sdk_1.AddressUtil.findProgramAddress([
          Buffer.from(PDA_METADATA_SEED),
          public_1.METADATA_PROGRAM_ADDRESS.toBuffer(),
          positionMintKey.toBuffer()
        ], public_1.METADATA_PROGRAM_ADDRESS);
      }
      static getTickArray(programId, whirlpoolAddress, startTick) {
        return common_sdk_1.AddressUtil.findProgramAddress([
          Buffer.from(PDA_TICK_ARRAY_SEED),
          whirlpoolAddress.toBuffer(),
          Buffer.from(startTick.toString())
        ], programId);
      }
      static getTickArrayFromTickIndex(tickIndex, tickSpacing, whirlpool, programId, tickArrayOffset = 0) {
        const startIndex = tick_utils_1.TickUtil.getStartTickIndex(tickIndex, tickSpacing, tickArrayOffset);
        return _PDAUtil.getTickArray(common_sdk_1.AddressUtil.toPubKey(programId), common_sdk_1.AddressUtil.toPubKey(whirlpool), startIndex);
      }
      static getTickArrayFromSqrtPrice(sqrtPriceX64, tickSpacing, whirlpool, programId, tickArrayOffset = 0) {
        const tickIndex = price_math_1.PriceMath.sqrtPriceX64ToTickIndex(sqrtPriceX64);
        return _PDAUtil.getTickArrayFromTickIndex(tickIndex, tickSpacing, whirlpool, programId, tickArrayOffset);
      }
      static getFeeTier(programId, whirlpoolsConfigAddress, feeTierIndex) {
        return common_sdk_1.AddressUtil.findProgramAddress([
          Buffer.from(PDA_FEE_TIER_SEED),
          whirlpoolsConfigAddress.toBuffer(),
          new anchor_1.BN(feeTierIndex).toArrayLike(Buffer, "le", 2)
        ], programId);
      }
      static getOracle(programId, whirlpoolAddress) {
        return common_sdk_1.AddressUtil.findProgramAddress([Buffer.from(PDA_ORACLE_SEED), whirlpoolAddress.toBuffer()], programId);
      }
      static getBundledPosition(programId, positionBundleMintKey, bundleIndex) {
        return common_sdk_1.AddressUtil.findProgramAddress([
          Buffer.from(PDA_BUNDLED_POSITION_SEED),
          positionBundleMintKey.toBuffer(),
          Buffer.from(bundleIndex.toString())
        ], programId);
      }
      static getPositionBundle(programId, positionBundleMintKey) {
        return common_sdk_1.AddressUtil.findProgramAddress([Buffer.from(PDA_POSITION_BUNDLE_SEED), positionBundleMintKey.toBuffer()], programId);
      }
      static getPositionBundleMetadata(positionBundleMintKey) {
        return common_sdk_1.AddressUtil.findProgramAddress([
          Buffer.from(PDA_METADATA_SEED),
          public_1.METADATA_PROGRAM_ADDRESS.toBuffer(),
          positionBundleMintKey.toBuffer()
        ], public_1.METADATA_PROGRAM_ADDRESS);
      }
      static getConfigExtension(programId, whirlpoolsConfigAddress) {
        return common_sdk_1.AddressUtil.findProgramAddress([
          Buffer.from(PDA_CONFIG_EXTENSION_SEED),
          whirlpoolsConfigAddress.toBuffer()
        ], programId);
      }
      static getTokenBadge(programId, whirlpoolsConfigAddress, tokenMintKey) {
        return common_sdk_1.AddressUtil.findProgramAddress([
          Buffer.from(PDA_TOKEN_BADGE_SEED),
          whirlpoolsConfigAddress.toBuffer(),
          tokenMintKey.toBuffer()
        ], programId);
      }
      static getLockConfig(programId, positionKey) {
        return common_sdk_1.AddressUtil.findProgramAddress([Buffer.from(PDA_LOCK_CONFIG_SEED), positionKey.toBuffer()], programId);
      }
    };
    exports2.PDAUtil = PDAUtil2;
  }
});

// node_modules/@orca-so/whirlpools-sdk/dist/utils/constants.js
var require_constants4 = __commonJS({
  "node_modules/@orca-so/whirlpools-sdk/dist/utils/constants.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TOKEN_MINTS = void 0;
    exports2.TOKEN_MINTS = {
      USDC: "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v",
      SOL: "So11111111111111111111111111111111111111112",
      USDT: "Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB",
      USDH: "USDH1SM1ojwWUga67PGrgFWUHibbjqMvuMaDkRJTgkX",
      mSOL: "mSoLzYCxHdYgdzU16g5QSh3i5K3z3KZK7ytfqcJm7So",
      stSOL: "7dHbWXmci3dT8UFYWYZweBLXgycu7Y3iL6trKn1Y7ARj"
    };
  }
});

// node_modules/@orca-so/whirlpools-sdk/dist/utils/public/types.js
var require_types3 = __commonJS({
  "node_modules/@orca-so/whirlpools-sdk/dist/utils/public/types.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TokenType = exports2.SwapDirection = void 0;
    var SwapDirection;
    (function(SwapDirection2) {
      SwapDirection2["AtoB"] = "aToB";
      SwapDirection2["BtoA"] = "bToA";
    })(SwapDirection || (exports2.SwapDirection = SwapDirection = {}));
    var TokenType;
    (function(TokenType2) {
      TokenType2[TokenType2["TokenA"] = 1] = "TokenA";
      TokenType2[TokenType2["TokenB"] = 2] = "TokenB";
    })(TokenType || (exports2.TokenType = TokenType = {}));
  }
});

// node_modules/@orca-so/whirlpools-sdk/dist/utils/public/pool-utils.js
var require_pool_utils = __commonJS({
  "node_modules/@orca-so/whirlpools-sdk/dist/utils/public/pool-utils.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PoolUtil = void 0;
    exports2.toTokenAmount = toTokenAmount;
    var common_sdk_1 = require_dist2();
    var web3_js_1 = require("@solana/web3.js");
    var bn_js_1 = __importDefault(require_bn());
    var decimal_js_1 = __importDefault(require_decimal());
    var constants_1 = require_constants4();
    var price_math_1 = require_price_math();
    var types_1 = require_types3();
    var __1 = require_dist3();
    var tiny_invariant_1 = __importDefault(require_tiny_invariant_cjs());
    var spl_token_1 = require_cjs3();
    var PoolUtil = class {
      static isRewardInitialized(rewardInfo) {
        return !web3_js_1.PublicKey.default.equals(rewardInfo.mint) && !web3_js_1.PublicKey.default.equals(rewardInfo.vault);
      }
      static getTokenType(pool, mint) {
        if (pool.tokenMintA.equals(mint)) {
          return types_1.TokenType.TokenA;
        } else if (pool.tokenMintB.equals(mint)) {
          return types_1.TokenType.TokenB;
        }
        return void 0;
      }
      static getFeeRate(feeRate) {
        return common_sdk_1.Percentage.fromFraction(feeRate, 1e6);
      }
      static getProtocolFeeRate(protocolFeeRate) {
        return common_sdk_1.Percentage.fromFraction(protocolFeeRate, 1e4);
      }
      static orderMints(mintX, mintY) {
        return this.compareMints(mintX, mintY) < 0 ? [mintX, mintY] : [mintY, mintX];
      }
      static compareMints(mintX, mintY) {
        return Buffer.compare(common_sdk_1.AddressUtil.toPubKey(mintX).toBuffer(), common_sdk_1.AddressUtil.toPubKey(mintY).toBuffer());
      }
      static getTokenAmountsFromLiquidity(liquidity, currentSqrtPrice, lowerSqrtPrice, upperSqrtPrice, round_up) {
        const _liquidity = new decimal_js_1.default(liquidity.toString());
        const _currentPrice = new decimal_js_1.default(currentSqrtPrice.toString());
        const _lowerPrice = new decimal_js_1.default(lowerSqrtPrice.toString());
        const _upperPrice = new decimal_js_1.default(upperSqrtPrice.toString());
        let tokenA, tokenB;
        if (currentSqrtPrice.lt(lowerSqrtPrice)) {
          tokenA = common_sdk_1.MathUtil.toX64_Decimal(_liquidity).mul(_upperPrice.sub(_lowerPrice)).div(_lowerPrice.mul(_upperPrice));
          tokenB = new decimal_js_1.default(0);
        } else if (currentSqrtPrice.lt(upperSqrtPrice)) {
          tokenA = common_sdk_1.MathUtil.toX64_Decimal(_liquidity).mul(_upperPrice.sub(_currentPrice)).div(_currentPrice.mul(_upperPrice));
          tokenB = common_sdk_1.MathUtil.fromX64_Decimal(_liquidity.mul(_currentPrice.sub(_lowerPrice)));
        } else {
          tokenA = new decimal_js_1.default(0);
          tokenB = common_sdk_1.MathUtil.fromX64_Decimal(_liquidity.mul(_upperPrice.sub(_lowerPrice)));
        }
        if (round_up) {
          return {
            tokenA: new bn_js_1.default(tokenA.ceil().toString()),
            tokenB: new bn_js_1.default(tokenB.ceil().toString())
          };
        } else {
          return {
            tokenA: new bn_js_1.default(tokenA.floor().toString()),
            tokenB: new bn_js_1.default(tokenB.floor().toString())
          };
        }
      }
      static estimateLiquidityFromTokenAmounts(currTick, lowerTick, upperTick, tokenAmount) {
        return this.estimateMaxLiquidityFromTokenAmounts(price_math_1.PriceMath.tickIndexToSqrtPriceX64(currTick), lowerTick, upperTick, tokenAmount);
      }
      static estimateMaxLiquidityFromTokenAmounts(sqrtPriceX64, tickLowerIndex, tickUpperIndex, tokenAmount) {
        if (tickUpperIndex < tickLowerIndex) {
          throw new Error("upper tick cannot be lower than the lower tick");
        }
        const currSqrtPrice = sqrtPriceX64;
        const lowerSqrtPrice = price_math_1.PriceMath.tickIndexToSqrtPriceX64(tickLowerIndex);
        const upperSqrtPrice = price_math_1.PriceMath.tickIndexToSqrtPriceX64(tickUpperIndex);
        if (currSqrtPrice.gte(upperSqrtPrice)) {
          return estLiquidityForTokenB(upperSqrtPrice, lowerSqrtPrice, tokenAmount.tokenB);
        } else if (currSqrtPrice.lt(lowerSqrtPrice)) {
          return estLiquidityForTokenA(lowerSqrtPrice, upperSqrtPrice, tokenAmount.tokenA);
        } else {
          const estLiquidityAmountA = estLiquidityForTokenA(currSqrtPrice, upperSqrtPrice, tokenAmount.tokenA);
          const estLiquidityAmountB = estLiquidityForTokenB(currSqrtPrice, lowerSqrtPrice, tokenAmount.tokenB);
          return bn_js_1.default.min(estLiquidityAmountA, estLiquidityAmountB);
        }
      }
      static toBaseQuoteOrder(tokenMintAKey, tokenMintBKey) {
        const pair = [tokenMintAKey, tokenMintBKey];
        return pair.sort(sortByQuotePriority);
      }
      static async isSupportedToken(ctx, whirlpoolsConfig, tokenMintKey) {
        const mintWithTokenProgram = await ctx.fetcher.getMintInfo(tokenMintKey);
        (0, tiny_invariant_1.default)(mintWithTokenProgram, "Mint not found");
        if (mintWithTokenProgram.tokenProgram.equals(spl_token_1.TOKEN_PROGRAM_ID)) {
          return true;
        }
        if (mintWithTokenProgram.address.equals(spl_token_1.NATIVE_MINT_2022)) {
          return false;
        }
        const tokenBadgePda = __1.PDAUtil.getTokenBadge(ctx.program.programId, whirlpoolsConfig, tokenMintKey);
        const tokenBadge = await ctx.fetcher.getTokenBadge(tokenBadgePda.publicKey);
        const isTokenBadgeInitialized = tokenBadge !== null;
        if (mintWithTokenProgram.freezeAuthority !== null && !isTokenBadgeInitialized) {
          return false;
        }
        const EXTENSION_TYPE_CONFIDENTIAL_TRANSFER_FEE_CONFIG = 16;
        const extensions = (0, spl_token_1.getExtensionTypes)(mintWithTokenProgram.tlvData);
        for (const extension of extensions) {
          switch (extension) {
            case spl_token_1.ExtensionType.TransferFeeConfig:
            case spl_token_1.ExtensionType.InterestBearingConfig:
            case spl_token_1.ExtensionType.TokenMetadata:
            case spl_token_1.ExtensionType.MetadataPointer:
            case spl_token_1.ExtensionType.ConfidentialTransferMint:
            case EXTENSION_TYPE_CONFIDENTIAL_TRANSFER_FEE_CONFIG:
              continue;
            case spl_token_1.ExtensionType.PermanentDelegate:
            case spl_token_1.ExtensionType.TransferHook:
            case spl_token_1.ExtensionType.MintCloseAuthority:
              if (!isTokenBadgeInitialized) {
                return false;
              }
              continue;
            case spl_token_1.ExtensionType.DefaultAccountState:
              if (!isTokenBadgeInitialized) {
                return false;
              }
              const defaultAccountState = (0, spl_token_1.getDefaultAccountState)(mintWithTokenProgram);
              if (defaultAccountState.state !== spl_token_1.AccountState.Initialized) {
                return false;
              }
              continue;
            case spl_token_1.ExtensionType.NonTransferable:
              return false;
            default:
              return false;
          }
        }
        return true;
      }
    };
    exports2.PoolUtil = PoolUtil;
    function toTokenAmount(a, b) {
      return {
        tokenA: new bn_js_1.default(a.toString()),
        tokenB: new bn_js_1.default(b.toString())
      };
    }
    var QUOTE_TOKENS = {
      [constants_1.TOKEN_MINTS["USDT"]]: 100,
      [constants_1.TOKEN_MINTS["USDC"]]: 90,
      [constants_1.TOKEN_MINTS["USDH"]]: 80,
      [constants_1.TOKEN_MINTS["SOL"]]: 70,
      [constants_1.TOKEN_MINTS["mSOL"]]: 60,
      [constants_1.TOKEN_MINTS["stSOL"]]: 50
    };
    var DEFAULT_QUOTE_PRIORITY = 0;
    function getQuoteTokenPriority(mint) {
      const value = QUOTE_TOKENS[mint];
      if (value) {
        return value;
      }
      return DEFAULT_QUOTE_PRIORITY;
    }
    function sortByQuotePriority(mintLeft, mintRight) {
      return getQuoteTokenPriority(mintLeft.toString()) - getQuoteTokenPriority(mintRight.toString());
    }
    function estLiquidityForTokenA(sqrtPrice1, sqrtPrice2, tokenAmount) {
      const lowerSqrtPriceX64 = bn_js_1.default.min(sqrtPrice1, sqrtPrice2);
      const upperSqrtPriceX64 = bn_js_1.default.max(sqrtPrice1, sqrtPrice2);
      const num = common_sdk_1.MathUtil.fromX64_BN(tokenAmount.mul(upperSqrtPriceX64).mul(lowerSqrtPriceX64));
      const dem = upperSqrtPriceX64.sub(lowerSqrtPriceX64);
      return num.div(dem);
    }
    function estLiquidityForTokenB(sqrtPrice1, sqrtPrice2, tokenAmount) {
      const lowerSqrtPriceX64 = bn_js_1.default.min(sqrtPrice1, sqrtPrice2);
      const upperSqrtPriceX64 = bn_js_1.default.max(sqrtPrice1, sqrtPrice2);
      const delta = upperSqrtPriceX64.sub(lowerSqrtPriceX64);
      return tokenAmount.shln(64).div(delta);
    }
  }
});

// node_modules/@orca-so/whirlpools-sdk/dist/utils/public/position-bundle-util.js
var require_position_bundle_util = __commonJS({
  "node_modules/@orca-so/whirlpools-sdk/dist/utils/public/position-bundle-util.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PositionBundleUtil = void 0;
    var tiny_invariant_1 = __importDefault(require_tiny_invariant_cjs());
    var public_1 = require_public();
    var PositionBundleUtil = class _PositionBundleUtil {
      static checkBundleIndexInBounds(bundleIndex) {
        return bundleIndex >= 0 && bundleIndex < public_1.POSITION_BUNDLE_SIZE;
      }
      static isOccupied(positionBundle, bundleIndex) {
        (0, tiny_invariant_1.default)(_PositionBundleUtil.checkBundleIndexInBounds(bundleIndex), "bundleIndex out of range");
        const array = _PositionBundleUtil.convertBitmapToArray(positionBundle);
        return array[bundleIndex];
      }
      static isUnoccupied(positionBundle, bundleIndex) {
        return !_PositionBundleUtil.isOccupied(positionBundle, bundleIndex);
      }
      static isFull(positionBundle) {
        const unoccupied = _PositionBundleUtil.getUnoccupiedBundleIndexes(positionBundle);
        return unoccupied.length === 0;
      }
      static isEmpty(positionBundle) {
        const occupied = _PositionBundleUtil.getOccupiedBundleIndexes(positionBundle);
        return occupied.length === 0;
      }
      static getOccupiedBundleIndexes(positionBundle) {
        const result = [];
        _PositionBundleUtil.convertBitmapToArray(positionBundle).forEach((occupied, index) => {
          if (occupied) {
            result.push(index);
          }
        });
        return result;
      }
      static getUnoccupiedBundleIndexes(positionBundle) {
        const result = [];
        _PositionBundleUtil.convertBitmapToArray(positionBundle).forEach((occupied, index) => {
          if (!occupied) {
            result.push(index);
          }
        });
        return result;
      }
      static findUnoccupiedBundleIndex(positionBundle) {
        const unoccupied = _PositionBundleUtil.getUnoccupiedBundleIndexes(positionBundle);
        return unoccupied.length === 0 ? null : unoccupied[0];
      }
      static convertBitmapToArray(positionBundle) {
        const result = [];
        positionBundle.positionBitmap.map((bitmap) => {
          for (let offset = 0; offset < 8; offset++) {
            result.push((bitmap & 1 << offset) !== 0);
          }
        });
        return result;
      }
    };
    exports2.PositionBundleUtil = PositionBundleUtil;
  }
});

// node_modules/@orca-so/whirlpools-sdk/dist/errors/errors.js
var require_errors3 = __commonJS({
  "node_modules/@orca-so/whirlpools-sdk/dist/errors/errors.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.WhirlpoolsError = exports2.RouteQueryErrorCode = exports2.SwapErrorCode = exports2.TokenErrorCode = exports2.MathErrorCode = void 0;
    var MathErrorCode;
    (function(MathErrorCode2) {
      MathErrorCode2["MultiplicationOverflow"] = "MultiplicationOverflow";
      MathErrorCode2["MulDivOverflow"] = "MulDivOverflow";
      MathErrorCode2["MultiplicationShiftRightOverflow"] = "MultiplicationShiftRightOverflow";
      MathErrorCode2["DivideByZero"] = "DivideByZero";
    })(MathErrorCode || (exports2.MathErrorCode = MathErrorCode = {}));
    var TokenErrorCode;
    (function(TokenErrorCode2) {
      TokenErrorCode2["TokenMaxExceeded"] = "TokenMaxExceeded";
      TokenErrorCode2["TokenMinSubceeded"] = "TokenMinSubceeded";
    })(TokenErrorCode || (exports2.TokenErrorCode = TokenErrorCode = {}));
    var SwapErrorCode;
    (function(SwapErrorCode2) {
      SwapErrorCode2["InvalidDevFeePercentage"] = "InvalidDevFeePercentage";
      SwapErrorCode2["InvalidSqrtPriceLimitDirection"] = "InvalidSqrtPriceLimitDirection";
      SwapErrorCode2["SqrtPriceOutOfBounds"] = "SqrtPriceOutOfBounds";
      SwapErrorCode2["ZeroTradableAmount"] = "ZeroTradableAmount";
      SwapErrorCode2["AmountOutBelowMinimum"] = "AmountOutBelowMinimum";
      SwapErrorCode2["AmountInAboveMaximum"] = "AmountInAboveMaximum";
      SwapErrorCode2["TickArrayCrossingAboveMax"] = "TickArrayCrossingAboveMax";
      SwapErrorCode2["TickArrayIndexNotInitialized"] = "TickArrayIndexNotInitialized";
      SwapErrorCode2["TickArraySequenceInvalid"] = "TickArraySequenceInvalid";
      SwapErrorCode2["AmountRemainingOverflow"] = "AmountRemainingOverflow";
      SwapErrorCode2["AmountCalcOverflow"] = "AmountCalcOverflow";
    })(SwapErrorCode || (exports2.SwapErrorCode = SwapErrorCode = {}));
    var RouteQueryErrorCode;
    (function(RouteQueryErrorCode2) {
      RouteQueryErrorCode2["RouteDoesNotExist"] = "RouteDoesNotExist";
      RouteQueryErrorCode2["TradeAmountTooHigh"] = "TradeAmountTooHigh";
      RouteQueryErrorCode2["ZeroInputAmount"] = "ZeroInputAmount";
      RouteQueryErrorCode2["General"] = "General";
    })(RouteQueryErrorCode || (exports2.RouteQueryErrorCode = RouteQueryErrorCode = {}));
    var WhirlpoolsError = class _WhirlpoolsError extends Error {
      message;
      errorCode;
      constructor(message, errorCode, stack) {
        super(message);
        this.message = message;
        this.errorCode = errorCode;
        this.stack = stack;
      }
      static isWhirlpoolsErrorCode(e, code) {
        return e instanceof _WhirlpoolsError && e.errorCode === code;
      }
    };
    exports2.WhirlpoolsError = WhirlpoolsError;
  }
});

// node_modules/@orca-so/whirlpools-sdk/dist/utils/math/bit-math.js
var require_bit_math = __commonJS({
  "node_modules/@orca-so/whirlpools-sdk/dist/utils/math/bit-math.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.BitMath = void 0;
    var anchor_1 = require("@coral-xyz/anchor");
    var common_sdk_1 = require_dist2();
    var errors_1 = require_errors3();
    var BitMath = class {
      static mul(n0, n1, limit) {
        const result = n0.mul(n1);
        if (this.isOverLimit(result, limit)) {
          throw new errors_1.WhirlpoolsError(`Mul result higher than u${limit}`, errors_1.MathErrorCode.MultiplicationOverflow);
        }
        return result;
      }
      static mulDiv(n0, n1, d, limit) {
        return this.mulDivRoundUpIf(n0, n1, d, false, limit);
      }
      static mulDivRoundUp(n0, n1, d, limit) {
        return this.mulDivRoundUpIf(n0, n1, d, true, limit);
      }
      static mulDivRoundUpIf(n0, n1, d, roundUp, limit) {
        if (d.eq(common_sdk_1.ZERO)) {
          throw new errors_1.WhirlpoolsError("mulDiv denominator is zero", errors_1.MathErrorCode.DivideByZero);
        }
        const p = this.mul(n0, n1, limit);
        const n = p.div(d);
        return roundUp && p.mod(d).gt(common_sdk_1.ZERO) ? n.add(common_sdk_1.ONE) : n;
      }
      static checked_mul_shift_right(n0, n1, limit) {
        return this.checked_mul_shift_right_round_up_if(n0, n1, false, limit);
      }
      static checked_mul_shift_right_round_up_if(n0, n1, roundUp, limit) {
        if (n0.eq(common_sdk_1.ZERO) || n1.eq(common_sdk_1.ZERO)) {
          return common_sdk_1.ZERO;
        }
        const p = this.mul(n0, n1, limit);
        if (this.isOverLimit(p, limit)) {
          throw new errors_1.WhirlpoolsError(`MulShiftRight overflowed u${limit}.`, errors_1.MathErrorCode.MultiplicationShiftRightOverflow);
        }
        const result = common_sdk_1.MathUtil.fromX64_BN(p);
        const shouldRound = roundUp && p.and(common_sdk_1.U64_MAX).gt(common_sdk_1.ZERO);
        if (shouldRound && result.eq(common_sdk_1.U64_MAX)) {
          throw new errors_1.WhirlpoolsError(`MulShiftRight overflowed u${limit}.`, errors_1.MathErrorCode.MultiplicationOverflow);
        }
        return shouldRound ? result.add(common_sdk_1.ONE) : result;
      }
      static isOverLimit(n0, limit) {
        const limitBN = common_sdk_1.TWO.pow(new anchor_1.BN(limit)).sub(common_sdk_1.ONE);
        return n0.gt(limitBN);
      }
      static divRoundUp(n, d) {
        return this.divRoundUpIf(n, d, true);
      }
      static divRoundUpIf(n, d, roundUp) {
        if (d.eq(common_sdk_1.ZERO)) {
          throw new errors_1.WhirlpoolsError("divRoundUpIf - divide by zero", errors_1.MathErrorCode.DivideByZero);
        }
        let q = n.div(d);
        return roundUp && n.mod(d).gt(common_sdk_1.ZERO) ? q.add(common_sdk_1.ONE) : q;
      }
    };
    exports2.BitMath = BitMath;
  }
});

// node_modules/@orca-so/whirlpools-sdk/dist/utils/math/token-math.js
var require_token_math = __commonJS({
  "node_modules/@orca-so/whirlpools-sdk/dist/utils/math/token-math.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AmountDeltaU64 = void 0;
    exports2.getAmountDeltaA = getAmountDeltaA;
    exports2.tryGetAmountDeltaA = tryGetAmountDeltaA;
    exports2.getAmountDeltaB = getAmountDeltaB;
    exports2.tryGetAmountDeltaB = tryGetAmountDeltaB;
    exports2.getNextSqrtPrice = getNextSqrtPrice;
    exports2.adjustForSlippage = adjustForSlippage;
    var common_sdk_1 = require_dist2();
    var bn_js_1 = __importDefault(require_bn());
    var errors_1 = require_errors3();
    var public_1 = require_public();
    var bit_math_1 = require_bit_math();
    var tiny_invariant_1 = __importDefault(require_tiny_invariant_cjs());
    var AmountDeltaU64 = class _AmountDeltaU64 {
      inner;
      constructor(inner) {
        this.inner = inner;
      }
      static fromValid(value) {
        return new _AmountDeltaU64({
          type: "Valid",
          value
        });
      }
      static fromExceedsMax(error) {
        return new _AmountDeltaU64({
          type: "ExceedsMax",
          error
        });
      }
      lte(other) {
        if (this.inner.type === "ExceedsMax") {
          return false;
        }
        return this.inner.value.lte(other);
      }
      exceedsMax() {
        return this.inner.type === "ExceedsMax";
      }
      value() {
        (0, tiny_invariant_1.default)(this.inner.type === "Valid", "Expected valid AmountDeltaU64");
        return this.inner.value;
      }
      unwrap() {
        if (this.inner.type === "Valid") {
          return this.inner.value;
        } else {
          throw this.inner.error;
        }
      }
    };
    exports2.AmountDeltaU64 = AmountDeltaU64;
    function getAmountDeltaA(currSqrtPrice, targetSqrtPrice, currLiquidity, roundUp) {
      return tryGetAmountDeltaA(currSqrtPrice, targetSqrtPrice, currLiquidity, roundUp).unwrap();
    }
    function tryGetAmountDeltaA(currSqrtPrice, targetSqrtPrice, currLiquidity, roundUp) {
      let [sqrtPriceLower, sqrtPriceUpper] = toIncreasingPriceOrder(currSqrtPrice, targetSqrtPrice);
      let sqrtPriceDiff = sqrtPriceUpper.sub(sqrtPriceLower);
      let numerator = currLiquidity.mul(sqrtPriceDiff).shln(64);
      let denominator = sqrtPriceLower.mul(sqrtPriceUpper);
      let quotient = numerator.div(denominator);
      let remainder = numerator.mod(denominator);
      let result = roundUp && !remainder.eq(common_sdk_1.ZERO) ? quotient.add(new bn_js_1.default(1)) : quotient;
      if (result.gt(common_sdk_1.U64_MAX)) {
        return AmountDeltaU64.fromExceedsMax(new errors_1.WhirlpoolsError("Results larger than U64", errors_1.TokenErrorCode.TokenMaxExceeded));
      }
      return AmountDeltaU64.fromValid(result);
    }
    function getAmountDeltaB(currSqrtPrice, targetSqrtPrice, currLiquidity, roundUp) {
      return tryGetAmountDeltaB(currSqrtPrice, targetSqrtPrice, currLiquidity, roundUp).unwrap();
    }
    function tryGetAmountDeltaB(currSqrtPrice, targetSqrtPrice, currLiquidity, roundUp) {
      let [sqrtPriceLower, sqrtPriceUpper] = toIncreasingPriceOrder(currSqrtPrice, targetSqrtPrice);
      const n0 = currLiquidity;
      const n1 = sqrtPriceUpper.sub(sqrtPriceLower);
      const limit = 128;
      if (n0.eq(common_sdk_1.ZERO) || n1.eq(common_sdk_1.ZERO)) {
        return AmountDeltaU64.fromValid(common_sdk_1.ZERO);
      }
      const p = bit_math_1.BitMath.mul(n0, n1, limit * 2);
      if (bit_math_1.BitMath.isOverLimit(p, limit)) {
        return AmountDeltaU64.fromExceedsMax(new errors_1.WhirlpoolsError(`MulShiftRight overflowed u${limit}.`, errors_1.MathErrorCode.MultiplicationShiftRightOverflow));
      }
      const result = common_sdk_1.MathUtil.fromX64_BN(p);
      const shouldRound = roundUp && p.and(common_sdk_1.U64_MAX).gt(common_sdk_1.ZERO);
      if (shouldRound && result.eq(common_sdk_1.U64_MAX)) {
        return AmountDeltaU64.fromExceedsMax(new errors_1.WhirlpoolsError(`MulShiftRight overflowed u${limit}.`, errors_1.MathErrorCode.MultiplicationOverflow));
      }
      return AmountDeltaU64.fromValid(shouldRound ? result.add(common_sdk_1.ONE) : result);
    }
    function getNextSqrtPrice(sqrtPrice, currLiquidity, amount, amountSpecifiedIsInput, aToB) {
      if (amountSpecifiedIsInput === aToB) {
        return getNextSqrtPriceFromARoundUp(sqrtPrice, currLiquidity, amount, amountSpecifiedIsInput);
      } else {
        return getNextSqrtPriceFromBRoundDown(sqrtPrice, currLiquidity, amount, amountSpecifiedIsInput);
      }
    }
    function adjustForSlippage(n, { numerator, denominator }, adjustUp) {
      if (adjustUp) {
        return n.mul(denominator.add(numerator)).div(denominator);
      } else {
        return n.mul(denominator).div(denominator.add(numerator));
      }
    }
    function toIncreasingPriceOrder(sqrtPrice0, sqrtPrice1) {
      if (sqrtPrice0.gt(sqrtPrice1)) {
        return [sqrtPrice1, sqrtPrice0];
      } else {
        return [sqrtPrice0, sqrtPrice1];
      }
    }
    function getNextSqrtPriceFromARoundUp(sqrtPrice, currLiquidity, amount, amountSpecifiedIsInput) {
      if (amount.eq(common_sdk_1.ZERO)) {
        return sqrtPrice;
      }
      let p = bit_math_1.BitMath.mul(sqrtPrice, amount, 256);
      let numerator = bit_math_1.BitMath.mul(currLiquidity, sqrtPrice, 256).shln(64);
      if (bit_math_1.BitMath.isOverLimit(numerator, 256)) {
        throw new errors_1.WhirlpoolsError("getNextSqrtPriceFromARoundUp - numerator overflow u256", errors_1.MathErrorCode.MultiplicationOverflow);
      }
      let currLiquidityShiftLeft = currLiquidity.shln(64);
      if (!amountSpecifiedIsInput && currLiquidityShiftLeft.lte(p)) {
        throw new errors_1.WhirlpoolsError("getNextSqrtPriceFromARoundUp - Unable to divide currLiquidityX64 by product", errors_1.MathErrorCode.DivideByZero);
      }
      let denominator = amountSpecifiedIsInput ? currLiquidityShiftLeft.add(p) : currLiquidityShiftLeft.sub(p);
      let price = bit_math_1.BitMath.divRoundUp(numerator, denominator);
      if (price.lt(new bn_js_1.default(public_1.MIN_SQRT_PRICE))) {
        throw new errors_1.WhirlpoolsError("getNextSqrtPriceFromARoundUp - price less than min sqrt price", errors_1.TokenErrorCode.TokenMinSubceeded);
      } else if (price.gt(new bn_js_1.default(public_1.MAX_SQRT_PRICE))) {
        throw new errors_1.WhirlpoolsError("getNextSqrtPriceFromARoundUp - price less than max sqrt price", errors_1.TokenErrorCode.TokenMaxExceeded);
      }
      return price;
    }
    function getNextSqrtPriceFromBRoundDown(sqrtPrice, currLiquidity, amount, amountSpecifiedIsInput) {
      let amountX64 = amount.shln(64);
      let delta = bit_math_1.BitMath.divRoundUpIf(amountX64, currLiquidity, !amountSpecifiedIsInput);
      if (amountSpecifiedIsInput) {
        sqrtPrice = sqrtPrice.add(delta);
      } else {
        sqrtPrice = sqrtPrice.sub(delta);
      }
      return sqrtPrice;
    }
  }
});

// node_modules/@orca-so/whirlpools-sdk/dist/utils/swap-utils.js
var require_swap_utils = __commonJS({
  "node_modules/@orca-so/whirlpools-sdk/dist/utils/swap-utils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ZEROED_TICKS = exports2.ZEROED_TICK_DATA = void 0;
    exports2.getLowerSqrtPriceFromTokenA = getLowerSqrtPriceFromTokenA;
    exports2.getUpperSqrtPriceFromTokenA = getUpperSqrtPriceFromTokenA;
    exports2.getLowerSqrtPriceFromTokenB = getLowerSqrtPriceFromTokenB;
    exports2.getUpperSqrtPriceFromTokenB = getUpperSqrtPriceFromTokenB;
    exports2.getTickArrayPublicKeysWithStartTickIndex = getTickArrayPublicKeysWithStartTickIndex;
    exports2.buildZeroedTickArray = buildZeroedTickArray;
    var common_sdk_1 = require_dist2();
    var public_1 = require_public();
    var public_2 = require_public3();
    function getLowerSqrtPriceFromTokenA(amount, liquidity, sqrtPriceX64) {
      const numerator = liquidity.mul(sqrtPriceX64).shln(64);
      const denominator = liquidity.shln(64).add(amount.mul(sqrtPriceX64));
      return common_sdk_1.MathUtil.divRoundUp(numerator, denominator);
    }
    function getUpperSqrtPriceFromTokenA(amount, liquidity, sqrtPriceX64) {
      const numerator = liquidity.mul(sqrtPriceX64).shln(64);
      const denominator = liquidity.shln(64).sub(amount.mul(sqrtPriceX64));
      return common_sdk_1.MathUtil.divRoundUp(numerator, denominator);
    }
    function getLowerSqrtPriceFromTokenB(amount, liquidity, sqrtPriceX64) {
      return sqrtPriceX64.sub(common_sdk_1.MathUtil.divRoundUp(amount.shln(64), liquidity));
    }
    function getUpperSqrtPriceFromTokenB(amount, liquidity, sqrtPriceX64) {
      return sqrtPriceX64.add(amount.shln(64).div(liquidity));
    }
    function getTickArrayPublicKeysWithStartTickIndex(tickCurrentIndex, tickSpacing, aToB, programId, whirlpoolAddress) {
      const shift = aToB ? 0 : tickSpacing;
      let offset = 0;
      let tickArrayAddresses = [];
      for (let i = 0; i < public_1.MAX_SWAP_TICK_ARRAYS; i++) {
        let startIndex;
        try {
          startIndex = public_2.TickUtil.getStartTickIndex(tickCurrentIndex + shift, tickSpacing, offset);
        } catch {
          return tickArrayAddresses;
        }
        const pda = public_2.PDAUtil.getTickArray(programId, whirlpoolAddress, startIndex);
        tickArrayAddresses.push({
          pubkey: pda.publicKey,
          startTickIndex: startIndex
        });
        offset = aToB ? offset - 1 : offset + 1;
      }
      return tickArrayAddresses;
    }
    exports2.ZEROED_TICK_DATA = Object.freeze({
      initialized: false,
      liquidityNet: common_sdk_1.ZERO,
      liquidityGross: common_sdk_1.ZERO,
      feeGrowthOutsideA: common_sdk_1.ZERO,
      feeGrowthOutsideB: common_sdk_1.ZERO,
      rewardGrowthsOutside: [common_sdk_1.ZERO, common_sdk_1.ZERO, common_sdk_1.ZERO]
    });
    exports2.ZEROED_TICKS = Array.from({ length: public_1.TICK_ARRAY_SIZE }, () => exports2.ZEROED_TICK_DATA);
    function buildZeroedTickArray(whirlpool, startTickIndex) {
      return {
        startTickIndex,
        ticks: exports2.ZEROED_TICKS,
        whirlpool
      };
    }
  }
});

// node_modules/@orca-so/whirlpools-sdk/dist/utils/public/swap-utils.js
var require_swap_utils2 = __commonJS({
  "node_modules/@orca-so/whirlpools-sdk/dist/utils/public/swap-utils.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SwapUtils = void 0;
    var common_sdk_1 = require_dist2();
    var bn_js_1 = __importDefault(require_bn());
    var __1 = require_dist3();
    var public_1 = require_public();
    var token_math_1 = require_token_math();
    var pda_utils_1 = require_pda_utils();
    var pool_utils_1 = require_pool_utils();
    var types_1 = require_types3();
    var swap_utils_1 = require_swap_utils();
    var SwapUtils2 = class {
      static getDefaultSqrtPriceLimit(aToB) {
        return new bn_js_1.default(aToB ? public_1.MIN_SQRT_PRICE : public_1.MAX_SQRT_PRICE);
      }
      static getDefaultOtherAmountThreshold(amountSpecifiedIsInput) {
        return amountSpecifiedIsInput ? common_sdk_1.ZERO : common_sdk_1.U64_MAX;
      }
      static getSwapDirection(pool, swapTokenMint, swapTokenIsInput) {
        const tokenType = pool_utils_1.PoolUtil.getTokenType(pool, swapTokenMint);
        if (!tokenType) {
          return void 0;
        }
        return tokenType === types_1.TokenType.TokenA === swapTokenIsInput ? types_1.SwapDirection.AtoB : types_1.SwapDirection.BtoA;
      }
      static getTickArrayPublicKeys(tickCurrentIndex, tickSpacing, aToB, programId, whirlpoolAddress) {
        return (0, swap_utils_1.getTickArrayPublicKeysWithStartTickIndex)(tickCurrentIndex, tickSpacing, aToB, programId, whirlpoolAddress).map((p) => p.pubkey);
      }
      static getFallbackTickArrayPublicKey(tickArrays, tickSpacing, aToB, programId, whirlpoolAddress) {
        try {
          const fallbackStartTickIndex = __1.TickUtil.getStartTickIndex(tickArrays[0].startTickIndex, tickSpacing, aToB ? 1 : -1);
          const pda = pda_utils_1.PDAUtil.getTickArray(programId, whirlpoolAddress, fallbackStartTickIndex);
          return pda.publicKey;
        } catch {
          return void 0;
        }
      }
      static async getTickArrays(tickCurrentIndex, tickSpacing, aToB, programId, whirlpoolAddress, fetcher, opts) {
        const data = await this.getBatchTickArrays(programId, fetcher, [{ tickCurrentIndex, tickSpacing, aToB, whirlpoolAddress }], opts);
        return data[0];
      }
      static async getBatchTickArrays(programId, fetcher, tickArrayRequests, opts) {
        let addresses = [];
        let requestToIndices = [];
        for (let i = 0; i < tickArrayRequests.length; i++) {
          const { tickCurrentIndex, tickSpacing, aToB, whirlpoolAddress } = tickArrayRequests[i];
          const requestAddresses = (0, swap_utils_1.getTickArrayPublicKeysWithStartTickIndex)(tickCurrentIndex, tickSpacing, aToB, programId, whirlpoolAddress);
          requestToIndices.push([
            addresses.length,
            addresses.length + requestAddresses.length
          ]);
          addresses.push(...requestAddresses);
        }
        const data = await fetcher.getTickArrays(addresses.map((a) => a.pubkey), opts);
        return requestToIndices.map((indices) => {
          const [start, end] = indices;
          const addressSlice = addresses.slice(start, end);
          const dataSlice = data.slice(start, end);
          return addressSlice.map((addr, index) => ({
            address: addr.pubkey,
            startTickIndex: addr.startTickIndex,
            data: dataSlice[index]
          }));
        });
      }
      static interpolateUninitializedTickArrays(whirlpoolAddress, tickArrays) {
        return tickArrays.map((tickArray) => ({
          address: tickArray.address,
          startTickIndex: tickArray.startTickIndex,
          data: tickArray.data ?? (0, swap_utils_1.buildZeroedTickArray)(whirlpoolAddress, tickArray.startTickIndex)
        }));
      }
      static calculateSwapAmountsFromQuote(amount, estAmountIn, estAmountOut, slippageTolerance, amountSpecifiedIsInput) {
        if (amountSpecifiedIsInput) {
          return {
            amount,
            otherAmountThreshold: (0, token_math_1.adjustForSlippage)(estAmountOut, slippageTolerance, false)
          };
        } else {
          return {
            amount,
            otherAmountThreshold: (0, token_math_1.adjustForSlippage)(estAmountIn, slippageTolerance, true)
          };
        }
      }
      static getSwapParamsFromQuote(quote, ctx, whirlpool, inputTokenAssociatedAddress, outputTokenAssociatedAddress, wallet) {
        const data = whirlpool.getData();
        return this.getSwapParamsFromQuoteKeys(quote, ctx, whirlpool.getAddress(), data.tokenVaultA, data.tokenVaultB, inputTokenAssociatedAddress, outputTokenAssociatedAddress, wallet);
      }
      static getSwapParamsFromQuoteKeys(quote, ctx, whirlpool, tokenVaultA, tokenVaultB, inputTokenAssociatedAddress, outputTokenAssociatedAddress, wallet) {
        const aToB = quote.aToB;
        const [inputTokenATA, outputTokenATA] = common_sdk_1.AddressUtil.toPubKeys([
          inputTokenAssociatedAddress,
          outputTokenAssociatedAddress
        ]);
        const oraclePda = pda_utils_1.PDAUtil.getOracle(ctx.program.programId, whirlpool);
        const params = {
          whirlpool,
          tokenOwnerAccountA: aToB ? inputTokenATA : outputTokenATA,
          tokenOwnerAccountB: aToB ? outputTokenATA : inputTokenATA,
          tokenVaultA,
          tokenVaultB,
          oracle: oraclePda.publicKey,
          tokenAuthority: wallet,
          ...quote
        };
        return params;
      }
    };
    exports2.SwapUtils = SwapUtils2;
  }
});

// node_modules/@orca-so/whirlpools-sdk/dist/utils/public/token-extension-util.js
var require_token_extension_util = __commonJS({
  "node_modules/@orca-so/whirlpools-sdk/dist/utils/public/token-extension-util.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TokenExtensionUtil = exports2.NO_TOKEN_EXTENSION_CONTEXT = void 0;
    var spl_token_1 = require_cjs3();
    var bn_js_1 = __importDefault(require_bn());
    var common_sdk_1 = require_dist2();
    var __1 = require_dist3();
    var web3_js_1 = require("@solana/web3.js");
    var defaultTokenMintWithProgram = {
      address: web3_js_1.PublicKey.default,
      decimals: 0,
      freezeAuthority: null,
      mintAuthority: null,
      isInitialized: true,
      supply: 0n,
      tlvData: Buffer.from([]),
      tokenProgram: spl_token_1.TOKEN_PROGRAM_ID
    };
    exports2.NO_TOKEN_EXTENSION_CONTEXT = {
      currentEpoch: 0,
      tokenMintWithProgramA: defaultTokenMintWithProgram,
      tokenMintWithProgramB: defaultTokenMintWithProgram,
      rewardTokenMintsWithProgram: [
        defaultTokenMintWithProgram,
        defaultTokenMintWithProgram,
        defaultTokenMintWithProgram
      ]
    };
    var TokenExtensionUtil = class _TokenExtensionUtil {
      static calculateTransferFeeIncludedAmount(transferFeeExcludedAmount, tokenInfo, currentEpoch) {
        const config2 = (0, spl_token_1.getTransferFeeConfig)(tokenInfo);
        if (config2 === null) {
          return { amount: transferFeeExcludedAmount, fee: common_sdk_1.ZERO };
        }
        const transferFee = (0, spl_token_1.getEpochFee)(config2, BigInt(currentEpoch));
        return calculateTransferFeeIncludedAmount2(transferFee, transferFeeExcludedAmount);
      }
      static calculateTransferFeeExcludedAmount(transferFeeIncludedAmount, tokenInfo, currentEpoch) {
        const config2 = (0, spl_token_1.getTransferFeeConfig)(tokenInfo);
        if (config2 === null) {
          return { amount: transferFeeIncludedAmount, fee: common_sdk_1.ZERO };
        }
        const transferFee = (0, spl_token_1.getEpochFee)(config2, BigInt(currentEpoch));
        return calculateTransferFeeExcludedAmount2(transferFee, transferFeeIncludedAmount);
      }
      static async buildTokenExtensionContext(fetcher, whirlpoolData, opts) {
        const mintA = whirlpoolData.tokenMintA;
        const mintB = whirlpoolData.tokenMintB;
        const rewards = whirlpoolData.rewardInfos;
        const [tokenMintWithProgram, currentEpoch] = await Promise.all([
          fetcher.getMintInfos([
            mintA,
            mintB,
            ...rewards.filter((r) => __1.PoolUtil.isRewardInitialized(r)).map((r) => r.mint)
          ], opts),
          fetcher.getEpoch()
        ]);
        const get = (mint) => tokenMintWithProgram.get(mint.toBase58());
        return {
          tokenMintWithProgramA: get(whirlpoolData.tokenMintA),
          tokenMintWithProgramB: get(whirlpoolData.tokenMintB),
          rewardTokenMintsWithProgram: [
            __1.PoolUtil.isRewardInitialized(rewards[0]) ? get(rewards[0].mint) : null,
            __1.PoolUtil.isRewardInitialized(rewards[1]) ? get(rewards[1].mint) : null,
            __1.PoolUtil.isRewardInitialized(rewards[2]) ? get(rewards[2].mint) : null
          ],
          currentEpoch
        };
      }
      static async buildTokenExtensionContextForPool(fetcher, tokenMintA, tokenMintB, opts) {
        const [tokenMintWithProgram, currentEpoch] = await Promise.all([
          fetcher.getMintInfos([tokenMintA, tokenMintB], opts),
          fetcher.getEpoch()
        ]);
        const get = (mint) => tokenMintWithProgram.get(mint.toBase58());
        return {
          tokenMintWithProgramA: get(tokenMintA),
          tokenMintWithProgramB: get(tokenMintB),
          currentEpoch
        };
      }
      static async getExtraAccountMetasForTransferHook(connection, tokenMintWithProgram, source, destination, owner) {
        const transferHook = (0, spl_token_1.getTransferHook)(tokenMintWithProgram);
        if (!transferHook)
          return void 0;
        const instruction = new web3_js_1.TransactionInstruction({
          programId: spl_token_1.TOKEN_2022_PROGRAM_ID,
          keys: [
            { pubkey: source, isSigner: false, isWritable: false },
            {
              pubkey: tokenMintWithProgram.address,
              isSigner: false,
              isWritable: false
            },
            { pubkey: destination, isSigner: false, isWritable: false },
            { pubkey: owner, isSigner: false, isWritable: false },
            { pubkey: owner, isSigner: false, isWritable: false }
          ]
        });
        await (0, spl_token_1.addExtraAccountMetasForExecute)(connection, instruction, transferHook.programId, source, tokenMintWithProgram.address, destination, owner, 0n, "confirmed");
        const extraAccountMetas = instruction.keys.slice(5);
        return extraAccountMetas.length > 0 ? extraAccountMetas : void 0;
      }
      static async getExtraAccountMetasForTransferHookForPool(connection, tokenExtensionCtx, sourceA, destinationA, ownerA, sourceB, destinationB, ownerB) {
        const [tokenTransferHookAccountsA, tokenTransferHookAccountsB] = await Promise.all([
          _TokenExtensionUtil.getExtraAccountMetasForTransferHook(connection, tokenExtensionCtx.tokenMintWithProgramA, sourceA, destinationA, ownerA),
          _TokenExtensionUtil.getExtraAccountMetasForTransferHook(connection, tokenExtensionCtx.tokenMintWithProgramB, sourceB, destinationB, ownerB)
        ]);
        return {
          tokenTransferHookAccountsA,
          tokenTransferHookAccountsB
        };
      }
      static isV2IxRequiredPool(tokenExtensionCtx) {
        return tokenExtensionCtx.tokenMintWithProgramA.tokenProgram.equals(spl_token_1.TOKEN_2022_PROGRAM_ID) || tokenExtensionCtx.tokenMintWithProgramB.tokenProgram.equals(spl_token_1.TOKEN_2022_PROGRAM_ID);
      }
      static isV2IxRequiredReward(tokenExtensionCtx, rewardIndex) {
        return tokenExtensionCtx.rewardTokenMintsWithProgram[rewardIndex]?.tokenProgram.equals(spl_token_1.TOKEN_2022_PROGRAM_ID) ?? false;
      }
    };
    exports2.TokenExtensionUtil = TokenExtensionUtil;
    function ceilDivBN(num, denom) {
      return num.add(denom.subn(1)).div(denom);
    }
    function calculateTransferFeeIncludedAmount2(transferFee, amount) {
      const ONE_IN_BASIS_POINTS2 = 1e4;
      const maxFeeBN = new bn_js_1.default(transferFee.maximumFee.toString());
      if (transferFee.transferFeeBasisPoints === 0) {
        return {
          amount,
          fee: common_sdk_1.ZERO
        };
      }
      if (amount.isZero()) {
        return {
          amount,
          fee: common_sdk_1.ZERO
        };
      }
      if (transferFee.transferFeeBasisPoints === ONE_IN_BASIS_POINTS2) {
        if (amount.add(maxFeeBN).gt(common_sdk_1.U64_MAX)) {
          throw new Error("The total amount and fees overflow");
        }
        return {
          amount: amount.add(maxFeeBN),
          fee: maxFeeBN
        };
      }
      const num = amount.muln(ONE_IN_BASIS_POINTS2);
      const denom = new bn_js_1.default(ONE_IN_BASIS_POINTS2 - transferFee.transferFeeBasisPoints);
      const rawFeeIncludedAmount = ceilDivBN(num, denom);
      const result = rawFeeIncludedAmount.sub(amount).gte(maxFeeBN) ? { amount: amount.add(maxFeeBN), fee: maxFeeBN } : { amount: rawFeeIncludedAmount, fee: rawFeeIncludedAmount.sub(amount) };
      if (result.amount.gt(common_sdk_1.U64_MAX)) {
        throw new Error("The total amount and fees overflow");
      }
      return { ...result };
    }
    function calculateTransferFeeExcludedAmount2(transferFee, amount) {
      const fee = (0, spl_token_1.calculateFee)(transferFee, BigInt(amount.toString()));
      const feeBN = new bn_js_1.default(fee.toString());
      return {
        amount: amount.sub(feeBN),
        fee: feeBN
      };
    }
  }
});

// node_modules/@orca-so/whirlpools-sdk/dist/utils/public/index.js
var require_public3 = __commonJS({
  "node_modules/@orca-so/whirlpools-sdk/dist/utils/public/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_public2(), exports2);
    __exportStar(require_ix_utils(), exports2);
    __exportStar(require_lock_config_util(), exports2);
    __exportStar(require_pda_utils(), exports2);
    __exportStar(require_pool_utils(), exports2);
    __exportStar(require_position_bundle_util(), exports2);
    __exportStar(require_price_math(), exports2);
    __exportStar(require_swap_utils2(), exports2);
    __exportStar(require_tick_utils(), exports2);
    __exportStar(require_token_extension_util(), exports2);
    __exportStar(require_types3(), exports2);
  }
});

// node_modules/@orca-so/whirlpools-sdk/dist/network/public/fetcher/fetcher-utils.js
var require_fetcher_utils = __commonJS({
  "node_modules/@orca-so/whirlpools-sdk/dist/network/public/fetcher/fetcher-utils.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getAllWhirlpoolAccountsForConfig = getAllWhirlpoolAccountsForConfig;
    exports2.getAllPositionAccountsByOwner = getAllPositionAccountsByOwner;
    var common_sdk_1 = require_dist2();
    var tiny_invariant_1 = __importDefault(require_tiny_invariant_cjs());
    var public_1 = require_public();
    var parsing_1 = require_parsing2();
    var spl_token_1 = require_cjs3();
    var public_2 = require_public3();
    var __1 = require_dist3();
    async function getAllWhirlpoolAccountsForConfig({ connection, programId, configId }) {
      const filters = [
        { dataSize: (0, public_1.getAccountSize)(public_1.AccountName.Whirlpool) },
        {
          memcmp: public_1.WHIRLPOOL_CODER.memcmp(public_1.AccountName.Whirlpool, common_sdk_1.AddressUtil.toPubKey(configId).toBuffer())
        }
      ];
      const accounts = await connection.getProgramAccounts(common_sdk_1.AddressUtil.toPubKey(programId), {
        filters
      });
      const parsedAccounts = [];
      accounts.forEach(({ pubkey, account }) => {
        const parsedAccount = parsing_1.ParsableWhirlpool.parse(pubkey, account);
        (0, tiny_invariant_1.default)(!!parsedAccount, `could not parse whirlpool: ${pubkey.toBase58()}`);
        parsedAccounts.push([common_sdk_1.AddressUtil.toString(pubkey), parsedAccount]);
      });
      return new Map(parsedAccounts.map(([address, pool]) => [
        common_sdk_1.AddressUtil.toString(address),
        pool
      ]));
    }
    async function getAllPositionAccountsByOwner({ ctx, owner, includesPositions = true, includesPositionsWithTokenExtensions = true, includesBundledPositions = false }) {
      const positions = !includesPositions ? /* @__PURE__ */ new Map() : await findPositions(ctx, owner, spl_token_1.TOKEN_PROGRAM_ID);
      const positionsWithTokenExtensions = !includesPositionsWithTokenExtensions ? /* @__PURE__ */ new Map() : await findPositions(ctx, owner, spl_token_1.TOKEN_2022_PROGRAM_ID);
      const positionBundles = !includesBundledPositions ? [] : await findBundledPositions(ctx, owner);
      return {
        positions,
        positionsWithTokenExtensions,
        positionBundles
      };
    }
    async function findPositions(ctx, owner, tokenProgramId) {
      const programId = common_sdk_1.AddressUtil.toPubKey(tokenProgramId);
      const tokenAccounts = await ctx.connection.getTokenAccountsByOwner(common_sdk_1.AddressUtil.toPubKey(owner), {
        programId
      });
      const candidatePubkeys = [];
      tokenAccounts.value.forEach((ta) => {
        const parsed = (0, spl_token_1.unpackAccount)(ta.pubkey, ta.account, programId);
        if (parsed.amount === 1n) {
          const pda = public_2.PDAUtil.getPosition(ctx.program.programId, parsed.mint);
          candidatePubkeys.push(pda.publicKey);
        }
      });
      const positionData = await ctx.fetcher.getPositions(candidatePubkeys, __1.IGNORE_CACHE);
      return new Map(Array.from(positionData.entries()).filter(([_, v]) => v !== null));
    }
    async function findBundledPositions(ctx, owner) {
      const tokenAccounts = await ctx.connection.getTokenAccountsByOwner(common_sdk_1.AddressUtil.toPubKey(owner), {
        programId: spl_token_1.TOKEN_PROGRAM_ID
      });
      const candidatePubkeys = [];
      tokenAccounts.value.forEach((ta) => {
        const parsed = (0, spl_token_1.unpackAccount)(ta.pubkey, ta.account, spl_token_1.TOKEN_PROGRAM_ID);
        if (parsed.amount === 1n) {
          const pda = public_2.PDAUtil.getPositionBundle(ctx.program.programId, parsed.mint);
          candidatePubkeys.push(pda.publicKey);
        }
      });
      const positionBundleData = await ctx.fetcher.getPositionBundles(candidatePubkeys, __1.IGNORE_CACHE);
      const positionBundles = Array.from(positionBundleData.entries()).filter(([_, v]) => v !== null);
      const bundledPositionPubkeys = [];
      positionBundles.forEach(([_, positionBundle]) => {
        const bundleIndexes = public_2.PositionBundleUtil.getOccupiedBundleIndexes(positionBundle);
        bundleIndexes.forEach((bundleIndex) => {
          const pda = public_2.PDAUtil.getBundledPosition(ctx.program.programId, positionBundle.positionBundleMint, bundleIndex);
          bundledPositionPubkeys.push(pda.publicKey);
        });
      });
      const bundledPositionData = await ctx.fetcher.getPositions(bundledPositionPubkeys, __1.IGNORE_CACHE);
      return positionBundles.map(([positionBundleAddress, positionBundleData2]) => {
        const bundleIndexes = public_2.PositionBundleUtil.getOccupiedBundleIndexes(positionBundleData2);
        const bundledPositions = new Map(bundleIndexes.map((bundleIndex) => {
          const pda = public_2.PDAUtil.getBundledPosition(ctx.program.programId, positionBundleData2.positionBundleMint, bundleIndex);
          return [
            bundleIndex,
            bundledPositionData.get(common_sdk_1.AddressUtil.toString(pda.publicKey))
          ];
        }).filter(([_, v]) => v !== null));
        return {
          positionBundleAddress,
          positionBundleData: positionBundleData2,
          bundledPositions
        };
      });
    }
  }
});

// node_modules/@orca-so/whirlpools-sdk/dist/network/public/fetcher/index.js
var require_fetcher2 = __commonJS({
  "node_modules/@orca-so/whirlpools-sdk/dist/network/public/fetcher/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_fetcher_impl(), exports2);
    __exportStar(require_fetcher_types(), exports2);
    __exportStar(require_fetcher_utils(), exports2);
  }
});

// node_modules/@orca-so/whirlpools-sdk/dist/network/public/index.js
var require_public4 = __commonJS({
  "node_modules/@orca-so/whirlpools-sdk/dist/network/public/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_fetcher2(), exports2);
    __exportStar(require_parsing2(), exports2);
  }
});

// node_modules/@orca-so/whirlpools-sdk/dist/utils/txn-utils.js
var require_txn_utils = __commonJS({
  "node_modules/@orca-so/whirlpools-sdk/dist/utils/txn-utils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MultipleTransactionBuilderFactoryWithAccountResolver = void 0;
    exports2.convertListToMap = convertListToMap;
    exports2.filterNullObjects = filterNullObjects;
    exports2.checkMergedTransactionSizeIsValid = checkMergedTransactionSizeIsValid;
    exports2.contextOptionsToBuilderOptions = contextOptionsToBuilderOptions;
    var common_sdk_1 = require_dist2();
    var spl_token_1 = require_cjs3();
    function convertListToMap(fetchedData, addresses) {
      const result = {};
      fetchedData.forEach((data, index) => {
        if (data) {
          const addr = addresses[index];
          result[addr] = data;
        }
      });
      return result;
    }
    function filterNullObjects(firstArray, secondArray) {
      const filteredFirstArray = [];
      const filteredSecondArray = [];
      firstArray.forEach((item, idx) => {
        if (item !== null) {
          filteredFirstArray.push(item);
          filteredSecondArray.push(secondArray[idx]);
        }
      });
      return [filteredFirstArray, filteredSecondArray];
    }
    async function checkMergedTransactionSizeIsValid(ctx, builders, latestBlockhash) {
      const merged = new common_sdk_1.TransactionBuilder(ctx.connection, ctx.wallet, ctx.txBuilderOpts);
      builders.forEach((builder) => merged.addInstruction(builder.compressIx(true)));
      try {
        await merged.txnSize({
          latestBlockhash
        });
        return true;
      } catch {
        return false;
      }
    }
    function contextOptionsToBuilderOptions(opts) {
      return {
        defaultBuildOption: {
          ...common_sdk_1.defaultTransactionBuilderOptions.defaultBuildOption,
          ...opts.userDefaultBuildOptions
        },
        defaultSendOption: {
          ...common_sdk_1.defaultTransactionBuilderOptions.defaultSendOption,
          ...opts.userDefaultSendOptions
        },
        defaultConfirmationCommitment: opts.userDefaultConfirmCommitment ?? common_sdk_1.defaultTransactionBuilderOptions.defaultConfirmationCommitment
      };
    }
    var MultipleTransactionBuilderFactoryWithAccountResolver = class {
      ctx;
      resolvedAtas;
      tokenOwner;
      payer;
      txBuilders = [];
      pendingTxBuilder = null;
      touchedMints = null;
      accountExemption = null;
      constructor(ctx, resolvedAtas, tokenOwner = ctx.wallet.publicKey, payer = tokenOwner) {
        this.ctx = ctx;
        this.resolvedAtas = resolvedAtas;
        this.tokenOwner = tokenOwner;
        this.payer = payer;
      }
      async addInstructions(generator) {
        if (this.accountExemption === null) {
          this.accountExemption = await this.ctx.fetcher.getAccountRentExempt();
        }
        for (let iter = 0; iter < 2; iter++) {
          if (!this.pendingTxBuilder || !this.touchedMints) {
            this.pendingTxBuilder = new common_sdk_1.TransactionBuilder(this.ctx.connection, this.ctx.wallet, this.ctx.txBuilderOpts);
            this.touchedMints = /* @__PURE__ */ new Set();
            this.resolvedAtas[spl_token_1.NATIVE_MINT.toBase58()] = common_sdk_1.TokenUtil.createWrappedNativeAccountInstruction(this.tokenOwner, common_sdk_1.ZERO, this.accountExemption, this.payer, this.tokenOwner, this.ctx.accountResolverOpts.createWrappedSolAccountMethod);
          }
          const newTxBuilder = new common_sdk_1.TransactionBuilder(this.ctx.connection, this.ctx.wallet, this.ctx.txBuilderOpts);
          const resolve = (mint) => {
            if (!this.touchedMints.has(mint)) {
              newTxBuilder.addInstruction(this.resolvedAtas[mint]);
              this.touchedMints.add(mint);
            }
            return this.resolvedAtas[mint].address;
          };
          const ixs = await generator(resolve.bind(this));
          newTxBuilder.addInstructions(ixs);
          const mergeable = await checkMergedTransactionSizeIsValid(this.ctx, [this.pendingTxBuilder, newTxBuilder], common_sdk_1.MEASUREMENT_BLOCKHASH);
          if (mergeable) {
            this.pendingTxBuilder.addInstruction(newTxBuilder.compressIx(false));
            break;
          } else {
            if (iter !== 0) {
              throw new Error(`instruction is too large.`);
            }
            this.txBuilders.push(this.pendingTxBuilder);
            this.pendingTxBuilder = null;
            this.touchedMints = null;
          }
        }
      }
      build() {
        return this.pendingTxBuilder ? [...this.txBuilders, this.pendingTxBuilder] : [...this.txBuilders];
      }
    };
    exports2.MultipleTransactionBuilderFactoryWithAccountResolver = MultipleTransactionBuilderFactoryWithAccountResolver;
  }
});

// node_modules/@orca-so/whirlpools-sdk/dist/context.js
var require_context = __commonJS({
  "node_modules/@orca-so/whirlpools-sdk/dist/context.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.WhirlpoolContext = void 0;
    var anchor_1 = require("@coral-xyz/anchor");
    var whirlpool_json_1 = __importDefault(require_whirlpool());
    var public_1 = require_public4();
    var txn_utils_1 = require_txn_utils();
    var DEFAULT_ACCOUNT_RESOLVER_OPTS = {
      createWrappedSolAccountMethod: "keypair",
      allowPDAOwnerAddress: false
    };
    var WhirlpoolContext2 = class _WhirlpoolContext {
      connection;
      wallet;
      program;
      provider;
      fetcher;
      lookupTableFetcher;
      opts;
      txBuilderOpts;
      accountResolverOpts;
      static from(connection, wallet, programId, fetcher = (0, public_1.buildDefaultAccountFetcher)(connection), lookupTableFetcher, opts = {}) {
        const anchorProvider = new anchor_1.AnchorProvider(connection, wallet, {
          commitment: opts.userDefaultConfirmCommitment || "confirmed",
          preflightCommitment: opts.userDefaultConfirmCommitment || "confirmed"
        });
        const program = new anchor_1.Program(whirlpool_json_1.default, programId, anchorProvider);
        return new _WhirlpoolContext(anchorProvider, anchorProvider.wallet, program, fetcher, lookupTableFetcher, opts);
      }
      static fromWorkspace(provider, program, fetcher = (0, public_1.buildDefaultAccountFetcher)(provider.connection), lookupTableFetcher, opts = {}) {
        return new _WhirlpoolContext(provider, provider.wallet, program, fetcher, lookupTableFetcher, opts);
      }
      static withProvider(provider, programId, fetcher = (0, public_1.buildDefaultAccountFetcher)(provider.connection), lookupTableFetcher, opts = {}) {
        const program = new anchor_1.Program(whirlpool_json_1.default, programId, provider);
        return new _WhirlpoolContext(provider, provider.wallet, program, fetcher, lookupTableFetcher, opts);
      }
      constructor(provider, wallet, program, fetcher, lookupTableFetcher, opts = {}) {
        this.connection = provider.connection;
        this.wallet = wallet;
        this.program = program;
        this.provider = provider;
        this.fetcher = fetcher;
        this.lookupTableFetcher = lookupTableFetcher;
        this.opts = opts;
        this.txBuilderOpts = (0, txn_utils_1.contextOptionsToBuilderOptions)(this.opts);
        this.accountResolverOpts = opts.accountResolverOptions ?? DEFAULT_ACCOUNT_RESOLVER_OPTS;
      }
    };
    exports2.WhirlpoolContext = WhirlpoolContext2;
  }
});

// node_modules/@orca-so/whirlpools-sdk/dist/instructions/close-bundled-position-ix.js
var require_close_bundled_position_ix = __commonJS({
  "node_modules/@orca-so/whirlpools-sdk/dist/instructions/close-bundled-position-ix.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.closeBundledPositionIx = closeBundledPositionIx;
    function closeBundledPositionIx(program, params) {
      const { bundledPosition, positionBundle, positionBundleTokenAccount, positionBundleAuthority, bundleIndex, receiver } = params;
      const ix = program.instruction.closeBundledPosition(bundleIndex, {
        accounts: {
          bundledPosition,
          positionBundle,
          positionBundleTokenAccount,
          positionBundleAuthority,
          receiver
        }
      });
      return {
        instructions: [ix],
        cleanupInstructions: [],
        signers: []
      };
    }
  }
});

// node_modules/@orca-so/whirlpools-sdk/dist/instructions/close-position-ix.js
var require_close_position_ix = __commonJS({
  "node_modules/@orca-so/whirlpools-sdk/dist/instructions/close-position-ix.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.closePositionIx = closePositionIx;
    var spl_token_1 = require_cjs3();
    function closePositionIx(program, params) {
      const { positionAuthority, receiver, position, positionMint, positionTokenAccount } = params;
      const ix = program.instruction.closePosition({
        accounts: {
          positionAuthority,
          receiver,
          position,
          positionMint,
          positionTokenAccount,
          tokenProgram: spl_token_1.TOKEN_PROGRAM_ID
        }
      });
      return {
        instructions: [ix],
        cleanupInstructions: [],
        signers: []
      };
    }
  }
});

// node_modules/@orca-so/whirlpools-sdk/dist/instructions/close-position-with-token-extensions-ix.js
var require_close_position_with_token_extensions_ix = __commonJS({
  "node_modules/@orca-so/whirlpools-sdk/dist/instructions/close-position-with-token-extensions-ix.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.closePositionWithTokenExtensionsIx = closePositionWithTokenExtensionsIx;
    var spl_token_1 = require_cjs3();
    function closePositionWithTokenExtensionsIx(program, params) {
      const ix = program.instruction.closePositionWithTokenExtensions({
        accounts: {
          ...params,
          token2022Program: spl_token_1.TOKEN_2022_PROGRAM_ID
        }
      });
      return {
        instructions: [ix],
        cleanupInstructions: [],
        signers: []
      };
    }
  }
});

// node_modules/@orca-so/whirlpools-sdk/dist/instructions/collect-fees-ix.js
var require_collect_fees_ix = __commonJS({
  "node_modules/@orca-so/whirlpools-sdk/dist/instructions/collect-fees-ix.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.collectFeesIx = collectFeesIx;
    var spl_token_1 = require_cjs3();
    function collectFeesIx(program, params) {
      const { whirlpool, positionAuthority, position, positionTokenAccount, tokenOwnerAccountA, tokenOwnerAccountB, tokenVaultA, tokenVaultB } = params;
      const ix = program.instruction.collectFees({
        accounts: {
          whirlpool,
          positionAuthority,
          position,
          positionTokenAccount,
          tokenOwnerAccountA,
          tokenOwnerAccountB,
          tokenVaultA,
          tokenVaultB,
          tokenProgram: spl_token_1.TOKEN_PROGRAM_ID
        }
      });
      return {
        instructions: [ix],
        cleanupInstructions: [],
        signers: []
      };
    }
  }
});

// node_modules/@orca-so/whirlpools-sdk/dist/instructions/collect-protocol-fees-ix.js
var require_collect_protocol_fees_ix = __commonJS({
  "node_modules/@orca-so/whirlpools-sdk/dist/instructions/collect-protocol-fees-ix.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.collectProtocolFeesIx = collectProtocolFeesIx;
    var spl_token_1 = require_cjs3();
    function collectProtocolFeesIx(program, params) {
      const { whirlpoolsConfig, whirlpool, collectProtocolFeesAuthority, tokenVaultA, tokenVaultB, tokenOwnerAccountA: tokenDestinationA, tokenOwnerAccountB: tokenDestinationB } = params;
      const ix = program.instruction.collectProtocolFees({
        accounts: {
          whirlpoolsConfig,
          whirlpool,
          collectProtocolFeesAuthority,
          tokenVaultA,
          tokenVaultB,
          tokenDestinationA,
          tokenDestinationB,
          tokenProgram: spl_token_1.TOKEN_PROGRAM_ID
        }
      });
      return {
        instructions: [ix],
        cleanupInstructions: [],
        signers: []
      };
    }
  }
});

// node_modules/@orca-so/whirlpools-sdk/dist/instructions/collect-reward-ix.js
var require_collect_reward_ix = __commonJS({
  "node_modules/@orca-so/whirlpools-sdk/dist/instructions/collect-reward-ix.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.collectRewardIx = collectRewardIx;
    var spl_token_1 = require_cjs3();
    function collectRewardIx(program, params) {
      const { whirlpool, positionAuthority, position, positionTokenAccount, rewardOwnerAccount, rewardVault, rewardIndex } = params;
      const ix = program.instruction.collectReward(rewardIndex, {
        accounts: {
          whirlpool,
          positionAuthority,
          position,
          positionTokenAccount,
          rewardOwnerAccount,
          rewardVault,
          tokenProgram: spl_token_1.TOKEN_PROGRAM_ID
        }
      });
      return {
        instructions: [ix],
        cleanupInstructions: [],
        signers: []
      };
    }
  }
});

// node_modules/@orca-so/whirlpools-sdk/dist/ix.js
var require_ix = __commonJS({
  "node_modules/@orca-so/whirlpools-sdk/dist/ix.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || /* @__PURE__ */ function() {
      var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2)
            if (Object.prototype.hasOwnProperty.call(o2, k))
              ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      };
      return function(mod2) {
        if (mod2 && mod2.__esModule)
          return mod2;
        var result = {};
        if (mod2 != null) {
          for (var k = ownKeys(mod2), i = 0; i < k.length; i++)
            if (k[i] !== "default")
              __createBinding(result, mod2, k[i]);
        }
        __setModuleDefault(result, mod2);
        return result;
      };
    }();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.WhirlpoolIx = void 0;
    var ix = __importStar(require_instructions9());
    var WhirlpoolIx2 = class {
      static initializeConfigIx(program, params) {
        return ix.initializeConfigIx(program, params);
      }
      static initializeFeeTierIx(program, params) {
        return ix.initializeFeeTierIx(program, params);
      }
      static initializePoolIx(program, params) {
        return ix.initializePoolIx(program, params);
      }
      static initializeRewardIx(program, params) {
        return ix.initializeRewardIx(program, params);
      }
      static initTickArrayIx(program, params) {
        return ix.initTickArrayIx(program, params);
      }
      static openPositionIx(program, params) {
        return ix.openPositionIx(program, params);
      }
      static openPositionWithMetadataIx(program, params) {
        return ix.openPositionWithMetadataIx(program, params);
      }
      static increaseLiquidityIx(program, params) {
        return ix.increaseLiquidityIx(program, params);
      }
      static decreaseLiquidityIx(program, params) {
        return ix.decreaseLiquidityIx(program, params);
      }
      static closePositionIx(program, params) {
        return ix.closePositionIx(program, params);
      }
      static swapIx(program, params) {
        return ix.swapIx(program, params);
      }
      static twoHopSwapIx(program, params) {
        return ix.twoHopSwapIx(program, params);
      }
      static updateFeesAndRewardsIx(program, params) {
        return ix.updateFeesAndRewardsIx(program, params);
      }
      static collectFeesIx(program, params) {
        return ix.collectFeesIx(program, params);
      }
      static collectProtocolFeesIx(program, params) {
        return ix.collectProtocolFeesIx(program, params);
      }
      static collectRewardIx(program, params) {
        return ix.collectRewardIx(program, params);
      }
      static setCollectProtocolFeesAuthorityIx(program, params) {
        return ix.setCollectProtocolFeesAuthorityIx(program, params);
      }
      static setDefaultFeeRateIx(program, params) {
        return ix.setDefaultFeeRateIx(program, params);
      }
      static setDefaultProtocolFeeRateIx(program, params) {
        return ix.setDefaultProtocolFeeRateIx(program, params);
      }
      static setFeeAuthorityIx(program, params) {
        return ix.setFeeAuthorityIx(program, params);
      }
      static setFeeRateIx(program, params) {
        return ix.setFeeRateIx(program, params);
      }
      static setProtocolFeeRateIx(program, params) {
        return ix.setProtocolFeeRateIx(program, params);
      }
      static setRewardAuthorityBySuperAuthorityIx(program, params) {
        return ix.setRewardAuthorityBySuperAuthorityIx(program, params);
      }
      static setRewardAuthorityIx(program, params) {
        return ix.setRewardAuthorityIx(program, params);
      }
      static setRewardEmissionsIx(program, params) {
        return ix.setRewardEmissionsIx(program, params);
      }
      static setRewardEmissionsSuperAuthorityIx(program, params) {
        return ix.setRewardEmissionsSuperAuthorityIx(program, params);
      }
      static initializePositionBundleIx(program, params) {
        return ix.initializePositionBundleIx(program, params);
      }
      static initializePositionBundleWithMetadataIx(program, params) {
        return ix.initializePositionBundleWithMetadataIx(program, params);
      }
      static deletePositionBundleIx(program, params) {
        return ix.deletePositionBundleIx(program, params);
      }
      static openBundledPositionIx(program, params) {
        return ix.openBundledPositionIx(program, params);
      }
      static closeBundledPositionIx(program, params) {
        return ix.closeBundledPositionIx(program, params);
      }
      static openPositionWithTokenExtensionsIx(program, params) {
        return ix.openPositionWithTokenExtensionsIx(program, params);
      }
      static closePositionWithTokenExtensionsIx(program, params) {
        return ix.closePositionWithTokenExtensionsIx(program, params);
      }
      static initializeAdaptiveFeeTierIx(program, params) {
        return ix.initializeAdaptiveFeeTierIx(program, params);
      }
      static initializePoolWithAdaptiveFeeIx(program, params) {
        return ix.initializePoolWithAdaptiveFeeIx(program, params);
      }
      static setDefaultBaseFeeRateIx(program, params) {
        return ix.setDefaultBaseFeeRateIx(program, params);
      }
      static setDelegatedFeeAuthorityIx(program, params) {
        return ix.setDelegatedFeeAuthorityIx(program, params);
      }
      static setFeeRateByDelegatedFeeAuthorityIx(program, params) {
        return ix.setFeeRateByDelegatedFeeAuthorityIx(program, params);
      }
      static setInitializePoolAuthorityIx(program, params) {
        return ix.setInitializePoolAuthorityIx(program, params);
      }
      static setPresetAdaptiveFeeConstantsIx(program, params) {
        return ix.setPresetAdaptiveFeeConstantsIx(program, params);
      }
      static resetPositionRangeIx(program, params) {
        return ix.resetPositionRangeIx(program, params);
      }
      static lockPositionIx(program, params) {
        return ix.lockPositionIx(program, params);
      }
      static transferLockedPositionIx(program, params) {
        return ix.transferLockedPositionIx(program, params);
      }
      static collectFeesV2Ix(program, params) {
        return ix.collectFeesV2Ix(program, params);
      }
      static collectProtocolFeesV2Ix(program, params) {
        return ix.collectProtocolFeesV2Ix(program, params);
      }
      static collectRewardV2Ix(program, params) {
        return ix.collectRewardV2Ix(program, params);
      }
      static decreaseLiquidityV2Ix(program, params) {
        return ix.decreaseLiquidityV2Ix(program, params);
      }
      static increaseLiquidityV2Ix(program, params) {
        return ix.increaseLiquidityV2Ix(program, params);
      }
      static initializePoolV2Ix(program, params) {
        return ix.initializePoolV2Ix(program, params);
      }
      static initializeRewardV2Ix(program, params) {
        return ix.initializeRewardV2Ix(program, params);
      }
      static setRewardEmissionsV2Ix(program, params) {
        return ix.setRewardEmissionsV2Ix(program, params);
      }
      static swapV2Ix(program, params) {
        return ix.swapV2Ix(program, params);
      }
      static twoHopSwapV2Ix(program, params) {
        return ix.twoHopSwapV2Ix(program, params);
      }
      static initializeConfigExtensionIx(program, params) {
        return ix.initializeConfigExtensionIx(program, params);
      }
      static setConfigExtensionAuthorityIx(program, params) {
        return ix.setConfigExtensionAuthorityIx(program, params);
      }
      static setTokenBadgeAuthorityIx(program, params) {
        return ix.setTokenBadgeAuthorityIx(program, params);
      }
      static initializeTokenBadgeIx(program, params) {
        return ix.initializeTokenBadgeIx(program, params);
      }
      static deleteTokenBadgeIx(program, params) {
        return ix.deleteTokenBadgeIx(program, params);
      }
    };
    exports2.WhirlpoolIx = WhirlpoolIx2;
  }
});

// node_modules/@orca-so/whirlpools-sdk/dist/utils/whirlpool-ata-utils.js
var require_whirlpool_ata_utils = __commonJS({
  "node_modules/@orca-so/whirlpools-sdk/dist/utils/whirlpool-ata-utils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TokenMintTypes = void 0;
    exports2.getTokenMintsFromWhirlpools = getTokenMintsFromWhirlpools;
    exports2.resolveAtaForMints = resolveAtaForMints;
    exports2.addNativeMintHandlingIx = addNativeMintHandlingIx;
    var common_sdk_1 = require_dist2();
    var spl_token_1 = require_cjs3();
    var web3_js_1 = require("@solana/web3.js");
    var __1 = require_dist3();
    var txn_utils_1 = require_txn_utils();
    var TokenMintTypes;
    (function(TokenMintTypes2) {
      TokenMintTypes2["ALL"] = "ALL";
      TokenMintTypes2["POOL_ONLY"] = "POOL_ONLY";
      TokenMintTypes2["REWARD_ONLY"] = "REWARDS_ONLY";
    })(TokenMintTypes || (exports2.TokenMintTypes = TokenMintTypes = {}));
    function getTokenMintsFromWhirlpools(whirlpoolDatas, mintTypes = TokenMintTypes.ALL) {
      let hasNativeMint = false;
      const mints = Array.from(whirlpoolDatas.reduce((accu, whirlpoolData) => {
        if (whirlpoolData) {
          if (mintTypes === TokenMintTypes.ALL || mintTypes === TokenMintTypes.POOL_ONLY) {
            const { tokenMintA, tokenMintB } = whirlpoolData;
            if (!common_sdk_1.TokenUtil.isNativeMint(tokenMintA)) {
              accu.add(tokenMintA.toBase58());
            } else {
              hasNativeMint = true;
            }
            if (!common_sdk_1.TokenUtil.isNativeMint(tokenMintB)) {
              accu.add(tokenMintB.toBase58());
            } else {
              hasNativeMint = true;
            }
          }
          if (mintTypes === TokenMintTypes.ALL || mintTypes === TokenMintTypes.REWARD_ONLY) {
            const rewardInfos = whirlpoolData.rewardInfos;
            rewardInfos.forEach((reward) => {
              if (common_sdk_1.TokenUtil.isNativeMint(reward.mint)) {
                hasNativeMint = true;
              }
              if (__1.PoolUtil.isRewardInitialized(reward)) {
                accu.add(reward.mint.toBase58());
              }
            });
          }
        }
        return accu;
      }, /* @__PURE__ */ new Set())).map((mint) => new web3_js_1.PublicKey(mint));
      return {
        mintMap: mints,
        hasNativeMint
      };
    }
    async function resolveAtaForMints(ctx, params) {
      const { mints, receiver, payer, accountExemption } = params;
      const receiverKey = receiver ?? ctx.wallet.publicKey;
      const payerKey = payer ?? ctx.wallet.publicKey;
      const resolvedAtaResults = await (0, common_sdk_1.resolveOrCreateATAs)(ctx.connection, receiverKey, mints.map((tokenMint) => {
        return { tokenMint };
      }), async () => accountExemption, payerKey, void 0, ctx.accountResolverOpts.allowPDAOwnerAddress, ctx.accountResolverOpts.createWrappedSolAccountMethod);
      const { resolveAtaIxs, resolvedAtas } = resolvedAtaResults.reduce((accu, curr) => {
        const { address, ...ix } = curr;
        accu.resolvedAtas.push(address);
        if (ix.instructions.length) {
          accu.resolveAtaIxs.push(ix);
        }
        return accu;
      }, { resolvedAtas: [], resolveAtaIxs: [] });
      const affliatedTokenAtaMap = (0, txn_utils_1.convertListToMap)(resolvedAtas, mints.map((mint) => mint.toBase58()));
      return {
        ataTokenAddresses: affliatedTokenAtaMap,
        resolveAtaIxs
      };
    }
    function addNativeMintHandlingIx(txBuilder, affliatedTokenAtaMap, destinationWallet, accountExemption, createAccountMethod) {
      let { address: wSOLAta, ...resolveWSolIx } = common_sdk_1.TokenUtil.createWrappedNativeAccountInstruction(destinationWallet, common_sdk_1.ZERO, accountExemption, void 0, void 0, createAccountMethod);
      affliatedTokenAtaMap[spl_token_1.NATIVE_MINT.toBase58()] = wSOLAta;
      txBuilder.prependInstruction(resolveWSolIx);
    }
  }
});

// node_modules/@orca-so/whirlpools-sdk/dist/instructions/update-fees-and-rewards-ix.js
var require_update_fees_and_rewards_ix = __commonJS({
  "node_modules/@orca-so/whirlpools-sdk/dist/instructions/update-fees-and-rewards-ix.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.updateFeesAndRewardsIx = updateFeesAndRewardsIx;
    function updateFeesAndRewardsIx(program, params) {
      const { whirlpool, position, tickArrayLower, tickArrayUpper } = params;
      const ix = program.instruction.updateFeesAndRewards({
        accounts: {
          whirlpool,
          position,
          tickArrayLower,
          tickArrayUpper
        }
      });
      return {
        instructions: [ix],
        cleanupInstructions: [],
        signers: []
      };
    }
  }
});

// node_modules/@orca-so/whirlpools-sdk/dist/instructions/composites/collect-all-txn.js
var require_collect_all_txn = __commonJS({
  "node_modules/@orca-so/whirlpools-sdk/dist/instructions/composites/collect-all-txn.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.collectAllForPositionAddressesTxns = collectAllForPositionAddressesTxns;
    exports2.collectAllForPositionsTxns = collectAllForPositionsTxns;
    var common_sdk_1 = require_dist2();
    var spl_token_1 = require_cjs3();
    var web3_js_1 = require("@solana/web3.js");
    var ix_1 = require_ix();
    var fetcher_1 = require_fetcher2();
    var public_1 = require_public3();
    var txn_utils_1 = require_txn_utils();
    var whirlpool_ata_utils_1 = require_whirlpool_ata_utils();
    var update_fees_and_rewards_ix_1 = require_update_fees_and_rewards_ix();
    var token_extension_util_1 = require_token_extension_util();
    async function collectAllForPositionAddressesTxns(ctx, params, opts = fetcher_1.PREFER_CACHE) {
      const { positions, ...rest } = params;
      const fetchedPositions = await ctx.fetcher.getPositions(positions, opts);
      const positionMap = {};
      fetchedPositions.forEach((pos, addr) => {
        if (pos) {
          positionMap[addr] = pos;
        }
      });
      return collectAllForPositionsTxns(ctx, { positions: positionMap, ...rest });
    }
    async function collectAllForPositionsTxns(ctx, params) {
      const { positions, receiver, positionAuthority, positionOwner, payer } = params;
      const receiverKey = receiver ?? ctx.wallet.publicKey;
      const positionAuthorityKey = positionAuthority ?? ctx.wallet.publicKey;
      const positionOwnerKey = positionOwner ?? ctx.wallet.publicKey;
      const payerKey = payer ?? ctx.wallet.publicKey;
      const positionList = Object.entries(positions);
      if (positionList.length === 0) {
        return [];
      }
      const whirlpoolAddrs = positionList.map(([, pos]) => pos.whirlpool.toBase58());
      const whirlpools = await ctx.fetcher.getPools(whirlpoolAddrs, fetcher_1.PREFER_CACHE);
      const allMints = (0, whirlpool_ata_utils_1.getTokenMintsFromWhirlpools)(Array.from(whirlpools.values()));
      const accountExemption = await ctx.fetcher.getAccountRentExempt();
      const positionMintAddrs = positionList.map(([, pos]) => pos.positionMint);
      const positionMintInfos = await ctx.fetcher.getMintInfos(positionMintAddrs);
      await ctx.fetcher.getMintInfos(allMints.mintMap);
      const resolvedAtas = (0, txn_utils_1.convertListToMap)(await (0, common_sdk_1.resolveOrCreateATAs)(ctx.connection, receiverKey, allMints.mintMap.map((tokenMint) => ({ tokenMint })), async () => accountExemption, payerKey, true, ctx.accountResolverOpts.allowPDAOwnerAddress, ctx.accountResolverOpts.createWrappedSolAccountMethod), allMints.mintMap.map((mint) => mint.toBase58()));
      const latestBlockhash = await ctx.connection.getLatestBlockhash();
      const txBuilders = [];
      const collectionTasks = [];
      positionList.forEach(([positionAddr, position]) => {
        const whirlpool = whirlpools.get(position.whirlpool.toBase58());
        if (!whirlpool) {
          throw new Error(`Unable to process positionMint ${position.positionMint.toBase58()} - unable to derive whirlpool ${position.whirlpool.toBase58()}`);
        }
        const positionMintInfo = positionMintInfos.get(position.positionMint.toBase58());
        if (!positionMintInfo) {
          throw new Error(`Unable to process positionMint ${position.positionMint.toBase58()} - missing mint info`);
        }
        collectionTasks.push({
          collectionType: "fee",
          positionAddr,
          position,
          whirlpool,
          positionMintTokenProgramId: positionMintInfo.tokenProgram
        });
        whirlpool.rewardInfos.forEach((rewardInfo, index) => {
          if (public_1.PoolUtil.isRewardInitialized(rewardInfo)) {
            collectionTasks.push({
              collectionType: "reward",
              rewardIndex: index,
              positionAddr,
              position,
              whirlpool,
              positionMintTokenProgramId: positionMintInfo.tokenProgram
            });
          }
        });
      });
      let cursor = 0;
      let pendingTxBuilder = null;
      let touchedMints = null;
      let lastUpdatedPosition = null;
      let reattempt = false;
      while (cursor < collectionTasks.length) {
        if (!pendingTxBuilder || !touchedMints) {
          pendingTxBuilder = new common_sdk_1.TransactionBuilder(ctx.connection, ctx.wallet, ctx.txBuilderOpts);
          touchedMints = /* @__PURE__ */ new Set();
          resolvedAtas[spl_token_1.NATIVE_MINT.toBase58()] = common_sdk_1.TokenUtil.createWrappedNativeAccountInstruction(receiverKey, common_sdk_1.ZERO, accountExemption, void 0, void 0, ctx.accountResolverOpts.createWrappedSolAccountMethod);
        }
        const task = collectionTasks[cursor];
        const alreadyUpdated = lastUpdatedPosition === task.positionAddr;
        const collectIxForPosition = await constructCollectIxForPosition(ctx, task, alreadyUpdated, positionOwnerKey, positionAuthorityKey, resolvedAtas, touchedMints);
        const positionTxBuilder = new common_sdk_1.TransactionBuilder(ctx.connection, ctx.wallet, ctx.txBuilderOpts);
        positionTxBuilder.addInstructions(collectIxForPosition);
        const mergeable = await (0, txn_utils_1.checkMergedTransactionSizeIsValid)(ctx, [pendingTxBuilder, positionTxBuilder], latestBlockhash);
        if (mergeable) {
          pendingTxBuilder.addInstruction(positionTxBuilder.compressIx(false));
          cursor += 1;
          lastUpdatedPosition = task.positionAddr;
          reattempt = false;
        } else {
          if (reattempt) {
            throw new Error(`Unable to fit collection ix for ${task.position.positionMint.toBase58()} in a Transaction.`);
          }
          txBuilders.push(pendingTxBuilder);
          pendingTxBuilder = null;
          touchedMints = null;
          lastUpdatedPosition = null;
          reattempt = true;
        }
      }
      if (pendingTxBuilder) {
        txBuilders.push(pendingTxBuilder);
      }
      return txBuilders;
    }
    var constructCollectIxForPosition = async (ctx, task, alreadyUpdated, positionOwner, positionAuthority, resolvedAtas, touchedMints) => {
      const ixForPosition = [];
      const { whirlpool: whirlpoolKey, liquidity, tickLowerIndex, tickUpperIndex, positionMint } = task.position;
      const positionMintTokenProgramId = task.positionMintTokenProgramId;
      const whirlpool = task.whirlpool;
      const { tickSpacing } = whirlpool;
      const mintA = whirlpool.tokenMintA.toBase58();
      const mintB = whirlpool.tokenMintB.toBase58();
      const tokenExtensionCtx = await token_extension_util_1.TokenExtensionUtil.buildTokenExtensionContext(ctx.fetcher, whirlpool, fetcher_1.PREFER_CACHE);
      const positionTokenAccount = (0, spl_token_1.getAssociatedTokenAddressSync)(positionMint, positionOwner, ctx.accountResolverOpts.allowPDAOwnerAddress, positionMintTokenProgramId);
      if (!liquidity.eq(common_sdk_1.ZERO) && !alreadyUpdated) {
        ixForPosition.push((0, update_fees_and_rewards_ix_1.updateFeesAndRewardsIx)(ctx.program, {
          position: new web3_js_1.PublicKey(task.positionAddr),
          whirlpool: whirlpoolKey,
          tickArrayLower: public_1.PDAUtil.getTickArray(ctx.program.programId, whirlpoolKey, public_1.TickUtil.getStartTickIndex(tickLowerIndex, tickSpacing)).publicKey,
          tickArrayUpper: public_1.PDAUtil.getTickArray(ctx.program.programId, whirlpoolKey, public_1.TickUtil.getStartTickIndex(tickUpperIndex, tickSpacing)).publicKey
        }));
      }
      if (task.collectionType === "fee") {
        if (!touchedMints.has(mintA)) {
          ixForPosition.push(resolvedAtas[mintA]);
          touchedMints.add(mintA);
        }
        if (!touchedMints.has(mintB)) {
          ixForPosition.push(resolvedAtas[mintB]);
          touchedMints.add(mintB);
        }
        const collectFeesBaseParams = {
          whirlpool: whirlpoolKey,
          position: new web3_js_1.PublicKey(task.positionAddr),
          positionAuthority,
          positionTokenAccount,
          tokenOwnerAccountA: resolvedAtas[mintA].address,
          tokenOwnerAccountB: resolvedAtas[mintB].address,
          tokenVaultA: whirlpool.tokenVaultA,
          tokenVaultB: whirlpool.tokenVaultB
        };
        ixForPosition.push(!token_extension_util_1.TokenExtensionUtil.isV2IxRequiredPool(tokenExtensionCtx) ? ix_1.WhirlpoolIx.collectFeesIx(ctx.program, collectFeesBaseParams) : ix_1.WhirlpoolIx.collectFeesV2Ix(ctx.program, {
          ...collectFeesBaseParams,
          tokenMintA: tokenExtensionCtx.tokenMintWithProgramA.address,
          tokenMintB: tokenExtensionCtx.tokenMintWithProgramB.address,
          tokenProgramA: tokenExtensionCtx.tokenMintWithProgramA.tokenProgram,
          tokenProgramB: tokenExtensionCtx.tokenMintWithProgramB.tokenProgram,
          ...await token_extension_util_1.TokenExtensionUtil.getExtraAccountMetasForTransferHookForPool(ctx.connection, tokenExtensionCtx, collectFeesBaseParams.tokenVaultA, collectFeesBaseParams.tokenOwnerAccountA, collectFeesBaseParams.whirlpool, collectFeesBaseParams.tokenVaultB, collectFeesBaseParams.tokenOwnerAccountB, collectFeesBaseParams.whirlpool)
        }));
      } else {
        const index = task.rewardIndex;
        const rewardInfo = whirlpool.rewardInfos[index];
        const mintReward = rewardInfo.mint.toBase58();
        if (!touchedMints.has(mintReward)) {
          ixForPosition.push(resolvedAtas[mintReward]);
          touchedMints.add(mintReward);
        }
        const collectRewardBaseParams = {
          whirlpool: whirlpoolKey,
          position: new web3_js_1.PublicKey(task.positionAddr),
          positionAuthority,
          positionTokenAccount,
          rewardIndex: index,
          rewardOwnerAccount: resolvedAtas[mintReward].address,
          rewardVault: rewardInfo.vault
        };
        ixForPosition.push(!token_extension_util_1.TokenExtensionUtil.isV2IxRequiredReward(tokenExtensionCtx, index) ? ix_1.WhirlpoolIx.collectRewardIx(ctx.program, collectRewardBaseParams) : ix_1.WhirlpoolIx.collectRewardV2Ix(ctx.program, {
          ...collectRewardBaseParams,
          rewardMint: tokenExtensionCtx.rewardTokenMintsWithProgram[index].address,
          rewardTokenProgram: tokenExtensionCtx.rewardTokenMintsWithProgram[index].tokenProgram,
          rewardTransferHookAccounts: await token_extension_util_1.TokenExtensionUtil.getExtraAccountMetasForTransferHook(ctx.connection, tokenExtensionCtx.rewardTokenMintsWithProgram[index], collectRewardBaseParams.rewardVault, collectRewardBaseParams.rewardOwnerAccount, collectRewardBaseParams.whirlpool)
        }));
      }
      return ixForPosition;
    };
  }
});

// node_modules/@orca-so/whirlpools-sdk/dist/utils/remaining-accounts-util.js
var require_remaining_accounts_util = __commonJS({
  "node_modules/@orca-so/whirlpools-sdk/dist/utils/remaining-accounts-util.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RemainingAccountsBuilder = exports2.RemainingAccountsType = void 0;
    exports2.toSupplementalTickArrayAccountMetas = toSupplementalTickArrayAccountMetas;
    var tiny_invariant_1 = __importDefault(require_tiny_invariant_cjs());
    var public_1 = require_public();
    var RemainingAccountsType;
    (function(RemainingAccountsType2) {
      RemainingAccountsType2["TransferHookA"] = "transferHookA";
      RemainingAccountsType2["TransferHookB"] = "transferHookB";
      RemainingAccountsType2["TransferHookReward"] = "transferHookReward";
      RemainingAccountsType2["TransferHookInput"] = "transferHookInput";
      RemainingAccountsType2["TransferHookIntermediate"] = "transferHookIntermediate";
      RemainingAccountsType2["TransferHookOutput"] = "transferHookOutput";
      RemainingAccountsType2["SupplementalTickArrays"] = "supplementalTickArrays";
      RemainingAccountsType2["SupplementalTickArraysOne"] = "supplementalTickArraysOne";
      RemainingAccountsType2["SupplementalTickArraysTwo"] = "supplementalTickArraysTwo";
    })(RemainingAccountsType || (exports2.RemainingAccountsType = RemainingAccountsType = {}));
    var RemainingAccountsBuilder = class {
      remainingAccounts = [];
      slices = [];
      addSlice(accountsType, accounts) {
        if (!accounts || accounts.length === 0)
          return this;
        this.slices.push({
          accountsType: { [accountsType]: {} },
          length: accounts.length
        });
        this.remainingAccounts.push(...accounts);
        return this;
      }
      build() {
        return this.slices.length === 0 ? [null, void 0] : [{ slices: this.slices }, this.remainingAccounts];
      }
    };
    exports2.RemainingAccountsBuilder = RemainingAccountsBuilder;
    function toSupplementalTickArrayAccountMetas(tickArrayPubkeys) {
      if (!tickArrayPubkeys)
        return void 0;
      (0, tiny_invariant_1.default)(tickArrayPubkeys.length <= public_1.MAX_SUPPLEMENTAL_TICK_ARRAYS, "Too many supplemental tick arrays provided");
      return tickArrayPubkeys.map((pubkey) => ({
        pubkey,
        isWritable: true,
        isSigner: false
      }));
    }
  }
});

// node_modules/@orca-so/whirlpools-sdk/dist/instructions/v2/collect-fees-ix.js
var require_collect_fees_ix2 = __commonJS({
  "node_modules/@orca-so/whirlpools-sdk/dist/instructions/v2/collect-fees-ix.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.collectFeesV2Ix = collectFeesV2Ix;
    var __1 = require_dist3();
    var remaining_accounts_util_1 = require_remaining_accounts_util();
    function collectFeesV2Ix(program, params) {
      const { whirlpool, positionAuthority, position, positionTokenAccount, tokenMintA, tokenMintB, tokenOwnerAccountA, tokenOwnerAccountB, tokenVaultA, tokenVaultB, tokenTransferHookAccountsA, tokenTransferHookAccountsB, tokenProgramA, tokenProgramB } = params;
      const [remainingAccountsInfo, remainingAccounts] = new remaining_accounts_util_1.RemainingAccountsBuilder().addSlice(remaining_accounts_util_1.RemainingAccountsType.TransferHookA, tokenTransferHookAccountsA).addSlice(remaining_accounts_util_1.RemainingAccountsType.TransferHookB, tokenTransferHookAccountsB).build();
      const ix = program.instruction.collectFeesV2(remainingAccountsInfo, {
        accounts: {
          whirlpool,
          positionAuthority,
          position,
          positionTokenAccount,
          tokenMintA,
          tokenMintB,
          tokenOwnerAccountA,
          tokenOwnerAccountB,
          tokenVaultA,
          tokenVaultB,
          tokenProgramA,
          tokenProgramB,
          memoProgram: __1.MEMO_PROGRAM_ADDRESS
        },
        remainingAccounts
      });
      return {
        instructions: [ix],
        cleanupInstructions: [],
        signers: []
      };
    }
  }
});

// node_modules/@orca-so/whirlpools-sdk/dist/instructions/v2/collect-protocol-fees-ix.js
var require_collect_protocol_fees_ix2 = __commonJS({
  "node_modules/@orca-so/whirlpools-sdk/dist/instructions/v2/collect-protocol-fees-ix.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.collectProtocolFeesV2Ix = collectProtocolFeesV2Ix;
    var __1 = require_dist3();
    var remaining_accounts_util_1 = require_remaining_accounts_util();
    function collectProtocolFeesV2Ix(program, params) {
      const { whirlpoolsConfig, whirlpool, collectProtocolFeesAuthority, tokenMintA, tokenMintB, tokenVaultA, tokenVaultB, tokenTransferHookAccountsA, tokenTransferHookAccountsB, tokenOwnerAccountA: tokenDestinationA, tokenOwnerAccountB: tokenDestinationB, tokenProgramA, tokenProgramB } = params;
      const [remainingAccountsInfo, remainingAccounts] = new remaining_accounts_util_1.RemainingAccountsBuilder().addSlice(remaining_accounts_util_1.RemainingAccountsType.TransferHookA, tokenTransferHookAccountsA).addSlice(remaining_accounts_util_1.RemainingAccountsType.TransferHookB, tokenTransferHookAccountsB).build();
      const ix = program.instruction.collectProtocolFeesV2(remainingAccountsInfo, {
        accounts: {
          whirlpoolsConfig,
          whirlpool,
          collectProtocolFeesAuthority,
          tokenMintA,
          tokenMintB,
          tokenVaultA,
          tokenVaultB,
          tokenDestinationA,
          tokenDestinationB,
          tokenProgramA,
          tokenProgramB,
          memoProgram: __1.MEMO_PROGRAM_ADDRESS
        },
        remainingAccounts
      });
      return {
        instructions: [ix],
        cleanupInstructions: [],
        signers: []
      };
    }
  }
});

// node_modules/@orca-so/whirlpools-sdk/dist/instructions/v2/collect-reward-ix.js
var require_collect_reward_ix2 = __commonJS({
  "node_modules/@orca-so/whirlpools-sdk/dist/instructions/v2/collect-reward-ix.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.collectRewardV2Ix = collectRewardV2Ix;
    var __1 = require_dist3();
    var remaining_accounts_util_1 = require_remaining_accounts_util();
    function collectRewardV2Ix(program, params) {
      const { whirlpool, positionAuthority, position, positionTokenAccount, rewardMint, rewardOwnerAccount, rewardVault, rewardTransferHookAccounts, rewardIndex, rewardTokenProgram } = params;
      const [remainingAccountsInfo, remainingAccounts] = new remaining_accounts_util_1.RemainingAccountsBuilder().addSlice(remaining_accounts_util_1.RemainingAccountsType.TransferHookReward, rewardTransferHookAccounts).build();
      const ix = program.instruction.collectRewardV2(rewardIndex, remainingAccountsInfo, {
        accounts: {
          whirlpool,
          positionAuthority,
          position,
          positionTokenAccount,
          rewardMint,
          rewardOwnerAccount,
          rewardVault,
          rewardTokenProgram,
          memoProgram: __1.MEMO_PROGRAM_ADDRESS
        },
        remainingAccounts
      });
      return {
        instructions: [ix],
        cleanupInstructions: [],
        signers: []
      };
    }
  }
});

// node_modules/@orca-so/whirlpools-sdk/dist/instructions/v2/decrease-liquidity-ix.js
var require_decrease_liquidity_ix = __commonJS({
  "node_modules/@orca-so/whirlpools-sdk/dist/instructions/v2/decrease-liquidity-ix.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.decreaseLiquidityV2Ix = decreaseLiquidityV2Ix;
    var __1 = require_dist3();
    var remaining_accounts_util_1 = require_remaining_accounts_util();
    function decreaseLiquidityV2Ix(program, params) {
      const { liquidityAmount, tokenMinA, tokenMinB, whirlpool, positionAuthority, position, positionTokenAccount, tokenMintA, tokenMintB, tokenOwnerAccountA, tokenOwnerAccountB, tokenVaultA, tokenVaultB, tokenTransferHookAccountsA, tokenTransferHookAccountsB, tokenProgramA, tokenProgramB, tickArrayLower, tickArrayUpper } = params;
      const [remainingAccountsInfo, remainingAccounts] = new remaining_accounts_util_1.RemainingAccountsBuilder().addSlice(remaining_accounts_util_1.RemainingAccountsType.TransferHookA, tokenTransferHookAccountsA).addSlice(remaining_accounts_util_1.RemainingAccountsType.TransferHookB, tokenTransferHookAccountsB).build();
      const ix = program.instruction.decreaseLiquidityV2(liquidityAmount, tokenMinA, tokenMinB, remainingAccountsInfo, {
        accounts: {
          whirlpool,
          positionAuthority,
          position,
          positionTokenAccount,
          tokenMintA,
          tokenMintB,
          tokenOwnerAccountA,
          tokenOwnerAccountB,
          tokenVaultA,
          tokenVaultB,
          tokenProgramA,
          tokenProgramB,
          tickArrayLower,
          tickArrayUpper,
          memoProgram: __1.MEMO_PROGRAM_ADDRESS
        },
        remainingAccounts
      });
      return {
        instructions: [ix],
        cleanupInstructions: [],
        signers: []
      };
    }
  }
});

// node_modules/@orca-so/whirlpools-sdk/dist/instructions/v2/increase-liquidity-ix.js
var require_increase_liquidity_ix = __commonJS({
  "node_modules/@orca-so/whirlpools-sdk/dist/instructions/v2/increase-liquidity-ix.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.increaseLiquidityV2Ix = increaseLiquidityV2Ix;
    var __1 = require_dist3();
    var remaining_accounts_util_1 = require_remaining_accounts_util();
    function increaseLiquidityV2Ix(program, params) {
      const { liquidityAmount, tokenMaxA, tokenMaxB, whirlpool, positionAuthority, position, positionTokenAccount, tokenMintA, tokenMintB, tokenOwnerAccountA, tokenOwnerAccountB, tokenVaultA, tokenVaultB, tokenTransferHookAccountsA, tokenTransferHookAccountsB, tokenProgramA, tokenProgramB, tickArrayLower, tickArrayUpper } = params;
      const [remainingAccountsInfo, remainingAccounts] = new remaining_accounts_util_1.RemainingAccountsBuilder().addSlice(remaining_accounts_util_1.RemainingAccountsType.TransferHookA, tokenTransferHookAccountsA).addSlice(remaining_accounts_util_1.RemainingAccountsType.TransferHookB, tokenTransferHookAccountsB).build();
      const ix = program.instruction.increaseLiquidityV2(liquidityAmount, tokenMaxA, tokenMaxB, remainingAccountsInfo, {
        accounts: {
          whirlpool,
          positionAuthority,
          position,
          positionTokenAccount,
          tokenMintA,
          tokenMintB,
          tokenOwnerAccountA,
          tokenOwnerAccountB,
          tokenVaultA,
          tokenVaultB,
          tokenProgramA,
          tokenProgramB,
          tickArrayLower,
          tickArrayUpper,
          memoProgram: __1.MEMO_PROGRAM_ADDRESS
        },
        remainingAccounts
      });
      return {
        instructions: [ix],
        cleanupInstructions: [],
        signers: []
      };
    }
  }
});

// node_modules/@orca-so/whirlpools-sdk/dist/instructions/v2/initialize-pool-ix.js
var require_initialize_pool_ix = __commonJS({
  "node_modules/@orca-so/whirlpools-sdk/dist/instructions/v2/initialize-pool-ix.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.initializePoolV2Ix = initializePoolV2Ix;
    var web3_js_1 = require("@solana/web3.js");
    function initializePoolV2Ix(program, params) {
      const { initSqrtPrice, tokenMintA, tokenMintB, tokenBadgeA, tokenBadgeB, tokenProgramA, tokenProgramB, whirlpoolsConfig, whirlpoolPda, feeTierKey, tokenVaultAKeypair, tokenVaultBKeypair, tickSpacing, funder } = params;
      const ix = program.instruction.initializePoolV2(tickSpacing, initSqrtPrice, {
        accounts: {
          whirlpoolsConfig,
          tokenMintA,
          tokenMintB,
          tokenBadgeA,
          tokenBadgeB,
          funder,
          whirlpool: whirlpoolPda.publicKey,
          tokenVaultA: tokenVaultAKeypair.publicKey,
          tokenVaultB: tokenVaultBKeypair.publicKey,
          feeTier: feeTierKey,
          systemProgram: web3_js_1.SystemProgram.programId,
          tokenProgramA,
          tokenProgramB,
          rent: web3_js_1.SYSVAR_RENT_PUBKEY
        }
      });
      return {
        instructions: [ix],
        cleanupInstructions: [],
        signers: [tokenVaultAKeypair, tokenVaultBKeypair]
      };
    }
  }
});

// node_modules/@orca-so/whirlpools-sdk/dist/instructions/v2/initialize-reward-ix.js
var require_initialize_reward_ix = __commonJS({
  "node_modules/@orca-so/whirlpools-sdk/dist/instructions/v2/initialize-reward-ix.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || /* @__PURE__ */ function() {
      var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2)
            if (Object.prototype.hasOwnProperty.call(o2, k))
              ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      };
      return function(mod2) {
        if (mod2 && mod2.__esModule)
          return mod2;
        var result = {};
        if (mod2 != null) {
          for (var k = ownKeys(mod2), i = 0; i < k.length; i++)
            if (k[i] !== "default")
              __createBinding(result, mod2, k[i]);
        }
        __setModuleDefault(result, mod2);
        return result;
      };
    }();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.initializeRewardV2Ix = initializeRewardV2Ix;
    var anchor = __importStar(require("@coral-xyz/anchor"));
    var web3_js_1 = require("@solana/web3.js");
    function initializeRewardV2Ix(program, params) {
      const { rewardAuthority, funder, whirlpool, rewardMint, rewardTokenBadge, rewardVaultKeypair, rewardIndex, rewardTokenProgram } = params;
      const ix = program.instruction.initializeRewardV2(rewardIndex, {
        accounts: {
          rewardAuthority,
          funder,
          whirlpool,
          rewardMint,
          rewardTokenBadge,
          rewardVault: rewardVaultKeypair.publicKey,
          rewardTokenProgram,
          systemProgram: web3_js_1.SystemProgram.programId,
          rent: anchor.web3.SYSVAR_RENT_PUBKEY
        }
      });
      return {
        instructions: [ix],
        cleanupInstructions: [],
        signers: [rewardVaultKeypair]
      };
    }
  }
});

// node_modules/@orca-so/whirlpools-sdk/dist/instructions/v2/set-reward-emissions-ix.js
var require_set_reward_emissions_ix = __commonJS({
  "node_modules/@orca-so/whirlpools-sdk/dist/instructions/v2/set-reward-emissions-ix.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.setRewardEmissionsV2Ix = setRewardEmissionsV2Ix;
    function setRewardEmissionsV2Ix(program, params) {
      const { rewardAuthority, whirlpool, rewardIndex, rewardVaultKey: rewardVault, emissionsPerSecondX64 } = params;
      const ix = program.instruction.setRewardEmissionsV2(rewardIndex, emissionsPerSecondX64, {
        accounts: {
          rewardAuthority,
          whirlpool,
          rewardVault
        }
      });
      return {
        instructions: [ix],
        cleanupInstructions: [],
        signers: []
      };
    }
  }
});

// node_modules/@orca-so/whirlpools-sdk/dist/instructions/v2/swap-ix.js
var require_swap_ix = __commonJS({
  "node_modules/@orca-so/whirlpools-sdk/dist/instructions/v2/swap-ix.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.swapV2Ix = swapV2Ix;
    var public_1 = require_public();
    var remaining_accounts_util_1 = require_remaining_accounts_util();
    function swapV2Ix(program, params) {
      const { amount, otherAmountThreshold, sqrtPriceLimit, amountSpecifiedIsInput, aToB, whirlpool, tokenAuthority, tokenMintA, tokenMintB, tokenOwnerAccountA, tokenVaultA, tokenOwnerAccountB, tokenVaultB, tokenTransferHookAccountsA, tokenTransferHookAccountsB, tokenProgramA, tokenProgramB, tickArray0, tickArray1, tickArray2, oracle, supplementalTickArrays } = params;
      const [remainingAccountsInfo, remainingAccounts] = new remaining_accounts_util_1.RemainingAccountsBuilder().addSlice(remaining_accounts_util_1.RemainingAccountsType.TransferHookA, tokenTransferHookAccountsA).addSlice(remaining_accounts_util_1.RemainingAccountsType.TransferHookB, tokenTransferHookAccountsB).addSlice(remaining_accounts_util_1.RemainingAccountsType.SupplementalTickArrays, (0, remaining_accounts_util_1.toSupplementalTickArrayAccountMetas)(supplementalTickArrays)).build();
      const ix = program.instruction.swapV2(amount, otherAmountThreshold, sqrtPriceLimit, amountSpecifiedIsInput, aToB, remainingAccountsInfo, {
        accounts: {
          tokenProgramA,
          tokenProgramB,
          memoProgram: public_1.MEMO_PROGRAM_ADDRESS,
          tokenAuthority,
          whirlpool,
          tokenMintA,
          tokenMintB,
          tokenOwnerAccountA,
          tokenVaultA,
          tokenOwnerAccountB,
          tokenVaultB,
          tickArray0,
          tickArray1,
          tickArray2,
          oracle
        },
        remainingAccounts
      });
      return {
        instructions: [ix],
        cleanupInstructions: [],
        signers: []
      };
    }
  }
});

// node_modules/@orca-so/whirlpools-sdk/dist/instructions/v2/two-hop-swap-ix.js
var require_two_hop_swap_ix = __commonJS({
  "node_modules/@orca-so/whirlpools-sdk/dist/instructions/v2/two-hop-swap-ix.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.twoHopSwapV2Ix = twoHopSwapV2Ix;
    var public_1 = require_public();
    var remaining_accounts_util_1 = require_remaining_accounts_util();
    function twoHopSwapV2Ix(program, params) {
      const { amount, otherAmountThreshold, amountSpecifiedIsInput, aToBOne, aToBTwo, sqrtPriceLimitOne, sqrtPriceLimitTwo, whirlpoolOne, whirlpoolTwo, tokenMintInput, tokenMintIntermediate, tokenMintOutput, tokenProgramInput, tokenProgramIntermediate, tokenProgramOutput, tokenVaultOneInput, tokenVaultOneIntermediate, tokenVaultTwoIntermediate, tokenVaultTwoOutput, tokenAuthority, tokenTransferHookAccountsInput, tokenTransferHookAccountsIntermediate, tokenTransferHookAccountsOutput, tokenOwnerAccountInput, tokenOwnerAccountOutput, tickArrayOne0, tickArrayOne1, tickArrayOne2, tickArrayTwo0, tickArrayTwo1, tickArrayTwo2, oracleOne, oracleTwo, supplementalTickArraysOne, supplementalTickArraysTwo } = params;
      const [remainingAccountsInfo, remainingAccounts] = new remaining_accounts_util_1.RemainingAccountsBuilder().addSlice(remaining_accounts_util_1.RemainingAccountsType.TransferHookInput, tokenTransferHookAccountsInput).addSlice(remaining_accounts_util_1.RemainingAccountsType.TransferHookIntermediate, tokenTransferHookAccountsIntermediate).addSlice(remaining_accounts_util_1.RemainingAccountsType.TransferHookOutput, tokenTransferHookAccountsOutput).addSlice(remaining_accounts_util_1.RemainingAccountsType.SupplementalTickArraysOne, (0, remaining_accounts_util_1.toSupplementalTickArrayAccountMetas)(supplementalTickArraysOne)).addSlice(remaining_accounts_util_1.RemainingAccountsType.SupplementalTickArraysTwo, (0, remaining_accounts_util_1.toSupplementalTickArrayAccountMetas)(supplementalTickArraysTwo)).build();
      const ix = program.instruction.twoHopSwapV2(amount, otherAmountThreshold, amountSpecifiedIsInput, aToBOne, aToBTwo, sqrtPriceLimitOne, sqrtPriceLimitTwo, remainingAccountsInfo, {
        accounts: {
          whirlpoolOne,
          whirlpoolTwo,
          tokenMintInput,
          tokenMintIntermediate,
          tokenMintOutput,
          tokenProgramInput,
          tokenProgramIntermediate,
          tokenProgramOutput,
          tokenOwnerAccountInput,
          tokenVaultOneInput,
          tokenVaultOneIntermediate,
          tokenVaultTwoIntermediate,
          tokenVaultTwoOutput,
          tokenOwnerAccountOutput,
          tokenAuthority,
          tickArrayOne0,
          tickArrayOne1,
          tickArrayOne2,
          tickArrayTwo0,
          tickArrayTwo1,
          tickArrayTwo2,
          oracleOne,
          oracleTwo,
          memoProgram: public_1.MEMO_PROGRAM_ADDRESS
        },
        remainingAccounts
      });
      return {
        instructions: [ix],
        cleanupInstructions: [],
        signers: []
      };
    }
  }
});

// node_modules/@orca-so/whirlpools-sdk/dist/instructions/v2/initialize-config-extension-ix.js
var require_initialize_config_extension_ix = __commonJS({
  "node_modules/@orca-so/whirlpools-sdk/dist/instructions/v2/initialize-config-extension-ix.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.initializeConfigExtensionIx = initializeConfigExtensionIx;
    var web3_js_1 = require("@solana/web3.js");
    function initializeConfigExtensionIx(program, params) {
      const { whirlpoolsConfig, whirlpoolsConfigExtensionPda, funder, feeAuthority } = params;
      const ix = program.instruction.initializeConfigExtension({
        accounts: {
          config: whirlpoolsConfig,
          configExtension: whirlpoolsConfigExtensionPda.publicKey,
          funder,
          feeAuthority,
          systemProgram: web3_js_1.SystemProgram.programId
        }
      });
      return {
        instructions: [ix],
        cleanupInstructions: [],
        signers: []
      };
    }
  }
});

// node_modules/@orca-so/whirlpools-sdk/dist/instructions/v2/set-config-extension-authority-ix.js
var require_set_config_extension_authority_ix = __commonJS({
  "node_modules/@orca-so/whirlpools-sdk/dist/instructions/v2/set-config-extension-authority-ix.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.setConfigExtensionAuthorityIx = setConfigExtensionAuthorityIx;
    function setConfigExtensionAuthorityIx(program, params) {
      const { whirlpoolsConfig, whirlpoolsConfigExtension, configExtensionAuthority, newConfigExtensionAuthority } = params;
      const ix = program.instruction.setConfigExtensionAuthority({
        accounts: {
          whirlpoolsConfig,
          whirlpoolsConfigExtension,
          configExtensionAuthority,
          newConfigExtensionAuthority
        }
      });
      return {
        instructions: [ix],
        cleanupInstructions: [],
        signers: []
      };
    }
  }
});

// node_modules/@orca-so/whirlpools-sdk/dist/instructions/v2/set-token-badge-authority-ix.js
var require_set_token_badge_authority_ix = __commonJS({
  "node_modules/@orca-so/whirlpools-sdk/dist/instructions/v2/set-token-badge-authority-ix.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.setTokenBadgeAuthorityIx = setTokenBadgeAuthorityIx;
    function setTokenBadgeAuthorityIx(program, params) {
      const { whirlpoolsConfig, whirlpoolsConfigExtension, configExtensionAuthority, newTokenBadgeAuthority } = params;
      const ix = program.instruction.setTokenBadgeAuthority({
        accounts: {
          whirlpoolsConfig,
          whirlpoolsConfigExtension,
          configExtensionAuthority,
          newTokenBadgeAuthority
        }
      });
      return {
        instructions: [ix],
        cleanupInstructions: [],
        signers: []
      };
    }
  }
});

// node_modules/@orca-so/whirlpools-sdk/dist/instructions/v2/initialize-token-badge-ix.js
var require_initialize_token_badge_ix = __commonJS({
  "node_modules/@orca-so/whirlpools-sdk/dist/instructions/v2/initialize-token-badge-ix.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.initializeTokenBadgeIx = initializeTokenBadgeIx;
    var web3_js_1 = require("@solana/web3.js");
    function initializeTokenBadgeIx(program, params) {
      const { whirlpoolsConfig, whirlpoolsConfigExtension, tokenBadgeAuthority, tokenMint, tokenBadgePda, funder } = params;
      const ix = program.instruction.initializeTokenBadge({
        accounts: {
          whirlpoolsConfig,
          whirlpoolsConfigExtension,
          tokenBadgeAuthority,
          tokenMint,
          tokenBadge: tokenBadgePda.publicKey,
          funder,
          systemProgram: web3_js_1.SystemProgram.programId
        }
      });
      return {
        instructions: [ix],
        cleanupInstructions: [],
        signers: []
      };
    }
  }
});

// node_modules/@orca-so/whirlpools-sdk/dist/instructions/v2/delete-token-badge-ix.js
var require_delete_token_badge_ix = __commonJS({
  "node_modules/@orca-so/whirlpools-sdk/dist/instructions/v2/delete-token-badge-ix.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.deleteTokenBadgeIx = deleteTokenBadgeIx;
    function deleteTokenBadgeIx(program, params) {
      const { whirlpoolsConfig, whirlpoolsConfigExtension, tokenBadgeAuthority, tokenMint, tokenBadge, receiver } = params;
      const ix = program.instruction.deleteTokenBadge({
        accounts: {
          whirlpoolsConfig,
          whirlpoolsConfigExtension,
          tokenBadgeAuthority,
          tokenMint,
          tokenBadge,
          receiver
        }
      });
      return {
        instructions: [ix],
        cleanupInstructions: [],
        signers: []
      };
    }
  }
});

// node_modules/@orca-so/whirlpools-sdk/dist/instructions/v2/index.js
var require_v2 = __commonJS({
  "node_modules/@orca-so/whirlpools-sdk/dist/instructions/v2/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_collect_fees_ix2(), exports2);
    __exportStar(require_collect_protocol_fees_ix2(), exports2);
    __exportStar(require_collect_reward_ix2(), exports2);
    __exportStar(require_decrease_liquidity_ix(), exports2);
    __exportStar(require_increase_liquidity_ix(), exports2);
    __exportStar(require_initialize_pool_ix(), exports2);
    __exportStar(require_initialize_reward_ix(), exports2);
    __exportStar(require_set_reward_emissions_ix(), exports2);
    __exportStar(require_swap_ix(), exports2);
    __exportStar(require_two_hop_swap_ix(), exports2);
    __exportStar(require_initialize_config_extension_ix(), exports2);
    __exportStar(require_set_config_extension_authority_ix(), exports2);
    __exportStar(require_set_token_badge_authority_ix(), exports2);
    __exportStar(require_initialize_token_badge_ix(), exports2);
    __exportStar(require_delete_token_badge_ix(), exports2);
  }
});

// node_modules/@orca-so/whirlpools-sdk/dist/instructions/composites/collect-protocol-fees.js
var require_collect_protocol_fees = __commonJS({
  "node_modules/@orca-so/whirlpools-sdk/dist/instructions/composites/collect-protocol-fees.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.collectProtocolFees = collectProtocolFees;
    var common_sdk_1 = require_dist2();
    var spl_token_1 = require_cjs3();
    var web3_js_1 = require("@solana/web3.js");
    var fetcher_1 = require_fetcher2();
    var whirlpool_ata_utils_1 = require_whirlpool_ata_utils();
    var collect_protocol_fees_ix_1 = require_collect_protocol_fees_ix();
    var token_extension_util_1 = require_token_extension_util();
    var v2_1 = require_v2();
    async function collectProtocolFees(ctx, poolAddresses) {
      const receiverKey = ctx.wallet.publicKey;
      const payerKey = ctx.wallet.publicKey;
      const whirlpoolDatas = Array.from((await ctx.fetcher.getPools(poolAddresses, fetcher_1.PREFER_CACHE)).values());
      const mints = (0, whirlpool_ata_utils_1.getTokenMintsFromWhirlpools)(whirlpoolDatas, whirlpool_ata_utils_1.TokenMintTypes.POOL_ONLY).mintMap;
      await ctx.fetcher.getMintInfos(mints);
      const accountExemption = await ctx.fetcher.getAccountRentExempt();
      const { ataTokenAddresses, resolveAtaIxs } = await (0, whirlpool_ata_utils_1.resolveAtaForMints)(ctx, {
        mints,
        accountExemption,
        receiver: receiverKey,
        payer: payerKey
      });
      const latestBlockhash = await ctx.connection.getLatestBlockhash();
      let txBuilder = new common_sdk_1.TransactionBuilder(ctx.connection, ctx.wallet, ctx.txBuilderOpts).addInstructions(resolveAtaIxs);
      const instructions = [];
      for (const poolAddress of poolAddresses) {
        const pool = await ctx.fetcher.getPool(poolAddress);
        if (!pool) {
          throw new Error(`Pool not found: ${poolAddress}`);
        }
        const poolConfig = await ctx.fetcher.getConfig(pool.whirlpoolsConfig);
        if (!poolConfig) {
          throw new Error(`Config not found: ${pool.whirlpoolsConfig}`);
        }
        if (poolConfig.collectProtocolFeesAuthority.toBase58() !== ctx.wallet.publicKey.toBase58()) {
          throw new Error(`Wallet is not the collectProtocolFeesAuthority`);
        }
        const poolHandlesNativeMint = common_sdk_1.TokenUtil.isNativeMint(pool.tokenMintA) || common_sdk_1.TokenUtil.isNativeMint(pool.tokenMintB);
        const txBuilderHasNativeMint = !!ataTokenAddresses[spl_token_1.NATIVE_MINT.toBase58()];
        if (poolHandlesNativeMint && !txBuilderHasNativeMint) {
          (0, whirlpool_ata_utils_1.addNativeMintHandlingIx)(txBuilder, ataTokenAddresses, receiverKey, accountExemption, ctx.accountResolverOpts.createWrappedSolAccountMethod);
        }
        const tokenExtensionCtx = await token_extension_util_1.TokenExtensionUtil.buildTokenExtensionContext(ctx.fetcher, pool, fetcher_1.PREFER_CACHE);
        const baseParams = {
          whirlpoolsConfig: pool.whirlpoolsConfig,
          whirlpool: common_sdk_1.AddressUtil.toPubKey(poolAddress),
          tokenVaultA: pool.tokenVaultA,
          tokenVaultB: pool.tokenVaultB,
          tokenOwnerAccountA: ataTokenAddresses[pool.tokenMintA.toBase58()],
          tokenOwnerAccountB: ataTokenAddresses[pool.tokenMintB.toBase58()],
          collectProtocolFeesAuthority: poolConfig.collectProtocolFeesAuthority
        };
        instructions.push(!token_extension_util_1.TokenExtensionUtil.isV2IxRequiredPool(tokenExtensionCtx) ? (0, collect_protocol_fees_ix_1.collectProtocolFeesIx)(ctx.program, baseParams) : (0, v2_1.collectProtocolFeesV2Ix)(ctx.program, {
          ...baseParams,
          tokenMintA: tokenExtensionCtx.tokenMintWithProgramA.address,
          tokenMintB: tokenExtensionCtx.tokenMintWithProgramB.address,
          tokenProgramA: tokenExtensionCtx.tokenMintWithProgramA.tokenProgram,
          tokenProgramB: tokenExtensionCtx.tokenMintWithProgramB.tokenProgram,
          ...await token_extension_util_1.TokenExtensionUtil.getExtraAccountMetasForTransferHookForPool(ctx.connection, tokenExtensionCtx, baseParams.tokenVaultA, baseParams.tokenOwnerAccountA, baseParams.whirlpool, baseParams.tokenVaultB, baseParams.tokenOwnerAccountB, baseParams.whirlpool)
        }));
      }
      txBuilder.addInstructions(instructions);
      const txSize = await txBuilder.txnSize({ latestBlockhash });
      if (txSize > web3_js_1.PACKET_DATA_SIZE) {
        throw new Error(`Transaction size is too large: ${txSize}`);
      }
      return txBuilder;
    }
  }
});

// node_modules/@orca-so/whirlpools-sdk/dist/instructions/swap-ix.js
var require_swap_ix2 = __commonJS({
  "node_modules/@orca-so/whirlpools-sdk/dist/instructions/swap-ix.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.swapIx = swapIx;
    var spl_token_1 = require_cjs3();
    var tiny_invariant_1 = __importDefault(require_tiny_invariant_cjs());
    function swapIx(program, params) {
      const { amount, otherAmountThreshold, sqrtPriceLimit, amountSpecifiedIsInput, aToB, whirlpool, tokenAuthority, tokenOwnerAccountA, tokenVaultA, tokenOwnerAccountB, tokenVaultB, tickArray0, tickArray1, tickArray2, oracle } = params;
      const ix = program.instruction.swap(amount, otherAmountThreshold, sqrtPriceLimit, amountSpecifiedIsInput, aToB, {
        accounts: {
          tokenProgram: spl_token_1.TOKEN_PROGRAM_ID,
          tokenAuthority,
          whirlpool,
          tokenOwnerAccountA,
          tokenVaultA,
          tokenOwnerAccountB,
          tokenVaultB,
          tickArray0,
          tickArray1,
          tickArray2,
          oracle
        }
      });
      (0, tiny_invariant_1.default)(ix.keys[10].pubkey.equals(oracle));
      ix.keys[10].isWritable = true;
      return {
        instructions: [ix],
        cleanupInstructions: [],
        signers: []
      };
    }
  }
});

// node_modules/@orca-so/whirlpools-sdk/dist/instructions/composites/swap-async.js
var require_swap_async = __commonJS({
  "node_modules/@orca-so/whirlpools-sdk/dist/instructions/composites/swap-async.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.swapAsync = swapAsync;
    var common_sdk_1 = require_dist2();
    var __1 = require_dist3();
    var swap_ix_1 = require_swap_ix2();
    var token_extension_util_1 = require_token_extension_util();
    var v2_1 = require_v2();
    var spl_token_1 = require_cjs3();
    async function swapAsync(ctx, params, _opts) {
      const { wallet, whirlpool, swapInput } = params;
      const { aToB, amount, otherAmountThreshold, amountSpecifiedIsInput } = swapInput;
      const txBuilder = new common_sdk_1.TransactionBuilder(ctx.connection, ctx.wallet, ctx.txBuilderOpts);
      const data = whirlpool.getData();
      const inputTokenMint = aToB ? data.tokenMintA : data.tokenMintB;
      const maxInputAmount = amountSpecifiedIsInput ? amount : otherAmountThreshold;
      if (inputTokenMint.equals(spl_token_1.NATIVE_MINT) && maxInputAmount.eq(common_sdk_1.U64_MAX)) {
        throw new Error("Wrapping U64_MAX amount of SOL is not possible");
      }
      const [resolvedAtaA, resolvedAtaB] = await (0, common_sdk_1.resolveOrCreateATAs)(ctx.connection, wallet, [
        {
          tokenMint: data.tokenMintA,
          wrappedSolAmountIn: aToB ? maxInputAmount : common_sdk_1.ZERO
        },
        {
          tokenMint: data.tokenMintB,
          wrappedSolAmountIn: !aToB ? maxInputAmount : common_sdk_1.ZERO
        }
      ], () => ctx.fetcher.getAccountRentExempt(), void 0, true, ctx.accountResolverOpts.allowPDAOwnerAddress, ctx.accountResolverOpts.createWrappedSolAccountMethod);
      const { address: ataAKey, ...tokenOwnerAccountAIx } = resolvedAtaA;
      const { address: ataBKey, ...tokenOwnerAccountBIx } = resolvedAtaB;
      txBuilder.addInstructions([tokenOwnerAccountAIx, tokenOwnerAccountBIx]);
      const inputTokenAccount = aToB ? ataAKey : ataBKey;
      const outputTokenAccount = aToB ? ataBKey : ataAKey;
      const tokenExtensionCtx = await token_extension_util_1.TokenExtensionUtil.buildTokenExtensionContext(ctx.fetcher, data);
      const baseParams = __1.SwapUtils.getSwapParamsFromQuote(swapInput, ctx, whirlpool, inputTokenAccount, outputTokenAccount, wallet);
      return txBuilder.addInstruction(!token_extension_util_1.TokenExtensionUtil.isV2IxRequiredPool(tokenExtensionCtx) && !params.swapInput.supplementalTickArrays ? (0, swap_ix_1.swapIx)(ctx.program, baseParams) : (0, v2_1.swapV2Ix)(ctx.program, {
        ...baseParams,
        tokenMintA: tokenExtensionCtx.tokenMintWithProgramA.address,
        tokenMintB: tokenExtensionCtx.tokenMintWithProgramB.address,
        tokenProgramA: tokenExtensionCtx.tokenMintWithProgramA.tokenProgram,
        tokenProgramB: tokenExtensionCtx.tokenMintWithProgramB.tokenProgram,
        ...await token_extension_util_1.TokenExtensionUtil.getExtraAccountMetasForTransferHookForPool(ctx.connection, tokenExtensionCtx, baseParams.aToB ? baseParams.tokenOwnerAccountA : baseParams.tokenVaultA, baseParams.aToB ? baseParams.tokenVaultA : baseParams.tokenOwnerAccountA, baseParams.aToB ? baseParams.tokenAuthority : baseParams.whirlpool, baseParams.aToB ? baseParams.tokenVaultB : baseParams.tokenOwnerAccountB, baseParams.aToB ? baseParams.tokenOwnerAccountB : baseParams.tokenVaultB, baseParams.aToB ? baseParams.whirlpool : baseParams.tokenAuthority),
        supplementalTickArrays: params.swapInput.supplementalTickArrays
      }));
    }
  }
});

// node_modules/@orca-so/whirlpools-sdk/dist/instructions/composites/index.js
var require_composites = __commonJS({
  "node_modules/@orca-so/whirlpools-sdk/dist/instructions/composites/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_collect_all_txn(), exports2);
    __exportStar(require_collect_protocol_fees(), exports2);
    __exportStar(require_swap_async(), exports2);
  }
});

// node_modules/@orca-so/whirlpools-sdk/dist/instructions/decrease-liquidity-ix.js
var require_decrease_liquidity_ix2 = __commonJS({
  "node_modules/@orca-so/whirlpools-sdk/dist/instructions/decrease-liquidity-ix.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.decreaseLiquidityIx = decreaseLiquidityIx;
    var spl_token_1 = require_cjs3();
    function decreaseLiquidityIx(program, params) {
      const { liquidityAmount, tokenMinA, tokenMinB, whirlpool, positionAuthority, position, positionTokenAccount, tokenOwnerAccountA, tokenOwnerAccountB, tokenVaultA, tokenVaultB, tickArrayLower, tickArrayUpper } = params;
      const ix = program.instruction.decreaseLiquidity(liquidityAmount, tokenMinA, tokenMinB, {
        accounts: {
          whirlpool,
          tokenProgram: spl_token_1.TOKEN_PROGRAM_ID,
          positionAuthority,
          position,
          positionTokenAccount,
          tokenOwnerAccountA,
          tokenOwnerAccountB,
          tokenVaultA,
          tokenVaultB,
          tickArrayLower,
          tickArrayUpper
        }
      });
      return {
        instructions: [ix],
        cleanupInstructions: [],
        signers: []
      };
    }
  }
});

// node_modules/@orca-so/whirlpools-sdk/dist/instructions/delete-position-bundle-ix.js
var require_delete_position_bundle_ix = __commonJS({
  "node_modules/@orca-so/whirlpools-sdk/dist/instructions/delete-position-bundle-ix.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.deletePositionBundleIx = deletePositionBundleIx;
    var spl_token_1 = require_cjs3();
    function deletePositionBundleIx(program, params) {
      const { owner, positionBundle, positionBundleMint, positionBundleTokenAccount, receiver } = params;
      const ix = program.instruction.deletePositionBundle({
        accounts: {
          positionBundle,
          positionBundleMint,
          positionBundleTokenAccount,
          positionBundleOwner: owner,
          receiver,
          tokenProgram: spl_token_1.TOKEN_PROGRAM_ID
        }
      });
      return {
        instructions: [ix],
        cleanupInstructions: [],
        signers: []
      };
    }
  }
});

// node_modules/@orca-so/whirlpools-sdk/dist/instructions/increase-liquidity-ix.js
var require_increase_liquidity_ix2 = __commonJS({
  "node_modules/@orca-so/whirlpools-sdk/dist/instructions/increase-liquidity-ix.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.increaseLiquidityIx = increaseLiquidityIx;
    var spl_token_1 = require_cjs3();
    function increaseLiquidityIx(program, params) {
      const { liquidityAmount, tokenMaxA, tokenMaxB, whirlpool, positionAuthority, position, positionTokenAccount, tokenOwnerAccountA, tokenOwnerAccountB, tokenVaultA, tokenVaultB, tickArrayLower, tickArrayUpper } = params;
      const ix = program.instruction.increaseLiquidity(liquidityAmount, tokenMaxA, tokenMaxB, {
        accounts: {
          whirlpool,
          tokenProgram: spl_token_1.TOKEN_PROGRAM_ID,
          positionAuthority,
          position,
          positionTokenAccount,
          tokenOwnerAccountA,
          tokenOwnerAccountB,
          tokenVaultA,
          tokenVaultB,
          tickArrayLower,
          tickArrayUpper
        }
      });
      return {
        instructions: [ix],
        cleanupInstructions: [],
        signers: []
      };
    }
  }
});

// node_modules/@orca-so/whirlpools-sdk/dist/instructions/initialize-config-ix.js
var require_initialize_config_ix = __commonJS({
  "node_modules/@orca-so/whirlpools-sdk/dist/instructions/initialize-config-ix.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.initializeConfigIx = initializeConfigIx;
    var web3_js_1 = require("@solana/web3.js");
    function initializeConfigIx(program, params) {
      const { feeAuthority, collectProtocolFeesAuthority, rewardEmissionsSuperAuthority, defaultProtocolFeeRate, funder } = params;
      const ix = program.instruction.initializeConfig(feeAuthority, collectProtocolFeesAuthority, rewardEmissionsSuperAuthority, defaultProtocolFeeRate, {
        accounts: {
          config: params.whirlpoolsConfigKeypair.publicKey,
          funder,
          systemProgram: web3_js_1.SystemProgram.programId
        }
      });
      return {
        instructions: [ix],
        cleanupInstructions: [],
        signers: [params.whirlpoolsConfigKeypair]
      };
    }
  }
});

// node_modules/@orca-so/whirlpools-sdk/dist/instructions/initialize-fee-tier-ix.js
var require_initialize_fee_tier_ix = __commonJS({
  "node_modules/@orca-so/whirlpools-sdk/dist/instructions/initialize-fee-tier-ix.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.initializeFeeTierIx = initializeFeeTierIx;
    var web3_js_1 = require("@solana/web3.js");
    function initializeFeeTierIx(program, params) {
      const { feeTierPda, whirlpoolsConfig, tickSpacing, feeAuthority, defaultFeeRate, funder } = params;
      const ix = program.instruction.initializeFeeTier(tickSpacing, defaultFeeRate, {
        accounts: {
          config: whirlpoolsConfig,
          feeTier: feeTierPda.publicKey,
          feeAuthority,
          funder,
          systemProgram: web3_js_1.SystemProgram.programId
        }
      });
      return {
        instructions: [ix],
        cleanupInstructions: [],
        signers: []
      };
    }
  }
});

// node_modules/@orca-so/whirlpools-sdk/dist/instructions/initialize-pool-ix.js
var require_initialize_pool_ix2 = __commonJS({
  "node_modules/@orca-so/whirlpools-sdk/dist/instructions/initialize-pool-ix.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.initializePoolIx = initializePoolIx;
    var spl_token_1 = require_cjs3();
    var web3_js_1 = require("@solana/web3.js");
    function initializePoolIx(program, params) {
      const { initSqrtPrice, tokenMintA, tokenMintB, whirlpoolsConfig, whirlpoolPda, feeTierKey, tokenVaultAKeypair, tokenVaultBKeypair, tickSpacing, funder } = params;
      const whirlpoolBumps = {
        whirlpoolBump: whirlpoolPda.bump
      };
      const ix = program.instruction.initializePool(whirlpoolBumps, tickSpacing, initSqrtPrice, {
        accounts: {
          whirlpoolsConfig,
          tokenMintA,
          tokenMintB,
          funder,
          whirlpool: whirlpoolPda.publicKey,
          tokenVaultA: tokenVaultAKeypair.publicKey,
          tokenVaultB: tokenVaultBKeypair.publicKey,
          feeTier: feeTierKey,
          tokenProgram: spl_token_1.TOKEN_PROGRAM_ID,
          systemProgram: web3_js_1.SystemProgram.programId,
          rent: web3_js_1.SYSVAR_RENT_PUBKEY
        }
      });
      return {
        instructions: [ix],
        cleanupInstructions: [],
        signers: [tokenVaultAKeypair, tokenVaultBKeypair]
      };
    }
  }
});

// node_modules/@orca-so/whirlpools-sdk/dist/instructions/initialize-position-bundle-ix.js
var require_initialize_position_bundle_ix = __commonJS({
  "node_modules/@orca-so/whirlpools-sdk/dist/instructions/initialize-position-bundle-ix.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || /* @__PURE__ */ function() {
      var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2)
            if (Object.prototype.hasOwnProperty.call(o2, k))
              ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      };
      return function(mod2) {
        if (mod2 && mod2.__esModule)
          return mod2;
        var result = {};
        if (mod2 != null) {
          for (var k = ownKeys(mod2), i = 0; i < k.length; i++)
            if (k[i] !== "default")
              __createBinding(result, mod2, k[i]);
        }
        __setModuleDefault(result, mod2);
        return result;
      };
    }();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.initializePositionBundleIx = initializePositionBundleIx;
    exports2.initializePositionBundleWithMetadataIx = initializePositionBundleWithMetadataIx;
    var anchor = __importStar(require("@coral-xyz/anchor"));
    var spl_token_1 = require_cjs3();
    var web3_js_1 = require("@solana/web3.js");
    var __1 = require_dist3();
    function initializePositionBundleIx(program, params) {
      const { owner, positionBundlePda, positionBundleMintKeypair, positionBundleTokenAccount, funder } = params;
      const ix = program.instruction.initializePositionBundle({
        accounts: {
          positionBundle: positionBundlePda.publicKey,
          positionBundleMint: positionBundleMintKeypair.publicKey,
          positionBundleTokenAccount,
          positionBundleOwner: owner,
          funder,
          associatedTokenProgram: spl_token_1.ASSOCIATED_TOKEN_PROGRAM_ID,
          tokenProgram: spl_token_1.TOKEN_PROGRAM_ID,
          systemProgram: web3_js_1.SystemProgram.programId,
          rent: anchor.web3.SYSVAR_RENT_PUBKEY
        }
      });
      return {
        instructions: [ix],
        cleanupInstructions: [],
        signers: [positionBundleMintKeypair]
      };
    }
    function initializePositionBundleWithMetadataIx(program, params) {
      const { owner, positionBundlePda, positionBundleMintKeypair, positionBundleTokenAccount, positionBundleMetadataPda, funder } = params;
      const ix = program.instruction.initializePositionBundleWithMetadata({
        accounts: {
          positionBundle: positionBundlePda.publicKey,
          positionBundleMint: positionBundleMintKeypair.publicKey,
          positionBundleMetadata: positionBundleMetadataPda.publicKey,
          positionBundleTokenAccount,
          positionBundleOwner: owner,
          funder,
          associatedTokenProgram: spl_token_1.ASSOCIATED_TOKEN_PROGRAM_ID,
          tokenProgram: spl_token_1.TOKEN_PROGRAM_ID,
          systemProgram: web3_js_1.SystemProgram.programId,
          rent: anchor.web3.SYSVAR_RENT_PUBKEY,
          metadataProgram: __1.METADATA_PROGRAM_ADDRESS,
          metadataUpdateAuth: __1.WHIRLPOOL_NFT_UPDATE_AUTH
        }
      });
      return {
        instructions: [ix],
        cleanupInstructions: [],
        signers: [positionBundleMintKeypair]
      };
    }
  }
});

// node_modules/@orca-so/whirlpools-sdk/dist/instructions/initialize-reward-ix.js
var require_initialize_reward_ix2 = __commonJS({
  "node_modules/@orca-so/whirlpools-sdk/dist/instructions/initialize-reward-ix.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || /* @__PURE__ */ function() {
      var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2)
            if (Object.prototype.hasOwnProperty.call(o2, k))
              ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      };
      return function(mod2) {
        if (mod2 && mod2.__esModule)
          return mod2;
        var result = {};
        if (mod2 != null) {
          for (var k = ownKeys(mod2), i = 0; i < k.length; i++)
            if (k[i] !== "default")
              __createBinding(result, mod2, k[i]);
        }
        __setModuleDefault(result, mod2);
        return result;
      };
    }();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.initializeRewardIx = initializeRewardIx;
    var anchor = __importStar(require("@coral-xyz/anchor"));
    var spl_token_1 = require_cjs3();
    var web3_js_1 = require("@solana/web3.js");
    function initializeRewardIx(program, params) {
      const { rewardAuthority, funder, whirlpool, rewardMint, rewardVaultKeypair, rewardIndex } = params;
      const ix = program.instruction.initializeReward(rewardIndex, {
        accounts: {
          rewardAuthority,
          funder,
          whirlpool,
          rewardMint,
          rewardVault: rewardVaultKeypair.publicKey,
          tokenProgram: spl_token_1.TOKEN_PROGRAM_ID,
          systemProgram: web3_js_1.SystemProgram.programId,
          rent: anchor.web3.SYSVAR_RENT_PUBKEY
        }
      });
      return {
        instructions: [ix],
        cleanupInstructions: [],
        signers: [rewardVaultKeypair]
      };
    }
  }
});

// node_modules/@orca-so/whirlpools-sdk/dist/instructions/initialize-tick-array-ix.js
var require_initialize_tick_array_ix = __commonJS({
  "node_modules/@orca-so/whirlpools-sdk/dist/instructions/initialize-tick-array-ix.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || /* @__PURE__ */ function() {
      var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2)
            if (Object.prototype.hasOwnProperty.call(o2, k))
              ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      };
      return function(mod2) {
        if (mod2 && mod2.__esModule)
          return mod2;
        var result = {};
        if (mod2 != null) {
          for (var k = ownKeys(mod2), i = 0; i < k.length; i++)
            if (k[i] !== "default")
              __createBinding(result, mod2, k[i]);
        }
        __setModuleDefault(result, mod2);
        return result;
      };
    }();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.initTickArrayIx = initTickArrayIx;
    var anchor = __importStar(require("@coral-xyz/anchor"));
    function initTickArrayIx(program, params) {
      const { whirlpool, funder, tickArrayPda } = params;
      const ix = program.instruction.initializeTickArray(params.startTick, {
        accounts: {
          whirlpool,
          funder,
          tickArray: tickArrayPda.publicKey,
          systemProgram: anchor.web3.SystemProgram.programId
        }
      });
      return {
        instructions: [ix],
        cleanupInstructions: [],
        signers: []
      };
    }
  }
});

// node_modules/@orca-so/whirlpools-sdk/dist/instructions/lock-position.js
var require_lock_position = __commonJS({
  "node_modules/@orca-so/whirlpools-sdk/dist/instructions/lock-position.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.lockPositionIx = lockPositionIx;
    var spl_token_1 = require_cjs3();
    var web3_js_1 = require("@solana/web3.js");
    function lockPositionIx(program, params) {
      const ix = program.instruction.lockPosition(params.lockType, {
        accounts: {
          funder: params.funder,
          positionAuthority: params.positionAuthority,
          position: params.position,
          positionMint: params.positionMint,
          positionTokenAccount: params.positionTokenAccount,
          lockConfig: params.lockConfigPda.publicKey,
          whirlpool: params.whirlpool,
          token2022Program: spl_token_1.TOKEN_2022_PROGRAM_ID,
          systemProgram: web3_js_1.SystemProgram.programId
        }
      });
      return {
        instructions: [ix],
        cleanupInstructions: [],
        signers: []
      };
    }
  }
});

// node_modules/@orca-so/whirlpools-sdk/dist/instructions/open-bundled-position-ix.js
var require_open_bundled_position_ix = __commonJS({
  "node_modules/@orca-so/whirlpools-sdk/dist/instructions/open-bundled-position-ix.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || /* @__PURE__ */ function() {
      var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2)
            if (Object.prototype.hasOwnProperty.call(o2, k))
              ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      };
      return function(mod2) {
        if (mod2 && mod2.__esModule)
          return mod2;
        var result = {};
        if (mod2 != null) {
          for (var k = ownKeys(mod2), i = 0; i < k.length; i++)
            if (k[i] !== "default")
              __createBinding(result, mod2, k[i]);
        }
        __setModuleDefault(result, mod2);
        return result;
      };
    }();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.openBundledPositionIx = openBundledPositionIx;
    var anchor = __importStar(require("@coral-xyz/anchor"));
    var web3_js_1 = require("@solana/web3.js");
    function openBundledPositionIx(program, params) {
      const { whirlpool, bundledPositionPda, positionBundle, positionBundleTokenAccount, positionBundleAuthority, bundleIndex, tickLowerIndex, tickUpperIndex, funder } = params;
      const ix = program.instruction.openBundledPosition(bundleIndex, tickLowerIndex, tickUpperIndex, {
        accounts: {
          bundledPosition: bundledPositionPda.publicKey,
          positionBundle,
          positionBundleTokenAccount,
          positionBundleAuthority,
          whirlpool,
          funder,
          systemProgram: web3_js_1.SystemProgram.programId,
          rent: anchor.web3.SYSVAR_RENT_PUBKEY
        }
      });
      return {
        instructions: [ix],
        cleanupInstructions: [],
        signers: []
      };
    }
  }
});

// node_modules/@orca-so/whirlpools-sdk/dist/utils/instructions-util.js
var require_instructions_util = __commonJS({
  "node_modules/@orca-so/whirlpools-sdk/dist/utils/instructions-util.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || /* @__PURE__ */ function() {
      var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2)
            if (Object.prototype.hasOwnProperty.call(o2, k))
              ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      };
      return function(mod2) {
        if (mod2 && mod2.__esModule)
          return mod2;
        var result = {};
        if (mod2 != null) {
          for (var k = ownKeys(mod2), i = 0; i < k.length; i++)
            if (k[i] !== "default")
              __createBinding(result, mod2, k[i]);
        }
        __setModuleDefault(result, mod2);
        return result;
      };
    }();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.openPositionAccounts = openPositionAccounts;
    exports2.openPositionWithTokenExtensionsAccounts = openPositionWithTokenExtensionsAccounts;
    var anchor = __importStar(require("@coral-xyz/anchor"));
    var spl_token_1 = require_cjs3();
    var web3_js_1 = require("@solana/web3.js");
    function openPositionAccounts(params) {
      const { funder, owner, positionPda, positionMintAddress, positionTokenAccount: positionTokenAccountAddress, whirlpool: whirlpoolKey } = params;
      return {
        funder,
        owner,
        position: positionPda.publicKey,
        positionMint: positionMintAddress,
        positionTokenAccount: positionTokenAccountAddress,
        whirlpool: whirlpoolKey,
        tokenProgram: spl_token_1.TOKEN_PROGRAM_ID,
        systemProgram: web3_js_1.SystemProgram.programId,
        rent: anchor.web3.SYSVAR_RENT_PUBKEY,
        associatedTokenProgram: spl_token_1.ASSOCIATED_TOKEN_PROGRAM_ID
      };
    }
    function openPositionWithTokenExtensionsAccounts(params) {
      const { funder, owner, positionPda, positionMint, positionTokenAccount, whirlpool: whirlpoolKey } = params;
      return {
        funder,
        owner,
        position: positionPda.publicKey,
        positionMint,
        positionTokenAccount,
        whirlpool: whirlpoolKey,
        token2022Program: spl_token_1.TOKEN_2022_PROGRAM_ID,
        systemProgram: web3_js_1.SystemProgram.programId,
        associatedTokenProgram: spl_token_1.ASSOCIATED_TOKEN_PROGRAM_ID
      };
    }
  }
});

// node_modules/@orca-so/whirlpools-sdk/dist/instructions/open-position-ix.js
var require_open_position_ix = __commonJS({
  "node_modules/@orca-so/whirlpools-sdk/dist/instructions/open-position-ix.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.openPositionIx = openPositionIx;
    exports2.openPositionWithMetadataIx = openPositionWithMetadataIx;
    var __1 = require_dist3();
    var instructions_util_1 = require_instructions_util();
    function openPositionIx(program, params) {
      const { positionPda, tickLowerIndex, tickUpperIndex } = params;
      const bumps = {
        positionBump: positionPda.bump
      };
      const ix = program.instruction.openPosition(bumps, tickLowerIndex, tickUpperIndex, {
        accounts: (0, instructions_util_1.openPositionAccounts)(params)
      });
      return {
        instructions: [ix],
        cleanupInstructions: [],
        signers: []
      };
    }
    function openPositionWithMetadataIx(program, params) {
      const { positionPda, metadataPda, tickLowerIndex, tickUpperIndex } = params;
      const bumps = {
        positionBump: positionPda.bump,
        metadataBump: metadataPda.bump
      };
      const ix = program.instruction.openPositionWithMetadata(bumps, tickLowerIndex, tickUpperIndex, {
        accounts: {
          ...(0, instructions_util_1.openPositionAccounts)(params),
          positionMetadataAccount: metadataPda.publicKey,
          metadataProgram: __1.METADATA_PROGRAM_ADDRESS,
          metadataUpdateAuth: __1.WHIRLPOOL_NFT_UPDATE_AUTH
        }
      });
      return {
        instructions: [ix],
        cleanupInstructions: [],
        signers: []
      };
    }
  }
});

// node_modules/@orca-so/whirlpools-sdk/dist/instructions/open-position-with-token-extensions-ix.js
var require_open_position_with_token_extensions_ix = __commonJS({
  "node_modules/@orca-so/whirlpools-sdk/dist/instructions/open-position-with-token-extensions-ix.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.openPositionWithTokenExtensionsIx = openPositionWithTokenExtensionsIx;
    var __1 = require_dist3();
    var instructions_util_1 = require_instructions_util();
    function openPositionWithTokenExtensionsIx(program, params) {
      const { tickLowerIndex, tickUpperIndex, withTokenMetadataExtension } = params;
      const ix = program.instruction.openPositionWithTokenExtensions(tickLowerIndex, tickUpperIndex, withTokenMetadataExtension, {
        accounts: {
          ...(0, instructions_util_1.openPositionWithTokenExtensionsAccounts)(params),
          metadataUpdateAuth: __1.WHIRLPOOL_NFT_UPDATE_AUTH
        }
      });
      return {
        instructions: [ix],
        cleanupInstructions: [],
        signers: []
      };
    }
  }
});

// node_modules/@orca-so/whirlpools-sdk/dist/instructions/reset-position-range-ix.js
var require_reset_position_range_ix = __commonJS({
  "node_modules/@orca-so/whirlpools-sdk/dist/instructions/reset-position-range-ix.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.resetPositionRangeIx = resetPositionRangeIx;
    var web3_js_1 = require("@solana/web3.js");
    function resetPositionRangeIx(program, params) {
      const { funder, positionAuthority, whirlpool, position, positionTokenAccount, tickLowerIndex, tickUpperIndex } = params;
      const ix = program.instruction.resetPositionRange(tickLowerIndex, tickUpperIndex, {
        accounts: {
          funder,
          positionAuthority,
          whirlpool,
          position,
          positionTokenAccount,
          systemProgram: web3_js_1.SystemProgram.programId
        }
      });
      return {
        instructions: [ix],
        cleanupInstructions: [],
        signers: []
      };
    }
  }
});

// node_modules/@orca-so/whirlpools-sdk/dist/instructions/set-collect-protocol-fees-authority-ix.js
var require_set_collect_protocol_fees_authority_ix = __commonJS({
  "node_modules/@orca-so/whirlpools-sdk/dist/instructions/set-collect-protocol-fees-authority-ix.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.setCollectProtocolFeesAuthorityIx = setCollectProtocolFeesAuthorityIx;
    function setCollectProtocolFeesAuthorityIx(program, params) {
      const { whirlpoolsConfig, collectProtocolFeesAuthority, newCollectProtocolFeesAuthority } = params;
      const ix = program.instruction.setCollectProtocolFeesAuthority({
        accounts: {
          whirlpoolsConfig,
          collectProtocolFeesAuthority,
          newCollectProtocolFeesAuthority
        }
      });
      return {
        instructions: [ix],
        cleanupInstructions: [],
        signers: []
      };
    }
  }
});

// node_modules/@orca-so/whirlpools-sdk/dist/instructions/set-default-fee-rate-ix.js
var require_set_default_fee_rate_ix = __commonJS({
  "node_modules/@orca-so/whirlpools-sdk/dist/instructions/set-default-fee-rate-ix.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.setDefaultFeeRateIx = setDefaultFeeRateIx;
    var public_1 = require_public3();
    function setDefaultFeeRateIx(program, params) {
      const { whirlpoolsConfig, feeAuthority, tickSpacing, defaultFeeRate } = params;
      const feeTierPda = public_1.PDAUtil.getFeeTier(program.programId, whirlpoolsConfig, tickSpacing);
      const ix = program.instruction.setDefaultFeeRate(defaultFeeRate, {
        accounts: {
          whirlpoolsConfig,
          feeTier: feeTierPda.publicKey,
          feeAuthority
        }
      });
      return {
        instructions: [ix],
        cleanupInstructions: [],
        signers: []
      };
    }
  }
});

// node_modules/@orca-so/whirlpools-sdk/dist/instructions/set-default-protocol-fee-rate-ix.js
var require_set_default_protocol_fee_rate_ix = __commonJS({
  "node_modules/@orca-so/whirlpools-sdk/dist/instructions/set-default-protocol-fee-rate-ix.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.setDefaultProtocolFeeRateIx = setDefaultProtocolFeeRateIx;
    function setDefaultProtocolFeeRateIx(program, params) {
      const { whirlpoolsConfig, feeAuthority, defaultProtocolFeeRate } = params;
      const ix = program.instruction.setDefaultProtocolFeeRate(defaultProtocolFeeRate, {
        accounts: {
          whirlpoolsConfig,
          feeAuthority
        }
      });
      return {
        instructions: [ix],
        cleanupInstructions: [],
        signers: []
      };
    }
  }
});

// node_modules/@orca-so/whirlpools-sdk/dist/instructions/set-fee-authority-ix.js
var require_set_fee_authority_ix = __commonJS({
  "node_modules/@orca-so/whirlpools-sdk/dist/instructions/set-fee-authority-ix.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.setFeeAuthorityIx = setFeeAuthorityIx;
    function setFeeAuthorityIx(program, params) {
      const { whirlpoolsConfig, feeAuthority, newFeeAuthority } = params;
      const ix = program.instruction.setFeeAuthority({
        accounts: {
          whirlpoolsConfig,
          feeAuthority,
          newFeeAuthority
        }
      });
      return {
        instructions: [ix],
        cleanupInstructions: [],
        signers: []
      };
    }
  }
});

// node_modules/@orca-so/whirlpools-sdk/dist/instructions/set-fee-rate-ix.js
var require_set_fee_rate_ix = __commonJS({
  "node_modules/@orca-so/whirlpools-sdk/dist/instructions/set-fee-rate-ix.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.setFeeRateIx = setFeeRateIx;
    function setFeeRateIx(program, params) {
      const { whirlpoolsConfig, whirlpool, feeAuthority, feeRate } = params;
      const ix = program.instruction.setFeeRate(feeRate, {
        accounts: {
          whirlpoolsConfig,
          whirlpool,
          feeAuthority
        }
      });
      return {
        instructions: [ix],
        cleanupInstructions: [],
        signers: []
      };
    }
  }
});

// node_modules/@orca-so/whirlpools-sdk/dist/instructions/set-protocol-fee-rate-ix.js
var require_set_protocol_fee_rate_ix = __commonJS({
  "node_modules/@orca-so/whirlpools-sdk/dist/instructions/set-protocol-fee-rate-ix.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.setProtocolFeeRateIx = setProtocolFeeRateIx;
    function setProtocolFeeRateIx(program, params) {
      const { whirlpoolsConfig, whirlpool, feeAuthority, protocolFeeRate } = params;
      const ix = program.instruction.setProtocolFeeRate(protocolFeeRate, {
        accounts: {
          whirlpoolsConfig,
          whirlpool,
          feeAuthority
        }
      });
      return {
        instructions: [ix],
        cleanupInstructions: [],
        signers: []
      };
    }
  }
});

// node_modules/@orca-so/whirlpools-sdk/dist/instructions/set-reward-authority-by-super-authority-ix.js
var require_set_reward_authority_by_super_authority_ix = __commonJS({
  "node_modules/@orca-so/whirlpools-sdk/dist/instructions/set-reward-authority-by-super-authority-ix.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.setRewardAuthorityBySuperAuthorityIx = setRewardAuthorityBySuperAuthorityIx;
    function setRewardAuthorityBySuperAuthorityIx(program, params) {
      const { whirlpoolsConfig, whirlpool, rewardEmissionsSuperAuthority, newRewardAuthority, rewardIndex } = params;
      const ix = program.instruction.setRewardAuthorityBySuperAuthority(rewardIndex, {
        accounts: {
          whirlpoolsConfig,
          whirlpool,
          rewardEmissionsSuperAuthority,
          newRewardAuthority
        }
      });
      return {
        instructions: [ix],
        cleanupInstructions: [],
        signers: []
      };
    }
  }
});

// node_modules/@orca-so/whirlpools-sdk/dist/instructions/set-reward-authority-ix.js
var require_set_reward_authority_ix = __commonJS({
  "node_modules/@orca-so/whirlpools-sdk/dist/instructions/set-reward-authority-ix.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.setRewardAuthorityIx = setRewardAuthorityIx;
    function setRewardAuthorityIx(program, params) {
      const { whirlpool, rewardAuthority, newRewardAuthority, rewardIndex } = params;
      const ix = program.instruction.setRewardAuthority(rewardIndex, {
        accounts: {
          whirlpool,
          rewardAuthority,
          newRewardAuthority
        }
      });
      return {
        instructions: [ix],
        cleanupInstructions: [],
        signers: []
      };
    }
  }
});

// node_modules/@orca-so/whirlpools-sdk/dist/instructions/set-reward-emissions-ix.js
var require_set_reward_emissions_ix2 = __commonJS({
  "node_modules/@orca-so/whirlpools-sdk/dist/instructions/set-reward-emissions-ix.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.setRewardEmissionsIx = setRewardEmissionsIx;
    function setRewardEmissionsIx(program, params) {
      const { rewardAuthority, whirlpool, rewardIndex, rewardVaultKey: rewardVault, emissionsPerSecondX64 } = params;
      const ix = program.instruction.setRewardEmissions(rewardIndex, emissionsPerSecondX64, {
        accounts: {
          rewardAuthority,
          whirlpool,
          rewardVault
        }
      });
      return {
        instructions: [ix],
        cleanupInstructions: [],
        signers: []
      };
    }
  }
});

// node_modules/@orca-so/whirlpools-sdk/dist/instructions/set-reward-emissions-super-authority-ix.js
var require_set_reward_emissions_super_authority_ix = __commonJS({
  "node_modules/@orca-so/whirlpools-sdk/dist/instructions/set-reward-emissions-super-authority-ix.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.setRewardEmissionsSuperAuthorityIx = setRewardEmissionsSuperAuthorityIx;
    function setRewardEmissionsSuperAuthorityIx(program, params) {
      const { whirlpoolsConfig, rewardEmissionsSuperAuthority, newRewardEmissionsSuperAuthority } = params;
      const ix = program.instruction.setRewardEmissionsSuperAuthority({
        accounts: {
          whirlpoolsConfig,
          rewardEmissionsSuperAuthority,
          newRewardEmissionsSuperAuthority
        }
      });
      return {
        instructions: [ix],
        cleanupInstructions: [],
        signers: []
      };
    }
  }
});

// node_modules/@orca-so/whirlpools-sdk/dist/instructions/transfer-locked-position.js
var require_transfer_locked_position = __commonJS({
  "node_modules/@orca-so/whirlpools-sdk/dist/instructions/transfer-locked-position.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.transferLockedPositionIx = transferLockedPositionIx;
    var spl_token_1 = require_cjs3();
    function transferLockedPositionIx(program, params) {
      const ix = program.instruction.transferLockedPosition({
        accounts: {
          receiver: params.receiver,
          positionAuthority: params.positionAuthority,
          position: params.position,
          positionMint: params.positionMint,
          positionTokenAccount: params.positionTokenAccount,
          destinationTokenAccount: params.destinationTokenAccount,
          token2022Program: spl_token_1.TOKEN_2022_PROGRAM_ID,
          lockConfig: params.lockConfig
        }
      });
      return {
        instructions: [ix],
        cleanupInstructions: [],
        signers: []
      };
    }
  }
});

// node_modules/@orca-so/whirlpools-sdk/dist/instructions/two-hop-swap-ix.js
var require_two_hop_swap_ix2 = __commonJS({
  "node_modules/@orca-so/whirlpools-sdk/dist/instructions/two-hop-swap-ix.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.twoHopSwapIx = twoHopSwapIx;
    var spl_token_1 = require_cjs3();
    var tiny_invariant_1 = __importDefault(require_tiny_invariant_cjs());
    function twoHopSwapIx(program, params) {
      const { amount, otherAmountThreshold, amountSpecifiedIsInput, aToBOne, aToBTwo, sqrtPriceLimitOne, sqrtPriceLimitTwo, whirlpoolOne, whirlpoolTwo, tokenAuthority, tokenOwnerAccountOneA, tokenVaultOneA, tokenOwnerAccountOneB, tokenVaultOneB, tokenOwnerAccountTwoA, tokenVaultTwoA, tokenOwnerAccountTwoB, tokenVaultTwoB, tickArrayOne0, tickArrayOne1, tickArrayOne2, tickArrayTwo0, tickArrayTwo1, tickArrayTwo2, oracleOne, oracleTwo } = params;
      const ix = program.instruction.twoHopSwap(amount, otherAmountThreshold, amountSpecifiedIsInput, aToBOne, aToBTwo, sqrtPriceLimitOne, sqrtPriceLimitTwo, {
        accounts: {
          tokenProgram: spl_token_1.TOKEN_PROGRAM_ID,
          tokenAuthority,
          whirlpoolOne,
          whirlpoolTwo,
          tokenOwnerAccountOneA,
          tokenVaultOneA,
          tokenOwnerAccountOneB,
          tokenVaultOneB,
          tokenOwnerAccountTwoA,
          tokenVaultTwoA,
          tokenOwnerAccountTwoB,
          tokenVaultTwoB,
          tickArrayOne0,
          tickArrayOne1,
          tickArrayOne2,
          tickArrayTwo0,
          tickArrayTwo1,
          tickArrayTwo2,
          oracleOne,
          oracleTwo
        }
      });
      (0, tiny_invariant_1.default)(ix.keys[18].pubkey.equals(oracleOne));
      ix.keys[18].isWritable = true;
      (0, tiny_invariant_1.default)(ix.keys[19].pubkey.equals(oracleTwo));
      ix.keys[19].isWritable = true;
      return {
        instructions: [ix],
        cleanupInstructions: [],
        signers: []
      };
    }
  }
});

// node_modules/@orca-so/whirlpools-sdk/dist/instructions/adaptive-fee/initialize-adaptive-fee-tier-ix.js
var require_initialize_adaptive_fee_tier_ix = __commonJS({
  "node_modules/@orca-so/whirlpools-sdk/dist/instructions/adaptive-fee/initialize-adaptive-fee-tier-ix.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || /* @__PURE__ */ function() {
      var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2)
            if (Object.prototype.hasOwnProperty.call(o2, k))
              ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      };
      return function(mod2) {
        if (mod2 && mod2.__esModule)
          return mod2;
        var result = {};
        if (mod2 != null) {
          for (var k = ownKeys(mod2), i = 0; i < k.length; i++)
            if (k[i] !== "default")
              __createBinding(result, mod2, k[i]);
        }
        __setModuleDefault(result, mod2);
        return result;
      };
    }();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.initializeAdaptiveFeeTierIx = initializeAdaptiveFeeTierIx;
    var anchor = __importStar(require("@coral-xyz/anchor"));
    var web3_js_1 = require("@solana/web3.js");
    function initializeAdaptiveFeeTierIx(program, params) {
      const ix = program.instruction.initializeAdaptiveFeeTier(params.feeTierIndex, params.tickSpacing, params.initializePoolAuthority ?? web3_js_1.PublicKey.default, params.delegatedFeeAuthority ?? web3_js_1.PublicKey.default, params.defaultBaseFeeRate, params.presetFilterPeriod, params.presetDecayPeriod, params.presetReductionFactor, params.presetAdaptiveFeeControlFactor, params.presetMaxVolatilityAccumulator, params.presetTickGroupSize, params.presetMajorSwapThresholdTicks, {
        accounts: {
          whirlpoolsConfig: params.whirlpoolsConfig,
          adaptiveFeeTier: params.feeTierPda.publicKey,
          funder: params.funder,
          feeAuthority: params.feeAuthority,
          systemProgram: anchor.web3.SystemProgram.programId
        }
      });
      return {
        instructions: [ix],
        cleanupInstructions: [],
        signers: []
      };
    }
  }
});

// node_modules/@orca-so/whirlpools-sdk/dist/instructions/adaptive-fee/initialize-pool-with-adaptive-fee-ix.js
var require_initialize_pool_with_adaptive_fee_ix = __commonJS({
  "node_modules/@orca-so/whirlpools-sdk/dist/instructions/adaptive-fee/initialize-pool-with-adaptive-fee-ix.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.initializePoolWithAdaptiveFeeIx = initializePoolWithAdaptiveFeeIx;
    var web3_js_1 = require("@solana/web3.js");
    function initializePoolWithAdaptiveFeeIx(program, params) {
      const { initSqrtPrice, tradeEnableTimestamp, tokenMintA, tokenMintB, tokenBadgeA, tokenBadgeB, tokenProgramA, tokenProgramB, whirlpoolsConfig, whirlpoolPda, oraclePda, adaptiveFeeTierKey, tokenVaultAKeypair, tokenVaultBKeypair, funder, initializePoolAuthority } = params;
      const optionTradeEnableTimestamp = tradeEnableTimestamp ?? null;
      const ix = program.instruction.initializePoolWithAdaptiveFee(initSqrtPrice, optionTradeEnableTimestamp, {
        accounts: {
          whirlpoolsConfig,
          tokenMintA,
          tokenMintB,
          tokenBadgeA,
          tokenBadgeB,
          funder,
          initializePoolAuthority,
          whirlpool: whirlpoolPda.publicKey,
          oracle: oraclePda.publicKey,
          tokenVaultA: tokenVaultAKeypair.publicKey,
          tokenVaultB: tokenVaultBKeypair.publicKey,
          adaptiveFeeTier: adaptiveFeeTierKey,
          systemProgram: web3_js_1.SystemProgram.programId,
          tokenProgramA,
          tokenProgramB,
          rent: web3_js_1.SYSVAR_RENT_PUBKEY
        }
      });
      return {
        instructions: [ix],
        cleanupInstructions: [],
        signers: [tokenVaultAKeypair, tokenVaultBKeypair]
      };
    }
  }
});

// node_modules/@orca-so/whirlpools-sdk/dist/instructions/adaptive-fee/set-default-base-fee-rate-ix.js
var require_set_default_base_fee_rate_ix = __commonJS({
  "node_modules/@orca-so/whirlpools-sdk/dist/instructions/adaptive-fee/set-default-base-fee-rate-ix.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.setDefaultBaseFeeRateIx = setDefaultBaseFeeRateIx;
    function setDefaultBaseFeeRateIx(program, params) {
      const { whirlpoolsConfig, feeAuthority, adaptiveFeeTier, defaultBaseFeeRate } = params;
      const ix = program.instruction.setDefaultBaseFeeRate(defaultBaseFeeRate, {
        accounts: {
          whirlpoolsConfig,
          adaptiveFeeTier,
          feeAuthority
        }
      });
      return {
        instructions: [ix],
        cleanupInstructions: [],
        signers: []
      };
    }
  }
});

// node_modules/@orca-so/whirlpools-sdk/dist/instructions/adaptive-fee/set-delegated-fee-authority-ix.js
var require_set_delegated_fee_authority_ix = __commonJS({
  "node_modules/@orca-so/whirlpools-sdk/dist/instructions/adaptive-fee/set-delegated-fee-authority-ix.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.setDelegatedFeeAuthorityIx = setDelegatedFeeAuthorityIx;
    function setDelegatedFeeAuthorityIx(program, params) {
      const { whirlpoolsConfig, feeAuthority, adaptiveFeeTier, newDelegatedFeeAuthority } = params;
      const ix = program.instruction.setDelegatedFeeAuthority({
        accounts: {
          whirlpoolsConfig,
          feeAuthority,
          adaptiveFeeTier,
          newDelegatedFeeAuthority
        }
      });
      return {
        instructions: [ix],
        cleanupInstructions: [],
        signers: []
      };
    }
  }
});

// node_modules/@orca-so/whirlpools-sdk/dist/instructions/adaptive-fee/set-fee-rate-by-delegated-fee-authority-ix.js
var require_set_fee_rate_by_delegated_fee_authority_ix = __commonJS({
  "node_modules/@orca-so/whirlpools-sdk/dist/instructions/adaptive-fee/set-fee-rate-by-delegated-fee-authority-ix.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.setFeeRateByDelegatedFeeAuthorityIx = setFeeRateByDelegatedFeeAuthorityIx;
    function setFeeRateByDelegatedFeeAuthorityIx(program, params) {
      const { whirlpool, adaptiveFeeTier, delegatedFeeAuthority, feeRate } = params;
      const ix = program.instruction.setFeeRateByDelegatedFeeAuthority(feeRate, {
        accounts: {
          whirlpool,
          adaptiveFeeTier,
          delegatedFeeAuthority
        }
      });
      return {
        instructions: [ix],
        cleanupInstructions: [],
        signers: []
      };
    }
  }
});

// node_modules/@orca-so/whirlpools-sdk/dist/instructions/adaptive-fee/set-initialize-pool-authority-ix.js
var require_set_initialize_pool_authority_ix = __commonJS({
  "node_modules/@orca-so/whirlpools-sdk/dist/instructions/adaptive-fee/set-initialize-pool-authority-ix.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.setInitializePoolAuthorityIx = setInitializePoolAuthorityIx;
    function setInitializePoolAuthorityIx(program, params) {
      const { whirlpoolsConfig, feeAuthority, adaptiveFeeTier, newInitializePoolAuthority } = params;
      const ix = program.instruction.setInitializePoolAuthority({
        accounts: {
          whirlpoolsConfig,
          feeAuthority,
          adaptiveFeeTier,
          newInitializePoolAuthority
        }
      });
      return {
        instructions: [ix],
        cleanupInstructions: [],
        signers: []
      };
    }
  }
});

// node_modules/@orca-so/whirlpools-sdk/dist/instructions/adaptive-fee/set-preset-adaptive-fee-constants-ix.js
var require_set_preset_adaptive_fee_constants_ix = __commonJS({
  "node_modules/@orca-so/whirlpools-sdk/dist/instructions/adaptive-fee/set-preset-adaptive-fee-constants-ix.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.setPresetAdaptiveFeeConstantsIx = setPresetAdaptiveFeeConstantsIx;
    function setPresetAdaptiveFeeConstantsIx(program, params) {
      const ix = program.instruction.setPresetAdaptiveFeeConstants(params.presetFilterPeriod, params.presetDecayPeriod, params.presetReductionFactor, params.presetAdaptiveFeeControlFactor, params.presetMaxVolatilityAccumulator, params.presetTickGroupSize, params.presetMajorSwapThresholdTicks, {
        accounts: {
          whirlpoolsConfig: params.whirlpoolsConfig,
          feeAuthority: params.feeAuthority,
          adaptiveFeeTier: params.adaptiveFeeTier
        }
      });
      return {
        instructions: [ix],
        cleanupInstructions: [],
        signers: []
      };
    }
  }
});

// node_modules/@orca-so/whirlpools-sdk/dist/instructions/adaptive-fee/index.js
var require_adaptive_fee = __commonJS({
  "node_modules/@orca-so/whirlpools-sdk/dist/instructions/adaptive-fee/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_initialize_adaptive_fee_tier_ix(), exports2);
    __exportStar(require_initialize_pool_with_adaptive_fee_ix(), exports2);
    __exportStar(require_set_default_base_fee_rate_ix(), exports2);
    __exportStar(require_set_delegated_fee_authority_ix(), exports2);
    __exportStar(require_set_fee_rate_by_delegated_fee_authority_ix(), exports2);
    __exportStar(require_set_initialize_pool_authority_ix(), exports2);
    __exportStar(require_set_preset_adaptive_fee_constants_ix(), exports2);
  }
});

// node_modules/@orca-so/whirlpools-sdk/dist/instructions/index.js
var require_instructions9 = __commonJS({
  "node_modules/@orca-so/whirlpools-sdk/dist/instructions/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_close_bundled_position_ix(), exports2);
    __exportStar(require_close_position_ix(), exports2);
    __exportStar(require_close_position_with_token_extensions_ix(), exports2);
    __exportStar(require_collect_fees_ix(), exports2);
    __exportStar(require_collect_protocol_fees_ix(), exports2);
    __exportStar(require_collect_reward_ix(), exports2);
    __exportStar(require_composites(), exports2);
    __exportStar(require_decrease_liquidity_ix2(), exports2);
    __exportStar(require_delete_position_bundle_ix(), exports2);
    __exportStar(require_increase_liquidity_ix2(), exports2);
    __exportStar(require_initialize_config_ix(), exports2);
    __exportStar(require_initialize_fee_tier_ix(), exports2);
    __exportStar(require_initialize_pool_ix2(), exports2);
    __exportStar(require_initialize_position_bundle_ix(), exports2);
    __exportStar(require_initialize_reward_ix2(), exports2);
    __exportStar(require_initialize_tick_array_ix(), exports2);
    __exportStar(require_lock_position(), exports2);
    __exportStar(require_open_bundled_position_ix(), exports2);
    __exportStar(require_open_position_ix(), exports2);
    __exportStar(require_open_position_with_token_extensions_ix(), exports2);
    __exportStar(require_reset_position_range_ix(), exports2);
    __exportStar(require_set_collect_protocol_fees_authority_ix(), exports2);
    __exportStar(require_set_default_fee_rate_ix(), exports2);
    __exportStar(require_set_default_protocol_fee_rate_ix(), exports2);
    __exportStar(require_set_fee_authority_ix(), exports2);
    __exportStar(require_set_fee_rate_ix(), exports2);
    __exportStar(require_set_protocol_fee_rate_ix(), exports2);
    __exportStar(require_set_reward_authority_by_super_authority_ix(), exports2);
    __exportStar(require_set_reward_authority_ix(), exports2);
    __exportStar(require_set_reward_emissions_ix2(), exports2);
    __exportStar(require_set_reward_emissions_super_authority_ix(), exports2);
    __exportStar(require_swap_ix2(), exports2);
    __exportStar(require_transfer_locked_position(), exports2);
    __exportStar(require_two_hop_swap_ix2(), exports2);
    __exportStar(require_update_fees_and_rewards_ix(), exports2);
    __exportStar(require_v2(), exports2);
    __exportStar(require_adaptive_fee(), exports2);
  }
});

// node_modules/@orca-so/whirlpools-sdk/dist/utils/builder/position-builder-util.js
var require_position_builder_util = __commonJS({
  "node_modules/@orca-so/whirlpools-sdk/dist/utils/builder/position-builder-util.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getTickArrayDataForPosition = getTickArrayDataForPosition;
    var public_1 = require_public3();
    async function getTickArrayDataForPosition(ctx, position, whirlpool, opts) {
      const lowerTickArrayKey = public_1.PDAUtil.getTickArrayFromTickIndex(position.tickLowerIndex, whirlpool.tickSpacing, position.whirlpool, ctx.program.programId).publicKey;
      const upperTickArrayKey = public_1.PDAUtil.getTickArrayFromTickIndex(position.tickUpperIndex, whirlpool.tickSpacing, position.whirlpool, ctx.program.programId).publicKey;
      return await ctx.fetcher.getTickArrays([lowerTickArrayKey, upperTickArrayKey], opts);
    }
  }
});

// node_modules/@orca-so/whirlpools-sdk/dist/impl/position-impl.js
var require_position_impl = __commonJS({
  "node_modules/@orca-so/whirlpools-sdk/dist/impl/position-impl.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PositionImpl = void 0;
    var common_sdk_1 = require_dist2();
    var spl_token_1 = require_cjs3();
    var web3_js_1 = require("@solana/web3.js");
    var tiny_invariant_1 = __importDefault(require_tiny_invariant_cjs());
    var instructions_1 = require_instructions9();
    var fetcher_1 = require_fetcher2();
    var position_builder_util_1 = require_position_builder_util();
    var public_1 = require_public3();
    var whirlpool_ata_utils_1 = require_whirlpool_ata_utils();
    var token_extension_util_1 = require_token_extension_util();
    var txn_utils_1 = require_txn_utils();
    var PositionImpl = class {
      ctx;
      address;
      positionMintTokenProgramId;
      data;
      whirlpoolData;
      lowerTickArrayData;
      upperTickArrayData;
      constructor(ctx, address, data, whirlpoolData, lowerTickArrayData, upperTickArrayData, positionMintTokenProgramId) {
        this.ctx = ctx;
        this.address = address;
        this.positionMintTokenProgramId = positionMintTokenProgramId;
        this.data = data;
        this.whirlpoolData = whirlpoolData;
        this.lowerTickArrayData = lowerTickArrayData;
        this.upperTickArrayData = upperTickArrayData;
      }
      getAddress() {
        return this.address;
      }
      getPositionMintTokenProgramId() {
        return this.positionMintTokenProgramId;
      }
      getData() {
        return this.data;
      }
      getWhirlpoolData() {
        return this.whirlpoolData;
      }
      getLowerTickData() {
        return public_1.TickArrayUtil.getTickFromArray(this.lowerTickArrayData, this.data.tickLowerIndex, this.whirlpoolData.tickSpacing);
      }
      getUpperTickData() {
        return public_1.TickArrayUtil.getTickFromArray(this.upperTickArrayData, this.data.tickUpperIndex, this.whirlpoolData.tickSpacing);
      }
      async refreshData() {
        await this.refresh();
        return this.data;
      }
      async increaseLiquidity(liquidityInput, resolveATA = true, sourceWallet, positionWallet, ataPayer) {
        const sourceWalletKey = sourceWallet ? common_sdk_1.AddressUtil.toPubKey(sourceWallet) : this.ctx.wallet.publicKey;
        const positionWalletKey = positionWallet ? common_sdk_1.AddressUtil.toPubKey(positionWallet) : this.ctx.wallet.publicKey;
        const ataPayerKey = ataPayer ? common_sdk_1.AddressUtil.toPubKey(ataPayer) : this.ctx.wallet.publicKey;
        const whirlpool = await this.ctx.fetcher.getPool(this.data.whirlpool, fetcher_1.IGNORE_CACHE);
        if (!whirlpool) {
          throw new Error("Unable to fetch whirlpool for this position.");
        }
        const tokenExtensionCtx = await token_extension_util_1.TokenExtensionUtil.buildTokenExtensionContext(this.ctx.fetcher, whirlpool, fetcher_1.IGNORE_CACHE);
        const txBuilder = new common_sdk_1.TransactionBuilder(this.ctx.provider.connection, this.ctx.provider.wallet, this.ctx.txBuilderOpts);
        let tokenOwnerAccountA;
        let tokenOwnerAccountB;
        if (resolveATA) {
          const [ataA, ataB] = await (0, common_sdk_1.resolveOrCreateATAs)(this.ctx.connection, sourceWalletKey, [
            {
              tokenMint: whirlpool.tokenMintA,
              wrappedSolAmountIn: liquidityInput.tokenMaxA
            },
            {
              tokenMint: whirlpool.tokenMintB,
              wrappedSolAmountIn: liquidityInput.tokenMaxB
            }
          ], () => this.ctx.fetcher.getAccountRentExempt(), ataPayerKey, void 0, this.ctx.accountResolverOpts.allowPDAOwnerAddress, this.ctx.accountResolverOpts.createWrappedSolAccountMethod);
          const { address: ataAddrA, ...tokenOwnerAccountAIx } = ataA;
          const { address: ataAddrB, ...tokenOwnerAccountBIx } = ataB;
          tokenOwnerAccountA = ataAddrA;
          tokenOwnerAccountB = ataAddrB;
          txBuilder.addInstruction(tokenOwnerAccountAIx);
          txBuilder.addInstruction(tokenOwnerAccountBIx);
        } else {
          tokenOwnerAccountA = (0, spl_token_1.getAssociatedTokenAddressSync)(whirlpool.tokenMintA, sourceWalletKey, this.ctx.accountResolverOpts.allowPDAOwnerAddress, tokenExtensionCtx.tokenMintWithProgramA.tokenProgram);
          tokenOwnerAccountB = (0, spl_token_1.getAssociatedTokenAddressSync)(whirlpool.tokenMintB, sourceWalletKey, this.ctx.accountResolverOpts.allowPDAOwnerAddress, tokenExtensionCtx.tokenMintWithProgramB.tokenProgram);
        }
        const positionTokenAccount = (0, spl_token_1.getAssociatedTokenAddressSync)(this.data.positionMint, positionWalletKey, this.ctx.accountResolverOpts.allowPDAOwnerAddress, this.positionMintTokenProgramId);
        const baseParams = {
          ...liquidityInput,
          whirlpool: this.data.whirlpool,
          position: this.address,
          positionTokenAccount,
          tokenOwnerAccountA,
          tokenOwnerAccountB,
          tokenVaultA: whirlpool.tokenVaultA,
          tokenVaultB: whirlpool.tokenVaultB,
          tickArrayLower: public_1.PDAUtil.getTickArray(this.ctx.program.programId, this.data.whirlpool, public_1.TickUtil.getStartTickIndex(this.data.tickLowerIndex, whirlpool.tickSpacing)).publicKey,
          tickArrayUpper: public_1.PDAUtil.getTickArray(this.ctx.program.programId, this.data.whirlpool, public_1.TickUtil.getStartTickIndex(this.data.tickUpperIndex, whirlpool.tickSpacing)).publicKey,
          positionAuthority: positionWalletKey
        };
        const increaseIx = !token_extension_util_1.TokenExtensionUtil.isV2IxRequiredPool(tokenExtensionCtx) ? (0, instructions_1.increaseLiquidityIx)(this.ctx.program, baseParams) : (0, instructions_1.increaseLiquidityV2Ix)(this.ctx.program, {
          ...baseParams,
          tokenMintA: whirlpool.tokenMintA,
          tokenMintB: whirlpool.tokenMintB,
          tokenProgramA: tokenExtensionCtx.tokenMintWithProgramA.tokenProgram,
          tokenProgramB: tokenExtensionCtx.tokenMintWithProgramB.tokenProgram,
          ...await token_extension_util_1.TokenExtensionUtil.getExtraAccountMetasForTransferHookForPool(this.ctx.connection, tokenExtensionCtx, baseParams.tokenOwnerAccountA, baseParams.tokenVaultA, baseParams.positionAuthority, baseParams.tokenOwnerAccountB, baseParams.tokenVaultB, baseParams.positionAuthority)
        });
        txBuilder.addInstruction(increaseIx);
        return txBuilder;
      }
      async decreaseLiquidity(liquidityInput, resolveATA = true, sourceWallet, positionWallet, ataPayer) {
        const sourceWalletKey = sourceWallet ? common_sdk_1.AddressUtil.toPubKey(sourceWallet) : this.ctx.wallet.publicKey;
        const positionWalletKey = positionWallet ? common_sdk_1.AddressUtil.toPubKey(positionWallet) : this.ctx.wallet.publicKey;
        const ataPayerKey = ataPayer ? common_sdk_1.AddressUtil.toPubKey(ataPayer) : this.ctx.wallet.publicKey;
        const whirlpool = await this.ctx.fetcher.getPool(this.data.whirlpool, fetcher_1.IGNORE_CACHE);
        if (!whirlpool) {
          throw new Error("Unable to fetch whirlpool for this position.");
        }
        const tokenExtensionCtx = await token_extension_util_1.TokenExtensionUtil.buildTokenExtensionContext(this.ctx.fetcher, whirlpool, fetcher_1.IGNORE_CACHE);
        const txBuilder = new common_sdk_1.TransactionBuilder(this.ctx.provider.connection, this.ctx.provider.wallet, this.ctx.txBuilderOpts);
        let tokenOwnerAccountA;
        let tokenOwnerAccountB;
        if (resolveATA) {
          const [ataA, ataB] = await (0, common_sdk_1.resolveOrCreateATAs)(this.ctx.connection, sourceWalletKey, [
            { tokenMint: whirlpool.tokenMintA },
            { tokenMint: whirlpool.tokenMintB }
          ], () => this.ctx.fetcher.getAccountRentExempt(), ataPayerKey, void 0, this.ctx.accountResolverOpts.allowPDAOwnerAddress, this.ctx.accountResolverOpts.createWrappedSolAccountMethod);
          const { address: ataAddrA, ...tokenOwnerAccountAIx } = ataA;
          const { address: ataAddrB, ...tokenOwnerAccountBIx } = ataB;
          tokenOwnerAccountA = ataAddrA;
          tokenOwnerAccountB = ataAddrB;
          txBuilder.addInstruction(tokenOwnerAccountAIx);
          txBuilder.addInstruction(tokenOwnerAccountBIx);
        } else {
          tokenOwnerAccountA = (0, spl_token_1.getAssociatedTokenAddressSync)(whirlpool.tokenMintA, sourceWalletKey, this.ctx.accountResolverOpts.allowPDAOwnerAddress, tokenExtensionCtx.tokenMintWithProgramA.tokenProgram);
          tokenOwnerAccountB = (0, spl_token_1.getAssociatedTokenAddressSync)(whirlpool.tokenMintB, sourceWalletKey, this.ctx.accountResolverOpts.allowPDAOwnerAddress, tokenExtensionCtx.tokenMintWithProgramB.tokenProgram);
        }
        const baseParams = {
          ...liquidityInput,
          whirlpool: this.data.whirlpool,
          position: this.address,
          positionTokenAccount: (0, spl_token_1.getAssociatedTokenAddressSync)(this.data.positionMint, positionWalletKey, this.ctx.accountResolverOpts.allowPDAOwnerAddress, this.positionMintTokenProgramId),
          tokenOwnerAccountA,
          tokenOwnerAccountB,
          tokenVaultA: whirlpool.tokenVaultA,
          tokenVaultB: whirlpool.tokenVaultB,
          tickArrayLower: public_1.PDAUtil.getTickArray(this.ctx.program.programId, this.data.whirlpool, public_1.TickUtil.getStartTickIndex(this.data.tickLowerIndex, whirlpool.tickSpacing)).publicKey,
          tickArrayUpper: public_1.PDAUtil.getTickArray(this.ctx.program.programId, this.data.whirlpool, public_1.TickUtil.getStartTickIndex(this.data.tickUpperIndex, whirlpool.tickSpacing)).publicKey,
          positionAuthority: positionWalletKey
        };
        const decreaseIx = !token_extension_util_1.TokenExtensionUtil.isV2IxRequiredPool(tokenExtensionCtx) ? (0, instructions_1.decreaseLiquidityIx)(this.ctx.program, baseParams) : (0, instructions_1.decreaseLiquidityV2Ix)(this.ctx.program, {
          ...baseParams,
          tokenMintA: whirlpool.tokenMintA,
          tokenMintB: whirlpool.tokenMintB,
          tokenProgramA: tokenExtensionCtx.tokenMintWithProgramA.tokenProgram,
          tokenProgramB: tokenExtensionCtx.tokenMintWithProgramB.tokenProgram,
          ...await token_extension_util_1.TokenExtensionUtil.getExtraAccountMetasForTransferHookForPool(this.ctx.connection, tokenExtensionCtx, baseParams.tokenVaultA, baseParams.tokenOwnerAccountA, baseParams.whirlpool, baseParams.tokenVaultB, baseParams.tokenOwnerAccountB, baseParams.whirlpool)
        });
        txBuilder.addInstruction(decreaseIx);
        return txBuilder;
      }
      async collectFees(updateFeesAndRewards = true, ownerTokenAccountMap, destinationWallet, positionWallet, ataPayer, opts = fetcher_1.PREFER_CACHE) {
        const [destinationWalletKey, positionWalletKey, ataPayerKey] = common_sdk_1.AddressUtil.toPubKeys([
          destinationWallet ?? this.ctx.wallet.publicKey,
          positionWallet ?? this.ctx.wallet.publicKey,
          ataPayer ?? this.ctx.wallet.publicKey
        ]);
        const whirlpool = await this.ctx.fetcher.getPool(this.data.whirlpool, opts);
        if (!whirlpool) {
          throw new Error(`Unable to fetch whirlpool (${this.data.whirlpool}) for this position (${this.address}).`);
        }
        const tokenExtensionCtx = await token_extension_util_1.TokenExtensionUtil.buildTokenExtensionContext(this.ctx.fetcher, whirlpool, fetcher_1.IGNORE_CACHE);
        let txBuilder = new common_sdk_1.TransactionBuilder(this.ctx.provider.connection, this.ctx.provider.wallet, this.ctx.txBuilderOpts);
        const accountExemption = await this.ctx.fetcher.getAccountRentExempt();
        let ataMap = { ...ownerTokenAccountMap };
        if (!ownerTokenAccountMap) {
          const affliatedMints = (0, whirlpool_ata_utils_1.getTokenMintsFromWhirlpools)([whirlpool], whirlpool_ata_utils_1.TokenMintTypes.POOL_ONLY);
          const { ataTokenAddresses: affliatedTokenAtaMap, resolveAtaIxs } = await (0, whirlpool_ata_utils_1.resolveAtaForMints)(this.ctx, {
            mints: affliatedMints.mintMap,
            accountExemption,
            receiver: destinationWalletKey,
            payer: ataPayerKey
          });
          txBuilder.addInstructions(resolveAtaIxs);
          if (affliatedMints.hasNativeMint) {
            let { address: wSOLAta, ...resolveWSolIx } = common_sdk_1.TokenUtil.createWrappedNativeAccountInstruction(destinationWalletKey, common_sdk_1.ZERO, accountExemption, ataPayerKey, destinationWalletKey, this.ctx.accountResolverOpts.createWrappedSolAccountMethod);
            affliatedTokenAtaMap[spl_token_1.NATIVE_MINT.toBase58()] = wSOLAta;
            txBuilder.addInstruction(resolveWSolIx);
          }
          ataMap = { ...affliatedTokenAtaMap };
        }
        const tokenOwnerAccountA = ataMap[whirlpool.tokenMintA.toBase58()];
        (0, tiny_invariant_1.default)(!!tokenOwnerAccountA, `No owner token account provided for wallet ${destinationWalletKey.toBase58()} for token A ${whirlpool.tokenMintA.toBase58()} `);
        const tokenOwnerAccountB = ataMap[whirlpool.tokenMintB.toBase58()];
        (0, tiny_invariant_1.default)(!!tokenOwnerAccountB, `No owner token account provided for wallet ${destinationWalletKey.toBase58()} for token B ${whirlpool.tokenMintB.toBase58()} `);
        const positionTokenAccount = (0, spl_token_1.getAssociatedTokenAddressSync)(this.data.positionMint, positionWalletKey, this.ctx.accountResolverOpts.allowPDAOwnerAddress, this.positionMintTokenProgramId);
        if (updateFeesAndRewards && !this.data.liquidity.isZero()) {
          const updateIx = await this.updateFeesAndRewards();
          txBuilder.addInstruction(updateIx);
        }
        const baseParams = {
          whirlpool: this.data.whirlpool,
          position: this.address,
          positionTokenAccount,
          tokenOwnerAccountA: common_sdk_1.AddressUtil.toPubKey(tokenOwnerAccountA),
          tokenOwnerAccountB: common_sdk_1.AddressUtil.toPubKey(tokenOwnerAccountB),
          tokenVaultA: whirlpool.tokenVaultA,
          tokenVaultB: whirlpool.tokenVaultB,
          positionAuthority: positionWalletKey
        };
        const ix = !token_extension_util_1.TokenExtensionUtil.isV2IxRequiredPool(tokenExtensionCtx) ? (0, instructions_1.collectFeesIx)(this.ctx.program, baseParams) : (0, instructions_1.collectFeesV2Ix)(this.ctx.program, {
          ...baseParams,
          tokenMintA: whirlpool.tokenMintA,
          tokenMintB: whirlpool.tokenMintB,
          tokenProgramA: tokenExtensionCtx.tokenMintWithProgramA.tokenProgram,
          tokenProgramB: tokenExtensionCtx.tokenMintWithProgramB.tokenProgram,
          ...await token_extension_util_1.TokenExtensionUtil.getExtraAccountMetasForTransferHookForPool(this.ctx.connection, tokenExtensionCtx, baseParams.tokenVaultA, baseParams.tokenOwnerAccountA, baseParams.whirlpool, baseParams.tokenVaultB, baseParams.tokenOwnerAccountB, baseParams.whirlpool)
        });
        txBuilder.addInstruction(ix);
        return txBuilder;
      }
      async collectRewards(rewardsToCollect, updateFeesAndRewards = true, ownerTokenAccountMap, destinationWallet, positionWallet, ataPayer, opts = fetcher_1.IGNORE_CACHE) {
        const [destinationWalletKey, positionWalletKey, ataPayerKey] = common_sdk_1.AddressUtil.toPubKeys([
          destinationWallet ?? this.ctx.wallet.publicKey,
          positionWallet ?? this.ctx.wallet.publicKey,
          ataPayer ?? this.ctx.wallet.publicKey
        ]);
        const whirlpool = await this.ctx.fetcher.getPool(this.data.whirlpool, opts);
        if (!whirlpool) {
          throw new Error(`Unable to fetch whirlpool(${this.data.whirlpool}) for this position(${this.address}).`);
        }
        const initializedRewards = whirlpool.rewardInfos.filter((info) => public_1.PoolUtil.isRewardInitialized(info));
        const tokenExtensionCtx = await token_extension_util_1.TokenExtensionUtil.buildTokenExtensionContext(this.ctx.fetcher, whirlpool, fetcher_1.IGNORE_CACHE);
        let resolvedAtas;
        if (ownerTokenAccountMap) {
          resolvedAtas = {};
          Object.entries(ownerTokenAccountMap).forEach(([mint, address]) => {
            if (!address)
              return;
            resolvedAtas[mint] = {
              address: common_sdk_1.AddressUtil.toPubKey(address),
              instructions: [],
              cleanupInstructions: [],
              signers: [],
              tokenProgram: web3_js_1.PublicKey.default
            };
          });
        } else {
          const accountExemption = await this.ctx.fetcher.getAccountRentExempt();
          const rewardMints = (0, whirlpool_ata_utils_1.getTokenMintsFromWhirlpools)([whirlpool], whirlpool_ata_utils_1.TokenMintTypes.REWARD_ONLY);
          resolvedAtas = (0, txn_utils_1.convertListToMap)(await (0, common_sdk_1.resolveOrCreateATAs)(this.ctx.connection, destinationWalletKey, rewardMints.mintMap.map((tokenMint) => ({ tokenMint })), async () => accountExemption, ataPayerKey, true, this.ctx.accountResolverOpts.allowPDAOwnerAddress), rewardMints.mintMap.map((mint) => mint.toBase58()));
        }
        const builder = new txn_utils_1.MultipleTransactionBuilderFactoryWithAccountResolver(this.ctx, resolvedAtas, destinationWalletKey, ataPayerKey);
        const positionTokenAccount = (0, spl_token_1.getAssociatedTokenAddressSync)(this.data.positionMint, positionWalletKey, this.ctx.accountResolverOpts.allowPDAOwnerAddress, this.positionMintTokenProgramId);
        if (updateFeesAndRewards && !this.data.liquidity.isZero()) {
          await builder.addInstructions(async () => {
            const updateIx = await this.updateFeesAndRewards();
            return [updateIx];
          });
        }
        for (let index = 0; index < initializedRewards.length; index++) {
          const info = initializedRewards[index];
          if (rewardsToCollect && !rewardsToCollect.some((r) => r.toString() === info.mint.toBase58())) {
            break;
          }
          await builder.addInstructions(async (resolve) => {
            const rewardOwnerAccount = resolve(info.mint.toBase58());
            (0, tiny_invariant_1.default)(!!rewardOwnerAccount, `No owner token account provided for wallet ${destinationWalletKey.toBase58()} for reward ${index} token ${info.mint.toBase58()} `);
            const baseParams = {
              whirlpool: this.data.whirlpool,
              position: this.address,
              positionTokenAccount,
              rewardIndex: index,
              rewardOwnerAccount: common_sdk_1.AddressUtil.toPubKey(rewardOwnerAccount),
              rewardVault: info.vault,
              positionAuthority: positionWalletKey
            };
            const ix = !token_extension_util_1.TokenExtensionUtil.isV2IxRequiredReward(tokenExtensionCtx, index) ? (0, instructions_1.collectRewardIx)(this.ctx.program, baseParams) : (0, instructions_1.collectRewardV2Ix)(this.ctx.program, {
              ...baseParams,
              rewardMint: info.mint,
              rewardTokenProgram: tokenExtensionCtx.rewardTokenMintsWithProgram[index].tokenProgram,
              rewardTransferHookAccounts: await token_extension_util_1.TokenExtensionUtil.getExtraAccountMetasForTransferHook(this.ctx.connection, tokenExtensionCtx.rewardTokenMintsWithProgram[index], baseParams.rewardVault, baseParams.rewardOwnerAccount, baseParams.whirlpool)
            });
            return [ix];
          });
        }
        return builder.build();
      }
      async lock(lockType, positionWallet, funder) {
        const [positionWalletKey, funderKey] = common_sdk_1.AddressUtil.toPubKeys([
          positionWallet ?? this.ctx.wallet.publicKey,
          funder ?? this.ctx.wallet.publicKey
        ]);
        let txBuilder = new common_sdk_1.TransactionBuilder(this.ctx.provider.connection, this.ctx.provider.wallet, this.ctx.txBuilderOpts);
        const positionTokenAccount = (0, spl_token_1.getAssociatedTokenAddressSync)(this.data.positionMint, positionWalletKey, this.ctx.accountResolverOpts.allowPDAOwnerAddress, this.positionMintTokenProgramId);
        const ix = (0, instructions_1.lockPositionIx)(this.ctx.program, {
          funder: funderKey,
          positionAuthority: positionWalletKey,
          position: this.address,
          positionMint: this.data.positionMint,
          positionTokenAccount,
          whirlpool: this.data.whirlpool,
          lockConfigPda: public_1.PDAUtil.getLockConfig(this.ctx.program.programId, this.address),
          lockType
        });
        txBuilder.addInstruction(ix);
        return txBuilder;
      }
      async resetPositionRange(tickLowerIndex, tickUpperIndex, positionWallet, funder) {
        const [positionWalletKey, funderKey] = common_sdk_1.AddressUtil.toPubKeys([
          positionWallet ?? this.ctx.wallet.publicKey,
          funder ?? this.ctx.wallet.publicKey
        ]);
        const txBuilder = new common_sdk_1.TransactionBuilder(this.ctx.provider.connection, this.ctx.provider.wallet, this.ctx.txBuilderOpts);
        const positionTokenAccount = (0, spl_token_1.getAssociatedTokenAddressSync)(this.data.positionMint, positionWalletKey, this.ctx.accountResolverOpts.allowPDAOwnerAddress, this.positionMintTokenProgramId);
        const ix = (0, instructions_1.resetPositionRangeIx)(this.ctx.program, {
          funder: funderKey,
          positionAuthority: positionWalletKey,
          whirlpool: this.data.whirlpool,
          position: this.address,
          positionTokenAccount,
          tickLowerIndex,
          tickUpperIndex
        });
        txBuilder.addInstruction(ix);
        return txBuilder;
      }
      async getLockConfigData() {
        const lockConfig = await this.ctx.fetcher.getLockConfig(public_1.PDAUtil.getLockConfig(this.ctx.program.programId, this.address).publicKey, fetcher_1.IGNORE_CACHE);
        return lockConfig;
      }
      async refresh() {
        const positionAccount = await this.ctx.fetcher.getPosition(this.address, fetcher_1.IGNORE_CACHE);
        if (!!positionAccount) {
          this.data = positionAccount;
        }
        const whirlpoolAccount = await this.ctx.fetcher.getPool(this.data.whirlpool, fetcher_1.IGNORE_CACHE);
        if (!!whirlpoolAccount) {
          this.whirlpoolData = whirlpoolAccount;
        }
        const [lowerTickArray, upperTickArray] = await (0, position_builder_util_1.getTickArrayDataForPosition)(this.ctx, this.data, this.whirlpoolData, fetcher_1.IGNORE_CACHE);
        if (lowerTickArray) {
          this.lowerTickArrayData = lowerTickArray;
        }
        if (upperTickArray) {
          this.upperTickArrayData = upperTickArray;
        }
      }
      async updateFeesAndRewards() {
        const whirlpool = await this.ctx.fetcher.getPool(this.data.whirlpool);
        if (!whirlpool) {
          throw new Error(`Unable to fetch whirlpool(${this.data.whirlpool}) for this position(${this.address}).`);
        }
        const [tickArrayLowerPda, tickArrayUpperPda] = [
          this.data.tickLowerIndex,
          this.data.tickUpperIndex
        ].map((tickIndex) => public_1.PDAUtil.getTickArrayFromTickIndex(tickIndex, whirlpool.tickSpacing, this.data.whirlpool, this.ctx.program.programId));
        const updateIx = (0, instructions_1.updateFeesAndRewardsIx)(this.ctx.program, {
          whirlpool: this.data.whirlpool,
          position: this.address,
          tickArrayLower: tickArrayLowerPda.publicKey,
          tickArrayUpper: tickArrayUpperPda.publicKey
        });
        return updateIx;
      }
    };
    exports2.PositionImpl = PositionImpl;
  }
});

// node_modules/@orca-so/whirlpools-sdk/dist/utils/math/swap-math.js
var require_swap_math = __commonJS({
  "node_modules/@orca-so/whirlpools-sdk/dist/utils/math/swap-math.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.computeSwapStep = computeSwapStep;
    var bn_js_1 = __importDefault(require_bn());
    var public_1 = require_public();
    var bit_math_1 = require_bit_math();
    var token_math_1 = require_token_math();
    function computeSwapStep(amountRemaining, feeRate, currLiquidity, currSqrtPrice, targetSqrtPrice, amountSpecifiedIsInput, aToB) {
      let initialAmountFixedDelta = tryGetAmountFixedDelta(currSqrtPrice, targetSqrtPrice, currLiquidity, amountSpecifiedIsInput, aToB);
      let amountCalc = amountRemaining;
      if (amountSpecifiedIsInput) {
        const result = bit_math_1.BitMath.mulDiv(amountRemaining, public_1.FEE_RATE_MUL_VALUE.sub(new bn_js_1.default(feeRate)), public_1.FEE_RATE_MUL_VALUE, 128);
        amountCalc = result;
      }
      let nextSqrtPrice = initialAmountFixedDelta.lte(amountCalc) ? targetSqrtPrice : (0, token_math_1.getNextSqrtPrice)(currSqrtPrice, currLiquidity, amountCalc, amountSpecifiedIsInput, aToB);
      let isMaxSwap = nextSqrtPrice.eq(targetSqrtPrice);
      let amountUnfixedDelta = getAmountUnfixedDelta(currSqrtPrice, nextSqrtPrice, currLiquidity, amountSpecifiedIsInput, aToB);
      let amountFixedDelta = !isMaxSwap || initialAmountFixedDelta.exceedsMax() ? getAmountFixedDelta(currSqrtPrice, nextSqrtPrice, currLiquidity, amountSpecifiedIsInput, aToB) : initialAmountFixedDelta.value();
      let amountIn = amountSpecifiedIsInput ? amountFixedDelta : amountUnfixedDelta;
      let amountOut = amountSpecifiedIsInput ? amountUnfixedDelta : amountFixedDelta;
      if (!amountSpecifiedIsInput && amountOut.gt(amountRemaining)) {
        amountOut = amountRemaining;
      }
      let feeAmount;
      if (amountSpecifiedIsInput && !isMaxSwap) {
        feeAmount = amountRemaining.sub(amountIn);
      } else {
        const feeRateBN = new bn_js_1.default(feeRate);
        feeAmount = bit_math_1.BitMath.mulDivRoundUp(amountIn, feeRateBN, public_1.FEE_RATE_MUL_VALUE.sub(feeRateBN), 128);
      }
      return {
        amountIn,
        amountOut,
        nextPrice: nextSqrtPrice,
        feeAmount
      };
    }
    function getAmountFixedDelta(currSqrtPrice, targetSqrtPrice, currLiquidity, amountSpecifiedIsInput, aToB) {
      if (aToB === amountSpecifiedIsInput) {
        return (0, token_math_1.getAmountDeltaA)(currSqrtPrice, targetSqrtPrice, currLiquidity, amountSpecifiedIsInput);
      } else {
        return (0, token_math_1.getAmountDeltaB)(currSqrtPrice, targetSqrtPrice, currLiquidity, amountSpecifiedIsInput);
      }
    }
    function tryGetAmountFixedDelta(currSqrtPrice, targetSqrtPrice, currLiquidity, amountSpecifiedIsInput, aToB) {
      if (aToB === amountSpecifiedIsInput) {
        return (0, token_math_1.tryGetAmountDeltaA)(currSqrtPrice, targetSqrtPrice, currLiquidity, amountSpecifiedIsInput);
      } else {
        return (0, token_math_1.tryGetAmountDeltaB)(currSqrtPrice, targetSqrtPrice, currLiquidity, amountSpecifiedIsInput);
      }
    }
    function getAmountUnfixedDelta(currSqrtPrice, targetSqrtPrice, currLiquidity, amountSpecifiedIsInput, aToB) {
      if (aToB === amountSpecifiedIsInput) {
        return (0, token_math_1.getAmountDeltaB)(currSqrtPrice, targetSqrtPrice, currLiquidity, !amountSpecifiedIsInput);
      } else {
        return (0, token_math_1.getAmountDeltaA)(currSqrtPrice, targetSqrtPrice, currLiquidity, !amountSpecifiedIsInput);
      }
    }
  }
});

// node_modules/@orca-so/whirlpools-sdk/dist/quotes/swap/swap-manager.js
var require_swap_manager = __commonJS({
  "node_modules/@orca-so/whirlpools-sdk/dist/quotes/swap/swap-manager.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.computeSwap = computeSwap;
    var common_sdk_1 = require_dist2();
    var bn_js_1 = __importDefault(require_bn());
    var public_1 = require_public();
    var swap_math_1 = require_swap_math();
    var public_2 = require_public3();
    var errors_1 = require_errors3();
    function computeSwap(whirlpoolData, tickSequence, tokenAmount, sqrtPriceLimit, amountSpecifiedIsInput, aToB) {
      let amountRemaining = tokenAmount;
      let amountCalculated = common_sdk_1.ZERO;
      let currSqrtPrice = whirlpoolData.sqrtPrice;
      let currLiquidity = whirlpoolData.liquidity;
      let currTickIndex = whirlpoolData.tickCurrentIndex;
      let totalFeeAmount = common_sdk_1.ZERO;
      const feeRate = whirlpoolData.feeRate;
      const protocolFeeRate = whirlpoolData.protocolFeeRate;
      let currProtocolFee = new bn_js_1.default(0);
      let currFeeGrowthGlobalInput = aToB ? whirlpoolData.feeGrowthGlobalA : whirlpoolData.feeGrowthGlobalB;
      while (amountRemaining.gt(common_sdk_1.ZERO) && !sqrtPriceLimit.eq(currSqrtPrice)) {
        let { nextIndex: nextTickIndex } = tickSequence.findNextInitializedTickIndex(currTickIndex);
        let { nextTickPrice, nextSqrtPriceLimit: targetSqrtPrice } = getNextSqrtPrices(nextTickIndex, sqrtPriceLimit, aToB);
        const swapComputation = (0, swap_math_1.computeSwapStep)(amountRemaining, feeRate, currLiquidity, currSqrtPrice, targetSqrtPrice, amountSpecifiedIsInput, aToB);
        totalFeeAmount = totalFeeAmount.add(swapComputation.feeAmount);
        if (amountSpecifiedIsInput) {
          amountRemaining = amountRemaining.sub(swapComputation.amountIn);
          amountRemaining = amountRemaining.sub(swapComputation.feeAmount);
          amountCalculated = amountCalculated.add(swapComputation.amountOut);
        } else {
          amountRemaining = amountRemaining.sub(swapComputation.amountOut);
          amountCalculated = amountCalculated.add(swapComputation.amountIn);
          amountCalculated = amountCalculated.add(swapComputation.feeAmount);
        }
        if (amountRemaining.isNeg()) {
          throw new errors_1.WhirlpoolsError("Amount remaining is negative.", errors_1.SwapErrorCode.AmountRemainingOverflow);
        }
        if (amountCalculated.gt(common_sdk_1.U64_MAX)) {
          throw new errors_1.WhirlpoolsError("Amount calculated is greater than U64_MAX.", errors_1.SwapErrorCode.AmountCalcOverflow);
        }
        let { nextProtocolFee, nextFeeGrowthGlobalInput } = calculateFees(swapComputation.feeAmount, protocolFeeRate, currLiquidity, currProtocolFee, currFeeGrowthGlobalInput);
        currProtocolFee = nextProtocolFee;
        currFeeGrowthGlobalInput = nextFeeGrowthGlobalInput;
        if (swapComputation.nextPrice.eq(nextTickPrice)) {
          const nextTick = tickSequence.getTick(nextTickIndex);
          if (nextTick.initialized) {
            currLiquidity = calculateNextLiquidity(nextTick.liquidityNet, currLiquidity, aToB);
          }
          currTickIndex = aToB ? nextTickIndex - 1 : nextTickIndex;
        } else {
          currTickIndex = public_2.PriceMath.sqrtPriceX64ToTickIndex(swapComputation.nextPrice);
        }
        currSqrtPrice = swapComputation.nextPrice;
      }
      let { amountA, amountB } = calculateEstTokens(tokenAmount, amountRemaining, amountCalculated, aToB, amountSpecifiedIsInput);
      return {
        amountA,
        amountB,
        nextTickIndex: currTickIndex,
        nextSqrtPrice: currSqrtPrice,
        totalFeeAmount
      };
    }
    function getNextSqrtPrices(nextTick, sqrtPriceLimit, aToB) {
      const nextTickPrice = public_2.PriceMath.tickIndexToSqrtPriceX64(nextTick);
      const nextSqrtPriceLimit = aToB ? bn_js_1.default.max(sqrtPriceLimit, nextTickPrice) : bn_js_1.default.min(sqrtPriceLimit, nextTickPrice);
      return { nextTickPrice, nextSqrtPriceLimit };
    }
    function calculateFees(feeAmount, protocolFeeRate, currLiquidity, currProtocolFee, currFeeGrowthGlobalInput) {
      let nextProtocolFee = currProtocolFee;
      let nextFeeGrowthGlobalInput = currFeeGrowthGlobalInput;
      let globalFee = feeAmount;
      if (protocolFeeRate > 0) {
        let delta = calculateProtocolFee(globalFee, protocolFeeRate);
        globalFee = globalFee.sub(delta);
        nextProtocolFee = nextProtocolFee.add(currProtocolFee);
      }
      if (currLiquidity.gt(common_sdk_1.ZERO)) {
        const globalFeeIncrement = globalFee.shln(64).div(currLiquidity);
        nextFeeGrowthGlobalInput = nextFeeGrowthGlobalInput.add(globalFeeIncrement);
      }
      return {
        nextProtocolFee,
        nextFeeGrowthGlobalInput
      };
    }
    function calculateProtocolFee(globalFee, protocolFeeRate) {
      return globalFee.mul(new bn_js_1.default(protocolFeeRate).div(public_1.PROTOCOL_FEE_RATE_MUL_VALUE));
    }
    function calculateEstTokens(amount, amountRemaining, amountCalculated, aToB, amountSpecifiedIsInput) {
      return aToB === amountSpecifiedIsInput ? {
        amountA: amount.sub(amountRemaining),
        amountB: amountCalculated
      } : {
        amountA: amountCalculated,
        amountB: amount.sub(amountRemaining)
      };
    }
    function calculateNextLiquidity(tickNetLiquidity, currLiquidity, aToB) {
      return aToB ? currLiquidity.sub(tickNetLiquidity) : currLiquidity.add(tickNetLiquidity);
    }
  }
});

// node_modules/@orca-so/whirlpools-sdk/dist/quotes/swap/tick-array-index.js
var require_tick_array_index = __commonJS({
  "node_modules/@orca-so/whirlpools-sdk/dist/quotes/swap/tick-array-index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TickArrayIndex = void 0;
    var public_1 = require_public();
    var TickArrayIndex = class _TickArrayIndex {
      arrayIndex;
      offsetIndex;
      tickSpacing;
      static fromTickIndex(index, tickSpacing) {
        const arrayIndex = Math.floor(Math.floor(index / tickSpacing) / public_1.TICK_ARRAY_SIZE);
        let offsetIndex = Math.floor(index % (tickSpacing * public_1.TICK_ARRAY_SIZE) / tickSpacing);
        if (offsetIndex < 0) {
          offsetIndex = public_1.TICK_ARRAY_SIZE + offsetIndex;
        }
        return new _TickArrayIndex(arrayIndex, offsetIndex, tickSpacing);
      }
      constructor(arrayIndex, offsetIndex, tickSpacing) {
        this.arrayIndex = arrayIndex;
        this.offsetIndex = offsetIndex;
        this.tickSpacing = tickSpacing;
        if (offsetIndex >= public_1.TICK_ARRAY_SIZE) {
          throw new Error("Invalid offsetIndex - value has to be smaller than TICK_ARRAY_SIZE");
        }
        if (offsetIndex < 0) {
          throw new Error("Invalid offsetIndex - value is smaller than 0");
        }
        if (tickSpacing < 0) {
          throw new Error("Invalid tickSpacing - value is less than 0");
        }
      }
      toTickIndex() {
        return this.arrayIndex * public_1.TICK_ARRAY_SIZE * this.tickSpacing + this.offsetIndex * this.tickSpacing;
      }
      toNextInitializableTickIndex() {
        return _TickArrayIndex.fromTickIndex(this.toTickIndex() + this.tickSpacing, this.tickSpacing);
      }
      toPrevInitializableTickIndex() {
        return _TickArrayIndex.fromTickIndex(this.toTickIndex() - this.tickSpacing, this.tickSpacing);
      }
    };
    exports2.TickArrayIndex = TickArrayIndex;
  }
});

// node_modules/@orca-so/whirlpools-sdk/dist/quotes/swap/tick-array-sequence.js
var require_tick_array_sequence = __commonJS({
  "node_modules/@orca-so/whirlpools-sdk/dist/quotes/swap/tick-array-sequence.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TickArraySequence = void 0;
    var errors_1 = require_errors3();
    var public_1 = require_public();
    var tick_array_index_1 = require_tick_array_index();
    var TickArraySequence = class {
      tickSpacing;
      aToB;
      sequence;
      touchedArrays;
      startArrayIndex;
      constructor(tickArrays, tickSpacing, aToB) {
        this.tickSpacing = tickSpacing;
        this.aToB = aToB;
        if (!tickArrays[0] || !tickArrays[0].data) {
          throw new Error("TickArray index 0 must be initialized");
        }
        this.sequence = [];
        for (const tickArray of tickArrays) {
          if (!tickArray || !tickArray.data) {
            break;
          }
          this.sequence.push({
            address: tickArray.address,
            startTickIndex: tickArray.data.startTickIndex,
            data: tickArray.data
          });
        }
        this.touchedArrays = [...Array(this.sequence.length).fill(false)];
        this.startArrayIndex = tick_array_index_1.TickArrayIndex.fromTickIndex(this.sequence[0].data.startTickIndex, this.tickSpacing).arrayIndex;
      }
      isValidTickArray0(tickCurrentIndex) {
        const shift = this.aToB ? 0 : this.tickSpacing;
        const tickArray = this.sequence[0].data;
        return this.checkIfIndexIsInTickArrayRange(tickArray.startTickIndex, tickCurrentIndex + shift);
      }
      getNumOfTouchedArrays() {
        return this.touchedArrays.filter((val) => !!val).length;
      }
      getTouchedArrays(minArraySize) {
        let result = this.touchedArrays.reduce((prev, curr, index) => {
          if (curr) {
            prev.push(this.sequence[index].address);
          }
          return prev;
        }, []);
        if (result.length === 0) {
          return [];
        }
        const sizeDiff = minArraySize - result.length;
        if (sizeDiff > 0) {
          result = result.concat(Array(sizeDiff).fill(result[result.length - 1]));
        }
        return result;
      }
      getTick(index) {
        const targetTaIndex = tick_array_index_1.TickArrayIndex.fromTickIndex(index, this.tickSpacing);
        if (!this.isArrayIndexInBounds(targetTaIndex, this.aToB)) {
          throw new Error("Provided tick index is out of bounds for this sequence.");
        }
        const localArrayIndex = this.getLocalArrayIndex(targetTaIndex.arrayIndex, this.aToB);
        const tickArray = this.sequence[localArrayIndex].data;
        this.touchedArrays[localArrayIndex] = true;
        if (!tickArray) {
          throw new errors_1.WhirlpoolsError(`TickArray at index ${localArrayIndex} is not initialized.`, errors_1.SwapErrorCode.TickArrayIndexNotInitialized);
        }
        if (!this.checkIfIndexIsInTickArrayRange(tickArray.startTickIndex, index)) {
          throw new errors_1.WhirlpoolsError(`TickArray at index ${localArrayIndex} is unexpected for this sequence.`, errors_1.SwapErrorCode.TickArraySequenceInvalid);
        }
        return tickArray.ticks[targetTaIndex.offsetIndex];
      }
      findNextInitializedTickIndex(currIndex) {
        const searchIndex = this.aToB ? currIndex : currIndex + this.tickSpacing;
        let currTaIndex = tick_array_index_1.TickArrayIndex.fromTickIndex(searchIndex, this.tickSpacing);
        if (!this.isArrayIndexInBounds(currTaIndex, this.aToB)) {
          throw new errors_1.WhirlpoolsError(`Swap input value traversed too many arrays. Out of bounds at attempt to traverse tick index - ${currTaIndex.toTickIndex()}.`, errors_1.SwapErrorCode.TickArraySequenceInvalid);
        }
        while (this.isArrayIndexInBounds(currTaIndex, this.aToB)) {
          const currTickData = this.getTick(currTaIndex.toTickIndex());
          if (currTickData.initialized) {
            return {
              nextIndex: currTaIndex.toTickIndex(),
              nextTickData: currTickData
            };
          }
          currTaIndex = this.aToB ? currTaIndex.toPrevInitializableTickIndex() : currTaIndex.toNextInitializableTickIndex();
        }
        const lastIndexInArray = Math.max(Math.min(this.aToB ? currTaIndex.toTickIndex() + this.tickSpacing : currTaIndex.toTickIndex() - 1, public_1.MAX_TICK_INDEX), public_1.MIN_TICK_INDEX);
        return { nextIndex: lastIndexInArray, nextTickData: null };
      }
      getLocalArrayIndex(arrayIndex, aToB) {
        return aToB ? this.startArrayIndex - arrayIndex : arrayIndex - this.startArrayIndex;
      }
      isArrayIndexInBounds(index, aToB) {
        const localArrayIndex = this.getLocalArrayIndex(index.arrayIndex, aToB);
        const seqLength = this.sequence.length;
        return localArrayIndex >= 0 && localArrayIndex < seqLength;
      }
      checkIfIndexIsInTickArrayRange(startTick, tickIndex) {
        const upperBound = startTick + this.tickSpacing * public_1.TICK_ARRAY_SIZE;
        return tickIndex >= startTick && tickIndex < upperBound;
      }
    };
    exports2.TickArraySequence = TickArraySequence;
  }
});

// node_modules/@orca-so/whirlpools-sdk/dist/quotes/swap/swap-quote-impl.js
var require_swap_quote_impl = __commonJS({
  "node_modules/@orca-so/whirlpools-sdk/dist/quotes/swap/swap-quote-impl.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.simulateSwap = simulateSwap;
    var anchor_1 = require("@coral-xyz/anchor");
    var common_sdk_1 = require_dist2();
    var errors_1 = require_errors3();
    var public_1 = require_public();
    var swap_manager_1 = require_swap_manager();
    var tick_array_sequence_1 = require_tick_array_sequence();
    var token_extension_util_1 = require_token_extension_util();
    function simulateSwap(params) {
      const { aToB, whirlpoolData, tickArrays, tokenAmount, sqrtPriceLimit, otherAmountThreshold, amountSpecifiedIsInput, tokenExtensionCtx } = params;
      if (sqrtPriceLimit.gt(new anchor_1.BN(public_1.MAX_SQRT_PRICE)) || sqrtPriceLimit.lt(new anchor_1.BN(public_1.MIN_SQRT_PRICE))) {
        throw new errors_1.WhirlpoolsError("Provided SqrtPriceLimit is out of bounds.", errors_1.SwapErrorCode.SqrtPriceOutOfBounds);
      }
      if (aToB && sqrtPriceLimit.gt(whirlpoolData.sqrtPrice) || !aToB && sqrtPriceLimit.lt(whirlpoolData.sqrtPrice)) {
        throw new errors_1.WhirlpoolsError("Provided SqrtPriceLimit is in the opposite direction of the trade.", errors_1.SwapErrorCode.InvalidSqrtPriceLimitDirection);
      }
      if (tokenAmount.eq(common_sdk_1.ZERO)) {
        throw new errors_1.WhirlpoolsError("Provided tokenAmount is zero.", errors_1.SwapErrorCode.ZeroTradableAmount);
      }
      const tickSequence = new tick_array_sequence_1.TickArraySequence(tickArrays, whirlpoolData.tickSpacing, aToB);
      if (!tickSequence.isValidTickArray0(whirlpoolData.tickCurrentIndex)) {
        throw new errors_1.WhirlpoolsError("TickArray at index 0 does not contain the Whirlpool current tick index.", errors_1.SwapErrorCode.TickArraySequenceInvalid);
      }
      if (amountSpecifiedIsInput) {
        const transferFeeExcludedIn = token_extension_util_1.TokenExtensionUtil.calculateTransferFeeExcludedAmount(tokenAmount, aToB ? tokenExtensionCtx.tokenMintWithProgramA : tokenExtensionCtx.tokenMintWithProgramB, tokenExtensionCtx.currentEpoch);
        if (transferFeeExcludedIn.amount.eq(common_sdk_1.ZERO)) {
          throw new errors_1.WhirlpoolsError("Provided tokenAmount is virtually zero due to transfer fee.", errors_1.SwapErrorCode.ZeroTradableAmount);
        }
        const swapResults2 = (0, swap_manager_1.computeSwap)(whirlpoolData, tickSequence, transferFeeExcludedIn.amount, sqrtPriceLimit, amountSpecifiedIsInput, aToB);
        const transferFeeExcludedOut2 = token_extension_util_1.TokenExtensionUtil.calculateTransferFeeExcludedAmount(aToB ? swapResults2.amountB : swapResults2.amountA, aToB ? tokenExtensionCtx.tokenMintWithProgramB : tokenExtensionCtx.tokenMintWithProgramA, tokenExtensionCtx.currentEpoch);
        if (transferFeeExcludedOut2.amount.lt(otherAmountThreshold)) {
          throw new errors_1.WhirlpoolsError("Quoted amount for the other token is below the otherAmountThreshold.", errors_1.SwapErrorCode.AmountOutBelowMinimum);
        }
        const fullfilled = (aToB ? swapResults2.amountA : swapResults2.amountB).eq(transferFeeExcludedIn.amount);
        const transferFeeIncludedIn2 = fullfilled ? { amount: tokenAmount, fee: transferFeeExcludedIn.fee } : token_extension_util_1.TokenExtensionUtil.calculateTransferFeeIncludedAmount(aToB ? swapResults2.amountA : swapResults2.amountB, aToB ? tokenExtensionCtx.tokenMintWithProgramA : tokenExtensionCtx.tokenMintWithProgramB, tokenExtensionCtx.currentEpoch);
        const numOfTickCrossings2 = tickSequence.getNumOfTouchedArrays();
        if (numOfTickCrossings2 > public_1.MAX_SWAP_TICK_ARRAYS) {
          throw new errors_1.WhirlpoolsError(`Input amount causes the quote to traverse more than the allowable amount of tick-arrays ${numOfTickCrossings2}`, errors_1.SwapErrorCode.TickArrayCrossingAboveMax);
        }
        const touchedArrays2 = tickSequence.getTouchedArrays(public_1.MAX_SWAP_TICK_ARRAYS);
        return {
          estimatedAmountIn: transferFeeIncludedIn2.amount,
          estimatedAmountOut: transferFeeExcludedOut2.amount,
          estimatedEndTickIndex: swapResults2.nextTickIndex,
          estimatedEndSqrtPrice: swapResults2.nextSqrtPrice,
          estimatedFeeAmount: swapResults2.totalFeeAmount,
          transferFee: {
            deductingFromEstimatedAmountIn: transferFeeIncludedIn2.fee,
            deductedFromEstimatedAmountOut: transferFeeExcludedOut2.fee
          },
          amount: tokenAmount,
          amountSpecifiedIsInput,
          aToB,
          otherAmountThreshold,
          sqrtPriceLimit,
          tickArray0: touchedArrays2[0],
          tickArray1: touchedArrays2[1],
          tickArray2: touchedArrays2[2]
        };
      }
      const transferFeeIncludedOut = token_extension_util_1.TokenExtensionUtil.calculateTransferFeeIncludedAmount(tokenAmount, aToB ? tokenExtensionCtx.tokenMintWithProgramB : tokenExtensionCtx.tokenMintWithProgramA, tokenExtensionCtx.currentEpoch);
      const swapResults = (0, swap_manager_1.computeSwap)(whirlpoolData, tickSequence, transferFeeIncludedOut.amount, sqrtPriceLimit, amountSpecifiedIsInput, aToB);
      const transferFeeIncludedIn = token_extension_util_1.TokenExtensionUtil.calculateTransferFeeIncludedAmount(aToB ? swapResults.amountA : swapResults.amountB, aToB ? tokenExtensionCtx.tokenMintWithProgramA : tokenExtensionCtx.tokenMintWithProgramB, tokenExtensionCtx.currentEpoch);
      if (transferFeeIncludedIn.amount.gt(otherAmountThreshold)) {
        throw new errors_1.WhirlpoolsError("Quoted amount for the other token is above the otherAmountThreshold.", errors_1.SwapErrorCode.AmountInAboveMaximum);
      }
      const transferFeeExcludedOut = token_extension_util_1.TokenExtensionUtil.calculateTransferFeeExcludedAmount(aToB ? swapResults.amountB : swapResults.amountA, aToB ? tokenExtensionCtx.tokenMintWithProgramB : tokenExtensionCtx.tokenMintWithProgramA, tokenExtensionCtx.currentEpoch);
      const numOfTickCrossings = tickSequence.getNumOfTouchedArrays();
      if (numOfTickCrossings > public_1.MAX_SWAP_TICK_ARRAYS) {
        throw new errors_1.WhirlpoolsError(`Input amount causes the quote to traverse more than the allowable amount of tick-arrays ${numOfTickCrossings}`, errors_1.SwapErrorCode.TickArrayCrossingAboveMax);
      }
      const touchedArrays = tickSequence.getTouchedArrays(public_1.MAX_SWAP_TICK_ARRAYS);
      return {
        estimatedAmountIn: transferFeeIncludedIn.amount,
        estimatedAmountOut: transferFeeExcludedOut.amount,
        estimatedEndTickIndex: swapResults.nextTickIndex,
        estimatedEndSqrtPrice: swapResults.nextSqrtPrice,
        estimatedFeeAmount: swapResults.totalFeeAmount,
        transferFee: {
          deductingFromEstimatedAmountIn: transferFeeIncludedIn.fee,
          deductedFromEstimatedAmountOut: transferFeeExcludedOut.fee
        },
        amount: tokenAmount,
        amountSpecifiedIsInput,
        aToB,
        otherAmountThreshold,
        sqrtPriceLimit,
        tickArray0: touchedArrays[0],
        tickArray1: touchedArrays[1],
        tickArray2: touchedArrays[2]
      };
    }
  }
});

// node_modules/@orca-so/whirlpools-sdk/dist/quotes/public/swap-quote.js
var require_swap_quote = __commonJS({
  "node_modules/@orca-so/whirlpools-sdk/dist/quotes/public/swap-quote.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.UseFallbackTickArray = void 0;
    exports2.swapQuoteByInputToken = swapQuoteByInputToken2;
    exports2.swapQuoteByOutputToken = swapQuoteByOutputToken;
    exports2.swapQuoteWithParams = swapQuoteWithParams;
    var common_sdk_1 = require_dist2();
    var tiny_invariant_1 = __importDefault(require_tiny_invariant_cjs());
    var fetcher_1 = require_fetcher2();
    var public_1 = require_public();
    var public_2 = require_public3();
    var swap_utils_1 = require_swap_utils2();
    var swap_quote_impl_1 = require_swap_quote_impl();
    var token_extension_util_1 = require_token_extension_util();
    var web3_js_1 = require("@solana/web3.js");
    var UseFallbackTickArray;
    (function(UseFallbackTickArray2) {
      UseFallbackTickArray2["Always"] = "Always";
      UseFallbackTickArray2["Never"] = "Never";
      UseFallbackTickArray2["Situational"] = "Situational";
    })(UseFallbackTickArray || (exports2.UseFallbackTickArray = UseFallbackTickArray = {}));
    async function swapQuoteByInputToken2(whirlpool, inputTokenMint, tokenAmount, slippageTolerance, programId, fetcher, opts, useFallbackTickArray = UseFallbackTickArray.Never) {
      const params = await swapQuoteByToken(whirlpool, inputTokenMint, tokenAmount, true, useFallbackTickArray, programId, fetcher, opts);
      return swapQuoteWithParams(params, slippageTolerance);
    }
    async function swapQuoteByOutputToken(whirlpool, outputTokenMint, tokenAmount, slippageTolerance, programId, fetcher, opts, useFallbackTickArray = UseFallbackTickArray.Never) {
      const params = await swapQuoteByToken(whirlpool, outputTokenMint, tokenAmount, false, useFallbackTickArray, programId, fetcher, opts);
      return swapQuoteWithParams(params, slippageTolerance);
    }
    function swapQuoteWithParams(params, slippageTolerance) {
      const quote = (0, swap_quote_impl_1.simulateSwap)({
        ...params,
        tickArrays: swap_utils_1.SwapUtils.interpolateUninitializedTickArrays(web3_js_1.PublicKey.default, params.tickArrays)
      });
      if (params.fallbackTickArray) {
        if (quote.tickArray2.equals(quote.tickArray1)) {
          quote.tickArray2 = params.fallbackTickArray;
        } else {
          quote.supplementalTickArrays = [params.fallbackTickArray];
        }
      }
      const slippageAdjustedQuote = {
        ...quote,
        ...swap_utils_1.SwapUtils.calculateSwapAmountsFromQuote(quote.amount, quote.estimatedAmountIn, quote.estimatedAmountOut, slippageTolerance, quote.amountSpecifiedIsInput)
      };
      return slippageAdjustedQuote;
    }
    async function swapQuoteByToken(whirlpool, inputTokenMint, tokenAmount, amountSpecifiedIsInput, useFallbackTickArray, programId, fetcher, opts) {
      const whirlpoolData = await fetcher.getPool(whirlpool.getAddress(), opts);
      (0, tiny_invariant_1.default)(!!whirlpoolData, "Whirlpool data not found");
      const swapMintKey = common_sdk_1.AddressUtil.toPubKey(inputTokenMint);
      const swapTokenType = public_2.PoolUtil.getTokenType(whirlpoolData, swapMintKey);
      (0, tiny_invariant_1.default)(!!swapTokenType, "swapTokenMint does not match any tokens on this pool");
      const aToB = swap_utils_1.SwapUtils.getSwapDirection(whirlpoolData, swapMintKey, amountSpecifiedIsInput) === public_2.SwapDirection.AtoB;
      const tickArrays = await swap_utils_1.SwapUtils.getTickArrays(whirlpoolData.tickCurrentIndex, whirlpoolData.tickSpacing, aToB, common_sdk_1.AddressUtil.toPubKey(programId), whirlpool.getAddress(), fetcher, opts);
      const fallbackTickArray = getFallbackTickArray(useFallbackTickArray, tickArrays, aToB, whirlpool, programId);
      const tokenExtensionCtx = await token_extension_util_1.TokenExtensionUtil.buildTokenExtensionContext(fetcher, whirlpoolData, fetcher_1.IGNORE_CACHE);
      return {
        whirlpoolData,
        tokenAmount,
        aToB,
        amountSpecifiedIsInput,
        sqrtPriceLimit: swap_utils_1.SwapUtils.getDefaultSqrtPriceLimit(aToB),
        otherAmountThreshold: swap_utils_1.SwapUtils.getDefaultOtherAmountThreshold(amountSpecifiedIsInput),
        tickArrays,
        tokenExtensionCtx,
        fallbackTickArray
      };
    }
    function getFallbackTickArray(useFallbackTickArray, tickArrays, aToB, whirlpool, programId) {
      if (useFallbackTickArray === UseFallbackTickArray.Never) {
        return void 0;
      }
      const fallbackTickArray = swap_utils_1.SwapUtils.getFallbackTickArrayPublicKey(tickArrays, whirlpool.getData().tickSpacing, aToB, common_sdk_1.AddressUtil.toPubKey(programId), whirlpool.getAddress());
      if (useFallbackTickArray === UseFallbackTickArray.Always || !fallbackTickArray) {
        return fallbackTickArray;
      }
      (0, tiny_invariant_1.default)(useFallbackTickArray === UseFallbackTickArray.Situational, `Unexpected UseFallbackTickArray value: ${useFallbackTickArray}`);
      const ticksInArray = whirlpool.getData().tickSpacing * public_1.TICK_ARRAY_SIZE;
      const tickCurrentIndex = whirlpool.getData().tickCurrentIndex;
      if (aToB) {
        const threshold = tickArrays[0].startTickIndex + ticksInArray / 4 * 3;
        return tickCurrentIndex >= threshold ? fallbackTickArray : void 0;
      } else {
        const threshold = tickArrays[0].startTickIndex + ticksInArray / 4;
        return tickCurrentIndex <= threshold ? fallbackTickArray : void 0;
      }
    }
  }
});

// node_modules/@orca-so/whirlpools-sdk/dist/prices/calculate-pool-prices.js
var require_calculate_pool_prices = __commonJS({
  "node_modules/@orca-so/whirlpools-sdk/dist/prices/calculate-pool-prices.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.calculatePricesForQuoteToken = calculatePricesForQuoteToken;
    exports2.isSubset = isSubset;
    exports2.convertAmount = convertAmount;
    var common_sdk_1 = require_dist2();
    var decimal_js_1 = __importDefault(require_decimal());
    var _1 = require_prices();
    var swap_quote_1 = require_swap_quote();
    var public_1 = require_public3();
    var token_extension_util_1 = require_token_extension_util();
    var swap_utils_1 = require_swap_utils();
    function checkLiquidity(pool, tickArrays, aToB, thresholdConfig, decimalsMap) {
      const { amountOut, priceImpactThreshold } = thresholdConfig;
      let estimatedAmountIn;
      try {
        ({ estimatedAmountIn } = (0, swap_quote_1.swapQuoteWithParams)({
          whirlpoolData: pool,
          aToB,
          amountSpecifiedIsInput: false,
          tokenAmount: amountOut,
          otherAmountThreshold: public_1.SwapUtils.getDefaultOtherAmountThreshold(false),
          sqrtPriceLimit: public_1.SwapUtils.getDefaultSqrtPriceLimit(aToB),
          tickArrays,
          tokenExtensionCtx: token_extension_util_1.NO_TOKEN_EXTENSION_CONTEXT
        }, common_sdk_1.Percentage.fromDecimal(new decimal_js_1.default(0))));
      } catch {
        return false;
      }
      let price, inputDecimals, outputDecimals;
      if (aToB) {
        price = getPrice(pool, decimalsMap);
        inputDecimals = decimalsMap[pool.tokenMintA.toBase58()];
        outputDecimals = decimalsMap[pool.tokenMintB.toBase58()];
      } else {
        price = getPrice(pool, decimalsMap).pow(-1);
        inputDecimals = decimalsMap[pool.tokenMintB.toBase58()];
        outputDecimals = decimalsMap[pool.tokenMintA.toBase58()];
      }
      const amountOutDecimals = common_sdk_1.DecimalUtil.fromBN(amountOut, outputDecimals);
      const estimatedAmountInDecimals = common_sdk_1.DecimalUtil.fromBN(estimatedAmountIn, inputDecimals);
      const maxAmountInDecimals = amountOutDecimals.div(price).mul(priceImpactThreshold).toDecimalPlaces(inputDecimals);
      return estimatedAmountInDecimals.lte(maxAmountInDecimals);
    }
    function getMostLiquidPools(quoteTokenMint, poolMap) {
      const mostLiquidPools = /* @__PURE__ */ new Map();
      Object.entries(poolMap).forEach(([address, pool]) => {
        const mintA = pool.tokenMintA.toBase58();
        const mintB = pool.tokenMintB.toBase58();
        if (pool.liquidity.isZero()) {
          return;
        }
        if (!pool.tokenMintA.equals(quoteTokenMint) && !pool.tokenMintB.equals(quoteTokenMint)) {
          return;
        }
        const baseTokenMint = pool.tokenMintA.equals(quoteTokenMint) ? mintB : mintA;
        const existingPool = mostLiquidPools.get(baseTokenMint);
        if (!existingPool || pool.liquidity.gt(existingPool.pool.liquidity)) {
          mostLiquidPools.set(baseTokenMint, {
            address: common_sdk_1.AddressUtil.toPubKey(address),
            pool
          });
        }
      });
      return Object.fromEntries(mostLiquidPools);
    }
    function calculatePricesForQuoteToken(mints, quoteTokenMint, poolMap, tickArrayMap, decimalsMap, config2, thresholdConfig) {
      const mostLiquidPools = getMostLiquidPools(quoteTokenMint, poolMap);
      return Object.fromEntries(mints.map((mintAddr) => {
        const mint = common_sdk_1.AddressUtil.toPubKey(mintAddr);
        if (mint.equals(quoteTokenMint)) {
          return [mint.toBase58(), new decimal_js_1.default(1)];
        }
        const [mintA, mintB] = public_1.PoolUtil.orderMints(mint, quoteTokenMint);
        const aToB = common_sdk_1.AddressUtil.toPubKey(mintB).equals(quoteTokenMint);
        const baseTokenMint = aToB ? mintA : mintB;
        const poolCandidate = mostLiquidPools[common_sdk_1.AddressUtil.toString(baseTokenMint)];
        if (poolCandidate === void 0) {
          return [mint.toBase58(), null];
        }
        const { pool, address } = poolCandidate;
        const tickArrays = getTickArrays(pool, address, aToB, tickArrayMap, config2);
        const isPoolLiquid = checkLiquidity(pool, tickArrays, aToB, thresholdConfig, decimalsMap);
        if (!isPoolLiquid) {
          return [mint.toBase58(), null];
        }
        const price = getPrice(pool, decimalsMap);
        const quotePrice = aToB ? price : price.pow(-1);
        return [mint.toBase58(), quotePrice];
      }));
    }
    function getTickArrays(pool, address, aToB, tickArrayMap, config2 = _1.defaultGetPricesConfig) {
      const { programId } = config2;
      const tickArrayAddresses = (0, swap_utils_1.getTickArrayPublicKeysWithStartTickIndex)(pool.tickCurrentIndex, pool.tickSpacing, aToB, programId, address);
      return tickArrayAddresses.map((a) => {
        return {
          address: a.pubkey,
          startTickIndex: a.startTickIndex,
          data: tickArrayMap[a.pubkey.toBase58()]
        };
      });
    }
    function getPrice(pool, decimalsMap) {
      const tokenAAddress = pool.tokenMintA.toBase58();
      const tokenBAddress = pool.tokenMintB.toBase58();
      if (!(tokenAAddress in decimalsMap) || !(tokenBAddress in decimalsMap)) {
        throw new Error("Missing token decimals");
      }
      return public_1.PriceMath.sqrtPriceX64ToPrice(pool.sqrtPrice, decimalsMap[tokenAAddress], decimalsMap[tokenBAddress]);
    }
    function isSubset(listA, listB) {
      return listA.every((itemA) => listB.includes(itemA));
    }
    function convertAmount(amount, price, amountDecimal, resultDecimal) {
      return common_sdk_1.DecimalUtil.toBN(common_sdk_1.DecimalUtil.fromBN(amount, amountDecimal).div(price), resultDecimal);
    }
  }
});

// node_modules/@orca-so/whirlpools-sdk/dist/prices/price-module.js
var require_price_module = __commonJS({
  "node_modules/@orca-so/whirlpools-sdk/dist/prices/price-module.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PriceModuleUtils = exports2.PriceModule = void 0;
    var common_sdk_1 = require_dist2();
    var web3_js_1 = require("@solana/web3.js");
    var _1 = require_prices();
    var fetcher_1 = require_fetcher2();
    var public_1 = require_public3();
    var txn_utils_1 = require_txn_utils();
    var calculate_pool_prices_1 = require_calculate_pool_prices();
    var PriceModule = class _PriceModule {
      static async fetchTokenPricesByMints(fetcher, mints, config2 = _1.defaultGetPricesConfig, thresholdConfig = _1.defaultGetPricesThresholdConfig, opts = fetcher_1.IGNORE_CACHE, availableData = {}) {
        const poolMap = availableData?.poolMap ? availableData?.poolMap : await PriceModuleUtils.fetchPoolDataFromMints(fetcher, mints, config2, opts);
        const tickArrayMap = availableData?.tickArrayMap ? availableData.tickArrayMap : await PriceModuleUtils.fetchTickArraysForPools(fetcher, poolMap, config2, opts);
        const decimalsMap = availableData?.decimalsMap ? availableData.decimalsMap : await PriceModuleUtils.fetchDecimalsForMints(fetcher, mints, fetcher_1.PREFER_CACHE);
        return _PriceModule.calculateTokenPrices(mints, {
          poolMap,
          tickArrayMap,
          decimalsMap
        }, config2, thresholdConfig);
      }
      static async fetchTokenPricesByPools(fetcher, pools, config2 = _1.defaultGetPricesConfig, thresholdConfig = _1.defaultGetPricesThresholdConfig, opts = fetcher_1.IGNORE_CACHE) {
        const poolDatas = Array.from((await fetcher.getPools(pools, opts)).values());
        const [filteredPoolDatas, filteredPoolAddresses] = (0, txn_utils_1.filterNullObjects)(poolDatas, pools);
        const poolMap = (0, txn_utils_1.convertListToMap)(filteredPoolDatas, common_sdk_1.AddressUtil.toStrings(filteredPoolAddresses));
        const tickArrayMap = await PriceModuleUtils.fetchTickArraysForPools(fetcher, poolMap, config2, opts);
        const mints = Array.from(Object.values(poolMap).reduce((acc, pool) => {
          acc.add(pool.tokenMintA.toBase58());
          acc.add(pool.tokenMintB.toBase58());
          return acc;
        }, /* @__PURE__ */ new Set()));
        const decimalsMap = await PriceModuleUtils.fetchDecimalsForMints(fetcher, mints, fetcher_1.PREFER_CACHE);
        return _PriceModule.calculateTokenPrices(mints, {
          poolMap,
          tickArrayMap,
          decimalsMap
        }, config2, thresholdConfig);
      }
      static calculateTokenPrices(mints, priceCalcData, config2 = _1.defaultGetPricesConfig, thresholdConfig = _1.defaultGetPricesThresholdConfig) {
        const { poolMap, decimalsMap, tickArrayMap } = priceCalcData;
        const mintStrings = common_sdk_1.AddressUtil.toStrings(mints);
        if (!(0, calculate_pool_prices_1.isSubset)(config2.quoteTokens.map((mint) => common_sdk_1.AddressUtil.toString(mint)), mintStrings.map((mint) => mint))) {
          throw new Error("Quote tokens must be in mints array");
        }
        const results = Object.fromEntries(mintStrings.map((mint) => [mint, null]));
        const remainingQuoteTokens = config2.quoteTokens.slice();
        let remainingMints = mints.slice();
        while (remainingQuoteTokens.length > 0 && remainingMints.length > 0) {
          const quoteToken = remainingQuoteTokens.shift();
          if (!quoteToken) {
            throw new Error("Unreachable: remainingQuoteTokens is an empty array");
          }
          let amountOutThresholdAgainstFirstQuoteToken;
          if (quoteToken.equals(config2.quoteTokens[0])) {
            amountOutThresholdAgainstFirstQuoteToken = thresholdConfig.amountOut;
          } else {
            const quoteTokenStr = quoteToken.toBase58();
            const quoteTokenPrice2 = results[quoteTokenStr];
            if (!quoteTokenPrice2) {
              throw new Error(`Quote token - ${quoteTokenStr} must have a price against the first quote token`);
            }
            amountOutThresholdAgainstFirstQuoteToken = (0, calculate_pool_prices_1.convertAmount)(thresholdConfig.amountOut, quoteTokenPrice2, decimalsMap[config2.quoteTokens[0].toBase58()], decimalsMap[quoteTokenStr]);
          }
          const prices = (0, calculate_pool_prices_1.calculatePricesForQuoteToken)(remainingMints, quoteToken, poolMap, tickArrayMap, decimalsMap, config2, {
            amountOut: amountOutThresholdAgainstFirstQuoteToken,
            priceImpactThreshold: thresholdConfig.priceImpactThreshold
          });
          const quoteTokenPrice = results[quoteToken.toBase58()] || prices[quoteToken.toBase58()];
          remainingMints.forEach((mintAddr) => {
            const mint = common_sdk_1.AddressUtil.toString(mintAddr);
            const mintPrice = prices[mint];
            if (mintPrice != null && quoteTokenPrice != null) {
              results[mint] = mintPrice.mul(quoteTokenPrice);
            }
          });
          remainingMints = remainingMints.filter((mint) => results[common_sdk_1.AddressUtil.toString(mint)] == null);
        }
        return results;
      }
    };
    exports2.PriceModule = PriceModule;
    var PriceModuleUtils = class {
      static async fetchPoolDataFromMints(fetcher, mints, config2 = _1.defaultGetPricesConfig, opts = fetcher_1.IGNORE_CACHE) {
        const { quoteTokens, tickSpacings, programId, whirlpoolsConfig } = config2;
        const poolAddresses = mints.map((mint) => tickSpacings.map((tickSpacing) => {
          return quoteTokens.map((quoteToken) => {
            const [mintA, mintB] = public_1.PoolUtil.orderMints(mint, quoteToken);
            return public_1.PDAUtil.getWhirlpool(programId, whirlpoolsConfig, common_sdk_1.AddressUtil.toPubKey(mintA), common_sdk_1.AddressUtil.toPubKey(mintB), tickSpacing).publicKey.toBase58();
          });
        }).flat()).flat();
        const poolDatas = Array.from((await fetcher.getPools(poolAddresses, opts)).values());
        const [filteredPoolDatas, filteredPoolAddresses] = (0, txn_utils_1.filterNullObjects)(poolDatas, poolAddresses);
        return (0, txn_utils_1.convertListToMap)(filteredPoolDatas, filteredPoolAddresses);
      }
      static async fetchTickArraysForPools(fetcher, pools, config2 = _1.defaultGetPricesConfig, opts = fetcher_1.IGNORE_CACHE) {
        const { programId } = config2;
        const getQuoteTokenOrder = (mint) => {
          const index = config2.quoteTokens.findIndex((quoteToken) => quoteToken.equals(mint));
          return index === -1 ? config2.quoteTokens.length : index;
        };
        const tickArrayAddressSet = /* @__PURE__ */ new Set();
        Object.entries(pools).forEach(([address, pool]) => {
          const orderA = getQuoteTokenOrder(pool.tokenMintA);
          const orderB = getQuoteTokenOrder(pool.tokenMintB);
          if (orderA === orderB) {
            return;
          }
          const aToB = orderA > orderB;
          const tickArrayPubkeys = public_1.SwapUtils.getTickArrayPublicKeys(pool.tickCurrentIndex, pool.tickSpacing, aToB, programId, new web3_js_1.PublicKey(address));
          tickArrayPubkeys.forEach((p) => tickArrayAddressSet.add(p.toBase58()));
        });
        const tickArrayAddresses = Array.from(tickArrayAddressSet);
        const tickArrays = await fetcher.getTickArrays(tickArrayAddresses, opts);
        const [filteredTickArrays, filteredTickArrayAddresses] = (0, txn_utils_1.filterNullObjects)(tickArrays, tickArrayAddresses);
        return (0, txn_utils_1.convertListToMap)(filteredTickArrays, filteredTickArrayAddresses);
      }
      static async fetchDecimalsForMints(fetcher, mints, opts = fetcher_1.IGNORE_CACHE) {
        const mintInfos = Array.from((await fetcher.getMintInfos(mints, opts)).values());
        return mintInfos.reduce((acc, mintInfo, index) => {
          const mint = common_sdk_1.AddressUtil.toString(mints[index]);
          if (!mintInfo) {
            throw new Error(`Mint account does not exist: ${mint}`);
          }
          acc[mint] = mintInfo.decimals;
          return acc;
        }, {});
      }
    };
    exports2.PriceModuleUtils = PriceModuleUtils;
  }
});

// node_modules/@orca-so/whirlpools-sdk/dist/prices/index.js
var require_prices = __commonJS({
  "node_modules/@orca-so/whirlpools-sdk/dist/prices/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.defaultGetPricesThresholdConfig = exports2.defaultGetPricesConfig = exports2.defaultQuoteTokens = void 0;
    var web3_js_1 = require("@solana/web3.js");
    var bn_js_1 = __importDefault(require_bn());
    var public_1 = require_public();
    var constants_1 = require_constants4();
    __exportStar(require_price_module(), exports2);
    exports2.defaultQuoteTokens = [
      constants_1.TOKEN_MINTS["USDC"],
      constants_1.TOKEN_MINTS["SOL"],
      constants_1.TOKEN_MINTS["mSOL"],
      constants_1.TOKEN_MINTS["stSOL"]
    ].map((mint) => new web3_js_1.PublicKey(mint));
    exports2.defaultGetPricesConfig = {
      quoteTokens: exports2.defaultQuoteTokens,
      tickSpacings: public_1.ORCA_SUPPORTED_TICK_SPACINGS,
      programId: public_1.ORCA_WHIRLPOOL_PROGRAM_ID,
      whirlpoolsConfig: public_1.ORCA_WHIRLPOOLS_CONFIG
    };
    exports2.defaultGetPricesThresholdConfig = {
      amountOut: new bn_js_1.default(1e9),
      priceImpactThreshold: 1.05
    };
  }
});

// node_modules/@orca-so/whirlpools-sdk/dist/utils/position-util.js
var require_position_util = __commonJS({
  "node_modules/@orca-so/whirlpools-sdk/dist/utils/position-util.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PositionUtil = exports2.PositionStatus = exports2.AmountSpecified = exports2.SwapDirection = void 0;
    exports2.adjustForSlippage = adjustForSlippage;
    exports2.adjustAmountForSlippage = adjustAmountForSlippage;
    exports2.getLiquidityFromTokenA = getLiquidityFromTokenA;
    exports2.getLiquidityFromTokenB = getLiquidityFromTokenB;
    exports2.getAmountFixedDelta = getAmountFixedDelta;
    exports2.getAmountUnfixedDelta = getAmountUnfixedDelta;
    exports2.getNextSqrtPrice = getNextSqrtPrice;
    exports2.getTokenAFromLiquidity = getTokenAFromLiquidity;
    exports2.getTokenBFromLiquidity = getTokenBFromLiquidity;
    var common_sdk_1 = require_dist2();
    var public_1 = require_public3();
    var swap_utils_1 = require_swap_utils();
    var SwapDirection;
    (function(SwapDirection2) {
      SwapDirection2["AtoB"] = "Swap A to B";
      SwapDirection2["BtoA"] = "Swap B to A";
    })(SwapDirection || (exports2.SwapDirection = SwapDirection = {}));
    var AmountSpecified;
    (function(AmountSpecified2) {
      AmountSpecified2["Input"] = "Specified input amount";
      AmountSpecified2["Output"] = "Specified output amount";
    })(AmountSpecified || (exports2.AmountSpecified = AmountSpecified = {}));
    var PositionStatus;
    (function(PositionStatus2) {
      PositionStatus2[PositionStatus2["BelowRange"] = 0] = "BelowRange";
      PositionStatus2[PositionStatus2["InRange"] = 1] = "InRange";
      PositionStatus2[PositionStatus2["AboveRange"] = 2] = "AboveRange";
    })(PositionStatus || (exports2.PositionStatus = PositionStatus = {}));
    var PositionUtil = class {
      static getPositionStatus(tickCurrentIndex, tickLowerIndex, tickUpperIndex) {
        if (tickCurrentIndex < tickLowerIndex) {
          return PositionStatus.BelowRange;
        } else if (tickCurrentIndex < tickUpperIndex) {
          return PositionStatus.InRange;
        } else {
          return PositionStatus.AboveRange;
        }
      }
      static getStrictPositionStatus(sqrtPriceX64, tickLowerIndex, tickUpperIndex) {
        const sqrtPriceLowerX64 = public_1.PriceMath.tickIndexToSqrtPriceX64(tickLowerIndex);
        const sqrtPriceUpperX64 = public_1.PriceMath.tickIndexToSqrtPriceX64(tickUpperIndex);
        if (sqrtPriceX64.lte(sqrtPriceLowerX64)) {
          return PositionStatus.BelowRange;
        } else if (sqrtPriceX64.gte(sqrtPriceUpperX64)) {
          return PositionStatus.AboveRange;
        } else {
          return PositionStatus.InRange;
        }
      }
    };
    exports2.PositionUtil = PositionUtil;
    function adjustForSlippage(n, { numerator, denominator }, adjustUp) {
      if (adjustUp) {
        return n.mul(denominator.add(numerator)).div(denominator);
      } else {
        return n.mul(denominator).div(denominator.add(numerator));
      }
    }
    function adjustAmountForSlippage(amountIn, amountOut, { numerator, denominator }, amountSpecified) {
      if (amountSpecified === AmountSpecified.Input) {
        return amountOut.mul(denominator).div(denominator.add(numerator));
      } else {
        return amountIn.mul(denominator.add(numerator)).div(denominator);
      }
    }
    function getLiquidityFromTokenA(amount, sqrtPriceLowerX64, sqrtPriceUpperX64, roundUp) {
      const result = amount.mul(sqrtPriceLowerX64).mul(sqrtPriceUpperX64).div(sqrtPriceUpperX64.sub(sqrtPriceLowerX64));
      if (roundUp) {
        return common_sdk_1.MathUtil.shiftRightRoundUp(result);
      } else {
        return result.shrn(64);
      }
    }
    function getLiquidityFromTokenB(amount, sqrtPriceLowerX64, sqrtPriceUpperX64, roundUp) {
      const numerator = amount.shln(64);
      const denominator = sqrtPriceUpperX64.sub(sqrtPriceLowerX64);
      if (roundUp) {
        return common_sdk_1.MathUtil.divRoundUp(numerator, denominator);
      } else {
        return numerator.div(denominator);
      }
    }
    function getAmountFixedDelta(currentSqrtPriceX64, targetSqrtPriceX64, liquidity, amountSpecified, swapDirection) {
      if (amountSpecified == AmountSpecified.Input == (swapDirection == SwapDirection.AtoB)) {
        return getTokenAFromLiquidity(liquidity, currentSqrtPriceX64, targetSqrtPriceX64, amountSpecified == AmountSpecified.Input);
      } else {
        return getTokenBFromLiquidity(liquidity, currentSqrtPriceX64, targetSqrtPriceX64, amountSpecified == AmountSpecified.Input);
      }
    }
    function getAmountUnfixedDelta(currentSqrtPriceX64, targetSqrtPriceX64, liquidity, amountSpecified, swapDirection) {
      if (amountSpecified == AmountSpecified.Input == (swapDirection == SwapDirection.AtoB)) {
        return getTokenBFromLiquidity(liquidity, currentSqrtPriceX64, targetSqrtPriceX64, amountSpecified == AmountSpecified.Output);
      } else {
        return getTokenAFromLiquidity(liquidity, currentSqrtPriceX64, targetSqrtPriceX64, amountSpecified == AmountSpecified.Output);
      }
    }
    function getNextSqrtPrice(sqrtPriceX64, liquidity, amount, amountSpecified, swapDirection) {
      if (amountSpecified === AmountSpecified.Input && swapDirection === SwapDirection.AtoB) {
        return (0, swap_utils_1.getLowerSqrtPriceFromTokenA)(amount, liquidity, sqrtPriceX64);
      } else if (amountSpecified === AmountSpecified.Output && swapDirection === SwapDirection.BtoA) {
        return (0, swap_utils_1.getUpperSqrtPriceFromTokenA)(amount, liquidity, sqrtPriceX64);
      } else if (amountSpecified === AmountSpecified.Input && swapDirection === SwapDirection.BtoA) {
        return (0, swap_utils_1.getUpperSqrtPriceFromTokenB)(amount, liquidity, sqrtPriceX64);
      } else {
        return (0, swap_utils_1.getLowerSqrtPriceFromTokenB)(amount, liquidity, sqrtPriceX64);
      }
    }
    function getTokenAFromLiquidity(liquidity, sqrtPrice0X64, sqrtPrice1X64, roundUp) {
      const [sqrtPriceLowerX64, sqrtPriceUpperX64] = orderSqrtPrice(sqrtPrice0X64, sqrtPrice1X64);
      const numerator = liquidity.mul(sqrtPriceUpperX64.sub(sqrtPriceLowerX64)).shln(64);
      const denominator = sqrtPriceUpperX64.mul(sqrtPriceLowerX64);
      if (roundUp) {
        return common_sdk_1.MathUtil.divRoundUp(numerator, denominator);
      } else {
        return numerator.div(denominator);
      }
    }
    function getTokenBFromLiquidity(liquidity, sqrtPrice0X64, sqrtPrice1X64, roundUp) {
      const [sqrtPriceLowerX64, sqrtPriceUpperX64] = orderSqrtPrice(sqrtPrice0X64, sqrtPrice1X64);
      const result = liquidity.mul(sqrtPriceUpperX64.sub(sqrtPriceLowerX64));
      if (roundUp) {
        return common_sdk_1.MathUtil.shiftRightRoundUp(result);
      } else {
        return result.shrn(64);
      }
    }
    function orderSqrtPrice(sqrtPrice0X64, sqrtPrice1X64) {
      if (sqrtPrice0X64.lt(sqrtPrice1X64)) {
        return [sqrtPrice0X64, sqrtPrice1X64];
      } else {
        return [sqrtPrice1X64, sqrtPrice0X64];
      }
    }
  }
});

// node_modules/@orca-so/whirlpools-sdk/dist/quotes/public/increase-liquidity-quote.js
var require_increase_liquidity_quote = __commonJS({
  "node_modules/@orca-so/whirlpools-sdk/dist/quotes/public/increase-liquidity-quote.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.increaseLiquidityQuoteByInputTokenUsingPriceSlippage = increaseLiquidityQuoteByInputTokenUsingPriceSlippage;
    exports2.increaseLiquidityQuoteByInputTokenWithParamsUsingPriceSlippage = increaseLiquidityQuoteByInputTokenWithParamsUsingPriceSlippage;
    exports2.increaseLiquidityQuoteByLiquidityWithParams = increaseLiquidityQuoteByLiquidityWithParams;
    exports2.increaseLiquidityQuoteByInputToken = increaseLiquidityQuoteByInputToken;
    exports2.increaseLiquidityQuoteByInputTokenWithParams = increaseLiquidityQuoteByInputTokenWithParams;
    var common_sdk_1 = require_dist2();
    var bn_js_1 = __importDefault(require_bn());
    var tiny_invariant_1 = __importDefault(require_tiny_invariant_cjs());
    var position_util_1 = require_position_util();
    var public_1 = require_public3();
    var token_extension_util_1 = require_token_extension_util();
    function increaseLiquidityQuoteByInputTokenUsingPriceSlippage(inputTokenMint, inputTokenAmount, tickLower, tickUpper, slippageTolerance, whirlpool, tokenExtensionCtx) {
      const data = whirlpool.getData();
      const tokenAInfo = whirlpool.getTokenAInfo();
      const tokenBInfo = whirlpool.getTokenBInfo();
      const inputMint = common_sdk_1.AddressUtil.toPubKey(inputTokenMint);
      const inputTokenInfo = inputMint.equals(tokenAInfo.mint) ? tokenAInfo : tokenBInfo;
      return increaseLiquidityQuoteByInputTokenWithParamsUsingPriceSlippage({
        inputTokenMint: inputMint,
        inputTokenAmount: common_sdk_1.DecimalUtil.toBN(inputTokenAmount, inputTokenInfo.decimals),
        tickLowerIndex: public_1.TickUtil.getInitializableTickIndex(tickLower, data.tickSpacing),
        tickUpperIndex: public_1.TickUtil.getInitializableTickIndex(tickUpper, data.tickSpacing),
        slippageTolerance,
        tokenExtensionCtx,
        ...data
      });
    }
    function increaseLiquidityQuoteByInputTokenWithParamsUsingPriceSlippage(param) {
      (0, tiny_invariant_1.default)(public_1.TickUtil.checkTickInBounds(param.tickLowerIndex), "tickLowerIndex is out of bounds.");
      (0, tiny_invariant_1.default)(public_1.TickUtil.checkTickInBounds(param.tickUpperIndex), "tickUpperIndex is out of bounds.");
      (0, tiny_invariant_1.default)(param.inputTokenMint.equals(param.tokenMintA) || param.inputTokenMint.equals(param.tokenMintB), `input token mint ${param.inputTokenMint.toBase58()} does not match any tokens in the provided pool.`);
      const liquidity = getLiquidityFromInputToken(param);
      if (liquidity.eq(common_sdk_1.ZERO)) {
        return {
          liquidityAmount: common_sdk_1.ZERO,
          tokenMaxA: common_sdk_1.ZERO,
          tokenMaxB: common_sdk_1.ZERO,
          tokenEstA: common_sdk_1.ZERO,
          tokenEstB: common_sdk_1.ZERO,
          transferFee: {
            deductingFromTokenMaxA: common_sdk_1.ZERO,
            deductingFromTokenMaxB: common_sdk_1.ZERO,
            deductingFromTokenEstA: common_sdk_1.ZERO,
            deductingFromTokenEstB: common_sdk_1.ZERO
          }
        };
      }
      return increaseLiquidityQuoteByLiquidityWithParams({
        liquidity,
        tickCurrentIndex: param.tickCurrentIndex,
        sqrtPrice: param.sqrtPrice,
        tickLowerIndex: param.tickLowerIndex,
        tickUpperIndex: param.tickUpperIndex,
        slippageTolerance: param.slippageTolerance,
        tokenExtensionCtx: param.tokenExtensionCtx
      });
    }
    function getLiquidityFromInputToken(params) {
      const { inputTokenMint, inputTokenAmount, tickLowerIndex, tickUpperIndex, sqrtPrice, tokenExtensionCtx } = params;
      (0, tiny_invariant_1.default)(tickLowerIndex < tickUpperIndex, `tickLowerIndex(${tickLowerIndex}) must be less than tickUpperIndex(${tickUpperIndex})`);
      if (inputTokenAmount.eq(common_sdk_1.ZERO)) {
        return common_sdk_1.ZERO;
      }
      const isTokenA = params.tokenMintA.equals(inputTokenMint);
      const sqrtPriceLowerX64 = public_1.PriceMath.tickIndexToSqrtPriceX64(tickLowerIndex);
      const sqrtPriceUpperX64 = public_1.PriceMath.tickIndexToSqrtPriceX64(tickUpperIndex);
      const positionStatus = position_util_1.PositionUtil.getStrictPositionStatus(sqrtPrice, tickLowerIndex, tickUpperIndex);
      if (positionStatus === position_util_1.PositionStatus.BelowRange) {
        if (!isTokenA) {
          return common_sdk_1.ZERO;
        }
        const transferFeeExcludedInputTokenAmount = token_extension_util_1.TokenExtensionUtil.calculateTransferFeeExcludedAmount(inputTokenAmount, tokenExtensionCtx.tokenMintWithProgramA, tokenExtensionCtx.currentEpoch);
        return (0, position_util_1.getLiquidityFromTokenA)(transferFeeExcludedInputTokenAmount.amount, sqrtPriceLowerX64, sqrtPriceUpperX64, false);
      }
      if (positionStatus === position_util_1.PositionStatus.AboveRange) {
        if (isTokenA) {
          return common_sdk_1.ZERO;
        }
        const transferFeeExcludedInputTokenAmount = token_extension_util_1.TokenExtensionUtil.calculateTransferFeeExcludedAmount(inputTokenAmount, tokenExtensionCtx.tokenMintWithProgramB, tokenExtensionCtx.currentEpoch);
        return (0, position_util_1.getLiquidityFromTokenB)(transferFeeExcludedInputTokenAmount.amount, sqrtPriceLowerX64, sqrtPriceUpperX64, false);
      }
      if (isTokenA) {
        const transferFeeExcludedInputTokenAmount = token_extension_util_1.TokenExtensionUtil.calculateTransferFeeExcludedAmount(inputTokenAmount, tokenExtensionCtx.tokenMintWithProgramA, tokenExtensionCtx.currentEpoch);
        return (0, position_util_1.getLiquidityFromTokenA)(transferFeeExcludedInputTokenAmount.amount, sqrtPrice, sqrtPriceUpperX64, false);
      } else {
        const transferFeeExcludedInputTokenAmount = token_extension_util_1.TokenExtensionUtil.calculateTransferFeeExcludedAmount(inputTokenAmount, tokenExtensionCtx.tokenMintWithProgramB, tokenExtensionCtx.currentEpoch);
        return (0, position_util_1.getLiquidityFromTokenB)(transferFeeExcludedInputTokenAmount.amount, sqrtPriceLowerX64, sqrtPrice, false);
      }
    }
    function increaseLiquidityQuoteByLiquidityWithParams(params) {
      if (params.liquidity.eq(common_sdk_1.ZERO)) {
        return {
          liquidityAmount: common_sdk_1.ZERO,
          tokenMaxA: common_sdk_1.ZERO,
          tokenMaxB: common_sdk_1.ZERO,
          tokenEstA: common_sdk_1.ZERO,
          tokenEstB: common_sdk_1.ZERO,
          transferFee: {
            deductingFromTokenMaxA: common_sdk_1.ZERO,
            deductingFromTokenMaxB: common_sdk_1.ZERO,
            deductingFromTokenEstA: common_sdk_1.ZERO,
            deductingFromTokenEstB: common_sdk_1.ZERO
          }
        };
      }
      const { tokenEstA, tokenEstB } = getTokenEstimatesFromLiquidity(params);
      const { lowerBound: [sLowerSqrtPrice, sLowerIndex], upperBound: [sUpperSqrtPrice, sUpperIndex] } = public_1.PriceMath.getSlippageBoundForSqrtPrice(params.sqrtPrice, params.slippageTolerance);
      const { tokenEstA: tokenEstALower, tokenEstB: tokenEstBLower } = getTokenEstimatesFromLiquidity({
        ...params,
        sqrtPrice: sLowerSqrtPrice,
        tickCurrentIndex: sLowerIndex
      });
      const { tokenEstA: tokenEstAUpper, tokenEstB: tokenEstBUpper } = getTokenEstimatesFromLiquidity({
        ...params,
        sqrtPrice: sUpperSqrtPrice,
        tickCurrentIndex: sUpperIndex
      });
      const tokenMaxA = bn_js_1.default.max(bn_js_1.default.max(tokenEstA, tokenEstALower), tokenEstAUpper);
      const tokenMaxB = bn_js_1.default.max(bn_js_1.default.max(tokenEstB, tokenEstBLower), tokenEstBUpper);
      const tokenExtensionCtx = params.tokenExtensionCtx;
      const tokenMaxAIncluded = token_extension_util_1.TokenExtensionUtil.calculateTransferFeeIncludedAmount(tokenMaxA, tokenExtensionCtx.tokenMintWithProgramA, tokenExtensionCtx.currentEpoch);
      const tokenEstAIncluded = token_extension_util_1.TokenExtensionUtil.calculateTransferFeeIncludedAmount(tokenEstA, tokenExtensionCtx.tokenMintWithProgramA, tokenExtensionCtx.currentEpoch);
      const tokenMaxBIncluded = token_extension_util_1.TokenExtensionUtil.calculateTransferFeeIncludedAmount(tokenMaxB, tokenExtensionCtx.tokenMintWithProgramB, tokenExtensionCtx.currentEpoch);
      const tokenEstBIncluded = token_extension_util_1.TokenExtensionUtil.calculateTransferFeeIncludedAmount(tokenEstB, tokenExtensionCtx.tokenMintWithProgramB, tokenExtensionCtx.currentEpoch);
      return {
        liquidityAmount: params.liquidity,
        tokenMaxA: tokenMaxAIncluded.amount,
        tokenMaxB: tokenMaxBIncluded.amount,
        tokenEstA: tokenEstAIncluded.amount,
        tokenEstB: tokenEstBIncluded.amount,
        transferFee: {
          deductingFromTokenMaxA: tokenMaxAIncluded.fee,
          deductingFromTokenMaxB: tokenMaxBIncluded.fee,
          deductingFromTokenEstA: tokenEstAIncluded.fee,
          deductingFromTokenEstB: tokenEstBIncluded.fee
        }
      };
    }
    function getTokenEstimatesFromLiquidity(params) {
      const { liquidity, sqrtPrice, tickLowerIndex, tickUpperIndex } = params;
      if (liquidity.eq(common_sdk_1.ZERO)) {
        throw new Error("liquidity must be greater than 0");
      }
      let tokenEstA = common_sdk_1.ZERO;
      let tokenEstB = common_sdk_1.ZERO;
      const lowerSqrtPrice = public_1.PriceMath.tickIndexToSqrtPriceX64(tickLowerIndex);
      const upperSqrtPrice = public_1.PriceMath.tickIndexToSqrtPriceX64(tickUpperIndex);
      const positionStatus = position_util_1.PositionUtil.getStrictPositionStatus(sqrtPrice, tickLowerIndex, tickUpperIndex);
      if (positionStatus === position_util_1.PositionStatus.BelowRange) {
        tokenEstA = (0, position_util_1.getTokenAFromLiquidity)(liquidity, lowerSqrtPrice, upperSqrtPrice, true);
      } else if (positionStatus === position_util_1.PositionStatus.InRange) {
        tokenEstA = (0, position_util_1.getTokenAFromLiquidity)(liquidity, sqrtPrice, upperSqrtPrice, true);
        tokenEstB = (0, position_util_1.getTokenBFromLiquidity)(liquidity, lowerSqrtPrice, sqrtPrice, true);
      } else {
        tokenEstB = (0, position_util_1.getTokenBFromLiquidity)(liquidity, lowerSqrtPrice, upperSqrtPrice, true);
      }
      return { tokenEstA, tokenEstB };
    }
    function increaseLiquidityQuoteByInputToken(inputTokenMint, inputTokenAmount, tickLower, tickUpper, slippageTolerance, whirlpool, tokenExtensionCtx) {
      const data = whirlpool.getData();
      const tokenAInfo = whirlpool.getTokenAInfo();
      const tokenBInfo = whirlpool.getTokenBInfo();
      const inputMint = common_sdk_1.AddressUtil.toPubKey(inputTokenMint);
      const inputTokenInfo = inputMint.equals(tokenAInfo.mint) ? tokenAInfo : tokenBInfo;
      return increaseLiquidityQuoteByInputTokenWithParams({
        inputTokenMint: inputMint,
        inputTokenAmount: common_sdk_1.DecimalUtil.toBN(inputTokenAmount, inputTokenInfo.decimals),
        tickLowerIndex: public_1.TickUtil.getInitializableTickIndex(tickLower, data.tickSpacing),
        tickUpperIndex: public_1.TickUtil.getInitializableTickIndex(tickUpper, data.tickSpacing),
        slippageTolerance,
        tokenExtensionCtx,
        ...data
      });
    }
    function increaseLiquidityQuoteByInputTokenWithParams(param) {
      (0, tiny_invariant_1.default)(public_1.TickUtil.checkTickInBounds(param.tickLowerIndex), "tickLowerIndex is out of bounds.");
      (0, tiny_invariant_1.default)(public_1.TickUtil.checkTickInBounds(param.tickUpperIndex), "tickUpperIndex is out of bounds.");
      (0, tiny_invariant_1.default)(param.inputTokenMint.equals(param.tokenMintA) || param.inputTokenMint.equals(param.tokenMintB), `input token mint ${param.inputTokenMint.toBase58()} does not match any tokens in the provided pool.`);
      const positionStatus = position_util_1.PositionUtil.getStrictPositionStatus(param.sqrtPrice, param.tickLowerIndex, param.tickUpperIndex);
      switch (positionStatus) {
        case position_util_1.PositionStatus.BelowRange:
          return quotePositionBelowRange(param);
        case position_util_1.PositionStatus.InRange:
          return quotePositionInRange(param);
        case position_util_1.PositionStatus.AboveRange:
          return quotePositionAboveRange(param);
        default:
          throw new Error(`type ${positionStatus} is an unknown PositionStatus`);
      }
    }
    function quotePositionBelowRange(param) {
      const { tokenMintA, inputTokenMint, inputTokenAmount, tickLowerIndex, tickUpperIndex, tokenExtensionCtx, slippageTolerance } = param;
      if (!tokenMintA.equals(inputTokenMint)) {
        return {
          liquidityAmount: common_sdk_1.ZERO,
          tokenMaxA: common_sdk_1.ZERO,
          tokenMaxB: common_sdk_1.ZERO,
          tokenEstA: common_sdk_1.ZERO,
          tokenEstB: common_sdk_1.ZERO,
          transferFee: {
            deductingFromTokenMaxA: common_sdk_1.ZERO,
            deductingFromTokenMaxB: common_sdk_1.ZERO,
            deductingFromTokenEstA: common_sdk_1.ZERO,
            deductingFromTokenEstB: common_sdk_1.ZERO
          }
        };
      }
      const sqrtPriceLowerX64 = public_1.PriceMath.tickIndexToSqrtPriceX64(tickLowerIndex);
      const sqrtPriceUpperX64 = public_1.PriceMath.tickIndexToSqrtPriceX64(tickUpperIndex);
      const transferFeeExcludedInputTokenAmount = token_extension_util_1.TokenExtensionUtil.calculateTransferFeeExcludedAmount(inputTokenAmount, tokenExtensionCtx.tokenMintWithProgramA, tokenExtensionCtx.currentEpoch);
      const liquidityAmount = (0, position_util_1.getLiquidityFromTokenA)(transferFeeExcludedInputTokenAmount.amount, sqrtPriceLowerX64, sqrtPriceUpperX64, false);
      const tokenEstA = (0, position_util_1.getTokenAFromLiquidity)(liquidityAmount, sqrtPriceLowerX64, sqrtPriceUpperX64, true);
      const tokenMaxA = (0, position_util_1.adjustForSlippage)(tokenEstA, slippageTolerance, true);
      const tokenMaxAIncluded = token_extension_util_1.TokenExtensionUtil.calculateTransferFeeIncludedAmount(tokenMaxA, tokenExtensionCtx.tokenMintWithProgramA, tokenExtensionCtx.currentEpoch);
      const tokenEstAIncluded = token_extension_util_1.TokenExtensionUtil.calculateTransferFeeIncludedAmount(tokenEstA, tokenExtensionCtx.tokenMintWithProgramA, tokenExtensionCtx.currentEpoch);
      return {
        liquidityAmount,
        tokenMaxA: tokenMaxAIncluded.amount,
        tokenMaxB: common_sdk_1.ZERO,
        tokenEstA: tokenEstAIncluded.amount,
        tokenEstB: common_sdk_1.ZERO,
        transferFee: {
          deductingFromTokenMaxA: tokenMaxAIncluded.fee,
          deductingFromTokenMaxB: common_sdk_1.ZERO,
          deductingFromTokenEstA: tokenEstAIncluded.fee,
          deductingFromTokenEstB: common_sdk_1.ZERO
        }
      };
    }
    function quotePositionInRange(param) {
      const { tokenMintA, tokenMintB, sqrtPrice, inputTokenMint, inputTokenAmount, tickLowerIndex, tickUpperIndex, tokenExtensionCtx, slippageTolerance } = param;
      const sqrtPriceX64 = sqrtPrice;
      const sqrtPriceLowerX64 = public_1.PriceMath.tickIndexToSqrtPriceX64(tickLowerIndex);
      const sqrtPriceUpperX64 = public_1.PriceMath.tickIndexToSqrtPriceX64(tickUpperIndex);
      let tokenEstA;
      let tokenEstB;
      let liquidityAmount;
      if (tokenMintA.equals(inputTokenMint)) {
        const transferFeeExcludedInputTokenAmount = token_extension_util_1.TokenExtensionUtil.calculateTransferFeeExcludedAmount(inputTokenAmount, tokenExtensionCtx.tokenMintWithProgramA, tokenExtensionCtx.currentEpoch);
        liquidityAmount = (0, position_util_1.getLiquidityFromTokenA)(transferFeeExcludedInputTokenAmount.amount, sqrtPriceX64, sqrtPriceUpperX64, false);
        tokenEstA = (0, position_util_1.getTokenAFromLiquidity)(liquidityAmount, sqrtPriceX64, sqrtPriceUpperX64, true);
        tokenEstB = (0, position_util_1.getTokenBFromLiquidity)(liquidityAmount, sqrtPriceLowerX64, sqrtPriceX64, true);
      } else if (tokenMintB.equals(inputTokenMint)) {
        const transferFeeExcludedInputTokenAmount = token_extension_util_1.TokenExtensionUtil.calculateTransferFeeExcludedAmount(inputTokenAmount, tokenExtensionCtx.tokenMintWithProgramB, tokenExtensionCtx.currentEpoch);
        liquidityAmount = (0, position_util_1.getLiquidityFromTokenB)(transferFeeExcludedInputTokenAmount.amount, sqrtPriceLowerX64, sqrtPriceX64, false);
        tokenEstA = (0, position_util_1.getTokenAFromLiquidity)(liquidityAmount, sqrtPriceX64, sqrtPriceUpperX64, true);
        tokenEstB = (0, position_util_1.getTokenBFromLiquidity)(liquidityAmount, sqrtPriceLowerX64, sqrtPriceX64, true);
      } else {
        throw new Error("invariant violation");
      }
      const tokenMaxA = (0, position_util_1.adjustForSlippage)(tokenEstA, slippageTolerance, true);
      const tokenMaxB = (0, position_util_1.adjustForSlippage)(tokenEstB, slippageTolerance, true);
      const tokenMaxAIncluded = token_extension_util_1.TokenExtensionUtil.calculateTransferFeeIncludedAmount(tokenMaxA, tokenExtensionCtx.tokenMintWithProgramA, tokenExtensionCtx.currentEpoch);
      const tokenEstAIncluded = token_extension_util_1.TokenExtensionUtil.calculateTransferFeeIncludedAmount(tokenEstA, tokenExtensionCtx.tokenMintWithProgramA, tokenExtensionCtx.currentEpoch);
      const tokenMaxBIncluded = token_extension_util_1.TokenExtensionUtil.calculateTransferFeeIncludedAmount(tokenMaxB, tokenExtensionCtx.tokenMintWithProgramB, tokenExtensionCtx.currentEpoch);
      const tokenEstBIncluded = token_extension_util_1.TokenExtensionUtil.calculateTransferFeeIncludedAmount(tokenEstB, tokenExtensionCtx.tokenMintWithProgramB, tokenExtensionCtx.currentEpoch);
      return {
        liquidityAmount,
        tokenMaxA: tokenMaxAIncluded.amount,
        tokenMaxB: tokenMaxBIncluded.amount,
        tokenEstA: tokenEstAIncluded.amount,
        tokenEstB: tokenEstBIncluded.amount,
        transferFee: {
          deductingFromTokenMaxA: tokenMaxAIncluded.fee,
          deductingFromTokenMaxB: tokenMaxBIncluded.fee,
          deductingFromTokenEstA: tokenEstAIncluded.fee,
          deductingFromTokenEstB: tokenEstBIncluded.fee
        }
      };
    }
    function quotePositionAboveRange(param) {
      const { tokenMintB, inputTokenMint, inputTokenAmount, tickLowerIndex, tickUpperIndex, tokenExtensionCtx, slippageTolerance } = param;
      if (!tokenMintB.equals(inputTokenMint)) {
        return {
          liquidityAmount: common_sdk_1.ZERO,
          tokenMaxA: common_sdk_1.ZERO,
          tokenMaxB: common_sdk_1.ZERO,
          tokenEstA: common_sdk_1.ZERO,
          tokenEstB: common_sdk_1.ZERO,
          transferFee: {
            deductingFromTokenMaxA: common_sdk_1.ZERO,
            deductingFromTokenMaxB: common_sdk_1.ZERO,
            deductingFromTokenEstA: common_sdk_1.ZERO,
            deductingFromTokenEstB: common_sdk_1.ZERO
          }
        };
      }
      const sqrtPriceLowerX64 = public_1.PriceMath.tickIndexToSqrtPriceX64(tickLowerIndex);
      const sqrtPriceUpperX64 = public_1.PriceMath.tickIndexToSqrtPriceX64(tickUpperIndex);
      const transferFeeExcludedInputTokenAmount = token_extension_util_1.TokenExtensionUtil.calculateTransferFeeExcludedAmount(inputTokenAmount, tokenExtensionCtx.tokenMintWithProgramB, tokenExtensionCtx.currentEpoch);
      const liquidityAmount = (0, position_util_1.getLiquidityFromTokenB)(transferFeeExcludedInputTokenAmount.amount, sqrtPriceLowerX64, sqrtPriceUpperX64, false);
      const tokenEstB = (0, position_util_1.getTokenBFromLiquidity)(liquidityAmount, sqrtPriceLowerX64, sqrtPriceUpperX64, true);
      const tokenMaxB = (0, position_util_1.adjustForSlippage)(tokenEstB, slippageTolerance, true);
      const tokenMaxBIncluded = token_extension_util_1.TokenExtensionUtil.calculateTransferFeeIncludedAmount(tokenMaxB, tokenExtensionCtx.tokenMintWithProgramB, tokenExtensionCtx.currentEpoch);
      const tokenEstBIncluded = token_extension_util_1.TokenExtensionUtil.calculateTransferFeeIncludedAmount(tokenEstB, tokenExtensionCtx.tokenMintWithProgramB, tokenExtensionCtx.currentEpoch);
      return {
        liquidityAmount,
        tokenMaxA: common_sdk_1.ZERO,
        tokenMaxB: tokenMaxBIncluded.amount,
        tokenEstA: common_sdk_1.ZERO,
        tokenEstB: tokenEstBIncluded.amount,
        transferFee: {
          deductingFromTokenMaxA: common_sdk_1.ZERO,
          deductingFromTokenMaxB: tokenMaxBIncluded.fee,
          deductingFromTokenEstA: common_sdk_1.ZERO,
          deductingFromTokenEstB: tokenEstBIncluded.fee
        }
      };
    }
  }
});

// node_modules/@orca-so/whirlpools-sdk/dist/quotes/public/decrease-liquidity-quote.js
var require_decrease_liquidity_quote = __commonJS({
  "node_modules/@orca-so/whirlpools-sdk/dist/quotes/public/decrease-liquidity-quote.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.decreaseLiquidityQuoteByLiquidity = decreaseLiquidityQuoteByLiquidity;
    exports2.decreaseLiquidityQuoteByLiquidityWithParams = decreaseLiquidityQuoteByLiquidityWithParams;
    exports2.decreaseLiquidityQuoteByLiquidityWithParamsUsingPriceSlippage = decreaseLiquidityQuoteByLiquidityWithParamsUsingPriceSlippage;
    var anchor_1 = require("@coral-xyz/anchor");
    var common_sdk_1 = require_dist2();
    var tiny_invariant_1 = __importDefault(require_tiny_invariant_cjs());
    var position_util_1 = require_position_util();
    var public_1 = require_public3();
    var token_extension_util_1 = require_token_extension_util();
    function decreaseLiquidityQuoteByLiquidity(liquidity, slippageTolerance, position, whirlpool, tokenExtensionCtx) {
      const positionData = position.getData();
      const whirlpoolData = whirlpool.getData();
      (0, tiny_invariant_1.default)(liquidity.lte(positionData.liquidity), "Quote liquidity is more than the position liquidity.");
      return decreaseLiquidityQuoteByLiquidityWithParams({
        liquidity,
        slippageTolerance,
        tickLowerIndex: positionData.tickLowerIndex,
        tickUpperIndex: positionData.tickUpperIndex,
        sqrtPrice: whirlpoolData.sqrtPrice,
        tickCurrentIndex: whirlpoolData.tickCurrentIndex,
        tokenExtensionCtx
      });
    }
    function decreaseLiquidityQuoteByLiquidityWithParams(params) {
      (0, tiny_invariant_1.default)(public_1.TickUtil.checkTickInBounds(params.tickLowerIndex), "tickLowerIndex is out of bounds.");
      (0, tiny_invariant_1.default)(public_1.TickUtil.checkTickInBounds(params.tickUpperIndex), "tickUpperIndex is out of bounds.");
      if (params.liquidity.eq(common_sdk_1.ZERO)) {
        return {
          tokenMinA: common_sdk_1.ZERO,
          tokenMinB: common_sdk_1.ZERO,
          liquidityAmount: common_sdk_1.ZERO,
          tokenEstA: common_sdk_1.ZERO,
          tokenEstB: common_sdk_1.ZERO,
          transferFee: {
            deductedFromTokenMinA: common_sdk_1.ZERO,
            deductedFromTokenMinB: common_sdk_1.ZERO,
            deductedFromTokenEstA: common_sdk_1.ZERO,
            deductedFromTokenEstB: common_sdk_1.ZERO
          }
        };
      }
      const { tokenExtensionCtx } = params;
      const { tokenEstA, tokenEstB } = getTokenEstimatesFromLiquidity(params);
      const [tokenMinA, tokenMinB] = [tokenEstA, tokenEstB].map((tokenEst) => (0, position_util_1.adjustForSlippage)(tokenEst, params.slippageTolerance, false));
      const tokenMinAExcluded = token_extension_util_1.TokenExtensionUtil.calculateTransferFeeExcludedAmount(tokenMinA, tokenExtensionCtx.tokenMintWithProgramA, tokenExtensionCtx.currentEpoch);
      const tokenEstAExcluded = token_extension_util_1.TokenExtensionUtil.calculateTransferFeeExcludedAmount(tokenEstA, tokenExtensionCtx.tokenMintWithProgramA, tokenExtensionCtx.currentEpoch);
      const tokenMinBExcluded = token_extension_util_1.TokenExtensionUtil.calculateTransferFeeExcludedAmount(tokenMinB, tokenExtensionCtx.tokenMintWithProgramB, tokenExtensionCtx.currentEpoch);
      const tokenEstBExcluded = token_extension_util_1.TokenExtensionUtil.calculateTransferFeeExcludedAmount(tokenEstB, tokenExtensionCtx.tokenMintWithProgramB, tokenExtensionCtx.currentEpoch);
      return {
        tokenMinA: tokenMinAExcluded.amount,
        tokenMinB: tokenMinBExcluded.amount,
        tokenEstA: tokenEstAExcluded.amount,
        tokenEstB: tokenEstBExcluded.amount,
        liquidityAmount: params.liquidity,
        transferFee: {
          deductedFromTokenMinA: tokenMinAExcluded.fee,
          deductedFromTokenMinB: tokenMinBExcluded.fee,
          deductedFromTokenEstA: tokenEstAExcluded.fee,
          deductedFromTokenEstB: tokenEstBExcluded.fee
        }
      };
    }
    function decreaseLiquidityQuoteByLiquidityWithParamsUsingPriceSlippage(params) {
      const { tokenExtensionCtx } = params;
      if (params.liquidity.eq(common_sdk_1.ZERO)) {
        return {
          tokenMinA: common_sdk_1.ZERO,
          tokenMinB: common_sdk_1.ZERO,
          liquidityAmount: common_sdk_1.ZERO,
          tokenEstA: common_sdk_1.ZERO,
          tokenEstB: common_sdk_1.ZERO,
          transferFee: {
            deductedFromTokenMinA: common_sdk_1.ZERO,
            deductedFromTokenMinB: common_sdk_1.ZERO,
            deductedFromTokenEstA: common_sdk_1.ZERO,
            deductedFromTokenEstB: common_sdk_1.ZERO
          }
        };
      }
      const { tokenEstA, tokenEstB } = getTokenEstimatesFromLiquidity(params);
      const { lowerBound: [sLowerSqrtPrice, sLowerIndex], upperBound: [sUpperSqrtPrice, sUpperIndex] } = public_1.PriceMath.getSlippageBoundForSqrtPrice(params.sqrtPrice, params.slippageTolerance);
      const { tokenEstA: tokenEstALower, tokenEstB: tokenEstBLower } = getTokenEstimatesFromLiquidity({
        ...params,
        sqrtPrice: sLowerSqrtPrice,
        tickCurrentIndex: sLowerIndex
      });
      const { tokenEstA: tokenEstAUpper, tokenEstB: tokenEstBUpper } = getTokenEstimatesFromLiquidity({
        ...params,
        sqrtPrice: sUpperSqrtPrice,
        tickCurrentIndex: sUpperIndex
      });
      const tokenMinA = anchor_1.BN.min(anchor_1.BN.min(tokenEstA, tokenEstALower), tokenEstAUpper);
      const tokenMinB = anchor_1.BN.min(anchor_1.BN.min(tokenEstB, tokenEstBLower), tokenEstBUpper);
      const tokenMinAExcluded = token_extension_util_1.TokenExtensionUtil.calculateTransferFeeExcludedAmount(tokenMinA, tokenExtensionCtx.tokenMintWithProgramA, tokenExtensionCtx.currentEpoch);
      const tokenEstAExcluded = token_extension_util_1.TokenExtensionUtil.calculateTransferFeeExcludedAmount(tokenEstA, tokenExtensionCtx.tokenMintWithProgramA, tokenExtensionCtx.currentEpoch);
      const tokenMinBExcluded = token_extension_util_1.TokenExtensionUtil.calculateTransferFeeExcludedAmount(tokenMinB, tokenExtensionCtx.tokenMintWithProgramB, tokenExtensionCtx.currentEpoch);
      const tokenEstBExcluded = token_extension_util_1.TokenExtensionUtil.calculateTransferFeeExcludedAmount(tokenEstB, tokenExtensionCtx.tokenMintWithProgramB, tokenExtensionCtx.currentEpoch);
      return {
        tokenMinA: tokenMinAExcluded.amount,
        tokenMinB: tokenMinBExcluded.amount,
        tokenEstA: tokenEstAExcluded.amount,
        tokenEstB: tokenEstBExcluded.amount,
        liquidityAmount: params.liquidity,
        transferFee: {
          deductedFromTokenMinA: tokenMinAExcluded.fee,
          deductedFromTokenMinB: tokenMinBExcluded.fee,
          deductedFromTokenEstA: tokenEstAExcluded.fee,
          deductedFromTokenEstB: tokenEstBExcluded.fee
        }
      };
    }
    function getTokenEstimatesFromLiquidity(params) {
      const { liquidity, tickLowerIndex, tickUpperIndex, sqrtPrice } = params;
      if (liquidity.eq(common_sdk_1.ZERO)) {
        throw new Error("liquidity must be greater than 0");
      }
      let tokenEstA = common_sdk_1.ZERO;
      let tokenEstB = common_sdk_1.ZERO;
      const lowerSqrtPrice = public_1.PriceMath.tickIndexToSqrtPriceX64(tickLowerIndex);
      const upperSqrtPrice = public_1.PriceMath.tickIndexToSqrtPriceX64(tickUpperIndex);
      const positionStatus = position_util_1.PositionUtil.getStrictPositionStatus(sqrtPrice, tickLowerIndex, tickUpperIndex);
      if (positionStatus === position_util_1.PositionStatus.BelowRange) {
        tokenEstA = (0, position_util_1.getTokenAFromLiquidity)(liquidity, lowerSqrtPrice, upperSqrtPrice, false);
      } else if (positionStatus === position_util_1.PositionStatus.InRange) {
        tokenEstA = (0, position_util_1.getTokenAFromLiquidity)(liquidity, sqrtPrice, upperSqrtPrice, false);
        tokenEstB = (0, position_util_1.getTokenBFromLiquidity)(liquidity, lowerSqrtPrice, sqrtPrice, false);
      } else {
        tokenEstB = (0, position_util_1.getTokenBFromLiquidity)(liquidity, lowerSqrtPrice, upperSqrtPrice, false);
      }
      return { tokenEstA, tokenEstB };
    }
  }
});

// node_modules/@orca-so/whirlpools-sdk/dist/quotes/public/collect-fees-quote.js
var require_collect_fees_quote = __commonJS({
  "node_modules/@orca-so/whirlpools-sdk/dist/quotes/public/collect-fees-quote.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.collectFeesQuote = collectFeesQuote;
    var common_sdk_1 = require_dist2();
    var token_extension_util_1 = require_token_extension_util();
    function collectFeesQuote(param) {
      const { whirlpool, position, tickLower, tickUpper, tokenExtensionCtx } = param;
      const { tickCurrentIndex, feeGrowthGlobalA: feeGrowthGlobalAX64, feeGrowthGlobalB: feeGrowthGlobalBX64 } = whirlpool;
      const { tickLowerIndex, tickUpperIndex, liquidity, feeOwedA, feeOwedB, feeGrowthCheckpointA: feeGrowthCheckpointAX64, feeGrowthCheckpointB: feeGrowthCheckpointBX64 } = position;
      const { feeGrowthOutsideA: tickLowerFeeGrowthOutsideAX64, feeGrowthOutsideB: tickLowerFeeGrowthOutsideBX64 } = tickLower;
      const { feeGrowthOutsideA: tickUpperFeeGrowthOutsideAX64, feeGrowthOutsideB: tickUpperFeeGrowthOutsideBX64 } = tickUpper;
      let feeGrowthBelowAX64 = null;
      let feeGrowthBelowBX64 = null;
      if (tickCurrentIndex < tickLowerIndex) {
        feeGrowthBelowAX64 = common_sdk_1.MathUtil.subUnderflowU128(feeGrowthGlobalAX64, tickLowerFeeGrowthOutsideAX64);
        feeGrowthBelowBX64 = common_sdk_1.MathUtil.subUnderflowU128(feeGrowthGlobalBX64, tickLowerFeeGrowthOutsideBX64);
      } else {
        feeGrowthBelowAX64 = tickLowerFeeGrowthOutsideAX64;
        feeGrowthBelowBX64 = tickLowerFeeGrowthOutsideBX64;
      }
      let feeGrowthAboveAX64 = null;
      let feeGrowthAboveBX64 = null;
      if (tickCurrentIndex < tickUpperIndex) {
        feeGrowthAboveAX64 = tickUpperFeeGrowthOutsideAX64;
        feeGrowthAboveBX64 = tickUpperFeeGrowthOutsideBX64;
      } else {
        feeGrowthAboveAX64 = common_sdk_1.MathUtil.subUnderflowU128(feeGrowthGlobalAX64, tickUpperFeeGrowthOutsideAX64);
        feeGrowthAboveBX64 = common_sdk_1.MathUtil.subUnderflowU128(feeGrowthGlobalBX64, tickUpperFeeGrowthOutsideBX64);
      }
      const feeGrowthInsideAX64 = common_sdk_1.MathUtil.subUnderflowU128(common_sdk_1.MathUtil.subUnderflowU128(feeGrowthGlobalAX64, feeGrowthBelowAX64), feeGrowthAboveAX64);
      const feeGrowthInsideBX64 = common_sdk_1.MathUtil.subUnderflowU128(common_sdk_1.MathUtil.subUnderflowU128(feeGrowthGlobalBX64, feeGrowthBelowBX64), feeGrowthAboveBX64);
      const feeOwedADelta = common_sdk_1.MathUtil.subUnderflowU128(feeGrowthInsideAX64, feeGrowthCheckpointAX64).mul(liquidity).shrn(64);
      const feeOwedBDelta = common_sdk_1.MathUtil.subUnderflowU128(feeGrowthInsideBX64, feeGrowthCheckpointBX64).mul(liquidity).shrn(64);
      const updatedFeeOwedA = feeOwedA.add(feeOwedADelta);
      const transferFeeExcludedAmountA = token_extension_util_1.TokenExtensionUtil.calculateTransferFeeExcludedAmount(updatedFeeOwedA, tokenExtensionCtx.tokenMintWithProgramA, tokenExtensionCtx.currentEpoch);
      const updatedFeeOwedB = feeOwedB.add(feeOwedBDelta);
      const transferFeeExcludedAmountB = token_extension_util_1.TokenExtensionUtil.calculateTransferFeeExcludedAmount(updatedFeeOwedB, tokenExtensionCtx.tokenMintWithProgramB, tokenExtensionCtx.currentEpoch);
      return {
        feeOwedA: transferFeeExcludedAmountA.amount,
        feeOwedB: transferFeeExcludedAmountB.amount,
        transferFee: {
          deductedFromFeeOwedA: transferFeeExcludedAmountA.fee,
          deductedFromFeeOwedB: transferFeeExcludedAmountB.fee
        }
      };
    }
  }
});

// node_modules/@orca-so/whirlpools-sdk/dist/quotes/public/collect-rewards-quote.js
var require_collect_rewards_quote = __commonJS({
  "node_modules/@orca-so/whirlpools-sdk/dist/quotes/public/collect-rewards-quote.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.collectRewardsQuote = collectRewardsQuote;
    var anchor_1 = require("@coral-xyz/anchor");
    var common_sdk_1 = require_dist2();
    var tiny_invariant_1 = __importDefault(require_tiny_invariant_cjs());
    var public_1 = require_public();
    var bit_math_1 = require_bit_math();
    var pool_utils_1 = require_pool_utils();
    var token_extension_util_1 = require_token_extension_util();
    function collectRewardsQuote(param) {
      const { whirlpool, position, tickLower, tickUpper, timeStampInSeconds, tokenExtensionCtx } = param;
      const { tickCurrentIndex, rewardInfos: whirlpoolRewardsInfos, rewardLastUpdatedTimestamp } = whirlpool;
      const { tickLowerIndex, tickUpperIndex, liquidity, rewardInfos: positionRewardInfos } = position;
      const currTimestampInSeconds = timeStampInSeconds ?? new anchor_1.BN(Date.now()).div(new anchor_1.BN(1e3));
      const timestampDelta = currTimestampInSeconds.sub(new anchor_1.BN(rewardLastUpdatedTimestamp));
      const rewardOwed = [
        void 0,
        void 0,
        void 0
      ];
      const transferFee = [
        void 0,
        void 0,
        void 0
      ];
      for (let i = 0; i < public_1.NUM_REWARDS; i++) {
        const rewardInfo = whirlpoolRewardsInfos[i];
        const positionRewardInfo = positionRewardInfos[i];
        (0, tiny_invariant_1.default)(!!rewardInfo, "whirlpoolRewardsInfos cannot be undefined");
        const isRewardInitialized = pool_utils_1.PoolUtil.isRewardInitialized(rewardInfo);
        if (!isRewardInitialized) {
          continue;
        }
        let adjustedRewardGrowthGlobalX64 = rewardInfo.growthGlobalX64;
        if (!whirlpool.liquidity.isZero()) {
          const rewardGrowthDelta = bit_math_1.BitMath.mulDiv(timestampDelta, rewardInfo.emissionsPerSecondX64, whirlpool.liquidity, 128);
          adjustedRewardGrowthGlobalX64 = rewardInfo.growthGlobalX64.add(rewardGrowthDelta);
        }
        const tickLowerRewardGrowthsOutsideX64 = tickLower.rewardGrowthsOutside[i];
        const tickUpperRewardGrowthsOutsideX64 = tickUpper.rewardGrowthsOutside[i];
        let rewardGrowthsBelowX64 = adjustedRewardGrowthGlobalX64;
        if (tickLower.initialized) {
          rewardGrowthsBelowX64 = tickCurrentIndex < tickLowerIndex ? common_sdk_1.MathUtil.subUnderflowU128(adjustedRewardGrowthGlobalX64, tickLowerRewardGrowthsOutsideX64) : tickLowerRewardGrowthsOutsideX64;
        }
        let rewardGrowthsAboveX64 = new anchor_1.BN(0);
        if (tickUpper.initialized) {
          rewardGrowthsAboveX64 = tickCurrentIndex < tickUpperIndex ? tickUpperRewardGrowthsOutsideX64 : common_sdk_1.MathUtil.subUnderflowU128(adjustedRewardGrowthGlobalX64, tickUpperRewardGrowthsOutsideX64);
        }
        const rewardGrowthInsideX64 = common_sdk_1.MathUtil.subUnderflowU128(common_sdk_1.MathUtil.subUnderflowU128(adjustedRewardGrowthGlobalX64, rewardGrowthsBelowX64), rewardGrowthsAboveX64);
        const amountOwedX64 = positionRewardInfo.amountOwed.shln(64);
        const amountOwed = amountOwedX64.add(common_sdk_1.MathUtil.subUnderflowU128(rewardGrowthInsideX64, positionRewardInfo.growthInsideCheckpoint).mul(liquidity)).shrn(64);
        const transferFeeExcluded = token_extension_util_1.TokenExtensionUtil.calculateTransferFeeExcludedAmount(amountOwed, tokenExtensionCtx.rewardTokenMintsWithProgram[i], tokenExtensionCtx.currentEpoch);
        rewardOwed[i] = transferFeeExcluded.amount;
        transferFee[i] = transferFeeExcluded.fee;
      }
      return {
        rewardOwed,
        transferFee: {
          deductedFromRewardOwed: transferFee
        }
      };
    }
  }
});

// node_modules/@orca-so/whirlpools-sdk/dist/quotes/public/dev-fee-swap-quote.js
var require_dev_fee_swap_quote = __commonJS({
  "node_modules/@orca-so/whirlpools-sdk/dist/quotes/public/dev-fee-swap-quote.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.swapQuoteByInputTokenWithDevFees = swapQuoteByInputTokenWithDevFees;
    var errors_1 = require_errors3();
    var swap_quote_1 = require_swap_quote();
    async function swapQuoteByInputTokenWithDevFees(whirlpool, inputTokenMint, tokenAmount, slippageTolerance, programId, fetcher, devFeePercentage, opts) {
      if (devFeePercentage.toDecimal().greaterThanOrEqualTo(1)) {
        throw new errors_1.WhirlpoolsError("Provided devFeePercentage must be less than 100%", errors_1.SwapErrorCode.InvalidDevFeePercentage);
      }
      const devFeeAmount = tokenAmount.mul(devFeePercentage.numerator).div(devFeePercentage.denominator);
      const slippageAdjustedQuote = await (0, swap_quote_1.swapQuoteByInputToken)(whirlpool, inputTokenMint, tokenAmount.sub(devFeeAmount), slippageTolerance, programId, fetcher, opts);
      const devFeeAdjustedQuote = {
        ...slippageAdjustedQuote,
        amountSpecifiedIsInput: true,
        estimatedAmountIn: slippageAdjustedQuote.estimatedAmountIn.add(devFeeAmount),
        estimatedFeeAmount: slippageAdjustedQuote.estimatedFeeAmount.add(devFeeAmount),
        estimatedSwapFeeAmount: slippageAdjustedQuote.estimatedFeeAmount,
        devFeeAmount
      };
      return devFeeAdjustedQuote;
    }
  }
});

// node_modules/@orca-so/whirlpools-sdk/dist/quotes/public/two-hop-swap-quote.js
var require_two_hop_swap_quote = __commonJS({
  "node_modules/@orca-so/whirlpools-sdk/dist/quotes/public/two-hop-swap-quote.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.twoHopSwapQuoteFromSwapQuotes = twoHopSwapQuoteFromSwapQuotes;
    function twoHopSwapQuoteFromSwapQuotes(swapQuoteOne, swapQuoteTwo) {
      const amountSpecifiedIsInput = swapQuoteOne.amountSpecifiedIsInput;
      let [amount, otherAmountThreshold] = amountSpecifiedIsInput ? [swapQuoteOne.amount, swapQuoteTwo.otherAmountThreshold] : [swapQuoteTwo.amount, swapQuoteOne.otherAmountThreshold];
      return {
        amount,
        otherAmountThreshold,
        amountSpecifiedIsInput,
        aToBOne: swapQuoteOne.aToB,
        aToBTwo: swapQuoteTwo.aToB,
        sqrtPriceLimitOne: swapQuoteOne.sqrtPriceLimit,
        sqrtPriceLimitTwo: swapQuoteTwo.sqrtPriceLimit,
        tickArrayOne0: swapQuoteOne.tickArray0,
        tickArrayOne1: swapQuoteOne.tickArray1,
        tickArrayOne2: swapQuoteOne.tickArray2,
        tickArrayTwo0: swapQuoteTwo.tickArray0,
        tickArrayTwo1: swapQuoteTwo.tickArray1,
        tickArrayTwo2: swapQuoteTwo.tickArray2,
        supplementalTickArraysOne: swapQuoteOne.supplementalTickArrays,
        supplementalTickArraysTwo: swapQuoteTwo.supplementalTickArrays,
        swapOneEstimates: { ...swapQuoteOne },
        swapTwoEstimates: { ...swapQuoteTwo }
      };
    }
  }
});

// node_modules/@orca-so/whirlpools-sdk/dist/quotes/public/index.js
var require_public5 = __commonJS({
  "node_modules/@orca-so/whirlpools-sdk/dist/quotes/public/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_increase_liquidity_quote(), exports2);
    __exportStar(require_decrease_liquidity_quote(), exports2);
    __exportStar(require_collect_fees_quote(), exports2);
    __exportStar(require_collect_rewards_quote(), exports2);
    __exportStar(require_swap_quote(), exports2);
    __exportStar(require_dev_fee_swap_quote(), exports2);
    __exportStar(require_two_hop_swap_quote(), exports2);
  }
});

// node_modules/@orca-so/whirlpools-sdk/dist/instructions/composites/swap-with-route.js
var require_swap_with_route = __commonJS({
  "node_modules/@orca-so/whirlpools-sdk/dist/instructions/composites/swap-with-route.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getSwapFromRoute = getSwapFromRoute;
    var common_sdk_1 = require_dist2();
    var spl_token_1 = require_cjs3();
    var web3_js_1 = require("@solana/web3.js");
    var bn_js_1 = __importDefault(require_bn());
    var __1 = require_dist3();
    var fetcher_1 = require_fetcher2();
    var position_util_1 = require_position_util();
    var txn_utils_1 = require_txn_utils();
    var swap_ix_1 = require_swap_ix2();
    var two_hop_swap_ix_1 = require_two_hop_swap_ix2();
    async function getSwapFromRoute(ctx, params, opts = fetcher_1.PREFER_CACHE, txBuilder = new common_sdk_1.TransactionBuilder(ctx.connection, ctx.wallet, (0, txn_utils_1.contextOptionsToBuilderOptions)(ctx.opts))) {
      const { route, wallet, resolvedAtaAccounts, slippage } = params;
      const requiredAtas = /* @__PURE__ */ new Set();
      const requiredIntermediateAtas = /* @__PURE__ */ new Set();
      const requiredTickArrays = [];
      let hasNativeMint = false;
      let nativeMintAmount = new bn_js_1.default(0);
      function addOrNative(mint, amount) {
        if (mint === spl_token_1.NATIVE_MINT.toBase58()) {
          hasNativeMint = true;
          nativeMintAmount = nativeMintAmount.add(amount);
        } else {
          requiredAtas.add(mint);
        }
      }
      for (let i = 0; i < route.subRoutes.length; i++) {
        const routeFragment = route.subRoutes[i];
        const slippageAdjustedRoute = adjustQuoteForSlippage(routeFragment, slippage);
        if (slippageAdjustedRoute.hopQuotes.length == 1) {
          const { quote, mintA, mintB } = slippageAdjustedRoute.hopQuotes[0];
          requiredTickArrays.push(...[quote.tickArray0, quote.tickArray1, quote.tickArray2]);
          const inputAmount = quote.amountSpecifiedIsInput ? quote.amount : quote.otherAmountThreshold;
          addOrNative(mintA.toString(), quote.aToB ? inputAmount : common_sdk_1.ZERO);
          addOrNative(mintB.toString(), !quote.aToB ? inputAmount : common_sdk_1.ZERO);
        } else if (slippageAdjustedRoute.hopQuotes.length == 2) {
          const { quote: quoteOne, mintA: mintOneA, mintB: mintOneB } = slippageAdjustedRoute.hopQuotes[0];
          const { quote: quoteTwo, mintA: mintTwoA, mintB: mintTwoB } = slippageAdjustedRoute.hopQuotes[1];
          const twoHopQuote = (0, __1.twoHopSwapQuoteFromSwapQuotes)(quoteOne, quoteTwo);
          requiredTickArrays.push(...[
            twoHopQuote.tickArrayOne0,
            twoHopQuote.tickArrayOne1,
            twoHopQuote.tickArrayOne2,
            twoHopQuote.tickArrayTwo0,
            twoHopQuote.tickArrayTwo1,
            twoHopQuote.tickArrayTwo2
          ]);
          const inputAmount = quoteOne.amountSpecifiedIsInput ? quoteOne.estimatedAmountIn : quoteOne.otherAmountThreshold;
          addOrNative(mintOneA.toString(), quoteOne.aToB ? inputAmount : common_sdk_1.ZERO);
          addOrNative(mintOneB.toString(), !quoteOne.aToB ? inputAmount : common_sdk_1.ZERO);
          addOrNative(mintTwoA.toString(), common_sdk_1.ZERO);
          addOrNative(mintTwoB.toString(), common_sdk_1.ZERO);
          requiredIntermediateAtas.add(quoteOne.aToB ? mintOneB.toString() : mintOneA.toString());
        }
      }
      requiredAtas.delete(spl_token_1.NATIVE_MINT.toBase58());
      const ataInstructionMap = await cachedResolveOrCreateNonNativeATAs(wallet, requiredAtas, requiredIntermediateAtas, (keys) => {
        if (resolvedAtaAccounts != null) {
          return Promise.resolve(keys.map((key) => resolvedAtaAccounts.find((ata) => ata.address?.toBase58() === key.toBase58())));
        } else {
          return ctx.fetcher.getTokenInfos(keys, opts).then((result) => Array.from(result.values()));
        }
      }, void 0, ctx.accountResolverOpts.allowPDAOwnerAddress);
      const ataIxes = Object.values(ataInstructionMap);
      if (hasNativeMint) {
        const solIx = common_sdk_1.TokenUtil.createWrappedNativeAccountInstruction(wallet, nativeMintAmount, await ctx.fetcher.getAccountRentExempt(), void 0, void 0, ctx.accountResolverOpts.createWrappedSolAccountMethod);
        txBuilder.addInstruction(solIx);
        ataInstructionMap[spl_token_1.NATIVE_MINT.toBase58()] = solIx;
      }
      txBuilder.addInstructions(ataIxes);
      const slippageAdjustedQuotes = route.subRoutes.map((quote) => adjustQuoteForSlippage(quote, slippage));
      for (let i = 0; i < slippageAdjustedQuotes.length; i++) {
        const routeFragment = slippageAdjustedQuotes[i];
        if (routeFragment.hopQuotes.length == 1) {
          const { quote, whirlpool, mintA, mintB, vaultA, vaultB } = routeFragment.hopQuotes[0];
          const [wp, tokenVaultA, tokenVaultB] = common_sdk_1.AddressUtil.toPubKeys([
            whirlpool,
            vaultA,
            vaultB
          ]);
          const accA = ataInstructionMap[mintA.toString()].address;
          const accB = ataInstructionMap[mintB.toString()].address;
          const oraclePda = __1.PDAUtil.getOracle(ctx.program.programId, wp);
          txBuilder.addInstruction((0, swap_ix_1.swapIx)(ctx.program, {
            whirlpool: wp,
            tokenOwnerAccountA: accA,
            tokenOwnerAccountB: accB,
            tokenVaultA,
            tokenVaultB,
            oracle: oraclePda.publicKey,
            tokenAuthority: wallet,
            ...quote
          }));
        } else if (routeFragment.hopQuotes.length == 2) {
          const { quote: quoteOne, whirlpool: whirlpoolOne, mintA: mintOneA, mintB: mintOneB, vaultA: vaultOneA, vaultB: vaultOneB } = routeFragment.hopQuotes[0];
          const { quote: quoteTwo, whirlpool: whirlpoolTwo, mintA: mintTwoA, mintB: mintTwoB, vaultA: vaultTwoA, vaultB: vaultTwoB } = routeFragment.hopQuotes[1];
          const [wpOne, wpTwo, tokenVaultOneA, tokenVaultOneB, tokenVaultTwoA, tokenVaultTwoB] = common_sdk_1.AddressUtil.toPubKeys([
            whirlpoolOne,
            whirlpoolTwo,
            vaultOneA,
            vaultOneB,
            vaultTwoA,
            vaultTwoB
          ]);
          const twoHopQuote = (0, __1.twoHopSwapQuoteFromSwapQuotes)(quoteOne, quoteTwo);
          const oracleOne = __1.PDAUtil.getOracle(ctx.program.programId, wpOne).publicKey;
          const oracleTwo = __1.PDAUtil.getOracle(ctx.program.programId, wpTwo).publicKey;
          const tokenOwnerAccountOneA = ataInstructionMap[mintOneA.toString()].address;
          const tokenOwnerAccountOneB = ataInstructionMap[mintOneB.toString()].address;
          const tokenOwnerAccountTwoA = ataInstructionMap[mintTwoA.toString()].address;
          const tokenOwnerAccountTwoB = ataInstructionMap[mintTwoB.toString()].address;
          txBuilder.addInstruction((0, two_hop_swap_ix_1.twoHopSwapIx)(ctx.program, {
            ...twoHopQuote,
            whirlpoolOne: wpOne,
            whirlpoolTwo: wpTwo,
            tokenOwnerAccountOneA,
            tokenOwnerAccountOneB,
            tokenOwnerAccountTwoA,
            tokenOwnerAccountTwoB,
            tokenVaultOneA,
            tokenVaultOneB,
            tokenVaultTwoA,
            tokenVaultTwoB,
            oracleOne,
            oracleTwo,
            tokenAuthority: wallet
          }));
        }
      }
      return txBuilder;
    }
    function adjustQuoteForSlippage(quote, slippage) {
      const { hopQuotes } = quote;
      if (hopQuotes.length === 1) {
        return {
          ...quote,
          hopQuotes: [
            {
              ...hopQuotes[0],
              quote: {
                ...hopQuotes[0].quote,
                ...__1.SwapUtils.calculateSwapAmountsFromQuote(hopQuotes[0].quote.amount, hopQuotes[0].quote.estimatedAmountIn, hopQuotes[0].quote.estimatedAmountOut, slippage, hopQuotes[0].quote.amountSpecifiedIsInput)
              }
            }
          ]
        };
      } else if (quote.hopQuotes.length === 2) {
        const swapQuoteOne = quote.hopQuotes[0];
        const swapQuoteTwo = quote.hopQuotes[1];
        const amountSpecifiedIsInput = swapQuoteOne.quote.amountSpecifiedIsInput;
        let updatedQuote = {
          ...quote
        };
        if (amountSpecifiedIsInput) {
          updatedQuote.hopQuotes = [
            updatedQuote.hopQuotes[0],
            {
              ...swapQuoteTwo,
              quote: {
                ...swapQuoteTwo.quote,
                otherAmountThreshold: (0, position_util_1.adjustForSlippage)(swapQuoteTwo.quote.estimatedAmountOut, slippage, false)
              }
            }
          ];
        } else {
          updatedQuote.hopQuotes = [
            {
              ...swapQuoteOne,
              quote: {
                ...swapQuoteOne.quote,
                otherAmountThreshold: (0, position_util_1.adjustForSlippage)(swapQuoteOne.quote.estimatedAmountIn, slippage, true)
              }
            },
            updatedQuote.hopQuotes[1]
          ];
        }
        return updatedQuote;
      }
      return quote;
    }
    async function cachedResolveOrCreateNonNativeATAs(ownerAddress, tokenMints, intermediateTokenMints, getTokenAccounts, payer = ownerAddress, allowPDAOwnerAddress = false) {
      const instructionMap = {};
      const tokenMintArray = Array.from(tokenMints).map((tm) => new web3_js_1.PublicKey(tm));
      const tokenAtas = tokenMintArray.map((tm) => (0, spl_token_1.getAssociatedTokenAddressSync)(tm, ownerAddress, allowPDAOwnerAddress));
      const tokenAccounts = await getTokenAccounts(tokenAtas);
      tokenAccounts.forEach((tokenAccount, index) => {
        const ataAddress = tokenAtas[index];
        let resolvedInstruction;
        if (tokenAccount) {
          if (!tokenAccount.owner.equals(ownerAddress)) {
            throw new Error(`ATA with change of ownership detected: ${ataAddress.toBase58()}`);
          }
          resolvedInstruction = { address: ataAddress, ...common_sdk_1.EMPTY_INSTRUCTION };
        } else {
          const tokenMint = tokenMintArray[index];
          const createAtaInstructions = [
            (0, spl_token_1.createAssociatedTokenAccountInstruction)(payer, ataAddress, ownerAddress, tokenMint)
          ];
          let cleanupInstructions = [];
          if (intermediateTokenMints.has(tokenMint.toBase58())) {
            cleanupInstructions = [
              (0, spl_token_1.createCloseAccountInstruction)(ataAddress, ownerAddress, ownerAddress)
            ];
          }
          resolvedInstruction = {
            address: ataAddress,
            instructions: createAtaInstructions,
            cleanupInstructions,
            signers: []
          };
        }
        instructionMap[tokenMintArray[index].toBase58()] = {
          tokenProgram: spl_token_1.TOKEN_PROGRAM_ID,
          ...resolvedInstruction
        };
      });
      return instructionMap;
    }
  }
});

// node_modules/@orca-so/whirlpools-sdk/dist/utils/math/k-smallest-partition.js
var require_k_smallest_partition = __commonJS({
  "node_modules/@orca-so/whirlpools-sdk/dist/utils/math/k-smallest-partition.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.kSmallestPartition = kSmallestPartition;
    var RECURSION_BREAKPOINT = 600;
    function kSmallestPartition(array, k, left = 0, right = array.length - 1, compare2 = defaultCompare) {
      while (right > left) {
        if (right - left > RECURSION_BREAKPOINT) {
          const n = right - left + 1;
          const i2 = k - left + 1;
          const z = Math.log(n);
          const s = 0.5 * Math.exp(2 * z / 3);
          const sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (i2 - n / 2 < 0 ? -1 : 1);
          const newLeft = Math.max(left, Math.floor(k - i2 * s / n + sd));
          const newRight = Math.min(right, Math.floor(k + (n - i2) * s / n + sd));
          kSmallestPartition(array, k, newLeft, newRight, compare2);
        }
        const t = array[k];
        let i = left;
        let j = right;
        swap(array, left, k);
        if (compare2(array[right], t) > 0) {
          swap(array, left, right);
        }
        while (i < j) {
          swap(array, i, j);
          i++;
          j--;
          while (compare2(array[i], t) < 0) {
            i++;
          }
          while (compare2(array[j], t) > 0) {
            j--;
          }
        }
        if (compare2(array[left], t) === 0) {
          swap(array, left, j);
        } else {
          j++;
          swap(array, j, right);
        }
        if (j <= k) {
          left = j + 1;
        }
        if (k <= j) {
          right = j - 1;
        }
      }
    }
    function swap(arr, i, j) {
      const tmp = arr[i];
      arr[i] = arr[j];
      arr[j] = tmp;
    }
    function defaultCompare(a, b) {
      return a < b ? -1 : a > b ? 1 : 0;
    }
  }
});

// node_modules/@orca-so/whirlpools-sdk/dist/router/convert-quote-map.js
var require_convert_quote_map = __commonJS({
  "node_modules/@orca-so/whirlpools-sdk/dist/router/convert-quote-map.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getBestRoutesFromQuoteMap = getBestRoutesFromQuoteMap;
    var bn_js_1 = __importDefault(require_bn());
    var k_smallest_partition_1 = require_k_smallest_partition();
    function getBestRoutesFromQuoteMap(quoteMap, amountSpecifiedIsInput, opts) {
      const { numTopRoutes, maxSplits } = opts;
      const sortedRoutes = [
        ...getRankedRoutes(quoteMap, amountSpecifiedIsInput, numTopRoutes, maxSplits),
        ...getSingleHopSplit(quoteMap)
      ].sort(getRouteCompareFn(amountSpecifiedIsInput));
      return convertInternalRoutesToTradeRoutes(sortedRoutes);
    }
    function convertInternalRoutesToTradeRoutes(internalRoutes) {
      const tradeRoutes = internalRoutes.map((internalRoute) => {
        const { quotes, totalIn, totalOut } = internalRoute;
        return {
          subRoutes: quotes.map((quote) => convertPathQuoteToSubTradeRoute(quote)),
          totalAmountIn: totalIn,
          totalAmountOut: totalOut
        };
      });
      return tradeRoutes;
    }
    function convertPathQuoteToSubTradeRoute(pathQuote) {
      const { calculatedEdgeQuotes, path, splitPercent, amountIn, amountOut } = pathQuote;
      return {
        path,
        splitPercent,
        amountIn,
        amountOut,
        hopQuotes: calculatedEdgeQuotes
      };
    }
    function getSingleHopSplit(quoteMap) {
      const fullFlow = quoteMap[100];
      if (fullFlow) {
        return fullFlow.filter((f) => f.calculatedEdgeQuotes.length == 1).map((f) => {
          const oneHop = f.calculatedEdgeQuotes[0];
          return {
            quotes: [f],
            splitPercent: 100,
            totalIn: oneHop.amountIn,
            totalOut: oneHop.amountOut
          };
        }).flatMap((g) => !!g ? g : []);
      }
      return [];
    }
    function getRankedRoutes(percentMap, amountSpecifiedIsInput, topN, maxSplits) {
      let routes = generateRoutes(percentMap, maxSplits);
      const routeCompare = getRouteCompareFn(amountSpecifiedIsInput);
      if (routes.length <= topN) {
        return routes.sort(routeCompare);
      }
      (0, k_smallest_partition_1.kSmallestPartition)(routes, topN, 0, routes.length - 1, routeCompare);
      return routes.slice(0, topN).sort(routeCompare);
    }
    function generateRoutes(percentMap, maxSplits) {
      let routes = [];
      buildRoutes(percentMap, maxSplits, {
        quotes: [],
        splitPercent: 0,
        totalIn: new bn_js_1.default(0),
        totalOut: new bn_js_1.default(0)
      }, routes);
      return routes;
    }
    function buildRoutes(quotePercentMap, maxSplits, currentRoute, routes) {
      const { splitPercent: percent, quotes } = currentRoute;
      const percents = Object.keys(quotePercentMap).map((percent2) => Number(percent2));
      for (let i = percents.length - 1; i >= 0; i--) {
        const nextPercent = percents[i];
        const newPercentTotal = percent + nextPercent;
        const nextPercentIsSmaller = quotes.length > 0 && nextPercent > quotes[quotes.length - 1].splitPercent;
        if (newPercentTotal > 100 || nextPercentIsSmaller) {
          continue;
        }
        const nextPercentQuotes = quotePercentMap[nextPercent];
        for (let j = 0; j < nextPercentQuotes.length; j++) {
          const nextQuote = nextPercentQuotes[j];
          const hasReusedPools = nextQuote.edgesPoolAddrs.some((r1) => quotes.some((r2) => r2.edgesPoolAddrs.some((r3) => r3.indexOf(r1) !== -1)));
          if (hasReusedPools) {
            continue;
          }
          const nextRoute = {
            quotes: [...quotes, nextQuote],
            splitPercent: newPercentTotal,
            totalIn: currentRoute.totalIn.add(nextQuote.amountIn),
            totalOut: currentRoute.totalOut.add(nextQuote.amountOut)
          };
          const nextCandidateQuotes = nextPercentQuotes.slice(j + 1);
          if (newPercentTotal === 100) {
            routes.push(nextRoute);
          } else if (quotes.length + 1 != maxSplits) {
            buildRoutes({
              ...quotePercentMap,
              [nextPercent]: nextCandidateQuotes
            }, maxSplits, nextRoute, routes);
          }
        }
      }
    }
    function getRouteCompareFn(amountSpecifiedIsInput) {
      return amountSpecifiedIsInput ? routesCompareForInputAmount : routesCompareForOutputAmount;
    }
    function routesCompareForInputAmount(a, b) {
      return b.totalOut.cmp(a.totalOut);
    }
    function routesCompareForOutputAmount(a, b) {
      return a.totalIn.cmp(b.totalIn);
    }
  }
});

// node_modules/@orca-so/whirlpools-sdk/dist/router/batch-swap-quote.js
var require_batch_swap_quote = __commonJS({
  "node_modules/@orca-so/whirlpools-sdk/dist/router/batch-swap-quote.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.batchBuildSwapQuoteParams = batchBuildSwapQuoteParams;
    var common_sdk_1 = require_dist2();
    var tiny_invariant_1 = __importDefault(require_tiny_invariant_cjs());
    var public_1 = require_public3();
    var token_extension_util_1 = require_token_extension_util();
    async function batchBuildSwapQuoteParams(quoteRequests, programId, fetcher, opts) {
      const whirlpools = await fetcher.getPools(quoteRequests.map((req) => req.whirlpool), opts);
      const program = common_sdk_1.AddressUtil.toPubKey(programId);
      const tickArrayRequests = quoteRequests.map((quoteReq) => {
        const { whirlpool, tokenAmount, tradeTokenMint, amountSpecifiedIsInput } = quoteReq;
        const whirlpoolData = whirlpools.get(common_sdk_1.AddressUtil.toString(whirlpool));
        const swapMintKey = common_sdk_1.AddressUtil.toPubKey(tradeTokenMint);
        const swapTokenType = public_1.PoolUtil.getTokenType(whirlpoolData, swapMintKey);
        (0, tiny_invariant_1.default)(!!swapTokenType, "swapTokenMint does not match any tokens on this pool");
        const aToB = public_1.SwapUtils.getSwapDirection(whirlpoolData, swapMintKey, amountSpecifiedIsInput) === public_1.SwapDirection.AtoB;
        return {
          whirlpoolData,
          tokenAmount,
          aToB,
          tickCurrentIndex: whirlpoolData.tickCurrentIndex,
          tickSpacing: whirlpoolData.tickSpacing,
          whirlpoolAddress: common_sdk_1.AddressUtil.toPubKey(whirlpool),
          amountSpecifiedIsInput
        };
      });
      const tickArrays = await public_1.SwapUtils.getBatchTickArrays(program, fetcher, tickArrayRequests, opts);
      return tickArrayRequests.map((req, index) => {
        const { whirlpoolData, tokenAmount, aToB, amountSpecifiedIsInput } = req;
        return {
          whirlpoolData,
          tokenAmount,
          aToB,
          amountSpecifiedIsInput,
          sqrtPriceLimit: public_1.SwapUtils.getDefaultSqrtPriceLimit(aToB),
          otherAmountThreshold: public_1.SwapUtils.getDefaultOtherAmountThreshold(amountSpecifiedIsInput),
          tickArrays: tickArrays[index],
          tokenExtensionCtx: token_extension_util_1.NO_TOKEN_EXTENSION_CONTEXT
        };
      });
    }
  }
});

// node_modules/@orca-so/whirlpools-sdk/dist/router/quote-map.js
var require_quote_map = __commonJS({
  "node_modules/@orca-so/whirlpools-sdk/dist/router/quote-map.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getQuoteMap = getQuoteMap;
    var common_sdk_1 = require_dist2();
    var bn_js_1 = __importDefault(require_bn());
    var fetcher_1 = require_fetcher2();
    var public_1 = require_public5();
    var public_2 = require_public3();
    var batch_swap_quote_1 = require_batch_swap_quote();
    async function getQuoteMap(trade, paths, amountSpecifiedIsInput, programId, fetcher, opts) {
      const { percentIncrement, numTopPartialQuotes } = opts;
      const { tokenIn, tokenOut, tradeAmount } = trade;
      const { percents, amounts } = getSplitPercentageAmts(tradeAmount, percentIncrement);
      const maxRouteLength = Math.max(...paths.map((path) => path.edges.length), 0);
      const quoteMap = {};
      let iteration = Array.from(Array(maxRouteLength).keys());
      if (!amountSpecifiedIsInput) {
        iteration = iteration.reverse();
      }
      try {
        for (const hop of iteration) {
          const quoteUpdates = buildQuoteUpdateRequests(tokenIn, tokenOut, paths, percents, amounts, hop, amountSpecifiedIsInput, quoteMap);
          const quoteParams = await (0, batch_swap_quote_1.batchBuildSwapQuoteParams)(quoteUpdates.map((update) => update.request), common_sdk_1.AddressUtil.toPubKey(programId), fetcher, fetcher_1.PREFER_CACHE);
          populateQuoteMap(quoteUpdates, quoteParams, quoteMap);
        }
      } catch (e) {
        throw e;
      }
      return sanitizeQuoteMap(quoteMap, numTopPartialQuotes, amountSpecifiedIsInput);
    }
    function populateQuoteMap(quoteUpdates, quoteParams, quoteMap) {
      for (const { splitPercent, pathIndex, quoteIndex, edgeIndex, request } of quoteUpdates) {
        const swapParam = quoteParams[quoteIndex];
        const path = quoteMap[splitPercent][pathIndex];
        try {
          const quote = (0, public_1.swapQuoteWithParams)(swapParam, common_sdk_1.Percentage.fromFraction(0, 1e3));
          const { whirlpoolData, tokenAmount, aToB, amountSpecifiedIsInput } = swapParam;
          const [mintA, mintB, vaultA, vaultB] = [
            whirlpoolData.tokenMintA.toBase58(),
            whirlpoolData.tokenMintB.toBase58(),
            whirlpoolData.tokenVaultA.toBase58(),
            whirlpoolData.tokenVaultB.toBase58()
          ];
          const [inputMint, outputMint] = aToB ? [mintA, mintB] : [mintB, mintA];
          path.calculatedEdgeQuotes[edgeIndex] = {
            success: true,
            amountIn: amountSpecifiedIsInput ? tokenAmount : quote.estimatedAmountIn,
            amountOut: amountSpecifiedIsInput ? quote.estimatedAmountOut : tokenAmount,
            whirlpool: request.whirlpool,
            inputMint,
            outputMint,
            mintA,
            mintB,
            vaultA,
            vaultB,
            quote,
            snapshot: {
              aToB: swapParam.aToB,
              sqrtPrice: whirlpoolData.sqrtPrice,
              feeRate: public_2.PoolUtil.getFeeRate(whirlpoolData.feeRate)
            }
          };
        } catch (e) {
          const errorCode = e.errorCode;
          path.calculatedEdgeQuotes[edgeIndex] = {
            success: false,
            error: errorCode
          };
          continue;
        }
      }
    }
    function buildQuoteUpdateRequests(tokenIn, tokenOut, paths, percents, amounts, hop, amountSpecifiedIsInput, quoteMap) {
      const quoteUpdates = [];
      for (let amountIndex = 0; amountIndex < amounts.length; amountIndex++) {
        const percent = percents[amountIndex];
        const tradeAmount = amounts[amountIndex];
        if (!quoteMap[percent]) {
          quoteMap[percent] = Array(paths.length);
        }
        for (let pathIndex = 0; pathIndex < paths.length; pathIndex++) {
          const path = paths[pathIndex];
          const edges = path.edges;
          if (amountSpecifiedIsInput ? edges.length <= hop : hop > edges.length - 1) {
            continue;
          }
          const startingRouteEval = amountSpecifiedIsInput ? hop === 0 : hop === edges.length - 1;
          const poolsPath = common_sdk_1.AddressUtil.toStrings(edges.map((edge) => edge.poolAddress));
          if (startingRouteEval) {
            quoteMap[percent][pathIndex] = {
              path,
              splitPercent: percent,
              edgesPoolAddrs: poolsPath,
              calculatedEdgeQuotes: Array(edges.length)
            };
          }
          const currentQuote = quoteMap[percent][pathIndex];
          const poolAddr = poolsPath[hop];
          const lastHop = amountSpecifiedIsInput ? currentQuote.calculatedEdgeQuotes[hop - 1] : currentQuote.calculatedEdgeQuotes[hop + 1];
          let tokenAmount;
          let tradeToken;
          if (startingRouteEval) {
            tokenAmount = tradeAmount;
            tradeToken = amountSpecifiedIsInput ? tokenIn : tokenOut;
          } else {
            if (!lastHop?.success) {
              continue;
            }
            tokenAmount = amountSpecifiedIsInput ? lastHop.amountOut : lastHop.amountIn;
            tradeToken = amountSpecifiedIsInput ? lastHop.outputMint : lastHop.inputMint;
          }
          quoteUpdates.push({
            splitPercent: percent,
            pathIndex,
            edgeIndex: hop,
            quoteIndex: quoteUpdates.length,
            request: {
              whirlpool: poolAddr,
              tradeTokenMint: tradeToken,
              tokenAmount,
              amountSpecifiedIsInput
            }
          });
        }
      }
      return quoteUpdates;
    }
    function sanitizeQuoteMap(quoteMap, pruneN, amountSpecifiedIsInput) {
      const percents = Object.keys(quoteMap).map((percent) => Number(percent));
      const cleanedQuoteMap = {};
      const failureErrors = /* @__PURE__ */ new Set();
      for (let i = 0; i < percents.length; i++) {
        const percent = percents[i];
        const uncleanedQuotes = quoteMap[percent];
        cleanedQuoteMap[percent] = [];
        for (const { edgesPoolAddrs: hopPoolAddrs, calculatedEdgeQuotes: calculatedHops, path } of uncleanedQuotes) {
          const filteredCalculatedEdges = calculatedHops.flatMap((val) => !!val && val.success ? val : []);
          if (filteredCalculatedEdges.length === hopPoolAddrs.length) {
            const [input, output] = [
              filteredCalculatedEdges[0].amountIn,
              filteredCalculatedEdges[filteredCalculatedEdges.length - 1].amountOut
            ];
            cleanedQuoteMap[percent].push({
              path,
              splitPercent: percent,
              edgesPoolAddrs: hopPoolAddrs,
              amountIn: input,
              amountOut: output,
              calculatedEdgeQuotes: filteredCalculatedEdges
            });
            continue;
          }
          const quoteFailures = calculatedHops.flatMap((f) => f && !f?.success ? f : []);
          failureErrors.add(quoteFailures[0].error);
        }
      }
      const prunedQuoteMap = {};
      const sortFn = amountSpecifiedIsInput ? (a, b) => b.amountOut.cmp(a.amountOut) : (a, b) => a.amountIn.cmp(b.amountIn);
      for (let i = 0; i < percents.length; i++) {
        const sortedQuotes = cleanedQuoteMap[percents[i]].sort(sortFn);
        const slicedSorted = sortedQuotes.slice(0, pruneN);
        prunedQuoteMap[percents[i]] = slicedSorted;
      }
      return [prunedQuoteMap, failureErrors];
    }
    function getSplitPercentageAmts(inputAmount, minPercent = 5) {
      const percents = [];
      const amounts = [];
      for (let i = 1; i <= 100 / minPercent; i++) {
        percents.push(i * minPercent);
        amounts.push(inputAmount.mul(new bn_js_1.default(i * minPercent)).div(new bn_js_1.default(100)));
      }
      return { percents, amounts };
    }
  }
});

// node_modules/@orca-so/whirlpools-sdk/dist/router/router-impl.js
var require_router_impl = __commonJS({
  "node_modules/@orca-so/whirlpools-sdk/dist/router/router-impl.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.WhirlpoolRouterImpl = void 0;
    var common_sdk_1 = require_dist2();
    var errors_1 = require_errors3();
    var swap_with_route_1 = require_swap_with_route();
    var fetcher_1 = require_fetcher2();
    var public_1 = require_public3();
    var convert_quote_map_1 = require_convert_quote_map();
    var public_2 = require_public6();
    var quote_map_1 = require_quote_map();
    var WhirlpoolRouterImpl = class {
      ctx;
      poolGraph;
      constructor(ctx, poolGraph) {
        this.ctx = ctx;
        this.poolGraph = poolGraph;
      }
      async findAllRoutes(trade, opts, fetchOpts) {
        const { tokenIn, tokenOut, tradeAmount, amountSpecifiedIsInput } = trade;
        const paths = this.poolGraph.getPath(tokenIn, tokenOut);
        if (paths.length === 0) {
          return Promise.reject(new errors_1.WhirlpoolsError(`Could not find route for ${tokenIn} -> ${tokenOut}`, errors_1.RouteQueryErrorCode.RouteDoesNotExist));
        }
        if (tradeAmount.isZero()) {
          return Promise.reject(new errors_1.WhirlpoolsError(`findBestRoutes error - input amount is zero.`, errors_1.RouteQueryErrorCode.ZeroInputAmount));
        }
        const routingOptions = { ...public_2.RouterUtils.getDefaultRouteOptions(), ...opts };
        const { program, fetcher } = this.ctx;
        const programId = program.programId;
        await prefetchRoutes(paths, programId, fetcher, fetchOpts);
        try {
          const [quoteMap, failures] = await (0, quote_map_1.getQuoteMap)(trade, paths, amountSpecifiedIsInput, programId, fetcher, routingOptions);
          const bestRoutes = (0, convert_quote_map_1.getBestRoutesFromQuoteMap)(quoteMap, amountSpecifiedIsInput, routingOptions);
          if (bestRoutes.length === 0) {
            if (failures.has(errors_1.SwapErrorCode.TickArraySequenceInvalid)) {
              return Promise.reject(new errors_1.WhirlpoolsError(`All swap quote generation failed on amount too high.`, errors_1.RouteQueryErrorCode.TradeAmountTooHigh));
            }
          }
          return bestRoutes;
        } catch (e) {
          return Promise.reject(new errors_1.WhirlpoolsError(`Stack error received on quote generation.`, errors_1.RouteQueryErrorCode.General, e instanceof Error ? e.stack : ""));
        }
      }
      async findBestRoute(trade, routingOpts, selectionOpts, fetchOpts) {
        const allRoutes = await this.findAllRoutes(trade, routingOpts, fetchOpts);
        const selectOpts = {
          ...public_2.RouterUtils.getDefaultSelectOptions(),
          ...selectionOpts
        };
        return await public_2.RouterUtils.selectFirstExecutableRoute(this.ctx, allRoutes, selectOpts);
      }
      async swap(trade, slippage, resolvedAtas) {
        const txBuilder = await (0, swap_with_route_1.getSwapFromRoute)(this.ctx, {
          route: trade,
          slippage,
          resolvedAtaAccounts: resolvedAtas,
          wallet: this.ctx.wallet.publicKey
        }, fetcher_1.IGNORE_CACHE);
        return txBuilder;
      }
    };
    exports2.WhirlpoolRouterImpl = WhirlpoolRouterImpl;
    async function prefetchRoutes(paths, programId, fetcher, opts = fetcher_1.PREFER_CACHE) {
      const poolSet = /* @__PURE__ */ new Set();
      for (let i = 0; i < paths.length; i++) {
        const path = paths[i];
        for (let j = 0; j < path.edges.length; j++) {
          poolSet.add(common_sdk_1.AddressUtil.toString(path.edges[j].poolAddress));
        }
      }
      const ps = Array.from(poolSet);
      const allWps = await fetcher.getPools(ps, opts);
      const tickArrayAddresses = [];
      for (const [key, wp] of allWps) {
        if (wp == null) {
          continue;
        }
        const addr1 = public_1.SwapUtils.getTickArrayPublicKeys(wp.tickCurrentIndex, wp.tickSpacing, true, common_sdk_1.AddressUtil.toPubKey(programId), common_sdk_1.AddressUtil.toPubKey(key));
        const addr2 = public_1.SwapUtils.getTickArrayPublicKeys(wp.tickCurrentIndex, wp.tickSpacing, false, common_sdk_1.AddressUtil.toPubKey(programId), common_sdk_1.AddressUtil.toPubKey(key));
        const allAddrs = [...addr1, ...addr2].map((k) => k.toBase58());
        const unique = Array.from(new Set(allAddrs));
        tickArrayAddresses.push(...unique);
      }
      await fetcher.getTickArrays(tickArrayAddresses, opts);
    }
  }
});

// node_modules/@orca-so/whirlpools-sdk/dist/router/public/router-builder.js
var require_router_builder = __commonJS({
  "node_modules/@orca-so/whirlpools-sdk/dist/router/public/router-builder.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.WhirlpoolRouterBuilder = void 0;
    var public_1 = require_public3();
    var router_impl_1 = require_router_impl();
    var WhirlpoolRouterBuilder = class {
      static buildWithPoolGraph(ctx, graph) {
        return new router_impl_1.WhirlpoolRouterImpl(ctx, graph);
      }
      static async buildWithPools(ctx, pools) {
        const poolGraph = await public_1.PoolGraphBuilder.buildPoolGraphWithFetch(pools, ctx.fetcher);
        return new router_impl_1.WhirlpoolRouterImpl(ctx, poolGraph);
      }
    };
    exports2.WhirlpoolRouterBuilder = WhirlpoolRouterBuilder;
  }
});

// node_modules/@orca-so/whirlpools-sdk/dist/utils/math/constants.js
var require_constants5 = __commonJS({
  "node_modules/@orca-so/whirlpools-sdk/dist/utils/math/constants.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.U64 = void 0;
    var common_sdk_1 = require_dist2();
    exports2.U64 = common_sdk_1.U64_MAX.add(common_sdk_1.ONE);
  }
});

// node_modules/@orca-so/whirlpools-sdk/dist/utils/wallet-utils.js
var require_wallet_utils = __commonJS({
  "node_modules/@orca-so/whirlpools-sdk/dist/utils/wallet-utils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isWalletConnected = isWalletConnected;
    var web3_js_1 = require("@solana/web3.js");
    function isWalletConnected(wallet) {
      return wallet !== null && !wallet.publicKey.equals(web3_js_1.PublicKey.default);
    }
  }
});

// node_modules/@orca-so/whirlpools-sdk/dist/router/public/router-utils.js
var require_router_utils = __commonJS({
  "node_modules/@orca-so/whirlpools-sdk/dist/router/public/router-utils.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RouterUtils = void 0;
    var common_sdk_1 = require_dist2();
    var bn_js_1 = __importDefault(require_bn());
    var decimal_js_1 = __importDefault(require_decimal());
    var swap_with_route_1 = require_swap_with_route();
    var fetcher_1 = require_fetcher2();
    var constants_1 = require_constants5();
    var public_1 = require_public3();
    var wallet_utils_1 = require_wallet_utils();
    var RouterUtils = class _RouterUtils {
      static async selectFirstExecutableRoute(ctx, orderedRoutes, opts) {
        const { wallet } = ctx;
        if (orderedRoutes.length === 0) {
          return null;
        }
        if (!(0, wallet_utils_1.isWalletConnected)(wallet)) {
          return [orderedRoutes[0], void 0];
        }
        if (opts.maxSupportedTransactionVersion !== "legacy" && ctx.lookupTableFetcher) {
          await loadLookupTablesForRoutes(ctx.lookupTableFetcher, orderedRoutes);
        }
        for (let i = 0; i < orderedRoutes.length && i < MEASURE_ROUTE_MAX; i++) {
          const route = orderedRoutes[i];
          const tx = await (0, swap_with_route_1.getSwapFromRoute)(ctx, {
            route,
            slippage: common_sdk_1.Percentage.fromFraction(0, 100),
            resolvedAtaAccounts: opts.availableAtaAccounts ?? null,
            wallet: wallet.publicKey
          }, fetcher_1.PREFER_CACHE);
          if (!!opts.onRouteEvaluation) {
            opts.onRouteEvaluation(route, tx);
          }
          try {
            const legacyTxSize = tx.txnSize({
              latestBlockhash: common_sdk_1.MEASUREMENT_BLOCKHASH,
              maxSupportedTransactionVersion: "legacy"
            });
            if (legacyTxSize !== void 0 && legacyTxSize <= opts.maxTransactionSize) {
              return [route, void 0];
            }
          } catch {
          }
          let v0TxSize;
          if (opts.maxSupportedTransactionVersion !== "legacy" && ctx.lookupTableFetcher) {
            const addressesToLookup = _RouterUtils.getTouchedTickArraysFromRoute(route);
            if (addressesToLookup.length > MAX_LOOKUP_TABLE_FETCH_SIZE) {
              continue;
            }
            const lookupTableAccounts = await ctx.lookupTableFetcher.getLookupTableAccountsForAddresses(addressesToLookup);
            try {
              v0TxSize = tx.txnSize({
                latestBlockhash: common_sdk_1.MEASUREMENT_BLOCKHASH,
                maxSupportedTransactionVersion: opts.maxSupportedTransactionVersion,
                lookupTableAccounts
              });
              if (v0TxSize !== void 0 && v0TxSize <= opts.maxTransactionSize) {
                return [route, lookupTableAccounts];
              }
            } catch {
            }
          }
        }
        return null;
      }
      static getPriceImpactForRoute(trade, route) {
        const { amountSpecifiedIsInput } = trade;
        const totalBaseValue = route.subRoutes.reduce((acc, route2) => {
          const directionalHops = amountSpecifiedIsInput ? route2.hopQuotes : route2.hopQuotes.slice().reverse();
          const baseOutputs = directionalHops.reduce((acc2, quote, index) => {
            const { snapshot } = quote;
            const { aToB, sqrtPrice, feeRate } = snapshot;
            const directionalSqrtPrice = aToB ? sqrtPrice : public_1.PriceMath.invertSqrtPriceX64(sqrtPrice);
            let nextBaseValue;
            const price = directionalSqrtPrice.mul(directionalSqrtPrice).div(constants_1.U64);
            if (amountSpecifiedIsInput) {
              const amountIn = index === 0 ? quote.amountIn : acc2[index - 1];
              const feeAdjustedAmount = amountIn.mul(feeRate.denominator.sub(feeRate.numerator)).div(feeRate.denominator);
              nextBaseValue = price.mul(feeAdjustedAmount).div(constants_1.U64);
            } else {
              const amountOut = index === 0 ? quote.amountOut : acc2[index - 1];
              const feeAdjustedAmount = amountOut.mul(constants_1.U64).div(price);
              nextBaseValue = feeAdjustedAmount.mul(feeRate.denominator).div(feeRate.denominator.sub(feeRate.numerator));
            }
            acc2.push(nextBaseValue);
            return acc2;
          }, new Array());
          return acc.add(baseOutputs[baseOutputs.length - 1]);
        }, new bn_js_1.default(0));
        const totalBaseValueDec = new decimal_js_1.default(totalBaseValue.toString());
        const totalAmountEstimatedDec = new decimal_js_1.default(amountSpecifiedIsInput ? route.totalAmountOut.toString() : route.totalAmountIn.toString());
        const priceImpact = amountSpecifiedIsInput ? totalBaseValueDec.sub(totalAmountEstimatedDec).div(totalBaseValueDec) : totalAmountEstimatedDec.sub(totalBaseValueDec).div(totalAmountEstimatedDec);
        return priceImpact.mul(100);
      }
      static getTouchedTickArraysFromRoute(route) {
        const taAddresses = /* @__PURE__ */ new Set();
        for (const quote of route.subRoutes) {
          for (const hop of quote.hopQuotes) {
            taAddresses.add(hop.quote.tickArray0.toBase58());
            taAddresses.add(hop.quote.tickArray1.toBase58());
            taAddresses.add(hop.quote.tickArray2.toBase58());
          }
        }
        return common_sdk_1.AddressUtil.toPubKeys(Array.from(taAddresses));
      }
      static getDefaultRouteOptions() {
        return {
          percentIncrement: 20,
          numTopRoutes: 50,
          numTopPartialQuotes: 10,
          maxSplits: 3
        };
      }
      static getDefaultSelectOptions() {
        return {
          maxSupportedTransactionVersion: 0,
          maxTransactionSize: common_sdk_1.TX_SIZE_LIMIT
        };
      }
    };
    exports2.RouterUtils = RouterUtils;
    async function loadLookupTablesForRoutes(lookupTableFetcher, routes) {
      const altTicks = /* @__PURE__ */ new Set();
      for (let i = 0; i < routes.length && i < MEASURE_ROUTE_MAX; i++) {
        const route = routes[i];
        RouterUtils.getTouchedTickArraysFromRoute(route).map((ta) => altTicks.add(ta.toBase58()));
      }
      const altTickArray = Array.from(altTicks);
      const altPageSize = 45;
      const altRequests = [];
      for (let i = 0; i < altTickArray.length; i += altPageSize) {
        altRequests.push(altTickArray.slice(i, i + altPageSize));
      }
      await Promise.all(altRequests.map((altPage) => {
        const altPageKeys = common_sdk_1.AddressUtil.toPubKeys(altPage);
        lookupTableFetcher.loadLookupTables(altPageKeys);
      }));
    }
    var MEASURE_ROUTE_MAX = 100;
    var MAX_LOOKUP_TABLE_FETCH_SIZE = 50;
  }
});

// node_modules/@orca-so/whirlpools-sdk/dist/router/public/index.js
var require_public6 = __commonJS({
  "node_modules/@orca-so/whirlpools-sdk/dist/router/public/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_router_builder(), exports2);
    __exportStar(require_router_utils(), exports2);
  }
});

// node_modules/@orca-so/whirlpools-sdk/dist/impl/util.js
var require_util = __commonJS({
  "node_modules/@orca-so/whirlpools-sdk/dist/impl/util.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getTokenMintInfos = getTokenMintInfos;
    exports2.getRewardInfos = getRewardInfos;
    exports2.getTokenVaultAccountInfos = getTokenVaultAccountInfos;
    var bn_js_1 = __importDefault(require_bn());
    var __1 = require_dist3();
    async function getTokenMintInfos(fetcher, data, opts) {
      const mintA = data.tokenMintA;
      const infoA = await fetcher.getMintInfo(mintA, opts);
      if (!infoA) {
        throw new Error(`Unable to fetch MintInfo for mint - ${mintA}`);
      }
      const mintB = data.tokenMintB;
      const infoB = await fetcher.getMintInfo(mintB, opts);
      if (!infoB) {
        throw new Error(`Unable to fetch MintInfo for mint - ${mintB}`);
      }
      return [
        { mint: mintA, ...infoA },
        { mint: mintB, ...infoB }
      ];
    }
    async function getRewardInfos(fetcher, data, opts) {
      const rewardInfos = [];
      for (const rewardInfo of data.rewardInfos) {
        rewardInfos.push(await getRewardInfo(fetcher, rewardInfo, opts));
      }
      return rewardInfos;
    }
    async function getRewardInfo(fetcher, data, opts) {
      const rewardInfo = { ...data, initialized: false, vaultAmount: new bn_js_1.default(0) };
      if (__1.PoolUtil.isRewardInitialized(data)) {
        const vaultInfo = await fetcher.getTokenInfo(data.vault, opts);
        if (!vaultInfo) {
          throw new Error(`Unable to fetch TokenAccountInfo for vault - ${data.vault}`);
        }
        rewardInfo.initialized = true;
        rewardInfo.vaultAmount = new bn_js_1.default(vaultInfo.amount.toString());
      }
      return rewardInfo;
    }
    async function getTokenVaultAccountInfos(fetcher, data, opts) {
      const vaultA = data.tokenVaultA;
      const vaultInfoA = await fetcher.getTokenInfo(vaultA, opts);
      if (!vaultInfoA) {
        throw new Error(`Unable to fetch TokenAccountInfo for vault - ${vaultA}`);
      }
      const vaultB = data.tokenVaultB;
      const vaultInfoB = await fetcher.getTokenInfo(vaultB, opts);
      if (!vaultInfoB) {
        throw new Error(`Unable to fetch TokenAccountInfo for vault - ${vaultB}`);
      }
      return [vaultInfoA, vaultInfoB];
    }
  }
});

// node_modules/@orca-so/whirlpools-sdk/dist/impl/whirlpool-impl.js
var require_whirlpool_impl = __commonJS({
  "node_modules/@orca-so/whirlpools-sdk/dist/impl/whirlpool-impl.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.WhirlpoolImpl = void 0;
    var anchor_1 = require("@coral-xyz/anchor");
    var common_sdk_1 = require_dist2();
    var spl_token_1 = require_cjs3();
    var web3_js_1 = require("@solana/web3.js");
    var tiny_invariant_1 = __importDefault(require_tiny_invariant_cjs());
    var instructions_1 = require_instructions9();
    var ix_1 = require_ix();
    var fetcher_1 = require_fetcher2();
    var public_1 = require_public5();
    var position_builder_util_1 = require_position_builder_util();
    var public_2 = require_public3();
    var token_extension_util_1 = require_token_extension_util();
    var txn_utils_1 = require_txn_utils();
    var whirlpool_ata_utils_1 = require_whirlpool_ata_utils();
    var position_impl_1 = require_position_impl();
    var util_1 = require_util();
    var WhirlpoolImpl = class {
      ctx;
      address;
      tokenAInfo;
      tokenBInfo;
      tokenVaultAInfo;
      tokenVaultBInfo;
      rewardInfos;
      data;
      constructor(ctx, address, tokenAInfo, tokenBInfo, tokenVaultAInfo, tokenVaultBInfo, rewardInfos, data) {
        this.ctx = ctx;
        this.address = address;
        this.tokenAInfo = tokenAInfo;
        this.tokenBInfo = tokenBInfo;
        this.tokenVaultAInfo = tokenVaultAInfo;
        this.tokenVaultBInfo = tokenVaultBInfo;
        this.rewardInfos = rewardInfos;
        this.data = data;
      }
      getAddress() {
        return this.address;
      }
      getData() {
        return this.data;
      }
      getTokenAInfo() {
        return this.tokenAInfo;
      }
      getTokenBInfo() {
        return this.tokenBInfo;
      }
      getTokenVaultAInfo() {
        return this.tokenVaultAInfo;
      }
      getTokenVaultBInfo() {
        return this.tokenVaultBInfo;
      }
      getRewardInfos() {
        return this.rewardInfos;
      }
      async refreshData() {
        await this.refresh();
        return this.data;
      }
      async openPosition(tickLower, tickUpper, liquidityInput, wallet, funder, positionMint, tokenProgramId) {
        await this.refresh();
        return this.getOpenPositionWithOptMetadataTx(tickLower, tickUpper, liquidityInput, !!wallet ? common_sdk_1.AddressUtil.toPubKey(wallet) : this.ctx.wallet.publicKey, !!funder ? common_sdk_1.AddressUtil.toPubKey(funder) : this.ctx.wallet.publicKey, tokenProgramId ?? spl_token_1.TOKEN_PROGRAM_ID, false, positionMint);
      }
      async openPositionWithMetadata(tickLower, tickUpper, liquidityInput, sourceWallet, funder, positionMint, tokenProgramId) {
        await this.refresh();
        return this.getOpenPositionWithOptMetadataTx(tickLower, tickUpper, liquidityInput, !!sourceWallet ? common_sdk_1.AddressUtil.toPubKey(sourceWallet) : this.ctx.wallet.publicKey, !!funder ? common_sdk_1.AddressUtil.toPubKey(funder) : this.ctx.wallet.publicKey, tokenProgramId ?? spl_token_1.TOKEN_PROGRAM_ID, true, positionMint);
      }
      async initTickArrayForTicks(ticks, funder, opts = fetcher_1.IGNORE_CACHE) {
        const initTickArrayStartPdas = await public_2.TickArrayUtil.getUninitializedArraysPDAs(ticks, this.ctx.program.programId, this.address, this.data.tickSpacing, this.ctx.fetcher, opts);
        if (!initTickArrayStartPdas.length) {
          return null;
        }
        const txBuilder = new common_sdk_1.TransactionBuilder(this.ctx.provider.connection, this.ctx.provider.wallet, this.ctx.txBuilderOpts);
        initTickArrayStartPdas.forEach((initTickArrayInfo) => {
          txBuilder.addInstruction((0, instructions_1.initTickArrayIx)(this.ctx.program, {
            startTick: initTickArrayInfo.startIndex,
            tickArrayPda: initTickArrayInfo.pda,
            whirlpool: this.address,
            funder: !!funder ? common_sdk_1.AddressUtil.toPubKey(funder) : this.ctx.provider.wallet.publicKey
          }));
        });
        return txBuilder;
      }
      async closePosition(positionAddress, slippageTolerance, destinationWallet, positionWallet, payer, usePriceSlippage = false) {
        await this.refresh();
        const positionWalletKey = positionWallet ? common_sdk_1.AddressUtil.toPubKey(positionWallet) : this.ctx.wallet.publicKey;
        const destinationWalletKey = destinationWallet ? common_sdk_1.AddressUtil.toPubKey(destinationWallet) : this.ctx.wallet.publicKey;
        const payerKey = payer ? common_sdk_1.AddressUtil.toPubKey(payer) : this.ctx.wallet.publicKey;
        return this.getClosePositionIx(common_sdk_1.AddressUtil.toPubKey(positionAddress), slippageTolerance, destinationWalletKey, positionWalletKey, payerKey, usePriceSlippage);
      }
      async swap(quote, sourceWallet) {
        const sourceWalletKey = sourceWallet ? common_sdk_1.AddressUtil.toPubKey(sourceWallet) : this.ctx.wallet.publicKey;
        return (0, instructions_1.swapAsync)(this.ctx, {
          swapInput: quote,
          whirlpool: this,
          wallet: sourceWalletKey
        }, fetcher_1.IGNORE_CACHE);
      }
      async swapWithDevFees(quote, devFeeWallet, wallet, payer) {
        const sourceWalletKey = wallet ? common_sdk_1.AddressUtil.toPubKey(wallet) : this.ctx.wallet.publicKey;
        const payerKey = payer ? common_sdk_1.AddressUtil.toPubKey(payer) : this.ctx.wallet.publicKey;
        const txBuilder = new common_sdk_1.TransactionBuilder(this.ctx.provider.connection, this.ctx.provider.wallet, this.ctx.txBuilderOpts);
        if (!quote.devFeeAmount.eq(common_sdk_1.ZERO)) {
          const inputToken = quote.aToB === quote.amountSpecifiedIsInput ? this.getTokenAInfo() : this.getTokenBInfo();
          txBuilder.addInstruction(await common_sdk_1.TokenUtil.createSendTokensToWalletInstruction(this.ctx.connection, sourceWalletKey, devFeeWallet, inputToken.mint, inputToken.decimals, quote.devFeeAmount, () => this.ctx.fetcher.getAccountRentExempt(), payerKey, this.ctx.accountResolverOpts.allowPDAOwnerAddress));
        }
        const swapTxBuilder = await (0, instructions_1.swapAsync)(this.ctx, {
          swapInput: quote,
          whirlpool: this,
          wallet: sourceWalletKey
        }, fetcher_1.IGNORE_CACHE);
        txBuilder.addInstruction(swapTxBuilder.compressIx(true));
        return txBuilder;
      }
      async getOpenPositionWithOptMetadataTx(tickLower, tickUpper, liquidityInput, wallet, funder, tokenProgramId, withMetadata = false, positionMint) {
        (0, tiny_invariant_1.default)(public_2.TickUtil.checkTickInBounds(tickLower), "tickLower is out of bounds.");
        (0, tiny_invariant_1.default)(public_2.TickUtil.checkTickInBounds(tickUpper), "tickUpper is out of bounds.");
        (0, tiny_invariant_1.default)(tokenProgramId.equals(spl_token_1.TOKEN_PROGRAM_ID) || tokenProgramId.equals(spl_token_1.TOKEN_2022_PROGRAM_ID), "tokenProgramId must be either TOKEN_PROGRAM_ID or TOKEN_2022_PROGRAM_ID");
        const { liquidityAmount: liquidity, tokenMaxA, tokenMaxB } = liquidityInput;
        (0, tiny_invariant_1.default)(liquidity.gt(new anchor_1.BN(0)), "liquidity must be greater than zero");
        const whirlpool = await this.ctx.fetcher.getPool(this.address, fetcher_1.PREFER_CACHE);
        if (!whirlpool) {
          throw new Error(`Whirlpool not found: ${(0, anchor_1.translateAddress)(this.address).toBase58()}`);
        }
        const tokenExtensionCtx = await token_extension_util_1.TokenExtensionUtil.buildTokenExtensionContext(this.ctx.fetcher, whirlpool, fetcher_1.IGNORE_CACHE);
        (0, tiny_invariant_1.default)(public_2.TickUtil.isTickInitializable(tickLower, whirlpool.tickSpacing), `lower tick ${tickLower} is not an initializable tick for tick-spacing ${whirlpool.tickSpacing}`);
        (0, tiny_invariant_1.default)(public_2.TickUtil.isTickInitializable(tickUpper, whirlpool.tickSpacing), `upper tick ${tickUpper} is not an initializable tick for tick-spacing ${whirlpool.tickSpacing}`);
        const positionMintKeypair = web3_js_1.Keypair.generate();
        const positionMintPubkey = positionMint ?? positionMintKeypair.publicKey;
        const positionPda = public_2.PDAUtil.getPosition(this.ctx.program.programId, positionMintPubkey);
        const metadataPda = public_2.PDAUtil.getPositionMetadata(positionMintPubkey);
        const positionTokenAccountAddress = (0, spl_token_1.getAssociatedTokenAddressSync)(positionMintPubkey, wallet, this.ctx.accountResolverOpts.allowPDAOwnerAddress, tokenProgramId);
        const txBuilder = new common_sdk_1.TransactionBuilder(this.ctx.provider.connection, this.ctx.provider.wallet, this.ctx.txBuilderOpts);
        const params = {
          funder,
          owner: wallet,
          positionPda,
          positionTokenAccount: positionTokenAccountAddress,
          whirlpool: this.address,
          tickLowerIndex: tickLower,
          tickUpperIndex: tickUpper
        };
        const positionIx = tokenProgramId.equals(spl_token_1.TOKEN_2022_PROGRAM_ID) ? (0, instructions_1.openPositionWithTokenExtensionsIx)(this.ctx.program, {
          ...params,
          positionMint: positionMintPubkey,
          withTokenMetadataExtension: withMetadata
        }) : (withMetadata ? instructions_1.openPositionWithMetadataIx : instructions_1.openPositionIx)(this.ctx.program, {
          ...params,
          positionMintAddress: positionMintPubkey,
          metadataPda
        });
        txBuilder.addInstruction(positionIx);
        if (positionMint === void 0) {
          txBuilder.addSigner(positionMintKeypair);
        }
        const [ataA, ataB] = await (0, common_sdk_1.resolveOrCreateATAs)(this.ctx.connection, wallet, [
          { tokenMint: whirlpool.tokenMintA, wrappedSolAmountIn: tokenMaxA },
          { tokenMint: whirlpool.tokenMintB, wrappedSolAmountIn: tokenMaxB }
        ], () => this.ctx.fetcher.getAccountRentExempt(), funder, void 0, this.ctx.accountResolverOpts.allowPDAOwnerAddress, this.ctx.accountResolverOpts.createWrappedSolAccountMethod);
        const { address: tokenOwnerAccountA, ...tokenOwnerAccountAIx } = ataA;
        const { address: tokenOwnerAccountB, ...tokenOwnerAccountBIx } = ataB;
        txBuilder.addInstruction(tokenOwnerAccountAIx);
        txBuilder.addInstruction(tokenOwnerAccountBIx);
        const tickArrayLowerPda = public_2.PDAUtil.getTickArrayFromTickIndex(tickLower, this.data.tickSpacing, this.address, this.ctx.program.programId);
        const tickArrayUpperPda = public_2.PDAUtil.getTickArrayFromTickIndex(tickUpper, this.data.tickSpacing, this.address, this.ctx.program.programId);
        const baseParams = {
          liquidityAmount: liquidity,
          tokenMaxA,
          tokenMaxB,
          whirlpool: this.address,
          positionAuthority: wallet,
          position: positionPda.publicKey,
          positionTokenAccount: positionTokenAccountAddress,
          tokenOwnerAccountA,
          tokenOwnerAccountB,
          tokenVaultA: whirlpool.tokenVaultA,
          tokenVaultB: whirlpool.tokenVaultB,
          tickArrayLower: tickArrayLowerPda.publicKey,
          tickArrayUpper: tickArrayUpperPda.publicKey
        };
        const liquidityIx = !token_extension_util_1.TokenExtensionUtil.isV2IxRequiredPool(tokenExtensionCtx) ? (0, instructions_1.increaseLiquidityIx)(this.ctx.program, baseParams) : (0, instructions_1.increaseLiquidityV2Ix)(this.ctx.program, {
          ...baseParams,
          tokenMintA: whirlpool.tokenMintA,
          tokenMintB: whirlpool.tokenMintB,
          tokenProgramA: tokenExtensionCtx.tokenMintWithProgramA.tokenProgram,
          tokenProgramB: tokenExtensionCtx.tokenMintWithProgramB.tokenProgram,
          ...await token_extension_util_1.TokenExtensionUtil.getExtraAccountMetasForTransferHookForPool(this.ctx.connection, tokenExtensionCtx, baseParams.tokenOwnerAccountA, baseParams.tokenVaultA, baseParams.positionAuthority, baseParams.tokenOwnerAccountB, baseParams.tokenVaultB, baseParams.positionAuthority)
        });
        txBuilder.addInstruction(liquidityIx);
        return {
          positionMint: positionMintPubkey,
          tx: txBuilder
        };
      }
      async getClosePositionIx(positionAddress, slippageTolerance, destinationWallet, positionWallet, payerKey, usePriceSlippage = false) {
        const positionData = await this.ctx.fetcher.getPosition(positionAddress, fetcher_1.IGNORE_CACHE);
        if (!positionData) {
          throw new Error(`Position not found: ${positionAddress.toBase58()}`);
        }
        const positionMint = await this.ctx.fetcher.getMintInfo(positionData.positionMint);
        if (!positionMint) {
          throw new Error(`Position mint not found: ${positionData.positionMint.toBase58()}`);
        }
        const whirlpool = this.data;
        (0, tiny_invariant_1.default)(positionData.whirlpool.equals(this.address), `Position ${positionAddress.toBase58()} is not a position for Whirlpool ${this.address.toBase58()}`);
        const positionTokenAccount = (0, spl_token_1.getAssociatedTokenAddressSync)(positionData.positionMint, positionWallet, this.ctx.accountResolverOpts.allowPDAOwnerAddress, positionMint.tokenProgram);
        const accountExemption = await this.ctx.fetcher.getAccountRentExempt();
        const tickArrayLower = public_2.PDAUtil.getTickArrayFromTickIndex(positionData.tickLowerIndex, whirlpool.tickSpacing, positionData.whirlpool, this.ctx.program.programId).publicKey;
        const tickArrayUpper = public_2.PDAUtil.getTickArrayFromTickIndex(positionData.tickUpperIndex, whirlpool.tickSpacing, positionData.whirlpool, this.ctx.program.programId).publicKey;
        const [tickArrayLowerData, tickArrayUpperData] = await (0, position_builder_util_1.getTickArrayDataForPosition)(this.ctx, positionData, whirlpool, fetcher_1.IGNORE_CACHE);
        (0, tiny_invariant_1.default)(!!tickArrayLowerData, `Tick array ${tickArrayLower} expected to be initialized for whirlpool ${this.address}`);
        (0, tiny_invariant_1.default)(!!tickArrayUpperData, `Tick array ${tickArrayUpper} expected to be initialized for whirlpool ${this.address}`);
        const tokenExtensionCtx = await token_extension_util_1.TokenExtensionUtil.buildTokenExtensionContext(this.ctx.fetcher, whirlpool, fetcher_1.IGNORE_CACHE);
        const position = new position_impl_1.PositionImpl(this.ctx, positionAddress, positionData, whirlpool, tickArrayLowerData, tickArrayUpperData, positionMint.tokenProgram);
        const tickLower = position.getLowerTickData();
        const tickUpper = position.getUpperTickData();
        const feesQuote = (0, public_1.collectFeesQuote)({
          position: positionData,
          whirlpool,
          tickLower,
          tickUpper,
          tokenExtensionCtx
        });
        const rewardsQuote = (0, public_1.collectRewardsQuote)({
          position: positionData,
          whirlpool,
          tickLower,
          tickUpper,
          tokenExtensionCtx
        });
        const shouldCollectFees = feesQuote.feeOwedA.gtn(0) || feesQuote.feeOwedB.gtn(0);
        (0, tiny_invariant_1.default)(this.data.rewardInfos.length === rewardsQuote.rewardOwed.length, "Rewards quote does not match reward infos length");
        const shouldDecreaseLiquidity = positionData.liquidity.gtn(0);
        const rewardsToCollect = this.data.rewardInfos.map((info, index) => ({ info, index })).filter(({ info, index }) => {
          if (!public_2.PoolUtil.isRewardInitialized(info)) {
            return false;
          }
          return (rewardsQuote.rewardOwed[index] ?? common_sdk_1.ZERO).gtn(0) || (rewardsQuote.transferFee.deductedFromRewardOwed[index] ?? common_sdk_1.ZERO).gtn(0);
        });
        const shouldCollectRewards = rewardsToCollect.length > 0;
        let mintType = whirlpool_ata_utils_1.TokenMintTypes.ALL;
        if ((shouldDecreaseLiquidity || shouldCollectFees) && !shouldCollectRewards) {
          mintType = whirlpool_ata_utils_1.TokenMintTypes.POOL_ONLY;
        } else if (!(shouldDecreaseLiquidity || shouldCollectFees) && shouldCollectRewards) {
          mintType = whirlpool_ata_utils_1.TokenMintTypes.REWARD_ONLY;
        }
        const allMints = (0, whirlpool_ata_utils_1.getTokenMintsFromWhirlpools)([whirlpool], mintType);
        const resolvedAtas = (0, txn_utils_1.convertListToMap)(await (0, common_sdk_1.resolveOrCreateATAs)(this.ctx.connection, destinationWallet, allMints.mintMap.map((tokenMint) => ({ tokenMint })), async () => accountExemption, payerKey, true, this.ctx.accountResolverOpts.allowPDAOwnerAddress, this.ctx.accountResolverOpts.createWrappedSolAccountMethod), allMints.mintMap.map((mint) => mint.toBase58()));
        const builder = new txn_utils_1.MultipleTransactionBuilderFactoryWithAccountResolver(this.ctx, resolvedAtas, destinationWallet, payerKey);
        if (shouldDecreaseLiquidity) {
          await builder.addInstructions(async (resolveTokenAccount) => {
            const tokenOwnerAccountA = resolveTokenAccount(whirlpool.tokenMintA.toBase58());
            const tokenOwnerAccountB = resolveTokenAccount(whirlpool.tokenMintB.toBase58());
            const params = {
              liquidity: positionData.liquidity,
              slippageTolerance,
              sqrtPrice: whirlpool.sqrtPrice,
              tickCurrentIndex: whirlpool.tickCurrentIndex,
              tickLowerIndex: positionData.tickLowerIndex,
              tickUpperIndex: positionData.tickUpperIndex,
              tokenExtensionCtx
            };
            const decreaseLiqQuote = usePriceSlippage ? (0, public_1.decreaseLiquidityQuoteByLiquidityWithParamsUsingPriceSlippage)(params) : (0, public_1.decreaseLiquidityQuoteByLiquidityWithParams)(params);
            const baseParams = {
              ...decreaseLiqQuote,
              whirlpool: positionData.whirlpool,
              positionAuthority: positionWallet,
              position: positionAddress,
              positionTokenAccount,
              tokenOwnerAccountA,
              tokenOwnerAccountB,
              tokenVaultA: whirlpool.tokenVaultA,
              tokenVaultB: whirlpool.tokenVaultB,
              tickArrayLower,
              tickArrayUpper
            };
            const ix = !token_extension_util_1.TokenExtensionUtil.isV2IxRequiredPool(tokenExtensionCtx) ? ix_1.WhirlpoolIx.decreaseLiquidityIx(this.ctx.program, baseParams) : ix_1.WhirlpoolIx.decreaseLiquidityV2Ix(this.ctx.program, {
              ...baseParams,
              tokenMintA: whirlpool.tokenMintA,
              tokenMintB: whirlpool.tokenMintB,
              tokenProgramA: tokenExtensionCtx.tokenMintWithProgramA.tokenProgram,
              tokenProgramB: tokenExtensionCtx.tokenMintWithProgramB.tokenProgram,
              ...await token_extension_util_1.TokenExtensionUtil.getExtraAccountMetasForTransferHookForPool(this.ctx.connection, tokenExtensionCtx, baseParams.tokenVaultA, baseParams.tokenOwnerAccountA, baseParams.whirlpool, baseParams.tokenVaultB, baseParams.tokenOwnerAccountB, baseParams.whirlpool)
            });
            return [ix];
          });
        }
        if (shouldCollectFees) {
          await builder.addInstructions(async (resolveTokenAccount) => {
            const tokenOwnerAccountA = resolveTokenAccount(whirlpool.tokenMintA.toBase58());
            const tokenOwnerAccountB = resolveTokenAccount(whirlpool.tokenMintB.toBase58());
            const collectFeesBaseParams = {
              whirlpool: positionData.whirlpool,
              position: positionAddress,
              positionAuthority: positionWallet,
              positionTokenAccount,
              tokenOwnerAccountA,
              tokenOwnerAccountB,
              tokenVaultA: whirlpool.tokenVaultA,
              tokenVaultB: whirlpool.tokenVaultB
            };
            const ix = !token_extension_util_1.TokenExtensionUtil.isV2IxRequiredPool(tokenExtensionCtx) ? ix_1.WhirlpoolIx.collectFeesIx(this.ctx.program, collectFeesBaseParams) : ix_1.WhirlpoolIx.collectFeesV2Ix(this.ctx.program, {
              ...collectFeesBaseParams,
              tokenMintA: tokenExtensionCtx.tokenMintWithProgramA.address,
              tokenMintB: tokenExtensionCtx.tokenMintWithProgramB.address,
              tokenProgramA: tokenExtensionCtx.tokenMintWithProgramA.tokenProgram,
              tokenProgramB: tokenExtensionCtx.tokenMintWithProgramB.tokenProgram,
              ...await token_extension_util_1.TokenExtensionUtil.getExtraAccountMetasForTransferHookForPool(this.ctx.connection, tokenExtensionCtx, collectFeesBaseParams.tokenVaultA, collectFeesBaseParams.tokenOwnerAccountA, collectFeesBaseParams.whirlpool, collectFeesBaseParams.tokenVaultB, collectFeesBaseParams.tokenOwnerAccountB, collectFeesBaseParams.whirlpool)
            });
            return [ix];
          });
        }
        if (shouldCollectRewards) {
          for (const { info, index: rewardIndex } of rewardsToCollect) {
            await builder.addInstructions(async (resolveTokenAccount) => {
              const rewardOwnerAccount = resolveTokenAccount(info.mint.toBase58());
              const collectRewardBaseParams = {
                whirlpool: positionData.whirlpool,
                position: positionAddress,
                positionAuthority: positionWallet,
                positionTokenAccount,
                rewardIndex,
                rewardOwnerAccount,
                rewardVault: info.vault
              };
              const ix = !token_extension_util_1.TokenExtensionUtil.isV2IxRequiredReward(tokenExtensionCtx, rewardIndex) ? ix_1.WhirlpoolIx.collectRewardIx(this.ctx.program, collectRewardBaseParams) : ix_1.WhirlpoolIx.collectRewardV2Ix(this.ctx.program, {
                ...collectRewardBaseParams,
                rewardMint: tokenExtensionCtx.rewardTokenMintsWithProgram[rewardIndex].address,
                rewardTokenProgram: tokenExtensionCtx.rewardTokenMintsWithProgram[rewardIndex].tokenProgram,
                rewardTransferHookAccounts: await token_extension_util_1.TokenExtensionUtil.getExtraAccountMetasForTransferHook(this.ctx.connection, tokenExtensionCtx.rewardTokenMintsWithProgram[rewardIndex], collectRewardBaseParams.rewardVault, collectRewardBaseParams.rewardOwnerAccount, collectRewardBaseParams.whirlpool)
              });
              return [ix];
            });
          }
        }
        await builder.addInstructions(async () => {
          const closePositionParams = {
            positionAuthority: positionWallet,
            receiver: destinationWallet,
            positionTokenAccount,
            position: positionAddress,
            positionMint: positionData.positionMint
          };
          if (positionMint.tokenProgram.equals(spl_token_1.TOKEN_2022_PROGRAM_ID)) {
            return [
              (0, instructions_1.closePositionWithTokenExtensionsIx)(this.ctx.program, closePositionParams)
            ];
          } else {
            return [(0, instructions_1.closePositionIx)(this.ctx.program, closePositionParams)];
          }
        });
        return builder.build();
      }
      async refresh() {
        const account = await this.ctx.fetcher.getPool(this.address, fetcher_1.IGNORE_CACHE);
        if (!!account) {
          const rewardInfos = await (0, util_1.getRewardInfos)(this.ctx.fetcher, account, fetcher_1.IGNORE_CACHE);
          const [tokenVaultAInfo, tokenVaultBInfo] = await (0, util_1.getTokenVaultAccountInfos)(this.ctx.fetcher, account, fetcher_1.IGNORE_CACHE);
          this.data = account;
          this.tokenVaultAInfo = tokenVaultAInfo;
          this.tokenVaultBInfo = tokenVaultBInfo;
          this.rewardInfos = rewardInfos;
        }
      }
    };
    exports2.WhirlpoolImpl = WhirlpoolImpl;
  }
});

// node_modules/@orca-so/whirlpools-sdk/dist/impl/whirlpool-client-impl.js
var require_whirlpool_client_impl = __commonJS({
  "node_modules/@orca-so/whirlpools-sdk/dist/impl/whirlpool-client-impl.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.WhirlpoolClientImpl = void 0;
    var common_sdk_1 = require_dist2();
    var web3_js_1 = require("@solana/web3.js");
    var tiny_invariant_1 = __importDefault(require_tiny_invariant_cjs());
    var instructions_1 = require_instructions9();
    var composites_1 = require_composites();
    var ix_1 = require_ix();
    var fetcher_1 = require_fetcher2();
    var public_1 = require_public6();
    var public_2 = require_public();
    var position_builder_util_1 = require_position_builder_util();
    var public_3 = require_public3();
    var position_impl_1 = require_position_impl();
    var util_1 = require_util();
    var whirlpool_impl_1 = require_whirlpool_impl();
    var token_extension_util_1 = require_token_extension_util();
    var decimal_js_1 = __importDefault(require_decimal());
    var WhirlpoolClientImpl = class {
      ctx;
      constructor(ctx) {
        this.ctx = ctx;
      }
      getContext() {
        return this.ctx;
      }
      getFetcher() {
        return this.ctx.fetcher;
      }
      getRouter(poolAddresses) {
        return public_1.WhirlpoolRouterBuilder.buildWithPools(this.ctx, poolAddresses);
      }
      async getPool(poolAddress, opts = fetcher_1.PREFER_CACHE) {
        const account = await this.ctx.fetcher.getPool(poolAddress, opts);
        if (!account) {
          throw new Error(`Unable to fetch Whirlpool at address at ${poolAddress}`);
        }
        const tokenInfos = await (0, util_1.getTokenMintInfos)(this.ctx.fetcher, account, opts);
        const vaultInfos = await (0, util_1.getTokenVaultAccountInfos)(this.ctx.fetcher, account, opts);
        const rewardInfos = await (0, util_1.getRewardInfos)(this.ctx.fetcher, account, opts);
        return new whirlpool_impl_1.WhirlpoolImpl(this.ctx, common_sdk_1.AddressUtil.toPubKey(poolAddress), tokenInfos[0], tokenInfos[1], vaultInfos[0], vaultInfos[1], rewardInfos, account);
      }
      async getPools(poolAddresses, opts = fetcher_1.PREFER_CACHE) {
        const accounts = Array.from((await this.ctx.fetcher.getPools(poolAddresses, opts)).values()).filter((account) => !!account);
        if (accounts.length !== poolAddresses.length) {
          throw new Error(`Unable to fetch all Whirlpools at addresses ${poolAddresses}`);
        }
        const tokenMints = /* @__PURE__ */ new Set();
        const tokenAccounts = /* @__PURE__ */ new Set();
        accounts.forEach((account) => {
          tokenMints.add(account.tokenMintA.toBase58());
          tokenMints.add(account.tokenMintB.toBase58());
          tokenAccounts.add(account.tokenVaultA.toBase58());
          tokenAccounts.add(account.tokenVaultB.toBase58());
          account.rewardInfos.forEach((rewardInfo) => {
            if (public_3.PoolUtil.isRewardInitialized(rewardInfo)) {
              tokenAccounts.add(rewardInfo.vault.toBase58());
            }
          });
        });
        await this.ctx.fetcher.getMintInfos(Array.from(tokenMints), opts);
        await this.ctx.fetcher.getTokenInfos(Array.from(tokenAccounts), opts);
        const whirlpools = [];
        for (let i = 0; i < accounts.length; i++) {
          const account = accounts[i];
          const poolAddress = poolAddresses[i];
          const tokenInfos = await (0, util_1.getTokenMintInfos)(this.ctx.fetcher, account, fetcher_1.PREFER_CACHE);
          const vaultInfos = await (0, util_1.getTokenVaultAccountInfos)(this.ctx.fetcher, account, fetcher_1.PREFER_CACHE);
          const rewardInfos = await (0, util_1.getRewardInfos)(this.ctx.fetcher, account, fetcher_1.PREFER_CACHE);
          whirlpools.push(new whirlpool_impl_1.WhirlpoolImpl(this.ctx, common_sdk_1.AddressUtil.toPubKey(poolAddress), tokenInfos[0], tokenInfos[1], vaultInfos[0], vaultInfos[1], rewardInfos, account));
        }
        return whirlpools;
      }
      async getPosition(positionAddress, opts = fetcher_1.PREFER_CACHE) {
        const account = await this.ctx.fetcher.getPosition(positionAddress, opts);
        if (!account) {
          throw new Error(`Unable to fetch Position at address at ${positionAddress}`);
        }
        const whirlAccount = await this.ctx.fetcher.getPool(account.whirlpool, opts);
        if (!whirlAccount) {
          throw new Error(`Unable to fetch Whirlpool for Position at address at ${positionAddress}`);
        }
        const positionMint = await this.ctx.fetcher.getMintInfo(account.positionMint, opts);
        if (!positionMint) {
          throw new Error(`Unable to fetch Mint for Position at address at ${positionAddress}`);
        }
        const [lowerTickArray, upperTickArray] = await (0, position_builder_util_1.getTickArrayDataForPosition)(this.ctx, account, whirlAccount, opts);
        if (!lowerTickArray || !upperTickArray) {
          throw new Error(`Unable to fetch TickArrays for Position at address at ${positionAddress}`);
        }
        return new position_impl_1.PositionImpl(this.ctx, common_sdk_1.AddressUtil.toPubKey(positionAddress), account, whirlAccount, lowerTickArray, upperTickArray, positionMint.tokenProgram);
      }
      async getPositions(positionAddresses, opts = fetcher_1.PREFER_CACHE) {
        const positions = Array.from((await this.ctx.fetcher.getPositions(positionAddresses, opts)).values());
        const whirlpoolAddrs = positions.map((position) => position?.whirlpool.toBase58()).flatMap((x) => !!x ? x : []);
        await this.ctx.fetcher.getPools(whirlpoolAddrs, opts);
        const positionMintAddrs = positions.map((position) => position?.positionMint.toBase58()).flatMap((x) => !!x ? x : []);
        await this.ctx.fetcher.getMintInfos(positionMintAddrs, opts);
        const tickArrayAddresses = /* @__PURE__ */ new Set();
        await Promise.all(positions.map(async (pos) => {
          if (pos) {
            const pool = await this.ctx.fetcher.getPool(pos.whirlpool, fetcher_1.PREFER_CACHE);
            if (pool) {
              const lowerTickArrayPda = public_3.PDAUtil.getTickArrayFromTickIndex(pos.tickLowerIndex, pool.tickSpacing, pos.whirlpool, this.ctx.program.programId).publicKey;
              const upperTickArrayPda = public_3.PDAUtil.getTickArrayFromTickIndex(pos.tickUpperIndex, pool.tickSpacing, pos.whirlpool, this.ctx.program.programId).publicKey;
              tickArrayAddresses.add(lowerTickArrayPda.toBase58());
              tickArrayAddresses.add(upperTickArrayPda.toBase58());
            }
          }
        }));
        await this.ctx.fetcher.getTickArrays(Array.from(tickArrayAddresses), fetcher_1.IGNORE_CACHE);
        const results = await Promise.all(positionAddresses.map(async (pos) => {
          try {
            const position = await this.getPosition(pos, fetcher_1.PREFER_CACHE);
            return [pos, position];
          } catch {
            return [pos, null];
          }
        }));
        return Object.fromEntries(results);
      }
      async createSplashPool(whirlpoolsConfig, tokenMintA, tokenMintB, initialPrice = new decimal_js_1.default(1), funder, opts = fetcher_1.PREFER_CACHE) {
        const correctTokenOrder = public_3.PoolUtil.orderMints(tokenMintA, tokenMintB).map((addr) => addr.toString());
        (0, tiny_invariant_1.default)(correctTokenOrder[0] === tokenMintA.toString(), "Token order needs to be flipped to match the canonical ordering (i.e. sorted on the byte repr. of the mint pubkeys)");
        const mintInfos = await this.getFetcher().getMintInfos([tokenMintA, tokenMintB], opts);
        (0, tiny_invariant_1.default)(mintInfos.size === 2, "At least one of the token mints cannot be found.");
        const tokenExtensionCtx = {
          ...token_extension_util_1.NO_TOKEN_EXTENSION_CONTEXT,
          tokenMintWithProgramA: mintInfos.get(tokenMintA.toString()),
          tokenMintWithProgramB: mintInfos.get(tokenMintB.toString())
        };
        whirlpoolsConfig = common_sdk_1.AddressUtil.toPubKey(whirlpoolsConfig);
        const feeTierKey = public_3.PDAUtil.getFeeTier(this.ctx.program.programId, whirlpoolsConfig, public_2.SPLASH_POOL_TICK_SPACING).publicKey;
        const whirlpoolPda = public_3.PDAUtil.getWhirlpool(this.ctx.program.programId, whirlpoolsConfig, new web3_js_1.PublicKey(tokenMintA), new web3_js_1.PublicKey(tokenMintB), public_2.SPLASH_POOL_TICK_SPACING);
        const tokenDecimalsA = mintInfos.get(tokenMintA.toString())?.decimals ?? 0;
        const tokenDecimalsB = mintInfos.get(tokenMintB.toString())?.decimals ?? 0;
        const initSqrtPrice = public_3.PriceMath.priceToSqrtPriceX64(initialPrice, tokenDecimalsA, tokenDecimalsB);
        const tokenVaultAKeypair = web3_js_1.Keypair.generate();
        const tokenVaultBKeypair = web3_js_1.Keypair.generate();
        const txBuilder = new common_sdk_1.TransactionBuilder(this.ctx.provider.connection, this.ctx.provider.wallet, this.ctx.txBuilderOpts);
        const tokenBadgeA = public_3.PDAUtil.getTokenBadge(this.ctx.program.programId, whirlpoolsConfig, common_sdk_1.AddressUtil.toPubKey(tokenMintA)).publicKey;
        const tokenBadgeB = public_3.PDAUtil.getTokenBadge(this.ctx.program.programId, whirlpoolsConfig, common_sdk_1.AddressUtil.toPubKey(tokenMintB)).publicKey;
        const baseParams = {
          initSqrtPrice,
          whirlpoolsConfig,
          whirlpoolPda,
          tokenMintA: new web3_js_1.PublicKey(tokenMintA),
          tokenMintB: new web3_js_1.PublicKey(tokenMintB),
          tokenVaultAKeypair,
          tokenVaultBKeypair,
          feeTierKey,
          tickSpacing: public_2.SPLASH_POOL_TICK_SPACING,
          funder: new web3_js_1.PublicKey(funder)
        };
        const initPoolIx = !token_extension_util_1.TokenExtensionUtil.isV2IxRequiredPool(tokenExtensionCtx) ? ix_1.WhirlpoolIx.initializePoolIx(this.ctx.program, baseParams) : ix_1.WhirlpoolIx.initializePoolV2Ix(this.ctx.program, {
          ...baseParams,
          tokenProgramA: tokenExtensionCtx.tokenMintWithProgramA.tokenProgram,
          tokenProgramB: tokenExtensionCtx.tokenMintWithProgramB.tokenProgram,
          tokenBadgeA,
          tokenBadgeB
        });
        txBuilder.addInstruction(initPoolIx);
        const [startTickIndex, endTickIndex] = public_3.TickUtil.getFullRangeTickIndex(public_2.SPLASH_POOL_TICK_SPACING);
        const startInitializableTickIndex = public_3.TickUtil.getStartTickIndex(startTickIndex, public_2.SPLASH_POOL_TICK_SPACING);
        const endInitializableTickIndex = public_3.TickUtil.getStartTickIndex(endTickIndex, public_2.SPLASH_POOL_TICK_SPACING);
        const startTickArrayPda = public_3.PDAUtil.getTickArray(this.ctx.program.programId, whirlpoolPda.publicKey, startInitializableTickIndex);
        const endTickArrayPda = public_3.PDAUtil.getTickArray(this.ctx.program.programId, whirlpoolPda.publicKey, endInitializableTickIndex);
        txBuilder.addInstruction((0, instructions_1.initTickArrayIx)(this.ctx.program, {
          startTick: startInitializableTickIndex,
          tickArrayPda: startTickArrayPda,
          whirlpool: whirlpoolPda.publicKey,
          funder: common_sdk_1.AddressUtil.toPubKey(funder)
        }));
        txBuilder.addInstruction((0, instructions_1.initTickArrayIx)(this.ctx.program, {
          startTick: endInitializableTickIndex,
          tickArrayPda: endTickArrayPda,
          whirlpool: whirlpoolPda.publicKey,
          funder: common_sdk_1.AddressUtil.toPubKey(funder)
        }));
        return {
          poolKey: whirlpoolPda.publicKey,
          tx: txBuilder
        };
      }
      async createPool(whirlpoolsConfig, tokenMintA, tokenMintB, tickSpacing, initialTick, funder, opts = fetcher_1.PREFER_CACHE) {
        (0, tiny_invariant_1.default)(public_3.TickUtil.checkTickInBounds(initialTick), "initialTick is out of bounds.");
        const correctTokenOrder = public_3.PoolUtil.orderMints(tokenMintA, tokenMintB).map((addr) => addr.toString());
        (0, tiny_invariant_1.default)(correctTokenOrder[0] === tokenMintA.toString(), "Token order needs to be flipped to match the canonical ordering (i.e. sorted on the byte repr. of the mint pubkeys)");
        const mintInfos = await this.ctx.fetcher.getMintInfos([tokenMintA, tokenMintB], opts);
        const tokenExtensionCtx = {
          ...token_extension_util_1.NO_TOKEN_EXTENSION_CONTEXT,
          tokenMintWithProgramA: mintInfos.get(tokenMintA.toString()),
          tokenMintWithProgramB: mintInfos.get(tokenMintB.toString())
        };
        whirlpoolsConfig = common_sdk_1.AddressUtil.toPubKey(whirlpoolsConfig);
        const feeTierKey = public_3.PDAUtil.getFeeTier(this.ctx.program.programId, whirlpoolsConfig, tickSpacing).publicKey;
        const initSqrtPrice = public_3.PriceMath.tickIndexToSqrtPriceX64(initialTick);
        const tokenVaultAKeypair = web3_js_1.Keypair.generate();
        const tokenVaultBKeypair = web3_js_1.Keypair.generate();
        const whirlpoolPda = public_3.PDAUtil.getWhirlpool(this.ctx.program.programId, whirlpoolsConfig, new web3_js_1.PublicKey(tokenMintA), new web3_js_1.PublicKey(tokenMintB), tickSpacing);
        const feeTier = await this.ctx.fetcher.getFeeTier(feeTierKey, opts);
        (0, tiny_invariant_1.default)(!!feeTier, `Fee tier for ${tickSpacing} doesn't exist`);
        const txBuilder = new common_sdk_1.TransactionBuilder(this.ctx.provider.connection, this.ctx.provider.wallet, this.ctx.txBuilderOpts);
        const tokenBadgeA = public_3.PDAUtil.getTokenBadge(this.ctx.program.programId, whirlpoolsConfig, common_sdk_1.AddressUtil.toPubKey(tokenMintA)).publicKey;
        const tokenBadgeB = public_3.PDAUtil.getTokenBadge(this.ctx.program.programId, whirlpoolsConfig, common_sdk_1.AddressUtil.toPubKey(tokenMintB)).publicKey;
        const baseParams = {
          initSqrtPrice,
          whirlpoolsConfig,
          whirlpoolPda,
          tokenMintA: new web3_js_1.PublicKey(tokenMintA),
          tokenMintB: new web3_js_1.PublicKey(tokenMintB),
          tokenVaultAKeypair,
          tokenVaultBKeypair,
          feeTierKey,
          tickSpacing,
          funder: new web3_js_1.PublicKey(funder)
        };
        const initPoolIx = !token_extension_util_1.TokenExtensionUtil.isV2IxRequiredPool(tokenExtensionCtx) ? ix_1.WhirlpoolIx.initializePoolIx(this.ctx.program, baseParams) : ix_1.WhirlpoolIx.initializePoolV2Ix(this.ctx.program, {
          ...baseParams,
          tokenProgramA: tokenExtensionCtx.tokenMintWithProgramA.tokenProgram,
          tokenProgramB: tokenExtensionCtx.tokenMintWithProgramB.tokenProgram,
          tokenBadgeA,
          tokenBadgeB
        });
        const initialTickArrayStartTick = public_3.TickUtil.getStartTickIndex(initialTick, tickSpacing);
        const initialTickArrayPda = public_3.PDAUtil.getTickArray(this.ctx.program.programId, whirlpoolPda.publicKey, initialTickArrayStartTick);
        txBuilder.addInstruction(initPoolIx);
        txBuilder.addInstruction((0, instructions_1.initTickArrayIx)(this.ctx.program, {
          startTick: initialTickArrayStartTick,
          tickArrayPda: initialTickArrayPda,
          whirlpool: whirlpoolPda.publicKey,
          funder: common_sdk_1.AddressUtil.toPubKey(funder)
        }));
        return {
          poolKey: whirlpoolPda.publicKey,
          tx: txBuilder
        };
      }
      async collectFeesAndRewardsForPositions(positionAddresses, opts) {
        const walletKey = this.ctx.wallet.publicKey;
        return (0, composites_1.collectAllForPositionAddressesTxns)(this.ctx, {
          positions: positionAddresses,
          receiver: walletKey,
          positionAuthority: walletKey,
          positionOwner: walletKey,
          payer: walletKey
        }, opts);
      }
      async collectProtocolFeesForPools(poolAddresses) {
        return (0, composites_1.collectProtocolFees)(this.ctx, poolAddresses);
      }
    };
    exports2.WhirlpoolClientImpl = WhirlpoolClientImpl;
  }
});

// node_modules/@orca-so/whirlpools-sdk/dist/whirlpool-client.js
var require_whirlpool_client = __commonJS({
  "node_modules/@orca-so/whirlpools-sdk/dist/whirlpool-client.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.buildWhirlpoolClient = buildWhirlpoolClient2;
    var whirlpool_client_impl_1 = require_whirlpool_client_impl();
    function buildWhirlpoolClient2(ctx) {
      return new whirlpool_client_impl_1.WhirlpoolClientImpl(ctx);
    }
  }
});

// node_modules/@orca-so/whirlpools-sdk/dist/index.js
var require_dist3 = __commonJS({
  "node_modules/@orca-so/whirlpools-sdk/dist/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var decimal_js_1 = __importDefault(require_decimal());
    __exportStar(require_context(), exports2);
    __exportStar(require_position_impl(), exports2);
    __exportStar(require_ix(), exports2);
    __exportStar(require_public4(), exports2);
    __exportStar(require_prices(), exports2);
    __exportStar(require_public5(), exports2);
    __exportStar(require_public6(), exports2);
    __exportStar(require_public(), exports2);
    __exportStar(require_anchor_types(), exports2);
    __exportStar(require_public3(), exports2);
    __exportStar(require_whirlpool_client(), exports2);
    decimal_js_1.default.set({ precision: 40, toExpPos: 40, toExpNeg: -20, rounding: 1 });
  }
});

// node_modules/base-x/src/index.js
var require_src = __commonJS({
  "node_modules/base-x/src/index.js"(exports2, module2) {
    "use strict";
    function base(ALPHABET) {
      if (ALPHABET.length >= 255) {
        throw new TypeError("Alphabet too long");
      }
      var BASE_MAP = new Uint8Array(256);
      for (var j = 0; j < BASE_MAP.length; j++) {
        BASE_MAP[j] = 255;
      }
      for (var i = 0; i < ALPHABET.length; i++) {
        var x = ALPHABET.charAt(i);
        var xc = x.charCodeAt(0);
        if (BASE_MAP[xc] !== 255) {
          throw new TypeError(x + " is ambiguous");
        }
        BASE_MAP[xc] = i;
      }
      var BASE3 = ALPHABET.length;
      var LEADER = ALPHABET.charAt(0);
      var FACTOR = Math.log(BASE3) / Math.log(256);
      var iFACTOR = Math.log(256) / Math.log(BASE3);
      function encode(source) {
        if (source instanceof Uint8Array) {
        } else if (ArrayBuffer.isView(source)) {
          source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
        } else if (Array.isArray(source)) {
          source = Uint8Array.from(source);
        }
        if (!(source instanceof Uint8Array)) {
          throw new TypeError("Expected Uint8Array");
        }
        if (source.length === 0) {
          return "";
        }
        var zeroes = 0;
        var length = 0;
        var pbegin = 0;
        var pend = source.length;
        while (pbegin !== pend && source[pbegin] === 0) {
          pbegin++;
          zeroes++;
        }
        var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
        var b58 = new Uint8Array(size);
        while (pbegin !== pend) {
          var carry = source[pbegin];
          var i2 = 0;
          for (var it1 = size - 1; (carry !== 0 || i2 < length) && it1 !== -1; it1--, i2++) {
            carry += 256 * b58[it1] >>> 0;
            b58[it1] = carry % BASE3 >>> 0;
            carry = carry / BASE3 >>> 0;
          }
          if (carry !== 0) {
            throw new Error("Non-zero carry");
          }
          length = i2;
          pbegin++;
        }
        var it2 = size - length;
        while (it2 !== size && b58[it2] === 0) {
          it2++;
        }
        var str = LEADER.repeat(zeroes);
        for (; it2 < size; ++it2) {
          str += ALPHABET.charAt(b58[it2]);
        }
        return str;
      }
      function decodeUnsafe(source) {
        if (typeof source !== "string") {
          throw new TypeError("Expected String");
        }
        if (source.length === 0) {
          return new Uint8Array();
        }
        var psz = 0;
        var zeroes = 0;
        var length = 0;
        while (source[psz] === LEADER) {
          zeroes++;
          psz++;
        }
        var size = (source.length - psz) * FACTOR + 1 >>> 0;
        var b256 = new Uint8Array(size);
        while (source[psz]) {
          var charCode = source.charCodeAt(psz);
          if (charCode > 255) {
            return;
          }
          var carry = BASE_MAP[charCode];
          if (carry === 255) {
            return;
          }
          var i2 = 0;
          for (var it3 = size - 1; (carry !== 0 || i2 < length) && it3 !== -1; it3--, i2++) {
            carry += BASE3 * b256[it3] >>> 0;
            b256[it3] = carry % 256 >>> 0;
            carry = carry / 256 >>> 0;
          }
          if (carry !== 0) {
            throw new Error("Non-zero carry");
          }
          length = i2;
          psz++;
        }
        var it4 = size - length;
        while (it4 !== size && b256[it4] === 0) {
          it4++;
        }
        var vch = new Uint8Array(zeroes + (size - it4));
        var j2 = zeroes;
        while (it4 !== size) {
          vch[j2++] = b256[it4++];
        }
        return vch;
      }
      function decode(string) {
        var buffer = decodeUnsafe(string);
        if (buffer) {
          return buffer;
        }
        throw new Error("Non-base" + BASE3 + " character");
      }
      return {
        encode,
        decodeUnsafe,
        decode
      };
    }
    module2.exports = base;
  }
});

// node_modules/bs58/index.js
var require_bs58 = __commonJS({
  "node_modules/bs58/index.js"(exports2, module2) {
    var basex = require_src();
    var ALPHABET = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
    module2.exports = basex(ALPHABET);
  }
});

// execution_engine.ts
var import_web321 = require("@solana/web3.js");

// node_modules/@meteora-ag/dlmm/dist/index.mjs
var import_anchor = require("@coral-xyz/anchor");

// node_modules/@meteora-ag/dlmm/node_modules/@solana/spl-token/lib/esm/constants.js
var import_web3 = require("@solana/web3.js");
var TOKEN_PROGRAM_ID = new import_web3.PublicKey("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA");
var TOKEN_2022_PROGRAM_ID = new import_web3.PublicKey("TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb");
var ASSOCIATED_TOKEN_PROGRAM_ID = new import_web3.PublicKey("ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL");
var NATIVE_MINT = new import_web3.PublicKey("So11111111111111111111111111111111111111112");
var NATIVE_MINT_2022 = new import_web3.PublicKey("9pan9bMn5HatX4EJdBwg9VgCa7Uz5HL8N1m5D3NdXejP");

// node_modules/@solana/buffer-layout-utils/lib/esm/base.mjs
var encodeDecode = (layout) => {
  const decode = layout.decode.bind(layout);
  const encode = layout.encode.bind(layout);
  return { decode, encode };
};

// node_modules/@solana/buffer-layout-utils/lib/esm/bigint.mjs
var import_buffer_layout = __toESM(require_Layout(), 1);
var import_bigint_buffer = __toESM(require_node(), 1);
var bigInt = (length) => (property) => {
  const layout = (0, import_buffer_layout.blob)(length, property);
  const { encode, decode } = encodeDecode(layout);
  const bigIntLayout = layout;
  bigIntLayout.decode = (buffer, offset) => {
    const src = decode(buffer, offset);
    return (0, import_bigint_buffer.toBigIntLE)(Buffer.from(src));
  };
  bigIntLayout.encode = (bigInt2, buffer, offset) => {
    const src = (0, import_bigint_buffer.toBufferLE)(bigInt2, length);
    return encode(src, buffer, offset);
  };
  return bigIntLayout;
};
var bigIntBE = (length) => (property) => {
  const layout = (0, import_buffer_layout.blob)(length, property);
  const { encode, decode } = encodeDecode(layout);
  const bigIntLayout = layout;
  bigIntLayout.decode = (buffer, offset) => {
    const src = decode(buffer, offset);
    return (0, import_bigint_buffer.toBigIntBE)(Buffer.from(src));
  };
  bigIntLayout.encode = (bigInt2, buffer, offset) => {
    const src = (0, import_bigint_buffer.toBufferBE)(bigInt2, length);
    return encode(src, buffer, offset);
  };
  return bigIntLayout;
};
var u64 = bigInt(8);
var u64be = bigIntBE(8);
var u128 = bigInt(16);
var u128be = bigIntBE(16);
var u192 = bigInt(24);
var u192be = bigIntBE(24);
var u256 = bigInt(32);
var u256be = bigIntBE(32);

// node_modules/bignumber.js/bignumber.mjs
var isNumeric = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i;
var mathceil = Math.ceil;
var mathfloor = Math.floor;
var bignumberError = "[BigNumber Error] ";
var tooManyDigits = bignumberError + "Number primitive has more than 15 significant digits: ";
var BASE = 1e14;
var LOG_BASE = 14;
var MAX_SAFE_INTEGER = 9007199254740991;
var POWS_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13];
var SQRT_BASE = 1e7;
var MAX = 1e9;
function clone(configObject) {
  var div2, convertBase2, parseNumeric, P2 = BigNumber2.prototype = { constructor: BigNumber2, toString: null, valueOf: null }, ONE2 = new BigNumber2(1), DECIMAL_PLACES = 20, ROUNDING_MODE = 4, TO_EXP_NEG = -7, TO_EXP_POS = 21, MIN_EXP = -1e7, MAX_EXP = 1e7, CRYPTO = false, MODULO_MODE = 1, POW_PRECISION = 0, FORMAT = {
    prefix: "",
    groupSize: 3,
    secondaryGroupSize: 0,
    groupSeparator: ",",
    decimalSeparator: ".",
    fractionGroupSize: 0,
    fractionGroupSeparator: "\xA0",
    // non-breaking space
    suffix: ""
  }, ALPHABET = "0123456789abcdefghijklmnopqrstuvwxyz", alphabetHasNormalDecimalDigits = true;
  function BigNumber2(v, b) {
    var alphabet, c, caseChanged, e, i, isNum, len, str, x = this;
    if (!(x instanceof BigNumber2))
      return new BigNumber2(v, b);
    if (b == null) {
      if (v && v._isBigNumber === true) {
        x.s = v.s;
        if (!v.c || v.e > MAX_EXP) {
          x.c = x.e = null;
        } else if (v.e < MIN_EXP) {
          x.c = [x.e = 0];
        } else {
          x.e = v.e;
          x.c = v.c.slice();
        }
        return;
      }
      if ((isNum = typeof v == "number") && v * 0 == 0) {
        x.s = 1 / v < 0 ? (v = -v, -1) : 1;
        if (v === ~~v) {
          for (e = 0, i = v; i >= 10; i /= 10, e++)
            ;
          if (e > MAX_EXP) {
            x.c = x.e = null;
          } else {
            x.e = e;
            x.c = [v];
          }
          return;
        }
        str = String(v);
      } else {
        if (!isNumeric.test(str = String(v)))
          return parseNumeric(x, str, isNum);
        x.s = str.charCodeAt(0) == 45 ? (str = str.slice(1), -1) : 1;
      }
      if ((e = str.indexOf(".")) > -1)
        str = str.replace(".", "");
      if ((i = str.search(/e/i)) > 0) {
        if (e < 0)
          e = i;
        e += +str.slice(i + 1);
        str = str.substring(0, i);
      } else if (e < 0) {
        e = str.length;
      }
    } else {
      intCheck(b, 2, ALPHABET.length, "Base");
      if (b == 10 && alphabetHasNormalDecimalDigits) {
        x = new BigNumber2(v);
        return round2(x, DECIMAL_PLACES + x.e + 1, ROUNDING_MODE);
      }
      str = String(v);
      if (isNum = typeof v == "number") {
        if (v * 0 != 0)
          return parseNumeric(x, str, isNum, b);
        x.s = 1 / v < 0 ? (str = str.slice(1), -1) : 1;
        if (BigNumber2.DEBUG && str.replace(/^0\.0*|\./, "").length > 15) {
          throw Error(tooManyDigits + v);
        }
      } else {
        x.s = str.charCodeAt(0) === 45 ? (str = str.slice(1), -1) : 1;
      }
      alphabet = ALPHABET.slice(0, b);
      e = i = 0;
      for (len = str.length; i < len; i++) {
        if (alphabet.indexOf(c = str.charAt(i)) < 0) {
          if (c == ".") {
            if (i > e) {
              e = len;
              continue;
            }
          } else if (!caseChanged) {
            if (str == str.toUpperCase() && (str = str.toLowerCase()) || str == str.toLowerCase() && (str = str.toUpperCase())) {
              caseChanged = true;
              i = -1;
              e = 0;
              continue;
            }
          }
          return parseNumeric(x, String(v), isNum, b);
        }
      }
      isNum = false;
      str = convertBase2(str, b, 10, x.s);
      if ((e = str.indexOf(".")) > -1)
        str = str.replace(".", "");
      else
        e = str.length;
    }
    for (i = 0; str.charCodeAt(i) === 48; i++)
      ;
    for (len = str.length; str.charCodeAt(--len) === 48; )
      ;
    if (str = str.slice(i, ++len)) {
      len -= i;
      if (isNum && BigNumber2.DEBUG && len > 15 && (v > MAX_SAFE_INTEGER || v !== mathfloor(v))) {
        throw Error(tooManyDigits + x.s * v);
      }
      if ((e = e - i - 1) > MAX_EXP) {
        x.c = x.e = null;
      } else if (e < MIN_EXP) {
        x.c = [x.e = 0];
      } else {
        x.e = e;
        x.c = [];
        i = (e + 1) % LOG_BASE;
        if (e < 0)
          i += LOG_BASE;
        if (i < len) {
          if (i)
            x.c.push(+str.slice(0, i));
          for (len -= LOG_BASE; i < len; ) {
            x.c.push(+str.slice(i, i += LOG_BASE));
          }
          i = LOG_BASE - (str = str.slice(i)).length;
        } else {
          i -= len;
        }
        for (; i--; str += "0")
          ;
        x.c.push(+str);
      }
    } else {
      x.c = [x.e = 0];
    }
  }
  BigNumber2.clone = clone;
  BigNumber2.ROUND_UP = 0;
  BigNumber2.ROUND_DOWN = 1;
  BigNumber2.ROUND_CEIL = 2;
  BigNumber2.ROUND_FLOOR = 3;
  BigNumber2.ROUND_HALF_UP = 4;
  BigNumber2.ROUND_HALF_DOWN = 5;
  BigNumber2.ROUND_HALF_EVEN = 6;
  BigNumber2.ROUND_HALF_CEIL = 7;
  BigNumber2.ROUND_HALF_FLOOR = 8;
  BigNumber2.EUCLID = 9;
  BigNumber2.config = BigNumber2.set = function(obj) {
    var p, v;
    if (obj != null) {
      if (typeof obj == "object") {
        if (obj.hasOwnProperty(p = "DECIMAL_PLACES")) {
          v = obj[p];
          intCheck(v, 0, MAX, p);
          DECIMAL_PLACES = v;
        }
        if (obj.hasOwnProperty(p = "ROUNDING_MODE")) {
          v = obj[p];
          intCheck(v, 0, 8, p);
          ROUNDING_MODE = v;
        }
        if (obj.hasOwnProperty(p = "EXPONENTIAL_AT")) {
          v = obj[p];
          if (v && v.pop) {
            intCheck(v[0], -MAX, 0, p);
            intCheck(v[1], 0, MAX, p);
            TO_EXP_NEG = v[0];
            TO_EXP_POS = v[1];
          } else {
            intCheck(v, -MAX, MAX, p);
            TO_EXP_NEG = -(TO_EXP_POS = v < 0 ? -v : v);
          }
        }
        if (obj.hasOwnProperty(p = "RANGE")) {
          v = obj[p];
          if (v && v.pop) {
            intCheck(v[0], -MAX, -1, p);
            intCheck(v[1], 1, MAX, p);
            MIN_EXP = v[0];
            MAX_EXP = v[1];
          } else {
            intCheck(v, -MAX, MAX, p);
            if (v) {
              MIN_EXP = -(MAX_EXP = v < 0 ? -v : v);
            } else {
              throw Error(bignumberError + p + " cannot be zero: " + v);
            }
          }
        }
        if (obj.hasOwnProperty(p = "CRYPTO")) {
          v = obj[p];
          if (v === !!v) {
            if (v) {
              if (typeof crypto != "undefined" && crypto && (crypto.getRandomValues || crypto.randomBytes)) {
                CRYPTO = v;
              } else {
                CRYPTO = !v;
                throw Error(bignumberError + "crypto unavailable");
              }
            } else {
              CRYPTO = v;
            }
          } else {
            throw Error(bignumberError + p + " not true or false: " + v);
          }
        }
        if (obj.hasOwnProperty(p = "MODULO_MODE")) {
          v = obj[p];
          intCheck(v, 0, 9, p);
          MODULO_MODE = v;
        }
        if (obj.hasOwnProperty(p = "POW_PRECISION")) {
          v = obj[p];
          intCheck(v, 0, MAX, p);
          POW_PRECISION = v;
        }
        if (obj.hasOwnProperty(p = "FORMAT")) {
          v = obj[p];
          if (typeof v == "object")
            FORMAT = v;
          else
            throw Error(bignumberError + p + " not an object: " + v);
        }
        if (obj.hasOwnProperty(p = "ALPHABET")) {
          v = obj[p];
          if (typeof v == "string" && !/^.?$|[+\-.\s]|(.).*\1/.test(v)) {
            alphabetHasNormalDecimalDigits = v.slice(0, 10) == "0123456789";
            ALPHABET = v;
          } else {
            throw Error(bignumberError + p + " invalid: " + v);
          }
        }
      } else {
        throw Error(bignumberError + "Object expected: " + obj);
      }
    }
    return {
      DECIMAL_PLACES,
      ROUNDING_MODE,
      EXPONENTIAL_AT: [TO_EXP_NEG, TO_EXP_POS],
      RANGE: [MIN_EXP, MAX_EXP],
      CRYPTO,
      MODULO_MODE,
      POW_PRECISION,
      FORMAT,
      ALPHABET
    };
  };
  BigNumber2.isBigNumber = function(v) {
    if (!v || v._isBigNumber !== true)
      return false;
    if (!BigNumber2.DEBUG)
      return true;
    var i, n, c = v.c, e = v.e, s = v.s;
    out:
      if ({}.toString.call(c) == "[object Array]") {
        if ((s === 1 || s === -1) && e >= -MAX && e <= MAX && e === mathfloor(e)) {
          if (c[0] === 0) {
            if (e === 0 && c.length === 1)
              return true;
            break out;
          }
          i = (e + 1) % LOG_BASE;
          if (i < 1)
            i += LOG_BASE;
          if (String(c[0]).length == i) {
            for (i = 0; i < c.length; i++) {
              n = c[i];
              if (n < 0 || n >= BASE || n !== mathfloor(n))
                break out;
            }
            if (n !== 0)
              return true;
          }
        }
      } else if (c === null && e === null && (s === null || s === 1 || s === -1)) {
        return true;
      }
    throw Error(bignumberError + "Invalid BigNumber: " + v);
  };
  BigNumber2.maximum = BigNumber2.max = function() {
    return maxOrMin2(arguments, -1);
  };
  BigNumber2.minimum = BigNumber2.min = function() {
    return maxOrMin2(arguments, 1);
  };
  BigNumber2.random = function() {
    var pow2_53 = 9007199254740992;
    var random53bitInt = Math.random() * pow2_53 & 2097151 ? function() {
      return mathfloor(Math.random() * pow2_53);
    } : function() {
      return (Math.random() * 1073741824 | 0) * 8388608 + (Math.random() * 8388608 | 0);
    };
    return function(dp) {
      var a, b, e, k, v, i = 0, c = [], rand = new BigNumber2(ONE2);
      if (dp == null)
        dp = DECIMAL_PLACES;
      else
        intCheck(dp, 0, MAX);
      k = mathceil(dp / LOG_BASE);
      if (CRYPTO) {
        if (crypto.getRandomValues) {
          a = crypto.getRandomValues(new Uint32Array(k *= 2));
          for (; i < k; ) {
            v = a[i] * 131072 + (a[i + 1] >>> 11);
            if (v >= 9e15) {
              b = crypto.getRandomValues(new Uint32Array(2));
              a[i] = b[0];
              a[i + 1] = b[1];
            } else {
              c.push(v % 1e14);
              i += 2;
            }
          }
          i = k / 2;
        } else if (crypto.randomBytes) {
          a = crypto.randomBytes(k *= 7);
          for (; i < k; ) {
            v = (a[i] & 31) * 281474976710656 + a[i + 1] * 1099511627776 + a[i + 2] * 4294967296 + a[i + 3] * 16777216 + (a[i + 4] << 16) + (a[i + 5] << 8) + a[i + 6];
            if (v >= 9e15) {
              crypto.randomBytes(7).copy(a, i);
            } else {
              c.push(v % 1e14);
              i += 7;
            }
          }
          i = k / 7;
        } else {
          CRYPTO = false;
          throw Error(bignumberError + "crypto unavailable");
        }
      }
      if (!CRYPTO) {
        for (; i < k; ) {
          v = random53bitInt();
          if (v < 9e15)
            c[i++] = v % 1e14;
        }
      }
      k = c[--i];
      dp %= LOG_BASE;
      if (k && dp) {
        v = POWS_TEN[LOG_BASE - dp];
        c[i] = mathfloor(k / v) * v;
      }
      for (; c[i] === 0; c.pop(), i--)
        ;
      if (i < 0) {
        c = [e = 0];
      } else {
        for (e = -1; c[0] === 0; c.splice(0, 1), e -= LOG_BASE)
          ;
        for (i = 1, v = c[0]; v >= 10; v /= 10, i++)
          ;
        if (i < LOG_BASE)
          e -= LOG_BASE - i;
      }
      rand.e = e;
      rand.c = c;
      return rand;
    };
  }();
  BigNumber2.sum = function() {
    var i = 1, args = arguments, sum2 = new BigNumber2(args[0]);
    for (; i < args.length; )
      sum2 = sum2.plus(args[i++]);
    return sum2;
  };
  convertBase2 = /* @__PURE__ */ function() {
    var decimal = "0123456789";
    function toBaseOut(str, baseIn, baseOut, alphabet) {
      var j, arr = [0], arrL, i = 0, len = str.length;
      for (; i < len; ) {
        for (arrL = arr.length; arrL--; arr[arrL] *= baseIn)
          ;
        arr[0] += alphabet.indexOf(str.charAt(i++));
        for (j = 0; j < arr.length; j++) {
          if (arr[j] > baseOut - 1) {
            if (arr[j + 1] == null)
              arr[j + 1] = 0;
            arr[j + 1] += arr[j] / baseOut | 0;
            arr[j] %= baseOut;
          }
        }
      }
      return arr.reverse();
    }
    return function(str, baseIn, baseOut, sign2, callerIsToString) {
      var alphabet, d, e, k, r, x, xc, y, i = str.indexOf("."), dp = DECIMAL_PLACES, rm = ROUNDING_MODE;
      if (i >= 0) {
        k = POW_PRECISION;
        POW_PRECISION = 0;
        str = str.replace(".", "");
        y = new BigNumber2(baseIn);
        x = y.pow(str.length - i);
        POW_PRECISION = k;
        y.c = toBaseOut(
          toFixedPoint(coeffToString(x.c), x.e, "0"),
          10,
          baseOut,
          decimal
        );
        y.e = y.c.length;
      }
      xc = toBaseOut(str, baseIn, baseOut, callerIsToString ? (alphabet = ALPHABET, decimal) : (alphabet = decimal, ALPHABET));
      e = k = xc.length;
      for (; xc[--k] == 0; xc.pop())
        ;
      if (!xc[0])
        return alphabet.charAt(0);
      if (i < 0) {
        --e;
      } else {
        x.c = xc;
        x.e = e;
        x.s = sign2;
        x = div2(x, y, dp, rm, baseOut);
        xc = x.c;
        r = x.r;
        e = x.e;
      }
      d = e + dp + 1;
      i = xc[d];
      k = baseOut / 2;
      r = r || d < 0 || xc[d + 1] != null;
      r = rm < 4 ? (i != null || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : i > k || i == k && (rm == 4 || r || rm == 6 && xc[d - 1] & 1 || rm == (x.s < 0 ? 8 : 7));
      if (d < 1 || !xc[0]) {
        str = r ? toFixedPoint(alphabet.charAt(1), -dp, alphabet.charAt(0)) : alphabet.charAt(0);
      } else {
        xc.length = d;
        if (r) {
          for (--baseOut; ++xc[--d] > baseOut; ) {
            xc[d] = 0;
            if (!d) {
              ++e;
              xc = [1].concat(xc);
            }
          }
        }
        for (k = xc.length; !xc[--k]; )
          ;
        for (i = 0, str = ""; i <= k; str += alphabet.charAt(xc[i++]))
          ;
        str = toFixedPoint(str, e, alphabet.charAt(0));
      }
      return str;
    };
  }();
  div2 = /* @__PURE__ */ function() {
    function multiply(x, k, base) {
      var m, temp, xlo, xhi, carry = 0, i = x.length, klo = k % SQRT_BASE, khi = k / SQRT_BASE | 0;
      for (x = x.slice(); i--; ) {
        xlo = x[i] % SQRT_BASE;
        xhi = x[i] / SQRT_BASE | 0;
        m = khi * xlo + xhi * klo;
        temp = klo * xlo + m % SQRT_BASE * SQRT_BASE + carry;
        carry = (temp / base | 0) + (m / SQRT_BASE | 0) + khi * xhi;
        x[i] = temp % base;
      }
      if (carry)
        x = [carry].concat(x);
      return x;
    }
    function compare2(a, b, aL, bL) {
      var i, cmp;
      if (aL != bL) {
        cmp = aL > bL ? 1 : -1;
      } else {
        for (i = cmp = 0; i < aL; i++) {
          if (a[i] != b[i]) {
            cmp = a[i] > b[i] ? 1 : -1;
            break;
          }
        }
      }
      return cmp;
    }
    function subtract(a, b, aL, base) {
      var i = 0;
      for (; aL--; ) {
        a[aL] -= i;
        i = a[aL] < b[aL] ? 1 : 0;
        a[aL] = i * base + a[aL] - b[aL];
      }
      for (; !a[0] && a.length > 1; a.splice(0, 1))
        ;
    }
    return function(x, y, dp, rm, base) {
      var cmp, e, i, more, n, prod, prodL, q, qc, rem, remL, rem0, xi, xL, yc0, yL, yz, s = x.s == y.s ? 1 : -1, xc = x.c, yc = y.c;
      if (!xc || !xc[0] || !yc || !yc[0]) {
        return new BigNumber2(
          // Return NaN if either NaN, or both Infinity or 0.
          !x.s || !y.s || (xc ? yc && xc[0] == yc[0] : !yc) ? NaN : (
            // Return 0 if x is 0 or y is Infinity, or return Infinity as y is 0.
            xc && xc[0] == 0 || !yc ? s * 0 : s / 0
          )
        );
      }
      q = new BigNumber2(s);
      qc = q.c = [];
      e = x.e - y.e;
      s = dp + e + 1;
      if (!base) {
        base = BASE;
        e = bitFloor(x.e / LOG_BASE) - bitFloor(y.e / LOG_BASE);
        s = s / LOG_BASE | 0;
      }
      for (i = 0; yc[i] == (xc[i] || 0); i++)
        ;
      if (yc[i] > (xc[i] || 0))
        e--;
      if (s < 0) {
        qc.push(1);
        more = true;
      } else {
        xL = xc.length;
        yL = yc.length;
        i = 0;
        s += 2;
        n = mathfloor(base / (yc[0] + 1));
        if (n > 1) {
          yc = multiply(yc, n, base);
          xc = multiply(xc, n, base);
          yL = yc.length;
          xL = xc.length;
        }
        xi = yL;
        rem = xc.slice(0, yL);
        remL = rem.length;
        for (; remL < yL; rem[remL++] = 0)
          ;
        yz = yc.slice();
        yz = [0].concat(yz);
        yc0 = yc[0];
        if (yc[1] >= base / 2)
          yc0++;
        do {
          n = 0;
          cmp = compare2(yc, rem, yL, remL);
          if (cmp < 0) {
            rem0 = rem[0];
            if (yL != remL)
              rem0 = rem0 * base + (rem[1] || 0);
            n = mathfloor(rem0 / yc0);
            if (n > 1) {
              if (n >= base)
                n = base - 1;
              prod = multiply(yc, n, base);
              prodL = prod.length;
              remL = rem.length;
              while (compare2(prod, rem, prodL, remL) == 1) {
                n--;
                subtract(prod, yL < prodL ? yz : yc, prodL, base);
                prodL = prod.length;
                cmp = 1;
              }
            } else {
              if (n == 0) {
                cmp = n = 1;
              }
              prod = yc.slice();
              prodL = prod.length;
            }
            if (prodL < remL)
              prod = [0].concat(prod);
            subtract(rem, prod, remL, base);
            remL = rem.length;
            if (cmp == -1) {
              while (compare2(yc, rem, yL, remL) < 1) {
                n++;
                subtract(rem, yL < remL ? yz : yc, remL, base);
                remL = rem.length;
              }
            }
          } else if (cmp === 0) {
            n++;
            rem = [0];
          }
          qc[i++] = n;
          if (rem[0]) {
            rem[remL++] = xc[xi] || 0;
          } else {
            rem = [xc[xi]];
            remL = 1;
          }
        } while ((xi++ < xL || rem[0] != null) && s--);
        more = rem[0] != null;
        if (!qc[0])
          qc.splice(0, 1);
      }
      if (base == BASE) {
        for (i = 1, s = qc[0]; s >= 10; s /= 10, i++)
          ;
        round2(q, dp + (q.e = i + e * LOG_BASE - 1) + 1, rm, more);
      } else {
        q.e = e;
        q.r = +more;
      }
      return q;
    };
  }();
  function format(n, i, rm, id) {
    var c0, e, ne, len, str;
    if (rm == null)
      rm = ROUNDING_MODE;
    else
      intCheck(rm, 0, 8);
    if (!n.c)
      return n.toString();
    c0 = n.c[0];
    ne = n.e;
    if (i == null) {
      str = coeffToString(n.c);
      str = id == 1 || id == 2 && (ne <= TO_EXP_NEG || ne >= TO_EXP_POS) ? toExponential(str, ne) : toFixedPoint(str, ne, "0");
    } else {
      n = round2(new BigNumber2(n), i, rm);
      e = n.e;
      str = coeffToString(n.c);
      len = str.length;
      if (id == 1 || id == 2 && (i <= e || e <= TO_EXP_NEG)) {
        for (; len < i; str += "0", len++)
          ;
        str = toExponential(str, e);
      } else {
        i -= ne + (id === 2 && e > ne);
        str = toFixedPoint(str, e, "0");
        if (e + 1 > len) {
          if (--i > 0)
            for (str += "."; i--; str += "0")
              ;
        } else {
          i += e - len;
          if (i > 0) {
            if (e + 1 == len)
              str += ".";
            for (; i--; str += "0")
              ;
          }
        }
      }
    }
    return n.s < 0 && c0 ? "-" + str : str;
  }
  function maxOrMin2(args, n) {
    var k, y, i = 1, x = new BigNumber2(args[0]);
    for (; i < args.length; i++) {
      y = new BigNumber2(args[i]);
      if (!y.s || (k = compare(x, y)) === n || k === 0 && x.s === n) {
        x = y;
      }
    }
    return x;
  }
  function normalise(n, c, e) {
    var i = 1, j = c.length;
    for (; !c[--j]; c.pop())
      ;
    for (j = c[0]; j >= 10; j /= 10, i++)
      ;
    if ((e = i + e * LOG_BASE - 1) > MAX_EXP) {
      n.c = n.e = null;
    } else if (e < MIN_EXP) {
      n.c = [n.e = 0];
    } else {
      n.e = e;
      n.c = c;
    }
    return n;
  }
  parseNumeric = /* @__PURE__ */ function() {
    var basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i, dotAfter = /^([^.]+)\.$/, dotBefore = /^\.([^.]+)$/, isInfinityOrNaN = /^-?(Infinity|NaN)$/, whitespaceOrPlus = /^\s*\+(?=[\w.])|^\s+|\s+$/g;
    return function(x, str, isNum, b) {
      var base, s = isNum ? str : str.replace(whitespaceOrPlus, "");
      if (isInfinityOrNaN.test(s)) {
        x.s = isNaN(s) ? null : s < 0 ? -1 : 1;
      } else {
        if (!isNum) {
          s = s.replace(basePrefix, function(m, p1, p2) {
            base = (p2 = p2.toLowerCase()) == "x" ? 16 : p2 == "b" ? 2 : 8;
            return !b || b == base ? p1 : m;
          });
          if (b) {
            base = b;
            s = s.replace(dotAfter, "$1").replace(dotBefore, "0.$1");
          }
          if (str != s)
            return new BigNumber2(s, base);
        }
        if (BigNumber2.DEBUG) {
          throw Error(bignumberError + "Not a" + (b ? " base " + b : "") + " number: " + str);
        }
        x.s = null;
      }
      x.c = x.e = null;
    };
  }();
  function round2(x, sd, rm, r) {
    var d, i, j, k, n, ni, rd, xc = x.c, pows10 = POWS_TEN;
    if (xc) {
      out: {
        for (d = 1, k = xc[0]; k >= 10; k /= 10, d++)
          ;
        i = sd - d;
        if (i < 0) {
          i += LOG_BASE;
          j = sd;
          n = xc[ni = 0];
          rd = mathfloor(n / pows10[d - j - 1] % 10);
        } else {
          ni = mathceil((i + 1) / LOG_BASE);
          if (ni >= xc.length) {
            if (r) {
              for (; xc.length <= ni; xc.push(0))
                ;
              n = rd = 0;
              d = 1;
              i %= LOG_BASE;
              j = i - LOG_BASE + 1;
            } else {
              break out;
            }
          } else {
            n = k = xc[ni];
            for (d = 1; k >= 10; k /= 10, d++)
              ;
            i %= LOG_BASE;
            j = i - LOG_BASE + d;
            rd = j < 0 ? 0 : mathfloor(n / pows10[d - j - 1] % 10);
          }
        }
        r = r || sd < 0 || // Are there any non-zero digits after the rounding digit?
        // The expression  n % pows10[d - j - 1]  returns all digits of n to the right
        // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.
        xc[ni + 1] != null || (j < 0 ? n : n % pows10[d - j - 1]);
        r = rm < 4 ? (rd || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : rd > 5 || rd == 5 && (rm == 4 || r || rm == 6 && // Check whether the digit to the left of the rounding digit is odd.
        (i > 0 ? j > 0 ? n / pows10[d - j] : 0 : xc[ni - 1]) % 10 & 1 || rm == (x.s < 0 ? 8 : 7));
        if (sd < 1 || !xc[0]) {
          xc.length = 0;
          if (r) {
            sd -= x.e + 1;
            xc[0] = pows10[(LOG_BASE - sd % LOG_BASE) % LOG_BASE];
            x.e = -sd || 0;
          } else {
            xc[0] = x.e = 0;
          }
          return x;
        }
        if (i == 0) {
          xc.length = ni;
          k = 1;
          ni--;
        } else {
          xc.length = ni + 1;
          k = pows10[LOG_BASE - i];
          xc[ni] = j > 0 ? mathfloor(n / pows10[d - j] % pows10[j]) * k : 0;
        }
        if (r) {
          for (; ; ) {
            if (ni == 0) {
              for (i = 1, j = xc[0]; j >= 10; j /= 10, i++)
                ;
              j = xc[0] += k;
              for (k = 1; j >= 10; j /= 10, k++)
                ;
              if (i != k) {
                x.e++;
                if (xc[0] == BASE)
                  xc[0] = 1;
              }
              break;
            } else {
              xc[ni] += k;
              if (xc[ni] != BASE)
                break;
              xc[ni--] = 0;
              k = 1;
            }
          }
        }
        for (i = xc.length; xc[--i] === 0; xc.pop())
          ;
      }
      if (x.e > MAX_EXP) {
        x.c = x.e = null;
      } else if (x.e < MIN_EXP) {
        x.c = [x.e = 0];
      }
    }
    return x;
  }
  function valueOf(n) {
    var str, e = n.e;
    if (e === null)
      return n.toString();
    str = coeffToString(n.c);
    str = e <= TO_EXP_NEG || e >= TO_EXP_POS ? toExponential(str, e) : toFixedPoint(str, e, "0");
    return n.s < 0 ? "-" + str : str;
  }
  P2.absoluteValue = P2.abs = function() {
    var x = new BigNumber2(this);
    if (x.s < 0)
      x.s = 1;
    return x;
  };
  P2.comparedTo = function(y, b) {
    return compare(this, new BigNumber2(y, b));
  };
  P2.decimalPlaces = P2.dp = function(dp, rm) {
    var c, n, v, x = this;
    if (dp != null) {
      intCheck(dp, 0, MAX);
      if (rm == null)
        rm = ROUNDING_MODE;
      else
        intCheck(rm, 0, 8);
      return round2(new BigNumber2(x), dp + x.e + 1, rm);
    }
    if (!(c = x.c))
      return null;
    n = ((v = c.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE;
    if (v = c[v])
      for (; v % 10 == 0; v /= 10, n--)
        ;
    if (n < 0)
      n = 0;
    return n;
  };
  P2.dividedBy = P2.div = function(y, b) {
    return div2(this, new BigNumber2(y, b), DECIMAL_PLACES, ROUNDING_MODE);
  };
  P2.dividedToIntegerBy = P2.idiv = function(y, b) {
    return div2(this, new BigNumber2(y, b), 0, 1);
  };
  P2.exponentiatedBy = P2.pow = function(n, m) {
    var half, isModExp, i, k, more, nIsBig, nIsNeg, nIsOdd, y, x = this;
    n = new BigNumber2(n);
    if (n.c && !n.isInteger()) {
      throw Error(bignumberError + "Exponent not an integer: " + valueOf(n));
    }
    if (m != null)
      m = new BigNumber2(m);
    nIsBig = n.e > 14;
    if (!x.c || !x.c[0] || x.c[0] == 1 && !x.e && x.c.length == 1 || !n.c || !n.c[0]) {
      y = new BigNumber2(Math.pow(+valueOf(x), nIsBig ? n.s * (2 - isOdd(n)) : +valueOf(n)));
      return m ? y.mod(m) : y;
    }
    nIsNeg = n.s < 0;
    if (m) {
      if (m.c ? !m.c[0] : !m.s)
        return new BigNumber2(NaN);
      isModExp = !nIsNeg && x.isInteger() && m.isInteger();
      if (isModExp)
        x = x.mod(m);
    } else if (n.e > 9 && (x.e > 0 || x.e < -1 || (x.e == 0 ? x.c[0] > 1 || nIsBig && x.c[1] >= 24e7 : x.c[0] < 8e13 || nIsBig && x.c[0] <= 9999975e7))) {
      k = x.s < 0 && isOdd(n) ? -0 : 0;
      if (x.e > -1)
        k = 1 / k;
      return new BigNumber2(nIsNeg ? 1 / k : k);
    } else if (POW_PRECISION) {
      k = mathceil(POW_PRECISION / LOG_BASE + 2);
    }
    if (nIsBig) {
      half = new BigNumber2(0.5);
      if (nIsNeg)
        n.s = 1;
      nIsOdd = isOdd(n);
    } else {
      i = Math.abs(+valueOf(n));
      nIsOdd = i % 2;
    }
    y = new BigNumber2(ONE2);
    for (; ; ) {
      if (nIsOdd) {
        y = y.times(x);
        if (!y.c)
          break;
        if (k) {
          if (y.c.length > k)
            y.c.length = k;
        } else if (isModExp) {
          y = y.mod(m);
        }
      }
      if (i) {
        i = mathfloor(i / 2);
        if (i === 0)
          break;
        nIsOdd = i % 2;
      } else {
        n = n.times(half);
        round2(n, n.e + 1, 1);
        if (n.e > 14) {
          nIsOdd = isOdd(n);
        } else {
          i = +valueOf(n);
          if (i === 0)
            break;
          nIsOdd = i % 2;
        }
      }
      x = x.times(x);
      if (k) {
        if (x.c && x.c.length > k)
          x.c.length = k;
      } else if (isModExp) {
        x = x.mod(m);
      }
    }
    if (isModExp)
      return y;
    if (nIsNeg)
      y = ONE2.div(y);
    return m ? y.mod(m) : k ? round2(y, POW_PRECISION, ROUNDING_MODE, more) : y;
  };
  P2.integerValue = function(rm) {
    var n = new BigNumber2(this);
    if (rm == null)
      rm = ROUNDING_MODE;
    else
      intCheck(rm, 0, 8);
    return round2(n, n.e + 1, rm);
  };
  P2.isEqualTo = P2.eq = function(y, b) {
    return compare(this, new BigNumber2(y, b)) === 0;
  };
  P2.isFinite = function() {
    return !!this.c;
  };
  P2.isGreaterThan = P2.gt = function(y, b) {
    return compare(this, new BigNumber2(y, b)) > 0;
  };
  P2.isGreaterThanOrEqualTo = P2.gte = function(y, b) {
    return (b = compare(this, new BigNumber2(y, b))) === 1 || b === 0;
  };
  P2.isInteger = function() {
    return !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2;
  };
  P2.isLessThan = P2.lt = function(y, b) {
    return compare(this, new BigNumber2(y, b)) < 0;
  };
  P2.isLessThanOrEqualTo = P2.lte = function(y, b) {
    return (b = compare(this, new BigNumber2(y, b))) === -1 || b === 0;
  };
  P2.isNaN = function() {
    return !this.s;
  };
  P2.isNegative = function() {
    return this.s < 0;
  };
  P2.isPositive = function() {
    return this.s > 0;
  };
  P2.isZero = function() {
    return !!this.c && this.c[0] == 0;
  };
  P2.minus = function(y, b) {
    var i, j, t, xLTy, x = this, a = x.s;
    y = new BigNumber2(y, b);
    b = y.s;
    if (!a || !b)
      return new BigNumber2(NaN);
    if (a != b) {
      y.s = -b;
      return x.plus(y);
    }
    var xe = x.e / LOG_BASE, ye = y.e / LOG_BASE, xc = x.c, yc = y.c;
    if (!xe || !ye) {
      if (!xc || !yc)
        return xc ? (y.s = -b, y) : new BigNumber2(yc ? x : NaN);
      if (!xc[0] || !yc[0]) {
        return yc[0] ? (y.s = -b, y) : new BigNumber2(xc[0] ? x : (
          // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity
          ROUNDING_MODE == 3 ? -0 : 0
        ));
      }
    }
    xe = bitFloor(xe);
    ye = bitFloor(ye);
    xc = xc.slice();
    if (a = xe - ye) {
      if (xLTy = a < 0) {
        a = -a;
        t = xc;
      } else {
        ye = xe;
        t = yc;
      }
      t.reverse();
      for (b = a; b--; t.push(0))
        ;
      t.reverse();
    } else {
      j = (xLTy = (a = xc.length) < (b = yc.length)) ? a : b;
      for (a = b = 0; b < j; b++) {
        if (xc[b] != yc[b]) {
          xLTy = xc[b] < yc[b];
          break;
        }
      }
    }
    if (xLTy) {
      t = xc;
      xc = yc;
      yc = t;
      y.s = -y.s;
    }
    b = (j = yc.length) - (i = xc.length);
    if (b > 0)
      for (; b--; xc[i++] = 0)
        ;
    b = BASE - 1;
    for (; j > a; ) {
      if (xc[--j] < yc[j]) {
        for (i = j; i && !xc[--i]; xc[i] = b)
          ;
        --xc[i];
        xc[j] += BASE;
      }
      xc[j] -= yc[j];
    }
    for (; xc[0] == 0; xc.splice(0, 1), --ye)
      ;
    if (!xc[0]) {
      y.s = ROUNDING_MODE == 3 ? -1 : 1;
      y.c = [y.e = 0];
      return y;
    }
    return normalise(y, xc, ye);
  };
  P2.modulo = P2.mod = function(y, b) {
    var q, s, x = this;
    y = new BigNumber2(y, b);
    if (!x.c || !y.s || y.c && !y.c[0]) {
      return new BigNumber2(NaN);
    } else if (!y.c || x.c && !x.c[0]) {
      return new BigNumber2(x);
    }
    if (MODULO_MODE == 9) {
      s = y.s;
      y.s = 1;
      q = div2(x, y, 0, 3);
      y.s = s;
      q.s *= s;
    } else {
      q = div2(x, y, 0, MODULO_MODE);
    }
    y = x.minus(q.times(y));
    if (!y.c[0] && MODULO_MODE == 1)
      y.s = x.s;
    return y;
  };
  P2.multipliedBy = P2.times = function(y, b) {
    var c, e, i, j, k, m, xcL, xlo, xhi, ycL, ylo, yhi, zc, base, sqrtBase, x = this, xc = x.c, yc = (y = new BigNumber2(y, b)).c;
    if (!xc || !yc || !xc[0] || !yc[0]) {
      if (!x.s || !y.s || xc && !xc[0] && !yc || yc && !yc[0] && !xc) {
        y.c = y.e = y.s = null;
      } else {
        y.s *= x.s;
        if (!xc || !yc) {
          y.c = y.e = null;
        } else {
          y.c = [0];
          y.e = 0;
        }
      }
      return y;
    }
    e = bitFloor(x.e / LOG_BASE) + bitFloor(y.e / LOG_BASE);
    y.s *= x.s;
    xcL = xc.length;
    ycL = yc.length;
    if (xcL < ycL) {
      zc = xc;
      xc = yc;
      yc = zc;
      i = xcL;
      xcL = ycL;
      ycL = i;
    }
    for (i = xcL + ycL, zc = []; i--; zc.push(0))
      ;
    base = BASE;
    sqrtBase = SQRT_BASE;
    for (i = ycL; --i >= 0; ) {
      c = 0;
      ylo = yc[i] % sqrtBase;
      yhi = yc[i] / sqrtBase | 0;
      for (k = xcL, j = i + k; j > i; ) {
        xlo = xc[--k] % sqrtBase;
        xhi = xc[k] / sqrtBase | 0;
        m = yhi * xlo + xhi * ylo;
        xlo = ylo * xlo + m % sqrtBase * sqrtBase + zc[j] + c;
        c = (xlo / base | 0) + (m / sqrtBase | 0) + yhi * xhi;
        zc[j--] = xlo % base;
      }
      zc[j] = c;
    }
    if (c) {
      ++e;
    } else {
      zc.splice(0, 1);
    }
    return normalise(y, zc, e);
  };
  P2.negated = function() {
    var x = new BigNumber2(this);
    x.s = -x.s || null;
    return x;
  };
  P2.plus = function(y, b) {
    var t, x = this, a = x.s;
    y = new BigNumber2(y, b);
    b = y.s;
    if (!a || !b)
      return new BigNumber2(NaN);
    if (a != b) {
      y.s = -b;
      return x.minus(y);
    }
    var xe = x.e / LOG_BASE, ye = y.e / LOG_BASE, xc = x.c, yc = y.c;
    if (!xe || !ye) {
      if (!xc || !yc)
        return new BigNumber2(a / 0);
      if (!xc[0] || !yc[0])
        return yc[0] ? y : new BigNumber2(xc[0] ? x : a * 0);
    }
    xe = bitFloor(xe);
    ye = bitFloor(ye);
    xc = xc.slice();
    if (a = xe - ye) {
      if (a > 0) {
        ye = xe;
        t = yc;
      } else {
        a = -a;
        t = xc;
      }
      t.reverse();
      for (; a--; t.push(0))
        ;
      t.reverse();
    }
    a = xc.length;
    b = yc.length;
    if (a - b < 0) {
      t = yc;
      yc = xc;
      xc = t;
      b = a;
    }
    for (a = 0; b; ) {
      a = (xc[--b] = xc[b] + yc[b] + a) / BASE | 0;
      xc[b] = BASE === xc[b] ? 0 : xc[b] % BASE;
    }
    if (a) {
      xc = [a].concat(xc);
      ++ye;
    }
    return normalise(y, xc, ye);
  };
  P2.precision = P2.sd = function(sd, rm) {
    var c, n, v, x = this;
    if (sd != null && sd !== !!sd) {
      intCheck(sd, 1, MAX);
      if (rm == null)
        rm = ROUNDING_MODE;
      else
        intCheck(rm, 0, 8);
      return round2(new BigNumber2(x), sd, rm);
    }
    if (!(c = x.c))
      return null;
    v = c.length - 1;
    n = v * LOG_BASE + 1;
    if (v = c[v]) {
      for (; v % 10 == 0; v /= 10, n--)
        ;
      for (v = c[0]; v >= 10; v /= 10, n++)
        ;
    }
    if (sd && x.e + 1 > n)
      n = x.e + 1;
    return n;
  };
  P2.shiftedBy = function(k) {
    intCheck(k, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER);
    return this.times("1e" + k);
  };
  P2.squareRoot = P2.sqrt = function() {
    var m, n, r, rep, t, x = this, c = x.c, s = x.s, e = x.e, dp = DECIMAL_PLACES + 4, half = new BigNumber2("0.5");
    if (s !== 1 || !c || !c[0]) {
      return new BigNumber2(!s || s < 0 && (!c || c[0]) ? NaN : c ? x : 1 / 0);
    }
    s = Math.sqrt(+valueOf(x));
    if (s == 0 || s == 1 / 0) {
      n = coeffToString(c);
      if ((n.length + e) % 2 == 0)
        n += "0";
      s = Math.sqrt(+n);
      e = bitFloor((e + 1) / 2) - (e < 0 || e % 2);
      if (s == 1 / 0) {
        n = "5e" + e;
      } else {
        n = s.toExponential();
        n = n.slice(0, n.indexOf("e") + 1) + e;
      }
      r = new BigNumber2(n);
    } else {
      r = new BigNumber2(s + "");
    }
    if (r.c[0]) {
      e = r.e;
      s = e + dp;
      if (s < 3)
        s = 0;
      for (; ; ) {
        t = r;
        r = half.times(t.plus(div2(x, t, dp, 1)));
        if (coeffToString(t.c).slice(0, s) === (n = coeffToString(r.c)).slice(0, s)) {
          if (r.e < e)
            --s;
          n = n.slice(s - 3, s + 1);
          if (n == "9999" || !rep && n == "4999") {
            if (!rep) {
              round2(t, t.e + DECIMAL_PLACES + 2, 0);
              if (t.times(t).eq(x)) {
                r = t;
                break;
              }
            }
            dp += 4;
            s += 4;
            rep = 1;
          } else {
            if (!+n || !+n.slice(1) && n.charAt(0) == "5") {
              round2(r, r.e + DECIMAL_PLACES + 2, 1);
              m = !r.times(r).eq(x);
            }
            break;
          }
        }
      }
    }
    return round2(r, r.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m);
  };
  P2.toExponential = function(dp, rm) {
    if (dp != null) {
      intCheck(dp, 0, MAX);
      dp++;
    }
    return format(this, dp, rm, 1);
  };
  P2.toFixed = function(dp, rm) {
    if (dp != null) {
      intCheck(dp, 0, MAX);
      dp = dp + this.e + 1;
    }
    return format(this, dp, rm);
  };
  P2.toFormat = function(dp, rm, format2) {
    var str, x = this;
    if (format2 == null) {
      if (dp != null && rm && typeof rm == "object") {
        format2 = rm;
        rm = null;
      } else if (dp && typeof dp == "object") {
        format2 = dp;
        dp = rm = null;
      } else {
        format2 = FORMAT;
      }
    } else if (typeof format2 != "object") {
      throw Error(bignumberError + "Argument not an object: " + format2);
    }
    str = x.toFixed(dp, rm);
    if (x.c) {
      var i, arr = str.split("."), g1 = +format2.groupSize, g2 = +format2.secondaryGroupSize, groupSeparator = format2.groupSeparator || "", intPart = arr[0], fractionPart = arr[1], isNeg = x.s < 0, intDigits = isNeg ? intPart.slice(1) : intPart, len = intDigits.length;
      if (g2) {
        i = g1;
        g1 = g2;
        g2 = i;
        len -= i;
      }
      if (g1 > 0 && len > 0) {
        i = len % g1 || g1;
        intPart = intDigits.substr(0, i);
        for (; i < len; i += g1)
          intPart += groupSeparator + intDigits.substr(i, g1);
        if (g2 > 0)
          intPart += groupSeparator + intDigits.slice(i);
        if (isNeg)
          intPart = "-" + intPart;
      }
      str = fractionPart ? intPart + (format2.decimalSeparator || "") + ((g2 = +format2.fractionGroupSize) ? fractionPart.replace(
        new RegExp("\\d{" + g2 + "}\\B", "g"),
        "$&" + (format2.fractionGroupSeparator || "")
      ) : fractionPart) : intPart;
    }
    return (format2.prefix || "") + str + (format2.suffix || "");
  };
  P2.toFraction = function(md) {
    var d, d0, d1, d2, e, exp2, n, n0, n1, q, r, s, x = this, xc = x.c;
    if (md != null) {
      n = new BigNumber2(md);
      if (!n.isInteger() && (n.c || n.s !== 1) || n.lt(ONE2)) {
        throw Error(bignumberError + "Argument " + (n.isInteger() ? "out of range: " : "not an integer: ") + valueOf(n));
      }
    }
    if (!xc)
      return new BigNumber2(x);
    d = new BigNumber2(ONE2);
    n1 = d0 = new BigNumber2(ONE2);
    d1 = n0 = new BigNumber2(ONE2);
    s = coeffToString(xc);
    e = d.e = s.length - x.e - 1;
    d.c[0] = POWS_TEN[(exp2 = e % LOG_BASE) < 0 ? LOG_BASE + exp2 : exp2];
    md = !md || n.comparedTo(d) > 0 ? e > 0 ? d : n1 : n;
    exp2 = MAX_EXP;
    MAX_EXP = 1 / 0;
    n = new BigNumber2(s);
    n0.c[0] = 0;
    for (; ; ) {
      q = div2(n, d, 0, 1);
      d2 = d0.plus(q.times(d1));
      if (d2.comparedTo(md) == 1)
        break;
      d0 = d1;
      d1 = d2;
      n1 = n0.plus(q.times(d2 = n1));
      n0 = d2;
      d = n.minus(q.times(d2 = d));
      n = d2;
    }
    d2 = div2(md.minus(d0), d1, 0, 1);
    n0 = n0.plus(d2.times(n1));
    d0 = d0.plus(d2.times(d1));
    n0.s = n1.s = x.s;
    e = e * 2;
    r = div2(n1, d1, e, ROUNDING_MODE).minus(x).abs().comparedTo(
      div2(n0, d0, e, ROUNDING_MODE).minus(x).abs()
    ) < 1 ? [n1, d1] : [n0, d0];
    MAX_EXP = exp2;
    return r;
  };
  P2.toNumber = function() {
    return +valueOf(this);
  };
  P2.toPrecision = function(sd, rm) {
    if (sd != null)
      intCheck(sd, 1, MAX);
    return format(this, sd, rm, 2);
  };
  P2.toString = function(b) {
    var str, n = this, s = n.s, e = n.e;
    if (e === null) {
      if (s) {
        str = "Infinity";
        if (s < 0)
          str = "-" + str;
      } else {
        str = "NaN";
      }
    } else {
      if (b == null) {
        str = e <= TO_EXP_NEG || e >= TO_EXP_POS ? toExponential(coeffToString(n.c), e) : toFixedPoint(coeffToString(n.c), e, "0");
      } else if (b === 10 && alphabetHasNormalDecimalDigits) {
        n = round2(new BigNumber2(n), DECIMAL_PLACES + e + 1, ROUNDING_MODE);
        str = toFixedPoint(coeffToString(n.c), n.e, "0");
      } else {
        intCheck(b, 2, ALPHABET.length, "Base");
        str = convertBase2(toFixedPoint(coeffToString(n.c), e, "0"), 10, b, s, true);
      }
      if (s < 0 && n.c[0])
        str = "-" + str;
    }
    return str;
  };
  P2.valueOf = P2.toJSON = function() {
    return valueOf(this);
  };
  P2._isBigNumber = true;
  P2[Symbol.toStringTag] = "BigNumber";
  P2[Symbol.for("nodejs.util.inspect.custom")] = P2.valueOf;
  if (configObject != null)
    BigNumber2.set(configObject);
  return BigNumber2;
}
function bitFloor(n) {
  var i = n | 0;
  return n > 0 || n === i ? i : i - 1;
}
function coeffToString(a) {
  var s, z, i = 1, j = a.length, r = a[0] + "";
  for (; i < j; ) {
    s = a[i++] + "";
    z = LOG_BASE - s.length;
    for (; z--; s = "0" + s)
      ;
    r += s;
  }
  for (j = r.length; r.charCodeAt(--j) === 48; )
    ;
  return r.slice(0, j + 1 || 1);
}
function compare(x, y) {
  var a, b, xc = x.c, yc = y.c, i = x.s, j = y.s, k = x.e, l = y.e;
  if (!i || !j)
    return null;
  a = xc && !xc[0];
  b = yc && !yc[0];
  if (a || b)
    return a ? b ? 0 : -j : i;
  if (i != j)
    return i;
  a = i < 0;
  b = k == l;
  if (!xc || !yc)
    return b ? 0 : !xc ^ a ? 1 : -1;
  if (!b)
    return k > l ^ a ? 1 : -1;
  j = (k = xc.length) < (l = yc.length) ? k : l;
  for (i = 0; i < j; i++)
    if (xc[i] != yc[i])
      return xc[i] > yc[i] ^ a ? 1 : -1;
  return k == l ? 0 : k > l ^ a ? 1 : -1;
}
function intCheck(n, min2, max2, name) {
  if (n < min2 || n > max2 || n !== mathfloor(n)) {
    throw Error(bignumberError + (name || "Argument") + (typeof n == "number" ? n < min2 || n > max2 ? " out of range: " : " not an integer: " : " not a primitive number: ") + String(n));
  }
}
function isOdd(n) {
  var k = n.c.length - 1;
  return bitFloor(n.e / LOG_BASE) == k && n.c[k] % 2 != 0;
}
function toExponential(str, e) {
  return (str.length > 1 ? str.charAt(0) + "." + str.slice(1) : str) + (e < 0 ? "e" : "e+") + e;
}
function toFixedPoint(str, e, z) {
  var len, zs;
  if (e < 0) {
    for (zs = z + "."; ++e; zs += z)
      ;
    str = zs + str;
  } else {
    len = str.length;
    if (++e > len) {
      for (zs = z, e -= len; --e; zs += z)
        ;
      str += zs;
    } else if (e < len) {
      str = str.slice(0, e) + "." + str.slice(e);
    }
  }
  return str;
}
var BigNumber = clone();
var bignumber_default = BigNumber;

// node_modules/@solana/buffer-layout-utils/lib/esm/decimal.mjs
var WAD = new bignumber_default("1e+18");

// node_modules/@solana/buffer-layout-utils/lib/esm/native.mjs
var import_buffer_layout2 = __toESM(require_Layout(), 1);
var bool = (property) => {
  const layout = (0, import_buffer_layout2.u8)(property);
  const { encode, decode } = encodeDecode(layout);
  const boolLayout = layout;
  boolLayout.decode = (buffer, offset) => {
    const src = decode(buffer, offset);
    return !!src;
  };
  boolLayout.encode = (bool2, buffer, offset) => {
    const src = Number(bool2);
    return encode(src, buffer, offset);
  };
  return boolLayout;
};

// node_modules/@solana/buffer-layout-utils/lib/esm/web3.mjs
var import_buffer_layout3 = __toESM(require_Layout(), 1);
var import_web32 = require("@solana/web3.js");
var publicKey = (property) => {
  const layout = (0, import_buffer_layout3.blob)(32, property);
  const { encode, decode } = encodeDecode(layout);
  const publicKeyLayout = layout;
  publicKeyLayout.decode = (buffer, offset) => {
    const src = decode(buffer, offset);
    return new import_web32.PublicKey(src);
  };
  publicKeyLayout.encode = (publicKey2, buffer, offset) => {
    const src = publicKey2.toBuffer();
    return encode(src, buffer, offset);
  };
  return publicKeyLayout;
};

// node_modules/@meteora-ag/dlmm/node_modules/@solana/spl-token/lib/esm/errors.js
var TokenError = class extends Error {
  constructor(message) {
    super(message);
  }
};
var TokenAccountNotFoundError = class extends TokenError {
  constructor() {
    super(...arguments);
    this.name = "TokenAccountNotFoundError";
  }
};
var TokenInvalidAccountError = class extends TokenError {
  constructor() {
    super(...arguments);
    this.name = "TokenInvalidAccountError";
  }
};
var TokenInvalidAccountOwnerError = class extends TokenError {
  constructor() {
    super(...arguments);
    this.name = "TokenInvalidAccountOwnerError";
  }
};
var TokenInvalidAccountSizeError = class extends TokenError {
  constructor() {
    super(...arguments);
    this.name = "TokenInvalidAccountSizeError";
  }
};
var TokenInvalidMintError = class extends TokenError {
  constructor() {
    super(...arguments);
    this.name = "TokenInvalidMintError";
  }
};
var TokenOwnerOffCurveError = class extends TokenError {
  constructor() {
    super(...arguments);
    this.name = "TokenOwnerOffCurveError";
  }
};
var TokenTransferHookAccountNotFound = class extends TokenError {
  constructor() {
    super(...arguments);
    this.name = "TokenTransferHookAccountNotFound";
  }
};
var TokenTransferHookInvalidSeed = class extends TokenError {
  constructor() {
    super(...arguments);
    this.name = "TokenTransferHookInvalidSeed";
  }
};
var TokenTransferHookAccountDataNotFound = class extends TokenError {
  constructor() {
    super(...arguments);
    this.name = "TokenTransferHookAccountDataNotFound";
  }
};
var TokenTransferHookInvalidPubkeyData = class extends TokenError {
  constructor() {
    super(...arguments);
    this.name = "TokenTransferHookInvalidPubkeyData";
  }
};
var TokenTransferHookPubkeyDataTooSmall = class extends TokenError {
  constructor() {
    super(...arguments);
    this.name = "TokenTransferHookPubkeyDataTooSmall";
  }
};

// node_modules/@meteora-ag/dlmm/node_modules/@solana/spl-token/lib/esm/instructions/types.js
var TokenInstruction;
(function(TokenInstruction2) {
  TokenInstruction2[TokenInstruction2["InitializeMint"] = 0] = "InitializeMint";
  TokenInstruction2[TokenInstruction2["InitializeAccount"] = 1] = "InitializeAccount";
  TokenInstruction2[TokenInstruction2["InitializeMultisig"] = 2] = "InitializeMultisig";
  TokenInstruction2[TokenInstruction2["Transfer"] = 3] = "Transfer";
  TokenInstruction2[TokenInstruction2["Approve"] = 4] = "Approve";
  TokenInstruction2[TokenInstruction2["Revoke"] = 5] = "Revoke";
  TokenInstruction2[TokenInstruction2["SetAuthority"] = 6] = "SetAuthority";
  TokenInstruction2[TokenInstruction2["MintTo"] = 7] = "MintTo";
  TokenInstruction2[TokenInstruction2["Burn"] = 8] = "Burn";
  TokenInstruction2[TokenInstruction2["CloseAccount"] = 9] = "CloseAccount";
  TokenInstruction2[TokenInstruction2["FreezeAccount"] = 10] = "FreezeAccount";
  TokenInstruction2[TokenInstruction2["ThawAccount"] = 11] = "ThawAccount";
  TokenInstruction2[TokenInstruction2["TransferChecked"] = 12] = "TransferChecked";
  TokenInstruction2[TokenInstruction2["ApproveChecked"] = 13] = "ApproveChecked";
  TokenInstruction2[TokenInstruction2["MintToChecked"] = 14] = "MintToChecked";
  TokenInstruction2[TokenInstruction2["BurnChecked"] = 15] = "BurnChecked";
  TokenInstruction2[TokenInstruction2["InitializeAccount2"] = 16] = "InitializeAccount2";
  TokenInstruction2[TokenInstruction2["SyncNative"] = 17] = "SyncNative";
  TokenInstruction2[TokenInstruction2["InitializeAccount3"] = 18] = "InitializeAccount3";
  TokenInstruction2[TokenInstruction2["InitializeMultisig2"] = 19] = "InitializeMultisig2";
  TokenInstruction2[TokenInstruction2["InitializeMint2"] = 20] = "InitializeMint2";
  TokenInstruction2[TokenInstruction2["GetAccountDataSize"] = 21] = "GetAccountDataSize";
  TokenInstruction2[TokenInstruction2["InitializeImmutableOwner"] = 22] = "InitializeImmutableOwner";
  TokenInstruction2[TokenInstruction2["AmountToUiAmount"] = 23] = "AmountToUiAmount";
  TokenInstruction2[TokenInstruction2["UiAmountToAmount"] = 24] = "UiAmountToAmount";
  TokenInstruction2[TokenInstruction2["InitializeMintCloseAuthority"] = 25] = "InitializeMintCloseAuthority";
  TokenInstruction2[TokenInstruction2["TransferFeeExtension"] = 26] = "TransferFeeExtension";
  TokenInstruction2[TokenInstruction2["ConfidentialTransferExtension"] = 27] = "ConfidentialTransferExtension";
  TokenInstruction2[TokenInstruction2["DefaultAccountStateExtension"] = 28] = "DefaultAccountStateExtension";
  TokenInstruction2[TokenInstruction2["Reallocate"] = 29] = "Reallocate";
  TokenInstruction2[TokenInstruction2["MemoTransferExtension"] = 30] = "MemoTransferExtension";
  TokenInstruction2[TokenInstruction2["CreateNativeMint"] = 31] = "CreateNativeMint";
  TokenInstruction2[TokenInstruction2["InitializeNonTransferableMint"] = 32] = "InitializeNonTransferableMint";
  TokenInstruction2[TokenInstruction2["InterestBearingMintExtension"] = 33] = "InterestBearingMintExtension";
  TokenInstruction2[TokenInstruction2["CpiGuardExtension"] = 34] = "CpiGuardExtension";
  TokenInstruction2[TokenInstruction2["InitializePermanentDelegate"] = 35] = "InitializePermanentDelegate";
  TokenInstruction2[TokenInstruction2["TransferHookExtension"] = 36] = "TransferHookExtension";
  TokenInstruction2[TokenInstruction2["MetadataPointerExtension"] = 39] = "MetadataPointerExtension";
  TokenInstruction2[TokenInstruction2["GroupPointerExtension"] = 40] = "GroupPointerExtension";
  TokenInstruction2[TokenInstruction2["GroupMemberPointerExtension"] = 41] = "GroupMemberPointerExtension";
  TokenInstruction2[TokenInstruction2["ScaledUiAmountExtension"] = 43] = "ScaledUiAmountExtension";
  TokenInstruction2[TokenInstruction2["PausableExtension"] = 44] = "PausableExtension";
})(TokenInstruction || (TokenInstruction = {}));

// node_modules/@meteora-ag/dlmm/node_modules/@solana/spl-token/lib/esm/state/mint.js
var import_buffer_layout10 = __toESM(require_Layout(), 1);
var import_web38 = require("@solana/web3.js");

// node_modules/@meteora-ag/dlmm/node_modules/@solana/spl-token/lib/esm/extensions/accountType.js
var AccountType;
(function(AccountType2) {
  AccountType2[AccountType2["Uninitialized"] = 0] = "Uninitialized";
  AccountType2[AccountType2["Mint"] = 1] = "Mint";
  AccountType2[AccountType2["Account"] = 2] = "Account";
})(AccountType || (AccountType = {}));
var ACCOUNT_TYPE_SIZE = 1;

// node_modules/@meteora-ag/dlmm/node_modules/@solana/spl-token/lib/esm/state/account.js
var import_buffer_layout5 = __toESM(require_Layout(), 1);

// node_modules/@meteora-ag/dlmm/node_modules/@solana/spl-token/lib/esm/state/multisig.js
var import_buffer_layout4 = __toESM(require_Layout(), 1);
var MultisigLayout = (0, import_buffer_layout4.struct)([
  (0, import_buffer_layout4.u8)("m"),
  (0, import_buffer_layout4.u8)("n"),
  bool("isInitialized"),
  publicKey("signer1"),
  publicKey("signer2"),
  publicKey("signer3"),
  publicKey("signer4"),
  publicKey("signer5"),
  publicKey("signer6"),
  publicKey("signer7"),
  publicKey("signer8"),
  publicKey("signer9"),
  publicKey("signer10"),
  publicKey("signer11")
]);
var MULTISIG_SIZE = MultisigLayout.span;

// node_modules/@meteora-ag/dlmm/node_modules/@solana/spl-token/lib/esm/state/account.js
var AccountState;
(function(AccountState2) {
  AccountState2[AccountState2["Uninitialized"] = 0] = "Uninitialized";
  AccountState2[AccountState2["Initialized"] = 1] = "Initialized";
  AccountState2[AccountState2["Frozen"] = 2] = "Frozen";
})(AccountState || (AccountState = {}));
var AccountLayout = (0, import_buffer_layout5.struct)([
  publicKey("mint"),
  publicKey("owner"),
  u64("amount"),
  (0, import_buffer_layout5.u32)("delegateOption"),
  publicKey("delegate"),
  (0, import_buffer_layout5.u8)("state"),
  (0, import_buffer_layout5.u32)("isNativeOption"),
  u64("isNative"),
  u64("delegatedAmount"),
  (0, import_buffer_layout5.u32)("closeAuthorityOption"),
  publicKey("closeAuthority")
]);
var ACCOUNT_SIZE = AccountLayout.span;
async function getAccount(connection, address, commitment, programId = TOKEN_PROGRAM_ID) {
  const info = await connection.getAccountInfo(address, commitment);
  return unpackAccount(address, info, programId);
}
function unpackAccount(address, info, programId = TOKEN_PROGRAM_ID) {
  if (!info)
    throw new TokenAccountNotFoundError();
  if (!info.owner.equals(programId))
    throw new TokenInvalidAccountOwnerError();
  if (info.data.length < ACCOUNT_SIZE)
    throw new TokenInvalidAccountSizeError();
  const rawAccount = AccountLayout.decode(info.data.slice(0, ACCOUNT_SIZE));
  let tlvData = Buffer.alloc(0);
  if (info.data.length > ACCOUNT_SIZE) {
    if (info.data.length === MULTISIG_SIZE)
      throw new TokenInvalidAccountSizeError();
    if (info.data[ACCOUNT_SIZE] != AccountType.Account)
      throw new TokenInvalidAccountError();
    tlvData = info.data.slice(ACCOUNT_SIZE + ACCOUNT_TYPE_SIZE);
  }
  return {
    address,
    mint: rawAccount.mint,
    owner: rawAccount.owner,
    amount: rawAccount.amount,
    delegate: rawAccount.delegateOption ? rawAccount.delegate : null,
    delegatedAmount: rawAccount.delegatedAmount,
    isInitialized: rawAccount.state !== AccountState.Uninitialized,
    isFrozen: rawAccount.state === AccountState.Frozen,
    isNative: !!rawAccount.isNativeOption,
    rentExemptReserve: rawAccount.isNativeOption ? rawAccount.isNative : null,
    closeAuthority: rawAccount.closeAuthorityOption ? rawAccount.closeAuthority : null,
    tlvData
  };
}

// node_modules/@meteora-ag/dlmm/node_modules/@solana/spl-token/lib/esm/instructions/internal.js
var import_web33 = require("@solana/web3.js");
function addSigners(keys, ownerOrAuthority, multiSigners) {
  if (multiSigners.length) {
    keys.push({ pubkey: ownerOrAuthority, isSigner: false, isWritable: false });
    for (const signer of multiSigners) {
      keys.push({
        pubkey: signer instanceof import_web33.PublicKey ? signer : signer.publicKey,
        isSigner: true,
        isWritable: false
      });
    }
  } else {
    keys.push({ pubkey: ownerOrAuthority, isSigner: true, isWritable: false });
  }
  return keys;
}

// node_modules/@meteora-ag/dlmm/node_modules/@solana/spl-token/lib/esm/extensions/transferFee/state.js
var import_buffer_layout6 = __toESM(require_Layout(), 1);
var MAX_FEE_BASIS_POINTS = 1e4;
var ONE_IN_BASIS_POINTS = BigInt(MAX_FEE_BASIS_POINTS);
function transferFeeLayout(property) {
  return (0, import_buffer_layout6.struct)([u64("epoch"), u64("maximumFee"), (0, import_buffer_layout6.u16)("transferFeeBasisPoints")], property);
}
function calculateFee(transferFee, preFeeAmount) {
  const transferFeeBasisPoints = transferFee.transferFeeBasisPoints;
  if (transferFeeBasisPoints === 0 || preFeeAmount === BigInt(0)) {
    return BigInt(0);
  } else {
    const numerator = preFeeAmount * BigInt(transferFeeBasisPoints);
    const rawFee = (numerator + ONE_IN_BASIS_POINTS - BigInt(1)) / ONE_IN_BASIS_POINTS;
    const fee = rawFee > transferFee.maximumFee ? transferFee.maximumFee : rawFee;
    return BigInt(fee);
  }
}
var TransferFeeConfigLayout = (0, import_buffer_layout6.struct)([
  publicKey("transferFeeConfigAuthority"),
  publicKey("withdrawWithheldAuthority"),
  u64("withheldAmount"),
  transferFeeLayout("olderTransferFee"),
  transferFeeLayout("newerTransferFee")
]);
var TRANSFER_FEE_CONFIG_SIZE = TransferFeeConfigLayout.span;
function getEpochFee(transferFeeConfig, epoch) {
  if (epoch >= transferFeeConfig.newerTransferFee.epoch) {
    return transferFeeConfig.newerTransferFee;
  } else {
    return transferFeeConfig.olderTransferFee;
  }
}
var TransferFeeAmountLayout = (0, import_buffer_layout6.struct)([u64("withheldAmount")]);
var TRANSFER_FEE_AMOUNT_SIZE = TransferFeeAmountLayout.span;
function getTransferFeeConfig(mint) {
  const extensionData = getExtensionData(ExtensionType.TransferFeeConfig, mint.tlvData);
  if (extensionData !== null) {
    return TransferFeeConfigLayout.decode(extensionData);
  } else {
    return null;
  }
}

// node_modules/@meteora-ag/dlmm/node_modules/@solana/spl-token/lib/esm/extensions/transferHook/instructions.js
var import_buffer_layout9 = __toESM(require_Layout(), 1);
var import_web37 = require("@solana/web3.js");

// node_modules/@meteora-ag/dlmm/node_modules/@solana/spl-token/lib/esm/instructions/transferChecked.js
var import_buffer_layout7 = __toESM(require_Layout(), 1);
var import_web34 = require("@solana/web3.js");
var transferCheckedInstructionData = (0, import_buffer_layout7.struct)([
  (0, import_buffer_layout7.u8)("instruction"),
  u64("amount"),
  (0, import_buffer_layout7.u8)("decimals")
]);
function createTransferCheckedInstruction(source, mint, destination, owner, amount, decimals, multiSigners = [], programId = TOKEN_PROGRAM_ID) {
  const keys = addSigners([
    { pubkey: source, isSigner: false, isWritable: true },
    { pubkey: mint, isSigner: false, isWritable: false },
    { pubkey: destination, isSigner: false, isWritable: true }
  ], owner, multiSigners);
  const data = Buffer.alloc(transferCheckedInstructionData.span);
  transferCheckedInstructionData.encode({
    instruction: TokenInstruction.TransferChecked,
    amount: BigInt(amount),
    decimals
  }, data);
  return new import_web34.TransactionInstruction({ keys, programId, data });
}

// node_modules/@meteora-ag/dlmm/node_modules/@solana/spl-token/lib/esm/extensions/transferHook/state.js
var import_buffer_layout8 = __toESM(require_Layout(), 1);
var import_web36 = require("@solana/web3.js");

// node_modules/@meteora-ag/dlmm/node_modules/@solana/spl-token/lib/esm/extensions/transferHook/seeds.js
var DISCRIMINATOR_SPAN = 1;
var LITERAL_LENGTH_SPAN = 1;
var INSTRUCTION_ARG_OFFSET_SPAN = 1;
var INSTRUCTION_ARG_LENGTH_SPAN = 1;
var ACCOUNT_KEY_INDEX_SPAN = 1;
var ACCOUNT_DATA_ACCOUNT_INDEX_SPAN = 1;
var ACCOUNT_DATA_OFFSET_SPAN = 1;
var ACCOUNT_DATA_LENGTH_SPAN = 1;
function unpackSeedLiteral(seeds) {
  if (seeds.length < 1) {
    throw new TokenTransferHookInvalidSeed();
  }
  const [length, ...rest] = seeds;
  if (rest.length < length) {
    throw new TokenTransferHookInvalidSeed();
  }
  return {
    data: Buffer.from(rest.slice(0, length)),
    packedLength: DISCRIMINATOR_SPAN + LITERAL_LENGTH_SPAN + length
  };
}
function unpackSeedInstructionArg(seeds, instructionData) {
  if (seeds.length < 2) {
    throw new TokenTransferHookInvalidSeed();
  }
  const [index, length] = seeds;
  if (instructionData.length < length + index) {
    throw new TokenTransferHookInvalidSeed();
  }
  return {
    data: instructionData.subarray(index, index + length),
    packedLength: DISCRIMINATOR_SPAN + INSTRUCTION_ARG_OFFSET_SPAN + INSTRUCTION_ARG_LENGTH_SPAN
  };
}
function unpackSeedAccountKey(seeds, previousMetas) {
  if (seeds.length < 1) {
    throw new TokenTransferHookInvalidSeed();
  }
  const [index] = seeds;
  if (previousMetas.length <= index) {
    throw new TokenTransferHookInvalidSeed();
  }
  return {
    data: previousMetas[index].pubkey.toBuffer(),
    packedLength: DISCRIMINATOR_SPAN + ACCOUNT_KEY_INDEX_SPAN
  };
}
async function unpackSeedAccountData(seeds, previousMetas, connection) {
  if (seeds.length < 3) {
    throw new TokenTransferHookInvalidSeed();
  }
  const [accountIndex, dataIndex, length] = seeds;
  if (previousMetas.length <= accountIndex) {
    throw new TokenTransferHookInvalidSeed();
  }
  const accountInfo = await connection.getAccountInfo(previousMetas[accountIndex].pubkey);
  if (accountInfo == null) {
    throw new TokenTransferHookAccountDataNotFound();
  }
  if (accountInfo.data.length < dataIndex + length) {
    throw new TokenTransferHookInvalidSeed();
  }
  return {
    data: accountInfo.data.subarray(dataIndex, dataIndex + length),
    packedLength: DISCRIMINATOR_SPAN + ACCOUNT_DATA_ACCOUNT_INDEX_SPAN + ACCOUNT_DATA_OFFSET_SPAN + ACCOUNT_DATA_LENGTH_SPAN
  };
}
async function unpackFirstSeed(seeds, previousMetas, instructionData, connection) {
  const [discriminator, ...rest] = seeds;
  const remaining = new Uint8Array(rest);
  switch (discriminator) {
    case 0:
      return null;
    case 1:
      return unpackSeedLiteral(remaining);
    case 2:
      return unpackSeedInstructionArg(remaining, instructionData);
    case 3:
      return unpackSeedAccountKey(remaining, previousMetas);
    case 4:
      return unpackSeedAccountData(remaining, previousMetas, connection);
    default:
      throw new TokenTransferHookInvalidSeed();
  }
}
async function unpackSeeds(seeds, previousMetas, instructionData, connection) {
  const unpackedSeeds = [];
  let i = 0;
  while (i < 32) {
    const seed = await unpackFirstSeed(seeds.slice(i), previousMetas, instructionData, connection);
    if (seed == null) {
      break;
    }
    unpackedSeeds.push(seed.data);
    i += seed.packedLength;
  }
  return unpackedSeeds;
}

// node_modules/@meteora-ag/dlmm/node_modules/@solana/spl-token/lib/esm/extensions/transferHook/pubkeyData.js
var import_web35 = require("@solana/web3.js");
async function unpackPubkeyData(keyDataConfig, previousMetas, instructionData, connection) {
  const [discriminator, ...rest] = keyDataConfig;
  const remaining = new Uint8Array(rest);
  switch (discriminator) {
    case 1:
      return unpackPubkeyDataFromInstructionData(remaining, instructionData);
    case 2:
      return unpackPubkeyDataFromAccountData(remaining, previousMetas, connection);
    default:
      throw new TokenTransferHookInvalidPubkeyData();
  }
}
function unpackPubkeyDataFromInstructionData(remaining, instructionData) {
  if (remaining.length < 1) {
    throw new TokenTransferHookInvalidPubkeyData();
  }
  const dataIndex = remaining[0];
  if (instructionData.length < dataIndex + import_web35.PUBLIC_KEY_LENGTH) {
    throw new TokenTransferHookPubkeyDataTooSmall();
  }
  return new import_web35.PublicKey(instructionData.subarray(dataIndex, dataIndex + import_web35.PUBLIC_KEY_LENGTH));
}
async function unpackPubkeyDataFromAccountData(remaining, previousMetas, connection) {
  if (remaining.length < 2) {
    throw new TokenTransferHookInvalidPubkeyData();
  }
  const [accountIndex, dataIndex] = remaining;
  if (previousMetas.length <= accountIndex) {
    throw new TokenTransferHookAccountDataNotFound();
  }
  const accountInfo = await connection.getAccountInfo(previousMetas[accountIndex].pubkey);
  if (accountInfo == null) {
    throw new TokenTransferHookAccountNotFound();
  }
  if (accountInfo.data.length < dataIndex + import_web35.PUBLIC_KEY_LENGTH) {
    throw new TokenTransferHookPubkeyDataTooSmall();
  }
  return new import_web35.PublicKey(accountInfo.data.subarray(dataIndex, dataIndex + import_web35.PUBLIC_KEY_LENGTH));
}

// node_modules/@meteora-ag/dlmm/node_modules/@solana/spl-token/lib/esm/extensions/transferHook/state.js
var TransferHookLayout = (0, import_buffer_layout8.struct)([publicKey("authority"), publicKey("programId")]);
var TRANSFER_HOOK_SIZE = TransferHookLayout.span;
function getTransferHook(mint) {
  const extensionData = getExtensionData(ExtensionType.TransferHook, mint.tlvData);
  if (extensionData !== null) {
    return TransferHookLayout.decode(extensionData);
  } else {
    return null;
  }
}
var TransferHookAccountLayout = (0, import_buffer_layout8.struct)([bool("transferring")]);
var TRANSFER_HOOK_ACCOUNT_SIZE = TransferHookAccountLayout.span;
function getExtraAccountMetaAddress(mint, programId) {
  const seeds = [Buffer.from("extra-account-metas"), mint.toBuffer()];
  return import_web36.PublicKey.findProgramAddressSync(seeds, programId)[0];
}
var ExtraAccountMetaLayout = (0, import_buffer_layout8.struct)([
  (0, import_buffer_layout8.u8)("discriminator"),
  (0, import_buffer_layout8.blob)(32, "addressConfig"),
  bool("isSigner"),
  bool("isWritable")
]);
var ExtraAccountMetaListLayout = (0, import_buffer_layout8.struct)([
  (0, import_buffer_layout8.u32)("count"),
  (0, import_buffer_layout8.seq)(ExtraAccountMetaLayout, (0, import_buffer_layout8.greedy)(ExtraAccountMetaLayout.span), "extraAccounts")
]);
var ExtraAccountMetaAccountDataLayout = (0, import_buffer_layout8.struct)([
  u64("instructionDiscriminator"),
  (0, import_buffer_layout8.u32)("length"),
  ExtraAccountMetaListLayout.replicate("extraAccountsList")
]);
function getExtraAccountMetas(account) {
  const extraAccountsList = ExtraAccountMetaAccountDataLayout.decode(account.data).extraAccountsList;
  return extraAccountsList.extraAccounts.slice(0, extraAccountsList.count);
}
async function resolveExtraAccountMeta(connection, extraMeta, previousMetas, instructionData, transferHookProgramId) {
  if (extraMeta.discriminator === 0) {
    return {
      pubkey: new import_web36.PublicKey(extraMeta.addressConfig),
      isSigner: extraMeta.isSigner,
      isWritable: extraMeta.isWritable
    };
  } else if (extraMeta.discriminator === 2) {
    const pubkey2 = await unpackPubkeyData(extraMeta.addressConfig, previousMetas, instructionData, connection);
    return {
      pubkey: pubkey2,
      isSigner: extraMeta.isSigner,
      isWritable: extraMeta.isWritable
    };
  }
  let programId = import_web36.PublicKey.default;
  if (extraMeta.discriminator === 1) {
    programId = transferHookProgramId;
  } else {
    const accountIndex = extraMeta.discriminator - (1 << 7);
    if (previousMetas.length <= accountIndex) {
      throw new TokenTransferHookAccountNotFound();
    }
    programId = previousMetas[accountIndex].pubkey;
  }
  const seeds = await unpackSeeds(extraMeta.addressConfig, previousMetas, instructionData, connection);
  const pubkey = import_web36.PublicKey.findProgramAddressSync(seeds, programId)[0];
  return { pubkey, isSigner: extraMeta.isSigner, isWritable: extraMeta.isWritable };
}

// node_modules/@meteora-ag/dlmm/node_modules/@solana/spl-token/lib/esm/extensions/transferHook/instructions.js
var TransferHookInstruction;
(function(TransferHookInstruction2) {
  TransferHookInstruction2[TransferHookInstruction2["Initialize"] = 0] = "Initialize";
  TransferHookInstruction2[TransferHookInstruction2["Update"] = 1] = "Update";
})(TransferHookInstruction || (TransferHookInstruction = {}));
var initializeTransferHookInstructionData = (0, import_buffer_layout9.struct)([
  (0, import_buffer_layout9.u8)("instruction"),
  (0, import_buffer_layout9.u8)("transferHookInstruction"),
  publicKey("authority"),
  publicKey("transferHookProgramId")
]);
var updateTransferHookInstructionData = (0, import_buffer_layout9.struct)([
  (0, import_buffer_layout9.u8)("instruction"),
  (0, import_buffer_layout9.u8)("transferHookInstruction"),
  publicKey("transferHookProgramId")
]);
function deEscalateAccountMeta(accountMeta, accountMetas) {
  const maybeHighestPrivileges = accountMetas.filter((x) => x.pubkey.equals(accountMeta.pubkey)).reduce((acc, x) => {
    if (!acc)
      return { isSigner: x.isSigner, isWritable: x.isWritable };
    return { isSigner: acc.isSigner || x.isSigner, isWritable: acc.isWritable || x.isWritable };
  }, void 0);
  if (maybeHighestPrivileges) {
    const { isSigner, isWritable } = maybeHighestPrivileges;
    if (!isSigner && isSigner !== accountMeta.isSigner) {
      accountMeta.isSigner = false;
    }
    if (!isWritable && isWritable !== accountMeta.isWritable) {
      accountMeta.isWritable = false;
    }
  }
  return accountMeta;
}
function createExecuteInstruction(programId, source, mint, destination, owner, validateStatePubkey, amount) {
  const keys = [source, mint, destination, owner, validateStatePubkey].map((pubkey) => ({
    pubkey,
    isSigner: false,
    isWritable: false
  }));
  const data = Buffer.alloc(16);
  data.set(Buffer.from([105, 37, 101, 197, 75, 251, 102, 26]), 0);
  data.writeBigUInt64LE(BigInt(amount), 8);
  return new import_web37.TransactionInstruction({ keys, programId, data });
}
async function addExtraAccountMetasForExecute(connection, instruction, programId, source, mint, destination, owner, amount, commitment) {
  const validateStatePubkey = getExtraAccountMetaAddress(mint, programId);
  const validateStateAccount = await connection.getAccountInfo(validateStatePubkey, commitment);
  if (validateStateAccount == null) {
    return instruction;
  }
  const validateStateData = getExtraAccountMetas(validateStateAccount);
  if (![source, mint, destination, owner].every((key) => instruction.keys.some((meta) => meta.pubkey.equals(key)))) {
    throw new Error("Missing required account in instruction");
  }
  const executeInstruction = createExecuteInstruction(programId, source, mint, destination, owner, validateStatePubkey, BigInt(amount));
  for (const extraAccountMeta of validateStateData) {
    executeInstruction.keys.push(deEscalateAccountMeta(await resolveExtraAccountMeta(connection, extraAccountMeta, executeInstruction.keys, executeInstruction.data, executeInstruction.programId), executeInstruction.keys));
  }
  instruction.keys.push(...executeInstruction.keys.slice(5));
  instruction.keys.push({ pubkey: programId, isSigner: false, isWritable: false });
  instruction.keys.push({ pubkey: validateStatePubkey, isSigner: false, isWritable: false });
}

// node_modules/@meteora-ag/dlmm/node_modules/@solana/spl-token/lib/esm/extensions/extensionType.js
var ExtensionType;
(function(ExtensionType2) {
  ExtensionType2[ExtensionType2["Uninitialized"] = 0] = "Uninitialized";
  ExtensionType2[ExtensionType2["TransferFeeConfig"] = 1] = "TransferFeeConfig";
  ExtensionType2[ExtensionType2["TransferFeeAmount"] = 2] = "TransferFeeAmount";
  ExtensionType2[ExtensionType2["MintCloseAuthority"] = 3] = "MintCloseAuthority";
  ExtensionType2[ExtensionType2["ConfidentialTransferMint"] = 4] = "ConfidentialTransferMint";
  ExtensionType2[ExtensionType2["ConfidentialTransferAccount"] = 5] = "ConfidentialTransferAccount";
  ExtensionType2[ExtensionType2["DefaultAccountState"] = 6] = "DefaultAccountState";
  ExtensionType2[ExtensionType2["ImmutableOwner"] = 7] = "ImmutableOwner";
  ExtensionType2[ExtensionType2["MemoTransfer"] = 8] = "MemoTransfer";
  ExtensionType2[ExtensionType2["NonTransferable"] = 9] = "NonTransferable";
  ExtensionType2[ExtensionType2["InterestBearingConfig"] = 10] = "InterestBearingConfig";
  ExtensionType2[ExtensionType2["CpiGuard"] = 11] = "CpiGuard";
  ExtensionType2[ExtensionType2["PermanentDelegate"] = 12] = "PermanentDelegate";
  ExtensionType2[ExtensionType2["NonTransferableAccount"] = 13] = "NonTransferableAccount";
  ExtensionType2[ExtensionType2["TransferHook"] = 14] = "TransferHook";
  ExtensionType2[ExtensionType2["TransferHookAccount"] = 15] = "TransferHookAccount";
  ExtensionType2[ExtensionType2["MetadataPointer"] = 18] = "MetadataPointer";
  ExtensionType2[ExtensionType2["TokenMetadata"] = 19] = "TokenMetadata";
  ExtensionType2[ExtensionType2["GroupPointer"] = 20] = "GroupPointer";
  ExtensionType2[ExtensionType2["TokenGroup"] = 21] = "TokenGroup";
  ExtensionType2[ExtensionType2["GroupMemberPointer"] = 22] = "GroupMemberPointer";
  ExtensionType2[ExtensionType2["TokenGroupMember"] = 23] = "TokenGroupMember";
  ExtensionType2[ExtensionType2["ScaledUiAmountConfig"] = 25] = "ScaledUiAmountConfig";
  ExtensionType2[ExtensionType2["PausableConfig"] = 26] = "PausableConfig";
  ExtensionType2[ExtensionType2["PausableAccount"] = 27] = "PausableAccount";
})(ExtensionType || (ExtensionType = {}));
var TYPE_SIZE = 2;
var LENGTH_SIZE = 2;
function addTypeAndLengthToLen(len) {
  return len + TYPE_SIZE + LENGTH_SIZE;
}
function getExtensionData(extension, tlvData) {
  let extensionTypeIndex = 0;
  while (addTypeAndLengthToLen(extensionTypeIndex) <= tlvData.length) {
    const entryType = tlvData.readUInt16LE(extensionTypeIndex);
    const entryLength = tlvData.readUInt16LE(extensionTypeIndex + TYPE_SIZE);
    const typeIndex = addTypeAndLengthToLen(extensionTypeIndex);
    if (entryType == extension) {
      return tlvData.slice(typeIndex, typeIndex + entryLength);
    }
    extensionTypeIndex = typeIndex + entryLength;
  }
  return null;
}

// node_modules/@meteora-ag/dlmm/node_modules/@solana/spl-token/lib/esm/state/mint.js
var MintLayout = (0, import_buffer_layout10.struct)([
  (0, import_buffer_layout10.u32)("mintAuthorityOption"),
  publicKey("mintAuthority"),
  u64("supply"),
  (0, import_buffer_layout10.u8)("decimals"),
  bool("isInitialized"),
  (0, import_buffer_layout10.u32)("freezeAuthorityOption"),
  publicKey("freezeAuthority")
]);
var MINT_SIZE = MintLayout.span;
function unpackMint(address, info, programId = TOKEN_PROGRAM_ID) {
  if (!info)
    throw new TokenAccountNotFoundError();
  if (!info.owner.equals(programId))
    throw new TokenInvalidAccountOwnerError();
  if (info.data.length < MINT_SIZE)
    throw new TokenInvalidAccountSizeError();
  const rawMint = MintLayout.decode(info.data.slice(0, MINT_SIZE));
  let tlvData = Buffer.alloc(0);
  if (info.data.length > MINT_SIZE) {
    if (info.data.length <= ACCOUNT_SIZE)
      throw new TokenInvalidAccountSizeError();
    if (info.data.length === MULTISIG_SIZE)
      throw new TokenInvalidAccountSizeError();
    if (info.data[ACCOUNT_SIZE] != AccountType.Mint)
      throw new TokenInvalidMintError();
    tlvData = info.data.slice(ACCOUNT_SIZE + ACCOUNT_TYPE_SIZE);
  }
  return {
    address,
    mintAuthority: rawMint.mintAuthorityOption ? rawMint.mintAuthority : null,
    supply: rawMint.supply,
    decimals: rawMint.decimals,
    isInitialized: rawMint.isInitialized,
    freezeAuthority: rawMint.freezeAuthorityOption ? rawMint.freezeAuthority : null,
    tlvData
  };
}
function getAssociatedTokenAddressSync(mint, owner, allowOwnerOffCurve = false, programId = TOKEN_PROGRAM_ID, associatedTokenProgramId = ASSOCIATED_TOKEN_PROGRAM_ID) {
  if (!allowOwnerOffCurve && !import_web38.PublicKey.isOnCurve(owner.toBuffer()))
    throw new TokenOwnerOffCurveError();
  const [address] = import_web38.PublicKey.findProgramAddressSync([owner.toBuffer(), programId.toBuffer(), mint.toBuffer()], associatedTokenProgramId);
  return address;
}

// node_modules/@meteora-ag/dlmm/node_modules/@solana/spl-token/lib/esm/instructions/closeAccount.js
var import_buffer_layout11 = __toESM(require_Layout(), 1);
var import_web39 = require("@solana/web3.js");
var closeAccountInstructionData = (0, import_buffer_layout11.struct)([(0, import_buffer_layout11.u8)("instruction")]);
function createCloseAccountInstruction(account, destination, authority, multiSigners = [], programId = TOKEN_PROGRAM_ID) {
  const keys = addSigners([
    { pubkey: account, isSigner: false, isWritable: true },
    { pubkey: destination, isSigner: false, isWritable: true }
  ], authority, multiSigners);
  const data = Buffer.alloc(closeAccountInstructionData.span);
  closeAccountInstructionData.encode({ instruction: TokenInstruction.CloseAccount }, data);
  return new import_web39.TransactionInstruction({ keys, programId, data });
}

// node_modules/@meteora-ag/dlmm/node_modules/@solana/spl-token/lib/esm/instructions/associatedTokenAccount.js
var import_web310 = require("@solana/web3.js");
function createAssociatedTokenAccountIdempotentInstruction(payer, associatedToken, owner, mint, programId = TOKEN_PROGRAM_ID, associatedTokenProgramId = ASSOCIATED_TOKEN_PROGRAM_ID) {
  return buildAssociatedTokenAccountInstruction(payer, associatedToken, owner, mint, Buffer.from([1]), programId, associatedTokenProgramId);
}
function buildAssociatedTokenAccountInstruction(payer, associatedToken, owner, mint, instructionData, programId = TOKEN_PROGRAM_ID, associatedTokenProgramId = ASSOCIATED_TOKEN_PROGRAM_ID) {
  const keys = [
    { pubkey: payer, isSigner: true, isWritable: true },
    { pubkey: associatedToken, isSigner: false, isWritable: true },
    { pubkey: owner, isSigner: false, isWritable: false },
    { pubkey: mint, isSigner: false, isWritable: false },
    { pubkey: import_web310.SystemProgram.programId, isSigner: false, isWritable: false },
    { pubkey: programId, isSigner: false, isWritable: false }
  ];
  return new import_web310.TransactionInstruction({
    keys,
    programId: associatedTokenProgramId,
    data: instructionData
  });
}

// node_modules/@meteora-ag/dlmm/dist/index.mjs
var import_web311 = require("@solana/web3.js");

// node_modules/decimal.js/decimal.mjs
var EXP_LIMIT = 9e15;
var MAX_DIGITS = 1e9;
var NUMERALS = "0123456789abcdef";
var LN10 = "2.3025850929940456840179914546843642076011014886287729760333279009675726096773524802359972050895982983419677840422862486334095254650828067566662873690987816894829072083255546808437998948262331985283935053089653777326288461633662222876982198867465436674744042432743651550489343149393914796194044002221051017141748003688084012647080685567743216228355220114804663715659121373450747856947683463616792101806445070648000277502684916746550586856935673420670581136429224554405758925724208241314695689016758940256776311356919292033376587141660230105703089634572075440370847469940168269282808481184289314848524948644871927809676271275775397027668605952496716674183485704422507197965004714951050492214776567636938662976979522110718264549734772662425709429322582798502585509785265383207606726317164309505995087807523710333101197857547331541421808427543863591778117054309827482385045648019095610299291824318237525357709750539565187697510374970888692180205189339507238539205144634197265287286965110862571492198849978748873771345686209167058";
var PI = "3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632789";
var DEFAULTS = {
  // These values must be integers within the stated ranges (inclusive).
  // Most of these values can be changed at run-time using the `Decimal.config` method.
  // The maximum number of significant digits of the result of a calculation or base conversion.
  // E.g. `Decimal.config({ precision: 20 });`
  precision: 20,
  // 1 to MAX_DIGITS
  // The rounding mode used when rounding to `precision`.
  //
  // ROUND_UP         0 Away from zero.
  // ROUND_DOWN       1 Towards zero.
  // ROUND_CEIL       2 Towards +Infinity.
  // ROUND_FLOOR      3 Towards -Infinity.
  // ROUND_HALF_UP    4 Towards nearest neighbour. If equidistant, up.
  // ROUND_HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.
  // ROUND_HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.
  // ROUND_HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.
  // ROUND_HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.
  //
  // E.g.
  // `Decimal.rounding = 4;`
  // `Decimal.rounding = Decimal.ROUND_HALF_UP;`
  rounding: 4,
  // 0 to 8
  // The modulo mode used when calculating the modulus: a mod n.
  // The quotient (q = a / n) is calculated according to the corresponding rounding mode.
  // The remainder (r) is calculated as: r = a - n * q.
  //
  // UP         0 The remainder is positive if the dividend is negative, else is negative.
  // DOWN       1 The remainder has the same sign as the dividend (JavaScript %).
  // FLOOR      3 The remainder has the same sign as the divisor (Python %).
  // HALF_EVEN  6 The IEEE 754 remainder function.
  // EUCLID     9 Euclidian division. q = sign(n) * floor(a / abs(n)). Always positive.
  //
  // Truncated division (1), floored division (3), the IEEE 754 remainder (6), and Euclidian
  // division (9) are commonly used for the modulus operation. The other rounding modes can also
  // be used, but they may not give useful results.
  modulo: 1,
  // 0 to 9
  // The exponent value at and beneath which `toString` returns exponential notation.
  // JavaScript numbers: -7
  toExpNeg: -7,
  // 0 to -EXP_LIMIT
  // The exponent value at and above which `toString` returns exponential notation.
  // JavaScript numbers: 21
  toExpPos: 21,
  // 0 to EXP_LIMIT
  // The minimum exponent value, beneath which underflow to zero occurs.
  // JavaScript numbers: -324  (5e-324)
  minE: -EXP_LIMIT,
  // -1 to -EXP_LIMIT
  // The maximum exponent value, above which overflow to Infinity occurs.
  // JavaScript numbers: 308  (1.7976931348623157e+308)
  maxE: EXP_LIMIT,
  // 1 to EXP_LIMIT
  // Whether to use cryptographically-secure random number generation, if available.
  crypto: false
  // true/false
};
var inexact;
var quadrant;
var external = true;
var decimalError = "[DecimalError] ";
var invalidArgument = decimalError + "Invalid argument: ";
var precisionLimitExceeded = decimalError + "Precision limit exceeded";
var cryptoUnavailable = decimalError + "crypto unavailable";
var tag = "[object Decimal]";
var mathfloor2 = Math.floor;
var mathpow = Math.pow;
var isBinary = /^0b([01]+(\.[01]*)?|\.[01]+)(p[+-]?\d+)?$/i;
var isHex = /^0x([0-9a-f]+(\.[0-9a-f]*)?|\.[0-9a-f]+)(p[+-]?\d+)?$/i;
var isOctal = /^0o([0-7]+(\.[0-7]*)?|\.[0-7]+)(p[+-]?\d+)?$/i;
var isDecimal = /^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i;
var BASE2 = 1e7;
var LOG_BASE2 = 7;
var MAX_SAFE_INTEGER2 = 9007199254740991;
var LN10_PRECISION = LN10.length - 1;
var PI_PRECISION = PI.length - 1;
var P = { toStringTag: tag };
P.absoluteValue = P.abs = function() {
  var x = new this.constructor(this);
  if (x.s < 0)
    x.s = 1;
  return finalise(x);
};
P.ceil = function() {
  return finalise(new this.constructor(this), this.e + 1, 2);
};
P.clampedTo = P.clamp = function(min2, max2) {
  var k, x = this, Ctor = x.constructor;
  min2 = new Ctor(min2);
  max2 = new Ctor(max2);
  if (!min2.s || !max2.s)
    return new Ctor(NaN);
  if (min2.gt(max2))
    throw Error(invalidArgument + max2);
  k = x.cmp(min2);
  return k < 0 ? min2 : x.cmp(max2) > 0 ? max2 : new Ctor(x);
};
P.comparedTo = P.cmp = function(y) {
  var i, j, xdL, ydL, x = this, xd = x.d, yd = (y = new x.constructor(y)).d, xs = x.s, ys = y.s;
  if (!xd || !yd) {
    return !xs || !ys ? NaN : xs !== ys ? xs : xd === yd ? 0 : !xd ^ xs < 0 ? 1 : -1;
  }
  if (!xd[0] || !yd[0])
    return xd[0] ? xs : yd[0] ? -ys : 0;
  if (xs !== ys)
    return xs;
  if (x.e !== y.e)
    return x.e > y.e ^ xs < 0 ? 1 : -1;
  xdL = xd.length;
  ydL = yd.length;
  for (i = 0, j = xdL < ydL ? xdL : ydL; i < j; ++i) {
    if (xd[i] !== yd[i])
      return xd[i] > yd[i] ^ xs < 0 ? 1 : -1;
  }
  return xdL === ydL ? 0 : xdL > ydL ^ xs < 0 ? 1 : -1;
};
P.cosine = P.cos = function() {
  var pr, rm, x = this, Ctor = x.constructor;
  if (!x.d)
    return new Ctor(NaN);
  if (!x.d[0])
    return new Ctor(1);
  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + Math.max(x.e, x.sd()) + LOG_BASE2;
  Ctor.rounding = 1;
  x = cosine(Ctor, toLessThanHalfPi(Ctor, x));
  Ctor.precision = pr;
  Ctor.rounding = rm;
  return finalise(quadrant == 2 || quadrant == 3 ? x.neg() : x, pr, rm, true);
};
P.cubeRoot = P.cbrt = function() {
  var e, m, n, r, rep, s, sd, t, t3, t3plusx, x = this, Ctor = x.constructor;
  if (!x.isFinite() || x.isZero())
    return new Ctor(x);
  external = false;
  s = x.s * mathpow(x.s * x, 1 / 3);
  if (!s || Math.abs(s) == 1 / 0) {
    n = digitsToString(x.d);
    e = x.e;
    if (s = (e - n.length + 1) % 3)
      n += s == 1 || s == -2 ? "0" : "00";
    s = mathpow(n, 1 / 3);
    e = mathfloor2((e + 1) / 3) - (e % 3 == (e < 0 ? -1 : 2));
    if (s == 1 / 0) {
      n = "5e" + e;
    } else {
      n = s.toExponential();
      n = n.slice(0, n.indexOf("e") + 1) + e;
    }
    r = new Ctor(n);
    r.s = x.s;
  } else {
    r = new Ctor(s.toString());
  }
  sd = (e = Ctor.precision) + 3;
  for (; ; ) {
    t = r;
    t3 = t.times(t).times(t);
    t3plusx = t3.plus(x);
    r = divide(t3plusx.plus(x).times(t), t3plusx.plus(t3), sd + 2, 1);
    if (digitsToString(t.d).slice(0, sd) === (n = digitsToString(r.d)).slice(0, sd)) {
      n = n.slice(sd - 3, sd + 1);
      if (n == "9999" || !rep && n == "4999") {
        if (!rep) {
          finalise(t, e + 1, 0);
          if (t.times(t).times(t).eq(x)) {
            r = t;
            break;
          }
        }
        sd += 4;
        rep = 1;
      } else {
        if (!+n || !+n.slice(1) && n.charAt(0) == "5") {
          finalise(r, e + 1, 1);
          m = !r.times(r).times(r).eq(x);
        }
        break;
      }
    }
  }
  external = true;
  return finalise(r, e, Ctor.rounding, m);
};
P.decimalPlaces = P.dp = function() {
  var w, d = this.d, n = NaN;
  if (d) {
    w = d.length - 1;
    n = (w - mathfloor2(this.e / LOG_BASE2)) * LOG_BASE2;
    w = d[w];
    if (w)
      for (; w % 10 == 0; w /= 10)
        n--;
    if (n < 0)
      n = 0;
  }
  return n;
};
P.dividedBy = P.div = function(y) {
  return divide(this, new this.constructor(y));
};
P.dividedToIntegerBy = P.divToInt = function(y) {
  var x = this, Ctor = x.constructor;
  return finalise(divide(x, new Ctor(y), 0, 1, 1), Ctor.precision, Ctor.rounding);
};
P.equals = P.eq = function(y) {
  return this.cmp(y) === 0;
};
P.floor = function() {
  return finalise(new this.constructor(this), this.e + 1, 3);
};
P.greaterThan = P.gt = function(y) {
  return this.cmp(y) > 0;
};
P.greaterThanOrEqualTo = P.gte = function(y) {
  var k = this.cmp(y);
  return k == 1 || k === 0;
};
P.hyperbolicCosine = P.cosh = function() {
  var k, n, pr, rm, len, x = this, Ctor = x.constructor, one = new Ctor(1);
  if (!x.isFinite())
    return new Ctor(x.s ? 1 / 0 : NaN);
  if (x.isZero())
    return one;
  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + Math.max(x.e, x.sd()) + 4;
  Ctor.rounding = 1;
  len = x.d.length;
  if (len < 32) {
    k = Math.ceil(len / 3);
    n = (1 / tinyPow(4, k)).toString();
  } else {
    k = 16;
    n = "2.3283064365386962890625e-10";
  }
  x = taylorSeries(Ctor, 1, x.times(n), new Ctor(1), true);
  var cosh2_x, i = k, d8 = new Ctor(8);
  for (; i--; ) {
    cosh2_x = x.times(x);
    x = one.minus(cosh2_x.times(d8.minus(cosh2_x.times(d8))));
  }
  return finalise(x, Ctor.precision = pr, Ctor.rounding = rm, true);
};
P.hyperbolicSine = P.sinh = function() {
  var k, pr, rm, len, x = this, Ctor = x.constructor;
  if (!x.isFinite() || x.isZero())
    return new Ctor(x);
  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + Math.max(x.e, x.sd()) + 4;
  Ctor.rounding = 1;
  len = x.d.length;
  if (len < 3) {
    x = taylorSeries(Ctor, 2, x, x, true);
  } else {
    k = 1.4 * Math.sqrt(len);
    k = k > 16 ? 16 : k | 0;
    x = x.times(1 / tinyPow(5, k));
    x = taylorSeries(Ctor, 2, x, x, true);
    var sinh2_x, d5 = new Ctor(5), d16 = new Ctor(16), d20 = new Ctor(20);
    for (; k--; ) {
      sinh2_x = x.times(x);
      x = x.times(d5.plus(sinh2_x.times(d16.times(sinh2_x).plus(d20))));
    }
  }
  Ctor.precision = pr;
  Ctor.rounding = rm;
  return finalise(x, pr, rm, true);
};
P.hyperbolicTangent = P.tanh = function() {
  var pr, rm, x = this, Ctor = x.constructor;
  if (!x.isFinite())
    return new Ctor(x.s);
  if (x.isZero())
    return new Ctor(x);
  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + 7;
  Ctor.rounding = 1;
  return divide(x.sinh(), x.cosh(), Ctor.precision = pr, Ctor.rounding = rm);
};
P.inverseCosine = P.acos = function() {
  var x = this, Ctor = x.constructor, k = x.abs().cmp(1), pr = Ctor.precision, rm = Ctor.rounding;
  if (k !== -1) {
    return k === 0 ? x.isNeg() ? getPi(Ctor, pr, rm) : new Ctor(0) : new Ctor(NaN);
  }
  if (x.isZero())
    return getPi(Ctor, pr + 4, rm).times(0.5);
  Ctor.precision = pr + 6;
  Ctor.rounding = 1;
  x = new Ctor(1).minus(x).div(x.plus(1)).sqrt().atan();
  Ctor.precision = pr;
  Ctor.rounding = rm;
  return x.times(2);
};
P.inverseHyperbolicCosine = P.acosh = function() {
  var pr, rm, x = this, Ctor = x.constructor;
  if (x.lte(1))
    return new Ctor(x.eq(1) ? 0 : NaN);
  if (!x.isFinite())
    return new Ctor(x);
  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + Math.max(Math.abs(x.e), x.sd()) + 4;
  Ctor.rounding = 1;
  external = false;
  x = x.times(x).minus(1).sqrt().plus(x);
  external = true;
  Ctor.precision = pr;
  Ctor.rounding = rm;
  return x.ln();
};
P.inverseHyperbolicSine = P.asinh = function() {
  var pr, rm, x = this, Ctor = x.constructor;
  if (!x.isFinite() || x.isZero())
    return new Ctor(x);
  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + 2 * Math.max(Math.abs(x.e), x.sd()) + 6;
  Ctor.rounding = 1;
  external = false;
  x = x.times(x).plus(1).sqrt().plus(x);
  external = true;
  Ctor.precision = pr;
  Ctor.rounding = rm;
  return x.ln();
};
P.inverseHyperbolicTangent = P.atanh = function() {
  var pr, rm, wpr, xsd, x = this, Ctor = x.constructor;
  if (!x.isFinite())
    return new Ctor(NaN);
  if (x.e >= 0)
    return new Ctor(x.abs().eq(1) ? x.s / 0 : x.isZero() ? x : NaN);
  pr = Ctor.precision;
  rm = Ctor.rounding;
  xsd = x.sd();
  if (Math.max(xsd, pr) < 2 * -x.e - 1)
    return finalise(new Ctor(x), pr, rm, true);
  Ctor.precision = wpr = xsd - x.e;
  x = divide(x.plus(1), new Ctor(1).minus(x), wpr + pr, 1);
  Ctor.precision = pr + 4;
  Ctor.rounding = 1;
  x = x.ln();
  Ctor.precision = pr;
  Ctor.rounding = rm;
  return x.times(0.5);
};
P.inverseSine = P.asin = function() {
  var halfPi, k, pr, rm, x = this, Ctor = x.constructor;
  if (x.isZero())
    return new Ctor(x);
  k = x.abs().cmp(1);
  pr = Ctor.precision;
  rm = Ctor.rounding;
  if (k !== -1) {
    if (k === 0) {
      halfPi = getPi(Ctor, pr + 4, rm).times(0.5);
      halfPi.s = x.s;
      return halfPi;
    }
    return new Ctor(NaN);
  }
  Ctor.precision = pr + 6;
  Ctor.rounding = 1;
  x = x.div(new Ctor(1).minus(x.times(x)).sqrt().plus(1)).atan();
  Ctor.precision = pr;
  Ctor.rounding = rm;
  return x.times(2);
};
P.inverseTangent = P.atan = function() {
  var i, j, k, n, px, t, r, wpr, x2, x = this, Ctor = x.constructor, pr = Ctor.precision, rm = Ctor.rounding;
  if (!x.isFinite()) {
    if (!x.s)
      return new Ctor(NaN);
    if (pr + 4 <= PI_PRECISION) {
      r = getPi(Ctor, pr + 4, rm).times(0.5);
      r.s = x.s;
      return r;
    }
  } else if (x.isZero()) {
    return new Ctor(x);
  } else if (x.abs().eq(1) && pr + 4 <= PI_PRECISION) {
    r = getPi(Ctor, pr + 4, rm).times(0.25);
    r.s = x.s;
    return r;
  }
  Ctor.precision = wpr = pr + 10;
  Ctor.rounding = 1;
  k = Math.min(28, wpr / LOG_BASE2 + 2 | 0);
  for (i = k; i; --i)
    x = x.div(x.times(x).plus(1).sqrt().plus(1));
  external = false;
  j = Math.ceil(wpr / LOG_BASE2);
  n = 1;
  x2 = x.times(x);
  r = new Ctor(x);
  px = x;
  for (; i !== -1; ) {
    px = px.times(x2);
    t = r.minus(px.div(n += 2));
    px = px.times(x2);
    r = t.plus(px.div(n += 2));
    if (r.d[j] !== void 0)
      for (i = j; r.d[i] === t.d[i] && i--; )
        ;
  }
  if (k)
    r = r.times(2 << k - 1);
  external = true;
  return finalise(r, Ctor.precision = pr, Ctor.rounding = rm, true);
};
P.isFinite = function() {
  return !!this.d;
};
P.isInteger = P.isInt = function() {
  return !!this.d && mathfloor2(this.e / LOG_BASE2) > this.d.length - 2;
};
P.isNaN = function() {
  return !this.s;
};
P.isNegative = P.isNeg = function() {
  return this.s < 0;
};
P.isPositive = P.isPos = function() {
  return this.s > 0;
};
P.isZero = function() {
  return !!this.d && this.d[0] === 0;
};
P.lessThan = P.lt = function(y) {
  return this.cmp(y) < 0;
};
P.lessThanOrEqualTo = P.lte = function(y) {
  return this.cmp(y) < 1;
};
P.logarithm = P.log = function(base) {
  var isBase10, d, denominator, k, inf, num, sd, r, arg = this, Ctor = arg.constructor, pr = Ctor.precision, rm = Ctor.rounding, guard = 5;
  if (base == null) {
    base = new Ctor(10);
    isBase10 = true;
  } else {
    base = new Ctor(base);
    d = base.d;
    if (base.s < 0 || !d || !d[0] || base.eq(1))
      return new Ctor(NaN);
    isBase10 = base.eq(10);
  }
  d = arg.d;
  if (arg.s < 0 || !d || !d[0] || arg.eq(1)) {
    return new Ctor(d && !d[0] ? -1 / 0 : arg.s != 1 ? NaN : d ? 0 : 1 / 0);
  }
  if (isBase10) {
    if (d.length > 1) {
      inf = true;
    } else {
      for (k = d[0]; k % 10 === 0; )
        k /= 10;
      inf = k !== 1;
    }
  }
  external = false;
  sd = pr + guard;
  num = naturalLogarithm(arg, sd);
  denominator = isBase10 ? getLn10(Ctor, sd + 10) : naturalLogarithm(base, sd);
  r = divide(num, denominator, sd, 1);
  if (checkRoundingDigits(r.d, k = pr, rm)) {
    do {
      sd += 10;
      num = naturalLogarithm(arg, sd);
      denominator = isBase10 ? getLn10(Ctor, sd + 10) : naturalLogarithm(base, sd);
      r = divide(num, denominator, sd, 1);
      if (!inf) {
        if (+digitsToString(r.d).slice(k + 1, k + 15) + 1 == 1e14) {
          r = finalise(r, pr + 1, 0);
        }
        break;
      }
    } while (checkRoundingDigits(r.d, k += 10, rm));
  }
  external = true;
  return finalise(r, pr, rm);
};
P.minus = P.sub = function(y) {
  var d, e, i, j, k, len, pr, rm, xd, xe, xLTy, yd, x = this, Ctor = x.constructor;
  y = new Ctor(y);
  if (!x.d || !y.d) {
    if (!x.s || !y.s)
      y = new Ctor(NaN);
    else if (x.d)
      y.s = -y.s;
    else
      y = new Ctor(y.d || x.s !== y.s ? x : NaN);
    return y;
  }
  if (x.s != y.s) {
    y.s = -y.s;
    return x.plus(y);
  }
  xd = x.d;
  yd = y.d;
  pr = Ctor.precision;
  rm = Ctor.rounding;
  if (!xd[0] || !yd[0]) {
    if (yd[0])
      y.s = -y.s;
    else if (xd[0])
      y = new Ctor(x);
    else
      return new Ctor(rm === 3 ? -0 : 0);
    return external ? finalise(y, pr, rm) : y;
  }
  e = mathfloor2(y.e / LOG_BASE2);
  xe = mathfloor2(x.e / LOG_BASE2);
  xd = xd.slice();
  k = xe - e;
  if (k) {
    xLTy = k < 0;
    if (xLTy) {
      d = xd;
      k = -k;
      len = yd.length;
    } else {
      d = yd;
      e = xe;
      len = xd.length;
    }
    i = Math.max(Math.ceil(pr / LOG_BASE2), len) + 2;
    if (k > i) {
      k = i;
      d.length = 1;
    }
    d.reverse();
    for (i = k; i--; )
      d.push(0);
    d.reverse();
  } else {
    i = xd.length;
    len = yd.length;
    xLTy = i < len;
    if (xLTy)
      len = i;
    for (i = 0; i < len; i++) {
      if (xd[i] != yd[i]) {
        xLTy = xd[i] < yd[i];
        break;
      }
    }
    k = 0;
  }
  if (xLTy) {
    d = xd;
    xd = yd;
    yd = d;
    y.s = -y.s;
  }
  len = xd.length;
  for (i = yd.length - len; i > 0; --i)
    xd[len++] = 0;
  for (i = yd.length; i > k; ) {
    if (xd[--i] < yd[i]) {
      for (j = i; j && xd[--j] === 0; )
        xd[j] = BASE2 - 1;
      --xd[j];
      xd[i] += BASE2;
    }
    xd[i] -= yd[i];
  }
  for (; xd[--len] === 0; )
    xd.pop();
  for (; xd[0] === 0; xd.shift())
    --e;
  if (!xd[0])
    return new Ctor(rm === 3 ? -0 : 0);
  y.d = xd;
  y.e = getBase10Exponent(xd, e);
  return external ? finalise(y, pr, rm) : y;
};
P.modulo = P.mod = function(y) {
  var q, x = this, Ctor = x.constructor;
  y = new Ctor(y);
  if (!x.d || !y.s || y.d && !y.d[0])
    return new Ctor(NaN);
  if (!y.d || x.d && !x.d[0]) {
    return finalise(new Ctor(x), Ctor.precision, Ctor.rounding);
  }
  external = false;
  if (Ctor.modulo == 9) {
    q = divide(x, y.abs(), 0, 3, 1);
    q.s *= y.s;
  } else {
    q = divide(x, y, 0, Ctor.modulo, 1);
  }
  q = q.times(y);
  external = true;
  return x.minus(q);
};
P.naturalExponential = P.exp = function() {
  return naturalExponential(this);
};
P.naturalLogarithm = P.ln = function() {
  return naturalLogarithm(this);
};
P.negated = P.neg = function() {
  var x = new this.constructor(this);
  x.s = -x.s;
  return finalise(x);
};
P.plus = P.add = function(y) {
  var carry, d, e, i, k, len, pr, rm, xd, yd, x = this, Ctor = x.constructor;
  y = new Ctor(y);
  if (!x.d || !y.d) {
    if (!x.s || !y.s)
      y = new Ctor(NaN);
    else if (!x.d)
      y = new Ctor(y.d || x.s === y.s ? x : NaN);
    return y;
  }
  if (x.s != y.s) {
    y.s = -y.s;
    return x.minus(y);
  }
  xd = x.d;
  yd = y.d;
  pr = Ctor.precision;
  rm = Ctor.rounding;
  if (!xd[0] || !yd[0]) {
    if (!yd[0])
      y = new Ctor(x);
    return external ? finalise(y, pr, rm) : y;
  }
  k = mathfloor2(x.e / LOG_BASE2);
  e = mathfloor2(y.e / LOG_BASE2);
  xd = xd.slice();
  i = k - e;
  if (i) {
    if (i < 0) {
      d = xd;
      i = -i;
      len = yd.length;
    } else {
      d = yd;
      e = k;
      len = xd.length;
    }
    k = Math.ceil(pr / LOG_BASE2);
    len = k > len ? k + 1 : len + 1;
    if (i > len) {
      i = len;
      d.length = 1;
    }
    d.reverse();
    for (; i--; )
      d.push(0);
    d.reverse();
  }
  len = xd.length;
  i = yd.length;
  if (len - i < 0) {
    i = len;
    d = yd;
    yd = xd;
    xd = d;
  }
  for (carry = 0; i; ) {
    carry = (xd[--i] = xd[i] + yd[i] + carry) / BASE2 | 0;
    xd[i] %= BASE2;
  }
  if (carry) {
    xd.unshift(carry);
    ++e;
  }
  for (len = xd.length; xd[--len] == 0; )
    xd.pop();
  y.d = xd;
  y.e = getBase10Exponent(xd, e);
  return external ? finalise(y, pr, rm) : y;
};
P.precision = P.sd = function(z) {
  var k, x = this;
  if (z !== void 0 && z !== !!z && z !== 1 && z !== 0)
    throw Error(invalidArgument + z);
  if (x.d) {
    k = getPrecision(x.d);
    if (z && x.e + 1 > k)
      k = x.e + 1;
  } else {
    k = NaN;
  }
  return k;
};
P.round = function() {
  var x = this, Ctor = x.constructor;
  return finalise(new Ctor(x), x.e + 1, Ctor.rounding);
};
P.sine = P.sin = function() {
  var pr, rm, x = this, Ctor = x.constructor;
  if (!x.isFinite())
    return new Ctor(NaN);
  if (x.isZero())
    return new Ctor(x);
  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + Math.max(x.e, x.sd()) + LOG_BASE2;
  Ctor.rounding = 1;
  x = sine(Ctor, toLessThanHalfPi(Ctor, x));
  Ctor.precision = pr;
  Ctor.rounding = rm;
  return finalise(quadrant > 2 ? x.neg() : x, pr, rm, true);
};
P.squareRoot = P.sqrt = function() {
  var m, n, sd, r, rep, t, x = this, d = x.d, e = x.e, s = x.s, Ctor = x.constructor;
  if (s !== 1 || !d || !d[0]) {
    return new Ctor(!s || s < 0 && (!d || d[0]) ? NaN : d ? x : 1 / 0);
  }
  external = false;
  s = Math.sqrt(+x);
  if (s == 0 || s == 1 / 0) {
    n = digitsToString(d);
    if ((n.length + e) % 2 == 0)
      n += "0";
    s = Math.sqrt(n);
    e = mathfloor2((e + 1) / 2) - (e < 0 || e % 2);
    if (s == 1 / 0) {
      n = "5e" + e;
    } else {
      n = s.toExponential();
      n = n.slice(0, n.indexOf("e") + 1) + e;
    }
    r = new Ctor(n);
  } else {
    r = new Ctor(s.toString());
  }
  sd = (e = Ctor.precision) + 3;
  for (; ; ) {
    t = r;
    r = t.plus(divide(x, t, sd + 2, 1)).times(0.5);
    if (digitsToString(t.d).slice(0, sd) === (n = digitsToString(r.d)).slice(0, sd)) {
      n = n.slice(sd - 3, sd + 1);
      if (n == "9999" || !rep && n == "4999") {
        if (!rep) {
          finalise(t, e + 1, 0);
          if (t.times(t).eq(x)) {
            r = t;
            break;
          }
        }
        sd += 4;
        rep = 1;
      } else {
        if (!+n || !+n.slice(1) && n.charAt(0) == "5") {
          finalise(r, e + 1, 1);
          m = !r.times(r).eq(x);
        }
        break;
      }
    }
  }
  external = true;
  return finalise(r, e, Ctor.rounding, m);
};
P.tangent = P.tan = function() {
  var pr, rm, x = this, Ctor = x.constructor;
  if (!x.isFinite())
    return new Ctor(NaN);
  if (x.isZero())
    return new Ctor(x);
  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + 10;
  Ctor.rounding = 1;
  x = x.sin();
  x.s = 1;
  x = divide(x, new Ctor(1).minus(x.times(x)).sqrt(), pr + 10, 0);
  Ctor.precision = pr;
  Ctor.rounding = rm;
  return finalise(quadrant == 2 || quadrant == 4 ? x.neg() : x, pr, rm, true);
};
P.times = P.mul = function(y) {
  var carry, e, i, k, r, rL, t, xdL, ydL, x = this, Ctor = x.constructor, xd = x.d, yd = (y = new Ctor(y)).d;
  y.s *= x.s;
  if (!xd || !xd[0] || !yd || !yd[0]) {
    return new Ctor(!y.s || xd && !xd[0] && !yd || yd && !yd[0] && !xd ? NaN : !xd || !yd ? y.s / 0 : y.s * 0);
  }
  e = mathfloor2(x.e / LOG_BASE2) + mathfloor2(y.e / LOG_BASE2);
  xdL = xd.length;
  ydL = yd.length;
  if (xdL < ydL) {
    r = xd;
    xd = yd;
    yd = r;
    rL = xdL;
    xdL = ydL;
    ydL = rL;
  }
  r = [];
  rL = xdL + ydL;
  for (i = rL; i--; )
    r.push(0);
  for (i = ydL; --i >= 0; ) {
    carry = 0;
    for (k = xdL + i; k > i; ) {
      t = r[k] + yd[i] * xd[k - i - 1] + carry;
      r[k--] = t % BASE2 | 0;
      carry = t / BASE2 | 0;
    }
    r[k] = (r[k] + carry) % BASE2 | 0;
  }
  for (; !r[--rL]; )
    r.pop();
  if (carry)
    ++e;
  else
    r.shift();
  y.d = r;
  y.e = getBase10Exponent(r, e);
  return external ? finalise(y, Ctor.precision, Ctor.rounding) : y;
};
P.toBinary = function(sd, rm) {
  return toStringBinary(this, 2, sd, rm);
};
P.toDecimalPlaces = P.toDP = function(dp, rm) {
  var x = this, Ctor = x.constructor;
  x = new Ctor(x);
  if (dp === void 0)
    return x;
  checkInt32(dp, 0, MAX_DIGITS);
  if (rm === void 0)
    rm = Ctor.rounding;
  else
    checkInt32(rm, 0, 8);
  return finalise(x, dp + x.e + 1, rm);
};
P.toExponential = function(dp, rm) {
  var str, x = this, Ctor = x.constructor;
  if (dp === void 0) {
    str = finiteToString(x, true);
  } else {
    checkInt32(dp, 0, MAX_DIGITS);
    if (rm === void 0)
      rm = Ctor.rounding;
    else
      checkInt32(rm, 0, 8);
    x = finalise(new Ctor(x), dp + 1, rm);
    str = finiteToString(x, true, dp + 1);
  }
  return x.isNeg() && !x.isZero() ? "-" + str : str;
};
P.toFixed = function(dp, rm) {
  var str, y, x = this, Ctor = x.constructor;
  if (dp === void 0) {
    str = finiteToString(x);
  } else {
    checkInt32(dp, 0, MAX_DIGITS);
    if (rm === void 0)
      rm = Ctor.rounding;
    else
      checkInt32(rm, 0, 8);
    y = finalise(new Ctor(x), dp + x.e + 1, rm);
    str = finiteToString(y, false, dp + y.e + 1);
  }
  return x.isNeg() && !x.isZero() ? "-" + str : str;
};
P.toFraction = function(maxD) {
  var d, d0, d1, d2, e, k, n, n0, n1, pr, q, r, x = this, xd = x.d, Ctor = x.constructor;
  if (!xd)
    return new Ctor(x);
  n1 = d0 = new Ctor(1);
  d1 = n0 = new Ctor(0);
  d = new Ctor(d1);
  e = d.e = getPrecision(xd) - x.e - 1;
  k = e % LOG_BASE2;
  d.d[0] = mathpow(10, k < 0 ? LOG_BASE2 + k : k);
  if (maxD == null) {
    maxD = e > 0 ? d : n1;
  } else {
    n = new Ctor(maxD);
    if (!n.isInt() || n.lt(n1))
      throw Error(invalidArgument + n);
    maxD = n.gt(d) ? e > 0 ? d : n1 : n;
  }
  external = false;
  n = new Ctor(digitsToString(xd));
  pr = Ctor.precision;
  Ctor.precision = e = xd.length * LOG_BASE2 * 2;
  for (; ; ) {
    q = divide(n, d, 0, 1, 1);
    d2 = d0.plus(q.times(d1));
    if (d2.cmp(maxD) == 1)
      break;
    d0 = d1;
    d1 = d2;
    d2 = n1;
    n1 = n0.plus(q.times(d2));
    n0 = d2;
    d2 = d;
    d = n.minus(q.times(d2));
    n = d2;
  }
  d2 = divide(maxD.minus(d0), d1, 0, 1, 1);
  n0 = n0.plus(d2.times(n1));
  d0 = d0.plus(d2.times(d1));
  n0.s = n1.s = x.s;
  r = divide(n1, d1, e, 1).minus(x).abs().cmp(divide(n0, d0, e, 1).minus(x).abs()) < 1 ? [n1, d1] : [n0, d0];
  Ctor.precision = pr;
  external = true;
  return r;
};
P.toHexadecimal = P.toHex = function(sd, rm) {
  return toStringBinary(this, 16, sd, rm);
};
P.toNearest = function(y, rm) {
  var x = this, Ctor = x.constructor;
  x = new Ctor(x);
  if (y == null) {
    if (!x.d)
      return x;
    y = new Ctor(1);
    rm = Ctor.rounding;
  } else {
    y = new Ctor(y);
    if (rm === void 0) {
      rm = Ctor.rounding;
    } else {
      checkInt32(rm, 0, 8);
    }
    if (!x.d)
      return y.s ? x : y;
    if (!y.d) {
      if (y.s)
        y.s = x.s;
      return y;
    }
  }
  if (y.d[0]) {
    external = false;
    x = divide(x, y, 0, rm, 1).times(y);
    external = true;
    finalise(x);
  } else {
    y.s = x.s;
    x = y;
  }
  return x;
};
P.toNumber = function() {
  return +this;
};
P.toOctal = function(sd, rm) {
  return toStringBinary(this, 8, sd, rm);
};
P.toPower = P.pow = function(y) {
  var e, k, pr, r, rm, s, x = this, Ctor = x.constructor, yn = +(y = new Ctor(y));
  if (!x.d || !y.d || !x.d[0] || !y.d[0])
    return new Ctor(mathpow(+x, yn));
  x = new Ctor(x);
  if (x.eq(1))
    return x;
  pr = Ctor.precision;
  rm = Ctor.rounding;
  if (y.eq(1))
    return finalise(x, pr, rm);
  e = mathfloor2(y.e / LOG_BASE2);
  if (e >= y.d.length - 1 && (k = yn < 0 ? -yn : yn) <= MAX_SAFE_INTEGER2) {
    r = intPow(Ctor, x, k, pr);
    return y.s < 0 ? new Ctor(1).div(r) : finalise(r, pr, rm);
  }
  s = x.s;
  if (s < 0) {
    if (e < y.d.length - 1)
      return new Ctor(NaN);
    if ((y.d[e] & 1) == 0)
      s = 1;
    if (x.e == 0 && x.d[0] == 1 && x.d.length == 1) {
      x.s = s;
      return x;
    }
  }
  k = mathpow(+x, yn);
  e = k == 0 || !isFinite(k) ? mathfloor2(yn * (Math.log("0." + digitsToString(x.d)) / Math.LN10 + x.e + 1)) : new Ctor(k + "").e;
  if (e > Ctor.maxE + 1 || e < Ctor.minE - 1)
    return new Ctor(e > 0 ? s / 0 : 0);
  external = false;
  Ctor.rounding = x.s = 1;
  k = Math.min(12, (e + "").length);
  r = naturalExponential(y.times(naturalLogarithm(x, pr + k)), pr);
  if (r.d) {
    r = finalise(r, pr + 5, 1);
    if (checkRoundingDigits(r.d, pr, rm)) {
      e = pr + 10;
      r = finalise(naturalExponential(y.times(naturalLogarithm(x, e + k)), e), e + 5, 1);
      if (+digitsToString(r.d).slice(pr + 1, pr + 15) + 1 == 1e14) {
        r = finalise(r, pr + 1, 0);
      }
    }
  }
  r.s = s;
  external = true;
  Ctor.rounding = rm;
  return finalise(r, pr, rm);
};
P.toPrecision = function(sd, rm) {
  var str, x = this, Ctor = x.constructor;
  if (sd === void 0) {
    str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);
  } else {
    checkInt32(sd, 1, MAX_DIGITS);
    if (rm === void 0)
      rm = Ctor.rounding;
    else
      checkInt32(rm, 0, 8);
    x = finalise(new Ctor(x), sd, rm);
    str = finiteToString(x, sd <= x.e || x.e <= Ctor.toExpNeg, sd);
  }
  return x.isNeg() && !x.isZero() ? "-" + str : str;
};
P.toSignificantDigits = P.toSD = function(sd, rm) {
  var x = this, Ctor = x.constructor;
  if (sd === void 0) {
    sd = Ctor.precision;
    rm = Ctor.rounding;
  } else {
    checkInt32(sd, 1, MAX_DIGITS);
    if (rm === void 0)
      rm = Ctor.rounding;
    else
      checkInt32(rm, 0, 8);
  }
  return finalise(new Ctor(x), sd, rm);
};
P.toString = function() {
  var x = this, Ctor = x.constructor, str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);
  return x.isNeg() && !x.isZero() ? "-" + str : str;
};
P.truncated = P.trunc = function() {
  return finalise(new this.constructor(this), this.e + 1, 1);
};
P.valueOf = P.toJSON = function() {
  var x = this, Ctor = x.constructor, str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);
  return x.isNeg() ? "-" + str : str;
};
function digitsToString(d) {
  var i, k, ws, indexOfLastWord = d.length - 1, str = "", w = d[0];
  if (indexOfLastWord > 0) {
    str += w;
    for (i = 1; i < indexOfLastWord; i++) {
      ws = d[i] + "";
      k = LOG_BASE2 - ws.length;
      if (k)
        str += getZeroString(k);
      str += ws;
    }
    w = d[i];
    ws = w + "";
    k = LOG_BASE2 - ws.length;
    if (k)
      str += getZeroString(k);
  } else if (w === 0) {
    return "0";
  }
  for (; w % 10 === 0; )
    w /= 10;
  return str + w;
}
function checkInt32(i, min2, max2) {
  if (i !== ~~i || i < min2 || i > max2) {
    throw Error(invalidArgument + i);
  }
}
function checkRoundingDigits(d, i, rm, repeating) {
  var di, k, r, rd;
  for (k = d[0]; k >= 10; k /= 10)
    --i;
  if (--i < 0) {
    i += LOG_BASE2;
    di = 0;
  } else {
    di = Math.ceil((i + 1) / LOG_BASE2);
    i %= LOG_BASE2;
  }
  k = mathpow(10, LOG_BASE2 - i);
  rd = d[di] % k | 0;
  if (repeating == null) {
    if (i < 3) {
      if (i == 0)
        rd = rd / 100 | 0;
      else if (i == 1)
        rd = rd / 10 | 0;
      r = rm < 4 && rd == 99999 || rm > 3 && rd == 49999 || rd == 5e4 || rd == 0;
    } else {
      r = (rm < 4 && rd + 1 == k || rm > 3 && rd + 1 == k / 2) && (d[di + 1] / k / 100 | 0) == mathpow(10, i - 2) - 1 || (rd == k / 2 || rd == 0) && (d[di + 1] / k / 100 | 0) == 0;
    }
  } else {
    if (i < 4) {
      if (i == 0)
        rd = rd / 1e3 | 0;
      else if (i == 1)
        rd = rd / 100 | 0;
      else if (i == 2)
        rd = rd / 10 | 0;
      r = (repeating || rm < 4) && rd == 9999 || !repeating && rm > 3 && rd == 4999;
    } else {
      r = ((repeating || rm < 4) && rd + 1 == k || !repeating && rm > 3 && rd + 1 == k / 2) && (d[di + 1] / k / 1e3 | 0) == mathpow(10, i - 3) - 1;
    }
  }
  return r;
}
function convertBase(str, baseIn, baseOut) {
  var j, arr = [0], arrL, i = 0, strL = str.length;
  for (; i < strL; ) {
    for (arrL = arr.length; arrL--; )
      arr[arrL] *= baseIn;
    arr[0] += NUMERALS.indexOf(str.charAt(i++));
    for (j = 0; j < arr.length; j++) {
      if (arr[j] > baseOut - 1) {
        if (arr[j + 1] === void 0)
          arr[j + 1] = 0;
        arr[j + 1] += arr[j] / baseOut | 0;
        arr[j] %= baseOut;
      }
    }
  }
  return arr.reverse();
}
function cosine(Ctor, x) {
  var k, len, y;
  if (x.isZero())
    return x;
  len = x.d.length;
  if (len < 32) {
    k = Math.ceil(len / 3);
    y = (1 / tinyPow(4, k)).toString();
  } else {
    k = 16;
    y = "2.3283064365386962890625e-10";
  }
  Ctor.precision += k;
  x = taylorSeries(Ctor, 1, x.times(y), new Ctor(1));
  for (var i = k; i--; ) {
    var cos2x = x.times(x);
    x = cos2x.times(cos2x).minus(cos2x).times(8).plus(1);
  }
  Ctor.precision -= k;
  return x;
}
var divide = /* @__PURE__ */ function() {
  function multiplyInteger(x, k, base) {
    var temp, carry = 0, i = x.length;
    for (x = x.slice(); i--; ) {
      temp = x[i] * k + carry;
      x[i] = temp % base | 0;
      carry = temp / base | 0;
    }
    if (carry)
      x.unshift(carry);
    return x;
  }
  function compare2(a, b, aL, bL) {
    var i, r;
    if (aL != bL) {
      r = aL > bL ? 1 : -1;
    } else {
      for (i = r = 0; i < aL; i++) {
        if (a[i] != b[i]) {
          r = a[i] > b[i] ? 1 : -1;
          break;
        }
      }
    }
    return r;
  }
  function subtract(a, b, aL, base) {
    var i = 0;
    for (; aL--; ) {
      a[aL] -= i;
      i = a[aL] < b[aL] ? 1 : 0;
      a[aL] = i * base + a[aL] - b[aL];
    }
    for (; !a[0] && a.length > 1; )
      a.shift();
  }
  return function(x, y, pr, rm, dp, base) {
    var cmp, e, i, k, logBase, more, prod, prodL, q, qd, rem, remL, rem0, sd, t, xi, xL, yd0, yL, yz, Ctor = x.constructor, sign2 = x.s == y.s ? 1 : -1, xd = x.d, yd = y.d;
    if (!xd || !xd[0] || !yd || !yd[0]) {
      return new Ctor(
        // Return NaN if either NaN, or both Infinity or 0.
        !x.s || !y.s || (xd ? yd && xd[0] == yd[0] : !yd) ? NaN : (
          // Return 0 if x is 0 or y is Infinity, or return Infinity as y is 0.
          xd && xd[0] == 0 || !yd ? sign2 * 0 : sign2 / 0
        )
      );
    }
    if (base) {
      logBase = 1;
      e = x.e - y.e;
    } else {
      base = BASE2;
      logBase = LOG_BASE2;
      e = mathfloor2(x.e / logBase) - mathfloor2(y.e / logBase);
    }
    yL = yd.length;
    xL = xd.length;
    q = new Ctor(sign2);
    qd = q.d = [];
    for (i = 0; yd[i] == (xd[i] || 0); i++)
      ;
    if (yd[i] > (xd[i] || 0))
      e--;
    if (pr == null) {
      sd = pr = Ctor.precision;
      rm = Ctor.rounding;
    } else if (dp) {
      sd = pr + (x.e - y.e) + 1;
    } else {
      sd = pr;
    }
    if (sd < 0) {
      qd.push(1);
      more = true;
    } else {
      sd = sd / logBase + 2 | 0;
      i = 0;
      if (yL == 1) {
        k = 0;
        yd = yd[0];
        sd++;
        for (; (i < xL || k) && sd--; i++) {
          t = k * base + (xd[i] || 0);
          qd[i] = t / yd | 0;
          k = t % yd | 0;
        }
        more = k || i < xL;
      } else {
        k = base / (yd[0] + 1) | 0;
        if (k > 1) {
          yd = multiplyInteger(yd, k, base);
          xd = multiplyInteger(xd, k, base);
          yL = yd.length;
          xL = xd.length;
        }
        xi = yL;
        rem = xd.slice(0, yL);
        remL = rem.length;
        for (; remL < yL; )
          rem[remL++] = 0;
        yz = yd.slice();
        yz.unshift(0);
        yd0 = yd[0];
        if (yd[1] >= base / 2)
          ++yd0;
        do {
          k = 0;
          cmp = compare2(yd, rem, yL, remL);
          if (cmp < 0) {
            rem0 = rem[0];
            if (yL != remL)
              rem0 = rem0 * base + (rem[1] || 0);
            k = rem0 / yd0 | 0;
            if (k > 1) {
              if (k >= base)
                k = base - 1;
              prod = multiplyInteger(yd, k, base);
              prodL = prod.length;
              remL = rem.length;
              cmp = compare2(prod, rem, prodL, remL);
              if (cmp == 1) {
                k--;
                subtract(prod, yL < prodL ? yz : yd, prodL, base);
              }
            } else {
              if (k == 0)
                cmp = k = 1;
              prod = yd.slice();
            }
            prodL = prod.length;
            if (prodL < remL)
              prod.unshift(0);
            subtract(rem, prod, remL, base);
            if (cmp == -1) {
              remL = rem.length;
              cmp = compare2(yd, rem, yL, remL);
              if (cmp < 1) {
                k++;
                subtract(rem, yL < remL ? yz : yd, remL, base);
              }
            }
            remL = rem.length;
          } else if (cmp === 0) {
            k++;
            rem = [0];
          }
          qd[i++] = k;
          if (cmp && rem[0]) {
            rem[remL++] = xd[xi] || 0;
          } else {
            rem = [xd[xi]];
            remL = 1;
          }
        } while ((xi++ < xL || rem[0] !== void 0) && sd--);
        more = rem[0] !== void 0;
      }
      if (!qd[0])
        qd.shift();
    }
    if (logBase == 1) {
      q.e = e;
      inexact = more;
    } else {
      for (i = 1, k = qd[0]; k >= 10; k /= 10)
        i++;
      q.e = i + e * logBase - 1;
      finalise(q, dp ? pr + q.e + 1 : pr, rm, more);
    }
    return q;
  };
}();
function finalise(x, sd, rm, isTruncated) {
  var digits, i, j, k, rd, roundUp, w, xd, xdi, Ctor = x.constructor;
  out:
    if (sd != null) {
      xd = x.d;
      if (!xd)
        return x;
      for (digits = 1, k = xd[0]; k >= 10; k /= 10)
        digits++;
      i = sd - digits;
      if (i < 0) {
        i += LOG_BASE2;
        j = sd;
        w = xd[xdi = 0];
        rd = w / mathpow(10, digits - j - 1) % 10 | 0;
      } else {
        xdi = Math.ceil((i + 1) / LOG_BASE2);
        k = xd.length;
        if (xdi >= k) {
          if (isTruncated) {
            for (; k++ <= xdi; )
              xd.push(0);
            w = rd = 0;
            digits = 1;
            i %= LOG_BASE2;
            j = i - LOG_BASE2 + 1;
          } else {
            break out;
          }
        } else {
          w = k = xd[xdi];
          for (digits = 1; k >= 10; k /= 10)
            digits++;
          i %= LOG_BASE2;
          j = i - LOG_BASE2 + digits;
          rd = j < 0 ? 0 : w / mathpow(10, digits - j - 1) % 10 | 0;
        }
      }
      isTruncated = isTruncated || sd < 0 || xd[xdi + 1] !== void 0 || (j < 0 ? w : w % mathpow(10, digits - j - 1));
      roundUp = rm < 4 ? (rd || isTruncated) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : rd > 5 || rd == 5 && (rm == 4 || isTruncated || rm == 6 && // Check whether the digit to the left of the rounding digit is odd.
      (i > 0 ? j > 0 ? w / mathpow(10, digits - j) : 0 : xd[xdi - 1]) % 10 & 1 || rm == (x.s < 0 ? 8 : 7));
      if (sd < 1 || !xd[0]) {
        xd.length = 0;
        if (roundUp) {
          sd -= x.e + 1;
          xd[0] = mathpow(10, (LOG_BASE2 - sd % LOG_BASE2) % LOG_BASE2);
          x.e = -sd || 0;
        } else {
          xd[0] = x.e = 0;
        }
        return x;
      }
      if (i == 0) {
        xd.length = xdi;
        k = 1;
        xdi--;
      } else {
        xd.length = xdi + 1;
        k = mathpow(10, LOG_BASE2 - i);
        xd[xdi] = j > 0 ? (w / mathpow(10, digits - j) % mathpow(10, j) | 0) * k : 0;
      }
      if (roundUp) {
        for (; ; ) {
          if (xdi == 0) {
            for (i = 1, j = xd[0]; j >= 10; j /= 10)
              i++;
            j = xd[0] += k;
            for (k = 1; j >= 10; j /= 10)
              k++;
            if (i != k) {
              x.e++;
              if (xd[0] == BASE2)
                xd[0] = 1;
            }
            break;
          } else {
            xd[xdi] += k;
            if (xd[xdi] != BASE2)
              break;
            xd[xdi--] = 0;
            k = 1;
          }
        }
      }
      for (i = xd.length; xd[--i] === 0; )
        xd.pop();
    }
  if (external) {
    if (x.e > Ctor.maxE) {
      x.d = null;
      x.e = NaN;
    } else if (x.e < Ctor.minE) {
      x.e = 0;
      x.d = [0];
    }
  }
  return x;
}
function finiteToString(x, isExp, sd) {
  if (!x.isFinite())
    return nonFiniteToString(x);
  var k, e = x.e, str = digitsToString(x.d), len = str.length;
  if (isExp) {
    if (sd && (k = sd - len) > 0) {
      str = str.charAt(0) + "." + str.slice(1) + getZeroString(k);
    } else if (len > 1) {
      str = str.charAt(0) + "." + str.slice(1);
    }
    str = str + (x.e < 0 ? "e" : "e+") + x.e;
  } else if (e < 0) {
    str = "0." + getZeroString(-e - 1) + str;
    if (sd && (k = sd - len) > 0)
      str += getZeroString(k);
  } else if (e >= len) {
    str += getZeroString(e + 1 - len);
    if (sd && (k = sd - e - 1) > 0)
      str = str + "." + getZeroString(k);
  } else {
    if ((k = e + 1) < len)
      str = str.slice(0, k) + "." + str.slice(k);
    if (sd && (k = sd - len) > 0) {
      if (e + 1 === len)
        str += ".";
      str += getZeroString(k);
    }
  }
  return str;
}
function getBase10Exponent(digits, e) {
  var w = digits[0];
  for (e *= LOG_BASE2; w >= 10; w /= 10)
    e++;
  return e;
}
function getLn10(Ctor, sd, pr) {
  if (sd > LN10_PRECISION) {
    external = true;
    if (pr)
      Ctor.precision = pr;
    throw Error(precisionLimitExceeded);
  }
  return finalise(new Ctor(LN10), sd, 1, true);
}
function getPi(Ctor, sd, rm) {
  if (sd > PI_PRECISION)
    throw Error(precisionLimitExceeded);
  return finalise(new Ctor(PI), sd, rm, true);
}
function getPrecision(digits) {
  var w = digits.length - 1, len = w * LOG_BASE2 + 1;
  w = digits[w];
  if (w) {
    for (; w % 10 == 0; w /= 10)
      len--;
    for (w = digits[0]; w >= 10; w /= 10)
      len++;
  }
  return len;
}
function getZeroString(k) {
  var zs = "";
  for (; k--; )
    zs += "0";
  return zs;
}
function intPow(Ctor, x, n, pr) {
  var isTruncated, r = new Ctor(1), k = Math.ceil(pr / LOG_BASE2 + 4);
  external = false;
  for (; ; ) {
    if (n % 2) {
      r = r.times(x);
      if (truncate(r.d, k))
        isTruncated = true;
    }
    n = mathfloor2(n / 2);
    if (n === 0) {
      n = r.d.length - 1;
      if (isTruncated && r.d[n] === 0)
        ++r.d[n];
      break;
    }
    x = x.times(x);
    truncate(x.d, k);
  }
  external = true;
  return r;
}
function isOdd2(n) {
  return n.d[n.d.length - 1] & 1;
}
function maxOrMin(Ctor, args, n) {
  var k, y, x = new Ctor(args[0]), i = 0;
  for (; ++i < args.length; ) {
    y = new Ctor(args[i]);
    if (!y.s) {
      x = y;
      break;
    }
    k = x.cmp(y);
    if (k === n || k === 0 && x.s === n) {
      x = y;
    }
  }
  return x;
}
function naturalExponential(x, sd) {
  var denominator, guard, j, pow3, sum2, t, wpr, rep = 0, i = 0, k = 0, Ctor = x.constructor, rm = Ctor.rounding, pr = Ctor.precision;
  if (!x.d || !x.d[0] || x.e > 17) {
    return new Ctor(x.d ? !x.d[0] ? 1 : x.s < 0 ? 0 : 1 / 0 : x.s ? x.s < 0 ? 0 : x : 0 / 0);
  }
  if (sd == null) {
    external = false;
    wpr = pr;
  } else {
    wpr = sd;
  }
  t = new Ctor(0.03125);
  while (x.e > -2) {
    x = x.times(t);
    k += 5;
  }
  guard = Math.log(mathpow(2, k)) / Math.LN10 * 2 + 5 | 0;
  wpr += guard;
  denominator = pow3 = sum2 = new Ctor(1);
  Ctor.precision = wpr;
  for (; ; ) {
    pow3 = finalise(pow3.times(x), wpr, 1);
    denominator = denominator.times(++i);
    t = sum2.plus(divide(pow3, denominator, wpr, 1));
    if (digitsToString(t.d).slice(0, wpr) === digitsToString(sum2.d).slice(0, wpr)) {
      j = k;
      while (j--)
        sum2 = finalise(sum2.times(sum2), wpr, 1);
      if (sd == null) {
        if (rep < 3 && checkRoundingDigits(sum2.d, wpr - guard, rm, rep)) {
          Ctor.precision = wpr += 10;
          denominator = pow3 = t = new Ctor(1);
          i = 0;
          rep++;
        } else {
          return finalise(sum2, Ctor.precision = pr, rm, external = true);
        }
      } else {
        Ctor.precision = pr;
        return sum2;
      }
    }
    sum2 = t;
  }
}
function naturalLogarithm(y, sd) {
  var c, c0, denominator, e, numerator, rep, sum2, t, wpr, x1, x2, n = 1, guard = 10, x = y, xd = x.d, Ctor = x.constructor, rm = Ctor.rounding, pr = Ctor.precision;
  if (x.s < 0 || !xd || !xd[0] || !x.e && xd[0] == 1 && xd.length == 1) {
    return new Ctor(xd && !xd[0] ? -1 / 0 : x.s != 1 ? NaN : xd ? 0 : x);
  }
  if (sd == null) {
    external = false;
    wpr = pr;
  } else {
    wpr = sd;
  }
  Ctor.precision = wpr += guard;
  c = digitsToString(xd);
  c0 = c.charAt(0);
  if (Math.abs(e = x.e) < 15e14) {
    while (c0 < 7 && c0 != 1 || c0 == 1 && c.charAt(1) > 3) {
      x = x.times(y);
      c = digitsToString(x.d);
      c0 = c.charAt(0);
      n++;
    }
    e = x.e;
    if (c0 > 1) {
      x = new Ctor("0." + c);
      e++;
    } else {
      x = new Ctor(c0 + "." + c.slice(1));
    }
  } else {
    t = getLn10(Ctor, wpr + 2, pr).times(e + "");
    x = naturalLogarithm(new Ctor(c0 + "." + c.slice(1)), wpr - guard).plus(t);
    Ctor.precision = pr;
    return sd == null ? finalise(x, pr, rm, external = true) : x;
  }
  x1 = x;
  sum2 = numerator = x = divide(x.minus(1), x.plus(1), wpr, 1);
  x2 = finalise(x.times(x), wpr, 1);
  denominator = 3;
  for (; ; ) {
    numerator = finalise(numerator.times(x2), wpr, 1);
    t = sum2.plus(divide(numerator, new Ctor(denominator), wpr, 1));
    if (digitsToString(t.d).slice(0, wpr) === digitsToString(sum2.d).slice(0, wpr)) {
      sum2 = sum2.times(2);
      if (e !== 0)
        sum2 = sum2.plus(getLn10(Ctor, wpr + 2, pr).times(e + ""));
      sum2 = divide(sum2, new Ctor(n), wpr, 1);
      if (sd == null) {
        if (checkRoundingDigits(sum2.d, wpr - guard, rm, rep)) {
          Ctor.precision = wpr += guard;
          t = numerator = x = divide(x1.minus(1), x1.plus(1), wpr, 1);
          x2 = finalise(x.times(x), wpr, 1);
          denominator = rep = 1;
        } else {
          return finalise(sum2, Ctor.precision = pr, rm, external = true);
        }
      } else {
        Ctor.precision = pr;
        return sum2;
      }
    }
    sum2 = t;
    denominator += 2;
  }
}
function nonFiniteToString(x) {
  return String(x.s * x.s / 0);
}
function parseDecimal(x, str) {
  var e, i, len;
  if ((e = str.indexOf(".")) > -1)
    str = str.replace(".", "");
  if ((i = str.search(/e/i)) > 0) {
    if (e < 0)
      e = i;
    e += +str.slice(i + 1);
    str = str.substring(0, i);
  } else if (e < 0) {
    e = str.length;
  }
  for (i = 0; str.charCodeAt(i) === 48; i++)
    ;
  for (len = str.length; str.charCodeAt(len - 1) === 48; --len)
    ;
  str = str.slice(i, len);
  if (str) {
    len -= i;
    x.e = e = e - i - 1;
    x.d = [];
    i = (e + 1) % LOG_BASE2;
    if (e < 0)
      i += LOG_BASE2;
    if (i < len) {
      if (i)
        x.d.push(+str.slice(0, i));
      for (len -= LOG_BASE2; i < len; )
        x.d.push(+str.slice(i, i += LOG_BASE2));
      str = str.slice(i);
      i = LOG_BASE2 - str.length;
    } else {
      i -= len;
    }
    for (; i--; )
      str += "0";
    x.d.push(+str);
    if (external) {
      if (x.e > x.constructor.maxE) {
        x.d = null;
        x.e = NaN;
      } else if (x.e < x.constructor.minE) {
        x.e = 0;
        x.d = [0];
      }
    }
  } else {
    x.e = 0;
    x.d = [0];
  }
  return x;
}
function parseOther(x, str) {
  var base, Ctor, divisor, i, isFloat, len, p, xd, xe;
  if (str.indexOf("_") > -1) {
    str = str.replace(/(\d)_(?=\d)/g, "$1");
    if (isDecimal.test(str))
      return parseDecimal(x, str);
  } else if (str === "Infinity" || str === "NaN") {
    if (!+str)
      x.s = NaN;
    x.e = NaN;
    x.d = null;
    return x;
  }
  if (isHex.test(str)) {
    base = 16;
    str = str.toLowerCase();
  } else if (isBinary.test(str)) {
    base = 2;
  } else if (isOctal.test(str)) {
    base = 8;
  } else {
    throw Error(invalidArgument + str);
  }
  i = str.search(/p/i);
  if (i > 0) {
    p = +str.slice(i + 1);
    str = str.substring(2, i);
  } else {
    str = str.slice(2);
  }
  i = str.indexOf(".");
  isFloat = i >= 0;
  Ctor = x.constructor;
  if (isFloat) {
    str = str.replace(".", "");
    len = str.length;
    i = len - i;
    divisor = intPow(Ctor, new Ctor(base), i, i * 2);
  }
  xd = convertBase(str, base, BASE2);
  xe = xd.length - 1;
  for (i = xe; xd[i] === 0; --i)
    xd.pop();
  if (i < 0)
    return new Ctor(x.s * 0);
  x.e = getBase10Exponent(xd, xe);
  x.d = xd;
  external = false;
  if (isFloat)
    x = divide(x, divisor, len * 4);
  if (p)
    x = x.times(Math.abs(p) < 54 ? mathpow(2, p) : Decimal.pow(2, p));
  external = true;
  return x;
}
function sine(Ctor, x) {
  var k, len = x.d.length;
  if (len < 3) {
    return x.isZero() ? x : taylorSeries(Ctor, 2, x, x);
  }
  k = 1.4 * Math.sqrt(len);
  k = k > 16 ? 16 : k | 0;
  x = x.times(1 / tinyPow(5, k));
  x = taylorSeries(Ctor, 2, x, x);
  var sin2_x, d5 = new Ctor(5), d16 = new Ctor(16), d20 = new Ctor(20);
  for (; k--; ) {
    sin2_x = x.times(x);
    x = x.times(d5.plus(sin2_x.times(d16.times(sin2_x).minus(d20))));
  }
  return x;
}
function taylorSeries(Ctor, n, x, y, isHyperbolic) {
  var j, t, u, x2, i = 1, pr = Ctor.precision, k = Math.ceil(pr / LOG_BASE2);
  external = false;
  x2 = x.times(x);
  u = new Ctor(y);
  for (; ; ) {
    t = divide(u.times(x2), new Ctor(n++ * n++), pr, 1);
    u = isHyperbolic ? y.plus(t) : y.minus(t);
    y = divide(t.times(x2), new Ctor(n++ * n++), pr, 1);
    t = u.plus(y);
    if (t.d[k] !== void 0) {
      for (j = k; t.d[j] === u.d[j] && j--; )
        ;
      if (j == -1)
        break;
    }
    j = u;
    u = y;
    y = t;
    t = j;
    i++;
  }
  external = true;
  t.d.length = k + 1;
  return t;
}
function tinyPow(b, e) {
  var n = b;
  while (--e)
    n *= b;
  return n;
}
function toLessThanHalfPi(Ctor, x) {
  var t, isNeg = x.s < 0, pi = getPi(Ctor, Ctor.precision, 1), halfPi = pi.times(0.5);
  x = x.abs();
  if (x.lte(halfPi)) {
    quadrant = isNeg ? 4 : 1;
    return x;
  }
  t = x.divToInt(pi);
  if (t.isZero()) {
    quadrant = isNeg ? 3 : 2;
  } else {
    x = x.minus(t.times(pi));
    if (x.lte(halfPi)) {
      quadrant = isOdd2(t) ? isNeg ? 2 : 3 : isNeg ? 4 : 1;
      return x;
    }
    quadrant = isOdd2(t) ? isNeg ? 1 : 4 : isNeg ? 3 : 2;
  }
  return x.minus(pi).abs();
}
function toStringBinary(x, baseOut, sd, rm) {
  var base, e, i, k, len, roundUp, str, xd, y, Ctor = x.constructor, isExp = sd !== void 0;
  if (isExp) {
    checkInt32(sd, 1, MAX_DIGITS);
    if (rm === void 0)
      rm = Ctor.rounding;
    else
      checkInt32(rm, 0, 8);
  } else {
    sd = Ctor.precision;
    rm = Ctor.rounding;
  }
  if (!x.isFinite()) {
    str = nonFiniteToString(x);
  } else {
    str = finiteToString(x);
    i = str.indexOf(".");
    if (isExp) {
      base = 2;
      if (baseOut == 16) {
        sd = sd * 4 - 3;
      } else if (baseOut == 8) {
        sd = sd * 3 - 2;
      }
    } else {
      base = baseOut;
    }
    if (i >= 0) {
      str = str.replace(".", "");
      y = new Ctor(1);
      y.e = str.length - i;
      y.d = convertBase(finiteToString(y), 10, base);
      y.e = y.d.length;
    }
    xd = convertBase(str, 10, base);
    e = len = xd.length;
    for (; xd[--len] == 0; )
      xd.pop();
    if (!xd[0]) {
      str = isExp ? "0p+0" : "0";
    } else {
      if (i < 0) {
        e--;
      } else {
        x = new Ctor(x);
        x.d = xd;
        x.e = e;
        x = divide(x, y, sd, rm, 0, base);
        xd = x.d;
        e = x.e;
        roundUp = inexact;
      }
      i = xd[sd];
      k = base / 2;
      roundUp = roundUp || xd[sd + 1] !== void 0;
      roundUp = rm < 4 ? (i !== void 0 || roundUp) && (rm === 0 || rm === (x.s < 0 ? 3 : 2)) : i > k || i === k && (rm === 4 || roundUp || rm === 6 && xd[sd - 1] & 1 || rm === (x.s < 0 ? 8 : 7));
      xd.length = sd;
      if (roundUp) {
        for (; ++xd[--sd] > base - 1; ) {
          xd[sd] = 0;
          if (!sd) {
            ++e;
            xd.unshift(1);
          }
        }
      }
      for (len = xd.length; !xd[len - 1]; --len)
        ;
      for (i = 0, str = ""; i < len; i++)
        str += NUMERALS.charAt(xd[i]);
      if (isExp) {
        if (len > 1) {
          if (baseOut == 16 || baseOut == 8) {
            i = baseOut == 16 ? 4 : 3;
            for (--len; len % i; len++)
              str += "0";
            xd = convertBase(str, base, baseOut);
            for (len = xd.length; !xd[len - 1]; --len)
              ;
            for (i = 1, str = "1."; i < len; i++)
              str += NUMERALS.charAt(xd[i]);
          } else {
            str = str.charAt(0) + "." + str.slice(1);
          }
        }
        str = str + (e < 0 ? "p" : "p+") + e;
      } else if (e < 0) {
        for (; ++e; )
          str = "0" + str;
        str = "0." + str;
      } else {
        if (++e > len)
          for (e -= len; e--; )
            str += "0";
        else if (e < len)
          str = str.slice(0, e) + "." + str.slice(e);
      }
    }
    str = (baseOut == 16 ? "0x" : baseOut == 2 ? "0b" : baseOut == 8 ? "0o" : "") + str;
  }
  return x.s < 0 ? "-" + str : str;
}
function truncate(arr, len) {
  if (arr.length > len) {
    arr.length = len;
    return true;
  }
}
function abs(x) {
  return new this(x).abs();
}
function acos(x) {
  return new this(x).acos();
}
function acosh(x) {
  return new this(x).acosh();
}
function add(x, y) {
  return new this(x).plus(y);
}
function asin(x) {
  return new this(x).asin();
}
function asinh(x) {
  return new this(x).asinh();
}
function atan(x) {
  return new this(x).atan();
}
function atanh(x) {
  return new this(x).atanh();
}
function atan2(y, x) {
  y = new this(y);
  x = new this(x);
  var r, pr = this.precision, rm = this.rounding, wpr = pr + 4;
  if (!y.s || !x.s) {
    r = new this(NaN);
  } else if (!y.d && !x.d) {
    r = getPi(this, wpr, 1).times(x.s > 0 ? 0.25 : 0.75);
    r.s = y.s;
  } else if (!x.d || y.isZero()) {
    r = x.s < 0 ? getPi(this, pr, rm) : new this(0);
    r.s = y.s;
  } else if (!y.d || x.isZero()) {
    r = getPi(this, wpr, 1).times(0.5);
    r.s = y.s;
  } else if (x.s < 0) {
    this.precision = wpr;
    this.rounding = 1;
    r = this.atan(divide(y, x, wpr, 1));
    x = getPi(this, wpr, 1);
    this.precision = pr;
    this.rounding = rm;
    r = y.s < 0 ? r.minus(x) : r.plus(x);
  } else {
    r = this.atan(divide(y, x, wpr, 1));
  }
  return r;
}
function cbrt(x) {
  return new this(x).cbrt();
}
function ceil(x) {
  return finalise(x = new this(x), x.e + 1, 2);
}
function clamp(x, min2, max2) {
  return new this(x).clamp(min2, max2);
}
function config(obj) {
  if (!obj || typeof obj !== "object")
    throw Error(decimalError + "Object expected");
  var i, p, v, useDefaults = obj.defaults === true, ps = [
    "precision",
    1,
    MAX_DIGITS,
    "rounding",
    0,
    8,
    "toExpNeg",
    -EXP_LIMIT,
    0,
    "toExpPos",
    0,
    EXP_LIMIT,
    "maxE",
    0,
    EXP_LIMIT,
    "minE",
    -EXP_LIMIT,
    0,
    "modulo",
    0,
    9
  ];
  for (i = 0; i < ps.length; i += 3) {
    if (p = ps[i], useDefaults)
      this[p] = DEFAULTS[p];
    if ((v = obj[p]) !== void 0) {
      if (mathfloor2(v) === v && v >= ps[i + 1] && v <= ps[i + 2])
        this[p] = v;
      else
        throw Error(invalidArgument + p + ": " + v);
    }
  }
  if (p = "crypto", useDefaults)
    this[p] = DEFAULTS[p];
  if ((v = obj[p]) !== void 0) {
    if (v === true || v === false || v === 0 || v === 1) {
      if (v) {
        if (typeof crypto != "undefined" && crypto && (crypto.getRandomValues || crypto.randomBytes)) {
          this[p] = true;
        } else {
          throw Error(cryptoUnavailable);
        }
      } else {
        this[p] = false;
      }
    } else {
      throw Error(invalidArgument + p + ": " + v);
    }
  }
  return this;
}
function cos(x) {
  return new this(x).cos();
}
function cosh(x) {
  return new this(x).cosh();
}
function clone2(obj) {
  var i, p, ps;
  function Decimal2(v) {
    var e, i2, t, x = this;
    if (!(x instanceof Decimal2))
      return new Decimal2(v);
    x.constructor = Decimal2;
    if (isDecimalInstance(v)) {
      x.s = v.s;
      if (external) {
        if (!v.d || v.e > Decimal2.maxE) {
          x.e = NaN;
          x.d = null;
        } else if (v.e < Decimal2.minE) {
          x.e = 0;
          x.d = [0];
        } else {
          x.e = v.e;
          x.d = v.d.slice();
        }
      } else {
        x.e = v.e;
        x.d = v.d ? v.d.slice() : v.d;
      }
      return;
    }
    t = typeof v;
    if (t === "number") {
      if (v === 0) {
        x.s = 1 / v < 0 ? -1 : 1;
        x.e = 0;
        x.d = [0];
        return;
      }
      if (v < 0) {
        v = -v;
        x.s = -1;
      } else {
        x.s = 1;
      }
      if (v === ~~v && v < 1e7) {
        for (e = 0, i2 = v; i2 >= 10; i2 /= 10)
          e++;
        if (external) {
          if (e > Decimal2.maxE) {
            x.e = NaN;
            x.d = null;
          } else if (e < Decimal2.minE) {
            x.e = 0;
            x.d = [0];
          } else {
            x.e = e;
            x.d = [v];
          }
        } else {
          x.e = e;
          x.d = [v];
        }
        return;
      }
      if (v * 0 !== 0) {
        if (!v)
          x.s = NaN;
        x.e = NaN;
        x.d = null;
        return;
      }
      return parseDecimal(x, v.toString());
    }
    if (t === "string") {
      if ((i2 = v.charCodeAt(0)) === 45) {
        v = v.slice(1);
        x.s = -1;
      } else {
        if (i2 === 43)
          v = v.slice(1);
        x.s = 1;
      }
      return isDecimal.test(v) ? parseDecimal(x, v) : parseOther(x, v);
    }
    if (t === "bigint") {
      if (v < 0) {
        v = -v;
        x.s = -1;
      } else {
        x.s = 1;
      }
      return parseDecimal(x, v.toString());
    }
    throw Error(invalidArgument + v);
  }
  Decimal2.prototype = P;
  Decimal2.ROUND_UP = 0;
  Decimal2.ROUND_DOWN = 1;
  Decimal2.ROUND_CEIL = 2;
  Decimal2.ROUND_FLOOR = 3;
  Decimal2.ROUND_HALF_UP = 4;
  Decimal2.ROUND_HALF_DOWN = 5;
  Decimal2.ROUND_HALF_EVEN = 6;
  Decimal2.ROUND_HALF_CEIL = 7;
  Decimal2.ROUND_HALF_FLOOR = 8;
  Decimal2.EUCLID = 9;
  Decimal2.config = Decimal2.set = config;
  Decimal2.clone = clone2;
  Decimal2.isDecimal = isDecimalInstance;
  Decimal2.abs = abs;
  Decimal2.acos = acos;
  Decimal2.acosh = acosh;
  Decimal2.add = add;
  Decimal2.asin = asin;
  Decimal2.asinh = asinh;
  Decimal2.atan = atan;
  Decimal2.atanh = atanh;
  Decimal2.atan2 = atan2;
  Decimal2.cbrt = cbrt;
  Decimal2.ceil = ceil;
  Decimal2.clamp = clamp;
  Decimal2.cos = cos;
  Decimal2.cosh = cosh;
  Decimal2.div = div;
  Decimal2.exp = exp;
  Decimal2.floor = floor;
  Decimal2.hypot = hypot;
  Decimal2.ln = ln;
  Decimal2.log = log;
  Decimal2.log10 = log10;
  Decimal2.log2 = log2;
  Decimal2.max = max;
  Decimal2.min = min;
  Decimal2.mod = mod;
  Decimal2.mul = mul;
  Decimal2.pow = pow;
  Decimal2.random = random;
  Decimal2.round = round;
  Decimal2.sign = sign;
  Decimal2.sin = sin;
  Decimal2.sinh = sinh;
  Decimal2.sqrt = sqrt;
  Decimal2.sub = sub;
  Decimal2.sum = sum;
  Decimal2.tan = tan;
  Decimal2.tanh = tanh;
  Decimal2.trunc = trunc;
  if (obj === void 0)
    obj = {};
  if (obj) {
    if (obj.defaults !== true) {
      ps = ["precision", "rounding", "toExpNeg", "toExpPos", "maxE", "minE", "modulo", "crypto"];
      for (i = 0; i < ps.length; )
        if (!obj.hasOwnProperty(p = ps[i++]))
          obj[p] = this[p];
    }
  }
  Decimal2.config(obj);
  return Decimal2;
}
function div(x, y) {
  return new this(x).div(y);
}
function exp(x) {
  return new this(x).exp();
}
function floor(x) {
  return finalise(x = new this(x), x.e + 1, 3);
}
function hypot() {
  var i, n, t = new this(0);
  external = false;
  for (i = 0; i < arguments.length; ) {
    n = new this(arguments[i++]);
    if (!n.d) {
      if (n.s) {
        external = true;
        return new this(1 / 0);
      }
      t = n;
    } else if (t.d) {
      t = t.plus(n.times(n));
    }
  }
  external = true;
  return t.sqrt();
}
function isDecimalInstance(obj) {
  return obj instanceof Decimal || obj && obj.toStringTag === tag || false;
}
function ln(x) {
  return new this(x).ln();
}
function log(x, y) {
  return new this(x).log(y);
}
function log2(x) {
  return new this(x).log(2);
}
function log10(x) {
  return new this(x).log(10);
}
function max() {
  return maxOrMin(this, arguments, -1);
}
function min() {
  return maxOrMin(this, arguments, 1);
}
function mod(x, y) {
  return new this(x).mod(y);
}
function mul(x, y) {
  return new this(x).mul(y);
}
function pow(x, y) {
  return new this(x).pow(y);
}
function random(sd) {
  var d, e, k, n, i = 0, r = new this(1), rd = [];
  if (sd === void 0)
    sd = this.precision;
  else
    checkInt32(sd, 1, MAX_DIGITS);
  k = Math.ceil(sd / LOG_BASE2);
  if (!this.crypto) {
    for (; i < k; )
      rd[i++] = Math.random() * 1e7 | 0;
  } else if (crypto.getRandomValues) {
    d = crypto.getRandomValues(new Uint32Array(k));
    for (; i < k; ) {
      n = d[i];
      if (n >= 429e7) {
        d[i] = crypto.getRandomValues(new Uint32Array(1))[0];
      } else {
        rd[i++] = n % 1e7;
      }
    }
  } else if (crypto.randomBytes) {
    d = crypto.randomBytes(k *= 4);
    for (; i < k; ) {
      n = d[i] + (d[i + 1] << 8) + (d[i + 2] << 16) + ((d[i + 3] & 127) << 24);
      if (n >= 214e7) {
        crypto.randomBytes(4).copy(d, i);
      } else {
        rd.push(n % 1e7);
        i += 4;
      }
    }
    i = k / 4;
  } else {
    throw Error(cryptoUnavailable);
  }
  k = rd[--i];
  sd %= LOG_BASE2;
  if (k && sd) {
    n = mathpow(10, LOG_BASE2 - sd);
    rd[i] = (k / n | 0) * n;
  }
  for (; rd[i] === 0; i--)
    rd.pop();
  if (i < 0) {
    e = 0;
    rd = [0];
  } else {
    e = -1;
    for (; rd[0] === 0; e -= LOG_BASE2)
      rd.shift();
    for (k = 1, n = rd[0]; n >= 10; n /= 10)
      k++;
    if (k < LOG_BASE2)
      e -= LOG_BASE2 - k;
  }
  r.e = e;
  r.d = rd;
  return r;
}
function round(x) {
  return finalise(x = new this(x), x.e + 1, this.rounding);
}
function sign(x) {
  x = new this(x);
  return x.d ? x.d[0] ? x.s : 0 * x.s : x.s || NaN;
}
function sin(x) {
  return new this(x).sin();
}
function sinh(x) {
  return new this(x).sinh();
}
function sqrt(x) {
  return new this(x).sqrt();
}
function sub(x, y) {
  return new this(x).sub(y);
}
function sum() {
  var i = 0, args = arguments, x = new this(args[i]);
  external = false;
  for (; x.s && ++i < args.length; )
    x = x.plus(args[i]);
  external = true;
  return finalise(x, this.precision, this.rounding);
}
function tan(x) {
  return new this(x).tan();
}
function tanh(x) {
  return new this(x).tanh();
}
function trunc(x) {
  return finalise(x = new this(x), x.e + 1, 1);
}
P[Symbol.for("nodejs.util.inspect.custom")] = P.toString;
P[Symbol.toStringTag] = "Decimal";
var Decimal = P.constructor = clone2(DEFAULTS);
LN10 = new Decimal(LN10);
PI = new Decimal(PI);
var decimal_default = Decimal;

// node_modules/@meteora-ag/dlmm/dist/index.mjs
var import_web312 = require("@solana/web3.js");
var import_anchor2 = require("@coral-xyz/anchor");
var import_anchor3 = require("@coral-xyz/anchor");
var import_anchor4 = require("@coral-xyz/anchor");
var import_web313 = require("@solana/web3.js");
var import_anchor5 = require("@coral-xyz/anchor");
var import_web314 = require("@solana/web3.js");
var import_borsh = __toESM(require_dist(), 1);
var import_anchor6 = require("@coral-xyz/anchor");
var import_web315 = require("@solana/web3.js");
var import_anchor7 = require("@coral-xyz/anchor");
var import_bn = __toESM(require_bn(), 1);
var import_anchor8 = require("@coral-xyz/anchor");
var import_gaussian = __toESM(require_gaussian(), 1);
var import_anchor9 = require("@coral-xyz/anchor");
var import_web316 = require("@solana/web3.js");
var import_bn2 = __toESM(require_bn(), 1);
var import_web317 = require("@solana/web3.js");
var import_web318 = require("@solana/web3.js");
var import_bn3 = __toESM(require_bn(), 1);
var import_bn4 = __toESM(require_bn(), 1);
var import_web319 = require("@solana/web3.js");
var import_bn5 = __toESM(require_bn(), 1);
var import_anchor10 = require("@coral-xyz/anchor");
var import_bn6 = __toESM(require_bn(), 1);
var import_bn7 = __toESM(require_bn(), 1);
var import_bn8 = __toESM(require_bn(), 1);
var import_bn9 = __toESM(require_bn(), 1);
var import_web320 = require("@solana/web3.js");
var import_anchor11 = require("@coral-xyz/anchor");
var import_bytes = require("@coral-xyz/anchor/dist/cjs/utils/bytes");
var import_bn10 = __toESM(require_bn(), 1);
var import_bn11 = __toESM(require_bn(), 1);
var dlmm_default = {
  address: "LBUZKhRxPF3XUpBCjp4YzTKgLccjZhTSDM9YuVaPwxo",
  metadata: {
    name: "lb_clmm",
    version: "0.10.1",
    spec: "0.1.0",
    description: "Created with Anchor"
  },
  instructions: [
    {
      name: "add_liquidity",
      discriminator: [181, 157, 89, 67, 143, 182, 52, 72],
      accounts: [
        {
          name: "position",
          writable: true
        },
        {
          name: "lb_pair",
          writable: true,
          relations: [
            "position",
            "bin_array_bitmap_extension",
            "bin_array_lower",
            "bin_array_upper"
          ]
        },
        {
          name: "bin_array_bitmap_extension",
          writable: true,
          optional: true
        },
        {
          name: "user_token_x",
          writable: true
        },
        {
          name: "user_token_y",
          writable: true
        },
        {
          name: "reserve_x",
          writable: true,
          relations: ["lb_pair"]
        },
        {
          name: "reserve_y",
          writable: true,
          relations: ["lb_pair"]
        },
        {
          name: "token_x_mint",
          relations: ["lb_pair"]
        },
        {
          name: "token_y_mint",
          relations: ["lb_pair"]
        },
        {
          name: "bin_array_lower",
          writable: true
        },
        {
          name: "bin_array_upper",
          writable: true
        },
        {
          name: "sender",
          signer: true
        },
        {
          name: "token_x_program",
          address: "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA"
        },
        {
          name: "token_y_program",
          address: "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA"
        },
        {
          name: "event_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  95,
                  95,
                  101,
                  118,
                  101,
                  110,
                  116,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              }
            ]
          }
        },
        {
          name: "program"
        }
      ],
      args: [
        {
          name: "liquidity_parameter",
          type: {
            defined: {
              name: "LiquidityParameter"
            }
          }
        }
      ]
    },
    {
      name: "add_liquidity2",
      discriminator: [228, 162, 78, 28, 70, 219, 116, 115],
      accounts: [
        {
          name: "position",
          writable: true
        },
        {
          name: "lb_pair",
          writable: true,
          relations: ["position", "bin_array_bitmap_extension"]
        },
        {
          name: "bin_array_bitmap_extension",
          writable: true,
          optional: true
        },
        {
          name: "user_token_x",
          writable: true
        },
        {
          name: "user_token_y",
          writable: true
        },
        {
          name: "reserve_x",
          writable: true,
          relations: ["lb_pair"]
        },
        {
          name: "reserve_y",
          writable: true,
          relations: ["lb_pair"]
        },
        {
          name: "token_x_mint",
          relations: ["lb_pair"]
        },
        {
          name: "token_y_mint",
          relations: ["lb_pair"]
        },
        {
          name: "sender",
          signer: true
        },
        {
          name: "token_x_program"
        },
        {
          name: "token_y_program"
        },
        {
          name: "event_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  95,
                  95,
                  101,
                  118,
                  101,
                  110,
                  116,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              }
            ]
          }
        },
        {
          name: "program"
        }
      ],
      args: [
        {
          name: "liquidity_parameter",
          type: {
            defined: {
              name: "LiquidityParameter"
            }
          }
        },
        {
          name: "remaining_accounts_info",
          type: {
            defined: {
              name: "RemainingAccountsInfo"
            }
          }
        }
      ]
    },
    {
      name: "add_liquidity_by_strategy",
      discriminator: [7, 3, 150, 127, 148, 40, 61, 200],
      accounts: [
        {
          name: "position",
          writable: true
        },
        {
          name: "lb_pair",
          writable: true,
          relations: [
            "position",
            "bin_array_bitmap_extension",
            "bin_array_lower",
            "bin_array_upper"
          ]
        },
        {
          name: "bin_array_bitmap_extension",
          writable: true,
          optional: true
        },
        {
          name: "user_token_x",
          writable: true
        },
        {
          name: "user_token_y",
          writable: true
        },
        {
          name: "reserve_x",
          writable: true,
          relations: ["lb_pair"]
        },
        {
          name: "reserve_y",
          writable: true,
          relations: ["lb_pair"]
        },
        {
          name: "token_x_mint",
          relations: ["lb_pair"]
        },
        {
          name: "token_y_mint",
          relations: ["lb_pair"]
        },
        {
          name: "bin_array_lower",
          writable: true
        },
        {
          name: "bin_array_upper",
          writable: true
        },
        {
          name: "sender",
          signer: true
        },
        {
          name: "token_x_program",
          address: "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA"
        },
        {
          name: "token_y_program",
          address: "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA"
        },
        {
          name: "event_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  95,
                  95,
                  101,
                  118,
                  101,
                  110,
                  116,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              }
            ]
          }
        },
        {
          name: "program"
        }
      ],
      args: [
        {
          name: "liquidity_parameter",
          type: {
            defined: {
              name: "LiquidityParameterByStrategy"
            }
          }
        }
      ]
    },
    {
      name: "add_liquidity_by_strategy2",
      discriminator: [3, 221, 149, 218, 111, 141, 118, 213],
      accounts: [
        {
          name: "position",
          writable: true
        },
        {
          name: "lb_pair",
          writable: true,
          relations: ["position", "bin_array_bitmap_extension"]
        },
        {
          name: "bin_array_bitmap_extension",
          writable: true,
          optional: true
        },
        {
          name: "user_token_x",
          writable: true
        },
        {
          name: "user_token_y",
          writable: true
        },
        {
          name: "reserve_x",
          writable: true,
          relations: ["lb_pair"]
        },
        {
          name: "reserve_y",
          writable: true,
          relations: ["lb_pair"]
        },
        {
          name: "token_x_mint",
          relations: ["lb_pair"]
        },
        {
          name: "token_y_mint",
          relations: ["lb_pair"]
        },
        {
          name: "sender",
          signer: true
        },
        {
          name: "token_x_program"
        },
        {
          name: "token_y_program"
        },
        {
          name: "event_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  95,
                  95,
                  101,
                  118,
                  101,
                  110,
                  116,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              }
            ]
          }
        },
        {
          name: "program"
        }
      ],
      args: [
        {
          name: "liquidity_parameter",
          type: {
            defined: {
              name: "LiquidityParameterByStrategy"
            }
          }
        },
        {
          name: "remaining_accounts_info",
          type: {
            defined: {
              name: "RemainingAccountsInfo"
            }
          }
        }
      ]
    },
    {
      name: "add_liquidity_by_strategy_one_side",
      discriminator: [41, 5, 238, 175, 100, 225, 6, 205],
      accounts: [
        {
          name: "position",
          writable: true
        },
        {
          name: "lb_pair",
          writable: true,
          relations: [
            "position",
            "bin_array_bitmap_extension",
            "bin_array_lower",
            "bin_array_upper"
          ]
        },
        {
          name: "bin_array_bitmap_extension",
          writable: true,
          optional: true
        },
        {
          name: "user_token",
          writable: true
        },
        {
          name: "reserve",
          writable: true
        },
        {
          name: "token_mint"
        },
        {
          name: "bin_array_lower",
          writable: true
        },
        {
          name: "bin_array_upper",
          writable: true
        },
        {
          name: "sender",
          signer: true
        },
        {
          name: "token_program",
          address: "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA"
        },
        {
          name: "event_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  95,
                  95,
                  101,
                  118,
                  101,
                  110,
                  116,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              }
            ]
          }
        },
        {
          name: "program"
        }
      ],
      args: [
        {
          name: "liquidity_parameter",
          type: {
            defined: {
              name: "LiquidityParameterByStrategyOneSide"
            }
          }
        }
      ]
    },
    {
      name: "add_liquidity_by_weight",
      discriminator: [28, 140, 238, 99, 231, 162, 21, 149],
      accounts: [
        {
          name: "position",
          writable: true
        },
        {
          name: "lb_pair",
          writable: true,
          relations: [
            "position",
            "bin_array_bitmap_extension",
            "bin_array_lower",
            "bin_array_upper"
          ]
        },
        {
          name: "bin_array_bitmap_extension",
          writable: true,
          optional: true
        },
        {
          name: "user_token_x",
          writable: true
        },
        {
          name: "user_token_y",
          writable: true
        },
        {
          name: "reserve_x",
          writable: true,
          relations: ["lb_pair"]
        },
        {
          name: "reserve_y",
          writable: true,
          relations: ["lb_pair"]
        },
        {
          name: "token_x_mint",
          relations: ["lb_pair"]
        },
        {
          name: "token_y_mint",
          relations: ["lb_pair"]
        },
        {
          name: "bin_array_lower",
          writable: true
        },
        {
          name: "bin_array_upper",
          writable: true
        },
        {
          name: "sender",
          signer: true
        },
        {
          name: "token_x_program",
          address: "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA"
        },
        {
          name: "token_y_program",
          address: "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA"
        },
        {
          name: "event_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  95,
                  95,
                  101,
                  118,
                  101,
                  110,
                  116,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              }
            ]
          }
        },
        {
          name: "program"
        }
      ],
      args: [
        {
          name: "liquidity_parameter",
          type: {
            defined: {
              name: "LiquidityParameterByWeight"
            }
          }
        }
      ]
    },
    {
      name: "add_liquidity_one_side",
      discriminator: [94, 155, 103, 151, 70, 95, 220, 165],
      accounts: [
        {
          name: "position",
          writable: true
        },
        {
          name: "lb_pair",
          writable: true,
          relations: [
            "position",
            "bin_array_bitmap_extension",
            "bin_array_lower",
            "bin_array_upper"
          ]
        },
        {
          name: "bin_array_bitmap_extension",
          writable: true,
          optional: true
        },
        {
          name: "user_token",
          writable: true
        },
        {
          name: "reserve",
          writable: true
        },
        {
          name: "token_mint"
        },
        {
          name: "bin_array_lower",
          writable: true
        },
        {
          name: "bin_array_upper",
          writable: true
        },
        {
          name: "sender",
          signer: true
        },
        {
          name: "token_program",
          address: "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA"
        },
        {
          name: "event_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  95,
                  95,
                  101,
                  118,
                  101,
                  110,
                  116,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              }
            ]
          }
        },
        {
          name: "program"
        }
      ],
      args: [
        {
          name: "liquidity_parameter",
          type: {
            defined: {
              name: "LiquidityOneSideParameter"
            }
          }
        }
      ]
    },
    {
      name: "add_liquidity_one_side_precise",
      discriminator: [161, 194, 103, 84, 171, 71, 250, 154],
      accounts: [
        {
          name: "position",
          writable: true
        },
        {
          name: "lb_pair",
          writable: true,
          relations: [
            "position",
            "bin_array_bitmap_extension",
            "bin_array_lower",
            "bin_array_upper"
          ]
        },
        {
          name: "bin_array_bitmap_extension",
          writable: true,
          optional: true
        },
        {
          name: "user_token",
          writable: true
        },
        {
          name: "reserve",
          writable: true
        },
        {
          name: "token_mint"
        },
        {
          name: "bin_array_lower",
          writable: true
        },
        {
          name: "bin_array_upper",
          writable: true
        },
        {
          name: "sender",
          signer: true
        },
        {
          name: "token_program",
          address: "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA"
        },
        {
          name: "event_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  95,
                  95,
                  101,
                  118,
                  101,
                  110,
                  116,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              }
            ]
          }
        },
        {
          name: "program"
        }
      ],
      args: [
        {
          name: "parameter",
          type: {
            defined: {
              name: "AddLiquiditySingleSidePreciseParameter"
            }
          }
        }
      ]
    },
    {
      name: "add_liquidity_one_side_precise2",
      discriminator: [33, 51, 163, 201, 117, 98, 125, 231],
      accounts: [
        {
          name: "position",
          writable: true
        },
        {
          name: "lb_pair",
          writable: true,
          relations: ["position", "bin_array_bitmap_extension"]
        },
        {
          name: "bin_array_bitmap_extension",
          writable: true,
          optional: true
        },
        {
          name: "user_token",
          writable: true
        },
        {
          name: "reserve",
          writable: true
        },
        {
          name: "token_mint"
        },
        {
          name: "sender",
          signer: true
        },
        {
          name: "token_program"
        },
        {
          name: "event_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  95,
                  95,
                  101,
                  118,
                  101,
                  110,
                  116,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              }
            ]
          }
        },
        {
          name: "program"
        }
      ],
      args: [
        {
          name: "liquidity_parameter",
          type: {
            defined: {
              name: "AddLiquiditySingleSidePreciseParameter2"
            }
          }
        },
        {
          name: "remaining_accounts_info",
          type: {
            defined: {
              name: "RemainingAccountsInfo"
            }
          }
        }
      ]
    },
    {
      name: "claim_fee",
      discriminator: [169, 32, 79, 137, 136, 232, 70, 137],
      accounts: [
        {
          name: "lb_pair",
          writable: true,
          relations: ["position", "bin_array_lower", "bin_array_upper"]
        },
        {
          name: "position",
          writable: true
        },
        {
          name: "bin_array_lower",
          writable: true
        },
        {
          name: "bin_array_upper",
          writable: true
        },
        {
          name: "sender",
          signer: true
        },
        {
          name: "reserve_x",
          writable: true,
          relations: ["lb_pair"]
        },
        {
          name: "reserve_y",
          writable: true,
          relations: ["lb_pair"]
        },
        {
          name: "user_token_x",
          writable: true
        },
        {
          name: "user_token_y",
          writable: true
        },
        {
          name: "token_x_mint",
          relations: ["lb_pair"]
        },
        {
          name: "token_y_mint",
          relations: ["lb_pair"]
        },
        {
          name: "token_program",
          address: "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA"
        },
        {
          name: "event_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  95,
                  95,
                  101,
                  118,
                  101,
                  110,
                  116,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              }
            ]
          }
        },
        {
          name: "program"
        }
      ],
      args: []
    },
    {
      name: "claim_fee2",
      discriminator: [112, 191, 101, 171, 28, 144, 127, 187],
      accounts: [
        {
          name: "lb_pair",
          writable: true,
          relations: ["position"]
        },
        {
          name: "position",
          writable: true
        },
        {
          name: "sender",
          signer: true
        },
        {
          name: "reserve_x",
          writable: true,
          relations: ["lb_pair"]
        },
        {
          name: "reserve_y",
          writable: true,
          relations: ["lb_pair"]
        },
        {
          name: "user_token_x",
          writable: true
        },
        {
          name: "user_token_y",
          writable: true
        },
        {
          name: "token_x_mint",
          relations: ["lb_pair"]
        },
        {
          name: "token_y_mint",
          relations: ["lb_pair"]
        },
        {
          name: "token_program_x"
        },
        {
          name: "token_program_y"
        },
        {
          name: "memo_program",
          address: "MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr"
        },
        {
          name: "event_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  95,
                  95,
                  101,
                  118,
                  101,
                  110,
                  116,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              }
            ]
          }
        },
        {
          name: "program"
        }
      ],
      args: [
        {
          name: "min_bin_id",
          type: "i32"
        },
        {
          name: "max_bin_id",
          type: "i32"
        },
        {
          name: "remaining_accounts_info",
          type: {
            defined: {
              name: "RemainingAccountsInfo"
            }
          }
        }
      ]
    },
    {
      name: "claim_reward",
      discriminator: [149, 95, 181, 242, 94, 90, 158, 162],
      accounts: [
        {
          name: "lb_pair",
          writable: true,
          relations: ["position", "bin_array_lower", "bin_array_upper"]
        },
        {
          name: "position",
          writable: true
        },
        {
          name: "bin_array_lower",
          writable: true
        },
        {
          name: "bin_array_upper",
          writable: true
        },
        {
          name: "sender",
          signer: true
        },
        {
          name: "reward_vault",
          writable: true
        },
        {
          name: "reward_mint"
        },
        {
          name: "user_token_account",
          writable: true
        },
        {
          name: "token_program",
          address: "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA"
        },
        {
          name: "event_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  95,
                  95,
                  101,
                  118,
                  101,
                  110,
                  116,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              }
            ]
          }
        },
        {
          name: "program"
        }
      ],
      args: [
        {
          name: "reward_index",
          type: "u64"
        }
      ]
    },
    {
      name: "claim_reward2",
      discriminator: [190, 3, 127, 119, 178, 87, 157, 183],
      accounts: [
        {
          name: "lb_pair",
          writable: true,
          relations: ["position"]
        },
        {
          name: "position",
          writable: true
        },
        {
          name: "sender",
          signer: true
        },
        {
          name: "reward_vault",
          writable: true
        },
        {
          name: "reward_mint"
        },
        {
          name: "user_token_account",
          writable: true
        },
        {
          name: "token_program"
        },
        {
          name: "memo_program",
          address: "MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr"
        },
        {
          name: "event_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  95,
                  95,
                  101,
                  118,
                  101,
                  110,
                  116,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              }
            ]
          }
        },
        {
          name: "program"
        }
      ],
      args: [
        {
          name: "reward_index",
          type: "u64"
        },
        {
          name: "min_bin_id",
          type: "i32"
        },
        {
          name: "max_bin_id",
          type: "i32"
        },
        {
          name: "remaining_accounts_info",
          type: {
            defined: {
              name: "RemainingAccountsInfo"
            }
          }
        }
      ]
    },
    {
      name: "close_claim_protocol_fee_operator",
      discriminator: [8, 41, 87, 35, 80, 48, 121, 26],
      accounts: [
        {
          name: "claim_fee_operator",
          writable: true
        },
        {
          name: "rent_receiver",
          writable: true
        },
        {
          name: "admin",
          signer: true
        }
      ],
      args: []
    },
    {
      name: "close_position",
      discriminator: [123, 134, 81, 0, 49, 68, 98, 98],
      accounts: [
        {
          name: "position",
          writable: true
        },
        {
          name: "lb_pair",
          writable: true,
          relations: ["position", "bin_array_lower", "bin_array_upper"]
        },
        {
          name: "bin_array_lower",
          writable: true
        },
        {
          name: "bin_array_upper",
          writable: true
        },
        {
          name: "sender",
          signer: true
        },
        {
          name: "rent_receiver",
          writable: true
        },
        {
          name: "event_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  95,
                  95,
                  101,
                  118,
                  101,
                  110,
                  116,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              }
            ]
          }
        },
        {
          name: "program"
        }
      ],
      args: []
    },
    {
      name: "close_position2",
      discriminator: [174, 90, 35, 115, 186, 40, 147, 226],
      accounts: [
        {
          name: "position",
          writable: true
        },
        {
          name: "sender",
          signer: true
        },
        {
          name: "rent_receiver",
          writable: true
        },
        {
          name: "event_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  95,
                  95,
                  101,
                  118,
                  101,
                  110,
                  116,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              }
            ]
          }
        },
        {
          name: "program"
        }
      ],
      args: []
    },
    {
      name: "close_position_if_empty",
      discriminator: [59, 124, 212, 118, 91, 152, 110, 157],
      accounts: [
        {
          name: "position",
          writable: true
        },
        {
          name: "sender",
          signer: true
        },
        {
          name: "rent_receiver",
          writable: true
        },
        {
          name: "event_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  95,
                  95,
                  101,
                  118,
                  101,
                  110,
                  116,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              }
            ]
          }
        },
        {
          name: "program"
        }
      ],
      args: []
    },
    {
      name: "close_preset_parameter",
      discriminator: [4, 148, 145, 100, 134, 26, 181, 61],
      accounts: [
        {
          name: "preset_parameter",
          writable: true
        },
        {
          name: "admin",
          writable: true,
          signer: true
        },
        {
          name: "rent_receiver",
          writable: true
        }
      ],
      args: []
    },
    {
      name: "close_preset_parameter2",
      discriminator: [39, 25, 95, 107, 116, 17, 115, 28],
      accounts: [
        {
          name: "preset_parameter",
          writable: true
        },
        {
          name: "admin",
          writable: true,
          signer: true
        },
        {
          name: "rent_receiver",
          writable: true
        }
      ],
      args: []
    },
    {
      name: "close_token_badge",
      discriminator: [108, 146, 86, 110, 179, 254, 10, 104],
      accounts: [
        {
          name: "token_badge",
          writable: true
        },
        {
          name: "rent_receiver",
          writable: true
        },
        {
          name: "admin",
          signer: true
        }
      ],
      args: []
    },
    {
      name: "create_claim_protocol_fee_operator",
      discriminator: [51, 19, 150, 252, 105, 157, 48, 91],
      accounts: [
        {
          name: "claim_fee_operator",
          writable: true,
          pda: {
            seeds: [
              {
                kind: "const",
                value: [99, 102, 95, 111, 112, 101, 114, 97, 116, 111, 114]
              },
              {
                kind: "account",
                path: "operator"
              }
            ]
          }
        },
        {
          name: "operator"
        },
        {
          name: "admin",
          writable: true,
          signer: true
        },
        {
          name: "system_program",
          address: "11111111111111111111111111111111"
        }
      ],
      args: []
    },
    {
      name: "decrease_position_length",
      discriminator: [194, 219, 136, 32, 25, 96, 105, 37],
      accounts: [
        {
          name: "rent_receiver",
          writable: true
        },
        {
          name: "position",
          writable: true
        },
        {
          name: "owner",
          signer: true,
          relations: ["position"]
        },
        {
          name: "system_program",
          address: "11111111111111111111111111111111"
        },
        {
          name: "event_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  95,
                  95,
                  101,
                  118,
                  101,
                  110,
                  116,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              }
            ]
          }
        },
        {
          name: "program"
        }
      ],
      args: [
        {
          name: "length_to_remove",
          type: "u16"
        },
        {
          name: "side",
          type: "u8"
        }
      ]
    },
    {
      name: "for_idl_type_generation_do_not_call",
      discriminator: [180, 105, 69, 80, 95, 50, 73, 108],
      accounts: [
        {
          name: "dummy_zc_account"
        }
      ],
      args: [
        {
          name: "_ix",
          type: {
            defined: {
              name: "DummyIx"
            }
          }
        }
      ]
    },
    {
      name: "fund_reward",
      discriminator: [188, 50, 249, 165, 93, 151, 38, 63],
      accounts: [
        {
          name: "lb_pair",
          writable: true,
          relations: ["bin_array"]
        },
        {
          name: "reward_vault",
          writable: true
        },
        {
          name: "reward_mint"
        },
        {
          name: "funder_token_account",
          writable: true
        },
        {
          name: "funder",
          signer: true
        },
        {
          name: "bin_array",
          writable: true
        },
        {
          name: "token_program"
        },
        {
          name: "event_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  95,
                  95,
                  101,
                  118,
                  101,
                  110,
                  116,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              }
            ]
          }
        },
        {
          name: "program"
        }
      ],
      args: [
        {
          name: "reward_index",
          type: "u64"
        },
        {
          name: "amount",
          type: "u64"
        },
        {
          name: "carry_forward",
          type: "bool"
        },
        {
          name: "remaining_accounts_info",
          type: {
            defined: {
              name: "RemainingAccountsInfo"
            }
          }
        }
      ]
    },
    {
      name: "go_to_a_bin",
      discriminator: [146, 72, 174, 224, 40, 253, 84, 174],
      accounts: [
        {
          name: "lb_pair",
          writable: true,
          relations: [
            "bin_array_bitmap_extension",
            "from_bin_array",
            "to_bin_array"
          ]
        },
        {
          name: "bin_array_bitmap_extension",
          optional: true
        },
        {
          name: "from_bin_array",
          optional: true
        },
        {
          name: "to_bin_array",
          optional: true
        },
        {
          name: "event_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  95,
                  95,
                  101,
                  118,
                  101,
                  110,
                  116,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              }
            ]
          }
        },
        {
          name: "program"
        }
      ],
      args: [
        {
          name: "bin_id",
          type: "i32"
        }
      ]
    },
    {
      name: "increase_oracle_length",
      discriminator: [190, 61, 125, 87, 103, 79, 158, 173],
      accounts: [
        {
          name: "oracle",
          writable: true
        },
        {
          name: "funder",
          writable: true,
          signer: true
        },
        {
          name: "system_program",
          address: "11111111111111111111111111111111"
        },
        {
          name: "event_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  95,
                  95,
                  101,
                  118,
                  101,
                  110,
                  116,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              }
            ]
          }
        },
        {
          name: "program"
        }
      ],
      args: [
        {
          name: "length_to_add",
          type: "u64"
        }
      ]
    },
    {
      name: "increase_position_length",
      discriminator: [80, 83, 117, 211, 66, 13, 33, 149],
      accounts: [
        {
          name: "funder",
          writable: true,
          signer: true
        },
        {
          name: "lb_pair",
          relations: ["position"]
        },
        {
          name: "position",
          writable: true
        },
        {
          name: "owner",
          signer: true,
          relations: ["position"]
        },
        {
          name: "system_program",
          address: "11111111111111111111111111111111"
        },
        {
          name: "event_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  95,
                  95,
                  101,
                  118,
                  101,
                  110,
                  116,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              }
            ]
          }
        },
        {
          name: "program"
        }
      ],
      args: [
        {
          name: "length_to_add",
          type: "u16"
        },
        {
          name: "side",
          type: "u8"
        }
      ]
    },
    {
      name: "increase_position_length2",
      discriminator: [255, 210, 204, 71, 115, 137, 225, 113],
      accounts: [
        {
          name: "funder",
          writable: true,
          signer: true
        },
        {
          name: "lb_pair",
          relations: ["position"]
        },
        {
          name: "position",
          writable: true
        },
        {
          name: "owner",
          signer: true,
          relations: ["position"]
        },
        {
          name: "system_program",
          address: "11111111111111111111111111111111"
        },
        {
          name: "event_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  95,
                  95,
                  101,
                  118,
                  101,
                  110,
                  116,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              }
            ]
          }
        },
        {
          name: "program"
        }
      ],
      args: [
        {
          name: "minimum_upper_bin_id",
          type: "i32"
        }
      ]
    },
    {
      name: "initialize_bin_array",
      discriminator: [35, 86, 19, 185, 78, 212, 75, 211],
      accounts: [
        {
          name: "lb_pair"
        },
        {
          name: "bin_array",
          writable: true,
          pda: {
            seeds: [
              {
                kind: "const",
                value: [98, 105, 110, 95, 97, 114, 114, 97, 121]
              },
              {
                kind: "account",
                path: "lb_pair"
              },
              {
                kind: "arg",
                path: "index"
              }
            ]
          }
        },
        {
          name: "funder",
          writable: true,
          signer: true
        },
        {
          name: "system_program",
          address: "11111111111111111111111111111111"
        }
      ],
      args: [
        {
          name: "index",
          type: "i64"
        }
      ]
    },
    {
      name: "initialize_bin_array_bitmap_extension",
      discriminator: [47, 157, 226, 180, 12, 240, 33, 71],
      accounts: [
        {
          name: "lb_pair"
        },
        {
          name: "bin_array_bitmap_extension",
          docs: [
            "Initialize an account to store if a bin array is initialized."
          ],
          writable: true,
          pda: {
            seeds: [
              {
                kind: "const",
                value: [98, 105, 116, 109, 97, 112]
              },
              {
                kind: "account",
                path: "lb_pair"
              }
            ]
          }
        },
        {
          name: "funder",
          writable: true,
          signer: true
        },
        {
          name: "system_program",
          address: "11111111111111111111111111111111"
        },
        {
          name: "rent",
          address: "SysvarRent111111111111111111111111111111111"
        }
      ],
      args: []
    },
    {
      name: "initialize_customizable_permissionless_lb_pair",
      discriminator: [46, 39, 41, 135, 111, 183, 200, 64],
      accounts: [
        {
          name: "lb_pair",
          writable: true
        },
        {
          name: "bin_array_bitmap_extension",
          writable: true,
          optional: true,
          pda: {
            seeds: [
              {
                kind: "const",
                value: [98, 105, 116, 109, 97, 112]
              },
              {
                kind: "account",
                path: "lb_pair"
              }
            ]
          }
        },
        {
          name: "token_mint_x"
        },
        {
          name: "token_mint_y"
        },
        {
          name: "reserve_x",
          writable: true,
          pda: {
            seeds: [
              {
                kind: "account",
                path: "lb_pair"
              },
              {
                kind: "account",
                path: "token_mint_x"
              }
            ]
          }
        },
        {
          name: "reserve_y",
          writable: true,
          pda: {
            seeds: [
              {
                kind: "account",
                path: "lb_pair"
              },
              {
                kind: "account",
                path: "token_mint_y"
              }
            ]
          }
        },
        {
          name: "oracle",
          writable: true,
          pda: {
            seeds: [
              {
                kind: "const",
                value: [111, 114, 97, 99, 108, 101]
              },
              {
                kind: "account",
                path: "lb_pair"
              }
            ]
          }
        },
        {
          name: "user_token_x"
        },
        {
          name: "funder",
          writable: true,
          signer: true
        },
        {
          name: "token_program",
          address: "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA"
        },
        {
          name: "system_program",
          address: "11111111111111111111111111111111"
        },
        {
          name: "user_token_y"
        },
        {
          name: "event_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  95,
                  95,
                  101,
                  118,
                  101,
                  110,
                  116,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              }
            ]
          }
        },
        {
          name: "program"
        }
      ],
      args: [
        {
          name: "params",
          type: {
            defined: {
              name: "CustomizableParams"
            }
          }
        }
      ]
    },
    {
      name: "initialize_customizable_permissionless_lb_pair2",
      discriminator: [243, 73, 129, 126, 51, 19, 241, 107],
      accounts: [
        {
          name: "lb_pair",
          writable: true
        },
        {
          name: "bin_array_bitmap_extension",
          writable: true,
          optional: true,
          pda: {
            seeds: [
              {
                kind: "const",
                value: [98, 105, 116, 109, 97, 112]
              },
              {
                kind: "account",
                path: "lb_pair"
              }
            ]
          }
        },
        {
          name: "token_mint_x"
        },
        {
          name: "token_mint_y"
        },
        {
          name: "reserve_x",
          writable: true,
          pda: {
            seeds: [
              {
                kind: "account",
                path: "lb_pair"
              },
              {
                kind: "account",
                path: "token_mint_x"
              }
            ]
          }
        },
        {
          name: "reserve_y",
          writable: true,
          pda: {
            seeds: [
              {
                kind: "account",
                path: "lb_pair"
              },
              {
                kind: "account",
                path: "token_mint_y"
              }
            ]
          }
        },
        {
          name: "oracle",
          writable: true,
          pda: {
            seeds: [
              {
                kind: "const",
                value: [111, 114, 97, 99, 108, 101]
              },
              {
                kind: "account",
                path: "lb_pair"
              }
            ]
          }
        },
        {
          name: "user_token_x"
        },
        {
          name: "funder",
          writable: true,
          signer: true
        },
        {
          name: "token_badge_x",
          optional: true
        },
        {
          name: "token_badge_y",
          optional: true
        },
        {
          name: "token_program_x"
        },
        {
          name: "token_program_y"
        },
        {
          name: "system_program",
          address: "11111111111111111111111111111111"
        },
        {
          name: "user_token_y"
        },
        {
          name: "event_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  95,
                  95,
                  101,
                  118,
                  101,
                  110,
                  116,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              }
            ]
          }
        },
        {
          name: "program"
        }
      ],
      args: [
        {
          name: "params",
          type: {
            defined: {
              name: "CustomizableParams"
            }
          }
        }
      ]
    },
    {
      name: "initialize_lb_pair",
      discriminator: [45, 154, 237, 210, 221, 15, 166, 92],
      accounts: [
        {
          name: "lb_pair",
          writable: true
        },
        {
          name: "bin_array_bitmap_extension",
          writable: true,
          optional: true,
          pda: {
            seeds: [
              {
                kind: "const",
                value: [98, 105, 116, 109, 97, 112]
              },
              {
                kind: "account",
                path: "lb_pair"
              }
            ]
          }
        },
        {
          name: "token_mint_x"
        },
        {
          name: "token_mint_y"
        },
        {
          name: "reserve_x",
          writable: true,
          pda: {
            seeds: [
              {
                kind: "account",
                path: "lb_pair"
              },
              {
                kind: "account",
                path: "token_mint_x"
              }
            ]
          }
        },
        {
          name: "reserve_y",
          writable: true,
          pda: {
            seeds: [
              {
                kind: "account",
                path: "lb_pair"
              },
              {
                kind: "account",
                path: "token_mint_y"
              }
            ]
          }
        },
        {
          name: "oracle",
          writable: true,
          pda: {
            seeds: [
              {
                kind: "const",
                value: [111, 114, 97, 99, 108, 101]
              },
              {
                kind: "account",
                path: "lb_pair"
              }
            ]
          }
        },
        {
          name: "preset_parameter"
        },
        {
          name: "funder",
          writable: true,
          signer: true
        },
        {
          name: "token_program",
          address: "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA"
        },
        {
          name: "system_program",
          address: "11111111111111111111111111111111"
        },
        {
          name: "rent",
          address: "SysvarRent111111111111111111111111111111111"
        },
        {
          name: "event_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  95,
                  95,
                  101,
                  118,
                  101,
                  110,
                  116,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              }
            ]
          }
        },
        {
          name: "program"
        }
      ],
      args: [
        {
          name: "active_id",
          type: "i32"
        },
        {
          name: "bin_step",
          type: "u16"
        }
      ]
    },
    {
      name: "initialize_lb_pair2",
      discriminator: [73, 59, 36, 120, 237, 83, 108, 198],
      accounts: [
        {
          name: "lb_pair",
          writable: true
        },
        {
          name: "bin_array_bitmap_extension",
          writable: true,
          optional: true,
          pda: {
            seeds: [
              {
                kind: "const",
                value: [98, 105, 116, 109, 97, 112]
              },
              {
                kind: "account",
                path: "lb_pair"
              }
            ]
          }
        },
        {
          name: "token_mint_x"
        },
        {
          name: "token_mint_y"
        },
        {
          name: "reserve_x",
          writable: true,
          pda: {
            seeds: [
              {
                kind: "account",
                path: "lb_pair"
              },
              {
                kind: "account",
                path: "token_mint_x"
              }
            ]
          }
        },
        {
          name: "reserve_y",
          writable: true,
          pda: {
            seeds: [
              {
                kind: "account",
                path: "lb_pair"
              },
              {
                kind: "account",
                path: "token_mint_y"
              }
            ]
          }
        },
        {
          name: "oracle",
          writable: true,
          pda: {
            seeds: [
              {
                kind: "const",
                value: [111, 114, 97, 99, 108, 101]
              },
              {
                kind: "account",
                path: "lb_pair"
              }
            ]
          }
        },
        {
          name: "preset_parameter"
        },
        {
          name: "funder",
          writable: true,
          signer: true
        },
        {
          name: "token_badge_x",
          optional: true
        },
        {
          name: "token_badge_y",
          optional: true
        },
        {
          name: "token_program_x"
        },
        {
          name: "token_program_y"
        },
        {
          name: "system_program",
          address: "11111111111111111111111111111111"
        },
        {
          name: "event_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  95,
                  95,
                  101,
                  118,
                  101,
                  110,
                  116,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              }
            ]
          }
        },
        {
          name: "program"
        }
      ],
      args: [
        {
          name: "params",
          type: {
            defined: {
              name: "InitializeLbPair2Params"
            }
          }
        }
      ]
    },
    {
      name: "initialize_permission_lb_pair",
      discriminator: [108, 102, 213, 85, 251, 3, 53, 21],
      accounts: [
        {
          name: "base",
          signer: true
        },
        {
          name: "lb_pair",
          writable: true
        },
        {
          name: "bin_array_bitmap_extension",
          writable: true,
          optional: true,
          pda: {
            seeds: [
              {
                kind: "const",
                value: [98, 105, 116, 109, 97, 112]
              },
              {
                kind: "account",
                path: "lb_pair"
              }
            ]
          }
        },
        {
          name: "token_mint_x"
        },
        {
          name: "token_mint_y"
        },
        {
          name: "reserve_x",
          writable: true,
          pda: {
            seeds: [
              {
                kind: "account",
                path: "lb_pair"
              },
              {
                kind: "account",
                path: "token_mint_x"
              }
            ]
          }
        },
        {
          name: "reserve_y",
          writable: true,
          pda: {
            seeds: [
              {
                kind: "account",
                path: "lb_pair"
              },
              {
                kind: "account",
                path: "token_mint_y"
              }
            ]
          }
        },
        {
          name: "oracle",
          writable: true,
          pda: {
            seeds: [
              {
                kind: "const",
                value: [111, 114, 97, 99, 108, 101]
              },
              {
                kind: "account",
                path: "lb_pair"
              }
            ]
          }
        },
        {
          name: "admin",
          writable: true,
          signer: true
        },
        {
          name: "token_badge_x",
          optional: true
        },
        {
          name: "token_badge_y",
          optional: true
        },
        {
          name: "token_program_x"
        },
        {
          name: "token_program_y"
        },
        {
          name: "system_program",
          address: "11111111111111111111111111111111"
        },
        {
          name: "rent",
          address: "SysvarRent111111111111111111111111111111111"
        },
        {
          name: "event_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  95,
                  95,
                  101,
                  118,
                  101,
                  110,
                  116,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              }
            ]
          }
        },
        {
          name: "program"
        }
      ],
      args: [
        {
          name: "ix_data",
          type: {
            defined: {
              name: "InitPermissionPairIx"
            }
          }
        }
      ]
    },
    {
      name: "initialize_position",
      discriminator: [219, 192, 234, 71, 190, 191, 102, 80],
      accounts: [
        {
          name: "payer",
          writable: true,
          signer: true
        },
        {
          name: "position",
          writable: true,
          signer: true
        },
        {
          name: "lb_pair"
        },
        {
          name: "owner",
          signer: true
        },
        {
          name: "system_program",
          address: "11111111111111111111111111111111"
        },
        {
          name: "rent",
          address: "SysvarRent111111111111111111111111111111111"
        },
        {
          name: "event_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  95,
                  95,
                  101,
                  118,
                  101,
                  110,
                  116,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              }
            ]
          }
        },
        {
          name: "program"
        }
      ],
      args: [
        {
          name: "lower_bin_id",
          type: "i32"
        },
        {
          name: "width",
          type: "i32"
        }
      ]
    },
    {
      name: "initialize_position2",
      discriminator: [143, 19, 242, 145, 213, 15, 104, 115],
      accounts: [
        {
          name: "payer",
          writable: true,
          signer: true
        },
        {
          name: "position",
          writable: true,
          signer: true
        },
        {
          name: "lb_pair"
        },
        {
          name: "owner",
          signer: true
        },
        {
          name: "system_program",
          address: "11111111111111111111111111111111"
        },
        {
          name: "event_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  95,
                  95,
                  101,
                  118,
                  101,
                  110,
                  116,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              }
            ]
          }
        },
        {
          name: "program"
        }
      ],
      args: [
        {
          name: "lower_bin_id",
          type: "i32"
        },
        {
          name: "width",
          type: "i32"
        }
      ]
    },
    {
      name: "initialize_position_by_operator",
      discriminator: [251, 189, 190, 244, 117, 254, 35, 148],
      accounts: [
        {
          name: "payer",
          writable: true,
          signer: true
        },
        {
          name: "base",
          signer: true
        },
        {
          name: "position",
          writable: true,
          pda: {
            seeds: [
              {
                kind: "const",
                value: [112, 111, 115, 105, 116, 105, 111, 110]
              },
              {
                kind: "account",
                path: "lb_pair"
              },
              {
                kind: "account",
                path: "base"
              },
              {
                kind: "arg",
                path: "lower_bin_id"
              },
              {
                kind: "arg",
                path: "width"
              }
            ]
          }
        },
        {
          name: "lb_pair"
        },
        {
          name: "owner"
        },
        {
          name: "operator",
          docs: ["operator"],
          signer: true
        },
        {
          name: "operator_token_x"
        },
        {
          name: "owner_token_x"
        },
        {
          name: "system_program",
          address: "11111111111111111111111111111111"
        },
        {
          name: "event_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  95,
                  95,
                  101,
                  118,
                  101,
                  110,
                  116,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              }
            ]
          }
        },
        {
          name: "program"
        }
      ],
      args: [
        {
          name: "lower_bin_id",
          type: "i32"
        },
        {
          name: "width",
          type: "i32"
        },
        {
          name: "fee_owner",
          type: "pubkey"
        },
        {
          name: "lock_release_point",
          type: "u64"
        }
      ]
    },
    {
      name: "initialize_position_pda",
      discriminator: [46, 82, 125, 146, 85, 141, 228, 153],
      accounts: [
        {
          name: "payer",
          writable: true,
          signer: true
        },
        {
          name: "base",
          signer: true
        },
        {
          name: "position",
          writable: true,
          pda: {
            seeds: [
              {
                kind: "const",
                value: [112, 111, 115, 105, 116, 105, 111, 110]
              },
              {
                kind: "account",
                path: "lb_pair"
              },
              {
                kind: "account",
                path: "base"
              },
              {
                kind: "arg",
                path: "lower_bin_id"
              },
              {
                kind: "arg",
                path: "width"
              }
            ]
          }
        },
        {
          name: "lb_pair"
        },
        {
          name: "owner",
          docs: ["owner"],
          signer: true
        },
        {
          name: "system_program",
          address: "11111111111111111111111111111111"
        },
        {
          name: "rent",
          address: "SysvarRent111111111111111111111111111111111"
        },
        {
          name: "event_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  95,
                  95,
                  101,
                  118,
                  101,
                  110,
                  116,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              }
            ]
          }
        },
        {
          name: "program"
        }
      ],
      args: [
        {
          name: "lower_bin_id",
          type: "i32"
        },
        {
          name: "width",
          type: "i32"
        }
      ]
    },
    {
      name: "initialize_preset_parameter",
      discriminator: [66, 188, 71, 211, 98, 109, 14, 186],
      accounts: [
        {
          name: "preset_parameter",
          writable: true,
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  112,
                  114,
                  101,
                  115,
                  101,
                  116,
                  95,
                  112,
                  97,
                  114,
                  97,
                  109,
                  101,
                  116,
                  101,
                  114
                ]
              },
              {
                kind: "arg",
                path: "ix.bin_step"
              },
              {
                kind: "arg",
                path: "ix.base_factor"
              }
            ]
          }
        },
        {
          name: "admin",
          writable: true,
          signer: true
        },
        {
          name: "system_program",
          address: "11111111111111111111111111111111"
        },
        {
          name: "rent",
          address: "SysvarRent111111111111111111111111111111111"
        }
      ],
      args: [
        {
          name: "ix",
          type: {
            defined: {
              name: "InitPresetParametersIx"
            }
          }
        }
      ]
    },
    {
      name: "initialize_preset_parameter2",
      discriminator: [184, 7, 240, 171, 103, 47, 183, 121],
      accounts: [
        {
          name: "preset_parameter",
          writable: true,
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  112,
                  114,
                  101,
                  115,
                  101,
                  116,
                  95,
                  112,
                  97,
                  114,
                  97,
                  109,
                  101,
                  116,
                  101,
                  114,
                  50
                ]
              },
              {
                kind: "arg",
                path: "ix.index"
              }
            ]
          }
        },
        {
          name: "admin",
          writable: true,
          signer: true
        },
        {
          name: "system_program",
          address: "11111111111111111111111111111111"
        }
      ],
      args: [
        {
          name: "ix",
          type: {
            defined: {
              name: "InitPresetParameters2Ix"
            }
          }
        }
      ]
    },
    {
      name: "initialize_reward",
      discriminator: [95, 135, 192, 196, 242, 129, 230, 68],
      accounts: [
        {
          name: "lb_pair",
          writable: true
        },
        {
          name: "reward_vault",
          writable: true,
          pda: {
            seeds: [
              {
                kind: "account",
                path: "lb_pair"
              },
              {
                kind: "arg",
                path: "reward_index"
              }
            ]
          }
        },
        {
          name: "reward_mint"
        },
        {
          name: "token_badge",
          optional: true
        },
        {
          name: "admin",
          writable: true,
          signer: true
        },
        {
          name: "token_program"
        },
        {
          name: "system_program",
          address: "11111111111111111111111111111111"
        },
        {
          name: "rent",
          address: "SysvarRent111111111111111111111111111111111"
        },
        {
          name: "event_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  95,
                  95,
                  101,
                  118,
                  101,
                  110,
                  116,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              }
            ]
          }
        },
        {
          name: "program"
        }
      ],
      args: [
        {
          name: "reward_index",
          type: "u64"
        },
        {
          name: "reward_duration",
          type: "u64"
        },
        {
          name: "funder",
          type: "pubkey"
        }
      ]
    },
    {
      name: "initialize_token_badge",
      discriminator: [253, 77, 205, 95, 27, 224, 89, 223],
      accounts: [
        {
          name: "token_mint"
        },
        {
          name: "token_badge",
          writable: true,
          pda: {
            seeds: [
              {
                kind: "const",
                value: [116, 111, 107, 101, 110, 95, 98, 97, 100, 103, 101]
              },
              {
                kind: "account",
                path: "token_mint"
              }
            ]
          }
        },
        {
          name: "admin",
          writable: true,
          signer: true
        },
        {
          name: "system_program",
          address: "11111111111111111111111111111111"
        }
      ],
      args: []
    },
    {
      name: "migrate_bin_array",
      discriminator: [17, 23, 159, 211, 101, 184, 41, 241],
      accounts: [
        {
          name: "lb_pair"
        }
      ],
      args: []
    },
    {
      name: "migrate_position",
      discriminator: [15, 132, 59, 50, 199, 6, 251, 46],
      accounts: [
        {
          name: "position_v2",
          writable: true,
          signer: true
        },
        {
          name: "position_v1",
          writable: true
        },
        {
          name: "lb_pair",
          relations: ["position_v1", "bin_array_lower", "bin_array_upper"]
        },
        {
          name: "bin_array_lower",
          writable: true
        },
        {
          name: "bin_array_upper",
          writable: true
        },
        {
          name: "owner",
          writable: true,
          signer: true,
          relations: ["position_v1"]
        },
        {
          name: "system_program",
          address: "11111111111111111111111111111111"
        },
        {
          name: "rent_receiver",
          writable: true
        },
        {
          name: "event_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  95,
                  95,
                  101,
                  118,
                  101,
                  110,
                  116,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              }
            ]
          }
        },
        {
          name: "program"
        }
      ],
      args: []
    },
    {
      name: "rebalance_liquidity",
      discriminator: [92, 4, 176, 193, 119, 185, 83, 9],
      accounts: [
        {
          name: "position",
          writable: true
        },
        {
          name: "lb_pair",
          writable: true,
          relations: ["position", "bin_array_bitmap_extension"]
        },
        {
          name: "bin_array_bitmap_extension",
          writable: true,
          optional: true
        },
        {
          name: "user_token_x",
          writable: true
        },
        {
          name: "user_token_y",
          writable: true
        },
        {
          name: "reserve_x",
          writable: true,
          relations: ["lb_pair"]
        },
        {
          name: "reserve_y",
          writable: true,
          relations: ["lb_pair"]
        },
        {
          name: "token_x_mint",
          relations: ["lb_pair"]
        },
        {
          name: "token_y_mint",
          relations: ["lb_pair"]
        },
        {
          name: "owner",
          signer: true,
          relations: ["position"]
        },
        {
          name: "rent_payer",
          writable: true,
          signer: true
        },
        {
          name: "token_x_program"
        },
        {
          name: "token_y_program"
        },
        {
          name: "memo_program",
          address: "MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr"
        },
        {
          name: "system_program",
          address: "11111111111111111111111111111111"
        },
        {
          name: "event_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  95,
                  95,
                  101,
                  118,
                  101,
                  110,
                  116,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              }
            ]
          }
        },
        {
          name: "program"
        }
      ],
      args: [
        {
          name: "params",
          type: {
            defined: {
              name: "RebalanceLiquidityParams"
            }
          }
        },
        {
          name: "remaining_accounts_info",
          type: {
            defined: {
              name: "RemainingAccountsInfo"
            }
          }
        }
      ]
    },
    {
      name: "remove_all_liquidity",
      discriminator: [10, 51, 61, 35, 112, 105, 24, 85],
      accounts: [
        {
          name: "position",
          writable: true
        },
        {
          name: "lb_pair",
          writable: true,
          relations: [
            "position",
            "bin_array_bitmap_extension",
            "bin_array_lower",
            "bin_array_upper"
          ]
        },
        {
          name: "bin_array_bitmap_extension",
          writable: true,
          optional: true
        },
        {
          name: "user_token_x",
          writable: true
        },
        {
          name: "user_token_y",
          writable: true
        },
        {
          name: "reserve_x",
          writable: true,
          relations: ["lb_pair"]
        },
        {
          name: "reserve_y",
          writable: true,
          relations: ["lb_pair"]
        },
        {
          name: "token_x_mint",
          relations: ["lb_pair"]
        },
        {
          name: "token_y_mint",
          relations: ["lb_pair"]
        },
        {
          name: "bin_array_lower",
          writable: true
        },
        {
          name: "bin_array_upper",
          writable: true
        },
        {
          name: "sender",
          signer: true
        },
        {
          name: "token_x_program",
          address: "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA"
        },
        {
          name: "token_y_program",
          address: "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA"
        },
        {
          name: "event_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  95,
                  95,
                  101,
                  118,
                  101,
                  110,
                  116,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              }
            ]
          }
        },
        {
          name: "program"
        }
      ],
      args: []
    },
    {
      name: "remove_liquidity",
      discriminator: [80, 85, 209, 72, 24, 206, 177, 108],
      accounts: [
        {
          name: "position",
          writable: true
        },
        {
          name: "lb_pair",
          writable: true,
          relations: [
            "position",
            "bin_array_bitmap_extension",
            "bin_array_lower",
            "bin_array_upper"
          ]
        },
        {
          name: "bin_array_bitmap_extension",
          writable: true,
          optional: true
        },
        {
          name: "user_token_x",
          writable: true
        },
        {
          name: "user_token_y",
          writable: true
        },
        {
          name: "reserve_x",
          writable: true,
          relations: ["lb_pair"]
        },
        {
          name: "reserve_y",
          writable: true,
          relations: ["lb_pair"]
        },
        {
          name: "token_x_mint",
          relations: ["lb_pair"]
        },
        {
          name: "token_y_mint",
          relations: ["lb_pair"]
        },
        {
          name: "bin_array_lower",
          writable: true
        },
        {
          name: "bin_array_upper",
          writable: true
        },
        {
          name: "sender",
          signer: true
        },
        {
          name: "token_x_program",
          address: "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA"
        },
        {
          name: "token_y_program",
          address: "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA"
        },
        {
          name: "event_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  95,
                  95,
                  101,
                  118,
                  101,
                  110,
                  116,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              }
            ]
          }
        },
        {
          name: "program"
        }
      ],
      args: [
        {
          name: "bin_liquidity_removal",
          type: {
            vec: {
              defined: {
                name: "BinLiquidityReduction"
              }
            }
          }
        }
      ]
    },
    {
      name: "remove_liquidity2",
      discriminator: [230, 215, 82, 127, 241, 101, 227, 146],
      accounts: [
        {
          name: "position",
          writable: true
        },
        {
          name: "lb_pair",
          writable: true,
          relations: ["position", "bin_array_bitmap_extension"]
        },
        {
          name: "bin_array_bitmap_extension",
          writable: true,
          optional: true
        },
        {
          name: "user_token_x",
          writable: true
        },
        {
          name: "user_token_y",
          writable: true
        },
        {
          name: "reserve_x",
          writable: true,
          relations: ["lb_pair"]
        },
        {
          name: "reserve_y",
          writable: true,
          relations: ["lb_pair"]
        },
        {
          name: "token_x_mint",
          relations: ["lb_pair"]
        },
        {
          name: "token_y_mint",
          relations: ["lb_pair"]
        },
        {
          name: "sender",
          signer: true
        },
        {
          name: "token_x_program"
        },
        {
          name: "token_y_program"
        },
        {
          name: "memo_program",
          address: "MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr"
        },
        {
          name: "event_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  95,
                  95,
                  101,
                  118,
                  101,
                  110,
                  116,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              }
            ]
          }
        },
        {
          name: "program"
        }
      ],
      args: [
        {
          name: "bin_liquidity_removal",
          type: {
            vec: {
              defined: {
                name: "BinLiquidityReduction"
              }
            }
          }
        },
        {
          name: "remaining_accounts_info",
          type: {
            defined: {
              name: "RemainingAccountsInfo"
            }
          }
        }
      ]
    },
    {
      name: "remove_liquidity_by_range",
      discriminator: [26, 82, 102, 152, 240, 74, 105, 26],
      accounts: [
        {
          name: "position",
          writable: true
        },
        {
          name: "lb_pair",
          writable: true,
          relations: [
            "position",
            "bin_array_bitmap_extension",
            "bin_array_lower",
            "bin_array_upper"
          ]
        },
        {
          name: "bin_array_bitmap_extension",
          writable: true,
          optional: true
        },
        {
          name: "user_token_x",
          writable: true
        },
        {
          name: "user_token_y",
          writable: true
        },
        {
          name: "reserve_x",
          writable: true,
          relations: ["lb_pair"]
        },
        {
          name: "reserve_y",
          writable: true,
          relations: ["lb_pair"]
        },
        {
          name: "token_x_mint",
          relations: ["lb_pair"]
        },
        {
          name: "token_y_mint",
          relations: ["lb_pair"]
        },
        {
          name: "bin_array_lower",
          writable: true
        },
        {
          name: "bin_array_upper",
          writable: true
        },
        {
          name: "sender",
          signer: true
        },
        {
          name: "token_x_program",
          address: "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA"
        },
        {
          name: "token_y_program",
          address: "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA"
        },
        {
          name: "event_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  95,
                  95,
                  101,
                  118,
                  101,
                  110,
                  116,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              }
            ]
          }
        },
        {
          name: "program"
        }
      ],
      args: [
        {
          name: "from_bin_id",
          type: "i32"
        },
        {
          name: "to_bin_id",
          type: "i32"
        },
        {
          name: "bps_to_remove",
          type: "u16"
        }
      ]
    },
    {
      name: "remove_liquidity_by_range2",
      discriminator: [204, 2, 195, 145, 53, 145, 145, 205],
      accounts: [
        {
          name: "position",
          writable: true
        },
        {
          name: "lb_pair",
          writable: true,
          relations: ["position", "bin_array_bitmap_extension"]
        },
        {
          name: "bin_array_bitmap_extension",
          writable: true,
          optional: true
        },
        {
          name: "user_token_x",
          writable: true
        },
        {
          name: "user_token_y",
          writable: true
        },
        {
          name: "reserve_x",
          writable: true,
          relations: ["lb_pair"]
        },
        {
          name: "reserve_y",
          writable: true,
          relations: ["lb_pair"]
        },
        {
          name: "token_x_mint",
          relations: ["lb_pair"]
        },
        {
          name: "token_y_mint",
          relations: ["lb_pair"]
        },
        {
          name: "sender",
          signer: true
        },
        {
          name: "token_x_program"
        },
        {
          name: "token_y_program"
        },
        {
          name: "memo_program",
          address: "MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr"
        },
        {
          name: "event_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  95,
                  95,
                  101,
                  118,
                  101,
                  110,
                  116,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              }
            ]
          }
        },
        {
          name: "program"
        }
      ],
      args: [
        {
          name: "from_bin_id",
          type: "i32"
        },
        {
          name: "to_bin_id",
          type: "i32"
        },
        {
          name: "bps_to_remove",
          type: "u16"
        },
        {
          name: "remaining_accounts_info",
          type: {
            defined: {
              name: "RemainingAccountsInfo"
            }
          }
        }
      ]
    },
    {
      name: "set_activation_point",
      discriminator: [91, 249, 15, 165, 26, 129, 254, 125],
      accounts: [
        {
          name: "lb_pair",
          writable: true
        },
        {
          name: "admin",
          writable: true,
          signer: true
        }
      ],
      args: [
        {
          name: "activation_point",
          type: "u64"
        }
      ]
    },
    {
      name: "set_pair_status",
      discriminator: [67, 248, 231, 137, 154, 149, 217, 174],
      accounts: [
        {
          name: "lb_pair",
          writable: true
        },
        {
          name: "admin",
          signer: true
        }
      ],
      args: [
        {
          name: "status",
          type: "u8"
        }
      ]
    },
    {
      name: "set_pair_status_permissionless",
      discriminator: [78, 59, 152, 211, 70, 183, 46, 208],
      accounts: [
        {
          name: "lb_pair",
          writable: true
        },
        {
          name: "creator",
          signer: true,
          relations: ["lb_pair"]
        }
      ],
      args: [
        {
          name: "status",
          type: "u8"
        }
      ]
    },
    {
      name: "set_pre_activation_duration",
      discriminator: [165, 61, 201, 244, 130, 159, 22, 100],
      accounts: [
        {
          name: "lb_pair",
          writable: true
        },
        {
          name: "creator",
          signer: true,
          relations: ["lb_pair"]
        }
      ],
      args: [
        {
          name: "pre_activation_duration",
          type: "u64"
        }
      ]
    },
    {
      name: "set_pre_activation_swap_address",
      discriminator: [57, 139, 47, 123, 216, 80, 223, 10],
      accounts: [
        {
          name: "lb_pair",
          writable: true
        },
        {
          name: "creator",
          signer: true,
          relations: ["lb_pair"]
        }
      ],
      args: [
        {
          name: "pre_activation_swap_address",
          type: "pubkey"
        }
      ]
    },
    {
      name: "swap",
      discriminator: [248, 198, 158, 145, 225, 117, 135, 200],
      accounts: [
        {
          name: "lb_pair",
          writable: true,
          relations: ["bin_array_bitmap_extension"]
        },
        {
          name: "bin_array_bitmap_extension",
          optional: true
        },
        {
          name: "reserve_x",
          writable: true,
          relations: ["lb_pair"]
        },
        {
          name: "reserve_y",
          writable: true,
          relations: ["lb_pair"]
        },
        {
          name: "user_token_in",
          writable: true
        },
        {
          name: "user_token_out",
          writable: true
        },
        {
          name: "token_x_mint",
          relations: ["lb_pair"]
        },
        {
          name: "token_y_mint",
          relations: ["lb_pair"]
        },
        {
          name: "oracle",
          writable: true,
          relations: ["lb_pair"]
        },
        {
          name: "host_fee_in",
          writable: true,
          optional: true
        },
        {
          name: "user",
          signer: true
        },
        {
          name: "token_x_program",
          address: "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA"
        },
        {
          name: "token_y_program",
          address: "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA"
        },
        {
          name: "event_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  95,
                  95,
                  101,
                  118,
                  101,
                  110,
                  116,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              }
            ]
          }
        },
        {
          name: "program"
        }
      ],
      args: [
        {
          name: "amount_in",
          type: "u64"
        },
        {
          name: "min_amount_out",
          type: "u64"
        }
      ]
    },
    {
      name: "swap2",
      discriminator: [65, 75, 63, 76, 235, 91, 91, 136],
      accounts: [
        {
          name: "lb_pair",
          writable: true,
          relations: ["bin_array_bitmap_extension"]
        },
        {
          name: "bin_array_bitmap_extension",
          optional: true
        },
        {
          name: "reserve_x",
          writable: true,
          relations: ["lb_pair"]
        },
        {
          name: "reserve_y",
          writable: true,
          relations: ["lb_pair"]
        },
        {
          name: "user_token_in",
          writable: true
        },
        {
          name: "user_token_out",
          writable: true
        },
        {
          name: "token_x_mint",
          relations: ["lb_pair"]
        },
        {
          name: "token_y_mint",
          relations: ["lb_pair"]
        },
        {
          name: "oracle",
          writable: true,
          relations: ["lb_pair"]
        },
        {
          name: "host_fee_in",
          writable: true,
          optional: true
        },
        {
          name: "user",
          signer: true
        },
        {
          name: "token_x_program"
        },
        {
          name: "token_y_program"
        },
        {
          name: "memo_program",
          address: "MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr"
        },
        {
          name: "event_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  95,
                  95,
                  101,
                  118,
                  101,
                  110,
                  116,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              }
            ]
          }
        },
        {
          name: "program"
        }
      ],
      args: [
        {
          name: "amount_in",
          type: "u64"
        },
        {
          name: "min_amount_out",
          type: "u64"
        },
        {
          name: "remaining_accounts_info",
          type: {
            defined: {
              name: "RemainingAccountsInfo"
            }
          }
        }
      ]
    },
    {
      name: "swap_exact_out",
      discriminator: [250, 73, 101, 33, 38, 207, 75, 184],
      accounts: [
        {
          name: "lb_pair",
          writable: true,
          relations: ["bin_array_bitmap_extension"]
        },
        {
          name: "bin_array_bitmap_extension",
          optional: true
        },
        {
          name: "reserve_x",
          writable: true,
          relations: ["lb_pair"]
        },
        {
          name: "reserve_y",
          writable: true,
          relations: ["lb_pair"]
        },
        {
          name: "user_token_in",
          writable: true
        },
        {
          name: "user_token_out",
          writable: true
        },
        {
          name: "token_x_mint",
          relations: ["lb_pair"]
        },
        {
          name: "token_y_mint",
          relations: ["lb_pair"]
        },
        {
          name: "oracle",
          writable: true,
          relations: ["lb_pair"]
        },
        {
          name: "host_fee_in",
          writable: true,
          optional: true
        },
        {
          name: "user",
          signer: true
        },
        {
          name: "token_x_program",
          address: "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA"
        },
        {
          name: "token_y_program",
          address: "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA"
        },
        {
          name: "event_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  95,
                  95,
                  101,
                  118,
                  101,
                  110,
                  116,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              }
            ]
          }
        },
        {
          name: "program"
        }
      ],
      args: [
        {
          name: "max_in_amount",
          type: "u64"
        },
        {
          name: "out_amount",
          type: "u64"
        }
      ]
    },
    {
      name: "swap_exact_out2",
      discriminator: [43, 215, 247, 132, 137, 60, 243, 81],
      accounts: [
        {
          name: "lb_pair",
          writable: true,
          relations: ["bin_array_bitmap_extension"]
        },
        {
          name: "bin_array_bitmap_extension",
          optional: true
        },
        {
          name: "reserve_x",
          writable: true,
          relations: ["lb_pair"]
        },
        {
          name: "reserve_y",
          writable: true,
          relations: ["lb_pair"]
        },
        {
          name: "user_token_in",
          writable: true
        },
        {
          name: "user_token_out",
          writable: true
        },
        {
          name: "token_x_mint",
          relations: ["lb_pair"]
        },
        {
          name: "token_y_mint",
          relations: ["lb_pair"]
        },
        {
          name: "oracle",
          writable: true,
          relations: ["lb_pair"]
        },
        {
          name: "host_fee_in",
          writable: true,
          optional: true
        },
        {
          name: "user",
          signer: true
        },
        {
          name: "token_x_program"
        },
        {
          name: "token_y_program"
        },
        {
          name: "memo_program",
          address: "MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr"
        },
        {
          name: "event_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  95,
                  95,
                  101,
                  118,
                  101,
                  110,
                  116,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              }
            ]
          }
        },
        {
          name: "program"
        }
      ],
      args: [
        {
          name: "max_in_amount",
          type: "u64"
        },
        {
          name: "out_amount",
          type: "u64"
        },
        {
          name: "remaining_accounts_info",
          type: {
            defined: {
              name: "RemainingAccountsInfo"
            }
          }
        }
      ]
    },
    {
      name: "swap_with_price_impact",
      discriminator: [56, 173, 230, 208, 173, 228, 156, 205],
      accounts: [
        {
          name: "lb_pair",
          writable: true,
          relations: ["bin_array_bitmap_extension"]
        },
        {
          name: "bin_array_bitmap_extension",
          optional: true
        },
        {
          name: "reserve_x",
          writable: true,
          relations: ["lb_pair"]
        },
        {
          name: "reserve_y",
          writable: true,
          relations: ["lb_pair"]
        },
        {
          name: "user_token_in",
          writable: true
        },
        {
          name: "user_token_out",
          writable: true
        },
        {
          name: "token_x_mint",
          relations: ["lb_pair"]
        },
        {
          name: "token_y_mint",
          relations: ["lb_pair"]
        },
        {
          name: "oracle",
          writable: true,
          relations: ["lb_pair"]
        },
        {
          name: "host_fee_in",
          writable: true,
          optional: true
        },
        {
          name: "user",
          signer: true
        },
        {
          name: "token_x_program",
          address: "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA"
        },
        {
          name: "token_y_program",
          address: "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA"
        },
        {
          name: "event_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  95,
                  95,
                  101,
                  118,
                  101,
                  110,
                  116,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              }
            ]
          }
        },
        {
          name: "program"
        }
      ],
      args: [
        {
          name: "amount_in",
          type: "u64"
        },
        {
          name: "active_id",
          type: {
            option: "i32"
          }
        },
        {
          name: "max_price_impact_bps",
          type: "u16"
        }
      ]
    },
    {
      name: "swap_with_price_impact2",
      discriminator: [74, 98, 192, 214, 177, 51, 75, 51],
      accounts: [
        {
          name: "lb_pair",
          writable: true,
          relations: ["bin_array_bitmap_extension"]
        },
        {
          name: "bin_array_bitmap_extension",
          optional: true
        },
        {
          name: "reserve_x",
          writable: true,
          relations: ["lb_pair"]
        },
        {
          name: "reserve_y",
          writable: true,
          relations: ["lb_pair"]
        },
        {
          name: "user_token_in",
          writable: true
        },
        {
          name: "user_token_out",
          writable: true
        },
        {
          name: "token_x_mint",
          relations: ["lb_pair"]
        },
        {
          name: "token_y_mint",
          relations: ["lb_pair"]
        },
        {
          name: "oracle",
          writable: true,
          relations: ["lb_pair"]
        },
        {
          name: "host_fee_in",
          writable: true,
          optional: true
        },
        {
          name: "user",
          signer: true
        },
        {
          name: "token_x_program"
        },
        {
          name: "token_y_program"
        },
        {
          name: "memo_program",
          address: "MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr"
        },
        {
          name: "event_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  95,
                  95,
                  101,
                  118,
                  101,
                  110,
                  116,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              }
            ]
          }
        },
        {
          name: "program"
        }
      ],
      args: [
        {
          name: "amount_in",
          type: "u64"
        },
        {
          name: "active_id",
          type: {
            option: "i32"
          }
        },
        {
          name: "max_price_impact_bps",
          type: "u16"
        },
        {
          name: "remaining_accounts_info",
          type: {
            defined: {
              name: "RemainingAccountsInfo"
            }
          }
        }
      ]
    },
    {
      name: "update_base_fee_parameters",
      discriminator: [75, 168, 223, 161, 16, 195, 3, 47],
      accounts: [
        {
          name: "lb_pair",
          writable: true
        },
        {
          name: "admin",
          signer: true
        },
        {
          name: "event_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  95,
                  95,
                  101,
                  118,
                  101,
                  110,
                  116,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              }
            ]
          }
        },
        {
          name: "program"
        }
      ],
      args: [
        {
          name: "fee_parameter",
          type: {
            defined: {
              name: "BaseFeeParameter"
            }
          }
        }
      ]
    },
    {
      name: "update_dynamic_fee_parameters",
      discriminator: [92, 161, 46, 246, 255, 189, 22, 22],
      accounts: [
        {
          name: "lb_pair",
          writable: true
        },
        {
          name: "admin",
          signer: true
        },
        {
          name: "event_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  95,
                  95,
                  101,
                  118,
                  101,
                  110,
                  116,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              }
            ]
          }
        },
        {
          name: "program"
        }
      ],
      args: [
        {
          name: "fee_parameter",
          type: {
            defined: {
              name: "DynamicFeeParameter"
            }
          }
        }
      ]
    },
    {
      name: "update_fees_and_reward2",
      discriminator: [32, 142, 184, 154, 103, 65, 184, 88],
      accounts: [
        {
          name: "position",
          writable: true
        },
        {
          name: "lb_pair",
          writable: true,
          relations: ["position"]
        },
        {
          name: "owner",
          signer: true
        }
      ],
      args: [
        {
          name: "min_bin_id",
          type: "i32"
        },
        {
          name: "max_bin_id",
          type: "i32"
        }
      ]
    },
    {
      name: "update_fees_and_rewards",
      discriminator: [154, 230, 250, 13, 236, 209, 75, 223],
      accounts: [
        {
          name: "position",
          writable: true
        },
        {
          name: "lb_pair",
          writable: true,
          relations: ["position", "bin_array_lower", "bin_array_upper"]
        },
        {
          name: "bin_array_lower",
          writable: true
        },
        {
          name: "bin_array_upper",
          writable: true
        },
        {
          name: "owner",
          signer: true
        }
      ],
      args: []
    },
    {
      name: "update_position_operator",
      discriminator: [202, 184, 103, 143, 180, 191, 116, 217],
      accounts: [
        {
          name: "position",
          writable: true
        },
        {
          name: "owner",
          signer: true,
          relations: ["position"]
        },
        {
          name: "event_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  95,
                  95,
                  101,
                  118,
                  101,
                  110,
                  116,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              }
            ]
          }
        },
        {
          name: "program"
        }
      ],
      args: [
        {
          name: "operator",
          type: "pubkey"
        }
      ]
    },
    {
      name: "update_reward_duration",
      discriminator: [138, 174, 196, 169, 213, 235, 254, 107],
      accounts: [
        {
          name: "lb_pair",
          writable: true,
          relations: ["bin_array"]
        },
        {
          name: "admin",
          signer: true
        },
        {
          name: "bin_array",
          writable: true
        },
        {
          name: "event_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  95,
                  95,
                  101,
                  118,
                  101,
                  110,
                  116,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              }
            ]
          }
        },
        {
          name: "program"
        }
      ],
      args: [
        {
          name: "reward_index",
          type: "u64"
        },
        {
          name: "new_duration",
          type: "u64"
        }
      ]
    },
    {
      name: "update_reward_funder",
      discriminator: [211, 28, 48, 32, 215, 160, 35, 23],
      accounts: [
        {
          name: "lb_pair",
          writable: true
        },
        {
          name: "admin",
          signer: true
        },
        {
          name: "event_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  95,
                  95,
                  101,
                  118,
                  101,
                  110,
                  116,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              }
            ]
          }
        },
        {
          name: "program"
        }
      ],
      args: [
        {
          name: "reward_index",
          type: "u64"
        },
        {
          name: "new_funder",
          type: "pubkey"
        }
      ]
    },
    {
      name: "withdraw_ineligible_reward",
      discriminator: [148, 206, 42, 195, 247, 49, 103, 8],
      accounts: [
        {
          name: "lb_pair",
          writable: true,
          relations: ["bin_array"]
        },
        {
          name: "reward_vault",
          writable: true
        },
        {
          name: "reward_mint"
        },
        {
          name: "funder_token_account",
          writable: true
        },
        {
          name: "funder",
          signer: true
        },
        {
          name: "bin_array",
          writable: true
        },
        {
          name: "token_program"
        },
        {
          name: "memo_program",
          address: "MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr"
        },
        {
          name: "event_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  95,
                  95,
                  101,
                  118,
                  101,
                  110,
                  116,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              }
            ]
          }
        },
        {
          name: "program"
        }
      ],
      args: [
        {
          name: "reward_index",
          type: "u64"
        },
        {
          name: "remaining_accounts_info",
          type: {
            defined: {
              name: "RemainingAccountsInfo"
            }
          }
        }
      ]
    },
    {
      name: "withdraw_protocol_fee",
      discriminator: [158, 201, 158, 189, 33, 93, 162, 103],
      accounts: [
        {
          name: "lb_pair",
          writable: true
        },
        {
          name: "reserve_x",
          writable: true,
          relations: ["lb_pair"]
        },
        {
          name: "reserve_y",
          writable: true,
          relations: ["lb_pair"]
        },
        {
          name: "token_x_mint",
          relations: ["lb_pair"]
        },
        {
          name: "token_y_mint",
          relations: ["lb_pair"]
        },
        {
          name: "receiver_token_x",
          writable: true,
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  8,
                  234,
                  192,
                  109,
                  87,
                  125,
                  190,
                  55,
                  129,
                  173,
                  227,
                  8,
                  104,
                  201,
                  104,
                  13,
                  31,
                  178,
                  74,
                  80,
                  54,
                  14,
                  77,
                  78,
                  226,
                  57,
                  47,
                  122,
                  166,
                  165,
                  57,
                  144
                ]
              },
              {
                kind: "account",
                path: "token_x_program"
              },
              {
                kind: "account",
                path: "token_x_mint"
              }
            ],
            program: {
              kind: "const",
              value: [
                140,
                151,
                37,
                143,
                78,
                36,
                137,
                241,
                187,
                61,
                16,
                41,
                20,
                142,
                13,
                131,
                11,
                90,
                19,
                153,
                218,
                255,
                16,
                132,
                4,
                142,
                123,
                216,
                219,
                233,
                248,
                89
              ]
            }
          }
        },
        {
          name: "receiver_token_y",
          writable: true,
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  8,
                  234,
                  192,
                  109,
                  87,
                  125,
                  190,
                  55,
                  129,
                  173,
                  227,
                  8,
                  104,
                  201,
                  104,
                  13,
                  31,
                  178,
                  74,
                  80,
                  54,
                  14,
                  77,
                  78,
                  226,
                  57,
                  47,
                  122,
                  166,
                  165,
                  57,
                  144
                ]
              },
              {
                kind: "account",
                path: "token_y_program"
              },
              {
                kind: "account",
                path: "token_y_mint"
              }
            ],
            program: {
              kind: "const",
              value: [
                140,
                151,
                37,
                143,
                78,
                36,
                137,
                241,
                187,
                61,
                16,
                41,
                20,
                142,
                13,
                131,
                11,
                90,
                19,
                153,
                218,
                255,
                16,
                132,
                4,
                142,
                123,
                216,
                219,
                233,
                248,
                89
              ]
            }
          }
        },
        {
          name: "claim_fee_operator"
        },
        {
          name: "operator",
          docs: ["operator"],
          signer: true,
          relations: ["claim_fee_operator"]
        },
        {
          name: "token_x_program"
        },
        {
          name: "token_y_program"
        },
        {
          name: "memo_program",
          address: "MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr"
        }
      ],
      args: [
        {
          name: "max_amount_x",
          type: "u64"
        },
        {
          name: "max_amount_y",
          type: "u64"
        },
        {
          name: "remaining_accounts_info",
          type: {
            defined: {
              name: "RemainingAccountsInfo"
            }
          }
        }
      ]
    }
  ],
  accounts: [
    {
      name: "BinArray",
      discriminator: [92, 142, 92, 220, 5, 148, 70, 181]
    },
    {
      name: "BinArrayBitmapExtension",
      discriminator: [80, 111, 124, 113, 55, 237, 18, 5]
    },
    {
      name: "ClaimFeeOperator",
      discriminator: [166, 48, 134, 86, 34, 200, 188, 150]
    },
    {
      name: "DummyZcAccount",
      discriminator: [94, 107, 238, 80, 208, 48, 180, 8]
    },
    {
      name: "LbPair",
      discriminator: [33, 11, 49, 98, 181, 101, 177, 13]
    },
    {
      name: "Oracle",
      discriminator: [139, 194, 131, 179, 140, 179, 229, 244]
    },
    {
      name: "Position",
      discriminator: [170, 188, 143, 228, 122, 64, 247, 208]
    },
    {
      name: "PositionV2",
      discriminator: [117, 176, 212, 199, 245, 180, 133, 182]
    },
    {
      name: "PresetParameter",
      discriminator: [242, 62, 244, 34, 181, 112, 58, 170]
    },
    {
      name: "PresetParameter2",
      discriminator: [171, 236, 148, 115, 162, 113, 222, 174]
    },
    {
      name: "TokenBadge",
      discriminator: [116, 219, 204, 229, 249, 116, 255, 150]
    }
  ],
  events: [
    {
      name: "AddLiquidity",
      discriminator: [31, 94, 125, 90, 227, 52, 61, 186]
    },
    {
      name: "ClaimFee",
      discriminator: [75, 122, 154, 48, 140, 74, 123, 163]
    },
    {
      name: "ClaimFee2",
      discriminator: [232, 171, 242, 97, 58, 77, 35, 45]
    },
    {
      name: "ClaimReward",
      discriminator: [148, 116, 134, 204, 22, 171, 85, 95]
    },
    {
      name: "ClaimReward2",
      discriminator: [27, 143, 244, 33, 80, 43, 110, 146]
    },
    {
      name: "CompositionFee",
      discriminator: [128, 151, 123, 106, 17, 102, 113, 142]
    },
    {
      name: "DecreasePositionLength",
      discriminator: [52, 118, 235, 85, 172, 169, 15, 128]
    },
    {
      name: "DynamicFeeParameterUpdate",
      discriminator: [88, 88, 178, 135, 194, 146, 91, 243]
    },
    {
      name: "FeeParameterUpdate",
      discriminator: [48, 76, 241, 117, 144, 215, 242, 44]
    },
    {
      name: "FundReward",
      discriminator: [246, 228, 58, 130, 145, 170, 79, 204]
    },
    {
      name: "GoToABin",
      discriminator: [59, 138, 76, 68, 138, 131, 176, 67]
    },
    {
      name: "IncreaseObservation",
      discriminator: [99, 249, 17, 121, 166, 156, 207, 215]
    },
    {
      name: "IncreasePositionLength",
      discriminator: [157, 239, 42, 204, 30, 56, 223, 46]
    },
    {
      name: "InitializeReward",
      discriminator: [211, 153, 88, 62, 149, 60, 177, 70]
    },
    {
      name: "LbPairCreate",
      discriminator: [185, 74, 252, 125, 27, 215, 188, 111]
    },
    {
      name: "PositionClose",
      discriminator: [255, 196, 16, 107, 28, 202, 53, 128]
    },
    {
      name: "PositionCreate",
      discriminator: [144, 142, 252, 84, 157, 53, 37, 121]
    },
    {
      name: "Rebalancing",
      discriminator: [0, 109, 117, 179, 61, 91, 199, 200]
    },
    {
      name: "RemoveLiquidity",
      discriminator: [116, 244, 97, 232, 103, 31, 152, 58]
    },
    {
      name: "Swap",
      discriminator: [81, 108, 227, 190, 205, 208, 10, 196]
    },
    {
      name: "UpdatePositionLockReleasePoint",
      discriminator: [133, 214, 66, 224, 64, 12, 7, 191]
    },
    {
      name: "UpdatePositionOperator",
      discriminator: [39, 115, 48, 204, 246, 47, 66, 57]
    },
    {
      name: "UpdateRewardDuration",
      discriminator: [223, 245, 224, 153, 49, 29, 163, 172]
    },
    {
      name: "UpdateRewardFunder",
      discriminator: [224, 178, 174, 74, 252, 165, 85, 180]
    },
    {
      name: "WithdrawIneligibleReward",
      discriminator: [231, 189, 65, 149, 102, 215, 154, 244]
    }
  ],
  errors: [
    {
      code: 6e3,
      name: "InvalidStartBinIndex",
      msg: "Invalid start bin index"
    },
    {
      code: 6001,
      name: "InvalidBinId",
      msg: "Invalid bin id"
    },
    {
      code: 6002,
      name: "InvalidInput",
      msg: "Invalid input data"
    },
    {
      code: 6003,
      name: "ExceededAmountSlippageTolerance",
      msg: "Exceeded amount slippage tolerance"
    },
    {
      code: 6004,
      name: "ExceededBinSlippageTolerance",
      msg: "Exceeded bin slippage tolerance"
    },
    {
      code: 6005,
      name: "CompositionFactorFlawed",
      msg: "Composition factor flawed"
    },
    {
      code: 6006,
      name: "NonPresetBinStep",
      msg: "Non preset bin step"
    },
    {
      code: 6007,
      name: "ZeroLiquidity",
      msg: "Zero liquidity"
    },
    {
      code: 6008,
      name: "InvalidPosition",
      msg: "Invalid position"
    },
    {
      code: 6009,
      name: "BinArrayNotFound",
      msg: "Bin array not found"
    },
    {
      code: 6010,
      name: "InvalidTokenMint",
      msg: "Invalid token mint"
    },
    {
      code: 6011,
      name: "InvalidAccountForSingleDeposit",
      msg: "Invalid account for single deposit"
    },
    {
      code: 6012,
      name: "PairInsufficientLiquidity",
      msg: "Pair insufficient liquidity"
    },
    {
      code: 6013,
      name: "InvalidFeeOwner",
      msg: "Invalid fee owner"
    },
    {
      code: 6014,
      name: "InvalidFeeWithdrawAmount",
      msg: "Invalid fee withdraw amount"
    },
    {
      code: 6015,
      name: "InvalidAdmin",
      msg: "Invalid admin"
    },
    {
      code: 6016,
      name: "IdenticalFeeOwner",
      msg: "Identical fee owner"
    },
    {
      code: 6017,
      name: "InvalidBps",
      msg: "Invalid basis point"
    },
    {
      code: 6018,
      name: "MathOverflow",
      msg: "Math operation overflow"
    },
    {
      code: 6019,
      name: "TypeCastFailed",
      msg: "Type cast error"
    },
    {
      code: 6020,
      name: "InvalidRewardIndex",
      msg: "Invalid reward index"
    },
    {
      code: 6021,
      name: "InvalidRewardDuration",
      msg: "Invalid reward duration"
    },
    {
      code: 6022,
      name: "RewardInitialized",
      msg: "Reward already initialized"
    },
    {
      code: 6023,
      name: "RewardUninitialized",
      msg: "Reward not initialized"
    },
    {
      code: 6024,
      name: "IdenticalFunder",
      msg: "Identical funder"
    },
    {
      code: 6025,
      name: "RewardCampaignInProgress",
      msg: "Reward campaign in progress"
    },
    {
      code: 6026,
      name: "IdenticalRewardDuration",
      msg: "Reward duration is the same"
    },
    {
      code: 6027,
      name: "InvalidBinArray",
      msg: "Invalid bin array"
    },
    {
      code: 6028,
      name: "NonContinuousBinArrays",
      msg: "Bin arrays must be continuous"
    },
    {
      code: 6029,
      name: "InvalidRewardVault",
      msg: "Invalid reward vault"
    },
    {
      code: 6030,
      name: "NonEmptyPosition",
      msg: "Position is not empty"
    },
    {
      code: 6031,
      name: "UnauthorizedAccess",
      msg: "Unauthorized access"
    },
    {
      code: 6032,
      name: "InvalidFeeParameter",
      msg: "Invalid fee parameter"
    },
    {
      code: 6033,
      name: "MissingOracle",
      msg: "Missing oracle account"
    },
    {
      code: 6034,
      name: "InsufficientSample",
      msg: "Insufficient observation sample"
    },
    {
      code: 6035,
      name: "InvalidLookupTimestamp",
      msg: "Invalid lookup timestamp"
    },
    {
      code: 6036,
      name: "BitmapExtensionAccountIsNotProvided",
      msg: "Bitmap extension account is not provided"
    },
    {
      code: 6037,
      name: "CannotFindNonZeroLiquidityBinArrayId",
      msg: "Cannot find non-zero liquidity binArrayId"
    },
    {
      code: 6038,
      name: "BinIdOutOfBound",
      msg: "Bin id out of bound"
    },
    {
      code: 6039,
      name: "InsufficientOutAmount",
      msg: "Insufficient amount in for minimum out"
    },
    {
      code: 6040,
      name: "InvalidPositionWidth",
      msg: "Invalid position width"
    },
    {
      code: 6041,
      name: "ExcessiveFeeUpdate",
      msg: "Excessive fee update"
    },
    {
      code: 6042,
      name: "PoolDisabled",
      msg: "Pool disabled"
    },
    {
      code: 6043,
      name: "InvalidPoolType",
      msg: "Invalid pool type"
    },
    {
      code: 6044,
      name: "ExceedMaxWhitelist",
      msg: "Whitelist for wallet is full"
    },
    {
      code: 6045,
      name: "InvalidIndex",
      msg: "Invalid index"
    },
    {
      code: 6046,
      name: "RewardNotEnded",
      msg: "Reward not ended"
    },
    {
      code: 6047,
      name: "MustWithdrawnIneligibleReward",
      msg: "Must withdraw ineligible reward"
    },
    {
      code: 6048,
      name: "UnauthorizedAddress",
      msg: "Unauthorized address"
    },
    {
      code: 6049,
      name: "OperatorsAreTheSame",
      msg: "Cannot update because operators are the same"
    },
    {
      code: 6050,
      name: "WithdrawToWrongTokenAccount",
      msg: "Withdraw to wrong token account"
    },
    {
      code: 6051,
      name: "WrongRentReceiver",
      msg: "Wrong rent receiver"
    },
    {
      code: 6052,
      name: "AlreadyPassActivationPoint",
      msg: "Already activated"
    },
    {
      code: 6053,
      name: "ExceedMaxSwappedAmount",
      msg: "Swapped amount is exceeded max swapped amount"
    },
    {
      code: 6054,
      name: "InvalidStrategyParameters",
      msg: "Invalid strategy parameters"
    },
    {
      code: 6055,
      name: "LiquidityLocked",
      msg: "Liquidity locked"
    },
    {
      code: 6056,
      name: "BinRangeIsNotEmpty",
      msg: "Bin range is not empty"
    },
    {
      code: 6057,
      name: "NotExactAmountOut",
      msg: "Amount out is not matched with exact amount out"
    },
    {
      code: 6058,
      name: "InvalidActivationType",
      msg: "Invalid activation type"
    },
    {
      code: 6059,
      name: "InvalidActivationDuration",
      msg: "Invalid activation duration"
    },
    {
      code: 6060,
      name: "MissingTokenAmountAsTokenLaunchProof",
      msg: "Missing token amount as token launch owner proof"
    },
    {
      code: 6061,
      name: "InvalidQuoteToken",
      msg: "Quote token must be SOL or USDC"
    },
    {
      code: 6062,
      name: "InvalidBinStep",
      msg: "Invalid bin step"
    },
    {
      code: 6063,
      name: "InvalidBaseFee",
      msg: "Invalid base fee"
    },
    {
      code: 6064,
      name: "InvalidPreActivationDuration",
      msg: "Invalid pre-activation duration"
    },
    {
      code: 6065,
      name: "AlreadyPassPreActivationSwapPoint",
      msg: "Already pass pre-activation swap point"
    },
    {
      code: 6066,
      name: "InvalidStatus",
      msg: "Invalid status"
    },
    {
      code: 6067,
      name: "ExceededMaxOracleLength",
      msg: "Exceed max oracle length"
    },
    {
      code: 6068,
      name: "InvalidMinimumLiquidity",
      msg: "Invalid minimum liquidity"
    },
    {
      code: 6069,
      name: "NotSupportMint",
      msg: "Not support token_2022 mint extension"
    },
    {
      code: 6070,
      name: "UnsupportedMintExtension",
      msg: "Unsupported mint extension"
    },
    {
      code: 6071,
      name: "UnsupportNativeMintToken2022",
      msg: "Unsupported native mint token2022"
    },
    {
      code: 6072,
      name: "UnmatchTokenMint",
      msg: "Unmatch token mint"
    },
    {
      code: 6073,
      name: "UnsupportedTokenMint",
      msg: "Unsupported token mint"
    },
    {
      code: 6074,
      name: "InsufficientRemainingAccounts",
      msg: "Insufficient remaining accounts"
    },
    {
      code: 6075,
      name: "InvalidRemainingAccountSlice",
      msg: "Invalid remaining account slice"
    },
    {
      code: 6076,
      name: "DuplicatedRemainingAccountTypes",
      msg: "Duplicated remaining account types"
    },
    {
      code: 6077,
      name: "MissingRemainingAccountForTransferHook",
      msg: "Missing remaining account for transfer hook"
    },
    {
      code: 6078,
      name: "NoTransferHookProgram",
      msg: "Remaining account was passed for transfer hook but there's no hook program"
    },
    {
      code: 6079,
      name: "ZeroFundedAmount",
      msg: "Zero funded amount"
    },
    {
      code: 6080,
      name: "InvalidSide",
      msg: "Invalid side"
    },
    {
      code: 6081,
      name: "InvalidResizeLength",
      msg: "Invalid resize length"
    },
    {
      code: 6082,
      name: "NotSupportAtTheMoment",
      msg: "Not support at the moment"
    },
    {
      code: 6083,
      name: "InvalidRebalanceParameters",
      msg: "Invalid rebalance parameters"
    },
    {
      code: 6084,
      name: "InvalidRewardAccounts",
      msg: "Invalid reward accounts"
    },
    {
      code: 6085,
      name: "UndeterminedError",
      msg: "Undetermined error"
    },
    {
      code: 6086,
      name: "ReallocExceedMaxLengthPerInstruction",
      msg: "Realloc exceed max length per instruction"
    },
    {
      code: 6087,
      name: "InvalidBaseFeeMantissa",
      msg: "Mantissa cannot more than two significant digits"
    },
    {
      code: 6088,
      name: "InvalidPositionOwner",
      msg: "Invalid position owner"
    },
    {
      code: 6089,
      name: "InvalidPoolAddress",
      msg: "Invalid pool address"
    }
  ],
  types: [
    {
      name: "AccountsType",
      type: {
        kind: "enum",
        variants: [
          {
            name: "TransferHookX"
          },
          {
            name: "TransferHookY"
          },
          {
            name: "TransferHookReward"
          },
          {
            name: "TransferHookMultiReward",
            fields: ["u8"]
          }
        ]
      }
    },
    {
      name: "ActivationType",
      docs: ["Type of the activation"],
      repr: {
        kind: "rust"
      },
      type: {
        kind: "enum",
        variants: [
          {
            name: "Slot"
          },
          {
            name: "Timestamp"
          }
        ]
      }
    },
    {
      name: "AddLiquidity",
      type: {
        kind: "struct",
        fields: [
          {
            name: "lb_pair",
            type: "pubkey"
          },
          {
            name: "from",
            type: "pubkey"
          },
          {
            name: "position",
            type: "pubkey"
          },
          {
            name: "amounts",
            type: {
              array: ["u64", 2]
            }
          },
          {
            name: "active_bin_id",
            type: "i32"
          }
        ]
      }
    },
    {
      name: "AddLiquidityParams",
      type: {
        kind: "struct",
        fields: [
          {
            name: "min_delta_id",
            type: "i32"
          },
          {
            name: "max_delta_id",
            type: "i32"
          },
          {
            name: "x0",
            type: "u64"
          },
          {
            name: "y0",
            type: "u64"
          },
          {
            name: "delta_x",
            type: "u64"
          },
          {
            name: "delta_y",
            type: "u64"
          },
          {
            name: "bit_flag",
            type: "u8"
          },
          {
            name: "favor_x_in_active_id",
            type: "bool"
          },
          {
            name: "padding",
            type: {
              array: ["u8", 16]
            }
          }
        ]
      }
    },
    {
      name: "AddLiquiditySingleSidePreciseParameter",
      type: {
        kind: "struct",
        fields: [
          {
            name: "bins",
            type: {
              vec: {
                defined: {
                  name: "CompressedBinDepositAmount"
                }
              }
            }
          },
          {
            name: "decompress_multiplier",
            type: "u64"
          }
        ]
      }
    },
    {
      name: "AddLiquiditySingleSidePreciseParameter2",
      type: {
        kind: "struct",
        fields: [
          {
            name: "bins",
            type: {
              vec: {
                defined: {
                  name: "CompressedBinDepositAmount"
                }
              }
            }
          },
          {
            name: "decompress_multiplier",
            type: "u64"
          },
          {
            name: "max_amount",
            type: "u64"
          }
        ]
      }
    },
    {
      name: "BaseFeeParameter",
      type: {
        kind: "struct",
        fields: [
          {
            name: "protocol_share",
            docs: [
              "Portion of swap fees retained by the protocol by controlling protocol_share parameter. protocol_swap_fee = protocol_share * total_swap_fee"
            ],
            type: "u16"
          },
          {
            name: "base_factor",
            docs: ["Base factor for base fee rate"],
            type: "u16"
          },
          {
            name: "base_fee_power_factor",
            docs: ["Base fee power factor"],
            type: "u8"
          }
        ]
      }
    },
    {
      name: "Bin",
      serialization: "bytemuck",
      repr: {
        kind: "c"
      },
      type: {
        kind: "struct",
        fields: [
          {
            name: "amount_x",
            docs: [
              "Amount of token X in the bin. This already excluded protocol fees."
            ],
            type: "u64"
          },
          {
            name: "amount_y",
            docs: [
              "Amount of token Y in the bin. This already excluded protocol fees."
            ],
            type: "u64"
          },
          {
            name: "price",
            docs: ["Bin price"],
            type: "u128"
          },
          {
            name: "liquidity_supply",
            docs: [
              "Liquidities of the bin. This is the same as LP mint supply. q-number"
            ],
            type: "u128"
          },
          {
            name: "reward_per_token_stored",
            docs: ["reward_a_per_token_stored"],
            type: {
              array: ["u128", 2]
            }
          },
          {
            name: "fee_amount_x_per_token_stored",
            docs: ["Swap fee amount of token X per liquidity deposited."],
            type: "u128"
          },
          {
            name: "fee_amount_y_per_token_stored",
            docs: ["Swap fee amount of token Y per liquidity deposited."],
            type: "u128"
          },
          {
            name: "amount_x_in",
            docs: [
              "Total token X swap into the bin. Only used for tracking purpose."
            ],
            type: "u128"
          },
          {
            name: "amount_y_in",
            docs: [
              "Total token Y swap into he bin. Only used for tracking purpose."
            ],
            type: "u128"
          }
        ]
      }
    },
    {
      name: "BinArray",
      docs: [
        "An account to contain a range of bin. For example: Bin 100 <-> 200.",
        "For example:",
        "BinArray index: 0 contains bin 0 <-> 599",
        "index: 2 contains bin 600 <-> 1199, ..."
      ],
      serialization: "bytemuck",
      repr: {
        kind: "c"
      },
      type: {
        kind: "struct",
        fields: [
          {
            name: "index",
            type: "i64"
          },
          {
            name: "version",
            docs: ["Version of binArray"],
            type: "u8"
          },
          {
            name: "_padding",
            type: {
              array: ["u8", 7]
            }
          },
          {
            name: "lb_pair",
            type: "pubkey"
          },
          {
            name: "bins",
            type: {
              array: [
                {
                  defined: {
                    name: "Bin"
                  }
                },
                70
              ]
            }
          }
        ]
      }
    },
    {
      name: "BinArrayBitmapExtension",
      serialization: "bytemuck",
      repr: {
        kind: "c"
      },
      type: {
        kind: "struct",
        fields: [
          {
            name: "lb_pair",
            type: "pubkey"
          },
          {
            name: "positive_bin_array_bitmap",
            docs: [
              "Packed initialized bin array state for start_bin_index is positive"
            ],
            type: {
              array: [
                {
                  array: ["u64", 8]
                },
                12
              ]
            }
          },
          {
            name: "negative_bin_array_bitmap",
            docs: [
              "Packed initialized bin array state for start_bin_index is negative"
            ],
            type: {
              array: [
                {
                  array: ["u64", 8]
                },
                12
              ]
            }
          }
        ]
      }
    },
    {
      name: "BinLiquidityDistribution",
      type: {
        kind: "struct",
        fields: [
          {
            name: "bin_id",
            docs: ["Define the bin ID wish to deposit to."],
            type: "i32"
          },
          {
            name: "distribution_x",
            docs: [
              "DistributionX (or distributionY) is the percentages of amountX (or amountY) you want to add to each bin."
            ],
            type: "u16"
          },
          {
            name: "distribution_y",
            docs: [
              "DistributionX (or distributionY) is the percentages of amountX (or amountY) you want to add to each bin."
            ],
            type: "u16"
          }
        ]
      }
    },
    {
      name: "BinLiquidityDistributionByWeight",
      type: {
        kind: "struct",
        fields: [
          {
            name: "bin_id",
            docs: ["Define the bin ID wish to deposit to."],
            type: "i32"
          },
          {
            name: "weight",
            docs: ["weight of liquidity distributed for this bin id"],
            type: "u16"
          }
        ]
      }
    },
    {
      name: "BinLiquidityReduction",
      type: {
        kind: "struct",
        fields: [
          {
            name: "bin_id",
            type: "i32"
          },
          {
            name: "bps_to_remove",
            type: "u16"
          }
        ]
      }
    },
    {
      name: "ClaimFee",
      type: {
        kind: "struct",
        fields: [
          {
            name: "lb_pair",
            type: "pubkey"
          },
          {
            name: "position",
            type: "pubkey"
          },
          {
            name: "owner",
            type: "pubkey"
          },
          {
            name: "fee_x",
            type: "u64"
          },
          {
            name: "fee_y",
            type: "u64"
          }
        ]
      }
    },
    {
      name: "ClaimFee2",
      type: {
        kind: "struct",
        fields: [
          {
            name: "lb_pair",
            type: "pubkey"
          },
          {
            name: "position",
            type: "pubkey"
          },
          {
            name: "owner",
            type: "pubkey"
          },
          {
            name: "fee_x",
            type: "u64"
          },
          {
            name: "fee_y",
            type: "u64"
          },
          {
            name: "active_bin_id",
            type: "i32"
          }
        ]
      }
    },
    {
      name: "ClaimFeeOperator",
      docs: ["Parameter that set by the protocol"],
      serialization: "bytemuck",
      repr: {
        kind: "c"
      },
      type: {
        kind: "struct",
        fields: [
          {
            name: "operator",
            docs: ["operator"],
            type: "pubkey"
          },
          {
            name: "_padding",
            docs: ["Reserve"],
            type: {
              array: ["u8", 128]
            }
          }
        ]
      }
    },
    {
      name: "ClaimReward",
      type: {
        kind: "struct",
        fields: [
          {
            name: "lb_pair",
            type: "pubkey"
          },
          {
            name: "position",
            type: "pubkey"
          },
          {
            name: "owner",
            type: "pubkey"
          },
          {
            name: "reward_index",
            type: "u64"
          },
          {
            name: "total_reward",
            type: "u64"
          }
        ]
      }
    },
    {
      name: "ClaimReward2",
      type: {
        kind: "struct",
        fields: [
          {
            name: "lb_pair",
            type: "pubkey"
          },
          {
            name: "position",
            type: "pubkey"
          },
          {
            name: "owner",
            type: "pubkey"
          },
          {
            name: "reward_index",
            type: "u64"
          },
          {
            name: "total_reward",
            type: "u64"
          },
          {
            name: "active_bin_id",
            type: "i32"
          }
        ]
      }
    },
    {
      name: "CompositionFee",
      type: {
        kind: "struct",
        fields: [
          {
            name: "from",
            type: "pubkey"
          },
          {
            name: "bin_id",
            type: "i16"
          },
          {
            name: "token_x_fee_amount",
            type: "u64"
          },
          {
            name: "token_y_fee_amount",
            type: "u64"
          },
          {
            name: "protocol_token_x_fee_amount",
            type: "u64"
          },
          {
            name: "protocol_token_y_fee_amount",
            type: "u64"
          }
        ]
      }
    },
    {
      name: "CompressedBinDepositAmount",
      type: {
        kind: "struct",
        fields: [
          {
            name: "bin_id",
            type: "i32"
          },
          {
            name: "amount",
            type: "u32"
          }
        ]
      }
    },
    {
      name: "CustomizableParams",
      type: {
        kind: "struct",
        fields: [
          {
            name: "active_id",
            docs: ["Pool price"],
            type: "i32"
          },
          {
            name: "bin_step",
            docs: ["Bin step"],
            type: "u16"
          },
          {
            name: "base_factor",
            docs: ["Base factor"],
            type: "u16"
          },
          {
            name: "activation_type",
            docs: [
              "Activation type. 0 = Slot, 1 = Time. Check ActivationType enum"
            ],
            type: "u8"
          },
          {
            name: "has_alpha_vault",
            docs: ["Whether the pool has an alpha vault"],
            type: "bool"
          },
          {
            name: "activation_point",
            docs: ["Decide when does the pool start trade. None = Now"],
            type: {
              option: "u64"
            }
          },
          {
            name: "creator_pool_on_off_control",
            docs: [
              "Pool creator have permission to enable/disable pool with restricted program validation. Only applicable for customizable permissionless pool."
            ],
            type: "bool"
          },
          {
            name: "base_fee_power_factor",
            docs: ["Base fee power factor"],
            type: "u8"
          },
          {
            name: "padding",
            docs: ["Padding, for future use"],
            type: {
              array: ["u8", 62]
            }
          }
        ]
      }
    },
    {
      name: "DecreasePositionLength",
      type: {
        kind: "struct",
        fields: [
          {
            name: "lb_pair",
            type: "pubkey"
          },
          {
            name: "position",
            type: "pubkey"
          },
          {
            name: "owner",
            type: "pubkey"
          },
          {
            name: "length_to_remove",
            type: "u16"
          },
          {
            name: "side",
            type: "u8"
          }
        ]
      }
    },
    {
      name: "DummyIx",
      type: {
        kind: "struct",
        fields: [
          {
            name: "_pair_status",
            type: {
              defined: {
                name: "PairStatus"
              }
            }
          },
          {
            name: "_pair_type",
            type: {
              defined: {
                name: "PairType"
              }
            }
          },
          {
            name: "_activation_type",
            type: {
              defined: {
                name: "ActivationType"
              }
            }
          },
          {
            name: "_token_program_flag",
            type: {
              defined: {
                name: "TokenProgramFlags"
              }
            }
          },
          {
            name: "_resize_side",
            type: {
              defined: {
                name: "ResizeSide"
              }
            }
          },
          {
            name: "_rounding",
            type: {
              defined: {
                name: "Rounding"
              }
            }
          }
        ]
      }
    },
    {
      name: "DummyZcAccount",
      serialization: "bytemuck",
      repr: {
        kind: "c"
      },
      type: {
        kind: "struct",
        fields: [
          {
            name: "position_bin_data",
            type: {
              defined: {
                name: "PositionBinData"
              }
            }
          }
        ]
      }
    },
    {
      name: "DynamicFeeParameter",
      type: {
        kind: "struct",
        fields: [
          {
            name: "filter_period",
            docs: [
              "Filter period determine high frequency trading time window."
            ],
            type: "u16"
          },
          {
            name: "decay_period",
            docs: [
              "Decay period determine when the volatile fee start decay / decrease."
            ],
            type: "u16"
          },
          {
            name: "reduction_factor",
            docs: [
              "Reduction factor controls the volatile fee rate decrement rate."
            ],
            type: "u16"
          },
          {
            name: "variable_fee_control",
            docs: [
              "Used to scale the variable fee component depending on the dynamic of the market"
            ],
            type: "u32"
          },
          {
            name: "max_volatility_accumulator",
            docs: [
              "Maximum number of bin crossed can be accumulated. Used to cap volatile fee rate."
            ],
            type: "u32"
          }
        ]
      }
    },
    {
      name: "DynamicFeeParameterUpdate",
      type: {
        kind: "struct",
        fields: [
          {
            name: "lb_pair",
            type: "pubkey"
          },
          {
            name: "filter_period",
            docs: [
              "Filter period determine high frequency trading time window."
            ],
            type: "u16"
          },
          {
            name: "decay_period",
            docs: [
              "Decay period determine when the volatile fee start decay / decrease."
            ],
            type: "u16"
          },
          {
            name: "reduction_factor",
            docs: [
              "Reduction factor controls the volatile fee rate decrement rate."
            ],
            type: "u16"
          },
          {
            name: "variable_fee_control",
            docs: [
              "Used to scale the variable fee component depending on the dynamic of the market"
            ],
            type: "u32"
          },
          {
            name: "max_volatility_accumulator",
            docs: [
              "Maximum number of bin crossed can be accumulated. Used to cap volatile fee rate."
            ],
            type: "u32"
          }
        ]
      }
    },
    {
      name: "FeeInfo",
      serialization: "bytemuck",
      repr: {
        kind: "c"
      },
      type: {
        kind: "struct",
        fields: [
          {
            name: "fee_x_per_token_complete",
            type: "u128"
          },
          {
            name: "fee_y_per_token_complete",
            type: "u128"
          },
          {
            name: "fee_x_pending",
            type: "u64"
          },
          {
            name: "fee_y_pending",
            type: "u64"
          }
        ]
      }
    },
    {
      name: "FeeParameterUpdate",
      type: {
        kind: "struct",
        fields: [
          {
            name: "lb_pair",
            type: "pubkey"
          },
          {
            name: "protocol_share",
            type: "u16"
          },
          {
            name: "base_factor",
            type: "u16"
          }
        ]
      }
    },
    {
      name: "FundReward",
      type: {
        kind: "struct",
        fields: [
          {
            name: "lb_pair",
            type: "pubkey"
          },
          {
            name: "funder",
            type: "pubkey"
          },
          {
            name: "reward_index",
            type: "u64"
          },
          {
            name: "amount",
            type: "u64"
          }
        ]
      }
    },
    {
      name: "GoToABin",
      type: {
        kind: "struct",
        fields: [
          {
            name: "lb_pair",
            type: "pubkey"
          },
          {
            name: "from_bin_id",
            type: "i32"
          },
          {
            name: "to_bin_id",
            type: "i32"
          }
        ]
      }
    },
    {
      name: "IncreaseObservation",
      type: {
        kind: "struct",
        fields: [
          {
            name: "oracle",
            type: "pubkey"
          },
          {
            name: "new_observation_length",
            type: "u64"
          }
        ]
      }
    },
    {
      name: "IncreasePositionLength",
      type: {
        kind: "struct",
        fields: [
          {
            name: "lb_pair",
            type: "pubkey"
          },
          {
            name: "position",
            type: "pubkey"
          },
          {
            name: "owner",
            type: "pubkey"
          },
          {
            name: "length_to_add",
            type: "u16"
          },
          {
            name: "side",
            type: "u8"
          }
        ]
      }
    },
    {
      name: "InitPermissionPairIx",
      type: {
        kind: "struct",
        fields: [
          {
            name: "active_id",
            type: "i32"
          },
          {
            name: "bin_step",
            type: "u16"
          },
          {
            name: "base_factor",
            type: "u16"
          },
          {
            name: "base_fee_power_factor",
            type: "u8"
          },
          {
            name: "activation_type",
            type: "u8"
          },
          {
            name: "protocol_share",
            type: "u16"
          }
        ]
      }
    },
    {
      name: "InitPresetParameters2Ix",
      type: {
        kind: "struct",
        fields: [
          {
            name: "index",
            type: "u16"
          },
          {
            name: "bin_step",
            docs: ["Bin step. Represent the price increment / decrement."],
            type: "u16"
          },
          {
            name: "base_factor",
            docs: [
              "Used for base fee calculation. base_fee_rate = base_factor * bin_step * 10 * 10^base_fee_power_factor"
            ],
            type: "u16"
          },
          {
            name: "filter_period",
            docs: [
              "Filter period determine high frequency trading time window."
            ],
            type: "u16"
          },
          {
            name: "decay_period",
            docs: [
              "Decay period determine when the volatile fee start decay / decrease."
            ],
            type: "u16"
          },
          {
            name: "reduction_factor",
            docs: [
              "Reduction factor controls the volatile fee rate decrement rate."
            ],
            type: "u16"
          },
          {
            name: "variable_fee_control",
            docs: [
              "Used to scale the variable fee component depending on the dynamic of the market"
            ],
            type: "u32"
          },
          {
            name: "max_volatility_accumulator",
            docs: [
              "Maximum number of bin crossed can be accumulated. Used to cap volatile fee rate."
            ],
            type: "u32"
          },
          {
            name: "protocol_share",
            docs: [
              "Portion of swap fees retained by the protocol by controlling protocol_share parameter. protocol_swap_fee = protocol_share * total_swap_fee"
            ],
            type: "u16"
          },
          {
            name: "base_fee_power_factor",
            docs: ["Base fee power factor"],
            type: "u8"
          }
        ]
      }
    },
    {
      name: "InitPresetParametersIx",
      type: {
        kind: "struct",
        fields: [
          {
            name: "bin_step",
            docs: ["Bin step. Represent the price increment / decrement."],
            type: "u16"
          },
          {
            name: "base_factor",
            docs: [
              "Used for base fee calculation. base_fee_rate = base_factor * bin_step * 10 * 10^base_fee_power_factor"
            ],
            type: "u16"
          },
          {
            name: "filter_period",
            docs: [
              "Filter period determine high frequency trading time window."
            ],
            type: "u16"
          },
          {
            name: "decay_period",
            docs: [
              "Decay period determine when the volatile fee start decay / decrease."
            ],
            type: "u16"
          },
          {
            name: "reduction_factor",
            docs: [
              "Reduction factor controls the volatile fee rate decrement rate."
            ],
            type: "u16"
          },
          {
            name: "variable_fee_control",
            docs: [
              "Used to scale the variable fee component depending on the dynamic of the market"
            ],
            type: "u32"
          },
          {
            name: "max_volatility_accumulator",
            docs: [
              "Maximum number of bin crossed can be accumulated. Used to cap volatile fee rate."
            ],
            type: "u32"
          },
          {
            name: "protocol_share",
            docs: [
              "Portion of swap fees retained by the protocol by controlling protocol_share parameter. protocol_swap_fee = protocol_share * total_swap_fee"
            ],
            type: "u16"
          }
        ]
      }
    },
    {
      name: "InitializeLbPair2Params",
      type: {
        kind: "struct",
        fields: [
          {
            name: "active_id",
            docs: ["Pool price"],
            type: "i32"
          },
          {
            name: "padding",
            docs: ["Padding, for future use"],
            type: {
              array: ["u8", 96]
            }
          }
        ]
      }
    },
    {
      name: "InitializeReward",
      type: {
        kind: "struct",
        fields: [
          {
            name: "lb_pair",
            type: "pubkey"
          },
          {
            name: "reward_mint",
            type: "pubkey"
          },
          {
            name: "funder",
            type: "pubkey"
          },
          {
            name: "reward_index",
            type: "u64"
          },
          {
            name: "reward_duration",
            type: "u64"
          }
        ]
      }
    },
    {
      name: "LbPair",
      serialization: "bytemuck",
      repr: {
        kind: "c"
      },
      type: {
        kind: "struct",
        fields: [
          {
            name: "parameters",
            type: {
              defined: {
                name: "StaticParameters"
              }
            }
          },
          {
            name: "v_parameters",
            type: {
              defined: {
                name: "VariableParameters"
              }
            }
          },
          {
            name: "bump_seed",
            type: {
              array: ["u8", 1]
            }
          },
          {
            name: "bin_step_seed",
            docs: ["Bin step signer seed"],
            type: {
              array: ["u8", 2]
            }
          },
          {
            name: "pair_type",
            docs: ["Type of the pair"],
            type: "u8"
          },
          {
            name: "active_id",
            docs: ["Active bin id"],
            type: "i32"
          },
          {
            name: "bin_step",
            docs: ["Bin step. Represent the price increment / decrement."],
            type: "u16"
          },
          {
            name: "status",
            docs: ["Status of the pair. Check PairStatus enum."],
            type: "u8"
          },
          {
            name: "require_base_factor_seed",
            docs: ["Require base factor seed"],
            type: "u8"
          },
          {
            name: "base_factor_seed",
            docs: ["Base factor seed"],
            type: {
              array: ["u8", 2]
            }
          },
          {
            name: "activation_type",
            docs: ["Activation type"],
            type: "u8"
          },
          {
            name: "creator_pool_on_off_control",
            docs: [
              "Allow pool creator to enable/disable pool with restricted validation. Only applicable for customizable permissionless pair type."
            ],
            type: "u8"
          },
          {
            name: "token_x_mint",
            docs: ["Token X mint"],
            type: "pubkey"
          },
          {
            name: "token_y_mint",
            docs: ["Token Y mint"],
            type: "pubkey"
          },
          {
            name: "reserve_x",
            docs: ["LB token X vault"],
            type: "pubkey"
          },
          {
            name: "reserve_y",
            docs: ["LB token Y vault"],
            type: "pubkey"
          },
          {
            name: "protocol_fee",
            docs: ["Uncollected protocol fee"],
            type: {
              defined: {
                name: "ProtocolFee"
              }
            }
          },
          {
            name: "_padding_1",
            docs: [
              "_padding_1, previous Fee owner, BE CAREFUL FOR TOMBSTONE WHEN REUSE !!"
            ],
            type: {
              array: ["u8", 32]
            }
          },
          {
            name: "reward_infos",
            docs: ["Farming reward information"],
            type: {
              array: [
                {
                  defined: {
                    name: "RewardInfo"
                  }
                },
                2
              ]
            }
          },
          {
            name: "oracle",
            docs: ["Oracle pubkey"],
            type: "pubkey"
          },
          {
            name: "bin_array_bitmap",
            docs: ["Packed initialized bin array state"],
            type: {
              array: ["u64", 16]
            }
          },
          {
            name: "last_updated_at",
            docs: ["Last time the pool fee parameter was updated"],
            type: "i64"
          },
          {
            name: "_padding_2",
            docs: [
              "_padding_2, previous whitelisted_wallet, BE CAREFUL FOR TOMBSTONE WHEN REUSE !!"
            ],
            type: {
              array: ["u8", 32]
            }
          },
          {
            name: "pre_activation_swap_address",
            docs: [
              "Address allowed to swap when the current point is greater than or equal to the pre-activation point. The pre-activation point is calculated as `activation_point - pre_activation_duration`."
            ],
            type: "pubkey"
          },
          {
            name: "base_key",
            docs: ["Base keypair. Only required for permission pair"],
            type: "pubkey"
          },
          {
            name: "activation_point",
            docs: [
              "Time point to enable the pair. Only applicable for permission pair."
            ],
            type: "u64"
          },
          {
            name: "pre_activation_duration",
            docs: [
              "Duration before activation activation_point. Used to calculate pre-activation time point for pre_activation_swap_address"
            ],
            type: "u64"
          },
          {
            name: "_padding_3",
            docs: [
              "_padding 3 is reclaimed free space from swap_cap_deactivate_point and swap_cap_amount before, BE CAREFUL FOR TOMBSTONE WHEN REUSE !!"
            ],
            type: {
              array: ["u8", 8]
            }
          },
          {
            name: "_padding_4",
            docs: [
              "_padding_4, previous lock_duration, BE CAREFUL FOR TOMBSTONE WHEN REUSE !!"
            ],
            type: "u64"
          },
          {
            name: "creator",
            docs: ["Pool creator"],
            type: "pubkey"
          },
          {
            name: "token_mint_x_program_flag",
            docs: ["token_mint_x_program_flag"],
            type: "u8"
          },
          {
            name: "token_mint_y_program_flag",
            docs: ["token_mint_y_program_flag"],
            type: "u8"
          },
          {
            name: "_reserved",
            docs: ["Reserved space for future use"],
            type: {
              array: ["u8", 22]
            }
          }
        ]
      }
    },
    {
      name: "LbPairCreate",
      type: {
        kind: "struct",
        fields: [
          {
            name: "lb_pair",
            type: "pubkey"
          },
          {
            name: "bin_step",
            type: "u16"
          },
          {
            name: "token_x",
            type: "pubkey"
          },
          {
            name: "token_y",
            type: "pubkey"
          }
        ]
      }
    },
    {
      name: "LiquidityOneSideParameter",
      type: {
        kind: "struct",
        fields: [
          {
            name: "amount",
            docs: ["Amount of X token or Y token to deposit"],
            type: "u64"
          },
          {
            name: "active_id",
            docs: ["Active bin that integrator observe off-chain"],
            type: "i32"
          },
          {
            name: "max_active_bin_slippage",
            docs: ["max active bin slippage allowed"],
            type: "i32"
          },
          {
            name: "bin_liquidity_dist",
            docs: ["Liquidity distribution to each bins"],
            type: {
              vec: {
                defined: {
                  name: "BinLiquidityDistributionByWeight"
                }
              }
            }
          }
        ]
      }
    },
    {
      name: "LiquidityParameter",
      type: {
        kind: "struct",
        fields: [
          {
            name: "amount_x",
            docs: ["Amount of X token to deposit"],
            type: "u64"
          },
          {
            name: "amount_y",
            docs: ["Amount of Y token to deposit"],
            type: "u64"
          },
          {
            name: "bin_liquidity_dist",
            docs: ["Liquidity distribution to each bins"],
            type: {
              vec: {
                defined: {
                  name: "BinLiquidityDistribution"
                }
              }
            }
          }
        ]
      }
    },
    {
      name: "LiquidityParameterByStrategy",
      type: {
        kind: "struct",
        fields: [
          {
            name: "amount_x",
            docs: ["Amount of X token to deposit"],
            type: "u64"
          },
          {
            name: "amount_y",
            docs: ["Amount of Y token to deposit"],
            type: "u64"
          },
          {
            name: "active_id",
            docs: ["Active bin that integrator observe off-chain"],
            type: "i32"
          },
          {
            name: "max_active_bin_slippage",
            docs: ["max active bin slippage allowed"],
            type: "i32"
          },
          {
            name: "strategy_parameters",
            docs: ["strategy parameters"],
            type: {
              defined: {
                name: "StrategyParameters"
              }
            }
          }
        ]
      }
    },
    {
      name: "LiquidityParameterByStrategyOneSide",
      type: {
        kind: "struct",
        fields: [
          {
            name: "amount",
            docs: ["Amount of X token or Y token to deposit"],
            type: "u64"
          },
          {
            name: "active_id",
            docs: ["Active bin that integrator observe off-chain"],
            type: "i32"
          },
          {
            name: "max_active_bin_slippage",
            docs: ["max active bin slippage allowed"],
            type: "i32"
          },
          {
            name: "strategy_parameters",
            docs: ["strategy parameters"],
            type: {
              defined: {
                name: "StrategyParameters"
              }
            }
          }
        ]
      }
    },
    {
      name: "LiquidityParameterByWeight",
      type: {
        kind: "struct",
        fields: [
          {
            name: "amount_x",
            docs: ["Amount of X token to deposit"],
            type: "u64"
          },
          {
            name: "amount_y",
            docs: ["Amount of Y token to deposit"],
            type: "u64"
          },
          {
            name: "active_id",
            docs: ["Active bin that integrator observe off-chain"],
            type: "i32"
          },
          {
            name: "max_active_bin_slippage",
            docs: ["max active bin slippage allowed"],
            type: "i32"
          },
          {
            name: "bin_liquidity_dist",
            docs: ["Liquidity distribution to each bins"],
            type: {
              vec: {
                defined: {
                  name: "BinLiquidityDistributionByWeight"
                }
              }
            }
          }
        ]
      }
    },
    {
      name: "Oracle",
      serialization: "bytemuck",
      repr: {
        kind: "c"
      },
      type: {
        kind: "struct",
        fields: [
          {
            name: "idx",
            docs: ["Index of latest observation"],
            type: "u64"
          },
          {
            name: "active_size",
            docs: [
              "Size of active sample. Active sample is initialized observation."
            ],
            type: "u64"
          },
          {
            name: "length",
            docs: ["Number of observations"],
            type: "u64"
          }
        ]
      }
    },
    {
      name: "PairStatus",
      docs: [
        "Pair status. 0 = Enabled, 1 = Disabled. Putting 0 as enabled for backward compatibility."
      ],
      repr: {
        kind: "rust"
      },
      type: {
        kind: "enum",
        variants: [
          {
            name: "Enabled"
          },
          {
            name: "Disabled"
          }
        ]
      }
    },
    {
      name: "PairType",
      docs: [
        "Type of the Pair. 0 = Permissionless, 1 = Permission, 2 = CustomizablePermissionless. Putting 0 as permissionless for backward compatibility."
      ],
      repr: {
        kind: "rust"
      },
      type: {
        kind: "enum",
        variants: [
          {
            name: "Permissionless"
          },
          {
            name: "Permission"
          },
          {
            name: "CustomizablePermissionless"
          },
          {
            name: "PermissionlessV2"
          }
        ]
      }
    },
    {
      name: "Position",
      serialization: "bytemuck",
      repr: {
        kind: "c"
      },
      type: {
        kind: "struct",
        fields: [
          {
            name: "lb_pair",
            docs: ["The LB pair of this position"],
            type: "pubkey"
          },
          {
            name: "owner",
            docs: [
              "Owner of the position. Client rely on this to to fetch their positions."
            ],
            type: "pubkey"
          },
          {
            name: "liquidity_shares",
            docs: [
              "Liquidity shares of this position in bins (lower_bin_id <-> upper_bin_id). This is the same as LP concept."
            ],
            type: {
              array: ["u64", 70]
            }
          },
          {
            name: "reward_infos",
            docs: ["Farming reward information"],
            type: {
              array: [
                {
                  defined: {
                    name: "UserRewardInfo"
                  }
                },
                70
              ]
            }
          },
          {
            name: "fee_infos",
            docs: ["Swap fee to claim information"],
            type: {
              array: [
                {
                  defined: {
                    name: "FeeInfo"
                  }
                },
                70
              ]
            }
          },
          {
            name: "lower_bin_id",
            docs: ["Lower bin ID"],
            type: "i32"
          },
          {
            name: "upper_bin_id",
            docs: ["Upper bin ID"],
            type: "i32"
          },
          {
            name: "last_updated_at",
            docs: ["Last updated timestamp"],
            type: "i64"
          },
          {
            name: "total_claimed_fee_x_amount",
            docs: ["Total claimed token fee X"],
            type: "u64"
          },
          {
            name: "total_claimed_fee_y_amount",
            docs: ["Total claimed token fee Y"],
            type: "u64"
          },
          {
            name: "total_claimed_rewards",
            docs: ["Total claimed rewards"],
            type: {
              array: ["u64", 2]
            }
          },
          {
            name: "_reserved",
            docs: ["Reserved space for future use"],
            type: {
              array: ["u8", 160]
            }
          }
        ]
      }
    },
    {
      name: "PositionBinData",
      serialization: "bytemuck",
      repr: {
        kind: "c"
      },
      type: {
        kind: "struct",
        fields: [
          {
            name: "liquidity_share",
            type: "u128"
          },
          {
            name: "reward_info",
            type: {
              defined: {
                name: "UserRewardInfo"
              }
            }
          },
          {
            name: "fee_info",
            type: {
              defined: {
                name: "FeeInfo"
              }
            }
          }
        ]
      }
    },
    {
      name: "PositionClose",
      type: {
        kind: "struct",
        fields: [
          {
            name: "position",
            type: "pubkey"
          },
          {
            name: "owner",
            type: "pubkey"
          }
        ]
      }
    },
    {
      name: "PositionCreate",
      type: {
        kind: "struct",
        fields: [
          {
            name: "lb_pair",
            type: "pubkey"
          },
          {
            name: "position",
            type: "pubkey"
          },
          {
            name: "owner",
            type: "pubkey"
          }
        ]
      }
    },
    {
      name: "PositionV2",
      serialization: "bytemuck",
      repr: {
        kind: "c"
      },
      type: {
        kind: "struct",
        fields: [
          {
            name: "lb_pair",
            docs: ["The LB pair of this position"],
            type: "pubkey"
          },
          {
            name: "owner",
            docs: [
              "Owner of the position. Client rely on this to to fetch their positions."
            ],
            type: "pubkey"
          },
          {
            name: "liquidity_shares",
            docs: [
              "Liquidity shares of this position in bins (lower_bin_id <-> upper_bin_id). This is the same as LP concept."
            ],
            type: {
              array: ["u128", 70]
            }
          },
          {
            name: "reward_infos",
            docs: ["Farming reward information"],
            type: {
              array: [
                {
                  defined: {
                    name: "UserRewardInfo"
                  }
                },
                70
              ]
            }
          },
          {
            name: "fee_infos",
            docs: ["Swap fee to claim information"],
            type: {
              array: [
                {
                  defined: {
                    name: "FeeInfo"
                  }
                },
                70
              ]
            }
          },
          {
            name: "lower_bin_id",
            docs: ["Lower bin ID"],
            type: "i32"
          },
          {
            name: "upper_bin_id",
            docs: ["Upper bin ID"],
            type: "i32"
          },
          {
            name: "last_updated_at",
            docs: ["Last updated timestamp"],
            type: "i64"
          },
          {
            name: "total_claimed_fee_x_amount",
            docs: ["Total claimed token fee X"],
            type: "u64"
          },
          {
            name: "total_claimed_fee_y_amount",
            docs: ["Total claimed token fee Y"],
            type: "u64"
          },
          {
            name: "total_claimed_rewards",
            docs: ["Total claimed rewards"],
            type: {
              array: ["u64", 2]
            }
          },
          {
            name: "operator",
            docs: ["Operator of position"],
            type: "pubkey"
          },
          {
            name: "lock_release_point",
            docs: ["Time point which the locked liquidity can be withdraw"],
            type: "u64"
          },
          {
            name: "_padding_0",
            docs: [
              "_padding_0, previous subjected_to_bootstrap_liquidity_locking, BE CAREFUL FOR TOMBSTONE WHEN REUSE !!"
            ],
            type: "u8"
          },
          {
            name: "fee_owner",
            docs: [
              "Address is able to claim fee in this position, only valid for bootstrap_liquidity_position"
            ],
            type: "pubkey"
          },
          {
            name: "_reserved",
            docs: ["Reserved space for future use"],
            type: {
              array: ["u8", 87]
            }
          }
        ]
      }
    },
    {
      name: "PresetParameter",
      type: {
        kind: "struct",
        fields: [
          {
            name: "bin_step",
            docs: ["Bin step. Represent the price increment / decrement."],
            type: "u16"
          },
          {
            name: "base_factor",
            docs: [
              "Used for base fee calculation. base_fee_rate = base_factor * bin_step * 10 * 10^base_fee_power_factor"
            ],
            type: "u16"
          },
          {
            name: "filter_period",
            docs: [
              "Filter period determine high frequency trading time window."
            ],
            type: "u16"
          },
          {
            name: "decay_period",
            docs: [
              "Decay period determine when the volatile fee start decay / decrease."
            ],
            type: "u16"
          },
          {
            name: "reduction_factor",
            docs: [
              "Reduction factor controls the volatile fee rate decrement rate."
            ],
            type: "u16"
          },
          {
            name: "variable_fee_control",
            docs: [
              "Used to scale the variable fee component depending on the dynamic of the market"
            ],
            type: "u32"
          },
          {
            name: "max_volatility_accumulator",
            docs: [
              "Maximum number of bin crossed can be accumulated. Used to cap volatile fee rate."
            ],
            type: "u32"
          },
          {
            name: "min_bin_id",
            docs: [
              "Min bin id supported by the pool based on the configured bin step."
            ],
            type: "i32"
          },
          {
            name: "max_bin_id",
            docs: [
              "Max bin id supported by the pool based on the configured bin step."
            ],
            type: "i32"
          },
          {
            name: "protocol_share",
            docs: [
              "Portion of swap fees retained by the protocol by controlling protocol_share parameter. protocol_swap_fee = protocol_share * total_swap_fee"
            ],
            type: "u16"
          }
        ]
      }
    },
    {
      name: "PresetParameter2",
      serialization: "bytemuck",
      repr: {
        kind: "c"
      },
      type: {
        kind: "struct",
        fields: [
          {
            name: "bin_step",
            docs: ["Bin step. Represent the price increment / decrement."],
            type: "u16"
          },
          {
            name: "base_factor",
            docs: [
              "Used for base fee calculation. base_fee_rate = base_factor * bin_step * 10 * 10^base_fee_power_factor"
            ],
            type: "u16"
          },
          {
            name: "filter_period",
            docs: [
              "Filter period determine high frequency trading time window."
            ],
            type: "u16"
          },
          {
            name: "decay_period",
            docs: [
              "Decay period determine when the volatile fee start decay / decrease."
            ],
            type: "u16"
          },
          {
            name: "variable_fee_control",
            docs: [
              "Used to scale the variable fee component depending on the dynamic of the market"
            ],
            type: "u32"
          },
          {
            name: "max_volatility_accumulator",
            docs: [
              "Maximum number of bin crossed can be accumulated. Used to cap volatile fee rate."
            ],
            type: "u32"
          },
          {
            name: "reduction_factor",
            docs: [
              "Reduction factor controls the volatile fee rate decrement rate."
            ],
            type: "u16"
          },
          {
            name: "protocol_share",
            docs: [
              "Portion of swap fees retained by the protocol by controlling protocol_share parameter. protocol_swap_fee = protocol_share * total_swap_fee"
            ],
            type: "u16"
          },
          {
            name: "index",
            docs: ["index"],
            type: "u16"
          },
          {
            name: "base_fee_power_factor",
            docs: ["Base fee power factor"],
            type: "u8"
          },
          {
            name: "padding_0",
            docs: ["Padding 0 for future use"],
            type: "u8"
          },
          {
            name: "padding_1",
            docs: ["Padding 1 for future use"],
            type: {
              array: ["u64", 20]
            }
          }
        ]
      }
    },
    {
      name: "ProtocolFee",
      serialization: "bytemuck",
      repr: {
        kind: "c"
      },
      type: {
        kind: "struct",
        fields: [
          {
            name: "amount_x",
            type: "u64"
          },
          {
            name: "amount_y",
            type: "u64"
          }
        ]
      }
    },
    {
      name: "RebalanceLiquidityParams",
      type: {
        kind: "struct",
        fields: [
          {
            name: "active_id",
            docs: ["active id"],
            type: "i32"
          },
          {
            name: "max_active_bin_slippage",
            docs: ["max active bin slippage allowed"],
            type: "u16"
          },
          {
            name: "should_claim_fee",
            docs: ["a flag to indicate that whether fee should be harvested"],
            type: "bool"
          },
          {
            name: "should_claim_reward",
            docs: [
              "a flag to indicate that whether rewards should be harvested"
            ],
            type: "bool"
          },
          {
            name: "min_withdraw_x_amount",
            docs: ["threshold for withdraw token x"],
            type: "u64"
          },
          {
            name: "max_deposit_x_amount",
            docs: ["threshold for deposit token x"],
            type: "u64"
          },
          {
            name: "min_withdraw_y_amount",
            docs: ["threshold for withdraw token y"],
            type: "u64"
          },
          {
            name: "max_deposit_y_amount",
            docs: ["threshold for deposit token y"],
            type: "u64"
          },
          {
            name: "shrink_mode",
            docs: ["shrink mode"],
            type: "u8"
          },
          {
            name: "padding",
            docs: ["padding 32 bytes for future usage"],
            type: {
              array: ["u8", 31]
            }
          },
          {
            name: "removes",
            docs: ["removes"],
            type: {
              vec: {
                defined: {
                  name: "RemoveLiquidityParams"
                }
              }
            }
          },
          {
            name: "adds",
            docs: ["adds"],
            type: {
              vec: {
                defined: {
                  name: "AddLiquidityParams"
                }
              }
            }
          }
        ]
      }
    },
    {
      name: "Rebalancing",
      type: {
        kind: "struct",
        fields: [
          {
            name: "lb_pair",
            type: "pubkey"
          },
          {
            name: "position",
            type: "pubkey"
          },
          {
            name: "owner",
            type: "pubkey"
          },
          {
            name: "active_bin_id",
            type: "i32"
          },
          {
            name: "x_withdrawn_amount",
            type: "u64"
          },
          {
            name: "x_added_amount",
            type: "u64"
          },
          {
            name: "y_withdrawn_amount",
            type: "u64"
          },
          {
            name: "y_added_amount",
            type: "u64"
          },
          {
            name: "x_fee_amount",
            type: "u64"
          },
          {
            name: "y_fee_amount",
            type: "u64"
          },
          {
            name: "old_min_id",
            type: "i32"
          },
          {
            name: "old_max_id",
            type: "i32"
          },
          {
            name: "new_min_id",
            type: "i32"
          },
          {
            name: "new_max_id",
            type: "i32"
          },
          {
            name: "rewards",
            type: {
              array: ["u64", 2]
            }
          }
        ]
      }
    },
    {
      name: "RemainingAccountsInfo",
      type: {
        kind: "struct",
        fields: [
          {
            name: "slices",
            type: {
              vec: {
                defined: {
                  name: "RemainingAccountsSlice"
                }
              }
            }
          }
        ]
      }
    },
    {
      name: "RemainingAccountsSlice",
      type: {
        kind: "struct",
        fields: [
          {
            name: "accounts_type",
            type: {
              defined: {
                name: "AccountsType"
              }
            }
          },
          {
            name: "length",
            type: "u8"
          }
        ]
      }
    },
    {
      name: "RemoveLiquidity",
      type: {
        kind: "struct",
        fields: [
          {
            name: "lb_pair",
            type: "pubkey"
          },
          {
            name: "from",
            type: "pubkey"
          },
          {
            name: "position",
            type: "pubkey"
          },
          {
            name: "amounts",
            type: {
              array: ["u64", 2]
            }
          },
          {
            name: "active_bin_id",
            type: "i32"
          }
        ]
      }
    },
    {
      name: "RemoveLiquidityParams",
      type: {
        kind: "struct",
        fields: [
          {
            name: "min_bin_id",
            type: {
              option: "i32"
            }
          },
          {
            name: "max_bin_id",
            type: {
              option: "i32"
            }
          },
          {
            name: "bps",
            type: "u16"
          },
          {
            name: "padding",
            type: {
              array: ["u8", 16]
            }
          }
        ]
      }
    },
    {
      name: "ResizeSide",
      docs: ["Side of resize, 0 for lower and 1 for upper"],
      repr: {
        kind: "rust"
      },
      type: {
        kind: "enum",
        variants: [
          {
            name: "Lower"
          },
          {
            name: "Upper"
          }
        ]
      }
    },
    {
      name: "RewardInfo",
      docs: [
        "Stores the state relevant for tracking liquidity mining rewards"
      ],
      serialization: "bytemuck",
      repr: {
        kind: "c"
      },
      type: {
        kind: "struct",
        fields: [
          {
            name: "mint",
            docs: ["Reward token mint."],
            type: "pubkey"
          },
          {
            name: "vault",
            docs: ["Reward vault token account."],
            type: "pubkey"
          },
          {
            name: "funder",
            docs: ["Authority account that allows to fund rewards"],
            type: "pubkey"
          },
          {
            name: "reward_duration",
            docs: ["LM reward duration in seconds."],
            type: "u64"
          },
          {
            name: "reward_duration_end",
            docs: ["LM reward duration end time."],
            type: "u64"
          },
          {
            name: "reward_rate",
            docs: ["LM reward rate"],
            type: "u128"
          },
          {
            name: "last_update_time",
            docs: ["The last time reward states were updated."],
            type: "u64"
          },
          {
            name: "cumulative_seconds_with_empty_liquidity_reward",
            docs: [
              "Accumulated seconds where when farm distribute rewards, but the bin is empty. The reward will be accumulated for next reward time window."
            ],
            type: "u64"
          }
        ]
      }
    },
    {
      name: "Rounding",
      type: {
        kind: "enum",
        variants: [
          {
            name: "Up"
          },
          {
            name: "Down"
          }
        ]
      }
    },
    {
      name: "StaticParameters",
      docs: ["Parameter that set by the protocol"],
      serialization: "bytemuck",
      repr: {
        kind: "c"
      },
      type: {
        kind: "struct",
        fields: [
          {
            name: "base_factor",
            docs: [
              "Used for base fee calculation. base_fee_rate = base_factor * bin_step * 10 * 10^base_fee_power_factor"
            ],
            type: "u16"
          },
          {
            name: "filter_period",
            docs: [
              "Filter period determine high frequency trading time window."
            ],
            type: "u16"
          },
          {
            name: "decay_period",
            docs: [
              "Decay period determine when the volatile fee start decay / decrease."
            ],
            type: "u16"
          },
          {
            name: "reduction_factor",
            docs: [
              "Reduction factor controls the volatile fee rate decrement rate."
            ],
            type: "u16"
          },
          {
            name: "variable_fee_control",
            docs: [
              "Used to scale the variable fee component depending on the dynamic of the market"
            ],
            type: "u32"
          },
          {
            name: "max_volatility_accumulator",
            docs: [
              "Maximum number of bin crossed can be accumulated. Used to cap volatile fee rate."
            ],
            type: "u32"
          },
          {
            name: "min_bin_id",
            docs: [
              "Min bin id supported by the pool based on the configured bin step."
            ],
            type: "i32"
          },
          {
            name: "max_bin_id",
            docs: [
              "Max bin id supported by the pool based on the configured bin step."
            ],
            type: "i32"
          },
          {
            name: "protocol_share",
            docs: [
              "Portion of swap fees retained by the protocol by controlling protocol_share parameter. protocol_swap_fee = protocol_share * total_swap_fee"
            ],
            type: "u16"
          },
          {
            name: "base_fee_power_factor",
            docs: ["Base fee power factor"],
            type: "u8"
          },
          {
            name: "_padding",
            docs: ["Padding for bytemuck safe alignment"],
            type: {
              array: ["u8", 5]
            }
          }
        ]
      }
    },
    {
      name: "StrategyParameters",
      type: {
        kind: "struct",
        fields: [
          {
            name: "min_bin_id",
            docs: ["min bin id"],
            type: "i32"
          },
          {
            name: "max_bin_id",
            docs: ["max bin id"],
            type: "i32"
          },
          {
            name: "strategy_type",
            docs: ["strategy type"],
            type: {
              defined: {
                name: "StrategyType"
              }
            }
          },
          {
            name: "parameteres",
            docs: ["parameters"],
            type: {
              array: ["u8", 64]
            }
          }
        ]
      }
    },
    {
      name: "StrategyType",
      type: {
        kind: "enum",
        variants: [
          {
            name: "SpotOneSide"
          },
          {
            name: "CurveOneSide"
          },
          {
            name: "BidAskOneSide"
          },
          {
            name: "SpotBalanced"
          },
          {
            name: "CurveBalanced"
          },
          {
            name: "BidAskBalanced"
          },
          {
            name: "SpotImBalanced"
          },
          {
            name: "CurveImBalanced"
          },
          {
            name: "BidAskImBalanced"
          }
        ]
      }
    },
    {
      name: "Swap",
      type: {
        kind: "struct",
        fields: [
          {
            name: "lb_pair",
            type: "pubkey"
          },
          {
            name: "from",
            type: "pubkey"
          },
          {
            name: "start_bin_id",
            type: "i32"
          },
          {
            name: "end_bin_id",
            type: "i32"
          },
          {
            name: "amount_in",
            type: "u64"
          },
          {
            name: "amount_out",
            type: "u64"
          },
          {
            name: "swap_for_y",
            type: "bool"
          },
          {
            name: "fee",
            type: "u64"
          },
          {
            name: "protocol_fee",
            type: "u64"
          },
          {
            name: "fee_bps",
            type: "u128"
          },
          {
            name: "host_fee",
            type: "u64"
          }
        ]
      }
    },
    {
      name: "TokenBadge",
      docs: ["Parameter that set by the protocol"],
      serialization: "bytemuck",
      repr: {
        kind: "c"
      },
      type: {
        kind: "struct",
        fields: [
          {
            name: "token_mint",
            docs: ["token mint"],
            type: "pubkey"
          },
          {
            name: "_padding",
            docs: ["Reserve"],
            type: {
              array: ["u8", 128]
            }
          }
        ]
      }
    },
    {
      name: "TokenProgramFlags",
      repr: {
        kind: "rust"
      },
      type: {
        kind: "enum",
        variants: [
          {
            name: "TokenProgram"
          },
          {
            name: "TokenProgram2022"
          }
        ]
      }
    },
    {
      name: "UpdatePositionLockReleasePoint",
      type: {
        kind: "struct",
        fields: [
          {
            name: "position",
            type: "pubkey"
          },
          {
            name: "current_point",
            type: "u64"
          },
          {
            name: "new_lock_release_point",
            type: "u64"
          },
          {
            name: "old_lock_release_point",
            type: "u64"
          },
          {
            name: "sender",
            type: "pubkey"
          }
        ]
      }
    },
    {
      name: "UpdatePositionOperator",
      type: {
        kind: "struct",
        fields: [
          {
            name: "position",
            type: "pubkey"
          },
          {
            name: "old_operator",
            type: "pubkey"
          },
          {
            name: "new_operator",
            type: "pubkey"
          }
        ]
      }
    },
    {
      name: "UpdateRewardDuration",
      type: {
        kind: "struct",
        fields: [
          {
            name: "lb_pair",
            type: "pubkey"
          },
          {
            name: "reward_index",
            type: "u64"
          },
          {
            name: "old_reward_duration",
            type: "u64"
          },
          {
            name: "new_reward_duration",
            type: "u64"
          }
        ]
      }
    },
    {
      name: "UpdateRewardFunder",
      type: {
        kind: "struct",
        fields: [
          {
            name: "lb_pair",
            type: "pubkey"
          },
          {
            name: "reward_index",
            type: "u64"
          },
          {
            name: "old_funder",
            type: "pubkey"
          },
          {
            name: "new_funder",
            type: "pubkey"
          }
        ]
      }
    },
    {
      name: "UserRewardInfo",
      serialization: "bytemuck",
      repr: {
        kind: "c"
      },
      type: {
        kind: "struct",
        fields: [
          {
            name: "reward_per_token_completes",
            type: {
              array: ["u128", 2]
            }
          },
          {
            name: "reward_pendings",
            type: {
              array: ["u64", 2]
            }
          }
        ]
      }
    },
    {
      name: "VariableParameters",
      docs: ["Parameters that changes based on dynamic of the market"],
      serialization: "bytemuck",
      repr: {
        kind: "c"
      },
      type: {
        kind: "struct",
        fields: [
          {
            name: "volatility_accumulator",
            docs: [
              "Volatility accumulator measure the number of bin crossed since reference bin ID. Normally (without filter period taken into consideration), reference bin ID is the active bin of last swap.",
              "It affects the variable fee rate"
            ],
            type: "u32"
          },
          {
            name: "volatility_reference",
            docs: [
              "Volatility reference is decayed volatility accumulator. It is always <= volatility_accumulator"
            ],
            type: "u32"
          },
          {
            name: "index_reference",
            docs: ["Active bin id of last swap."],
            type: "i32"
          },
          {
            name: "_padding",
            docs: ["Padding for bytemuck safe alignment"],
            type: {
              array: ["u8", 4]
            }
          },
          {
            name: "last_update_timestamp",
            docs: ["Last timestamp the variable parameters was updated"],
            type: "i64"
          },
          {
            name: "_padding_1",
            docs: ["Padding for bytemuck safe alignment"],
            type: {
              array: ["u8", 8]
            }
          }
        ]
      }
    },
    {
      name: "WithdrawIneligibleReward",
      type: {
        kind: "struct",
        fields: [
          {
            name: "lb_pair",
            type: "pubkey"
          },
          {
            name: "reward_mint",
            type: "pubkey"
          },
          {
            name: "amount",
            type: "u64"
          }
        ]
      }
    }
  ],
  constants: [
    {
      name: "BASIS_POINT_MAX",
      type: "i32",
      value: "10000"
    },
    {
      name: "BIN_ARRAY",
      type: "bytes",
      value: "[98, 105, 110, 95, 97, 114, 114, 97, 121]"
    },
    {
      name: "BIN_ARRAY_BITMAP_SEED",
      type: "bytes",
      value: "[98, 105, 116, 109, 97, 112]"
    },
    {
      name: "BIN_ARRAY_BITMAP_SIZE",
      type: "i32",
      value: "512"
    },
    {
      name: "CLAIM_PROTOCOL_FEE_OPERATOR",
      type: "bytes",
      value: "[99, 102, 95, 111, 112, 101, 114, 97, 116, 111, 114]"
    },
    {
      name: "DEFAULT_BIN_PER_POSITION",
      type: "u64",
      value: "70"
    },
    {
      name: "EXTENSION_BINARRAY_BITMAP_SIZE",
      type: "u64",
      value: "12"
    },
    {
      name: "FEE_PRECISION",
      type: "u64",
      value: "1000000000"
    },
    {
      name: "HOST_FEE_BPS",
      docs: ["Host fee. 20%"],
      type: "u16",
      value: "2000"
    },
    {
      name: "ILM_PROTOCOL_SHARE",
      type: "u16",
      value: "2000"
    },
    {
      name: "MAX_BASE_FEE",
      docs: ["Maximum base fee, base_fee / 10^9 = fee_in_percentage"],
      type: "u128",
      value: "100000000"
    },
    {
      name: "MAX_BIN_ID",
      docs: ["Maximum bin ID supported. Computed based on 1 bps."],
      type: "i32",
      value: "443636"
    },
    {
      name: "MAX_BIN_PER_ARRAY",
      type: "u64",
      value: "70"
    },
    {
      name: "MAX_BIN_STEP",
      docs: ["Maximum bin step"],
      type: "u16",
      value: "400"
    },
    {
      name: "MAX_FEE_RATE",
      docs: ["Maximum fee rate. 10%"],
      type: "u64",
      value: "100000000"
    },
    {
      name: "MAX_PROTOCOL_SHARE",
      docs: ["Maximum protocol share of the fee. 25%"],
      type: "u16",
      value: "2500"
    },
    {
      name: "MAX_RESIZE_LENGTH",
      type: "u64",
      value: "91"
    },
    {
      name: "MAX_REWARD_BIN_SPLIT",
      type: "u64",
      value: "15"
    },
    {
      name: "MAX_REWARD_DURATION",
      type: "u64",
      value: "31536000"
    },
    {
      name: "MINIMUM_LIQUIDITY",
      type: "u128",
      value: "1000000"
    },
    {
      name: "MIN_BASE_FEE",
      docs: ["Minimum base fee"],
      type: "u128",
      value: "100000"
    },
    {
      name: "MIN_BIN_ID",
      docs: ["Minimum bin ID supported. Computed based on 1 bps."],
      type: "i32",
      value: "-443636"
    },
    {
      name: "MIN_REWARD_DURATION",
      type: "u64",
      value: "1"
    },
    {
      name: "NUM_REWARDS",
      type: "u64",
      value: "2"
    },
    {
      name: "ORACLE",
      type: "bytes",
      value: "[111, 114, 97, 99, 108, 101]"
    },
    {
      name: "POSITION",
      type: "bytes",
      value: "[112, 111, 115, 105, 116, 105, 111, 110]"
    },
    {
      name: "POSITION_MAX_LENGTH",
      type: "u64",
      value: "1400"
    },
    {
      name: "PRESET_PARAMETER",
      type: "bytes",
      value: "[112, 114, 101, 115, 101, 116, 95, 112, 97, 114, 97, 109, 101, 116, 101, 114]"
    },
    {
      name: "PRESET_PARAMETER2",
      type: "bytes",
      value: "[112, 114, 101, 115, 101, 116, 95, 112, 97, 114, 97, 109, 101, 116, 101, 114, 50]"
    },
    {
      name: "PROTOCOL_SHARE",
      type: "u16",
      value: "500"
    }
  ]
};
var LBCLMM_PROGRAM_IDS = {
  devnet: "LBUZKhRxPF3XUpBCjp4YzTKgLccjZhTSDM9YuVaPwxo",
  localhost: "LbVRzDTvBDEcrthxfZ4RL6yiq3uZw8bS6MwtdY6UhFQ",
  "mainnet-beta": "LBUZKhRxPF3XUpBCjp4YzTKgLccjZhTSDM9YuVaPwxo"
};
var ALT_ADDRESS = {
  "mainnet-beta": "JA5F83HUK9L78Y12TRLCsJZbu3Tv8pCK1GfK8mVNp1sz",
  devnet: "BD6E8oYV52P829MxDq3sEtqWKJrHh9pDSUHeaWR1jRBs"
};
var BASIS_POINT_MAX = 1e4;
var SCALE_OFFSET = 64;
var SCALE = new import_anchor2.BN(1).shln(SCALE_OFFSET);
var FEE_PRECISION = new import_anchor2.BN(1e9);
var MAX_FEE_RATE = new import_anchor2.BN(1e8);
var BIN_ARRAY_FEE = 0.07143744;
var POSITION_FEE = 0.05740608;
var TOKEN_ACCOUNT_FEE = 203928e-8;
var POOL_FEE = 718272e-8;
var BIN_ARRAY_BITMAP_FEE = 0.01180416;
var BIN_ARRAY_FEE_BN = new import_anchor2.BN(
  new decimal_default(BIN_ARRAY_FEE).mul(import_web312.LAMPORTS_PER_SOL).toString()
);
var POSITION_FEE_BN = new import_anchor2.BN(
  new decimal_default(POSITION_FEE).mul(import_web312.LAMPORTS_PER_SOL).toString()
);
var TOKEN_ACCOUNT_FEE_BN = new import_anchor2.BN(
  new decimal_default(TOKEN_ACCOUNT_FEE).mul(import_web312.LAMPORTS_PER_SOL).toString()
);
var POOL_FEE_BN = new import_anchor2.BN(
  new decimal_default(POOL_FEE).mul(import_web312.LAMPORTS_PER_SOL).toString()
);
var BIN_ARRAY_BITMAP_FEE_BN = new import_anchor2.BN(
  new decimal_default(BIN_ARRAY_BITMAP_FEE).mul(import_web312.LAMPORTS_PER_SOL).toString()
);
var CONSTANTS = Object.entries(dlmm_default.constants);
var MAX_BIN_ARRAY_SIZE = new import_anchor2.BN(
  CONSTANTS.find(([k, v]) => v.name == "MAX_BIN_PER_ARRAY")?.[1].value ?? 0
);
var DEFAULT_BIN_PER_POSITION = new import_anchor2.BN(
  CONSTANTS.find(([k, v]) => v.name == "DEFAULT_BIN_PER_POSITION")?.[1].value ?? 0
);
var BIN_ARRAY_BITMAP_SIZE = new import_anchor2.BN(
  CONSTANTS.find(([k, v]) => v.name == "BIN_ARRAY_BITMAP_SIZE")?.[1].value ?? 0
);
var EXTENSION_BINARRAY_BITMAP_SIZE = new import_anchor2.BN(
  CONSTANTS.find(([k, v]) => v.name == "EXTENSION_BINARRAY_BITMAP_SIZE")?.[1].value ?? 0
);
var POSITION_MAX_LENGTH = new import_anchor2.BN(
  CONSTANTS.find(([k, v]) => v.name == "POSITION_MAX_LENGTH")?.[1].value ?? 0
);
var MAX_RESIZE_LENGTH = new import_anchor2.BN(
  CONSTANTS.find(([k, v]) => v.name == "MAX_RESIZE_LENGTH")?.[1].value ?? 0
);
var SIMULATION_USER = new import_web312.PublicKey(
  "HrY9qR5TiB2xPzzvbBu5KrBorMfYGQXh9osXydz4jy9s"
);
var PRECISION = 18446744073709552e3;
var MAX_CLAIM_ALL_ALLOWED = 2;
var MAX_BIN_LENGTH_ALLOWED_IN_ONE_TX = 26;
var MAX_ACTIVE_BIN_SLIPPAGE = 3;
var ILM_BASE = new import_web312.PublicKey(
  "MFGQxwAmB91SwuYX36okv2Qmdc9aMuHTwWGUrp4AtB1"
);
var MAX_EXTRA_BIN_ARRAYS = 3;
var U64_MAX = new import_anchor2.BN("18446744073709551615");
var MAX_BINS_PER_POSITION = new import_anchor2.BN(
  CONSTANTS.find(([k, v]) => v.name == "POSITION_MAX_LENGTH")?.[1].value ?? 0
);
var DlmmSdkError = class extends Error {
  name;
  message;
  constructor(name, message) {
    super();
    this.name = name;
    this.message = message;
  }
};
var POSITION_MIN_SIZE = 8112;
var POSITION_BIN_DATA_SIZE = 112;
var BinLiquidity;
((BinLiquidity3) => {
  function fromBin(bin, binId, binStep, baseTokenDecimal, quoteTokenDecimal, version) {
    const pricePerLamport = getPriceOfBinByBinId(binId, binStep).toString();
    return {
      binId,
      xAmount: bin.amountX,
      yAmount: bin.amountY,
      supply: bin.liquiditySupply,
      price: pricePerLamport,
      version,
      pricePerToken: new decimal_default(pricePerLamport).mul(new decimal_default(10 ** (baseTokenDecimal - quoteTokenDecimal))).toString(),
      feeAmountXPerTokenStored: bin.feeAmountXPerTokenStored,
      feeAmountYPerTokenStored: bin.feeAmountYPerTokenStored,
      rewardPerTokenStored: bin.rewardPerTokenStored
    };
  }
  BinLiquidity3.fromBin = fromBin;
  function empty(binId, binStep, baseTokenDecimal, quoteTokenDecimal, version) {
    const pricePerLamport = getPriceOfBinByBinId(binId, binStep).toString();
    return {
      binId,
      xAmount: new import_anchor5.BN(0),
      yAmount: new import_anchor5.BN(0),
      supply: new import_anchor5.BN(0),
      price: pricePerLamport,
      version,
      pricePerToken: new decimal_default(pricePerLamport).mul(new decimal_default(10 ** (baseTokenDecimal - quoteTokenDecimal))).toString(),
      feeAmountXPerTokenStored: new import_anchor5.BN(0),
      feeAmountYPerTokenStored: new import_anchor5.BN(0),
      rewardPerTokenStored: [new import_anchor5.BN(0), new import_anchor5.BN(0)]
    };
  }
  BinLiquidity3.empty = empty;
})(BinLiquidity || (BinLiquidity = {}));
var ClockLayout = (0, import_borsh.struct)([
  (0, import_borsh.u64)("slot"),
  (0, import_borsh.i64)("epochStartTimestamp"),
  (0, import_borsh.u64)("epoch"),
  (0, import_borsh.u64)("leaderScheduleEpoch"),
  (0, import_borsh.i64)("unixTimestamp")
]);
var MEMO_PROGRAM_ID = new import_web314.PublicKey(
  "MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr"
);
var REBALANCE_POSITION_PADDING = Array(31).fill(0);
var MAX_EXPONENTIAL = new import_bn.default(524288);
var ONE = new import_bn.default(1).shln(SCALE_OFFSET);
var MAX2 = new import_bn.default(2).pow(new import_bn.default(128)).sub(new import_bn.default(1));
function pow2(base, exp2) {
  let invert = exp2.isNeg();
  if (exp2.isZero()) {
    return ONE;
  }
  exp2 = invert ? exp2.abs() : exp2;
  if (exp2.gt(MAX_EXPONENTIAL)) {
    return new import_bn.default(0);
  }
  let squaredBase = base;
  let result = ONE;
  if (squaredBase.gte(result)) {
    squaredBase = MAX2.div(squaredBase);
    invert = !invert;
  }
  if (!exp2.and(new import_bn.default(1)).isZero()) {
    result = result.mul(squaredBase).shrn(SCALE_OFFSET);
  }
  squaredBase = squaredBase.mul(squaredBase).shrn(SCALE_OFFSET);
  if (!exp2.and(new import_bn.default(2)).isZero()) {
    result = result.mul(squaredBase).shrn(SCALE_OFFSET);
  }
  squaredBase = squaredBase.mul(squaredBase).shrn(SCALE_OFFSET);
  if (!exp2.and(new import_bn.default(4)).isZero()) {
    result = result.mul(squaredBase).shrn(SCALE_OFFSET);
  }
  squaredBase = squaredBase.mul(squaredBase).shrn(SCALE_OFFSET);
  if (!exp2.and(new import_bn.default(8)).isZero()) {
    result = result.mul(squaredBase).shrn(SCALE_OFFSET);
  }
  squaredBase = squaredBase.mul(squaredBase).shrn(SCALE_OFFSET);
  if (!exp2.and(new import_bn.default(16)).isZero()) {
    result = result.mul(squaredBase).shrn(SCALE_OFFSET);
  }
  squaredBase = squaredBase.mul(squaredBase).shrn(SCALE_OFFSET);
  if (!exp2.and(new import_bn.default(32)).isZero()) {
    result = result.mul(squaredBase).shrn(SCALE_OFFSET);
  }
  squaredBase = squaredBase.mul(squaredBase).shrn(SCALE_OFFSET);
  if (!exp2.and(new import_bn.default(64)).isZero()) {
    result = result.mul(squaredBase).shrn(SCALE_OFFSET);
  }
  squaredBase = squaredBase.mul(squaredBase).shrn(SCALE_OFFSET);
  if (!exp2.and(new import_bn.default(128)).isZero()) {
    result = result.mul(squaredBase).shrn(SCALE_OFFSET);
  }
  squaredBase = squaredBase.mul(squaredBase).shrn(SCALE_OFFSET);
  if (!exp2.and(new import_bn.default(256)).isZero()) {
    result = result.mul(squaredBase).shrn(SCALE_OFFSET);
  }
  squaredBase = squaredBase.mul(squaredBase).shrn(SCALE_OFFSET);
  if (!exp2.and(new import_bn.default(512)).isZero()) {
    result = result.mul(squaredBase).shrn(SCALE_OFFSET);
  }
  squaredBase = squaredBase.mul(squaredBase).shrn(SCALE_OFFSET);
  if (!exp2.and(new import_bn.default(1024)).isZero()) {
    result = result.mul(squaredBase).shrn(SCALE_OFFSET);
  }
  squaredBase = squaredBase.mul(squaredBase).shrn(SCALE_OFFSET);
  if (!exp2.and(new import_bn.default(2048)).isZero()) {
    result = result.mul(squaredBase).shrn(SCALE_OFFSET);
  }
  squaredBase = squaredBase.mul(squaredBase).shrn(SCALE_OFFSET);
  if (!exp2.and(new import_bn.default(4096)).isZero()) {
    result = result.mul(squaredBase).shrn(SCALE_OFFSET);
  }
  squaredBase = squaredBase.mul(squaredBase).shrn(SCALE_OFFSET);
  if (!exp2.and(new import_bn.default(8192)).isZero()) {
    result = result.mul(squaredBase).shrn(SCALE_OFFSET);
  }
  squaredBase = squaredBase.mul(squaredBase).shrn(SCALE_OFFSET);
  if (!exp2.and(new import_bn.default(16384)).isZero()) {
    result = result.mul(squaredBase).shrn(SCALE_OFFSET);
  }
  squaredBase = squaredBase.mul(squaredBase).shrn(SCALE_OFFSET);
  if (!exp2.and(new import_bn.default(32768)).isZero()) {
    result = result.mul(squaredBase).shrn(SCALE_OFFSET);
  }
  squaredBase = squaredBase.mul(squaredBase).shrn(SCALE_OFFSET);
  if (!exp2.and(new import_bn.default(65536)).isZero()) {
    result = result.mul(squaredBase).shrn(SCALE_OFFSET);
  }
  squaredBase = squaredBase.mul(squaredBase).shrn(SCALE_OFFSET);
  if (!exp2.and(new import_bn.default(131072)).isZero()) {
    result = result.mul(squaredBase).shrn(SCALE_OFFSET);
  }
  squaredBase = squaredBase.mul(squaredBase).shrn(SCALE_OFFSET);
  if (!exp2.and(new import_bn.default(262144)).isZero()) {
    result = result.mul(squaredBase).shrn(SCALE_OFFSET);
  }
  if (result.isZero()) {
    return new import_bn.default(0);
  }
  if (invert) {
    result = MAX2.div(result);
  }
  return result;
}
async function getMultipleMintsExtraAccountMetasForTransferHook(connection, mintAddressesWithAccountInfo) {
  const extraAccountMetas = await Promise.all(
    mintAddressesWithAccountInfo.map(
      ({ mintAddress, mintAccountInfo }) => getExtraAccountMetasForTransferHook(
        connection,
        mintAddress,
        mintAccountInfo
      )
    )
  );
  const mintsWithHookAccountMap = /* @__PURE__ */ new Map();
  for (let i = 0; i < extraAccountMetas.length; i++) {
    const { mintAddress } = mintAddressesWithAccountInfo[i];
    const transferHooks = extraAccountMetas[i];
    mintsWithHookAccountMap.set(mintAddress.toBase58(), transferHooks);
  }
  return mintsWithHookAccountMap;
}
async function getExtraAccountMetasForTransferHook(connection, mintAddress, mintAccountInfo) {
  if (![TOKEN_PROGRAM_ID.toBase58(), TOKEN_2022_PROGRAM_ID.toBase58()].includes(
    mintAccountInfo.owner.toBase58()
  )) {
    return [];
  }
  const mintState = unpackMint(
    mintAddress,
    mintAccountInfo,
    mintAccountInfo.owner
  );
  if (mintAccountInfo.owner.equals(TOKEN_PROGRAM_ID)) {
    return [];
  }
  const transferHook = getTransferHook(mintState);
  if (!transferHook || transferHook.programId.equals(import_web316.PublicKey.default)) {
    return [];
  } else {
    const instruction = createTransferCheckedInstruction(
      import_web316.PublicKey.default,
      mintAddress,
      import_web316.PublicKey.default,
      import_web316.PublicKey.default,
      BigInt(0),
      mintState.decimals,
      [],
      mintAccountInfo.owner
    );
    await addExtraAccountMetasForExecute(
      connection,
      instruction,
      transferHook.programId,
      import_web316.PublicKey.default,
      mintAddress,
      import_web316.PublicKey.default,
      import_web316.PublicKey.default,
      BigInt(0)
    );
    const transferHookAccounts = instruction.keys.slice(4);
    if (transferHookAccounts.length == 0) {
      transferHookAccounts.push({
        pubkey: transferHook.programId,
        isSigner: false,
        isWritable: false
      });
    }
    return transferHookAccounts;
  }
}
function calculatePreFeeAmount(transferFee, postFeeAmount) {
  if (postFeeAmount.isZero()) {
    return new import_bn2.default(0);
  }
  if (transferFee.transferFeeBasisPoints === 0) {
    return postFeeAmount;
  }
  const maximumFee = new import_bn2.default(transferFee.maximumFee.toString());
  if (transferFee.transferFeeBasisPoints === MAX_FEE_BASIS_POINTS) {
    return postFeeAmount.add(maximumFee);
  }
  const ONE_IN_BASIS_POINTS2 = new import_bn2.default(MAX_FEE_BASIS_POINTS);
  const numerator = postFeeAmount.mul(ONE_IN_BASIS_POINTS2);
  const denominator = ONE_IN_BASIS_POINTS2.sub(
    new import_bn2.default(transferFee.transferFeeBasisPoints)
  );
  const rawPreFeeAmount = numerator.add(denominator).sub(new import_bn2.default(1)).div(denominator);
  if (rawPreFeeAmount.sub(postFeeAmount).gte(maximumFee)) {
    return postFeeAmount.add(maximumFee);
  }
  return rawPreFeeAmount;
}
function calculateInverseFee(transferFee, postFeeAmount) {
  const preFeeAmount = calculatePreFeeAmount(transferFee, postFeeAmount);
  return new import_bn2.default(
    calculateFee(transferFee, BigInt(preFeeAmount.toString())).toString()
  );
}
function calculateTransferFeeIncludedAmount(transferFeeExcludedAmount, mint, currentEpoch) {
  if (transferFeeExcludedAmount.isZero()) {
    return {
      amount: new import_bn2.default(0),
      transferFee: new import_bn2.default(0)
    };
  }
  const transferFeeConfig = getTransferFeeConfig(mint);
  if (transferFeeConfig === null) {
    return {
      amount: transferFeeExcludedAmount,
      transferFee: new import_bn2.default(0)
    };
  }
  const epochFee = getEpochFee(transferFeeConfig, BigInt(currentEpoch));
  const transferFee = epochFee.transferFeeBasisPoints == MAX_FEE_BASIS_POINTS ? new import_bn2.default(epochFee.maximumFee.toString()) : calculateInverseFee(epochFee, transferFeeExcludedAmount);
  const transferFeeIncludedAmount = transferFeeExcludedAmount.add(transferFee);
  return {
    amount: transferFeeIncludedAmount,
    transferFee
  };
}
function calculateTransferFeeExcludedAmount(transferFeeIncludedAmount, mint, currentEpoch) {
  const transferFeeConfig = getTransferFeeConfig(mint);
  if (transferFeeConfig === null) {
    return {
      amount: transferFeeIncludedAmount,
      transferFee: new import_bn2.default(0)
    };
  }
  const transferFeeIncludedAmountN = BigInt(
    transferFeeIncludedAmount.toString()
  );
  const transferFee = calculateFee(
    getEpochFee(transferFeeConfig, BigInt(currentEpoch)),
    transferFeeIncludedAmountN
  );
  const transferFeeExcludedAmount = new import_bn2.default(
    (transferFeeIncludedAmountN - transferFee).toString()
  );
  return {
    amount: transferFeeExcludedAmount,
    transferFee: new import_bn2.default(transferFee.toString())
  };
}
function getPriceOfBinByBinId(binId, binStep) {
  const binStepNum = new decimal_default(binStep).div(new decimal_default(BASIS_POINT_MAX));
  return new decimal_default(1).add(new decimal_default(binStepNum)).pow(new decimal_default(binId));
}
function toWeightDistribution(amountX, amountY, distributions, binStep) {
  let totalQuote = new import_anchor8.BN(0);
  const precision = 1e12;
  const quoteDistributions = distributions.map((bin) => {
    const price = new import_anchor8.BN(
      getPriceOfBinByBinId(bin.binId, binStep).mul(precision).floor().toString()
    );
    const quoteValue = amountX.mul(new import_anchor8.BN(bin.xAmountBpsOfTotal)).mul(new import_anchor8.BN(price)).div(new import_anchor8.BN(BASIS_POINT_MAX)).div(new import_anchor8.BN(precision));
    const quoteAmount = quoteValue.add(
      amountY.mul(new import_anchor8.BN(bin.yAmountBpsOfTotal)).div(new import_anchor8.BN(BASIS_POINT_MAX))
    );
    totalQuote = totalQuote.add(quoteAmount);
    return {
      binId: bin.binId,
      quoteAmount
    };
  });
  if (totalQuote.eq(new import_anchor8.BN(0))) {
    return [];
  }
  const distributionWeights = quoteDistributions.map((bin) => {
    const weight = Math.floor(
      bin.quoteAmount.mul(new import_anchor8.BN(65535)).div(totalQuote).toNumber()
    );
    return {
      binId: bin.binId,
      weight
    };
  }).filter((item) => item.weight > 0);
  return distributionWeights;
}
function mulShr(x, y, offset, rounding) {
  const denominator = new import_anchor7.BN(1).shln(offset);
  return mulDiv(x, y, denominator, rounding);
}
function shlDiv(x, y, offset, rounding) {
  const scale = new import_anchor7.BN(1).shln(offset);
  return mulDiv(x, scale, y, rounding);
}
function mulDiv(x, y, denominator, rounding) {
  const { div: div2, mod: mod2 } = x.mul(y).divmod(denominator);
  if (rounding == 0 && !mod2.isZero()) {
    return div2.add(new import_anchor7.BN(1));
  }
  return div2;
}
function computeBaseFactorFromFeeBps(binStep, feeBps) {
  const U16_MAX = 65535;
  const computedBaseFactor = feeBps.toNumber() * BASIS_POINT_MAX / binStep.toNumber();
  if (computedBaseFactor > U16_MAX) {
    let truncatedBaseFactor = computedBaseFactor;
    let base_power_factor = 0;
    while (truncatedBaseFactor > U16_MAX) {
      const remainder = truncatedBaseFactor % 10;
      if (remainder == 0) {
        base_power_factor += 1;
        truncatedBaseFactor /= 10;
      } else {
        throw "have decimals";
      }
    }
    return [new import_anchor7.BN(truncatedBaseFactor), new import_anchor7.BN(base_power_factor)];
  } else {
    const computedBaseFactorFloor = Math.floor(computedBaseFactor);
    if (computedBaseFactor != computedBaseFactorFloor) {
      if (computedBaseFactorFloor >= U16_MAX) {
        throw "base factor for the give fee bps overflow u16";
      }
      if (computedBaseFactorFloor == 0) {
        throw "base factor for the give fee bps underflow";
      }
      if (computedBaseFactor % 1 != 0) {
        throw "couldn't compute base factor for the exact fee bps";
      }
    }
    return [new import_anchor7.BN(computedBaseFactor), new import_anchor7.BN(0)];
  }
}
function getQPriceFromId(binId, binStep) {
  return pow2(getQPriceBaseFactor(binStep), binId);
}
function getQPriceBaseFactor(binStep) {
  const bps = binStep.shln(SCALE_OFFSET).div(new import_anchor7.BN(BASIS_POINT_MAX));
  const base = ONE.add(bps);
  return base;
}
function getC(amount, binStep, binId, baseTokenDecimal, quoteTokenDecimal, minPrice, maxPrice, k) {
  const currentPricePerLamport = new decimal_default(1 + binStep / 1e4).pow(
    binId.toNumber()
  );
  const currentPricePerToken = currentPricePerLamport.mul(
    new decimal_default(10 ** (baseTokenDecimal - quoteTokenDecimal))
  );
  const priceRange = maxPrice.sub(minPrice);
  const currentPriceDeltaFromMin = currentPricePerToken.sub(
    new decimal_default(minPrice)
  );
  const c = new decimal_default(amount.toString()).mul(
    currentPriceDeltaFromMin.div(priceRange).pow(k)
  );
  return c.floor();
}
function distributeAmountToCompressedBinsByRatio(compressedBinAmount, uncompressedAmount, multiplier, binCapAmount) {
  const newCompressedBinAmount = /* @__PURE__ */ new Map();
  let totalCompressedAmount = new import_anchor7.BN(0);
  for (const compressedAmount of compressedBinAmount.values()) {
    totalCompressedAmount = totalCompressedAmount.add(compressedAmount);
  }
  let totalDepositedAmount = new import_anchor7.BN(0);
  for (const [binId, compressedAmount] of compressedBinAmount.entries()) {
    const depositAmount = compressedAmount.mul(uncompressedAmount).div(totalCompressedAmount);
    let compressedDepositAmount = depositAmount.div(multiplier);
    let newCompressedAmount = compressedAmount.add(compressedDepositAmount);
    if (newCompressedAmount.gt(binCapAmount)) {
      compressedDepositAmount = compressedDepositAmount.sub(
        newCompressedAmount.sub(binCapAmount)
      );
      newCompressedAmount = binCapAmount;
    }
    newCompressedBinAmount.set(binId, newCompressedAmount);
    totalDepositedAmount = totalDepositedAmount.add(
      compressedDepositAmount.mul(multiplier)
    );
  }
  const loss = uncompressedAmount.sub(totalDepositedAmount);
  return {
    newCompressedBinAmount,
    loss
  };
}
function getPositionCount(minBinId, maxBinId) {
  const binDelta = maxBinId.sub(minBinId);
  const positionCount = binDelta.div(DEFAULT_BIN_PER_POSITION);
  return positionCount.add(new import_anchor7.BN(1));
}
function findOptimumDecompressMultiplier(binAmount, tokenDecimal) {
  let multiplier = new import_anchor7.BN(10).pow(tokenDecimal);
  while (!multiplier.isZero()) {
    let found = true;
    for (const [_binId, amount] of binAmount) {
      const compressedAmount = amount.div(multiplier);
      if (compressedAmount.isZero()) {
        multiplier = multiplier.div(new import_anchor7.BN(10));
        found = false;
        break;
      }
    }
    if (found) {
      return multiplier;
    }
  }
  throw "Couldn't find optimum multiplier";
}
function compressBinAmount(binAmount, multiplier) {
  const compressedBinAmount = /* @__PURE__ */ new Map();
  let totalAmount = new import_anchor7.BN(0);
  let compressionLoss = new import_anchor7.BN(0);
  for (const [binId, amount] of binAmount) {
    totalAmount = totalAmount.add(amount);
    const compressedAmount = amount.div(multiplier);
    compressedBinAmount.set(binId, compressedAmount);
    let loss = amount.sub(compressedAmount.mul(multiplier));
    compressionLoss = compressionLoss.add(loss);
  }
  return {
    compressedBinAmount,
    compressionLoss
  };
}
function generateAmountForBinRange(amount, binStep, tokenXDecimal, tokenYDecimal, minBinId, maxBinId, k) {
  const toTokenMultiplier = new decimal_default(10 ** (tokenXDecimal - tokenYDecimal));
  const minPrice = getPriceOfBinByBinId(minBinId.toNumber(), binStep).mul(
    toTokenMultiplier
  );
  const maxPrice = getPriceOfBinByBinId(maxBinId.toNumber(), binStep).mul(
    toTokenMultiplier
  );
  const binAmounts = /* @__PURE__ */ new Map();
  for (let i = minBinId.toNumber(); i < maxBinId.toNumber(); i++) {
    const binAmount = generateBinAmount(
      amount,
      binStep,
      new import_anchor7.BN(i),
      tokenXDecimal,
      tokenYDecimal,
      minPrice,
      maxPrice,
      k
    );
    if (binAmount.isZero()) {
      throw "bin amount is zero";
    }
    binAmounts.set(i, binAmount);
  }
  return binAmounts;
}
function generateBinAmount(amount, binStep, binId, tokenXDecimal, tokenYDecimal, minPrice, maxPrice, k) {
  const c1 = getC(
    amount,
    binStep,
    binId.add(new import_anchor7.BN(1)),
    tokenXDecimal,
    tokenYDecimal,
    minPrice,
    maxPrice,
    k
  );
  const c0 = getC(
    amount,
    binStep,
    binId,
    tokenXDecimal,
    tokenYDecimal,
    minPrice,
    maxPrice,
    k
  );
  return new import_anchor7.BN(c1.sub(c0).floor().toString());
}
function sortTokenMints(tokenX, tokenY) {
  const [minKey, maxKey] = tokenX.toBuffer().compare(tokenY.toBuffer()) == 1 ? [tokenY, tokenX] : [tokenX, tokenY];
  return [minKey, maxKey];
}
function deriveLbPairWithPresetParamWithIndexKey(presetParameterKey, tokenX, tokenY, programId) {
  const [minKey, maxKey] = sortTokenMints(tokenX, tokenY);
  return import_web317.PublicKey.findProgramAddressSync(
    [presetParameterKey.toBuffer(), minKey.toBuffer(), maxKey.toBuffer()],
    programId
  );
}
function deriveLbPair2(tokenX, tokenY, binStep, baseFactor, programId) {
  const [minKey, maxKey] = sortTokenMints(tokenX, tokenY);
  return import_web317.PublicKey.findProgramAddressSync(
    [
      minKey.toBuffer(),
      maxKey.toBuffer(),
      new Uint8Array(binStep.toArrayLike(Buffer, "le", 2)),
      new Uint8Array(baseFactor.toArrayLike(Buffer, "le", 2))
    ],
    programId
  );
}
function deriveLbPair(tokenX, tokenY, binStep, programId) {
  const [minKey, maxKey] = sortTokenMints(tokenX, tokenY);
  return import_web317.PublicKey.findProgramAddressSync(
    [
      minKey.toBuffer(),
      maxKey.toBuffer(),
      new Uint8Array(binStep.toArrayLike(Buffer, "le", 2))
    ],
    programId
  );
}
function deriveCustomizablePermissionlessLbPair(tokenX, tokenY, programId) {
  const [minKey, maxKey] = sortTokenMints(tokenX, tokenY);
  return import_web317.PublicKey.findProgramAddressSync(
    [ILM_BASE.toBuffer(), minKey.toBuffer(), maxKey.toBuffer()],
    programId
  );
}
function deriveOracle(lbPair, programId) {
  return import_web317.PublicKey.findProgramAddressSync(
    [Buffer.from("oracle"), lbPair.toBytes()],
    programId
  );
}
function derivePosition(lbPair, base, lowerBinId, width, programId) {
  let lowerBinIdBytes;
  if (lowerBinId.isNeg()) {
    lowerBinIdBytes = new Uint8Array(
      lowerBinId.toTwos(32).toArrayLike(Buffer, "le", 4)
    );
  } else {
    lowerBinIdBytes = new Uint8Array(lowerBinId.toArrayLike(Buffer, "le", 4));
  }
  return import_web317.PublicKey.findProgramAddressSync(
    [
      Buffer.from("position"),
      lbPair.toBuffer(),
      base.toBuffer(),
      lowerBinIdBytes,
      new Uint8Array(width.toArrayLike(Buffer, "le", 4))
    ],
    programId
  );
}
function deriveBinArray(lbPair, index, programId) {
  let binArrayBytes;
  if (index.isNeg()) {
    binArrayBytes = new Uint8Array(
      index.toTwos(64).toArrayLike(Buffer, "le", 8)
    );
  } else {
    binArrayBytes = new Uint8Array(index.toArrayLike(Buffer, "le", 8));
  }
  return import_web317.PublicKey.findProgramAddressSync(
    [Buffer.from("bin_array"), lbPair.toBytes(), binArrayBytes],
    programId
  );
}
function deriveReserve(token, lbPair, programId) {
  return import_web317.PublicKey.findProgramAddressSync(
    [lbPair.toBuffer(), token.toBuffer()],
    programId
  );
}
function deriveTokenBadge(mint, programId) {
  return import_web317.PublicKey.findProgramAddressSync(
    [Buffer.from("token_badge"), mint.toBuffer()],
    programId
  );
}
function derivePlaceHolderAccountMeta(programId) {
  return {
    pubkey: programId,
    isWritable: false,
    isSigner: false
  };
}
function internalBitmapRange() {
  const lowerBinArrayIndex = BIN_ARRAY_BITMAP_SIZE.neg();
  const upperBinArrayIndex = BIN_ARRAY_BITMAP_SIZE.sub(new import_anchor6.BN(1));
  return [lowerBinArrayIndex, upperBinArrayIndex];
}
function buildBitmapFromU64Arrays(u64Arrays, type) {
  const buffer = Buffer.concat(
    u64Arrays.map((b) => {
      return b.toArrayLike(Buffer, "le", 8);
    })
  );
  return new import_anchor6.BN(buffer, "le");
}
function bitmapTypeDetail(type) {
  if (type == 0) {
    return {
      bits: 1024,
      bytes: 1024 / 8
    };
  } else {
    return {
      bits: 512,
      bytes: 512 / 8
    };
  }
}
function mostSignificantBit(number, bitLength) {
  const highestIndex = bitLength - 1;
  if (number.isZero()) {
    return null;
  }
  for (let i = highestIndex; i >= 0; i--) {
    if (number.testn(i)) {
      return highestIndex - i;
    }
  }
  return null;
}
function leastSignificantBit(number, bitLength) {
  if (number.isZero()) {
    return null;
  }
  for (let i = 0; i < bitLength; i++) {
    if (number.testn(i)) {
      return i;
    }
  }
  return null;
}
function extensionBitmapRange() {
  return [
    BIN_ARRAY_BITMAP_SIZE.neg().mul(
      EXTENSION_BINARRAY_BITMAP_SIZE.add(new import_anchor6.BN(1))
    ),
    BIN_ARRAY_BITMAP_SIZE.mul(
      EXTENSION_BINARRAY_BITMAP_SIZE.add(new import_anchor6.BN(1))
    ).sub(new import_anchor6.BN(1))
  ];
}
function findSetBit(startIndex, endIndex, binArrayBitmapExtension) {
  const getBinArrayOffset = (binArrayIndex) => {
    return binArrayIndex.gt(new import_anchor6.BN(0)) ? binArrayIndex.mod(BIN_ARRAY_BITMAP_SIZE) : binArrayIndex.add(new import_anchor6.BN(1)).neg().mod(BIN_ARRAY_BITMAP_SIZE);
  };
  const getBitmapOffset = (binArrayIndex) => {
    return binArrayIndex.gt(new import_anchor6.BN(0)) ? binArrayIndex.div(BIN_ARRAY_BITMAP_SIZE).sub(new import_anchor6.BN(1)) : binArrayIndex.add(new import_anchor6.BN(1)).neg().div(BIN_ARRAY_BITMAP_SIZE).sub(new import_anchor6.BN(1));
  };
  if (startIndex <= endIndex) {
    for (let i = startIndex; i <= endIndex; i++) {
      const binArrayOffset = getBinArrayOffset(new import_anchor6.BN(i)).toNumber();
      const bitmapOffset = getBitmapOffset(new import_anchor6.BN(i)).toNumber();
      const bitmapChunks = i > 0 ? binArrayBitmapExtension.positiveBinArrayBitmap[bitmapOffset] : binArrayBitmapExtension.negativeBinArrayBitmap[bitmapOffset];
      const bitmap = buildBitmapFromU64Arrays(
        bitmapChunks,
        1
        /* U512 */
      );
      if (bitmap.testn(binArrayOffset)) {
        return i;
      }
    }
  } else {
    for (let i = startIndex; i >= endIndex; i--) {
      const binArrayOffset = getBinArrayOffset(new import_anchor6.BN(i)).toNumber();
      const bitmapOffset = getBitmapOffset(new import_anchor6.BN(i)).toNumber();
      const bitmapChunks = i > 0 ? binArrayBitmapExtension.positiveBinArrayBitmap[bitmapOffset] : binArrayBitmapExtension.negativeBinArrayBitmap[bitmapOffset];
      const bitmap = buildBitmapFromU64Arrays(
        bitmapChunks,
        1
        /* U512 */
      );
      if (bitmap.testn(binArrayOffset)) {
        return i;
      }
    }
  }
  return null;
}
function isOverflowDefaultBinArrayBitmap(binArrayIndex) {
  const [minBinArrayIndex, maxBinArrayIndex] = internalBitmapRange();
  return binArrayIndex.gt(maxBinArrayIndex) || binArrayIndex.lt(minBinArrayIndex);
}
function deriveBinArrayBitmapExtension(lbPair, programId) {
  return import_web315.PublicKey.findProgramAddressSync(
    [Buffer.from("bitmap"), lbPair.toBytes()],
    programId
  );
}
function binIdToBinArrayIndex(binId) {
  const { div: idx, mod: mod2 } = binId.divmod(MAX_BIN_ARRAY_SIZE);
  return binId.isNeg() && !mod2.isZero() ? idx.sub(new import_anchor6.BN(1)) : idx;
}
function getBinArrayLowerUpperBinId(binArrayIndex) {
  const lowerBinId = binArrayIndex.mul(MAX_BIN_ARRAY_SIZE);
  const upperBinId = lowerBinId.add(MAX_BIN_ARRAY_SIZE).sub(new import_anchor6.BN(1));
  return [lowerBinId, upperBinId];
}
function isBinIdWithinBinArray(activeId, binArrayIndex) {
  const [lowerBinId, upperBinId] = getBinArrayLowerUpperBinId(binArrayIndex);
  return activeId.gte(lowerBinId) && activeId.lte(upperBinId);
}
function getBinFromBinArray(binId, binArray) {
  const [lowerBinId, upperBinId] = getBinArrayLowerUpperBinId(binArray.index);
  let index = 0;
  if (binId > 0) {
    index = binId - lowerBinId.toNumber();
  } else {
    const delta = upperBinId.toNumber() - binId;
    index = MAX_BIN_ARRAY_SIZE.toNumber() - delta - 1;
  }
  return binArray.bins[index];
}
function findNextBinArrayIndexWithLiquidity(swapForY, activeId, lbPairState, binArrayBitmapExtension) {
  const [lowerBinArrayIndex, upperBinArrayIndex] = internalBitmapRange();
  let startBinArrayIndex = binIdToBinArrayIndex(activeId);
  while (true) {
    if (isOverflowDefaultBinArrayBitmap(startBinArrayIndex)) {
      if (binArrayBitmapExtension === null) {
        return null;
      }
      const [minBinArrayIndex, maxBinArrayIndex] = extensionBitmapRange();
      if (startBinArrayIndex.isNeg()) {
        if (swapForY) {
          const binArrayIndex = findSetBit(
            startBinArrayIndex.toNumber(),
            minBinArrayIndex.toNumber(),
            binArrayBitmapExtension
          );
          if (binArrayIndex !== null) {
            return new import_anchor6.BN(binArrayIndex);
          } else {
            return null;
          }
        } else {
          const binArrayIndex = findSetBit(
            startBinArrayIndex.toNumber(),
            BIN_ARRAY_BITMAP_SIZE.neg().sub(new import_anchor6.BN(1)).toNumber(),
            binArrayBitmapExtension
          );
          if (binArrayIndex !== null) {
            return new import_anchor6.BN(binArrayIndex);
          } else {
            startBinArrayIndex = BIN_ARRAY_BITMAP_SIZE.neg();
          }
        }
      } else {
        if (swapForY) {
          const binArrayIndex = findSetBit(
            startBinArrayIndex.toNumber(),
            BIN_ARRAY_BITMAP_SIZE.toNumber(),
            binArrayBitmapExtension
          );
          if (binArrayIndex !== null) {
            return new import_anchor6.BN(binArrayIndex);
          } else {
            startBinArrayIndex = BIN_ARRAY_BITMAP_SIZE.sub(new import_anchor6.BN(1));
          }
        } else {
          const binArrayIndex = findSetBit(
            startBinArrayIndex.toNumber(),
            maxBinArrayIndex.toNumber(),
            binArrayBitmapExtension
          );
          if (binArrayIndex !== null) {
            return new import_anchor6.BN(binArrayIndex);
          } else {
            return null;
          }
        }
      }
    } else {
      const bitmapType = 0;
      const bitmapDetail = bitmapTypeDetail(bitmapType);
      const offset = startBinArrayIndex.add(BIN_ARRAY_BITMAP_SIZE);
      const bitmap = buildBitmapFromU64Arrays(
        lbPairState.binArrayBitmap,
        bitmapType
      );
      if (swapForY) {
        const upperBitRange = new import_anchor6.BN(bitmapDetail.bits - 1).sub(offset);
        const croppedBitmap = bitmap.shln(upperBitRange.toNumber());
        const msb = mostSignificantBit(croppedBitmap, bitmapDetail.bits);
        if (msb !== null) {
          return startBinArrayIndex.sub(new import_anchor6.BN(msb));
        } else {
          startBinArrayIndex = lowerBinArrayIndex.sub(new import_anchor6.BN(1));
        }
      } else {
        const lowerBitRange = offset;
        const croppedBitmap = bitmap.shrn(lowerBitRange.toNumber());
        const lsb = leastSignificantBit(croppedBitmap, bitmapDetail.bits);
        if (lsb !== null) {
          return startBinArrayIndex.add(new import_anchor6.BN(lsb));
        } else {
          startBinArrayIndex = upperBinArrayIndex.add(new import_anchor6.BN(1));
        }
      }
    }
  }
}
function findNextBinArrayWithLiquidity(swapForY, activeBinId, lbPairState, binArrayBitmapExtension, binArrays) {
  const nearestBinArrayIndexWithLiquidity = findNextBinArrayIndexWithLiquidity(
    swapForY,
    activeBinId,
    lbPairState,
    binArrayBitmapExtension
  );
  if (nearestBinArrayIndexWithLiquidity == null) {
    return null;
  }
  const binArrayAccount = binArrays.find(
    (ba) => ba.account.index.eq(nearestBinArrayIndexWithLiquidity)
  );
  if (!binArrayAccount) {
    return null;
  }
  return binArrayAccount;
}
function* enumerateBins(binsById, lowerBinId, upperBinId, binStep, baseTokenDecimal, quoteTokenDecimal, version) {
  for (let currentBinId = lowerBinId; currentBinId <= upperBinId; currentBinId++) {
    const bin = binsById.get(currentBinId);
    if (bin != null) {
      yield BinLiquidity.fromBin(
        bin,
        currentBinId,
        binStep,
        baseTokenDecimal,
        quoteTokenDecimal,
        version
      );
    } else {
      yield BinLiquidity.empty(
        currentBinId,
        binStep,
        baseTokenDecimal,
        quoteTokenDecimal,
        version
      );
    }
  }
}
function getBinIdIndexInBinArray(binId, lowerBinId, upperBinId) {
  if (binId.lt(lowerBinId) || binId.gt(upperBinId)) {
    return null;
  }
  return binId.sub(lowerBinId);
}
var DEFAULT_ADD_LIQUIDITY_CU = 1e6;
var DEFAULT_EXTEND_POSITION_HIGH_CU = 1e6;
var DEFAULT_EXTEND_POSITION_LOW_CU = 3e4;
var DEFAULT_INIT_POSITION_CU = 3e4;
var DEFAULT_INIT_BIN_ARRAY_CU = 35e4;
var MIN_CU_BUFFER = 5e4;
var MAX_CU_BUFFER = 2e5;
var MAX_CU = 14e5;
var getDefaultExtendPositionCU = (side) => {
  switch (side) {
    case 0:
      return DEFAULT_EXTEND_POSITION_HIGH_CU;
    case 1:
      return DEFAULT_EXTEND_POSITION_LOW_CU;
  }
};
var getSimulationComputeUnits = async (connection, instructions, payer, lookupTables, commitment = "confirmed") => {
  const testInstructions = [
    // Set an arbitrarily high number in simulation
    // so we can be sure the transaction will succeed
    // and get the real compute units used
    import_web318.ComputeBudgetProgram.setComputeUnitLimit({ units: 14e5 }),
    ...instructions
  ];
  const testTransaction = new import_web318.VersionedTransaction(
    new import_web318.TransactionMessage({
      instructions: testInstructions,
      payerKey: payer,
      // RecentBlockhash can by any public key during simulation
      // since 'replaceRecentBlockhash' is set to 'true' below
      recentBlockhash: import_web318.PublicKey.default.toString()
    }).compileToV0Message(lookupTables)
  );
  const rpcResponse = await connection.simulateTransaction(testTransaction, {
    replaceRecentBlockhash: true,
    sigVerify: false,
    commitment
  });
  if (rpcResponse?.value?.err) {
    const logs = rpcResponse.value.logs?.join("\n  \u2022 ") || "No logs available";
    throw new Error(
      `Transaction simulation failed:
  \u2022${logs}` + JSON.stringify(rpcResponse?.value?.err)
    );
  }
  return rpcResponse.value.unitsConsumed || null;
};
function combineBaseAndExtendedPositionBinData(base, extended) {
  const combinedLiquidityShares = base.liquidityShares;
  const combinedRewardInfos = base.rewardInfos;
  const combinedFeeInfos = base.feeInfos;
  for (const binData of extended) {
    combinedLiquidityShares.push(binData.liquidityShare);
    combinedRewardInfos.push(binData.rewardInfo);
    combinedFeeInfos.push(binData.feeInfo);
  }
  return {
    liquidityShares: combinedLiquidityShares,
    rewardInfos: combinedRewardInfos,
    feeInfos: combinedFeeInfos
  };
}
function wrapPosition(program, key, account) {
  const disc = account.data.subarray(0, 8);
  if (disc.equals(Buffer.from(getAccountDiscriminator("positionV2")))) {
    const state = decodeAccount(
      program,
      "positionV2",
      account.data
    );
    const extended = decodeExtendedPosition(
      state,
      program,
      account.data.subarray(8 + POSITION_MIN_SIZE)
    );
    const combinedPositionBinData = combineBaseAndExtendedPositionBinData(
      state,
      extended
    );
    return new PositionV2Wrapper(key, state, extended, combinedPositionBinData);
  } else {
    throw new Error("Unknown position account");
  }
}
var PositionV2Wrapper = class {
  constructor(positionAddress, inner, extended, combinedPositionBinData) {
    this.positionAddress = positionAddress;
    this.inner = inner;
    this.extended = extended;
    this.combinedPositionBinData = combinedPositionBinData;
  }
  address() {
    return this.positionAddress;
  }
  totalClaimedRewards() {
    return this.inner.totalClaimedRewards;
  }
  feeOwner() {
    return this.inner.feeOwner;
  }
  lockReleasePoint() {
    return this.inner.lockReleasePoint;
  }
  operator() {
    return this.inner.operator;
  }
  totalClaimedFeeYAmount() {
    return this.inner.totalClaimedFeeYAmount;
  }
  totalClaimedFeeXAmount() {
    return this.inner.totalClaimedFeeXAmount;
  }
  lbPair() {
    return this.inner.lbPair;
  }
  lowerBinId() {
    return new import_bn4.default(this.inner.lowerBinId);
  }
  upperBinId() {
    return new import_bn4.default(this.inner.upperBinId);
  }
  liquidityShares() {
    return this.combinedPositionBinData.liquidityShares;
  }
  rewardInfos() {
    return this.combinedPositionBinData.rewardInfos;
  }
  feeInfos() {
    return this.combinedPositionBinData.feeInfos;
  }
  lastUpdatedAt() {
    return this.inner.lastUpdatedAt;
  }
  getBinArrayIndexesCoverage() {
    const isExtended = this.extended.length > 0;
    if (isExtended) {
      return getBinArrayIndexesCoverage(this.lowerBinId(), this.upperBinId());
    } else {
      const lowerBinArrayIndex = binIdToBinArrayIndex(this.lowerBinId());
      const upperBinArrayIndex = lowerBinArrayIndex.add(new import_bn4.default(1));
      return [lowerBinArrayIndex, upperBinArrayIndex];
    }
  }
  getBinArrayKeysCoverage(programId) {
    return this.getBinArrayIndexesCoverage().map(
      (index) => deriveBinArray(this.lbPair(), index, programId)[0]
    );
  }
  version() {
    return 1;
  }
  owner() {
    return this.inner.owner;
  }
  width() {
    return this.upperBinId().sub(this.lowerBinId()).add(new import_bn4.default(1));
  }
};
function getBinArrayIndexesCoverage(lowerBinId, upperBinId) {
  const lowerBinArrayIndex = binIdToBinArrayIndex(lowerBinId);
  const upperBinArrayIndex = binIdToBinArrayIndex(upperBinId);
  const binArrayIndexes = [];
  for (let i = lowerBinArrayIndex.toNumber(); i <= upperBinArrayIndex.toNumber(); i++) {
    binArrayIndexes.push(new import_bn3.default(i));
  }
  return binArrayIndexes;
}
function getBinArrayKeysCoverage2(lowerBinId, upperBinId, lbPair, programId) {
  const binArrayIndexes = getBinArrayIndexesCoverage(lowerBinId, upperBinId);
  return binArrayIndexes.map((index) => {
    return deriveBinArray(lbPair, index, programId)[0];
  });
}
function getBinArrayAccountMetasCoverage(lowerBinId, upperBinId, lbPair, programId) {
  return getBinArrayKeysCoverage2(lowerBinId, upperBinId, lbPair, programId).map(
    (key) => {
      return {
        pubkey: key,
        isSigner: false,
        isWritable: true
      };
    }
  );
}
function getPositionLowerUpperBinIdWithLiquidity(position) {
  const binWithLiquidity = position.positionBinData.filter(
    (b) => !new import_bn3.default(b.binLiquidity).isZero() || !new import_bn3.default(b.positionFeeXAmount.toString()).isZero() || !new import_bn3.default(b.positionFeeYAmount.toString()).isZero() || !new import_bn3.default(b.positionRewardAmount[0].toString()).isZero() || !new import_bn3.default(b.positionRewardAmount[1].toString()).isZero()
  );
  return binWithLiquidity.length > 0 ? {
    lowerBinId: new import_bn3.default(binWithLiquidity[0].binId),
    upperBinId: new import_bn3.default(binWithLiquidity[binWithLiquidity.length - 1].binId)
  } : null;
}
function isPositionNoFee(position) {
  return position.feeX.isZero() && position.feeY.isZero();
}
function isPositionNoReward(position) {
  return position.rewardOne.isZero() && position.rewardTwo.isZero();
}
function chunkBinRange(minBinId, maxBinId) {
  const chunkedBinRange = [];
  let startBinId = minBinId;
  while (startBinId <= maxBinId) {
    const endBinId = Math.min(
      startBinId + DEFAULT_BIN_PER_POSITION.toNumber() - 1,
      maxBinId
    );
    chunkedBinRange.push({
      lowerBinId: startBinId,
      upperBinId: endBinId
    });
    startBinId += DEFAULT_BIN_PER_POSITION.toNumber();
  }
  return chunkedBinRange;
}
async function getPositionExpandRentExemption(currentMinBinId, currentMaxBinId, connection, binCountToExpand) {
  const currentPositionWidth = currentMaxBinId.sub(currentMinBinId).addn(1);
  const positionWidthAfterExpand = currentPositionWidth.add(binCountToExpand);
  if (positionWidthAfterExpand.lte(DEFAULT_BIN_PER_POSITION)) {
    return 0;
  } else {
    const binCountInExpandedBytes = positionWidthAfterExpand.sub(
      DEFAULT_BIN_PER_POSITION
    );
    const expandSize = binCountInExpandedBytes.toNumber() * POSITION_BIN_DATA_SIZE;
    const [minimumLamports, rentExemptionLamports] = await Promise.all([
      connection.getMinimumBalanceForRentExemption(0),
      connection.getMinimumBalanceForRentExemption(expandSize)
    ]);
    return rentExemptionLamports - minimumLamports;
  }
}
function getExtendedPositionBinCount(minBinId, maxBinId) {
  const width = maxBinId.sub(minBinId).addn(1);
  const extended = width.sub(DEFAULT_BIN_PER_POSITION);
  return extended.lte(new import_bn3.default(0)) ? new import_bn3.default(0) : extended;
}
function decodeExtendedPosition(base, program, bytes) {
  const width = base.upperBinId - base.lowerBinId + 1;
  const extendedWidth = width - DEFAULT_BIN_PER_POSITION.toNumber();
  const extendedPosition = [];
  for (let i = 0; i < extendedWidth; i++) {
    const offset = i * POSITION_BIN_DATA_SIZE;
    const data = bytes.subarray(offset, offset + POSITION_BIN_DATA_SIZE);
    const decodedPositionBinData = program.coder.types.decode(
      // TODO: Find a type safe way
      "positionBinData",
      data
    );
    extendedPosition.push(decodedPositionBinData);
  }
  return extendedPosition;
}
function getBaseFee(binStep, sParameter) {
  return new import_anchor10.BN(sParameter.baseFactor).mul(new import_anchor10.BN(binStep)).mul(new import_anchor10.BN(10)).mul(new import_anchor10.BN(10).pow(new import_anchor10.BN(sParameter.baseFeePowerFactor)));
}
function getVariableFee(binStep, sParameter, vParameter) {
  if (sParameter.variableFeeControl > 0) {
    const square_vfa_bin = new import_anchor10.BN(vParameter.volatilityAccumulator).mul(new import_anchor10.BN(binStep)).pow(new import_anchor10.BN(2));
    const v_fee = new import_anchor10.BN(sParameter.variableFeeControl).mul(square_vfa_bin);
    return v_fee.add(new import_anchor10.BN(99999999999)).div(new import_anchor10.BN(1e11));
  }
  return new import_anchor10.BN(0);
}
function getTotalFee(binStep, sParameter, vParameter) {
  const totalFee = getBaseFee(binStep, sParameter).add(
    getVariableFee(binStep, sParameter, vParameter)
  );
  return totalFee.gt(MAX_FEE_RATE) ? MAX_FEE_RATE : totalFee;
}
function computeFee(binStep, sParameter, vParameter, inAmount) {
  const totalFee = getTotalFee(binStep, sParameter, vParameter);
  const denominator = FEE_PRECISION.sub(totalFee);
  return inAmount.mul(totalFee).add(denominator).sub(new import_anchor10.BN(1)).div(denominator);
}
function computeFeeFromAmount(binStep, sParameter, vParameter, inAmountWithFees) {
  const totalFee = getTotalFee(binStep, sParameter, vParameter);
  return inAmountWithFees.mul(totalFee).add(FEE_PRECISION.sub(new import_anchor10.BN(1))).div(FEE_PRECISION);
}
function computeProtocolFee(feeAmount, sParameter) {
  return feeAmount.mul(new import_anchor10.BN(sParameter.protocolShare)).div(new import_anchor10.BN(BASIS_POINT_MAX));
}
function swapExactOutQuoteAtBin(bin, binStep, sParameter, vParameter, outAmount, swapForY) {
  if (swapForY && bin.amountY.isZero()) {
    return {
      amountIn: new import_anchor10.BN(0),
      amountOut: new import_anchor10.BN(0),
      fee: new import_anchor10.BN(0),
      protocolFee: new import_anchor10.BN(0)
    };
  }
  if (!swapForY && bin.amountX.isZero()) {
    return {
      amountIn: new import_anchor10.BN(0),
      amountOut: new import_anchor10.BN(0),
      fee: new import_anchor10.BN(0),
      protocolFee: new import_anchor10.BN(0)
    };
  }
  let maxAmountOut;
  let maxAmountIn;
  if (swapForY) {
    maxAmountOut = bin.amountY;
    maxAmountIn = shlDiv(
      bin.amountY,
      bin.price,
      SCALE_OFFSET,
      0
      /* Up */
    );
  } else {
    maxAmountOut = bin.amountX;
    maxAmountIn = mulShr(
      bin.amountX,
      bin.price,
      SCALE_OFFSET,
      0
      /* Up */
    );
  }
  if (outAmount.gte(maxAmountOut)) {
    const maxFee = computeFee(binStep, sParameter, vParameter, maxAmountIn);
    const protocolFee = computeProtocolFee(maxFee, sParameter);
    return {
      amountIn: maxAmountIn,
      amountOut: maxAmountOut,
      fee: maxFee,
      protocolFee
    };
  } else {
    const amountIn = getAmountIn(outAmount, bin.price, swapForY);
    const fee = computeFee(binStep, sParameter, vParameter, amountIn);
    const protocolFee = computeProtocolFee(fee, sParameter);
    return {
      amountIn,
      amountOut: outAmount,
      fee,
      protocolFee
    };
  }
}
function swapExactInQuoteAtBin(bin, binStep, sParameter, vParameter, inAmount, swapForY) {
  if (swapForY && bin.amountY.isZero()) {
    return {
      amountIn: new import_anchor10.BN(0),
      amountOut: new import_anchor10.BN(0),
      fee: new import_anchor10.BN(0),
      protocolFee: new import_anchor10.BN(0)
    };
  }
  if (!swapForY && bin.amountX.isZero()) {
    return {
      amountIn: new import_anchor10.BN(0),
      amountOut: new import_anchor10.BN(0),
      fee: new import_anchor10.BN(0),
      protocolFee: new import_anchor10.BN(0)
    };
  }
  let maxAmountOut;
  let maxAmountIn;
  if (swapForY) {
    maxAmountOut = bin.amountY;
    maxAmountIn = shlDiv(
      bin.amountY,
      bin.price,
      SCALE_OFFSET,
      0
      /* Up */
    );
  } else {
    maxAmountOut = bin.amountX;
    maxAmountIn = mulShr(
      bin.amountX,
      bin.price,
      SCALE_OFFSET,
      0
      /* Up */
    );
  }
  const maxFee = computeFee(binStep, sParameter, vParameter, maxAmountIn);
  maxAmountIn = maxAmountIn.add(maxFee);
  let amountInWithFees;
  let amountOut;
  let fee;
  let protocolFee;
  if (inAmount.gt(maxAmountIn)) {
    amountInWithFees = maxAmountIn;
    amountOut = maxAmountOut;
    fee = maxFee;
    protocolFee = computeProtocolFee(maxFee, sParameter);
  } else {
    fee = computeFeeFromAmount(binStep, sParameter, vParameter, inAmount);
    const amountInAfterFee = inAmount.sub(fee);
    const computedOutAmount = getOutAmount(bin, amountInAfterFee, swapForY);
    amountOut = computedOutAmount.gt(maxAmountOut) ? maxAmountOut : computedOutAmount;
    protocolFee = computeProtocolFee(fee, sParameter);
    amountInWithFees = inAmount;
  }
  return {
    amountIn: amountInWithFees,
    amountOut,
    fee,
    protocolFee
  };
}
function getAmountIn(amountOut, price, swapForY) {
  if (swapForY) {
    return shlDiv(
      amountOut,
      price,
      SCALE_OFFSET,
      0
      /* Up */
    );
  } else {
    return mulShr(
      amountOut,
      price,
      SCALE_OFFSET,
      0
      /* Up */
    );
  }
}
function buildBitFlagAndNegateStrategyParameters(x0, y0, deltaX, deltaY) {
  let bitFlag = 0;
  if (x0.isNeg()) {
    bitFlag |= 1;
    x0 = x0.neg();
  }
  if (y0.isNeg()) {
    bitFlag |= 2;
    y0 = y0.neg();
  }
  if (deltaX.isNeg()) {
    bitFlag |= 4;
    deltaX = deltaX.neg();
  }
  if (deltaY.isNeg()) {
    bitFlag |= 8;
    deltaY = deltaY.neg();
  }
  return {
    bitFlag,
    x0,
    y0,
    deltaX,
    deltaY
  };
}
function toRebalancePositionBinData(positionData) {
  return positionData.positionBinData.map(
    ({
      binId,
      price,
      pricePerToken,
      positionXAmount,
      positionYAmount,
      positionFeeXAmount,
      positionFeeYAmount,
      positionRewardAmount
    }) => {
      return {
        binId,
        price,
        pricePerToken,
        amountX: new import_bn5.default(positionXAmount),
        amountY: new import_bn5.default(positionYAmount),
        claimableRewardAmount: positionRewardAmount.map(
          (amount) => new import_bn5.default(amount)
        ),
        claimableFeeXAmount: new import_bn5.default(positionFeeXAmount),
        claimableFeeYAmount: new import_bn5.default(positionFeeYAmount)
      };
    }
  );
}
function getDepositBinIds(activeId, deposits) {
  const uniqueBinId = /* @__PURE__ */ new Set();
  for (const { minDeltaId, maxDeltaId } of deposits) {
    const minBinId = activeId.add(minDeltaId);
    const maxBinId = activeId.add(maxDeltaId);
    for (let binId = minBinId.toNumber(); binId <= maxBinId.toNumber(); binId++) {
      uniqueBinId.add(binId);
    }
  }
  const binIds = Array.from(uniqueBinId);
  binIds.sort((a, b) => a - b);
  return binIds;
}
function findMinMaxBinIdWithLiquidity(rebalancePositionBinData) {
  let minBinId = null;
  let maxBinId = null;
  for (const binData of rebalancePositionBinData) {
    if (binData.amountX.isZero() && binData.amountY.isZero() && binData.claimableFeeXAmount.isZero() && binData.claimableFeeYAmount.isZero() && binData.claimableRewardAmount.every((amount) => amount.isZero())) {
      continue;
    }
    if (minBinId == null || binData.binId < minBinId) {
      minBinId = binData.binId;
    }
    if (maxBinId == null || binData.binId > maxBinId) {
      maxBinId = binData.binId;
    }
  }
  return [minBinId, maxBinId];
}
function onlyDepositToBidSide(maxDeltaId, favorXInActiveBin) {
  if (favorXInActiveBin) {
    return maxDeltaId.lt(new import_bn5.default(0));
  }
  return maxDeltaId.lte(new import_bn5.default(0));
}
function onlyDepositToAskSide(minDeltaId, favorXInActiveBin) {
  if (favorXInActiveBin) {
    return minDeltaId.gte(new import_bn5.default(0));
  }
  return minDeltaId.gt(new import_bn5.default(0));
}
function getAmountInBinsBidSide(activeId, minDeltaId, maxDeltaId, deltaY, y0) {
  const amountInBins = [];
  const minBinId = activeId.add(minDeltaId);
  const maxBinId = activeId.add(maxDeltaId);
  for (let binId = minBinId.toNumber(); binId <= maxBinId.toNumber(); binId++) {
    const deltaBin = activeId.toNumber() - binId;
    const totalDeltaY = deltaY.mul(new import_bn5.default(deltaBin));
    const amountY = y0.add(totalDeltaY);
    amountInBins.push({
      binId: new import_bn5.default(binId),
      amountX: new import_bn5.default(0),
      amountY
    });
  }
  return amountInBins;
}
function getAmountInBinsAskSide(activeId, binStep, minDeltaId, maxDeltaId, deltaX, x0) {
  const binCount = maxDeltaId.sub(minDeltaId).add(new import_bn5.default(1));
  const minBinId = activeId.add(minDeltaId);
  const maxBinId = activeId.add(maxDeltaId);
  const amountInBins = new Array(binCount.toNumber());
  const base = getQPriceBaseFactor(binStep);
  let inverseBasePrice = pow2(base, maxBinId.neg());
  for (let binId = maxBinId.toNumber(); binId >= minBinId.toNumber(); binId--) {
    const delta = binId - activeId.toNumber();
    const totalDeltaX = deltaX.mul(new import_bn5.default(delta));
    const amountX = x0.add(totalDeltaX).mul(inverseBasePrice).shrn(SCALE_OFFSET);
    const idx = binId - minBinId.toNumber();
    amountInBins[idx] = {
      binId: new import_bn5.default(binId),
      amountX,
      amountY: new import_bn5.default(0)
    };
    inverseBasePrice = inverseBasePrice.mul(base).shrn(SCALE_OFFSET);
  }
  return amountInBins;
}
function toAmountIntoBins(activeId, minDeltaId, maxDeltaId, deltaX, deltaY, x0, y0, binStep, favorXInActiveBin) {
  if (onlyDepositToBidSide(maxDeltaId, favorXInActiveBin)) {
    return getAmountInBinsBidSide(activeId, minDeltaId, maxDeltaId, deltaY, y0);
  }
  if (onlyDepositToAskSide(minDeltaId, favorXInActiveBin)) {
    return getAmountInBinsAskSide(
      activeId,
      binStep,
      minDeltaId,
      maxDeltaId,
      deltaX,
      x0
    );
  }
  const [bidSideEndDeltaId, askSideStartDeltaId] = favorXInActiveBin ? [-1, 0] : [0, 1];
  const amountInBinsBidSide = getAmountInBinsBidSide(
    activeId,
    minDeltaId,
    new import_bn5.default(bidSideEndDeltaId),
    deltaY,
    y0
  );
  const amountInBinsAskSide = getAmountInBinsAskSide(
    activeId,
    binStep,
    new import_bn5.default(askSideStartDeltaId),
    maxDeltaId,
    deltaX,
    x0
  );
  return amountInBinsBidSide.concat(amountInBinsAskSide);
}
function getLiquidity(x, y, price) {
  const px = price.mul(x);
  const shly = y.shln(SCALE_OFFSET);
  return px.add(shly);
}
function computeCompositionFee(binStep, sParameters3, vParameters3, outAmountX, inAmountX, outAmountY, inAmountY) {
  if (outAmountX.gt(inAmountX)) {
    const delta = inAmountY.sub(outAmountY);
    const totalFeeRate = getTotalFee(
      binStep.toNumber(),
      sParameters3,
      vParameters3
    );
    const feeAmount = delta.mul(totalFeeRate);
    return feeAmount.mul(FEE_PRECISION.add(totalFeeRate)).div(FEE_PRECISION.pow(new import_bn5.default(2)));
  }
  return new import_bn5.default(0);
}
function simulateDepositBin(binId, binStep, amountX, amountY, bin) {
  if (!bin) {
    return {
      amountXIntoBin: amountX,
      amountYIntoBin: amountY
    };
  }
  const price = getQPriceFromId(binId, binStep);
  const inLiquidity = getLiquidity(amountX, amountY, price);
  const binLiquidity = getLiquidity(bin.amountX, bin.amountY, price);
  if (bin.liquiditySupply.isZero()) {
    return {
      amountXIntoBin: amountX,
      amountYIntoBin: amountY
    };
  }
  const liquidityShare = inLiquidity.mul(bin.liquiditySupply).div(binLiquidity);
  const updatedBinXAmount = bin.amountX.add(amountX);
  const updatedBinYAmount = bin.amountY.add(amountY);
  const updatedBinSupply = bin.liquiditySupply.add(liquidityShare);
  let amountXIntoBin = liquidityShare.mul(
    updatedBinXAmount.div(updatedBinSupply)
  );
  let amountYIntoBin = liquidityShare.mul(
    updatedBinYAmount.div(updatedBinSupply)
  );
  if (amountXIntoBin.gt(amountX)) {
  }
  return {
    amountXIntoBin,
    amountYIntoBin
  };
}
var RebalancePosition = class {
  address;
  lowerBinId;
  upperBinId;
  lbPair;
  owner;
  shouldClaimFee;
  shouldClaimReward;
  rebalancePositionBinData;
  activeBin;
  currentTimestamp;
  constructor(positionAddress, positionData, lbPair, activeBin, shouldClaimFee, shouldClaimReward, currentTimestamp) {
    this.address = positionAddress;
    this.rebalancePositionBinData = toRebalancePositionBinData(positionData);
    this.lowerBinId = new import_bn5.default(positionData.lowerBinId);
    this.upperBinId = new import_bn5.default(positionData.upperBinId);
    this.lbPair = lbPair;
    this.shouldClaimFee = shouldClaimFee;
    this.shouldClaimReward = shouldClaimReward;
    this.owner = positionData.owner;
    this.activeBin = activeBin;
    this.currentTimestamp = currentTimestamp;
  }
  static async create(params) {
    const {
      program,
      positionAddress,
      pairAddress,
      positionData,
      shouldClaimFee,
      shouldClaimReward
    } = params;
    const [lbPairAccount, clockAccount] = await program.provider.connection.getMultipleAccountsInfo([
      pairAddress,
      import_web319.SYSVAR_CLOCK_PUBKEY
    ]);
    const lbPair = decodeAccount(program, "lbPair", lbPairAccount.data);
    const clock = ClockLayout.decode(clockAccount.data);
    const activeBinArrayIdx = binIdToBinArrayIndex(new import_bn5.default(lbPair.activeId));
    const [activeBinArrayPubkey] = deriveBinArray(
      pairAddress,
      activeBinArrayIdx,
      program.programId
    );
    const [lowerBinId, upperBinId] = getBinArrayLowerUpperBinId(activeBinArrayIdx);
    const idx = getBinIdIndexInBinArray(
      new import_bn5.default(lbPair.activeId),
      lowerBinId,
      upperBinId
    );
    let activeBin = null;
    try {
      const activeBinArrayState = await program.account.binArray.fetch(
        activeBinArrayPubkey
      );
      activeBin = activeBinArrayState[idx.toNumber()];
    } catch (error) {
    }
    return new RebalancePosition(
      positionAddress,
      positionData,
      lbPair,
      activeBin,
      shouldClaimFee,
      shouldClaimReward,
      clock.unixTimestamp
    );
  }
  _simulateDeposit(binStep, tokenXDecimal, tokenYDecimal, deposits, simulatedWithdrawResult) {
    const { liquidityAndFeeXWithdrawn, liquidityAndFeeYWithdrawn } = simulatedWithdrawResult;
    const activeId = new import_bn5.default(this.lbPair.activeId);
    const depositBinIds = getDepositBinIds(activeId, deposits);
    if (depositBinIds.length > 0) {
      const depositMinBinId = depositBinIds[0];
      const depositMaxBinId = depositBinIds[depositBinIds.length - 1];
      this._simulateResize(
        new import_bn5.default(depositMinBinId),
        new import_bn5.default(depositMaxBinId),
        binStep,
        tokenXDecimal,
        tokenYDecimal
      );
    }
    let totalAmountXDeposited = new import_bn5.default(0);
    let totalAmountYDeposited = new import_bn5.default(0);
    const addLiquidityParam = [];
    for (const {
      x0,
      y0,
      favorXInActiveBin,
      deltaX,
      deltaY,
      minDeltaId,
      maxDeltaId
    } of deposits) {
      const params = buildBitFlagAndNegateStrategyParameters(
        x0,
        y0,
        deltaX,
        deltaY
      );
      addLiquidityParam.push({
        minDeltaId: minDeltaId.toNumber(),
        maxDeltaId: maxDeltaId.toNumber(),
        x0: params.x0,
        y0: params.y0,
        deltaX: params.deltaX,
        deltaY: params.deltaY,
        bitFlag: params.bitFlag,
        padding: Array(16).fill(0),
        favorXInActiveId: favorXInActiveBin
      });
      const amountIntoBins = toAmountIntoBins(
        activeId,
        minDeltaId,
        maxDeltaId,
        deltaX,
        deltaY,
        x0,
        y0,
        binStep,
        favorXInActiveBin
      );
      for (const { binId, amountX, amountY } of amountIntoBins) {
        totalAmountXDeposited = totalAmountXDeposited.add(amountX);
        totalAmountYDeposited = totalAmountYDeposited.add(amountY);
        const idx = this.rebalancePositionBinData.findIndex(
          (data) => data.binId == binId.toNumber()
        );
        if (binId.eq(activeId)) {
          const vParameters3 = Object.assign({}, this.lbPair.vParameters);
          const sParameters3 = Object.assign({}, this.lbPair.parameters);
          DLMM.updateReference(
            activeId.toNumber(),
            vParameters3,
            sParameters3,
            this.currentTimestamp.toNumber()
          );
          DLMM.updateVolatilityAccumulator(
            vParameters3,
            sParameters3,
            activeId.toNumber()
          );
          const { amountXIntoBin, amountYIntoBin } = simulateDepositBin(
            binId,
            binStep,
            amountX,
            amountY,
            this.activeBin
          );
          const feeY = computeCompositionFee(
            binStep,
            sParameters3,
            vParameters3,
            amountXIntoBin,
            amountX,
            amountYIntoBin,
            amountY
          );
          const feeX = computeCompositionFee(
            binStep,
            sParameters3,
            vParameters3,
            amountYIntoBin,
            amountY,
            amountXIntoBin,
            amountX
          );
          const amountXIntoBinExcludeFee = amountXIntoBin.sub(feeX);
          const amountYIntoBinExcludeFee = amountYIntoBin.sub(feeY);
          this.rebalancePositionBinData[idx].amountX = this.rebalancePositionBinData[idx].amountX.add(
            amountXIntoBinExcludeFee
          );
          this.rebalancePositionBinData[idx].amountY = this.rebalancePositionBinData[idx].amountY.add(
            amountYIntoBinExcludeFee
          );
        } else {
          this.rebalancePositionBinData[idx].amountX = this.rebalancePositionBinData[idx].amountX.add(amountX);
          this.rebalancePositionBinData[idx].amountY = this.rebalancePositionBinData[idx].amountY.add(amountY);
        }
      }
    }
    let actualTotalAmountXDeposited = totalAmountXDeposited;
    let actualTotalAmountYDeposited = totalAmountYDeposited;
    let actualLiquidityAndFeeXWithdrawn = liquidityAndFeeXWithdrawn;
    let actualLiquidityAndFeeYWithdrawn = liquidityAndFeeYWithdrawn;
    if (actualTotalAmountXDeposited.gt(actualLiquidityAndFeeXWithdrawn)) {
      actualTotalAmountXDeposited = actualTotalAmountXDeposited.sub(
        actualLiquidityAndFeeXWithdrawn
      );
      actualLiquidityAndFeeXWithdrawn = new import_bn5.default(0);
    } else {
      actualLiquidityAndFeeXWithdrawn = actualLiquidityAndFeeXWithdrawn.sub(
        actualTotalAmountXDeposited
      );
      actualTotalAmountXDeposited = new import_bn5.default(0);
    }
    if (actualTotalAmountYDeposited.gt(actualLiquidityAndFeeYWithdrawn)) {
      actualTotalAmountYDeposited = actualTotalAmountYDeposited.sub(
        actualLiquidityAndFeeYWithdrawn
      );
      actualLiquidityAndFeeYWithdrawn = new import_bn5.default(0);
    } else {
      actualLiquidityAndFeeYWithdrawn = actualLiquidityAndFeeYWithdrawn.sub(
        actualTotalAmountYDeposited
      );
      actualTotalAmountYDeposited = new import_bn5.default(0);
    }
    return {
      result: {
        totalAmountXDeposited,
        totalAmountYDeposited,
        actualLiquidityAndFeeXWithdrawn,
        actualLiquidityAndFeeYWithdrawn,
        actualTotalAmountXDeposited,
        actualTotalAmountYDeposited
      },
      depositParams: addLiquidityParam
    };
  }
  _simulateResize(depositMinBinId, depositMaxBinId, binStep, tokenXDecimal, tokenYDecimal) {
    const tokenXMultiplier = new decimal_default(10 ** tokenXDecimal.toNumber());
    const tokenYMultiplier = new decimal_default(10 ** tokenYDecimal.toNumber());
    const [minBinId, maxBinId] = findMinMaxBinIdWithLiquidity(
      this.rebalancePositionBinData
    );
    const newMinBinId = new import_bn5.default(
      Math.min(depositMinBinId.toNumber(), minBinId ?? Number.MAX_SAFE_INTEGER)
    );
    const newMaxBinId = new import_bn5.default(
      Math.max(depositMaxBinId.toNumber(), maxBinId ?? Number.MIN_SAFE_INTEGER)
    );
    if (newMinBinId.lt(this.lowerBinId)) {
      const binCountToExpand = this.lowerBinId.sub(depositMinBinId);
      for (let i = 1; i <= binCountToExpand.toNumber(); i++) {
        const binId = this.lowerBinId.subn(i);
        const price = getPriceOfBinByBinId(
          binId.toNumber(),
          binStep.toNumber()
        );
        const adjustedPrice = price.mul(tokenXMultiplier).div(tokenYMultiplier);
        this.rebalancePositionBinData.unshift({
          binId: binId.toNumber(),
          price: adjustedPrice.toString(),
          pricePerToken: adjustedPrice.toString(),
          amountX: new import_bn5.default(0),
          amountY: new import_bn5.default(0),
          claimableRewardAmount: [new import_bn5.default(0), new import_bn5.default(0)],
          claimableFeeXAmount: new import_bn5.default(0),
          claimableFeeYAmount: new import_bn5.default(0)
        });
      }
    } else {
      const binCountToShrink = newMinBinId.sub(this.lowerBinId);
      for (let i = 1; i <= binCountToShrink.toNumber(); i++) {
        this.rebalancePositionBinData.shift();
      }
    }
    if (newMaxBinId.gt(this.upperBinId)) {
      const binCountToExpand = newMaxBinId.sub(this.upperBinId);
      for (let i = 1; i <= binCountToExpand.toNumber(); i++) {
        const binId = this.upperBinId.addn(i);
        const price = getPriceOfBinByBinId(
          binId.toNumber(),
          binStep.toNumber()
        );
        const adjustedPrice = price.mul(tokenXMultiplier).div(tokenYMultiplier);
        this.rebalancePositionBinData.push({
          binId: binId.toNumber(),
          price: adjustedPrice.toString(),
          pricePerToken: adjustedPrice.toString(),
          amountX: new import_bn5.default(0),
          amountY: new import_bn5.default(0),
          claimableRewardAmount: [new import_bn5.default(0), new import_bn5.default(0)],
          claimableFeeXAmount: new import_bn5.default(0),
          claimableFeeYAmount: new import_bn5.default(0)
        });
      }
    } else {
      const binCountToShrink = this.upperBinId.sub(newMaxBinId);
      for (let i = 1; i <= binCountToShrink.toNumber(); i++) {
        this.rebalancePositionBinData.pop();
      }
    }
    this.lowerBinId = newMinBinId;
    this.upperBinId = newMaxBinId;
  }
  _simulateWithdraw(withdraws) {
    let liquidityAndFeeXWithdrawn = new import_bn5.default(0);
    let liquidityAndFeeYWithdrawn = new import_bn5.default(0);
    let rewardsAmountClaimed = [new import_bn5.default(0), new import_bn5.default(0)];
    const activeId = new import_bn5.default(this.lbPair.activeId);
    for (const { minBinId, maxBinId, bps } of withdraws) {
      const fromBinId = minBinId ?? activeId;
      const toBinId = maxBinId ?? activeId;
      const binIds = binRangeToBinIdArray(fromBinId, toBinId).filter(
        (binId) => binId.gte(this.lowerBinId) && binId.lte(this.upperBinId)
      );
      for (const binId of binIds) {
        const idx = this.rebalancePositionBinData.findIndex(
          (b) => b.binId === binId.toNumber()
        );
        const binData = this.rebalancePositionBinData[idx];
        const amountXWithdrawn = binData.amountX.mul(bps).divn(BASIS_POINT_MAX);
        const amountYWithdrawn = binData.amountY.mul(bps).divn(BASIS_POINT_MAX);
        liquidityAndFeeXWithdrawn = liquidityAndFeeXWithdrawn.add(amountXWithdrawn);
        liquidityAndFeeYWithdrawn = liquidityAndFeeYWithdrawn.add(amountYWithdrawn);
        binData.amountX = binData.amountX.sub(amountXWithdrawn);
        binData.amountY = binData.amountY.sub(amountYWithdrawn);
        if (this.shouldClaimFee) {
          liquidityAndFeeXWithdrawn = liquidityAndFeeXWithdrawn.add(
            binData.claimableFeeXAmount
          );
          liquidityAndFeeYWithdrawn = liquidityAndFeeYWithdrawn.add(
            binData.claimableFeeYAmount
          );
          binData.claimableFeeXAmount = new import_bn5.default(0);
          binData.claimableFeeYAmount = new import_bn5.default(0);
        }
        if (this.shouldClaimReward) {
          for (const [idx2, amount] of binData.claimableRewardAmount.entries()) {
            rewardsAmountClaimed[idx2] = rewardsAmountClaimed[idx2].add(amount);
            binData.claimableRewardAmount[idx2] = new import_bn5.default(0);
          }
        }
        this.rebalancePositionBinData[idx] = binData;
      }
    }
    const withdrawParams = withdraws.map(
      ({ minBinId, maxBinId, bps }) => {
        return {
          minBinId: minBinId ? minBinId.toNumber() : null,
          maxBinId: maxBinId ? maxBinId.toNumber() : null,
          bps: bps.toNumber(),
          padding: Array(16).fill(0)
        };
      }
    );
    return {
      result: {
        liquidityAndFeeXWithdrawn,
        liquidityAndFeeYWithdrawn,
        rewardsAmountClaimed
      },
      withdrawParams
    };
  }
  async simulateRebalance(connection, binStep, tokenXDecimal, tokenYDecimal, withdraws, deposits) {
    if (withdraws.length == 0 && deposits.length == 0) {
      throw "No rebalance action";
    }
    const activeId = new import_bn5.default(this.lbPair.activeId);
    withdraws = validateAndSortRebalanceWithdraw(withdraws, activeId);
    deposits = validateAndSortRebalanceDeposit(deposits);
    const beforeWidth = getPositionWidthWithMinWidth(
      this.lowerBinId.toNumber(),
      this.upperBinId.toNumber()
    );
    const { withdrawParams, result: withdrawResult } = this._simulateWithdraw(withdraws);
    const { depositParams, result: depositResult } = this._simulateDeposit(
      binStep,
      tokenXDecimal,
      tokenYDecimal,
      deposits,
      withdrawResult
    );
    const afterWidth = getPositionWidthWithMinWidth(
      this.lowerBinId.toNumber(),
      this.upperBinId.toNumber()
    );
    const widthDelta = afterWidth - beforeWidth;
    let rentalCostLamports = new import_bn5.default(0);
    if (widthDelta != 0) {
      const sizeChanges = Math.abs(widthDelta) * POSITION_BIN_DATA_SIZE;
      const [minimumLamports, rentExemptionLamports] = await Promise.all([
        connection.getMinimumBalanceForRentExemption(0),
        connection.getMinimumBalanceForRentExemption(sizeChanges)
      ]);
      const lamportChanges = new import_bn5.default(rentExemptionLamports).sub(
        new import_bn5.default(minimumLamports)
      );
      if (widthDelta > 0) {
        rentalCostLamports = rentalCostLamports.add(lamportChanges);
      } else {
        rentalCostLamports = rentalCostLamports.sub(lamportChanges);
      }
    }
    return {
      amountXDeposited: depositResult.totalAmountXDeposited,
      amountYDeposited: depositResult.totalAmountYDeposited,
      actualAmountXDeposited: depositResult.actualTotalAmountXDeposited,
      actualAmountYDeposited: depositResult.actualTotalAmountYDeposited,
      actualAmountXWithdrawn: depositResult.actualLiquidityAndFeeXWithdrawn,
      actualAmountYWithdrawn: depositResult.actualLiquidityAndFeeYWithdrawn,
      rewardAmountsClaimed: withdrawResult.rewardsAmountClaimed,
      withdrawParams,
      depositParams,
      rentalCostLamports
    };
  }
  totalAmounts() {
    let totalAmountX = new import_bn5.default(0);
    let totalAmountY = new import_bn5.default(0);
    for (const binData of this.rebalancePositionBinData) {
      totalAmountX = totalAmountX.add(binData.amountX);
      totalAmountY = totalAmountY.add(binData.amountY);
    }
    return [totalAmountX, totalAmountY];
  }
  totalFeeAmounts() {
    let totalFeeXAmount = new import_bn5.default(0);
    let totalFeeYAmount = new import_bn5.default(0);
    for (const binData of this.rebalancePositionBinData) {
      totalFeeXAmount = totalFeeXAmount.add(binData.claimableFeeXAmount);
      totalFeeYAmount = totalFeeYAmount.add(binData.claimableFeeYAmount);
    }
    return [totalFeeXAmount, totalFeeYAmount];
  }
  totalRewardAmounts() {
    let totalRewardAmounts = [new import_bn5.default(0), new import_bn5.default(0)];
    for (const binData of this.rebalancePositionBinData) {
      totalRewardAmounts[0] = totalRewardAmounts[0].add(
        binData.claimableRewardAmount[0]
      );
      totalRewardAmounts[1] = totalRewardAmounts[1].add(
        binData.claimableRewardAmount[1]
      );
    }
    return totalRewardAmounts;
  }
};
function getPositionWidthWithMinWidth(lowerBinId, upperBinId) {
  const width = upperBinId - lowerBinId + 1;
  return Math.max(width, DEFAULT_BIN_PER_POSITION.toNumber());
}
function validateAndSortRebalanceDeposit(deposits) {
  const sortedDeposits = deposits.sort(
    (a, b) => a.minDeltaId.sub(b.minDeltaId).toNumber()
  );
  for (const deposit of deposits) {
    if (deposit.minDeltaId.gte(deposit.maxDeltaId)) {
      throw "Invalid minDeltaId or maxDeltaId";
    }
  }
  for (let i = 1; i < sortedDeposits.length; i++) {
    const prevDeposit = sortedDeposits[i - 1];
    const currDeposit = sortedDeposits[i];
    if (prevDeposit.maxDeltaId.gte(currDeposit.minDeltaId)) {
      throw "Overlap deposit bin range";
    }
  }
  return sortedDeposits;
}
function validateAndSortRebalanceWithdraw(withdraws, activeId) {
  const filledWithdraws = [];
  for (const { minBinId, maxBinId, bps } of withdraws) {
    if (bps.toNumber() < 0 || bps.toNumber() > BASIS_POINT_MAX) {
      throw "Invalid bps";
    }
    const filledMinBinId = minBinId ?? activeId;
    const filledMaxBinId = maxBinId ?? activeId;
    if (filledMinBinId.gt(filledMaxBinId)) {
      throw "Invalid minBinId or maxBinId";
    }
    filledWithdraws.push({
      minBinId: filledMinBinId,
      maxBinId: filledMaxBinId,
      bps
    });
  }
  filledWithdraws.sort((a, b) => {
    return a.minBinId.sub(b.minBinId).toNumber();
  });
  for (let i = 1; i < filledWithdraws.length; i++) {
    const prev = filledWithdraws[i - 1];
    const curr = filledWithdraws[i];
    if (curr.minBinId.lte(prev.maxBinId)) {
      throw "Overlap withdraw bin range";
    }
  }
  return filledWithdraws;
}
function binRangeToBinIdArray(minBinId, maxBinId) {
  const binIdArray = [];
  const fromBinId = minBinId.toNumber();
  const toBinId = maxBinId.toNumber();
  for (let binId = fromBinId; binId <= toBinId; binId++) {
    binIdArray.push(new import_bn5.default(binId));
  }
  return binIdArray;
}
function getRebalanceBinArrayIndexesAndBitmapCoverage(adds, removes, activeId, pairAddress, programId) {
  let indexMap = /* @__PURE__ */ new Map();
  removes.forEach((value) => {
    let minBinId = value.minBinId;
    if (minBinId == null) {
      minBinId = activeId;
    }
    let maxBinId = value.maxBinId;
    if (maxBinId == null) {
      maxBinId = activeId;
    }
    let binArrayIndex = binIdToBinArrayIndex(new import_bn5.default(minBinId));
    const upperBinId = new import_bn5.default(maxBinId);
    while (true) {
      indexMap.set(binArrayIndex.toNumber(), true);
      const [binArrayLowerBinId, binArrayUpperBinId] = getBinArrayLowerUpperBinId(binArrayIndex);
      if (upperBinId.gte(binArrayLowerBinId) && upperBinId.lte(binArrayUpperBinId)) {
        break;
      } else {
        binArrayIndex = binArrayIndex.add(new import_bn5.default(1));
      }
    }
  });
  adds.forEach((value) => {
    const minBinId = activeId + value.minDeltaId;
    const maxBinId = activeId + value.maxDeltaId;
    let binArrayIndex = binIdToBinArrayIndex(new import_bn5.default(minBinId));
    const upperBinId = new import_bn5.default(maxBinId);
    while (true) {
      indexMap.set(binArrayIndex.toNumber(), true);
      const [binArrayLowerBinId, binArrayUpperBinId] = getBinArrayLowerUpperBinId(binArrayIndex);
      if (upperBinId.gte(binArrayLowerBinId) && upperBinId.lte(binArrayUpperBinId)) {
        break;
      } else {
        binArrayIndex = binArrayIndex.add(new import_bn5.default(1));
      }
    }
  });
  const binArrayIndexes = Array.from(indexMap.keys()).map((idx) => new import_bn5.default(idx));
  const requireBitmapExtension = binArrayIndexes.some(
    (index) => isOverflowDefaultBinArrayBitmap(new import_bn5.default(index))
  );
  return {
    binArrayIndexes,
    binArrayBitmap: requireBitmapExtension ? deriveBinArrayBitmapExtension(pairAddress, programId)[0] : programId
  };
}
function findBaseDeltaY(amountY, minDeltaId, maxDeltaId) {
  if (minDeltaId.gt(maxDeltaId) || amountY.lte(new import_bn7.default(0))) {
    return new import_bn7.default(0);
  }
  if (minDeltaId.eq(maxDeltaId)) {
    return amountY;
  }
  const m1 = minDeltaId.neg();
  const m2 = maxDeltaId.neg();
  const b = m2.neg().addn(1).mul(m1.sub(m2).addn(1));
  const c = m1.mul(m1.addn(1)).divn(2);
  const d = m2.mul(m2.subn(1)).divn(2);
  const a = b.add(c.sub(d));
  return amountY.div(a);
}
function findY0AndDeltaY(amountY, minDeltaId, maxDeltaId, activeId) {
  if (minDeltaId.gt(maxDeltaId) || amountY.isZero()) {
    return {
      base: new import_bn7.default(0),
      delta: new import_bn7.default(0)
    };
  }
  let baseDeltaY = findBaseDeltaY(amountY, minDeltaId, maxDeltaId);
  const y0 = baseDeltaY.neg().mul(maxDeltaId.neg().subn(1));
  while (true) {
    const amountInBins = getAmountInBinsBidSide(
      activeId,
      minDeltaId,
      maxDeltaId,
      baseDeltaY,
      y0
    );
    const totalAmountY = amountInBins.reduce((acc, { amountY: amountY2 }) => {
      return acc.add(amountY2);
    }, new import_bn7.default(0));
    if (totalAmountY.gt(amountY)) {
      baseDeltaY = baseDeltaY.sub(new import_bn7.default(1));
    } else {
      return {
        base: y0,
        delta: baseDeltaY
      };
    }
  }
}
function findBaseDeltaX(amountX, minDeltaId, maxDeltaId, binStep, activeId) {
  if (minDeltaId.gt(maxDeltaId) || amountX.lte(new import_bn7.default(0))) {
    return new import_bn7.default(0);
  }
  let b = new import_bn7.default(0);
  let c = new import_bn7.default(0);
  let m1 = minDeltaId;
  let m2 = maxDeltaId.addn(1);
  for (let m = m1.toNumber(); m <= m2.toNumber(); m++) {
    const binId = activeId.addn(m);
    const pm = getQPriceFromId(binId.neg(), binStep);
    const bDelta = m1.mul(pm);
    b = b.add(bDelta);
    const cDelta = new import_bn7.default(m).mul(pm);
    c = c.add(cDelta);
  }
  return amountX.shln(SCALE_OFFSET).div(c.sub(b));
}
function findX0AndDeltaX(amountX, minDeltaId, maxDeltaId, binStep, activeId) {
  if (minDeltaId.gt(maxDeltaId) || amountX.lte(new import_bn7.default(0)) || amountX.isZero()) {
    return {
      base: new import_bn7.default(0),
      delta: new import_bn7.default(0)
    };
  }
  let baseDeltaX = findBaseDeltaX(
    amountX,
    minDeltaId,
    maxDeltaId,
    binStep,
    activeId
  );
  const x0 = minDeltaId.neg().mul(baseDeltaX).add(baseDeltaX);
  while (true) {
    const amountInBins = getAmountInBinsAskSide(
      activeId,
      binStep,
      minDeltaId,
      maxDeltaId,
      baseDeltaX,
      x0
    );
    const totalAmountX = amountInBins.reduce((acc, { amountX: amountX2 }) => {
      return acc.add(amountX2);
    }, new import_bn7.default(0));
    if (totalAmountX.gt(amountX)) {
      baseDeltaX = baseDeltaX.sub(new import_bn7.default(1));
    } else {
      return {
        base: x0,
        delta: baseDeltaX
      };
    }
  }
}
var BidAskStrategyParameterBuilder = class {
  findXParameters(amountX, minDeltaId, maxDeltaId, binStep, activeId) {
    return findX0AndDeltaX(amountX, minDeltaId, maxDeltaId, binStep, activeId);
  }
  findYParameters(amountY, minDeltaId, maxDeltaId, activeId) {
    return findY0AndDeltaY(amountY, minDeltaId, maxDeltaId, activeId);
  }
  suggestBalancedXParametersFromY(activeId, binStep, favorXInActiveBin, minDeltaId, maxDeltaId, amountY) {
    const deltaX = amountY.div(
      maxDeltaId.addn(1).mul(maxDeltaId.addn(2)).divn(2)
    );
    const x0 = minDeltaId.neg().mul(deltaX).add(deltaX);
    const totalAmountX = toAmountIntoBins(
      activeId,
      minDeltaId,
      maxDeltaId,
      deltaX,
      new import_bn7.default(0),
      x0,
      new import_bn7.default(0),
      binStep,
      favorXInActiveBin
    ).reduce((acc, bin) => {
      return acc.add(bin.amountX);
    }, new import_bn7.default(0));
    return {
      base: x0,
      delta: deltaX,
      amountX: totalAmountX
    };
  }
  suggestBalancedYParametersFromX(activeId, binStep, favorXInActiveBin, minDeltaId, maxDeltaId, amountXInQuoteValue) {
    const m1 = minDeltaId.neg().subn(1);
    const m2 = maxDeltaId.neg();
    const a1 = m2.neg().mul(m1.sub(m2).addn(1));
    const a2 = m1.mul(m1.addn(1)).divn(2);
    const a3 = m2.mul(m2.subn(1)).divn(2);
    const a = a1.add(a2.sub(a3));
    const deltaY = amountXInQuoteValue.div(a);
    const y0 = deltaY.neg().mul(m2).add(deltaY);
    const amountY = toAmountIntoBins(
      activeId,
      minDeltaId,
      maxDeltaId,
      new import_bn7.default(0),
      deltaY,
      new import_bn7.default(0),
      y0,
      binStep,
      favorXInActiveBin
    ).reduce((acc, bin) => {
      return acc.add(bin.amountY);
    }, new import_bn7.default(0));
    return {
      base: y0,
      delta: deltaY,
      amountY
    };
  }
};
function findBaseY0(amountY, minDeltaId, maxDeltaId) {
  if (minDeltaId.gt(maxDeltaId) || amountY.lte(new import_bn8.default(0))) {
    return new import_bn8.default(0);
  }
  if (minDeltaId.eq(maxDeltaId)) {
    return amountY;
  }
  const m1 = minDeltaId.neg();
  const m2 = maxDeltaId.neg();
  const b = m1.sub(m2).addn(1);
  const c = m1.mul(m1.addn(1)).divn(2);
  const d = m2.mul(m2.subn(1)).divn(2);
  const a = b.sub(c.sub(d).div(m1.addn(1)));
  return amountY.div(a);
}
function findY0AndDeltaY2(amountY, minDeltaId, maxDeltaId, activeId) {
  if (minDeltaId.gt(maxDeltaId) || amountY.isZero()) {
    return {
      base: new import_bn8.default(0),
      delta: new import_bn8.default(0)
    };
  }
  let baseY0 = findBaseY0(amountY, minDeltaId, maxDeltaId);
  while (true) {
    const deltaY = baseY0.neg().div(minDeltaId.neg().addn(1));
    const amountInBins = getAmountInBinsBidSide(
      activeId,
      minDeltaId,
      maxDeltaId,
      deltaY,
      baseY0
    );
    const totalAmountY = amountInBins.reduce((acc, { amountY: amountY2 }) => {
      return acc.add(amountY2);
    }, new import_bn8.default(0));
    if (totalAmountY.gt(amountY)) {
      baseY0 = baseY0.sub(new import_bn8.default(1));
    } else {
      return {
        base: baseY0,
        delta: deltaY
      };
    }
  }
}
function findBaseX0(amountX, minDeltaId, maxDeltaId, binStep, activeId) {
  if (minDeltaId.gt(maxDeltaId) || amountX.lte(new import_bn8.default(0))) {
    return new import_bn8.default(0);
  }
  let b = new import_bn8.default(0);
  let c = new import_bn8.default(0);
  let m1 = minDeltaId;
  let m2 = maxDeltaId;
  for (let m = m1.toNumber(); m <= m2.toNumber(); m++) {
    const binId = activeId.addn(m);
    const pm = getQPriceFromId(binId.neg(), binStep);
    b = b.add(pm);
    const cDelta = new import_bn8.default(m).mul(pm).div(m2);
    c = c.add(cDelta);
  }
  return amountX.shln(SCALE_OFFSET).div(b.sub(c));
}
function findX0AndDeltaX2(amountX, minDeltaId, maxDeltaId, binStep, activeId) {
  if (minDeltaId.gt(maxDeltaId) || amountX.lte(new import_bn8.default(0)) || amountX.isZero()) {
    return {
      base: new import_bn8.default(0),
      delta: new import_bn8.default(0)
    };
  }
  let baseX0 = findBaseX0(amountX, minDeltaId, maxDeltaId, binStep, activeId);
  const deltaX = baseX0.neg().div(maxDeltaId);
  while (true) {
    const amountInBins = getAmountInBinsAskSide(
      activeId,
      binStep,
      minDeltaId,
      maxDeltaId,
      deltaX,
      baseX0
    );
    const totalAmountX = amountInBins.reduce((acc, { amountX: amountX2 }) => {
      return acc.add(amountX2);
    }, new import_bn8.default(0));
    if (totalAmountX.gt(amountX)) {
      baseX0 = baseX0.sub(new import_bn8.default(1));
    } else {
      return {
        base: baseX0,
        delta: deltaX
      };
    }
  }
}
var CurveStrategyParameterBuilder = class {
  findXParameters(amountX, minDeltaId, maxDeltaId, binStep, activeId) {
    return findX0AndDeltaX2(amountX, minDeltaId, maxDeltaId, binStep, activeId);
  }
  findYParameters(amountY, minDeltaId, maxDeltaId, activeId) {
    return findY0AndDeltaY2(amountY, minDeltaId, maxDeltaId, activeId);
  }
  suggestBalancedXParametersFromY(activeId, binStep, favorXInActiveBin, minDeltaId, maxDeltaId, amountY) {
    const x0 = amountY.muln(2).div(maxDeltaId.addn(1));
    const deltaX = x0.neg().div(maxDeltaId);
    const totalAmountX = toAmountIntoBins(
      activeId,
      minDeltaId,
      maxDeltaId,
      deltaX,
      new import_bn8.default(0),
      x0,
      new import_bn8.default(0),
      binStep,
      favorXInActiveBin
    ).reduce((acc, bin) => {
      return acc.add(bin.amountX);
    }, new import_bn8.default(0));
    return {
      base: x0,
      delta: deltaX,
      amountX: totalAmountX
    };
  }
  suggestBalancedYParametersFromX(activeId, binStep, favorXInActiveBin, minDeltaId, maxDeltaId, amountXInQuoteValue) {
    const m1 = minDeltaId.neg();
    const m2 = maxDeltaId.neg();
    const a1 = m1.sub(m2).addn(1);
    const a2 = m1.mul(m1.addn(1)).divn(2);
    const a3 = m2.mul(m2.subn(1)).divn(2);
    const a = m1.sub(a3.sub(a2)).div(m1);
    const y0 = amountXInQuoteValue.div(a);
    const deltaY = y0.neg().div(m1);
    const amountY = toAmountIntoBins(
      activeId,
      minDeltaId,
      maxDeltaId,
      new import_bn8.default(0),
      deltaY,
      new import_bn8.default(0),
      y0,
      binStep,
      favorXInActiveBin
    ).reduce((acc, bin) => {
      return acc.add(bin.amountY);
    }, new import_bn8.default(0));
    return {
      base: y0,
      delta: deltaY,
      amountY
    };
  }
};
function findY0(amountY, minDeltaId, maxDeltaId) {
  if (minDeltaId.gt(maxDeltaId) || amountY.lte(new import_bn9.default(0)) || amountY.isZero()) {
    return new import_bn9.default(0);
  }
  const m1 = minDeltaId.neg();
  const m2 = maxDeltaId.neg();
  const delta = m1.sub(m2).addn(1);
  return amountY.div(delta);
}
function findBaseX02(amountX, minDeltaId, maxDeltaId, binStep, activeId) {
  let totalWeight = new import_bn9.default(0);
  const minBinId = activeId.add(minDeltaId);
  const maxBinId = activeId.add(maxDeltaId);
  let baseFactor = getQPriceBaseFactor(binStep);
  let basePrice = getQPriceFromId(maxBinId.neg(), binStep);
  for (let binId = minBinId.toNumber(); binId <= maxBinId.toNumber(); binId++) {
    totalWeight = totalWeight.add(basePrice);
    basePrice = basePrice.mul(baseFactor).shrn(SCALE_OFFSET);
  }
  return amountX.shln(SCALE_OFFSET).div(totalWeight);
}
function findX0(amountX, minDeltaId, maxDeltaId, binStep, activeId) {
  if (minDeltaId.gt(maxDeltaId) || amountX.lte(new import_bn9.default(0)) || amountX.isZero()) {
    return new import_bn9.default(0);
  }
  let x0 = findBaseX02(amountX, minDeltaId, maxDeltaId, binStep, activeId);
  while (true) {
    const amountInBins = getAmountInBinsAskSide(
      activeId,
      binStep,
      minDeltaId,
      maxDeltaId,
      new import_bn9.default(0),
      x0
    );
    const totalAmountX = amountInBins.reduce((acc, bin) => {
      return acc.add(bin.amountX);
    }, new import_bn9.default(0));
    if (totalAmountX.lt(amountX)) {
      x0 = x0.add(new import_bn9.default(1));
    } else {
      x0 = x0.sub(new import_bn9.default(1));
      return x0;
    }
  }
}
var SpotStrategyParameterBuilder = class {
  findXParameters(amountX, minDeltaId, maxDeltaId, binStep, activeId) {
    return {
      base: findX0(amountX, minDeltaId, maxDeltaId, binStep, activeId),
      delta: new import_bn9.default(0)
    };
  }
  findYParameters(amountY, minDeltaId, maxDeltaId, _activeId) {
    return {
      base: findY0(amountY, minDeltaId, maxDeltaId),
      delta: new import_bn9.default(0)
    };
  }
  suggestBalancedXParametersFromY(activeId, binStep, favorXInActiveBin, minDeltaId, maxDeltaId, amountY) {
    const x0 = amountY.div(maxDeltaId.addn(1));
    const totalAmountX = toAmountIntoBins(
      activeId,
      minDeltaId,
      maxDeltaId,
      new import_bn9.default(0),
      new import_bn9.default(0),
      x0,
      new import_bn9.default(0),
      binStep,
      favorXInActiveBin
    ).reduce((acc, bin) => {
      return acc.add(bin.amountX);
    }, new import_bn9.default(0));
    return {
      base: new import_bn9.default(x0.toString()),
      delta: new import_bn9.default(0),
      amountX: totalAmountX
    };
  }
  suggestBalancedYParametersFromX(activeId, binStep, favorXInActiveBin, minDeltaId, maxDeltaId, amountXInQuoteValue) {
    const y0 = amountXInQuoteValue.div(maxDeltaId.sub(minDeltaId).addn(1));
    const amountY = toAmountIntoBins(
      activeId,
      minDeltaId,
      maxDeltaId,
      new import_bn9.default(0),
      new import_bn9.default(0),
      new import_bn9.default(0),
      y0,
      binStep,
      favorXInActiveBin
    ).reduce((acc, bin) => {
      return acc.add(bin.amountY);
    }, new import_bn9.default(0));
    return {
      base: y0,
      delta: new import_bn9.default(0),
      amountY
    };
  }
};
function getLiquidityStrategyParameterBuilder(strategyType) {
  switch (strategyType) {
    case 0:
      return new SpotStrategyParameterBuilder();
    case 1:
      return new CurveStrategyParameterBuilder();
    case 2:
      return new BidAskStrategyParameterBuilder();
    default:
      throw new Error("Strategy not supported");
  }
}
function buildLiquidityStrategyParameters(amountX, amountY, minDeltaId, maxDeltaId, binStep, favorXInActiveId, activeId, strategyParameterBuilder) {
  if (minDeltaId.gt(maxDeltaId)) {
    return {
      x0: new import_bn6.default(0),
      y0: new import_bn6.default(0),
      deltaX: new import_bn6.default(0),
      deltaY: new import_bn6.default(0)
    };
  }
  const depositOnlyY = maxDeltaId.lt(new import_bn6.default(0)) || maxDeltaId.isZero() && !favorXInActiveId;
  const depositOnlyX = minDeltaId.gt(new import_bn6.default(0)) || minDeltaId.isZero() && favorXInActiveId;
  if (depositOnlyY) {
    const { base, delta } = strategyParameterBuilder.findYParameters(
      amountY,
      minDeltaId,
      maxDeltaId,
      activeId
    );
    return {
      x0: new import_bn6.default(0),
      deltaX: new import_bn6.default(0),
      y0: base,
      deltaY: delta
    };
  }
  if (depositOnlyX) {
    const { base, delta } = strategyParameterBuilder.findXParameters(
      amountX,
      minDeltaId,
      maxDeltaId,
      binStep,
      activeId
    );
    return {
      x0: base,
      deltaX: delta,
      y0: new import_bn6.default(0),
      deltaY: new import_bn6.default(0)
    };
  }
  const maxDeltaIdBidSide = favorXInActiveId ? new import_bn6.default(-1) : new import_bn6.default(0);
  const minDeltaIdAskSide = favorXInActiveId ? new import_bn6.default(0) : new import_bn6.default(1);
  const { base: y0, delta: deltaY } = strategyParameterBuilder.findYParameters(
    amountY,
    minDeltaId,
    maxDeltaIdBidSide,
    activeId
  );
  const { base: x0, delta: deltaX } = strategyParameterBuilder.findXParameters(
    amountX,
    minDeltaIdAskSide,
    maxDeltaId,
    binStep,
    activeId
  );
  return {
    x0,
    deltaX,
    y0,
    deltaY
  };
}
function getTokenProgramId(lbPairState) {
  const getTokenProgramIdByFlag = (flag) => {
    return flag == 0 ? TOKEN_PROGRAM_ID : TOKEN_2022_PROGRAM_ID;
  };
  return {
    tokenXProgram: getTokenProgramIdByFlag(lbPairState.tokenMintXProgramFlag),
    tokenYProgram: getTokenProgramIdByFlag(lbPairState.tokenMintYProgramFlag)
  };
}
function toStrategyParameters({
  maxBinId,
  minBinId,
  strategyType,
  singleSidedX
}) {
  const parameteres = new Array(64).fill(0);
  const favorSide = singleSidedX ? 1 : 0;
  parameteres[0] = favorSide;
  switch (strategyType) {
    case 0: {
      return {
        minBinId,
        maxBinId,
        strategyType: { spotImBalanced: {} },
        parameteres
      };
    }
    case 1: {
      return {
        minBinId,
        maxBinId,
        strategyType: { curveImBalanced: {} },
        parameteres
      };
    }
    case 2: {
      return {
        minBinId,
        maxBinId,
        strategyType: { bidAskImBalanced: {} },
        parameteres
      };
    }
  }
}
function chunks(array, size) {
  return Array.apply(0, new Array(Math.ceil(array.length / size))).map(
    (_, index) => array.slice(index * size, (index + 1) * size)
  );
}
function range(min2, max2, mapfn) {
  const length = max2 - min2 + 1;
  return Array.from({ length }, (_, i) => mapfn(min2 + i));
}
function getOutAmount(bin, inAmount, swapForY) {
  return swapForY ? mulShr(
    inAmount,
    bin.price,
    SCALE_OFFSET,
    1
    /* Down */
  ) : shlDiv(
    inAmount,
    bin.price,
    SCALE_OFFSET,
    1
    /* Down */
  );
}
var getOrCreateATAInstruction = async (connection, tokenMint, owner, programId, payer = owner, allowOwnerOffCurve = true) => {
  programId = programId ?? TOKEN_PROGRAM_ID;
  const toAccount = getAssociatedTokenAddressSync(
    tokenMint,
    owner,
    allowOwnerOffCurve,
    programId,
    ASSOCIATED_TOKEN_PROGRAM_ID
  );
  try {
    await getAccount(connection, toAccount, connection.commitment, programId);
    return { ataPubKey: toAccount, ix: void 0 };
  } catch (e) {
    if (e instanceof TokenAccountNotFoundError || e instanceof TokenInvalidAccountOwnerError) {
      const ix = createAssociatedTokenAccountIdempotentInstruction(
        payer,
        toAccount,
        owner,
        tokenMint,
        programId,
        ASSOCIATED_TOKEN_PROGRAM_ID
      );
      return { ataPubKey: toAccount, ix };
    } else {
      console.error("Error::getOrCreateATAInstruction", e);
      throw e;
    }
  }
};
var wrapSOLInstruction = (from, to, amount) => {
  return [
    import_web313.SystemProgram.transfer({
      fromPubkey: from,
      toPubkey: to,
      lamports: amount
    }),
    new import_web313.TransactionInstruction({
      keys: [
        {
          pubkey: to,
          isSigner: false,
          isWritable: true
        }
      ],
      data: Buffer.from(new Uint8Array([17])),
      programId: TOKEN_PROGRAM_ID
    })
  ];
};
var unwrapSOLInstruction = async (owner, allowOwnerOffCurve = true) => {
  const wSolATAAccount = getAssociatedTokenAddressSync(
    NATIVE_MINT,
    owner,
    allowOwnerOffCurve
  );
  if (wSolATAAccount) {
    const closedWrappedSolInstruction = createCloseAccountInstruction(
      wSolATAAccount,
      owner,
      owner,
      [],
      TOKEN_PROGRAM_ID
    );
    return closedWrappedSolInstruction;
  }
  return null;
};
async function chunkedGetMultipleAccountInfos(connection, pks, chunkSize = 100) {
  const accountInfos = (await Promise.all(
    chunks(pks, chunkSize).map(
      (chunk) => connection.getMultipleAccountsInfo(chunk)
    )
  )).flat();
  return accountInfos;
}
var getEstimatedComputeUnitUsageWithBuffer = async (connection, instructions, feePayer, buffer, altAddress) => {
  if (!buffer) {
    buffer = 0.1;
  }
  buffer = Math.max(0, buffer);
  buffer = Math.min(1, buffer);
  const altAccounts = [];
  if (altAddress) {
    const altAccountInfo = await connection.getAddressLookupTable(altAddress);
    altAccounts.push(altAccountInfo.value);
  }
  const estimatedComputeUnitUsage = await getSimulationComputeUnits(
    connection,
    instructions,
    feePayer,
    altAccounts
  );
  let extraComputeUnitBuffer = estimatedComputeUnitUsage * buffer;
  if (extraComputeUnitBuffer > MAX_CU_BUFFER) {
    extraComputeUnitBuffer = MAX_CU_BUFFER;
  } else if (extraComputeUnitBuffer < MIN_CU_BUFFER) {
    extraComputeUnitBuffer = MIN_CU_BUFFER;
  }
  return estimatedComputeUnitUsage + extraComputeUnitBuffer;
};
var getEstimatedComputeUnitIxWithBuffer = async (connection, instructions, feePayer, buffer, altAddress) => {
  const units = await getEstimatedComputeUnitUsageWithBuffer(
    connection,
    instructions,
    feePayer,
    buffer,
    altAddress
  ).catch((error) => {
    console.error("Error::getEstimatedComputeUnitUsageWithBuffer", error);
    return 14e5;
  });
  return import_web313.ComputeBudgetProgram.setComputeUnitLimit({ units });
};
function createProgram(connection, opt) {
  const cluster = opt?.cluster || "mainnet-beta";
  const provider = new import_anchor4.AnchorProvider(
    connection,
    {},
    import_anchor4.AnchorProvider.defaultOptions()
  );
  return new import_anchor4.Program(
    { ...dlmm_default, address: opt?.programId ?? LBCLMM_PROGRAM_IDS[cluster] },
    provider
  );
}
function decodeAccount(program, accountName, buffer) {
  return program.coder.accounts.decode(accountName, buffer);
}
function getAccountDiscriminator(accountName) {
  return dlmm_default.accounts.find(
    (acc) => acc.name.toLowerCase() === accountName.toLowerCase()
  )?.discriminator;
}
function capSlippagePercentage(slippage) {
  if (slippage > 100) {
    slippage = 100;
  }
  if (slippage < 0) {
    slippage = 0;
  }
  return slippage;
}
function getAndCapMaxActiveBinSlippage(slippagePercentage, binStep, maxActiveBinSlippage) {
  return slippagePercentage ? Math.ceil(slippagePercentage / (binStep / 100)) : maxActiveBinSlippage;
}
function getBinCount(minBinId, maxBinId) {
  return maxBinId - minBinId + 1;
}
function getSlippageMaxAmount(amount, slippage) {
  if (slippage == 100) {
    return U64_MAX;
  }
  const amountDecimal = new decimal_default(amount.toString());
  const slippageAppliedAmount = new import_anchor4.BN(
    amountDecimal.mul(new decimal_default(100 + slippage)).div(new decimal_default(100)).floor().toString()
  );
  return slippageAppliedAmount;
}
function getSlippageMinAmount(amount, slippage) {
  const amountDecimal = new decimal_default(amount.toString());
  return new import_anchor4.BN(
    amountDecimal.mul(new decimal_default(100 - slippage)).div(new decimal_default(100)).ceil().toString()
  );
}
function getPositionCountByBinCount(binCount) {
  return Math.ceil(binCount / MAX_BINS_PER_POSITION.toNumber());
}
function resetUninvolvedLiquidityParams(minDeltaId, maxDeltaId, favorXInActiveId, params) {
  const endBidSideDeltaId = favorXInActiveId ? new import_anchor4.BN(-1) : new import_anchor4.BN(0);
  const startAskSideDeltaId = endBidSideDeltaId.addn(1);
  let x0 = params.x0;
  let y0 = params.y0;
  let deltaX = params.deltaX;
  let deltaY = params.deltaY;
  if (maxDeltaId.lte(endBidSideDeltaId)) {
    deltaX = new import_anchor4.BN(0);
    x0 = new import_anchor4.BN(0);
  }
  if (minDeltaId.gte(startAskSideDeltaId)) {
    deltaY = new import_anchor4.BN(0);
    y0 = new import_anchor4.BN(0);
  }
  return {
    x0,
    y0,
    deltaX,
    deltaY
  };
}
async function chunkDepositWithRebalanceEndpoint(dlmm, strategy, slippagePercentage, maxActiveBinSlippage, position, positionMinBinId, positionMaxBinId, liquidityStrategyParameters, owner, payer, isParallel, skipSolWrappingOperation = false) {
  const { slices, accounts: transferHookAccounts } = dlmm.getPotentialToken2022IxDataAndAccounts(
    0
    /* Liquidity */
  );
  const userTokenX = getAssociatedTokenAddressSync(
    dlmm.lbPair.tokenXMint,
    owner,
    true,
    dlmm.tokenX.owner
  );
  const userTokenY = getAssociatedTokenAddressSync(
    dlmm.lbPair.tokenYMint,
    owner,
    true,
    dlmm.tokenY.owner
  );
  const createUserTokenXIx = createAssociatedTokenAccountIdempotentInstruction(
    payer,
    userTokenX,
    owner,
    dlmm.lbPair.tokenXMint,
    dlmm.tokenX.owner
  );
  const createUserTokenYIx = createAssociatedTokenAccountIdempotentInstruction(
    payer,
    userTokenY,
    owner,
    dlmm.lbPair.tokenYMint,
    dlmm.tokenY.owner
  );
  const bitmapPubkey = deriveBinArrayBitmapExtension(
    dlmm.pubkey,
    dlmm.program.programId
  )[0];
  let calculatedAddLiquidityCU = 0;
  const chunkedAddLiquidityIx = [];
  const chunkedBinRange = chunkBinRange(positionMinBinId, positionMaxBinId);
  const binArrayOrBitmapInitTracking = /* @__PURE__ */ new Set();
  for (let i = 0; i < chunkedBinRange.length; i++) {
    const chunkMinBinId = chunkedBinRange[i].lowerBinId;
    const chunkMaxBinId = chunkedBinRange[i].upperBinId;
    const initBinArrayIxs = [];
    const initBitmapIxs = [];
    const binArrayIndexes = getBinArrayIndexesCoverage(
      new import_anchor4.BN(chunkMinBinId),
      new import_anchor4.BN(chunkMaxBinId)
    );
    const overflowDefaultBinArrayBitmap = binArrayIndexes.reduce(
      (acc, binArrayIndex) => acc || isOverflowDefaultBinArrayBitmap(binArrayIndex),
      false
    );
    if (overflowDefaultBinArrayBitmap) {
      const initBitmapIx = await dlmm.program.methods.initializeBinArrayBitmapExtension().accountsPartial({
        binArrayBitmapExtension: bitmapPubkey,
        lbPair: dlmm.pubkey,
        funder: payer
      }).instruction();
      initBitmapIxs.push(initBitmapIx);
      binArrayOrBitmapInitTracking.add(bitmapPubkey.toBase58());
    }
    const binArrayPubkeys = binArrayIndexes.map(
      (index) => deriveBinArray(dlmm.pubkey, index, dlmm.program.programId)[0]
    );
    for (const [idx, binArrayPubkey] of binArrayPubkeys.entries()) {
      const initBinArrayIx = await dlmm.program.methods.initializeBinArray(binArrayIndexes[idx]).accountsPartial({
        binArray: binArrayPubkey,
        funder: payer,
        lbPair: dlmm.pubkey
      }).instruction();
      if (isParallel) {
        initBinArrayIxs.push(initBinArrayIx);
      } else if (!binArrayOrBitmapInitTracking.has(binArrayPubkey.toBase58())) {
        binArrayOrBitmapInitTracking.add(binArrayPubkey.toBase58());
        initBinArrayIxs.push(initBinArrayIx);
        calculatedAddLiquidityCU += DEFAULT_INIT_BIN_ARRAY_CU;
      }
    }
    const minDeltaId = new import_anchor4.BN(chunkMinBinId - dlmm.lbPair.activeId);
    const maxDeltaId = new import_anchor4.BN(chunkMaxBinId - dlmm.lbPair.activeId);
    const { deltaX, deltaY, x0, y0 } = resetUninvolvedLiquidityParams(
      minDeltaId,
      maxDeltaId,
      strategy.singleSidedX,
      {
        ...liquidityStrategyParameters
      }
    );
    const { bitFlag, ...baseAndDelta } = buildBitFlagAndNegateStrategyParameters(x0, y0, deltaX, deltaY);
    const addParam = {
      minDeltaId: minDeltaId.toNumber(),
      maxDeltaId: maxDeltaId.toNumber(),
      x0: baseAndDelta.x0,
      y0: baseAndDelta.y0,
      deltaX: baseAndDelta.deltaX,
      deltaY: baseAndDelta.deltaY,
      bitFlag,
      favorXInActiveId: strategy.singleSidedX,
      padding: Array(36).fill(0)
    };
    const { totalXAmount, totalYAmount } = toAmountIntoBins(
      new import_anchor4.BN(dlmm.lbPair.activeId),
      minDeltaId,
      maxDeltaId,
      deltaX,
      deltaY,
      x0,
      y0,
      new import_anchor4.BN(dlmm.lbPair.binStep),
      strategy.singleSidedX
    ).reduce(
      (acc, bin) => {
        return {
          totalXAmount: acc.totalXAmount.add(bin.amountX),
          totalYAmount: acc.totalYAmount.add(bin.amountY)
        };
      },
      {
        totalXAmount: new import_anchor4.BN(0),
        totalYAmount: new import_anchor4.BN(0)
      }
    );
    const totalXAmountIncludeTransferFee = calculateTransferFeeIncludedAmount(
      totalXAmount,
      dlmm.tokenX.mint,
      dlmm.clock.epoch.toNumber()
    ).amount;
    const totalYAmountIncludeTransferFee = calculateTransferFeeIncludedAmount(
      totalYAmount,
      dlmm.tokenY.mint,
      dlmm.clock.epoch.toNumber()
    ).amount;
    const maxDepositXAmount = getSlippageMaxAmount(
      totalXAmountIncludeTransferFee,
      slippagePercentage
    );
    const maxDepositYAmount = getSlippageMaxAmount(
      totalYAmountIncludeTransferFee,
      slippagePercentage
    );
    let shrinkMode;
    if (isParallel) {
      if (i == 0) {
        shrinkMode = 2;
      } else if (i == chunkBinRange.length - 1) {
        shrinkMode = 1;
      } else {
        shrinkMode = 3;
      }
    } else {
      shrinkMode = 0;
    }
    const rebalanceIx = await dlmm.program.methods.rebalanceLiquidity(
      {
        activeId: dlmm.lbPair.activeId,
        maxActiveBinSlippage,
        shouldClaimFee: false,
        shouldClaimReward: false,
        minWithdrawXAmount: new import_anchor4.BN(0),
        minWithdrawYAmount: new import_anchor4.BN(0),
        maxDepositXAmount,
        maxDepositYAmount,
        removes: [],
        adds: [addParam],
        shrinkMode,
        padding: REBALANCE_POSITION_PADDING
      },
      {
        slices
      }
    ).accountsPartial({
      binArrayBitmapExtension: initBitmapIxs.length > 0 ? bitmapPubkey : dlmm.program.programId,
      lbPair: dlmm.pubkey,
      position,
      owner,
      tokenXMint: dlmm.lbPair.tokenXMint,
      tokenYMint: dlmm.lbPair.tokenYMint,
      userTokenX,
      userTokenY,
      tokenXProgram: dlmm.tokenX.owner,
      tokenYProgram: dlmm.tokenY.owner,
      rentPayer: payer
    }).remainingAccounts([
      ...transferHookAccounts,
      ...binArrayPubkeys.map((baPubkey) => ({
        pubkey: baPubkey,
        isWritable: true,
        isSigner: false
      })),
      derivePlaceHolderAccountMeta(dlmm.program.programId)
    ]).instruction();
    calculatedAddLiquidityCU += DEFAULT_ADD_LIQUIDITY_CU;
    const addLiquidityIxs = [];
    addLiquidityIxs.push(...initBitmapIxs, ...initBinArrayIxs);
    if (isParallel) {
      addLiquidityIxs.push(createUserTokenXIx);
      addLiquidityIxs.push(createUserTokenYIx);
    }
    if (dlmm.tokenX.publicKey.equals(NATIVE_MINT) && !skipSolWrappingOperation) {
      const wrapSOLIx = wrapSOLInstruction(
        owner,
        userTokenX,
        BigInt(totalXAmount.toString())
      );
      if (!isParallel) {
        addLiquidityIxs.push(createUserTokenXIx);
      }
      addLiquidityIxs.push(...wrapSOLIx);
    }
    if (dlmm.tokenY.publicKey.equals(NATIVE_MINT) && !skipSolWrappingOperation) {
      const wrapSOLIx = wrapSOLInstruction(
        owner,
        userTokenY,
        BigInt(totalYAmount.toString())
      );
      if (!isParallel) {
        addLiquidityIxs.push(createUserTokenYIx);
      }
      addLiquidityIxs.push(...wrapSOLIx);
    }
    addLiquidityIxs.push(rebalanceIx);
    if (dlmm.tokenX.publicKey.equals(NATIVE_MINT) && !totalXAmount.isZero() && !skipSolWrappingOperation) {
      addLiquidityIxs.push(
        createCloseAccountInstruction(
          userTokenX,
          owner,
          owner,
          [],
          TOKEN_PROGRAM_ID
        )
      );
    }
    if (dlmm.tokenY.publicKey.equals(NATIVE_MINT) && !totalYAmount.isZero() && !skipSolWrappingOperation) {
      addLiquidityIxs.push(
        createCloseAccountInstruction(
          userTokenY,
          owner,
          owner,
          [],
          TOKEN_PROGRAM_ID
        )
      );
    }
    if (!isParallel) {
      addLiquidityIxs.unshift(
        import_web313.ComputeBudgetProgram.setComputeUnitLimit({
          units: Math.min(calculatedAddLiquidityCU, MAX_CU)
        })
      );
    }
    chunkedAddLiquidityIx.push(addLiquidityIxs);
  }
  return chunkedAddLiquidityIx;
}
var presetParameter2BinStepFilter = (binStep) => {
  return {
    memcmp: {
      bytes: import_bytes.bs58.encode(binStep.toArrayLike(Buffer, "le", 2)),
      offset: 8
    }
  };
};
var presetParameter2BaseFactorFilter = (baseFactor) => {
  return {
    memcmp: {
      bytes: import_bytes.bs58.encode(baseFactor.toArrayLike(Buffer, "le", 2)),
      offset: 8 + 2
    }
  };
};
var presetParameter2BaseFeePowerFactor = (baseFeePowerFactor) => {
  return {
    memcmp: {
      bytes: import_bytes.bs58.encode(baseFeePowerFactor.toArrayLike(Buffer, "le", 1)),
      offset: 8 + 22
    }
  };
};
var binArrayLbPairFilter = (lbPair) => {
  return {
    memcmp: {
      bytes: lbPair.toBase58(),
      offset: 8 + 16
    }
  };
};
var positionOwnerFilter = (owner) => {
  return {
    memcmp: {
      bytes: owner.toBase58(),
      offset: 8 + 32
    }
  };
};
var positionLbPairFilter = (lbPair) => {
  return {
    memcmp: {
      bytes: import_bytes.bs58.encode(lbPair.toBuffer()),
      offset: 8
    }
  };
};
var positionV2Filter = () => {
  return {
    memcmp: {
      bytes: import_bytes.bs58.encode(Buffer.from(getAccountDiscriminator("positionV2"))),
      offset: 0
    }
  };
};
var MAX_BPS = new import_bn11.default(BASIS_POINT_MAX);
function capBps(bps) {
  return bps.lt(new import_bn11.default(0)) ? new import_bn11.default(0) : bps.gt(MAX_BPS) ? new import_bn11.default(MAX_BPS) : bps;
}
var BalancedStrategyBuilder = class {
  constructor(activeId, binStep, positionData, topUpAmountX, topUpAmountY, xWithdrawBps, yWithdrawBps, strategy, favorXIfImbalance = false, favorXInActiveBin = false) {
    this.activeId = activeId;
    this.binStep = binStep;
    this.positionData = positionData;
    this.topUpAmountX = topUpAmountX;
    this.topUpAmountY = topUpAmountY;
    this.xWithdrawBps = xWithdrawBps;
    this.yWithdrawBps = yWithdrawBps;
    this.strategy = strategy;
    this.favorXIfImbalance = favorXIfImbalance;
    this.favorXInActiveBin = favorXInActiveBin;
  }
  // Rebalance to active bin by withdrawing all liquidities and redeposit portion of withdrawn liquidity, together with topup amount
  buildRebalanceStrategyParameters() {
    const xWithdrawBps = capBps(this.xWithdrawBps);
    const yWithdrawBps = capBps(this.yWithdrawBps);
    let totalXAmountOut = new import_bn10.default(this.positionData.totalXAmount);
    let totalYAmountOut = new import_bn10.default(this.positionData.totalYAmount);
    totalXAmountOut = totalXAmountOut.add(new import_bn10.default(this.positionData.feeX));
    totalYAmountOut = totalYAmountOut.add(new import_bn10.default(this.positionData.feeY));
    const redepositAmountX = totalXAmountOut.mul(MAX_BPS.sub(xWithdrawBps)).div(MAX_BPS);
    const redepositAmountY = totalYAmountOut.mul(MAX_BPS.sub(yWithdrawBps)).div(MAX_BPS);
    const depositAmountX = this.topUpAmountX.add(redepositAmountX);
    const depositAmountY = this.topUpAmountY.add(redepositAmountY);
    const width = this.positionData.upperBinId - this.positionData.lowerBinId + 1;
    const binPerSide = Math.floor(width / 2);
    const rem = width % 2;
    let binPerAsk = binPerSide;
    let binPerBid = binPerSide;
    if (rem == 0) {
      if (this.favorXIfImbalance) {
        binPerAsk += 1;
        binPerBid -= 1;
      } else {
        binPerAsk -= 1;
        binPerBid += 1;
      }
    }
    const minDeltaId = new import_bn10.default(binPerBid).neg();
    const maxDeltaId = new import_bn10.default(binPerAsk);
    const strategyParameters = buildLiquidityStrategyParameters(
      depositAmountX,
      depositAmountY,
      minDeltaId,
      maxDeltaId,
      this.binStep,
      this.favorXInActiveBin,
      this.activeId,
      getLiquidityStrategyParameterBuilder(this.strategy)
    );
    const depositParam = {
      minDeltaId,
      maxDeltaId,
      x0: strategyParameters.x0,
      y0: strategyParameters.y0,
      deltaX: strategyParameters.deltaX,
      deltaY: strategyParameters.deltaY,
      favorXInActiveBin: this.favorXInActiveBin
    };
    const withdrawParam = {
      minBinId: new import_bn10.default(this.positionData.lowerBinId),
      maxBinId: new import_bn10.default(this.positionData.upperBinId),
      bps: MAX_BPS
    };
    return {
      shouldClaimFee: true,
      shouldClaimReward: true,
      deposits: [depositParam],
      withdraws: [withdrawParam]
    };
  }
};
var DLMM = class {
  constructor(pubkey, program, lbPair, binArrayBitmapExtension, tokenX, tokenY, rewards, clock, opt) {
    this.pubkey = pubkey;
    this.program = program;
    this.lbPair = lbPair;
    this.binArrayBitmapExtension = binArrayBitmapExtension;
    this.tokenX = tokenX;
    this.tokenY = tokenY;
    this.rewards = rewards;
    this.clock = clock;
    this.opt = opt;
  }
  /** Static public method */
  /**
   * The function `getLbPairs` retrieves a list of LB pair accounts using a connection and optional
   * parameters.
   * @param {Connection} connection - The `connection` parameter is an instance of the `Connection`
   * class, which represents the connection to the Solana blockchain network.
   * @param {Opt} [opt] - The `opt` parameter is an optional object that contains additional options
   * for the function. It can have the following properties:
   * @returns The function `getLbPairs` returns a Promise that resolves to an array of
   * `LbPairAccount` objects.
   */
  static async getLbPairs(connection, opt) {
    const program = createProgram(connection, opt);
    return program.account.lbPair.all();
  }
  /**
   * Retrieves the public key of a LB pair if it exists. This function expect the RPC have getProgramAccounts RPC method enabled.
   * @param connection The connection to the Solana cluster.
   * @param tokenX The mint address of token X.
   * @param tokenY The mint address of token Y.
   * @param binStep The bin step of the LB pair.
   * @param baseFactor The base factor of the LB pair.
   * @param baseFeePowerFactor The base fee power factor of the LB pair. It allow small bin step to have bigger fee rate.
   * @param opt Optional parameters.
   * @returns The public key of the LB pair if it exists, or null.
   */
  static async getPairPubkeyIfExists(connection, tokenX, tokenY, binStep, baseFactor, baseFeePowerFactor, opt) {
    const program = createProgram(connection, opt);
    const [lbPair2Key] = deriveLbPair2(
      tokenX,
      tokenY,
      binStep,
      baseFactor,
      program.programId
    );
    const account2 = await program.account.lbPair.fetchNullable(lbPair2Key);
    if (account2 && account2.parameters.baseFeePowerFactor == baseFeePowerFactor.toNumber()) {
      return lbPair2Key;
    }
    const [lbPairKey] = deriveLbPair(
      tokenX,
      tokenY,
      binStep,
      program.programId
    );
    const account = await program.account.lbPair.fetchNullable(lbPairKey);
    if (account && account.parameters.baseFactor === baseFactor.toNumber() && account.parameters.baseFeePowerFactor === baseFeePowerFactor.toNumber()) {
      return lbPairKey;
    }
    const presetParametersWithIndex = await program.account.presetParameter2.all([
      presetParameter2BinStepFilter(binStep),
      presetParameter2BaseFactorFilter(baseFactor),
      presetParameter2BaseFeePowerFactor(baseFeePowerFactor)
    ]);
    if (presetParametersWithIndex.length > 0) {
      const possibleLbPairKeys = presetParametersWithIndex.map((account3) => {
        return deriveLbPairWithPresetParamWithIndexKey(
          account3.publicKey,
          tokenX,
          tokenY,
          program.programId
        )[0];
      });
      const accounts = await chunkedGetMultipleAccountInfos(
        program.provider.connection,
        possibleLbPairKeys
      );
      for (let i = 0; i < possibleLbPairKeys.length; i++) {
        const pairKey = possibleLbPairKeys[i];
        const account3 = accounts[i];
        if (account3) {
          return pairKey;
        }
      }
    }
    return null;
  }
  static async getCustomizablePermissionlessLbPairIfExists(connection, tokenX, tokenY, opt) {
    const program = createProgram(connection, opt);
    try {
      const [lpPair] = deriveCustomizablePermissionlessLbPair(
        tokenX,
        tokenY,
        program.programId
      );
      const account = await program.account.lbPair.fetchNullable(lpPair);
      if (account)
        return lpPair;
      return null;
    } catch (error) {
      return null;
    }
  }
  /**
   * The `create` function is a static method that creates a new instance of the `DLMM` class
   * @param {Connection} connection - The `connection` parameter is an instance of the `Connection`
   * class, which represents the connection to the Solana blockchain network.
   * @param {PublicKey} dlmm - The PublicKey of LB Pair.
   * @param {Opt} [opt] - The `opt` parameter is an optional object that can contain additional options
   * for the `create` function. It has the following properties:
   * @returns The `create` function returns a `Promise` that resolves to a `DLMM` object.
   */
  static async create(connection, dlmm, opt) {
    const program = createProgram(connection, opt);
    const binArrayBitMapExtensionPubkey = deriveBinArrayBitmapExtension(
      dlmm,
      program.programId
    )[0];
    let accountsToFetch = [
      dlmm,
      binArrayBitMapExtensionPubkey,
      import_web311.SYSVAR_CLOCK_PUBKEY
    ];
    const accountsInfo = await chunkedGetMultipleAccountInfos(
      connection,
      accountsToFetch
    );
    const lbPairAccountInfoBuffer = accountsInfo[0]?.data;
    if (!lbPairAccountInfoBuffer)
      throw new Error(`LB Pair account ${dlmm.toBase58()} not found`);
    const lbPairAccInfo = decodeAccount(
      program,
      "lbPair",
      lbPairAccountInfoBuffer
    );
    const binArrayBitMapAccountInfoBuffer = accountsInfo[1]?.data;
    let binArrayBitMapExtensionAccInfo = null;
    if (binArrayBitMapAccountInfoBuffer) {
      binArrayBitMapExtensionAccInfo = decodeAccount(
        program,
        "binArrayBitmapExtension",
        binArrayBitMapAccountInfoBuffer
      );
    }
    const clockAccountInfoBuffer = accountsInfo[2]?.data;
    if (!clockAccountInfoBuffer)
      throw new Error(`Clock account not found`);
    const clock = ClockLayout.decode(clockAccountInfoBuffer);
    accountsToFetch = [
      lbPairAccInfo.reserveX,
      lbPairAccInfo.reserveY,
      lbPairAccInfo.tokenXMint,
      lbPairAccInfo.tokenYMint,
      lbPairAccInfo.rewardInfos[0].vault,
      lbPairAccInfo.rewardInfos[1].vault,
      lbPairAccInfo.rewardInfos[0].mint,
      lbPairAccInfo.rewardInfos[1].mint
    ];
    const [
      reserveXAccount,
      reserveYAccount,
      tokenXMintAccount,
      tokenYMintAccount,
      reward0VaultAccount,
      reward1VaultAccount,
      reward0MintAccount,
      reward1MintAccount
    ] = await chunkedGetMultipleAccountInfos(
      program.provider.connection,
      accountsToFetch
    );
    let binArrayBitmapExtension;
    if (binArrayBitMapExtensionAccInfo) {
      binArrayBitmapExtension = {
        account: binArrayBitMapExtensionAccInfo,
        publicKey: binArrayBitMapExtensionPubkey
      };
    }
    const reserveXBalance = AccountLayout.decode(reserveXAccount.data);
    const reserveYBalance = AccountLayout.decode(reserveYAccount.data);
    const mintX = unpackMint(
      lbPairAccInfo.tokenXMint,
      tokenXMintAccount,
      tokenXMintAccount.owner
    );
    const mintY = unpackMint(
      lbPairAccInfo.tokenYMint,
      tokenYMintAccount,
      tokenYMintAccount.owner
    );
    const [
      tokenXTransferHook,
      tokenYTransferHook,
      reward0TransferHook,
      reward1TransferHook
    ] = await Promise.all([
      getExtraAccountMetasForTransferHook(
        connection,
        lbPairAccInfo.tokenXMint,
        tokenXMintAccount
      ),
      getExtraAccountMetasForTransferHook(
        connection,
        lbPairAccInfo.tokenYMint,
        tokenYMintAccount
      ),
      reward0MintAccount ? getExtraAccountMetasForTransferHook(
        connection,
        lbPairAccInfo.rewardInfos[0].mint,
        reward0MintAccount
      ) : [],
      reward1MintAccount ? getExtraAccountMetasForTransferHook(
        connection,
        lbPairAccInfo.rewardInfos[1].mint,
        reward1MintAccount
      ) : []
    ]);
    const tokenX = {
      publicKey: lbPairAccInfo.tokenXMint,
      reserve: lbPairAccInfo.reserveX,
      amount: reserveXBalance.amount,
      mint: mintX,
      owner: tokenXMintAccount.owner,
      transferHookAccountMetas: tokenXTransferHook
    };
    const tokenY = {
      publicKey: lbPairAccInfo.tokenYMint,
      reserve: lbPairAccInfo.reserveY,
      amount: reserveYBalance.amount,
      mint: mintY,
      owner: tokenYMintAccount.owner,
      transferHookAccountMetas: tokenYTransferHook
    };
    const reward0 = !lbPairAccInfo.rewardInfos[0].mint.equals(
      import_web311.PublicKey.default
    ) ? {
      publicKey: lbPairAccInfo.rewardInfos[0].mint,
      reserve: lbPairAccInfo.rewardInfos[0].vault,
      amount: AccountLayout.decode(reward0VaultAccount.data).amount,
      mint: unpackMint(
        lbPairAccInfo.rewardInfos[0].mint,
        reward0MintAccount,
        reward0MintAccount.owner
      ),
      owner: reward0MintAccount.owner,
      transferHookAccountMetas: reward0TransferHook
    } : null;
    const reward1 = !lbPairAccInfo.rewardInfos[1].mint.equals(
      import_web311.PublicKey.default
    ) ? {
      publicKey: lbPairAccInfo.rewardInfos[1].mint,
      reserve: lbPairAccInfo.rewardInfos[1].vault,
      amount: AccountLayout.decode(reward1VaultAccount.data).amount,
      mint: unpackMint(
        lbPairAccInfo.rewardInfos[1].mint,
        reward1MintAccount,
        reward1MintAccount.owner
      ),
      owner: reward1MintAccount.owner,
      transferHookAccountMetas: reward1TransferHook
    } : null;
    return new DLMM(
      dlmm,
      program,
      lbPairAccInfo,
      binArrayBitmapExtension,
      tokenX,
      tokenY,
      [reward0, reward1],
      clock,
      opt
    );
  }
  /**
   * Similar to `create` function, but it accept multiple lbPairs to be initialized.
   * @param {Connection} connection - The `connection` parameter is an instance of the `Connection`
   * class, which represents the connection to the Solana blockchain network.
   * @param dlmmList - An Array of PublicKey of LB Pairs.
   * @param {Opt} [opt] - An optional parameter of type `Opt`.
   * @returns The function `createMultiple` returns a Promise that resolves to an array of `DLMM`
   * objects.
   */
  static async createMultiple(connection, dlmmList, opt) {
    const program = createProgram(connection, opt);
    const binArrayBitMapExtensions = dlmmList.map(
      (lbPair) => deriveBinArrayBitmapExtension(lbPair, program.programId)[0]
    );
    const accountsToFetch = [
      ...dlmmList,
      ...binArrayBitMapExtensions,
      import_web311.SYSVAR_CLOCK_PUBKEY
    ];
    let accountsInfo = await chunkedGetMultipleAccountInfos(
      connection,
      accountsToFetch
    );
    const clockAccount = accountsInfo.pop();
    const clockAccountInfoBuffer = clockAccount?.data;
    if (!clockAccountInfoBuffer)
      throw new Error(`Clock account not found`);
    const clock = ClockLayout.decode(clockAccountInfoBuffer);
    const lbPairArraysMap = /* @__PURE__ */ new Map();
    for (let i = 0; i < dlmmList.length; i++) {
      const lbPairPubKey = dlmmList[i];
      const lbPairAccountInfoBuffer = accountsInfo[i]?.data;
      if (!lbPairAccountInfoBuffer)
        throw new Error(`LB Pair account ${lbPairPubKey.toBase58()} not found`);
      const lbPairAccInfo = decodeAccount(
        program,
        "lbPair",
        lbPairAccountInfoBuffer
      );
      lbPairArraysMap.set(lbPairPubKey.toBase58(), lbPairAccInfo);
    }
    const binArrayBitMapExtensionsMap = /* @__PURE__ */ new Map();
    for (let i = dlmmList.length; i < accountsInfo.length; i++) {
      const index = i - dlmmList.length;
      const lbPairPubkey = dlmmList[index];
      const binArrayBitMapAccountInfoBuffer = accountsInfo[i]?.data;
      if (binArrayBitMapAccountInfoBuffer) {
        const binArrayBitMapExtensionAccInfo = decodeAccount(
          program,
          "binArrayBitmapExtension",
          binArrayBitMapAccountInfoBuffer
        );
        binArrayBitMapExtensionsMap.set(
          lbPairPubkey.toBase58(),
          binArrayBitMapExtensionAccInfo
        );
      }
    }
    const reservePublicKeys = Array.from(lbPairArraysMap.values()).map(({ reserveX, reserveY }) => [reserveX, reserveY]).flat();
    const tokenMintPublicKeys = Array.from(lbPairArraysMap.values()).map(({ tokenXMint, tokenYMint }) => [tokenXMint, tokenYMint]).flat();
    const rewardVaultPublicKeys = Array.from(lbPairArraysMap.values()).map(({ rewardInfos }) => rewardInfos.map(({ vault }) => vault)).flat();
    const rewardMintPublicKeys = Array.from(lbPairArraysMap.values()).map(({ rewardInfos }) => rewardInfos.map(({ mint }) => mint)).flat();
    accountsInfo = await chunkedGetMultipleAccountInfos(
      program.provider.connection,
      [
        ...reservePublicKeys,
        ...tokenMintPublicKeys,
        ...rewardVaultPublicKeys,
        ...rewardMintPublicKeys
      ]
    );
    const offsetToTokenMint = reservePublicKeys.length;
    const offsetToRewardMint = reservePublicKeys.length + tokenMintPublicKeys.length + rewardVaultPublicKeys.length;
    const tokenMintAccounts = accountsInfo.slice(
      offsetToTokenMint,
      offsetToTokenMint + tokenMintPublicKeys.length
    );
    const rewardMintAccounts = accountsInfo.slice(
      offsetToRewardMint,
      offsetToRewardMint + rewardMintPublicKeys.length
    );
    const tokenMintsWithAccount = tokenMintPublicKeys.map((key, idx) => {
      return {
        mintAddress: key,
        mintAccountInfo: tokenMintAccounts[idx]
      };
    }).filter(({ mintAddress }) => mintAddress !== import_web311.PublicKey.default);
    const rewardMintsWithAccount = rewardMintPublicKeys.map((key, idx) => {
      return {
        mintAddress: key,
        mintAccountInfo: rewardMintAccounts[idx]
      };
    }).filter(({ mintAddress }) => mintAddress !== import_web311.PublicKey.default);
    const uniqueMintWithAccounts = Array.from(
      new Set(tokenMintsWithAccount.concat(rewardMintsWithAccount))
    );
    const mintHookAccountsMap = await getMultipleMintsExtraAccountMetasForTransferHook(
      connection,
      uniqueMintWithAccounts
    );
    const lbClmmImpl = dlmmList.map((lbPair, index) => {
      const lbPairState = lbPairArraysMap.get(lbPair.toBase58());
      if (!lbPairState)
        throw new Error(`LB Pair ${lbPair.toBase58()} state not found`);
      const binArrayBitmapExtensionState = binArrayBitMapExtensionsMap.get(
        lbPair.toBase58()
      );
      const binArrayBitmapExtensionPubkey = binArrayBitMapExtensions[index];
      let binArrayBitmapExtension = null;
      if (binArrayBitmapExtensionState) {
        binArrayBitmapExtension = {
          account: binArrayBitmapExtensionState,
          publicKey: binArrayBitmapExtensionPubkey
        };
      }
      const reserveXAccountInfo = accountsInfo[index * 2];
      const reserveYAccountInfo = accountsInfo[index * 2 + 1];
      let offsetToTokenMint2 = reservePublicKeys.length;
      const tokenXMintAccountInfo = accountsInfo[offsetToTokenMint2 + index * 2];
      const tokenYMintAccountInfo = accountsInfo[offsetToTokenMint2 + index * 2 + 1];
      const offsetToRewardVaultAccountInfos = offsetToTokenMint2 + tokenMintPublicKeys.length;
      const reward0VaultAccountInfo = accountsInfo[offsetToRewardVaultAccountInfos + index * 2];
      const reward1VaultAccountInfo = accountsInfo[offsetToRewardVaultAccountInfos + index * 2 + 1];
      const offsetToRewardMintAccountInfos = offsetToRewardVaultAccountInfos + rewardVaultPublicKeys.length;
      const reward0MintAccountInfo = accountsInfo[offsetToRewardMintAccountInfos + index * 2];
      const reward1MintAccountInfo = accountsInfo[offsetToRewardMintAccountInfos + index * 2 + 1];
      if (!reserveXAccountInfo || !reserveYAccountInfo)
        throw new Error(
          `Reserve account for LB Pair ${lbPair.toBase58()} not found`
        );
      const reserveXBalance = AccountLayout.decode(reserveXAccountInfo.data);
      const reserveYBalance = AccountLayout.decode(reserveYAccountInfo.data);
      const mintX = unpackMint(
        lbPairState.tokenXMint,
        tokenXMintAccountInfo,
        tokenXMintAccountInfo.owner
      );
      const mintY = unpackMint(
        lbPairState.tokenYMint,
        tokenYMintAccountInfo,
        tokenYMintAccountInfo.owner
      );
      const tokenX = {
        publicKey: lbPairState.tokenXMint,
        reserve: lbPairState.reserveX,
        mint: mintX,
        amount: reserveXBalance.amount,
        owner: tokenXMintAccountInfo.owner,
        transferHookAccountMetas: mintHookAccountsMap.get(lbPairState.tokenXMint.toBase58()) ?? []
      };
      const tokenY = {
        publicKey: lbPairState.tokenYMint,
        reserve: lbPairState.reserveY,
        amount: reserveYBalance.amount,
        mint: mintY,
        owner: tokenYMintAccountInfo.owner,
        transferHookAccountMetas: mintHookAccountsMap.get(lbPairState.tokenYMint.toBase58()) ?? []
      };
      const reward0 = !lbPairState.rewardInfos[0].mint.equals(
        import_web311.PublicKey.default
      ) ? {
        publicKey: lbPairState.rewardInfos[0].mint,
        reserve: lbPairState.rewardInfos[0].vault,
        amount: AccountLayout.decode(reward0VaultAccountInfo.data).amount,
        mint: unpackMint(
          lbPairState.rewardInfos[0].mint,
          reward0MintAccountInfo,
          reward0MintAccountInfo.owner
        ),
        owner: reward0MintAccountInfo.owner,
        transferHookAccountMetas: mintHookAccountsMap.get(
          lbPairState.rewardInfos[0].mint.toBase58()
        ) ?? []
      } : null;
      const reward1 = !lbPairState.rewardInfos[1].mint.equals(
        import_web311.PublicKey.default
      ) ? {
        publicKey: lbPairState.rewardInfos[1].mint,
        reserve: lbPairState.rewardInfos[1].vault,
        amount: AccountLayout.decode(reward1VaultAccountInfo.data).amount,
        mint: unpackMint(
          lbPairState.rewardInfos[1].mint,
          reward1MintAccountInfo,
          reward1MintAccountInfo.owner
        ),
        owner: reward1MintAccountInfo.owner,
        transferHookAccountMetas: mintHookAccountsMap.get(
          lbPairState.rewardInfos[1].mint.toBase58()
        ) ?? []
      } : null;
      return new DLMM(
        lbPair,
        program,
        lbPairState,
        binArrayBitmapExtension,
        tokenX,
        tokenY,
        [reward0, reward1],
        clock,
        opt
      );
    });
    return lbClmmImpl;
  }
  /**
   * The `getAllPresetParameters` function retrieves all preset parameter accounts
   * for the given DLMM program.
   *
   * @param {Connection} connection - The connection to the Solana cluster.
   * @param {Opt} [opt] - The optional parameters for the function.
   *
   * @returns A promise that resolves to an object containing the preset parameter
   * accounts, with the following properties:
   * - `presetParameter`: The preset parameter accounts for the original `PresetParameter` struct.
   * - `presetParameter2`: The preset parameter accounts for the `PresetParameter2` struct.
   */
  static async getAllPresetParameters(connection, opt) {
    const program = createProgram(connection, opt);
    const [presetParameter, presetParameter2] = await Promise.all([
      program.account.presetParameter.all(),
      program.account.presetParameter2.all()
    ]);
    return {
      presetParameter,
      presetParameter2
    };
  }
  /**
   * The function `getAllLbPairPositionsByUser` retrieves all liquidity pool pair positions for a given
   * user.
   * @param {Connection} connection - The `connection` parameter is an instance of the `Connection`
   * class, which represents the connection to the Solana blockchain.
   * @param {PublicKey} userPubKey - The user's wallet public key.
   * @param {Opt} [opt] - An optional object that contains additional options for the function.
   * @returns The function `getAllLbPairPositionsByUser` returns a `Promise` that resolves to a `Map`
   * object. The `Map` object contains key-value pairs, where the key is a string representing the LB
   * Pair account, and the value is an object of PositionInfo
   */
  static async getAllLbPairPositionsByUser(connection, userPubKey, opt) {
    const program = createProgram(connection, opt);
    const positionsV2 = await program.provider.connection.getProgramAccounts(
      program.programId,
      {
        filters: [positionV2Filter(), positionOwnerFilter(userPubKey)]
      }
    );
    const positionWrappers = [
      ...positionsV2.map((p) => wrapPosition(program, p.pubkey, p.account))
    ];
    const binArrayPubkeySetV2 = /* @__PURE__ */ new Set();
    const lbPairSetV2 = /* @__PURE__ */ new Set();
    positionWrappers.forEach((p) => {
      const binArrayKeys = p.getBinArrayKeysCoverage(program.programId);
      binArrayKeys.forEach((binArrayKey) => {
        binArrayPubkeySetV2.add(binArrayKey.toBase58());
      });
      lbPairSetV2.add(p.lbPair().toBase58());
    });
    const binArrayPubkeyArrayV2 = Array.from(binArrayPubkeySetV2).map(
      (pubkey) => new import_web311.PublicKey(pubkey)
    );
    const lbPairKeys = Array.from(lbPairSetV2).map(
      (pubkey) => new import_web311.PublicKey(pubkey)
    );
    const [clockAccInfo, ...binArraysAccInfo] = await chunkedGetMultipleAccountInfos(connection, [
      import_web311.SYSVAR_CLOCK_PUBKEY,
      ...binArrayPubkeyArrayV2,
      ...lbPairKeys
    ]);
    const positionBinArraysMapV2 = /* @__PURE__ */ new Map();
    for (let i = 0; i < binArrayPubkeyArrayV2.length; i++) {
      const binArrayPubkey = binArrayPubkeyArrayV2[i];
      const binArrayAccInfoBufferV2 = binArraysAccInfo[i];
      if (binArrayAccInfoBufferV2) {
        const binArrayAccInfo = decodeAccount(
          program,
          "binArray",
          binArrayAccInfoBufferV2.data
        );
        positionBinArraysMapV2.set(binArrayPubkey.toBase58(), binArrayAccInfo);
      }
    }
    const lbPairMap = /* @__PURE__ */ new Map();
    for (let i = binArrayPubkeyArrayV2.length; i < binArraysAccInfo.length; i++) {
      const lbPairPubkey = lbPairKeys[i - binArrayPubkeyArrayV2.length];
      const lbPairAccInfoBufferV2 = binArraysAccInfo[i];
      if (!lbPairAccInfoBufferV2)
        throw new Error(`LB Pair account ${lbPairPubkey.toBase58()} not found`);
      const lbPairAccInfo = decodeAccount(
        program,
        "lbPair",
        lbPairAccInfoBufferV2.data
      );
      lbPairMap.set(lbPairPubkey.toBase58(), lbPairAccInfo);
    }
    const accountKeys = Array.from(lbPairMap.values()).map(({ reserveX, reserveY, tokenXMint, tokenYMint, rewardInfos }) => [
      reserveX,
      reserveY,
      tokenXMint,
      tokenYMint,
      rewardInfos[0].mint,
      rewardInfos[1].mint
    ]).flat();
    const accountInfos = await chunkedGetMultipleAccountInfos(
      program.provider.connection,
      accountKeys
    );
    const lbPairReserveMap = /* @__PURE__ */ new Map();
    const lbPairMintMap = /* @__PURE__ */ new Map();
    lbPairKeys.forEach((lbPair, idx) => {
      const index = idx * 6;
      const reserveXAccount = accountInfos[index];
      const reserveYAccount = accountInfos[index + 1];
      if (!reserveXAccount || !reserveYAccount)
        throw new Error(
          `Reserve account for LB Pair ${lbPair.toBase58()} not found`
        );
      const reserveAccX = AccountLayout.decode(reserveXAccount.data);
      const reserveAccY = AccountLayout.decode(reserveYAccount.data);
      lbPairReserveMap.set(lbPair.toBase58(), {
        reserveX: reserveAccX.amount,
        reserveY: reserveAccY.amount
      });
      const mintXAccount = accountInfos[index + 2];
      const mintYAccount = accountInfos[index + 3];
      if (!mintXAccount || !mintYAccount)
        throw new Error(
          `Mint account for LB Pair ${lbPair.toBase58()} not found`
        );
      const mintX = unpackMint(
        reserveAccX.mint,
        mintXAccount,
        mintXAccount.owner
      );
      const mintY = unpackMint(
        reserveAccY.mint,
        mintYAccount,
        mintYAccount.owner
      );
      const rewardMint0Account = accountInfos[index + 4];
      const rewardMint1Account = accountInfos[index + 5];
      const lbPairState = lbPairMap.get(lbPair.toBase58());
      let rewardMint0 = null;
      let rewardMint1 = null;
      if (!lbPairState.rewardInfos[0].mint.equals(import_web311.PublicKey.default)) {
        rewardMint0 = unpackMint(
          lbPairState.rewardInfos[0].mint,
          rewardMint0Account,
          rewardMint0Account.owner
        );
      }
      if (!lbPairState.rewardInfos[1].mint.equals(import_web311.PublicKey.default)) {
        rewardMint1 = unpackMint(
          lbPairState.rewardInfos[1].mint,
          rewardMint1Account,
          rewardMint1Account.owner
        );
      }
      lbPairMintMap.set(lbPair.toBase58(), {
        mintX,
        mintY,
        rewardMint0,
        rewardMint1
      });
    });
    const clock = ClockLayout.decode(clockAccInfo.data);
    const positionsMap = /* @__PURE__ */ new Map();
    for (const position of positionWrappers) {
      const lbPair = position.lbPair();
      const positionPubkey = position.address();
      const version = position.version();
      const lbPairAcc = lbPairMap.get(lbPair.toBase58());
      const { mintX, mintY, rewardMint0, rewardMint1 } = lbPairMintMap.get(
        lbPair.toBase58()
      );
      const reserveXBalance = lbPairReserveMap.get(lbPair.toBase58())?.reserveX ?? BigInt(0);
      const reserveYBalance = lbPairReserveMap.get(lbPair.toBase58())?.reserveY ?? BigInt(0);
      const { tokenXProgram, tokenYProgram } = getTokenProgramId(lbPairAcc);
      const tokenX = {
        publicKey: lbPairAcc.tokenXMint,
        reserve: lbPairAcc.reserveX,
        amount: reserveXBalance,
        mint: mintX,
        owner: tokenXProgram,
        transferHookAccountMetas: []
        // No need, the TokenReserve created just for processing position info, doesn't require any transaction
      };
      const tokenY = {
        publicKey: lbPairAcc.tokenYMint,
        reserve: lbPairAcc.reserveY,
        amount: reserveYBalance,
        mint: mintY,
        owner: tokenYProgram,
        transferHookAccountMetas: []
        // No need, the TokenReserve created just for processing position info, doesn't require any transaction
      };
      const positionData = await DLMM.processPosition(
        program,
        lbPairAcc,
        clock,
        position,
        mintX,
        mintY,
        rewardMint0,
        rewardMint1,
        positionBinArraysMapV2
      );
      if (positionData) {
        positionsMap.set(lbPair.toBase58(), {
          publicKey: lbPair,
          lbPair: lbPairAcc,
          tokenX,
          tokenY,
          lbPairPositionsData: [
            ...positionsMap.get(lbPair.toBase58())?.lbPairPositionsData ?? [],
            {
              publicKey: positionPubkey,
              positionData,
              version
            }
          ]
        });
      }
    }
    return positionsMap;
  }
  static getPricePerLamport(tokenXDecimal, tokenYDecimal, price) {
    return new decimal_default(price).mul(new decimal_default(10 ** (tokenYDecimal - tokenXDecimal))).toString();
  }
  static getBinIdFromPrice(price, binStep, min2) {
    const binStepNum = new decimal_default(binStep).div(new decimal_default(BASIS_POINT_MAX));
    const binId = new decimal_default(price).log().dividedBy(new decimal_default(1).add(binStepNum).log());
    return (min2 ? binId.floor() : binId.ceil()).toNumber();
  }
  /**
   * The function `getLbPairLockInfo` retrieves all pair positions that has locked liquidity.
   * @param {number} [lockDurationOpt] - An optional value indicating the minimum position lock duration that the function should return.
   * Depending on the lbPair activationType, the param should be a number of seconds or a number of slots.
   * @returns The function `getLbPairLockInfo` returns a `Promise` that resolves to a `PairLockInfo`
   * object. The `PairLockInfo` object contains an array of `PositionLockInfo` objects.
   */
  async getLbPairLockInfo(lockDurationOpt) {
    const lockDuration = lockDurationOpt | 0;
    const positionAccounts = await this.program.provider.connection.getProgramAccounts(
      this.program.programId,
      {
        filters: [positionLbPairFilter(this.pubkey)]
      }
    );
    const lbPairPositions = positionAccounts.map((acc) => {
      return wrapPosition(this.program, acc.pubkey, acc.account);
    });
    const clockAccInfo = await this.program.provider.connection.getAccountInfo(
      import_web311.SYSVAR_CLOCK_PUBKEY
    );
    const clock = ClockLayout.decode(clockAccInfo.data);
    const currentPoint = this.lbPair.activationType == 0 ? clock.slot : clock.unixTimestamp;
    const minLockReleasePoint = currentPoint.add(new import_anchor.BN(lockDuration));
    const positionsWithLock = lbPairPositions.filter(
      (p) => p.lockReleasePoint().gt(minLockReleasePoint)
    );
    if (positionsWithLock.length == 0) {
      return {
        positions: []
      };
    }
    const binArrayPubkeySetV2 = /* @__PURE__ */ new Set();
    positionsWithLock.forEach((position) => {
      const binArrayKeys = position.getBinArrayKeysCoverage(
        this.program.programId
      );
      binArrayKeys.forEach((key) => {
        binArrayPubkeySetV2.add(key.toBase58());
      });
    });
    const binArrayPubkeyArrayV2 = Array.from(binArrayPubkeySetV2).map(
      (pubkey) => new import_web311.PublicKey(pubkey)
    );
    const binArraysAccInfo = await chunkedGetMultipleAccountInfos(
      this.program.provider.connection,
      binArrayPubkeyArrayV2
    );
    const positionBinArraysMapV2 = /* @__PURE__ */ new Map();
    for (let i = 0; i < binArraysAccInfo.length; i++) {
      const binArrayPubkey = binArrayPubkeyArrayV2[i];
      const binArrayAccBufferV2 = binArraysAccInfo[i];
      if (!binArrayAccBufferV2)
        throw new Error(
          `Bin Array account ${binArrayPubkey.toBase58()} not found`
        );
      const binArrayAccInfo = decodeAccount(
        this.program,
        "binArray",
        binArrayAccBufferV2.data
      );
      positionBinArraysMapV2.set(binArrayPubkey.toBase58(), binArrayAccInfo);
    }
    const positionsLockInfo = await Promise.all(
      positionsWithLock.map(async (position) => {
        const positionData = await DLMM.processPosition(
          this.program,
          this.lbPair,
          clock,
          position,
          this.tokenX.mint,
          this.tokenY.mint,
          this.rewards[0].mint,
          this.rewards[1].mint,
          positionBinArraysMapV2
        );
        return {
          positionAddress: position.address(),
          owner: position.owner(),
          lockReleasePoint: position.lockReleasePoint().toNumber(),
          tokenXAmount: positionData.totalXAmount,
          tokenYAmount: positionData.totalYAmount
        };
      })
    );
    return {
      positions: positionsLockInfo
    };
  }
  /** Public methods */
  /**
   * Create a new customizable permissionless pair. Support both token and token 2022.
   * @param connection A connection to the Solana cluster.
   * @param binStep The bin step for the pair.
   * @param tokenX The mint of the first token.
   * @param tokenY The mint of the second token.
   * @param activeId The ID of the initial active bin. Represent the starting price.
   * @param feeBps The fee rate for swaps in the pair, in basis points.
   * @param activationType The type of activation for the pair.
   * @param hasAlphaVault Whether the pair has an alpha vault.
   * @param creatorKey The public key of the creator of the pair.
   * @param activationPoint The timestamp at which the pair will be activated.
   * @param opt An options object.
   * @returns A transaction that creates the pair.
   */
  static async createCustomizablePermissionlessLbPair2(connection, binStep, tokenX, tokenY, activeId, feeBps, activationType, hasAlphaVault, creatorKey, activationPoint, creatorPoolOnOffControl, opt) {
    const program = createProgram(connection, opt);
    const [tokenBadgeX] = deriveTokenBadge(tokenX, program.programId);
    const [tokenBadgeY] = deriveTokenBadge(tokenY, program.programId);
    const [
      tokenXAccount,
      tokenYAccount,
      tokenBadgeXAccount,
      tokenBadgeYAccount
    ] = await connection.getMultipleAccountsInfo([
      tokenX,
      tokenY,
      tokenBadgeX,
      tokenBadgeY
    ]);
    const [lbPair] = deriveCustomizablePermissionlessLbPair(
      tokenX,
      tokenY,
      program.programId
    );
    const [reserveX] = deriveReserve(tokenX, lbPair, program.programId);
    const [reserveY] = deriveReserve(tokenY, lbPair, program.programId);
    const [oracle] = deriveOracle(lbPair, program.programId);
    const activeBinArrayIndex = binIdToBinArrayIndex(activeId);
    const binArrayBitmapExtension = isOverflowDefaultBinArrayBitmap(
      activeBinArrayIndex
    ) ? deriveBinArrayBitmapExtension(lbPair, program.programId)[0] : null;
    const [baseFactor, baseFeePowerFactor] = computeBaseFactorFromFeeBps(
      binStep,
      feeBps
    );
    const ixData = {
      activeId: activeId.toNumber(),
      binStep: binStep.toNumber(),
      baseFactor: baseFactor.toNumber(),
      activationType,
      activationPoint: activationPoint ? activationPoint : null,
      hasAlphaVault,
      creatorPoolOnOffControl: creatorPoolOnOffControl ? creatorPoolOnOffControl : false,
      baseFeePowerFactor: baseFeePowerFactor.toNumber(),
      padding: Array(63).fill(0)
    };
    const userTokenX = getAssociatedTokenAddressSync(
      tokenX,
      creatorKey,
      true,
      tokenXAccount.owner
    );
    const userTokenY = getAssociatedTokenAddressSync(
      tokenY,
      creatorKey,
      true,
      tokenYAccount.owner
    );
    return program.methods.initializeCustomizablePermissionlessLbPair2(ixData).accountsPartial({
      tokenBadgeX: tokenBadgeXAccount ? tokenBadgeX : program.programId,
      tokenBadgeY: tokenBadgeYAccount ? tokenBadgeY : program.programId,
      lbPair,
      reserveX,
      reserveY,
      binArrayBitmapExtension,
      tokenMintX: tokenX,
      tokenMintY: tokenY,
      oracle,
      systemProgram: import_web311.SystemProgram.programId,
      userTokenX,
      userTokenY,
      funder: creatorKey,
      tokenProgramX: tokenXAccount.owner,
      tokenProgramY: tokenYAccount.owner
    }).transaction();
  }
  /**
   * Create a new customizable permissionless pair. Support only token program.
   * @param connection A connection to the Solana cluster.
   * @param binStep The bin step for the pair.
   * @param tokenX The mint of the first token.
   * @param tokenY The mint of the second token.
   * @param activeId The ID of the initial active bin. Represent the starting price.
   * @param feeBps The fee rate for swaps in the pair, in basis points.
   * @param activationType The type of activation for the pair.
   * @param hasAlphaVault Whether the pair has an alpha vault.
   * @param creatorKey The public key of the creator of the pair.
   * @param activationPoint The timestamp at which the pair will be activated.
   * @param opt An options object.
   * @returns A transaction that creates the pair.
   */
  static async createCustomizablePermissionlessLbPair(connection, binStep, tokenX, tokenY, activeId, feeBps, activationType, hasAlphaVault, creatorKey, activationPoint, creatorPoolOnOffControl, opt) {
    const program = createProgram(connection, opt);
    const [lbPair] = deriveCustomizablePermissionlessLbPair(
      tokenX,
      tokenY,
      program.programId
    );
    const [reserveX] = deriveReserve(tokenX, lbPair, program.programId);
    const [reserveY] = deriveReserve(tokenY, lbPair, program.programId);
    const [oracle] = deriveOracle(lbPair, program.programId);
    const activeBinArrayIndex = binIdToBinArrayIndex(activeId);
    const binArrayBitmapExtension = isOverflowDefaultBinArrayBitmap(
      activeBinArrayIndex
    ) ? deriveBinArrayBitmapExtension(lbPair, program.programId)[0] : null;
    const [baseFactor, baseFeePowerFactor] = computeBaseFactorFromFeeBps(
      binStep,
      feeBps
    );
    if (!baseFeePowerFactor.isZero()) {
      throw "base factor for the give fee bps overflow u16";
    }
    const ixData = {
      activeId: activeId.toNumber(),
      binStep: binStep.toNumber(),
      baseFactor: baseFactor.toNumber(),
      activationType,
      activationPoint: activationPoint ? activationPoint : null,
      hasAlphaVault,
      baseFeePowerFactor: 0,
      creatorPoolOnOffControl: creatorPoolOnOffControl ? creatorPoolOnOffControl : false,
      padding: Array(63).fill(0)
    };
    const userTokenX = getAssociatedTokenAddressSync(tokenX, creatorKey);
    const userTokenY = getAssociatedTokenAddressSync(tokenY, creatorKey);
    return program.methods.initializeCustomizablePermissionlessLbPair(ixData).accountsPartial({
      lbPair,
      reserveX,
      reserveY,
      binArrayBitmapExtension,
      tokenMintX: tokenX,
      tokenMintY: tokenY,
      oracle,
      systemProgram: import_web311.SystemProgram.programId,
      userTokenX,
      userTokenY,
      funder: creatorKey
    }).transaction();
  }
  /**
   * Create a new liquidity pair. Support only token program.
   * @param connection A connection to the Solana cluster.
   * @param funder The public key of the funder of the pair.
   * @param tokenX The mint of the first token.
   * @param tokenY The mint of the second token.
   * @param binStep The bin step for the pair.
   * @param baseFactor The base factor for the pair.
   * @param presetParameter The public key of the preset parameter account.
   * @param activeId The ID of the initial active bin. Represent the starting price.
   * @param opt An options object.
   * @returns A transaction that creates the pair.
   * @throws If the pair already exists.
   */
  static async createLbPair(connection, funder, tokenX, tokenY, binStep, baseFactor, presetParameter, activeId, opt) {
    const program = createProgram(connection, opt);
    const existsPool = await this.getPairPubkeyIfExists(
      connection,
      tokenX,
      tokenY,
      binStep,
      baseFactor,
      new import_anchor.BN(0)
    );
    if (existsPool) {
      throw new Error("Pool already exists");
    }
    const [lbPair] = deriveLbPair2(
      tokenX,
      tokenY,
      binStep,
      baseFactor,
      program.programId
    );
    const [reserveX] = deriveReserve(tokenX, lbPair, program.programId);
    const [reserveY] = deriveReserve(tokenY, lbPair, program.programId);
    const [oracle] = deriveOracle(lbPair, program.programId);
    const activeBinArrayIndex = binIdToBinArrayIndex(activeId);
    const binArrayBitmapExtension = isOverflowDefaultBinArrayBitmap(
      activeBinArrayIndex
    ) ? deriveBinArrayBitmapExtension(lbPair, program.programId)[0] : null;
    return program.methods.initializeLbPair(activeId.toNumber(), binStep.toNumber()).accountsPartial({
      funder,
      lbPair,
      rent: import_web311.SYSVAR_RENT_PUBKEY,
      reserveX,
      reserveY,
      binArrayBitmapExtension,
      tokenMintX: tokenX,
      tokenMintY: tokenY,
      tokenProgram: TOKEN_PROGRAM_ID,
      oracle,
      presetParameter,
      systemProgram: import_web311.SystemProgram.programId
    }).transaction();
  }
  /**
   * Create a new liquidity pair. Support both token and token2022 program.
   * @param connection A connection to the Solana cluster.
   * @param funder The public key of the funder of the pair.
   * @param tokenX The mint of the first token.
   * @param tokenY The mint of the second token.
   * @param presetParameter The public key of the preset parameter account.
   * @param activeId The ID of the initial active bin. Represent the starting price.
   * @param opt An options object.
   * @returns A transaction that creates the pair.
   * @throws If the pair already exists.
   */
  static async createLbPair2(connection, funder, tokenX, tokenY, presetParameter, activeId, opt) {
    const program = createProgram(connection, opt);
    const [tokenBadgeX] = deriveTokenBadge(tokenX, program.programId);
    const [tokenBadgeY] = deriveTokenBadge(tokenY, program.programId);
    const [
      tokenXAccount,
      tokenYAccount,
      tokenBadgeXAccount,
      tokenBadgeYAccount
    ] = await connection.getMultipleAccountsInfo([
      tokenX,
      tokenY,
      tokenBadgeX,
      tokenBadgeY
    ]);
    const presetParameterState = await program.account.presetParameter2.fetch(
      presetParameter
    );
    const existsPool = await this.getPairPubkeyIfExists(
      connection,
      tokenX,
      tokenY,
      new import_anchor.BN(presetParameterState.binStep),
      new import_anchor.BN(presetParameterState.baseFactor),
      new import_anchor.BN(presetParameterState.baseFeePowerFactor),
      {
        cluster: opt?.cluster,
        programId: opt?.programId
      }
    );
    if (existsPool) {
      throw new Error("Pool already exists");
    }
    const [lbPair] = deriveLbPairWithPresetParamWithIndexKey(
      presetParameter,
      tokenX,
      tokenY,
      program.programId
    );
    const [reserveX] = deriveReserve(tokenX, lbPair, program.programId);
    const [reserveY] = deriveReserve(tokenY, lbPair, program.programId);
    const [oracle] = deriveOracle(lbPair, program.programId);
    const activeBinArrayIndex = binIdToBinArrayIndex(activeId);
    const binArrayBitmapExtension = isOverflowDefaultBinArrayBitmap(
      activeBinArrayIndex
    ) ? deriveBinArrayBitmapExtension(lbPair, program.programId)[0] : null;
    return program.methods.initializeLbPair2({
      activeId: activeId.toNumber(),
      padding: Array(96).fill(0)
    }).accountsPartial({
      funder,
      lbPair,
      reserveX,
      reserveY,
      binArrayBitmapExtension,
      tokenMintX: tokenX,
      tokenMintY: tokenY,
      tokenBadgeX: tokenBadgeXAccount ? tokenBadgeX : program.programId,
      tokenBadgeY: tokenBadgeYAccount ? tokenBadgeY : program.programId,
      tokenProgramX: tokenXAccount.owner,
      tokenProgramY: tokenYAccount.owner,
      oracle,
      presetParameter,
      systemProgram: import_web311.SystemProgram.programId
    }).transaction();
  }
  /**
   * The function `refetchStates` retrieves and updates various states and data related to bin arrays
   * and lb pairs.
   */
  async refetchStates() {
    const binArrayBitmapExtensionPubkey = deriveBinArrayBitmapExtension(
      this.pubkey,
      this.program.programId
    )[0];
    const [
      lbPairAccountInfo,
      binArrayBitmapExtensionAccountInfo,
      reserveXAccountInfo,
      reserveYAccountInfo,
      mintXAccountInfo,
      mintYAccountInfo,
      reward0VaultAccountInfo,
      reward1VaultAccountInfo,
      rewardMint0AccountInfo,
      rewardMint1AccountInfo,
      clockAccountInfo
    ] = await chunkedGetMultipleAccountInfos(this.program.provider.connection, [
      this.pubkey,
      binArrayBitmapExtensionPubkey,
      this.lbPair.reserveX,
      this.lbPair.reserveY,
      this.lbPair.tokenXMint,
      this.lbPair.tokenYMint,
      this.lbPair.rewardInfos[0].vault,
      this.lbPair.rewardInfos[1].vault,
      this.lbPair.rewardInfos[0].mint,
      this.lbPair.rewardInfos[1].mint,
      import_web311.SYSVAR_CLOCK_PUBKEY
    ]);
    const lbPairState = decodeAccount(
      this.program,
      "lbPair",
      lbPairAccountInfo.data
    );
    if (binArrayBitmapExtensionAccountInfo) {
      const binArrayBitmapExtensionState = decodeAccount(
        this.program,
        "binArrayBitmapExtension",
        binArrayBitmapExtensionAccountInfo.data
      );
      if (binArrayBitmapExtensionState) {
        this.binArrayBitmapExtension = {
          account: binArrayBitmapExtensionState,
          publicKey: binArrayBitmapExtensionPubkey
        };
      }
    }
    const reserveXBalance = AccountLayout.decode(reserveXAccountInfo.data);
    const reserveYBalance = AccountLayout.decode(reserveYAccountInfo.data);
    const [
      tokenXTransferHook,
      tokenYTransferHook,
      reward0TransferHook,
      reward1TransferHook
    ] = await Promise.all([
      getExtraAccountMetasForTransferHook(
        this.program.provider.connection,
        lbPairState.tokenXMint,
        mintXAccountInfo
      ),
      getExtraAccountMetasForTransferHook(
        this.program.provider.connection,
        lbPairState.tokenYMint,
        mintYAccountInfo
      ),
      rewardMint0AccountInfo ? getExtraAccountMetasForTransferHook(
        this.program.provider.connection,
        lbPairState.rewardInfos[0].mint,
        rewardMint0AccountInfo
      ) : [],
      rewardMint1AccountInfo ? getExtraAccountMetasForTransferHook(
        this.program.provider.connection,
        lbPairState.rewardInfos[1].mint,
        rewardMint1AccountInfo
      ) : []
    ]);
    const mintX = unpackMint(
      this.tokenX.publicKey,
      mintXAccountInfo,
      mintXAccountInfo.owner
    );
    const mintY = unpackMint(
      this.tokenY.publicKey,
      mintYAccountInfo,
      mintYAccountInfo.owner
    );
    this.tokenX = {
      amount: reserveXBalance.amount,
      mint: mintX,
      publicKey: lbPairState.tokenXMint,
      reserve: lbPairState.reserveX,
      owner: mintXAccountInfo.owner,
      transferHookAccountMetas: tokenXTransferHook
    };
    this.tokenY = {
      amount: reserveYBalance.amount,
      mint: mintY,
      publicKey: lbPairState.tokenYMint,
      reserve: lbPairState.reserveY,
      owner: mintYAccountInfo.owner,
      transferHookAccountMetas: tokenYTransferHook
    };
    this.rewards[0] = null;
    this.rewards[1] = null;
    if (!lbPairState.rewardInfos[0].mint.equals(import_web311.PublicKey.default)) {
      this.rewards[0] = {
        publicKey: lbPairState.rewardInfos[0].mint,
        reserve: lbPairState.rewardInfos[0].vault,
        mint: unpackMint(
          lbPairState.rewardInfos[0].mint,
          rewardMint0AccountInfo,
          rewardMint0AccountInfo.owner
        ),
        amount: AccountLayout.decode(reward0VaultAccountInfo.data).amount,
        owner: rewardMint0AccountInfo.owner,
        transferHookAccountMetas: reward0TransferHook
      };
    }
    if (!lbPairState.rewardInfos[1].mint.equals(import_web311.PublicKey.default)) {
      this.rewards[1] = {
        publicKey: lbPairState.rewardInfos[1].mint,
        reserve: lbPairState.rewardInfos[1].vault,
        mint: unpackMint(
          lbPairState.rewardInfos[1].mint,
          rewardMint1AccountInfo,
          rewardMint1AccountInfo.owner
        ),
        amount: AccountLayout.decode(reward1VaultAccountInfo.data).amount,
        owner: rewardMint1AccountInfo.owner,
        transferHookAccountMetas: reward1TransferHook
      };
    }
    const clock = ClockLayout.decode(clockAccountInfo.data);
    this.clock = clock;
    this.lbPair = lbPairState;
  }
  /**
   * Set the status of a permissionless LB pair to either enabled or disabled. This require pool field `creator_pool_on_off_control` to be true and type `CustomizablePermissionless`.
   * Pool creator can enable/disable the pair anytime before the pool is opened / activated. Once the pool activation time is passed, the pool creator can only enable the pair.
   * Useful for token launches which do not have fixed activation time.
   * @param enable If true, the pair will be enabled. If false, the pair will be disabled.
   * @param creator The public key of the pool creator.
   * @returns a Promise that resolves to the transaction.
   */
  async setPairStatusPermissionless(enable, creator) {
    const status = enable ? 0 : 1;
    const tx = await this.program.methods.setPairStatusPermissionless(status).accountsPartial({
      lbPair: this.pubkey,
      creator
    }).transaction();
    const { blockhash, lastValidBlockHeight } = await this.program.provider.connection.getLatestBlockhash("confirmed");
    return new import_web311.Transaction({
      feePayer: this.lbPair.creator,
      blockhash,
      lastValidBlockHeight
    }).add(tx);
  }
  /**
   * The function `getBinArrays` returns an array of `BinArrayAccount` objects
   * @returns a Promise that resolves to an array of BinArrayAccount objects.
   */
  async getBinArrays() {
    return this.program.account.binArray.all([
      binArrayLbPairFilter(this.pubkey)
    ]);
  }
  /**
   * The function `getBinArrayAroundActiveBin` retrieves a specified number of `BinArrayAccount`
   * objects from the blockchain, based on the active bin and its surrounding bin arrays.
   * @param
   *    swapForY - The `swapForY` parameter is a boolean value that indicates whether the swap is using quote token as input.
   *    [count=4] - The `count` parameter is the number of bin arrays to retrieve on left and right respectively. By default, it is set to 4.
   * @returns an array of `BinArrayAccount` objects.
   */
  async getBinArrayForSwap(swapForY, count = 4) {
    await this.refetchStates();
    const binArraysPubkey = /* @__PURE__ */ new Set();
    let shouldStop = false;
    let activeIdToLoop = this.lbPair.activeId;
    while (!shouldStop) {
      const binArrayIndex = findNextBinArrayIndexWithLiquidity(
        swapForY,
        new import_anchor.BN(activeIdToLoop),
        this.lbPair,
        this.binArrayBitmapExtension?.account ?? null
      );
      if (binArrayIndex === null)
        shouldStop = true;
      else {
        const [binArrayPubKey] = deriveBinArray(
          this.pubkey,
          binArrayIndex,
          this.program.programId
        );
        binArraysPubkey.add(binArrayPubKey.toBase58());
        const [lowerBinId, upperBinId] = getBinArrayLowerUpperBinId(binArrayIndex);
        activeIdToLoop = swapForY ? lowerBinId.toNumber() - 1 : upperBinId.toNumber() + 1;
      }
      if (binArraysPubkey.size === count)
        shouldStop = true;
    }
    const accountsToFetch = Array.from(binArraysPubkey).map(
      (pubkey) => new import_web311.PublicKey(pubkey)
    );
    const binArraysAccInfoBuffer = await chunkedGetMultipleAccountInfos(
      this.program.provider.connection,
      accountsToFetch
    );
    const binArrays = await Promise.all(
      binArraysAccInfoBuffer.map(async (accInfo, idx) => {
        const account = decodeAccount(
          this.program,
          "binArray",
          accInfo.data
        );
        const publicKey2 = accountsToFetch[idx];
        return {
          account,
          publicKey: publicKey2
        };
      })
    );
    return binArrays;
  }
  /**
   * The function `calculateFeeInfo` calculates the base fee rate percentage and maximum fee rate percentage
   * given the base factor, bin step, and optional base fee power factor.
   * @param baseFactor - The base factor of the pair.
   * @param binStep - The bin step of the pair.
   * @param baseFeePowerFactor - Optional parameter to allow small bin step to have bigger fee rate. Default to 0.
   * @returns an object of type `Omit<FeeInfo, "protocolFeePercentage">` with the following properties: baseFeeRatePercentage and maxFeeRatePercentage.
   */
  static calculateFeeInfo(baseFactor, binStep, baseFeePowerFactor) {
    const baseFeeRate = new import_anchor.BN(baseFactor).mul(new import_anchor.BN(binStep)).mul(new import_anchor.BN(10)).mul(new import_anchor.BN(10).pow(new import_anchor.BN(baseFeePowerFactor ?? 0)));
    const baseFeeRatePercentage = new decimal_default(baseFeeRate.toString()).mul(new decimal_default(100)).div(new decimal_default(FEE_PRECISION.toString()));
    const maxFeeRatePercentage = new decimal_default(MAX_FEE_RATE.toString()).mul(new decimal_default(100)).div(new decimal_default(FEE_PRECISION.toString()));
    return {
      baseFeeRatePercentage,
      maxFeeRatePercentage
    };
  }
  /**
   * The function `getFeeInfo` calculates and returns the base fee rate percentage, maximum fee rate
   * percentage, and protocol fee percentage.
   * @returns an object of type `FeeInfo` with the following properties: baseFeeRatePercentage, maxFeeRatePercentage, and protocolFeePercentage.
   */
  getFeeInfo() {
    const { baseFactor, protocolShare } = this.lbPair.parameters;
    const { baseFeeRatePercentage, maxFeeRatePercentage } = DLMM.calculateFeeInfo(
      baseFactor,
      this.lbPair.binStep,
      this.lbPair.parameters.baseFeePowerFactor
    );
    const protocolFeePercentage = new decimal_default(protocolShare.toString()).mul(new decimal_default(100)).div(new decimal_default(BASIS_POINT_MAX));
    return {
      baseFeeRatePercentage,
      maxFeeRatePercentage,
      protocolFeePercentage
    };
  }
  /**
   * The function calculates and returns a dynamic fee
   * @returns a Decimal value representing the dynamic fee.
   */
  getDynamicFee() {
    let vParameterClone = Object.assign({}, this.lbPair.vParameters);
    let activeId = new import_anchor.BN(this.lbPair.activeId);
    const sParameters3 = this.lbPair.parameters;
    const currentTimestamp = Date.now() / 1e3;
    DLMM.updateReference(
      activeId.toNumber(),
      vParameterClone,
      sParameters3,
      currentTimestamp
    );
    DLMM.updateVolatilityAccumulator(
      vParameterClone,
      sParameters3,
      activeId.toNumber()
    );
    const totalFee = getTotalFee(
      this.lbPair.binStep,
      sParameters3,
      vParameterClone
    );
    return new decimal_default(totalFee.toString()).div(new decimal_default(FEE_PRECISION.toString())).mul(100);
  }
  /**
   * The function `getEmissionRate` returns the emission rates for two rewards.
   * @returns an object of type `EmissionRate`. The object has two properties: `rewardOne` and
   * `rewardTwo`, both of which are of type `Decimal`.
   */
  getEmissionRate() {
    const now = Date.now() / 1e3;
    const [rewardOneEmissionRate, rewardTwoEmissionRate] = this.lbPair.rewardInfos.map(
      ({ rewardRate, rewardDurationEnd }) => now > rewardDurationEnd.toNumber() ? void 0 : rewardRate
    );
    return {
      rewardOne: rewardOneEmissionRate ? new decimal_default(rewardOneEmissionRate.toString()).div(PRECISION) : void 0,
      rewardTwo: rewardTwoEmissionRate ? new decimal_default(rewardTwoEmissionRate.toString()).div(PRECISION) : void 0
    };
  }
  /**
   * The function `getBinsAroundActiveBin` retrieves a specified number of bins to the left and right
   * of the active bin and returns them along with the active bin ID.
   * @param {number} numberOfBinsToTheLeft - The parameter `numberOfBinsToTheLeft` represents the
   * number of bins to the left of the active bin that you want to retrieve. It determines how many
   * bins you want to include in the result that are positioned to the left of the active bin.
   * @param {number} numberOfBinsToTheRight - The parameter `numberOfBinsToTheRight` represents the
   * number of bins to the right of the active bin that you want to retrieve.
   * @returns an object with two properties: "activeBin" and "bins". The value of "activeBin" is the
   * value of "this.lbPair.activeId", and the value of "bins" is the result of calling the "getBins"
   * function with the specified parameters.
   */
  async getBinsAroundActiveBin(numberOfBinsToTheLeft, numberOfBinsToTheRight) {
    const lowerBinId = this.lbPair.activeId - numberOfBinsToTheLeft - 1;
    const upperBinId = this.lbPair.activeId + numberOfBinsToTheRight + 1;
    const bins = await this.getBins(
      this.pubkey,
      lowerBinId,
      upperBinId,
      this.tokenX.mint.decimals,
      this.tokenY.mint.decimals
    );
    return { activeBin: this.lbPair.activeId, bins };
  }
  /**
   * The function `getBinsBetweenMinAndMaxPrice` retrieves a list of bins within a specified price
   * range.
   * @param {number} minPrice - The minimum price value for filtering the bins.
   * @param {number} maxPrice - The `maxPrice` parameter is the maximum price value that you want to
   * use for filtering the bins.
   * @returns an object with two properties: "activeBin" and "bins". The value of "activeBin" is the
   * active bin ID of the lbPair, and the value of "bins" is an array of BinLiquidity objects.
   */
  async getBinsBetweenMinAndMaxPrice(minPrice, maxPrice) {
    const lowerBinId = this.getBinIdFromPrice(minPrice, true) - 1;
    const upperBinId = this.getBinIdFromPrice(maxPrice, false) + 1;
    const bins = await this.getBins(
      this.pubkey,
      lowerBinId,
      upperBinId,
      this.tokenX.mint.decimals,
      this.tokenX.mint.decimals
    );
    return { activeBin: this.lbPair.activeId, bins };
  }
  /**
   * The function `getBinsBetweenLowerAndUpperBound` retrieves a list of bins between a lower and upper
   * bin ID and returns the active bin ID and the list of bins.
   * @param {number} lowerBinId - The lowerBinId parameter is a number that represents the ID of the
   * lowest bin.
   * @param {number} upperBinId - The upperBinID parameter is a number that represents the ID of the
   * highest bin.
   * @param {BinArray} [lowerBinArrays] - The `lowerBinArrays` parameter is an optional parameter of
   * type `BinArray`. It represents an array of bins that are below the lower bin ID.
   * @param {BinArray} [upperBinArrays] - The parameter `upperBinArrays` is an optional parameter of
   * type `BinArray`. It represents an array of bins that are above the upper bin ID.
   * @returns an object with two properties: "activeBin" and "bins". The value of "activeBin" is the
   * active bin ID of the lbPair, and the value of "bins" is an array of BinLiquidity objects.
   */
  async getBinsBetweenLowerAndUpperBound(lowerBinId, upperBinId, lowerBinArray, upperBinArray) {
    const bins = await this.getBins(
      this.pubkey,
      lowerBinId,
      upperBinId,
      this.tokenX.mint.decimals,
      this.tokenY.mint.decimals,
      lowerBinArray,
      upperBinArray
    );
    return { activeBin: this.lbPair.activeId, bins };
  }
  /**
   * The function converts a real price of bin to a lamport value
   * @param {number} price - The `price` parameter is a number representing the price of a token.
   * @returns {string} price per Lamport of bin
   */
  toPricePerLamport(price) {
    return DLMM.getPricePerLamport(
      this.tokenX.mint.decimals,
      this.tokenY.mint.decimals,
      price
    );
  }
  /**
   * The function converts a price per lamport value to a real price of bin
   * @param {number} pricePerLamport - The parameter `pricePerLamport` is a number representing the
   * price per lamport.
   * @returns {string} real price of bin
   */
  fromPricePerLamport(pricePerLamport) {
    return new decimal_default(pricePerLamport).div(
      new decimal_default(
        10 ** (this.tokenY.mint.decimals - this.tokenX.mint.decimals)
      )
    ).toString();
  }
  /**
   * The function retrieves the active bin ID and its corresponding price.
   * @returns an object with two properties: "binId" which is a number, and "price" which is a string.
   */
  async getActiveBin() {
    const { activeId } = await this.program.account.lbPair.fetch(this.pubkey);
    const [activeBinState] = await this.getBins(
      this.pubkey,
      activeId,
      activeId,
      this.tokenX.mint.decimals,
      this.tokenY.mint.decimals
    );
    return activeBinState;
  }
  /**
   * The function get bin ID based on a given price and a boolean flag indicating whether to
   * round down or up.
   * @param {number} price - The price parameter is a number that represents the price value.
   * @param {boolean} min - The "min" parameter is a boolean value that determines whether to round
   * down or round up the calculated binId. If "min" is true, the binId will be rounded down (floor),
   * otherwise it will be rounded up (ceil).
   * @returns {number} which is the binId calculated based on the given price and whether the minimum
   * value should be used.
   */
  getBinIdFromPrice(price, min2) {
    return DLMM.getBinIdFromPrice(price, this.lbPair.binStep, min2);
  }
  /**
   * The function `getPositionsByUserAndLbPair` retrieves positions by user and LB pair, including
   * active bin and user positions.
   * @param {PublicKey} [userPubKey] - The `userPubKey` parameter is an optional parameter of type
   * `PublicKey`. It represents the public key of a user. If no `userPubKey` is provided, the function
   * will return an object with an empty `userPositions` array and the active bin information obtained
   * from the `getActive
   * @returns The function `getPositionsByUserAndLbPair` returns a Promise that resolves to an object
   * with two properties:
   *    - "activeBin" which is an object with two properties: "binId" and "price". The value of "binId"
   *     is the active bin ID of the lbPair, and the value of "price" is the price of the active bin.
   *   - "userPositions" which is an array of Position objects.
   */
  async getPositionsByUserAndLbPair(userPubKey) {
    const promiseResults = await Promise.all([
      this.getActiveBin(),
      userPubKey && this.program.provider.connection.getProgramAccounts(
        this.program.programId,
        {
          filters: [
            positionV2Filter(),
            positionOwnerFilter(userPubKey),
            positionLbPairFilter(this.pubkey)
          ]
        }
      )
    ]);
    const [activeBin, positionsV2] = promiseResults;
    if (!activeBin) {
      throw new Error("Error fetching active bin");
    }
    if (!userPubKey) {
      return {
        activeBin,
        userPositions: []
      };
    }
    const positions = [
      ...positionsV2.map(
        (p) => wrapPosition(this.program, p.pubkey, p.account)
      )
    ];
    if (!positions) {
      throw new Error("Error fetching positions");
    }
    const binArrayPubkeySetV2 = /* @__PURE__ */ new Set();
    positions.forEach((position) => {
      const binArrayKeys = position.getBinArrayKeysCoverage(
        this.program.programId
      );
      binArrayKeys.forEach((key) => {
        binArrayPubkeySetV2.add(key.toBase58());
      });
    });
    const binArrayPubkeyArrayV2 = Array.from(binArrayPubkeySetV2).map(
      (pubkey) => new import_web311.PublicKey(pubkey)
    );
    const lbPairAndBinArrays = await chunkedGetMultipleAccountInfos(
      this.program.provider.connection,
      [this.pubkey, import_web311.SYSVAR_CLOCK_PUBKEY, ...binArrayPubkeyArrayV2]
    );
    const [lbPairAccInfo, clockAccInfo, ...binArraysAccInfo] = lbPairAndBinArrays;
    const positionBinArraysMapV2 = /* @__PURE__ */ new Map();
    for (let i = 0; i < binArraysAccInfo.length; i++) {
      const binArrayPubkey = binArrayPubkeyArrayV2[i];
      const binArrayAccBufferV2 = binArraysAccInfo[i];
      if (binArrayAccBufferV2) {
        const binArrayAccInfo = decodeAccount(
          this.program,
          "binArray",
          binArrayAccBufferV2.data
        );
        positionBinArraysMapV2.set(binArrayPubkey.toBase58(), binArrayAccInfo);
      }
    }
    if (!lbPairAccInfo)
      throw new Error(`LB Pair account ${this.pubkey.toBase58()} not found`);
    const clock = ClockLayout.decode(clockAccInfo.data);
    const userPositions = await Promise.all(
      positions.map(async (position) => {
        return {
          publicKey: position.address(),
          positionData: await DLMM.processPosition(
            this.program,
            this.lbPair,
            clock,
            position,
            this.tokenX.mint,
            this.tokenY.mint,
            this.rewards[0]?.mint,
            this.rewards[1]?.mint,
            positionBinArraysMapV2
          ),
          version: position.version()
        };
      })
    );
    return {
      activeBin,
      userPositions
    };
  }
  /**
   * Estimates the cost to extend a position by a specified number of bins. Max position length is 1400
   *
   * The function calculates the rent cost required to expand a position and the cost
   * to create necessary bin arrays for the new position range.
   *
   * @param currentMinBinId - The current minimum bin ID of the position.
   * @param currentMaxBinId - The current maximum bin ID of the position.
   * @param binCountToExpand - The number of bins to expand the position by.
   * @returns An object containing:
   *   - positionExtendCost: The estimated rent cost in lamports for extending the position.
   *   - binArrayCost: The estimated cost for creating necessary bin arrays.
   */
  async quoteExtendPosition(currentMinBinId, currentMaxBinId, binCountToExpand) {
    const positionExtendCost = await getPositionExpandRentExemption(
      currentMinBinId,
      currentMaxBinId,
      this.program.provider.connection,
      binCountToExpand
    );
    const lowerBinArrayIndex = binIdToBinArrayIndex(currentMinBinId);
    const upperBinArrayIndex = binIdToBinArrayIndex(currentMaxBinId);
    const binArraysCount = (await this.binArraysToBeCreate(lowerBinArrayIndex, upperBinArrayIndex)).length;
    const binArrayCost = new decimal_default(binArraysCount).mul(
      new decimal_default(BIN_ARRAY_FEE)
    );
    return {
      positionExtendCost: new decimal_default(positionExtendCost).div(
        new decimal_default(import_web311.LAMPORTS_PER_SOL)
      ),
      binArrayCost
    };
  }
  async quoteCreatePosition({ strategy }) {
    const { minBinId, maxBinId } = strategy;
    const binCount = maxBinId - minBinId + 1;
    let positionCount = Math.floor(binCount / MAX_BINS_PER_POSITION.toNumber());
    if (binCount % MAX_BINS_PER_POSITION.toNumber() > 0) {
      positionCount++;
    }
    let positionReallocCost = 0;
    let lastUpperBinId = minBinId;
    for (let i = 0; i < positionCount; i++) {
      const lowerBinId = lastUpperBinId;
      const upperBinId = Math.min(
        maxBinId,
        lowerBinId + DEFAULT_BIN_PER_POSITION.toNumber() - 1
      );
      const maxUpperBinId = Math.min(
        maxBinId,
        upperBinId + MAX_BINS_PER_POSITION.toNumber() - 1
      );
      const binToExpand = maxUpperBinId - upperBinId;
      const { positionExtendCost } = await this.quoteExtendPosition(
        new import_anchor.BN(lowerBinId),
        new import_anchor.BN(upperBinId),
        new import_anchor.BN(binToExpand)
      );
      positionReallocCost += positionExtendCost.toNumber();
      lastUpperBinId = upperBinId;
    }
    const lowerBinArrayIndex = binIdToBinArrayIndex(new import_anchor.BN(minBinId));
    const upperBinArrayIndex = import_anchor.BN.max(
      binIdToBinArrayIndex(new import_anchor.BN(maxBinId)),
      lowerBinArrayIndex.add(new import_anchor.BN(1))
    );
    let bitmapExtensionCost = 0;
    if (isOverflowDefaultBinArrayBitmap(lowerBinArrayIndex) || isOverflowDefaultBinArrayBitmap(upperBinArrayIndex)) {
      bitmapExtensionCost = BIN_ARRAY_BITMAP_FEE;
    }
    const binArraysCount = (await this.binArraysToBeCreate(lowerBinArrayIndex, upperBinArrayIndex)).length;
    const transactionCount = Math.ceil(
      (maxBinId - minBinId + 1) / DEFAULT_BIN_PER_POSITION.toNumber()
    );
    const binArrayCost = binArraysCount * BIN_ARRAY_FEE;
    return {
      positionCount,
      positionCost: positionCount * POSITION_FEE,
      positionReallocCost,
      bitmapExtensionCost,
      binArraysCount,
      binArrayCost,
      transactionCount
    };
  }
  /**
   * Creates an empty position and initializes the corresponding bin arrays if needed.
   * @param param0 The settings of the requested new position.
   * @returns A promise that resolves into a transaction for creating the requested position.
   */
  async createEmptyPosition({
    positionPubKey,
    minBinId,
    maxBinId,
    user
  }) {
    const createPositionIx = await this.program.methods.initializePosition(minBinId, maxBinId - minBinId + 1).accountsPartial({
      payer: user,
      position: positionPubKey,
      lbPair: this.pubkey,
      owner: user
    }).instruction();
    const binArrayIndexes = getBinArrayIndexesCoverage(
      new import_anchor.BN(minBinId),
      new import_anchor.BN(maxBinId)
    );
    const createBinArrayIxs = await this.createBinArraysIfNeeded(
      binArrayIndexes,
      user
    );
    const instructions = [createPositionIx, ...createBinArrayIxs];
    const setCUIx = await getEstimatedComputeUnitIxWithBuffer(
      this.program.provider.connection,
      instructions,
      user
    );
    const { blockhash, lastValidBlockHeight } = await this.program.provider.connection.getLatestBlockhash("confirmed");
    return new import_web311.Transaction({
      blockhash,
      lastValidBlockHeight,
      feePayer: user
    }).add(setCUIx, ...instructions);
  }
  /**
   * The function `getPosition` retrieves position information for a given public key and processes it
   * using various data to return a `LbPosition` object.
   * @param {PublicKey} positionPubKey - The `getPosition` function you provided is an asynchronous
   * function that fetches position information based on a given public key. Here's a breakdown of the
   * parameters used in the function:
   * @returns The `getPosition` function returns a Promise that resolves to an object of type
   * `LbPosition`. The object contains the following properties:
   * - `publicKey`: The public key of the position account
   * - `positionData`: Position Object
   * - `version`: The version of the position (in this case, `Position.V2`)
   */
  async getPosition(positionPubKey) {
    const positionAccountInfo = await this.program.provider.connection.getAccountInfo(positionPubKey);
    if (!positionAccountInfo) {
      throw new Error(
        `Position account ${positionPubKey.toBase58()} not found`
      );
    }
    let position = wrapPosition(
      this.program,
      positionPubKey,
      positionAccountInfo
    );
    const binArrayKeys = position.getBinArrayKeysCoverage(
      this.program.programId
    );
    const [clockAccInfo, ...binArrayAccountsInfo] = await chunkedGetMultipleAccountInfos(this.program.provider.connection, [
      import_web311.SYSVAR_CLOCK_PUBKEY,
      ...binArrayKeys
    ]);
    const clock = ClockLayout.decode(clockAccInfo.data);
    const binArrayMap = /* @__PURE__ */ new Map();
    for (let i = 0; i < binArrayAccountsInfo.length; i++) {
      if (binArrayAccountsInfo[i]) {
        const binArrayState = decodeAccount(
          this.program,
          "binArray",
          binArrayAccountsInfo[i].data
        );
        binArrayMap.set(binArrayKeys[i].toBase58(), binArrayState);
      }
    }
    return {
      publicKey: positionPubKey,
      positionData: await DLMM.processPosition(
        this.program,
        this.lbPair,
        clock,
        position,
        this.tokenX.mint,
        this.tokenY.mint,
        this.rewards[0]?.mint,
        this.rewards[1]?.mint,
        binArrayMap
      ),
      version: position.version()
    };
  }
  /**
   * Creates multiple positions and adds liquidity by strategy. It allow parallel execution of transactions.
   * @param positionKeypairGenerator A function that generates a specified number of keypairs.
   * @param totalXAmount The total amount of token X to be added.
   * @param totalYAmount The total amount of token Y to be added.
   * @param strategy The strategy for adding liquidity.
   * @param owner The owner of the position.
   * @param payer The payer of the transaction.
   * @param slippagePercentage The slippage percentage for adding liquidity.
   * @returns An object with two properties: `initPositionIxs` and `addLiquidityIxs`.
   */
  async initializeMultiplePositionAndAddLiquidityByStrategy2(positionKeypairGenerator, totalXAmount, totalYAmount, strategy, owner, payer, slippagePercentage, altAddress) {
    const maxActiveBinSlippage = getAndCapMaxActiveBinSlippage(
      slippagePercentage,
      this.lbPair.binStep,
      MAX_ACTIVE_BIN_SLIPPAGE
    );
    const { minBinId, maxBinId } = strategy;
    const binCount = getBinCount(minBinId, maxBinId);
    const defaultAltAddressString = altAddress ?? ALT_ADDRESS[this.opt?.cluster];
    if (defaultAltAddressString) {
      altAddress = new import_web311.PublicKey(defaultAltAddressString);
    }
    const maxResizeIxAllowed = altAddress ? 5 : 3;
    const maxBinPerParallelizedPosition = DEFAULT_BIN_PER_POSITION.toNumber() + MAX_RESIZE_LENGTH.toNumber() * maxResizeIxAllowed;
    const positionCount = Math.ceil(binCount / maxBinPerParallelizedPosition);
    const positionKeypairs = await positionKeypairGenerator(positionCount);
    const liquidityStrategyParameters = buildLiquidityStrategyParameters(
      totalXAmount,
      totalYAmount,
      new import_anchor.BN(minBinId - this.lbPair.activeId),
      new import_anchor.BN(maxBinId - this.lbPair.activeId),
      new import_anchor.BN(this.lbPair.binStep),
      strategy.singleSidedX,
      new import_anchor.BN(this.lbPair.activeId),
      getLiquidityStrategyParameterBuilder(strategy.strategyType)
    );
    let startBinId = minBinId;
    const response = { instructionsByPositions: [], lookupTableAddress: altAddress };
    for (const position of positionKeypairs) {
      const txsIxs = [];
      const endBinId = Math.min(
        startBinId + maxBinPerParallelizedPosition - 1,
        maxBinId
      );
      const finalPositionWidth = endBinId - startBinId + 1;
      const initialPositionWidth = finalPositionWidth > DEFAULT_BIN_PER_POSITION.toNumber() ? DEFAULT_BIN_PER_POSITION.toNumber() : finalPositionWidth;
      const initPositionIx = await this.program.methods.initializePosition2(startBinId, initialPositionWidth).accountsPartial({
        position: position.publicKey,
        lbPair: this.pubkey,
        owner,
        payer
      }).instruction();
      const extendPositionIxs = [];
      let currentEndBinId = startBinId + initialPositionWidth - 1;
      while (true) {
        if (currentEndBinId == endBinId)
          break;
        currentEndBinId = Math.min(
          currentEndBinId + MAX_RESIZE_LENGTH.toNumber(),
          endBinId
        );
        const increaseLengthIx = await this.program.methods.increasePositionLength2(currentEndBinId).accountsPartial({
          lbPair: this.pubkey,
          position: position.publicKey,
          funder: payer,
          owner
        }).instruction();
        extendPositionIxs.push(increaseLengthIx);
      }
      const addLiquidityIxs = await chunkDepositWithRebalanceEndpoint(
        this,
        strategy,
        slippagePercentage,
        maxActiveBinSlippage,
        position.publicKey,
        startBinId,
        endBinId,
        liquidityStrategyParameters,
        owner,
        payer,
        true,
        this.opt?.skipSolWrappingOperation
      );
      for (const instructions of addLiquidityIxs) {
        const txIxs = [];
        txIxs.push(initPositionIx);
        txIxs.push(...extendPositionIxs);
        txIxs.push(...instructions);
        const setCuIx = await getEstimatedComputeUnitIxWithBuffer(
          this.program.provider.connection,
          txIxs,
          payer,
          0.1,
          altAddress
        );
        txIxs.unshift(setCuIx);
        txsIxs.push(txIxs);
      }
      response.instructionsByPositions.push({
        positionKeypair: position,
        transactionInstructions: txsIxs
      });
      startBinId = endBinId + 1;
    }
    return response;
  }
  /**
   * Creates multiple positions and adds liquidity by strategy without chainsaw issues.
   * @param positionKeypairGenerator A function that generates a specified number of keypairs.
   * @param totalXAmount The total amount of token X to be added.
   * @param totalYAmount The total amount of token Y to be added.
   * @param strategy The strategy for adding liquidity.
   * @param owner The owner of the position.
   * @param payer The payer of the transaction.
   * @param slippagePercentage The slippage percentage for adding liquidity.
   * @returns An object with two properties: `initPositionIxs` and `addLiquidityIxs`.
   */
  async initializeMultiplePositionAndAddLiquidityByStrategy(positionKeypairGenerator, totalXAmount, totalYAmount, strategy, owner, payer, slippagePercentage) {
    const maxActiveBinSlippage = getAndCapMaxActiveBinSlippage(
      slippagePercentage,
      this.lbPair.binStep,
      MAX_ACTIVE_BIN_SLIPPAGE
    );
    const { minBinId, maxBinId } = strategy;
    const binCount = getBinCount(minBinId, maxBinId);
    const positionCount = getPositionCountByBinCount(binCount);
    const positionKeypairs = await positionKeypairGenerator(positionCount);
    const liquidityStrategyParameters = buildLiquidityStrategyParameters(
      totalXAmount,
      totalYAmount,
      new import_anchor.BN(minBinId - this.lbPair.activeId),
      new import_anchor.BN(maxBinId - this.lbPair.activeId),
      new import_anchor.BN(this.lbPair.binStep),
      strategy.singleSidedX,
      new import_anchor.BN(this.lbPair.activeId),
      getLiquidityStrategyParameterBuilder(strategy.strategyType)
    );
    const instructionsByPositions = [];
    let startBinId = minBinId;
    const initializeAtaIxs = [];
    if (!this.tokenX.publicKey.equals(NATIVE_MINT)) {
      const ownerAtaX = getAssociatedTokenAddressSync(
        this.tokenX.publicKey,
        owner,
        true,
        this.tokenX.owner
      );
      initializeAtaIxs.push(
        createAssociatedTokenAccountIdempotentInstruction(
          owner,
          ownerAtaX,
          owner,
          this.tokenX.publicKey,
          this.tokenX.owner
        )
      );
    }
    if (!this.tokenY.publicKey.equals(NATIVE_MINT)) {
      const ownerAtaY = getAssociatedTokenAddressSync(
        this.tokenY.publicKey,
        owner,
        true,
        this.tokenY.owner
      );
      initializeAtaIxs.push(
        createAssociatedTokenAccountIdempotentInstruction(
          owner,
          ownerAtaY,
          owner,
          this.tokenY.publicKey,
          this.tokenY.owner
        )
      );
    }
    for (const position of positionKeypairs) {
      const endBinId = Math.min(
        startBinId + MAX_BINS_PER_POSITION.toNumber() - 1,
        maxBinId
      );
      const binCount2 = getBinCount(startBinId, endBinId);
      const positionWidth = Math.min(
        binCount2,
        DEFAULT_BIN_PER_POSITION.toNumber()
      );
      const initPositionIx = await this.program.methods.initializePosition(startBinId, positionWidth).accountsPartial({
        position: position.publicKey,
        lbPair: this.pubkey,
        owner,
        payer
      }).instruction();
      const chunkedAddLiquidityIx = await chunkDepositWithRebalanceEndpoint(
        this,
        strategy,
        slippagePercentage,
        maxActiveBinSlippage,
        position.publicKey,
        startBinId,
        endBinId,
        liquidityStrategyParameters,
        owner,
        payer,
        false,
        this.opt?.skipSolWrappingOperation
      );
      instructionsByPositions.push({
        positionKeypair: position,
        initializePositionIx: initPositionIx,
        initializeAtaIxs,
        addLiquidityIxs: chunkedAddLiquidityIx
      });
      startBinId = endBinId + 1;
    }
    return {
      instructionsByPositions
    };
  }
  /**
   * Adds liquidity to an existing position using a specified strategy, allowing for chunkable transactions.
   * If adding liquidity to bin out of position range, it will automatically expand. The limitation is 70 bins.
   *
   * @param {TInitializePositionAndAddLiquidityParamsByStrategy} params - The parameters required for adding liquidity.
   * @param {PublicKey} params.positionPubKey - The public key of the position to which liquidity is being added.
   * @param {BN} params.totalXAmount - The total amount of token X to be added as liquidity.
   * @param {BN} params.totalYAmount - The total amount of token Y to be added as liquidity.
   * @param {StrategyParameters} params.strategy - The strategy parameters for adding liquidity.
   * @param {PublicKey} params.user - The public key of the user adding liquidity.
   * @param {number} params.slippage - The slippage percentage allowed for the transaction.
   *
   * @returns {Promise<Transaction[]>} A promise that resolves to an array of transactions for adding liquidity.
   */
  async addLiquidityByStrategyChunkable({
    positionPubKey,
    totalXAmount,
    totalYAmount,
    strategy,
    user,
    slippage
  }) {
    const maxActiveBinSlippage = getAndCapMaxActiveBinSlippage(
      slippage,
      this.lbPair.binStep,
      MAX_ACTIVE_BIN_SLIPPAGE
    );
    const { minBinId, maxBinId } = strategy;
    const liquidityStrategyParameters = buildLiquidityStrategyParameters(
      totalXAmount,
      totalYAmount,
      new import_anchor.BN(minBinId - this.lbPair.activeId),
      new import_anchor.BN(maxBinId - this.lbPair.activeId),
      new import_anchor.BN(this.lbPair.binStep),
      strategy.singleSidedX,
      new import_anchor.BN(this.lbPair.activeId),
      getLiquidityStrategyParameterBuilder(strategy.strategyType)
    );
    const chunkedAddLiquidityIx = await chunkDepositWithRebalanceEndpoint(
      this,
      strategy,
      slippage,
      maxActiveBinSlippage,
      positionPubKey,
      minBinId,
      maxBinId,
      liquidityStrategyParameters,
      user,
      user,
      true,
      this.opt?.skipSolWrappingOperation
    );
    const latestBlockhashInfo = await this.program.provider.connection.getLatestBlockhash();
    return chunkedAddLiquidityIx.map((ixs) => {
      return new import_web311.Transaction({
        ...latestBlockhashInfo,
        feePayer: user
      }).add(...ixs);
    });
  }
  /**
   * The function `initializePositionAndAddLiquidityByStrategy` function is used to initializes a position and adds liquidity
   * @param {TInitializePositionAndAddLiquidityParamsByStrategy}
   *    - `positionPubKey`: The public key of the position account. (usually use `new Keypair()`)
   *    - `totalXAmount`: The total amount of token X to be added to the liquidity pool.
   *    - `totalYAmount`: The total amount of token Y to be added to the liquidity pool.
   *    - `strategy`: The strategy parameters to be used for the liquidity pool (Can use `calculateStrategyParameter` to calculate).
   *    - `user`: The public key of the user account.
   *    - `slippage`: The slippage percentage to be used for the liquidity pool.
   * @returns {Promise<Transaction>} The function `initializePositionAndAddLiquidityByStrategy` returns a `Promise` that
   * resolves to either a single `Transaction` object.
   */
  async initializePositionAndAddLiquidityByStrategy({
    positionPubKey,
    totalXAmount,
    totalYAmount,
    strategy,
    user,
    slippage
  }) {
    const { maxBinId, minBinId } = strategy;
    const maxActiveBinSlippage = slippage ? Math.ceil(slippage / (this.lbPair.binStep / 100)) : MAX_ACTIVE_BIN_SLIPPAGE;
    const preInstructions = [];
    const initializePositionIx = await this.program.methods.initializePosition(minBinId, maxBinId - minBinId + 1).accountsPartial({
      payer: user,
      position: positionPubKey,
      lbPair: this.pubkey,
      owner: user
    }).instruction();
    preInstructions.push(initializePositionIx);
    const binArrayIndexes = getBinArrayIndexesCoverage(
      new import_anchor.BN(minBinId),
      new import_anchor.BN(maxBinId)
    );
    const binArrayAccountMetas = getBinArrayAccountMetasCoverage(
      new import_anchor.BN(minBinId),
      new import_anchor.BN(maxBinId),
      this.pubkey,
      this.program.programId
    );
    const createBinArrayIxs = await this.createBinArraysIfNeeded(
      binArrayIndexes,
      user
    );
    preInstructions.push(...createBinArrayIxs);
    const [
      { ataPubKey: userTokenX, ix: createPayerTokenXIx },
      { ataPubKey: userTokenY, ix: createPayerTokenYIx }
    ] = await Promise.all([
      getOrCreateATAInstruction(
        this.program.provider.connection,
        this.tokenX.publicKey,
        user,
        this.tokenX.owner
      ),
      getOrCreateATAInstruction(
        this.program.provider.connection,
        this.tokenY.publicKey,
        user,
        this.tokenY.owner
      )
    ]);
    createPayerTokenXIx && preInstructions.push(createPayerTokenXIx);
    createPayerTokenYIx && preInstructions.push(createPayerTokenYIx);
    if (this.tokenX.publicKey.equals(NATIVE_MINT) && !totalXAmount.isZero() && !this.opt?.skipSolWrappingOperation) {
      const wrapSOLIx = wrapSOLInstruction(
        user,
        userTokenX,
        BigInt(totalXAmount.toString())
      );
      preInstructions.push(...wrapSOLIx);
    }
    if (this.tokenY.publicKey.equals(NATIVE_MINT) && !totalYAmount.isZero() && !this.opt?.skipSolWrappingOperation) {
      const wrapSOLIx = wrapSOLInstruction(
        user,
        userTokenY,
        BigInt(totalYAmount.toString())
      );
      preInstructions.push(...wrapSOLIx);
    }
    const postInstructions = [];
    if ([
      this.tokenX.publicKey.toBase58(),
      this.tokenY.publicKey.toBase58()
    ].includes(NATIVE_MINT.toBase58()) && !this.opt?.skipSolWrappingOperation) {
      const closeWrappedSOLIx = await unwrapSOLInstruction(user);
      closeWrappedSOLIx && postInstructions.push(closeWrappedSOLIx);
    }
    const minBinArrayIndex = binIdToBinArrayIndex(new import_anchor.BN(minBinId));
    const maxBinArrayIndex = binIdToBinArrayIndex(new import_anchor.BN(maxBinId));
    const useExtension = isOverflowDefaultBinArrayBitmap(minBinArrayIndex) || isOverflowDefaultBinArrayBitmap(maxBinArrayIndex);
    const binArrayBitmapExtension = useExtension ? deriveBinArrayBitmapExtension(this.pubkey, this.program.programId)[0] : null;
    const activeId = this.lbPair.activeId;
    const strategyParameters = toStrategyParameters(strategy);
    const liquidityParams = {
      amountX: totalXAmount,
      amountY: totalYAmount,
      activeId,
      maxActiveBinSlippage,
      strategyParameters
    };
    const addLiquidityAccounts = {
      position: positionPubKey,
      lbPair: this.pubkey,
      userTokenX,
      userTokenY,
      reserveX: this.lbPair.reserveX,
      reserveY: this.lbPair.reserveY,
      tokenXMint: this.lbPair.tokenXMint,
      tokenYMint: this.lbPair.tokenYMint,
      binArrayBitmapExtension,
      sender: user,
      tokenXProgram: this.tokenX.owner,
      tokenYProgram: this.tokenY.owner,
      memoProgram: MEMO_PROGRAM_ID
    };
    const { slices, accounts: transferHookAccounts } = this.getPotentialToken2022IxDataAndAccounts(
      0
      /* Liquidity */
    );
    const programMethod = this.program.methods.addLiquidityByStrategy2(
      liquidityParams,
      {
        slices
      }
    );
    const addLiquidityIx = await programMethod.accountsPartial(addLiquidityAccounts).remainingAccounts(transferHookAccounts).remainingAccounts(binArrayAccountMetas).instruction();
    const instructions = [
      ...preInstructions,
      addLiquidityIx,
      ...postInstructions
    ];
    const setCUIx = await getEstimatedComputeUnitIxWithBuffer(
      this.program.provider.connection,
      instructions,
      user
    );
    instructions.unshift(setCUIx);
    const { blockhash, lastValidBlockHeight } = await this.program.provider.connection.getLatestBlockhash("confirmed");
    return new import_web311.Transaction({
      blockhash,
      lastValidBlockHeight,
      feePayer: user
    }).add(...instructions);
  }
  /**
   * @deprecated Use `initializePositionAndAddLiquidityByStrategy` instead which support both token and token2022.
   * The function `initializePositionAndAddLiquidityByWeight` function is used to initializes a position and adds liquidity
   * @param {TInitializePositionAndAddLiquidityParams}
   *    - `positionPubKey`: The public key of the position account. (usually use `new Keypair()`)
   *    - `totalXAmount`: The total amount of token X to be added to the liquidity pool.
   *    - `totalYAmount`: The total amount of token Y to be added to the liquidity pool.
   *    - `xYAmountDistribution`: An array of objects of type `XYAmountDistribution` that represents (can use `calculateSpotDistribution`, `calculateBidAskDistribution` & `calculateNormalDistribution`)
   *    - `user`: The public key of the user account.
   *    - `slippage`: The slippage percentage to be used for the liquidity pool.
   * @returns {Promise<Transaction|Transaction[]>} The function `initializePositionAndAddLiquidityByWeight` returns a `Promise` that
   * resolves to either a single `Transaction` object (if less than 26bin involved) or an array of `Transaction` objects.
   */
  async initializePositionAndAddLiquidityByWeight({
    positionPubKey,
    totalXAmount,
    totalYAmount,
    xYAmountDistribution,
    user,
    slippage
  }) {
    const { lowerBinId, upperBinId, binIds } = this.processXYAmountDistribution(xYAmountDistribution);
    const maxActiveBinSlippage = slippage ? Math.ceil(slippage / (this.lbPair.binStep / 100)) : MAX_ACTIVE_BIN_SLIPPAGE;
    if (upperBinId >= lowerBinId + DEFAULT_BIN_PER_POSITION.toNumber()) {
      throw new Error(
        `Position must be within a range of 1 to ${DEFAULT_BIN_PER_POSITION.toNumber()} bins.`
      );
    }
    const preInstructions = [];
    const initializePositionIx = await this.program.methods.initializePosition(lowerBinId, upperBinId - lowerBinId + 1).accountsPartial({
      payer: user,
      position: positionPubKey,
      lbPair: this.pubkey,
      owner: user
    }).instruction();
    preInstructions.push(initializePositionIx);
    const lowerBinArrayIndex = binIdToBinArrayIndex(new import_anchor.BN(lowerBinId));
    const [binArrayLower] = deriveBinArray(
      this.pubkey,
      lowerBinArrayIndex,
      this.program.programId
    );
    const upperBinArrayIndex = import_anchor.BN.max(
      lowerBinArrayIndex.add(new import_anchor.BN(1)),
      binIdToBinArrayIndex(new import_anchor.BN(upperBinId))
    );
    const [binArrayUpper] = deriveBinArray(
      this.pubkey,
      upperBinArrayIndex,
      this.program.programId
    );
    const createBinArrayIxs = await this.createBinArraysIfNeeded(
      [lowerBinArrayIndex, upperBinArrayIndex],
      user
    );
    preInstructions.push(...createBinArrayIxs);
    const [
      { ataPubKey: userTokenX, ix: createPayerTokenXIx },
      { ataPubKey: userTokenY, ix: createPayerTokenYIx }
    ] = await Promise.all([
      getOrCreateATAInstruction(
        this.program.provider.connection,
        this.tokenX.publicKey,
        user,
        this.tokenX.owner
      ),
      getOrCreateATAInstruction(
        this.program.provider.connection,
        this.tokenY.publicKey,
        user,
        this.tokenY.owner
      )
    ]);
    createPayerTokenXIx && preInstructions.push(createPayerTokenXIx);
    createPayerTokenYIx && preInstructions.push(createPayerTokenYIx);
    if (this.tokenX.publicKey.equals(NATIVE_MINT) && !totalXAmount.isZero() && !this.opt?.skipSolWrappingOperation) {
      const wrapSOLIx = wrapSOLInstruction(
        user,
        userTokenX,
        BigInt(totalXAmount.toString())
      );
      preInstructions.push(...wrapSOLIx);
    }
    if (this.tokenY.publicKey.equals(NATIVE_MINT) && !totalYAmount.isZero() && !this.opt?.skipSolWrappingOperation) {
      const wrapSOLIx = wrapSOLInstruction(
        user,
        userTokenY,
        BigInt(totalYAmount.toString())
      );
      preInstructions.push(...wrapSOLIx);
    }
    const postInstructions = [];
    if ([
      this.tokenX.publicKey.toBase58(),
      this.tokenY.publicKey.toBase58()
    ].includes(NATIVE_MINT.toBase58()) && !this.opt?.skipSolWrappingOperation) {
      const closeWrappedSOLIx = await unwrapSOLInstruction(user);
      closeWrappedSOLIx && postInstructions.push(closeWrappedSOLIx);
    }
    const minBinId = Math.min(...binIds);
    const maxBinId = Math.max(...binIds);
    const minBinArrayIndex = binIdToBinArrayIndex(new import_anchor.BN(minBinId));
    const maxBinArrayIndex = binIdToBinArrayIndex(new import_anchor.BN(maxBinId));
    const useExtension = isOverflowDefaultBinArrayBitmap(minBinArrayIndex) || isOverflowDefaultBinArrayBitmap(maxBinArrayIndex);
    const binArrayBitmapExtension = useExtension ? deriveBinArrayBitmapExtension(this.pubkey, this.program.programId)[0] : null;
    const activeId = this.lbPair.activeId;
    const binLiquidityDist = toWeightDistribution(
      totalXAmount,
      totalYAmount,
      xYAmountDistribution.map((item) => ({
        binId: item.binId,
        xAmountBpsOfTotal: item.xAmountBpsOfTotal,
        yAmountBpsOfTotal: item.yAmountBpsOfTotal
      })),
      this.lbPair.binStep
    );
    if (binLiquidityDist.length === 0) {
      throw new Error("No liquidity to add");
    }
    const liquidityParams = {
      amountX: totalXAmount,
      amountY: totalYAmount,
      binLiquidityDist,
      activeId,
      maxActiveBinSlippage
    };
    const addLiquidityAccounts = {
      position: positionPubKey,
      lbPair: this.pubkey,
      userTokenX,
      userTokenY,
      reserveX: this.lbPair.reserveX,
      reserveY: this.lbPair.reserveY,
      tokenXMint: this.lbPair.tokenXMint,
      tokenYMint: this.lbPair.tokenYMint,
      binArrayLower,
      binArrayUpper,
      binArrayBitmapExtension,
      sender: user,
      tokenXProgram: TOKEN_PROGRAM_ID,
      tokenYProgram: TOKEN_PROGRAM_ID
    };
    const oneSideLiquidityParams = {
      amount: totalXAmount.isZero() ? totalYAmount : totalXAmount,
      activeId,
      maxActiveBinSlippage,
      binLiquidityDist
    };
    const oneSideAddLiquidityAccounts = {
      binArrayLower,
      binArrayUpper,
      lbPair: this.pubkey,
      binArrayBitmapExtension: null,
      sender: user,
      position: positionPubKey,
      reserve: totalXAmount.isZero() ? this.lbPair.reserveY : this.lbPair.reserveX,
      tokenMint: totalXAmount.isZero() ? this.lbPair.tokenYMint : this.lbPair.tokenXMint,
      tokenProgram: TOKEN_PROGRAM_ID,
      userToken: totalXAmount.isZero() ? userTokenY : userTokenX
    };
    const isOneSideDeposit = totalXAmount.isZero() || totalYAmount.isZero();
    const programMethod = isOneSideDeposit ? this.program.methods.addLiquidityOneSide(oneSideLiquidityParams) : this.program.methods.addLiquidityByWeight(liquidityParams);
    if (xYAmountDistribution.length < MAX_BIN_LENGTH_ALLOWED_IN_ONE_TX) {
      const addLiqIx2 = await programMethod.accountsPartial(
        isOneSideDeposit ? oneSideAddLiquidityAccounts : addLiquidityAccounts
      ).instruction();
      const instructions = [...preInstructions, addLiqIx2, ...postInstructions];
      const setCUIx2 = await getEstimatedComputeUnitIxWithBuffer(
        this.program.provider.connection,
        instructions,
        user
      );
      instructions.unshift(setCUIx2);
      const { blockhash: blockhash2, lastValidBlockHeight: lastValidBlockHeight2 } = await this.program.provider.connection.getLatestBlockhash("confirmed");
      return new import_web311.Transaction({
        blockhash: blockhash2,
        lastValidBlockHeight: lastValidBlockHeight2,
        feePayer: user
      }).add(...instructions);
    }
    const addLiqIx = await programMethod.accountsPartial(
      isOneSideDeposit ? oneSideAddLiquidityAccounts : addLiquidityAccounts
    ).instruction();
    const setCUIx = await getEstimatedComputeUnitIxWithBuffer(
      this.program.provider.connection,
      [addLiqIx],
      user,
      DEFAULT_ADD_LIQUIDITY_CU
      // The function return multiple transactions that dependent on each other, simulation will fail
    );
    const mainInstructions = [setCUIx, addLiqIx];
    const transactions = [];
    const { blockhash, lastValidBlockHeight } = await this.program.provider.connection.getLatestBlockhash("confirmed");
    if (preInstructions.length) {
      const preInstructionsTx = new import_web311.Transaction({
        blockhash,
        lastValidBlockHeight,
        feePayer: user
      }).add(...preInstructions);
      transactions.push(preInstructionsTx);
    }
    const mainTx = new import_web311.Transaction({
      blockhash,
      lastValidBlockHeight,
      feePayer: user
    }).add(...mainInstructions);
    transactions.push(mainTx);
    if (postInstructions.length) {
      const postInstructionsTx = new import_web311.Transaction({
        blockhash,
        lastValidBlockHeight,
        feePayer: user
      }).add(...postInstructions);
      transactions.push(postInstructionsTx);
    }
    return transactions;
  }
  /**
   * The `addLiquidityByStrategy` function is used to add liquidity to existing position
   * @param {TInitializePositionAndAddLiquidityParamsByStrategy}
   *    - `positionPubKey`: The public key of the position account. (usually use `new Keypair()`)
   *    - `totalXAmount`: The total amount of token X to be added to the liquidity pool.
   *    - `totalYAmount`: The total amount of token Y to be added to the liquidity pool.
   *    - `strategy`: The strategy parameters to be used for the liquidity pool (Can use `calculateStrategyParameter` to calculate).
   *    - `user`: The public key of the user account.
   *    - `slippage`: The slippage percentage to be used for the liquidity pool.
   * @returns {Promise<Transaction>} The function `addLiquidityByWeight` returns a `Promise` that resolves to either a single
   * `Transaction` object
   */
  async addLiquidityByStrategy({
    positionPubKey,
    totalXAmount,
    totalYAmount,
    strategy,
    user,
    slippage
  }) {
    const { maxBinId, minBinId } = strategy;
    const maxActiveBinSlippage = slippage ? Math.ceil(slippage / (this.lbPair.binStep / 100)) : MAX_ACTIVE_BIN_SLIPPAGE;
    const preInstructions = [];
    const minBinArrayIndex = binIdToBinArrayIndex(new import_anchor.BN(minBinId));
    const maxBinArrayIndex = binIdToBinArrayIndex(new import_anchor.BN(maxBinId));
    const useExtension = isOverflowDefaultBinArrayBitmap(minBinArrayIndex) || isOverflowDefaultBinArrayBitmap(maxBinArrayIndex);
    const binArrayBitmapExtension = useExtension ? deriveBinArrayBitmapExtension(this.pubkey, this.program.programId)[0] : null;
    const strategyParameters = toStrategyParameters(strategy);
    const binArrayIndexes = getBinArrayIndexesCoverage(
      new import_anchor.BN(minBinId),
      new import_anchor.BN(maxBinId)
    );
    const binArrayAccountsMeta = getBinArrayAccountMetasCoverage(
      new import_anchor.BN(minBinId),
      new import_anchor.BN(maxBinId),
      this.pubkey,
      this.program.programId
    );
    const createBinArrayIxs = await this.createBinArraysIfNeeded(
      binArrayIndexes,
      user
    );
    preInstructions.push(...createBinArrayIxs);
    const [
      { ataPubKey: userTokenX, ix: createPayerTokenXIx },
      { ataPubKey: userTokenY, ix: createPayerTokenYIx }
    ] = await Promise.all([
      getOrCreateATAInstruction(
        this.program.provider.connection,
        this.tokenX.publicKey,
        user,
        this.tokenX.owner
      ),
      getOrCreateATAInstruction(
        this.program.provider.connection,
        this.tokenY.publicKey,
        user,
        this.tokenY.owner
      )
    ]);
    createPayerTokenXIx && preInstructions.push(createPayerTokenXIx);
    createPayerTokenYIx && preInstructions.push(createPayerTokenYIx);
    if (this.tokenX.publicKey.equals(NATIVE_MINT) && !totalXAmount.isZero() && !this.opt?.skipSolWrappingOperation) {
      const wrapSOLIx = wrapSOLInstruction(
        user,
        userTokenX,
        BigInt(totalXAmount.toString())
      );
      preInstructions.push(...wrapSOLIx);
    }
    if (this.tokenY.publicKey.equals(NATIVE_MINT) && !totalYAmount.isZero() && !this.opt?.skipSolWrappingOperation) {
      const wrapSOLIx = wrapSOLInstruction(
        user,
        userTokenY,
        BigInt(totalYAmount.toString())
      );
      preInstructions.push(...wrapSOLIx);
    }
    const postInstructions = [];
    if ([
      this.tokenX.publicKey.toBase58(),
      this.tokenY.publicKey.toBase58()
    ].includes(NATIVE_MINT.toBase58()) && !this.opt?.skipSolWrappingOperation) {
      const closeWrappedSOLIx = await unwrapSOLInstruction(user);
      closeWrappedSOLIx && postInstructions.push(closeWrappedSOLIx);
    }
    const liquidityParams = {
      amountX: totalXAmount,
      amountY: totalYAmount,
      activeId: this.lbPair.activeId,
      maxActiveBinSlippage,
      strategyParameters
    };
    const addLiquidityAccounts = {
      position: positionPubKey,
      lbPair: this.pubkey,
      userTokenX,
      userTokenY,
      reserveX: this.lbPair.reserveX,
      reserveY: this.lbPair.reserveY,
      tokenXMint: this.lbPair.tokenXMint,
      tokenYMint: this.lbPair.tokenYMint,
      binArrayBitmapExtension,
      sender: user,
      tokenXProgram: this.tokenX.owner,
      tokenYProgram: this.tokenY.owner,
      memoProgram: MEMO_PROGRAM_ID
    };
    const { slices, accounts: transferHookAccounts } = this.getPotentialToken2022IxDataAndAccounts(
      0
      /* Liquidity */
    );
    const programMethod = this.program.methods.addLiquidityByStrategy2(
      liquidityParams,
      {
        slices
      }
    );
    const addLiquidityIx = await programMethod.accounts(addLiquidityAccounts).remainingAccounts(transferHookAccounts).remainingAccounts(binArrayAccountsMeta).instruction();
    const instructions = [
      ...preInstructions,
      addLiquidityIx,
      ...postInstructions
    ];
    const setCUIx = await getEstimatedComputeUnitIxWithBuffer(
      this.program.provider.connection,
      instructions,
      user
    );
    instructions.unshift(setCUIx);
    const { blockhash, lastValidBlockHeight } = await this.program.provider.connection.getLatestBlockhash("confirmed");
    return new import_web311.Transaction({
      blockhash,
      lastValidBlockHeight,
      feePayer: user
    }).add(...instructions);
  }
  /**
   * @deprecated Use `addLiquidityByStrategy` instead which support both token and token2022.
   * The `addLiquidityByWeight` function is used to add liquidity to existing position
   * @param {TInitializePositionAndAddLiquidityParams}
   *    - `positionPubKey`: The public key of the position account. (usually use `new Keypair()`)
   *    - `totalXAmount`: The total amount of token X to be added to the liquidity pool.
   *    - `totalYAmount`: The total amount of token Y to be added to the liquidity pool.
   *    - `xYAmountDistribution`: An array of objects of type `XYAmountDistribution` that represents (can use `calculateSpotDistribution`, `calculateBidAskDistribution` & `calculateNormalDistribution`)
   *    - `user`: The public key of the user account.
   *    - `slippage`: The slippage percentage to be used for the liquidity pool.
   * @returns {Promise<Transaction|Transaction[]>} The function `addLiquidityByWeight` returns a `Promise` that resolves to either a single
   * `Transaction` object (if less than 26bin involved) or an array of `Transaction` objects.
   */
  async addLiquidityByWeight({
    positionPubKey,
    totalXAmount,
    totalYAmount,
    xYAmountDistribution,
    user,
    slippage
  }) {
    const maxActiveBinSlippage = slippage ? Math.ceil(slippage / (this.lbPair.binStep / 100)) : MAX_ACTIVE_BIN_SLIPPAGE;
    const positionAccount = await this.program.account.positionV2.fetch(
      positionPubKey
    );
    const { lowerBinId, upperBinId, binIds } = this.processXYAmountDistribution(xYAmountDistribution);
    if (lowerBinId < positionAccount.lowerBinId)
      throw new Error(
        `Lower Bin ID (${lowerBinId}) lower than Position Lower Bin Id (${positionAccount.lowerBinId})`
      );
    if (upperBinId > positionAccount.upperBinId)
      throw new Error(
        `Upper Bin ID (${upperBinId}) higher than Position Upper Bin Id (${positionAccount.upperBinId})`
      );
    const minBinId = Math.min(...binIds);
    const maxBinId = Math.max(...binIds);
    const minBinArrayIndex = binIdToBinArrayIndex(new import_anchor.BN(minBinId));
    const maxBinArrayIndex = binIdToBinArrayIndex(new import_anchor.BN(maxBinId));
    const useExtension = isOverflowDefaultBinArrayBitmap(minBinArrayIndex) || isOverflowDefaultBinArrayBitmap(maxBinArrayIndex);
    const binArrayBitmapExtension = useExtension ? deriveBinArrayBitmapExtension(this.pubkey, this.program.programId)[0] : null;
    const activeId = this.lbPair.activeId;
    const binLiquidityDist = toWeightDistribution(
      totalXAmount,
      totalYAmount,
      xYAmountDistribution.map((item) => ({
        binId: item.binId,
        xAmountBpsOfTotal: item.xAmountBpsOfTotal,
        yAmountBpsOfTotal: item.yAmountBpsOfTotal
      })),
      this.lbPair.binStep
    );
    if (binLiquidityDist.length === 0) {
      throw new Error("No liquidity to add");
    }
    const lowerBinArrayIndex = binIdToBinArrayIndex(
      new import_anchor.BN(positionAccount.lowerBinId)
    );
    const [binArrayLower] = deriveBinArray(
      this.pubkey,
      lowerBinArrayIndex,
      this.program.programId
    );
    const upperBinArrayIndex = import_anchor.BN.max(
      lowerBinArrayIndex.add(new import_anchor.BN(1)),
      binIdToBinArrayIndex(new import_anchor.BN(positionAccount.upperBinId))
    );
    const [binArrayUpper] = deriveBinArray(
      this.pubkey,
      upperBinArrayIndex,
      this.program.programId
    );
    const preInstructions = [];
    const createBinArrayIxs = await this.createBinArraysIfNeeded(
      [lowerBinArrayIndex, upperBinArrayIndex],
      user
    );
    preInstructions.push(...createBinArrayIxs);
    const [
      { ataPubKey: userTokenX, ix: createPayerTokenXIx },
      { ataPubKey: userTokenY, ix: createPayerTokenYIx }
    ] = await Promise.all([
      getOrCreateATAInstruction(
        this.program.provider.connection,
        this.tokenX.publicKey,
        user,
        this.tokenX.owner
      ),
      getOrCreateATAInstruction(
        this.program.provider.connection,
        this.tokenY.publicKey,
        user,
        this.tokenY.owner
      )
    ]);
    createPayerTokenXIx && preInstructions.push(createPayerTokenXIx);
    createPayerTokenYIx && preInstructions.push(createPayerTokenYIx);
    if (this.tokenX.publicKey.equals(NATIVE_MINT) && !totalXAmount.isZero() && !this.opt?.skipSolWrappingOperation) {
      const wrapSOLIx = wrapSOLInstruction(
        user,
        userTokenX,
        BigInt(totalXAmount.toString())
      );
      preInstructions.push(...wrapSOLIx);
    }
    if (this.tokenY.publicKey.equals(NATIVE_MINT) && !totalYAmount.isZero() && !this.opt?.skipSolWrappingOperation) {
      const wrapSOLIx = wrapSOLInstruction(
        user,
        userTokenY,
        BigInt(totalYAmount.toString())
      );
      preInstructions.push(...wrapSOLIx);
    }
    const postInstructions = [];
    if ([
      this.tokenX.publicKey.toBase58(),
      this.tokenY.publicKey.toBase58()
    ].includes(NATIVE_MINT.toBase58()) && !this.opt?.skipSolWrappingOperation) {
      const closeWrappedSOLIx = await unwrapSOLInstruction(user);
      closeWrappedSOLIx && postInstructions.push(closeWrappedSOLIx);
    }
    const liquidityParams = {
      amountX: totalXAmount,
      amountY: totalYAmount,
      binLiquidityDist,
      activeId,
      maxActiveBinSlippage
    };
    const addLiquidityAccounts = {
      position: positionPubKey,
      lbPair: this.pubkey,
      userTokenX,
      userTokenY,
      reserveX: this.lbPair.reserveX,
      reserveY: this.lbPair.reserveY,
      tokenXMint: this.lbPair.tokenXMint,
      tokenYMint: this.lbPair.tokenYMint,
      binArrayLower,
      binArrayUpper,
      binArrayBitmapExtension,
      sender: user,
      tokenXProgram: TOKEN_PROGRAM_ID,
      tokenYProgram: TOKEN_PROGRAM_ID
    };
    const oneSideLiquidityParams = {
      amount: totalXAmount.isZero() ? totalYAmount : totalXAmount,
      activeId,
      maxActiveBinSlippage,
      binLiquidityDist
    };
    const oneSideAddLiquidityAccounts = {
      binArrayLower,
      binArrayUpper,
      lbPair: this.pubkey,
      binArrayBitmapExtension: null,
      sender: user,
      position: positionPubKey,
      reserve: totalXAmount.isZero() ? this.lbPair.reserveY : this.lbPair.reserveX,
      tokenMint: totalXAmount.isZero() ? this.lbPair.tokenYMint : this.lbPair.tokenXMint,
      tokenProgram: TOKEN_PROGRAM_ID,
      userToken: totalXAmount.isZero() ? userTokenY : userTokenX
    };
    const isOneSideDeposit = totalXAmount.isZero() || totalYAmount.isZero();
    const programMethod = isOneSideDeposit ? this.program.methods.addLiquidityOneSide(oneSideLiquidityParams) : this.program.methods.addLiquidityByWeight(liquidityParams);
    if (xYAmountDistribution.length < MAX_BIN_LENGTH_ALLOWED_IN_ONE_TX) {
      const addLiqIx2 = await programMethod.accountsPartial(
        isOneSideDeposit ? oneSideAddLiquidityAccounts : addLiquidityAccounts
      ).instruction();
      const instructions = [...preInstructions, addLiqIx2, ...postInstructions];
      const setCUIx2 = await getEstimatedComputeUnitIxWithBuffer(
        this.program.provider.connection,
        instructions,
        user
      );
      instructions.unshift(setCUIx2);
      const { blockhash: blockhash2, lastValidBlockHeight: lastValidBlockHeight2 } = await this.program.provider.connection.getLatestBlockhash("confirmed");
      return new import_web311.Transaction({
        blockhash: blockhash2,
        lastValidBlockHeight: lastValidBlockHeight2,
        feePayer: user
      }).add(...instructions);
    }
    const addLiqIx = await programMethod.accountsPartial(
      isOneSideDeposit ? oneSideAddLiquidityAccounts : addLiquidityAccounts
    ).instruction();
    const setCUIx = await getEstimatedComputeUnitIxWithBuffer(
      this.program.provider.connection,
      [addLiqIx],
      user
    );
    const mainInstructions = [setCUIx, addLiqIx];
    const transactions = [];
    const { blockhash, lastValidBlockHeight } = await this.program.provider.connection.getLatestBlockhash("confirmed");
    if (preInstructions.length) {
      const preInstructionsTx = new import_web311.Transaction({
        blockhash,
        lastValidBlockHeight,
        feePayer: user
      }).add(...preInstructions);
      transactions.push(preInstructionsTx);
    }
    const mainTx = new import_web311.Transaction({
      blockhash,
      lastValidBlockHeight,
      feePayer: user
    }).add(...mainInstructions);
    transactions.push(mainTx);
    if (postInstructions.length) {
      const postInstructionsTx = new import_web311.Transaction({
        blockhash,
        lastValidBlockHeight,
        feePayer: user
      }).add(...postInstructions);
      transactions.push(postInstructionsTx);
    }
    return transactions;
  }
  /**
   * The `removeLiquidity` function is used to remove liquidity from a position,
   * with the option to claim rewards and close the position.
   * @param
   *    - `user`: The public key of the user account.
   *    - `position`: The public key of the position account.
   *    - `fromBinId`: The ID of the starting bin to remove liquidity from. Must within position range.
   *    - `toBinId`: The ID of the ending bin to remove liquidity from. Must within position range.
   *    - `liquiditiesBpsToRemove`: An array of numbers (percentage) that represent the liquidity to remove from each bin.
   *    - `shouldClaimAndClose`: A boolean flag that indicates whether to claim rewards and close the position.
   *    - `skipUnwrapSOL`: A boolean flag that indicates whether to skip unwrapping SOL. Enable this when using zap-sdk to ensure accuracy in SOL zap out amount when SOL is in token
   * @returns {Promise<Transaction[]>}
   */
  async removeLiquidity({
    user,
    position,
    fromBinId,
    toBinId,
    bps,
    shouldClaimAndClose = false,
    skipUnwrapSOL = false
  }) {
    const positionAccount = await this.program.provider.connection.getAccountInfo(position);
    const positionState = wrapPosition(this.program, position, positionAccount);
    const lbPair = positionState.lbPair();
    const owner = positionState.owner();
    const feeOwner = positionState.feeOwner();
    const liquidityShares = positionState.liquidityShares();
    const liqudityShareWithBinId = liquidityShares.map((share, i) => {
      return {
        share,
        binId: positionState.lowerBinId().add(new import_anchor.BN(i))
      };
    });
    const binIdsWithLiquidity = liqudityShareWithBinId.filter((bin) => {
      return !bin.share.isZero();
    });
    if (binIdsWithLiquidity.length == 0) {
      throw new Error("No liquidity to remove");
    }
    const lowerBinIdWithLiquidity = binIdsWithLiquidity[0].binId.toNumber();
    const upperBinIdWithLiquidity = binIdsWithLiquidity[binIdsWithLiquidity.length - 1].binId.toNumber();
    if (fromBinId < lowerBinIdWithLiquidity) {
      fromBinId = lowerBinIdWithLiquidity;
    }
    if (toBinId > upperBinIdWithLiquidity) {
      toBinId = upperBinIdWithLiquidity;
    }
    const walletToReceiveFee = feeOwner.equals(import_web311.PublicKey.default) ? user : feeOwner;
    const userTokenX = getAssociatedTokenAddressSync(
      this.lbPair.tokenXMint,
      owner,
      true,
      this.tokenX.owner
    );
    const userTokenY = getAssociatedTokenAddressSync(
      this.lbPair.tokenYMint,
      owner,
      true,
      this.tokenY.owner
    );
    const feeOwnerTokenX = getAssociatedTokenAddressSync(
      this.lbPair.tokenXMint,
      walletToReceiveFee,
      true,
      this.tokenX.owner
    );
    const feeOwnerTokenY = getAssociatedTokenAddressSync(
      this.lbPair.tokenYMint,
      walletToReceiveFee,
      true,
      this.tokenY.owner
    );
    const createUserTokenXIx = createAssociatedTokenAccountIdempotentInstruction(
      user,
      userTokenX,
      owner,
      this.lbPair.tokenXMint,
      this.tokenX.owner
    );
    const createUserTokenYIx = createAssociatedTokenAccountIdempotentInstruction(
      user,
      userTokenY,
      owner,
      this.lbPair.tokenYMint,
      this.tokenY.owner
    );
    const createFeeOwnerTokenXIx = createAssociatedTokenAccountIdempotentInstruction(
      user,
      feeOwnerTokenX,
      walletToReceiveFee,
      this.lbPair.tokenXMint,
      this.tokenX.owner
    );
    const createFeeOwnerTokenYIx = createAssociatedTokenAccountIdempotentInstruction(
      user,
      feeOwnerTokenY,
      walletToReceiveFee,
      this.lbPair.tokenYMint,
      this.tokenY.owner
    );
    const chunkedBinRange = chunkBinRange(fromBinId, toBinId);
    const groupedInstructions = [];
    for (const { lowerBinId, upperBinId } of chunkedBinRange) {
      const binArrayAccountsMeta = getBinArrayAccountMetasCoverage(
        new import_anchor.BN(lowerBinId),
        new import_anchor.BN(upperBinId),
        this.pubkey,
        this.program.programId
      );
      const { slices, accounts: transferHookAccounts } = this.getPotentialToken2022IxDataAndAccounts(
        0
        /* Liquidity */
      );
      const preInstructions = [];
      const postInstructions = [];
      if (shouldClaimAndClose) {
        const claimSwapFeeIx = await this.program.methods.claimFee2(lowerBinId, upperBinId, {
          slices
        }).accountsPartial({
          lbPair: this.pubkey,
          sender: user,
          position,
          reserveX: this.lbPair.reserveX,
          reserveY: this.lbPair.reserveY,
          tokenXMint: this.tokenX.publicKey,
          tokenYMint: this.tokenY.publicKey,
          userTokenX: feeOwnerTokenX,
          userTokenY: feeOwnerTokenY,
          tokenProgramX: this.tokenX.owner,
          tokenProgramY: this.tokenY.owner,
          memoProgram: MEMO_PROGRAM_ID
        }).remainingAccounts(transferHookAccounts).remainingAccounts(binArrayAccountsMeta).instruction();
        preInstructions.push(createFeeOwnerTokenXIx);
        preInstructions.push(createFeeOwnerTokenYIx);
        postInstructions.push(claimSwapFeeIx);
        for (let i = 0; i < 2; i++) {
          const rewardInfo = this.lbPair.rewardInfos[i];
          if (!rewardInfo || rewardInfo.mint.equals(import_web311.PublicKey.default))
            continue;
          const userRewardAccount = getAssociatedTokenAddressSync(
            rewardInfo.mint,
            user,
            true,
            this.rewards[i].owner
          );
          const createUserRewardAccountIx = createAssociatedTokenAccountIdempotentInstruction(
            user,
            userRewardAccount,
            user,
            rewardInfo.mint,
            this.rewards[i].owner
          );
          preInstructions.push(createUserRewardAccountIx);
          const { slices: slices2, accounts: transferHookAccounts2 } = this.getPotentialToken2022IxDataAndAccounts(1, i);
          const claimRewardIx = await this.program.methods.claimReward2(new import_anchor.BN(i), lowerBinId, upperBinId, {
            slices: slices2
          }).accountsPartial({
            lbPair: this.pubkey,
            sender: user,
            position,
            rewardVault: rewardInfo.vault,
            rewardMint: rewardInfo.mint,
            tokenProgram: this.rewards[i].owner,
            userTokenAccount: userRewardAccount,
            memoProgram: MEMO_PROGRAM_ID
          }).remainingAccounts(transferHookAccounts2).remainingAccounts(binArrayAccountsMeta).instruction();
          postInstructions.push(claimRewardIx);
        }
        const closePositionIx = await this.program.methods.closePositionIfEmpty().accountsPartial({
          rentReceiver: owner,
          // Must be position owner
          position,
          sender: user
        }).instruction();
        postInstructions.push(closePositionIx);
      }
      if ([
        this.tokenX.publicKey.toBase58(),
        this.tokenY.publicKey.toBase58()
      ].includes(NATIVE_MINT.toBase58()) && (!skipUnwrapSOL || !this.opt?.skipSolWrappingOperation)) {
        const closeWrappedSOLIx = await unwrapSOLInstruction(user);
        closeWrappedSOLIx && postInstructions.push(closeWrappedSOLIx);
      }
      preInstructions.push(createUserTokenXIx);
      preInstructions.push(createUserTokenYIx);
      const binArrayBitmapExtension = this.binArrayBitmapExtension ? this.binArrayBitmapExtension.publicKey : this.program.programId;
      const removeLiquidityTx = await this.program.methods.removeLiquidityByRange2(lowerBinId, upperBinId, bps.toNumber(), {
        slices
      }).accountsPartial({
        position,
        lbPair,
        userTokenX,
        userTokenY,
        reserveX: this.lbPair.reserveX,
        reserveY: this.lbPair.reserveY,
        tokenXMint: this.tokenX.publicKey,
        tokenYMint: this.tokenY.publicKey,
        binArrayBitmapExtension,
        tokenXProgram: this.tokenX.owner,
        tokenYProgram: this.tokenY.owner,
        sender: user,
        memoProgram: MEMO_PROGRAM_ID
      }).remainingAccounts(transferHookAccounts).remainingAccounts(binArrayAccountsMeta).instruction();
      const instructions = [
        ...preInstructions,
        removeLiquidityTx,
        ...postInstructions
      ];
      groupedInstructions.push(instructions);
    }
    const groupedInstructionsWithCUIx = await Promise.all(
      groupedInstructions.map(async (ixs) => {
        const setCUIx = await getEstimatedComputeUnitIxWithBuffer(
          this.program.provider.connection,
          ixs,
          user,
          0.3
          // Extra 30% buffer CU
        );
        return [setCUIx, ...ixs];
      })
    );
    const { blockhash, lastValidBlockHeight } = await this.program.provider.connection.getLatestBlockhash("confirmed");
    return groupedInstructionsWithCUIx.map((ixs) => {
      return new import_web311.Transaction({
        blockhash,
        lastValidBlockHeight,
        feePayer: user
      }).add(...ixs);
    });
  }
  /**
   * The `closePositionIfEmpty` function closes a position if it is empty. Else, it does nothing.
   */
  async closePositionIfEmpty({
    owner,
    position
  }) {
    const closePositionIfEmptyIx = await this.program.methods.closePositionIfEmpty().accountsPartial({
      rentReceiver: owner,
      position: position.publicKey,
      sender: owner
    }).instruction();
    const setCUIx = await getEstimatedComputeUnitIxWithBuffer(
      this.program.provider.connection,
      [closePositionIfEmptyIx],
      owner
    );
    const { blockhash, lastValidBlockHeight } = await this.program.provider.connection.getLatestBlockhash("confirmed");
    return new import_web311.Transaction({
      blockhash,
      lastValidBlockHeight,
      feePayer: owner
    }).add(setCUIx, closePositionIfEmptyIx);
  }
  /**
   * The `closePosition` function closes a position
   * @param
   *    - `owner`: The public key of the owner of the position.
   *    - `position`: The public key of the position account.
   * @returns {Promise<Transaction>}
   */
  async closePosition({
    owner,
    position
  }) {
    const closePositionIx = await this.program.methods.closePosition2().accountsPartial({
      rentReceiver: owner,
      position: position.publicKey,
      sender: owner
    }).instruction();
    const setCUIx = await getEstimatedComputeUnitIxWithBuffer(
      this.program.provider.connection,
      [closePositionIx],
      owner
    );
    const { blockhash, lastValidBlockHeight } = await this.program.provider.connection.getLatestBlockhash("confirmed");
    return new import_web311.Transaction({
      blockhash,
      lastValidBlockHeight,
      feePayer: owner
    }).add(setCUIx, closePositionIx);
  }
  /**
   * The `swapQuoteExactOut` function returns a quote for a swap
   * @param
   *    - `outAmount`: Amount of lamport to swap out
   *    - `swapForY`: Swap token X to Y when it is true, else reversed.
   *    - `allowedSlippage`: Allowed slippage for the swap. Expressed in BPS. To convert from slippage percentage to BPS unit: SLIPPAGE_PERCENTAGE * 100
   *    - `maxExtraBinArrays`: Maximum number of extra binArrays to return
   * @returns {SwapQuote}
   *    - `inAmount`: Amount of lamport to swap in
   *    - `outAmount`: Amount of lamport to swap out
   *    - `fee`: Fee amount
   *    - `protocolFee`: Protocol fee amount
   *    - `maxInAmount`: Maximum amount of lamport to swap in
   *    - `binArraysPubkey`: Array of bin arrays involved in the swap
   * @throws {DlmmSdkError}
   *
   */
  swapQuoteExactOut(outAmount, swapForY, allowedSlippage, binArrays, maxExtraBinArrays = 0) {
    const currentTimestamp = Date.now() / 1e3;
    const [inMint, outMint] = swapForY ? [this.tokenX.mint, this.tokenY.mint] : [this.tokenY.mint, this.tokenX.mint];
    let outAmountLeft = calculateTransferFeeIncludedAmount(
      outAmount,
      outMint,
      this.clock.epoch.toNumber()
    ).amount;
    if (maxExtraBinArrays < 0 || maxExtraBinArrays > MAX_EXTRA_BIN_ARRAYS) {
      throw new DlmmSdkError(
        "INVALID_MAX_EXTRA_BIN_ARRAYS",
        `maxExtraBinArrays must be a value between 0 and ${MAX_EXTRA_BIN_ARRAYS}`
      );
    }
    let vParameterClone = Object.assign({}, this.lbPair.vParameters);
    let activeId = new import_anchor.BN(this.lbPair.activeId);
    const binStep = this.lbPair.binStep;
    const sParameters3 = this.lbPair.parameters;
    DLMM.updateReference(
      activeId.toNumber(),
      vParameterClone,
      sParameters3,
      currentTimestamp
    );
    let startBinId = activeId;
    let binArraysForSwap = /* @__PURE__ */ new Map();
    let actualInAmount = new import_anchor.BN(0);
    let feeAmount = new import_anchor.BN(0);
    let protocolFeeAmount = new import_anchor.BN(0);
    while (!outAmountLeft.isZero()) {
      let binArrayAccountToSwap = findNextBinArrayWithLiquidity(
        swapForY,
        activeId,
        this.lbPair,
        this.binArrayBitmapExtension?.account ?? null,
        binArrays
      );
      if (binArrayAccountToSwap == null) {
        throw new DlmmSdkError(
          "SWAP_QUOTE_INSUFFICIENT_LIQUIDITY",
          "Insufficient liquidity in binArrays"
        );
      }
      binArraysForSwap.set(binArrayAccountToSwap.publicKey, true);
      DLMM.updateVolatilityAccumulator(
        vParameterClone,
        sParameters3,
        activeId.toNumber()
      );
      if (isBinIdWithinBinArray(activeId, binArrayAccountToSwap.account.index)) {
        const bin = getBinFromBinArray(
          activeId.toNumber(),
          binArrayAccountToSwap.account
        );
        const { amountIn, amountOut, fee, protocolFee } = swapExactOutQuoteAtBin(
          bin,
          binStep,
          sParameters3,
          vParameterClone,
          outAmountLeft,
          swapForY
        );
        if (!amountOut.isZero()) {
          outAmountLeft = outAmountLeft.sub(amountOut);
          actualInAmount = actualInAmount.add(amountIn);
          feeAmount = feeAmount.add(fee);
          protocolFeeAmount = protocolFee.add(protocolFee);
        }
      }
      if (!outAmountLeft.isZero()) {
        if (swapForY) {
          activeId = activeId.sub(new import_anchor.BN(1));
        } else {
          activeId = activeId.add(new import_anchor.BN(1));
        }
      }
    }
    const startPrice = getPriceOfBinByBinId(
      startBinId.toNumber(),
      this.lbPair.binStep
    );
    const endPrice = getPriceOfBinByBinId(
      activeId.toNumber(),
      this.lbPair.binStep
    );
    const priceImpact = startPrice.sub(endPrice).abs().div(startPrice).mul(new decimal_default(100));
    actualInAmount = calculateTransferFeeIncludedAmount(
      actualInAmount.add(feeAmount),
      inMint,
      this.clock.epoch.toNumber()
    ).amount;
    const maxInAmount = actualInAmount.mul(new import_anchor.BN(BASIS_POINT_MAX).add(allowedSlippage)).div(new import_anchor.BN(BASIS_POINT_MAX));
    if (maxExtraBinArrays > 0 && maxExtraBinArrays <= MAX_EXTRA_BIN_ARRAYS) {
      const extraBinArrays = new Array();
      while (extraBinArrays.length < maxExtraBinArrays) {
        let binArrayAccountToSwap = findNextBinArrayWithLiquidity(
          swapForY,
          activeId,
          this.lbPair,
          this.binArrayBitmapExtension?.account ?? null,
          binArrays
        );
        if (binArrayAccountToSwap == null) {
          break;
        }
        const binArrayAccountToSwapExisted = binArraysForSwap.has(
          binArrayAccountToSwap.publicKey
        );
        if (binArrayAccountToSwapExisted) {
          if (swapForY) {
            activeId = activeId.sub(new import_anchor.BN(1));
          } else {
            activeId = activeId.add(new import_anchor.BN(1));
          }
        } else {
          extraBinArrays.push(binArrayAccountToSwap.publicKey);
          const [lowerBinId, upperBinId] = getBinArrayLowerUpperBinId(
            binArrayAccountToSwap.account.index
          );
          if (swapForY) {
            activeId = lowerBinId.sub(new import_anchor.BN(1));
          } else {
            activeId = upperBinId.add(new import_anchor.BN(1));
          }
        }
      }
      extraBinArrays.forEach((binArrayPubkey) => {
        binArraysForSwap.set(binArrayPubkey, true);
      });
    }
    const binArraysPubkey = Array.from(binArraysForSwap.keys());
    return {
      inAmount: actualInAmount,
      maxInAmount,
      outAmount,
      priceImpact,
      fee: feeAmount,
      protocolFee: protocolFeeAmount,
      binArraysPubkey
    };
  }
  /**
   * The `swapQuote` function returns a quote for a swap
   * @param
   *    - `inAmount`: Amount of lamport to swap in
   *    - `swapForY`: Swap token X to Y when it is true, else reversed.
   *    - `allowedSlippage`: Allowed slippage for the swap. Expressed in BPS. To convert from slippage percentage to BPS unit: SLIPPAGE_PERCENTAGE * 100
   *    - `binArrays`: binArrays for swapQuote.
   *    - `isPartialFill`: Flag to check whether the the swapQuote is partial fill, default = false.
   *    - `maxExtraBinArrays`: Maximum number of extra binArrays to return
   * @returns {SwapQuote}
   *    - `consumedInAmount`: Amount of lamport to swap in
   *    - `outAmount`: Amount of lamport to swap out
   *    - `fee`: Fee amount
   *    - `protocolFee`: Protocol fee amount
   *    - `minOutAmount`: Minimum amount of lamport to swap out
   *    - `priceImpact`: Price impact of the swap
   *    - `binArraysPubkey`: Array of bin arrays involved in the swap
   * @throws {DlmmSdkError}
   */
  swapQuote(inAmount, swapForY, allowedSlippage, binArrays, isPartialFill, maxExtraBinArrays = 0) {
    const currentTimestamp = Date.now() / 1e3;
    if (maxExtraBinArrays < 0 || maxExtraBinArrays > MAX_EXTRA_BIN_ARRAYS) {
      throw new DlmmSdkError(
        "INVALID_MAX_EXTRA_BIN_ARRAYS",
        `maxExtraBinArrays must be a value between 0 and ${MAX_EXTRA_BIN_ARRAYS}`
      );
    }
    const [inMint, outMint] = swapForY ? [this.tokenX.mint, this.tokenY.mint] : [this.tokenY.mint, this.tokenX.mint];
    let transferFeeExcludedAmountIn = calculateTransferFeeExcludedAmount(
      inAmount,
      inMint,
      this.clock.epoch.toNumber()
    ).amount;
    let inAmountLeft = transferFeeExcludedAmountIn;
    let vParameterClone = Object.assign({}, this.lbPair.vParameters);
    let activeId = new import_anchor.BN(this.lbPair.activeId);
    const binStep = this.lbPair.binStep;
    const sParameters3 = this.lbPair.parameters;
    DLMM.updateReference(
      activeId.toNumber(),
      vParameterClone,
      sParameters3,
      currentTimestamp
    );
    let startBin = null;
    let binArraysForSwap = /* @__PURE__ */ new Map();
    let totalOutAmount = new import_anchor.BN(0);
    let feeAmount = new import_anchor.BN(0);
    let protocolFeeAmount = new import_anchor.BN(0);
    let lastFilledActiveBinId = activeId;
    while (!inAmountLeft.isZero()) {
      let binArrayAccountToSwap = findNextBinArrayWithLiquidity(
        swapForY,
        activeId,
        this.lbPair,
        this.binArrayBitmapExtension?.account ?? null,
        binArrays
      );
      if (binArrayAccountToSwap == null) {
        if (isPartialFill) {
          break;
        } else {
          throw new DlmmSdkError(
            "SWAP_QUOTE_INSUFFICIENT_LIQUIDITY",
            "Insufficient liquidity in binArrays for swapQuote"
          );
        }
      }
      binArraysForSwap.set(binArrayAccountToSwap.publicKey, true);
      DLMM.updateVolatilityAccumulator(
        vParameterClone,
        sParameters3,
        activeId.toNumber()
      );
      if (isBinIdWithinBinArray(activeId, binArrayAccountToSwap.account.index)) {
        const bin = getBinFromBinArray(
          activeId.toNumber(),
          binArrayAccountToSwap.account
        );
        const { amountIn, amountOut, fee, protocolFee } = swapExactInQuoteAtBin(
          bin,
          binStep,
          sParameters3,
          vParameterClone,
          inAmountLeft,
          swapForY
        );
        if (!amountIn.isZero()) {
          inAmountLeft = inAmountLeft.sub(amountIn);
          totalOutAmount = totalOutAmount.add(amountOut);
          feeAmount = feeAmount.add(fee);
          protocolFeeAmount = protocolFee.add(protocolFee);
          if (!startBin) {
            startBin = bin;
          }
          lastFilledActiveBinId = activeId;
        }
      }
      if (!inAmountLeft.isZero()) {
        if (swapForY) {
          activeId = activeId.sub(new import_anchor.BN(1));
        } else {
          activeId = activeId.add(new import_anchor.BN(1));
        }
      }
    }
    if (!startBin) {
      throw new DlmmSdkError(
        "SWAP_QUOTE_INSUFFICIENT_LIQUIDITY",
        "Insufficient liquidity"
      );
    }
    const actualInAmount = transferFeeExcludedAmountIn.sub(inAmountLeft);
    let transferFeeIncludedInAmount = calculateTransferFeeIncludedAmount(
      actualInAmount,
      inMint,
      this.clock.epoch.toNumber()
    ).amount;
    transferFeeIncludedInAmount = transferFeeIncludedInAmount.gt(inAmount) ? inAmount : transferFeeIncludedInAmount;
    const outAmountWithoutSlippage = getOutAmount(
      startBin,
      actualInAmount.sub(
        computeFeeFromAmount(
          binStep,
          sParameters3,
          vParameterClone,
          actualInAmount
        )
      ),
      swapForY
    );
    const priceImpact = new decimal_default(totalOutAmount.toString()).sub(new decimal_default(outAmountWithoutSlippage.toString())).div(new decimal_default(outAmountWithoutSlippage.toString())).mul(new decimal_default(100)).abs();
    const endPrice = getPriceOfBinByBinId(
      lastFilledActiveBinId.toNumber(),
      this.lbPair.binStep
    );
    if (maxExtraBinArrays > 0 && maxExtraBinArrays <= MAX_EXTRA_BIN_ARRAYS) {
      const extraBinArrays = new Array();
      while (extraBinArrays.length < maxExtraBinArrays) {
        let binArrayAccountToSwap = findNextBinArrayWithLiquidity(
          swapForY,
          activeId,
          this.lbPair,
          this.binArrayBitmapExtension?.account ?? null,
          binArrays
        );
        if (binArrayAccountToSwap == null) {
          break;
        }
        const binArrayAccountToSwapExisted = binArraysForSwap.has(
          binArrayAccountToSwap.publicKey
        );
        if (binArrayAccountToSwapExisted) {
          if (swapForY) {
            activeId = activeId.sub(new import_anchor.BN(1));
          } else {
            activeId = activeId.add(new import_anchor.BN(1));
          }
        } else {
          extraBinArrays.push(binArrayAccountToSwap.publicKey);
          const [lowerBinId, upperBinId] = getBinArrayLowerUpperBinId(
            binArrayAccountToSwap.account.index
          );
          if (swapForY) {
            activeId = lowerBinId.sub(new import_anchor.BN(1));
          } else {
            activeId = upperBinId.add(new import_anchor.BN(1));
          }
        }
      }
      extraBinArrays.forEach((binArrayPubkey) => {
        binArraysForSwap.set(binArrayPubkey, true);
      });
    }
    const binArraysPubkey = Array.from(binArraysForSwap.keys());
    const transferFeeExcludedAmountOut = calculateTransferFeeExcludedAmount(
      totalOutAmount,
      outMint,
      this.clock.epoch.toNumber()
    ).amount;
    const minOutAmount = transferFeeExcludedAmountOut.mul(new import_anchor.BN(BASIS_POINT_MAX).sub(allowedSlippage)).div(new import_anchor.BN(BASIS_POINT_MAX));
    return {
      consumedInAmount: transferFeeIncludedInAmount,
      outAmount: transferFeeExcludedAmountOut,
      fee: feeAmount,
      protocolFee: protocolFeeAmount,
      minOutAmount,
      priceImpact,
      binArraysPubkey,
      endPrice
    };
  }
  async swapExactOut({
    inToken,
    outToken,
    outAmount,
    maxInAmount,
    lbPair,
    user,
    binArraysPubkey
  }) {
    const preInstructions = [];
    const postInstructions = [];
    const [inTokenProgram, outTokenProgram] = inToken.equals(
      this.lbPair.tokenXMint
    ) ? [this.tokenX.owner, this.tokenY.owner] : [this.tokenY.owner, this.tokenX.owner];
    const [
      { ataPubKey: userTokenIn, ix: createInTokenAccountIx },
      { ataPubKey: userTokenOut, ix: createOutTokenAccountIx }
    ] = await Promise.all([
      getOrCreateATAInstruction(
        this.program.provider.connection,
        inToken,
        user,
        inTokenProgram
      ),
      getOrCreateATAInstruction(
        this.program.provider.connection,
        outToken,
        user,
        outTokenProgram
      )
    ]);
    createInTokenAccountIx && preInstructions.push(createInTokenAccountIx);
    createOutTokenAccountIx && preInstructions.push(createOutTokenAccountIx);
    if (inToken.equals(NATIVE_MINT) && !this.opt?.skipSolWrappingOperation) {
      const wrapSOLIx = wrapSOLInstruction(
        user,
        userTokenIn,
        BigInt(maxInAmount.toString())
      );
      preInstructions.push(...wrapSOLIx);
      const closeWrappedSOLIx = await unwrapSOLInstruction(user);
      closeWrappedSOLIx && postInstructions.push(closeWrappedSOLIx);
    }
    if (outToken.equals(NATIVE_MINT) && !this.opt?.skipSolWrappingOperation) {
      const closeWrappedSOLIx = await unwrapSOLInstruction(user);
      closeWrappedSOLIx && postInstructions.push(closeWrappedSOLIx);
    }
    const { slices, accounts: transferHookAccounts } = this.getPotentialToken2022IxDataAndAccounts(
      0
      /* Liquidity */
    );
    const binArrays = binArraysPubkey.map((pubkey) => {
      return {
        isSigner: false,
        isWritable: true,
        pubkey
      };
    });
    const swapIx = await this.program.methods.swapExactOut2(maxInAmount, outAmount, { slices }).accountsPartial({
      lbPair,
      reserveX: this.lbPair.reserveX,
      reserveY: this.lbPair.reserveY,
      tokenXMint: this.lbPair.tokenXMint,
      tokenYMint: this.lbPair.tokenYMint,
      tokenXProgram: this.tokenX.owner,
      tokenYProgram: this.tokenY.owner,
      user,
      userTokenIn,
      userTokenOut,
      binArrayBitmapExtension: this.binArrayBitmapExtension ? this.binArrayBitmapExtension.publicKey : null,
      oracle: this.lbPair.oracle,
      hostFeeIn: null,
      memoProgram: MEMO_PROGRAM_ID
    }).remainingAccounts(transferHookAccounts).remainingAccounts(binArrays).instruction();
    const instructions = [...preInstructions, swapIx, ...postInstructions];
    instructions.push(
      import_web311.ComputeBudgetProgram.setComputeUnitLimit({
        units: 14e5
      })
    );
    const { blockhash, lastValidBlockHeight } = await this.program.provider.connection.getLatestBlockhash("confirmed");
    return new import_web311.Transaction({
      blockhash,
      lastValidBlockHeight,
      feePayer: user
    }).add(...instructions);
  }
  /**
   * Returns a transaction to be signed and sent by user performing swap.
   * @param {SwapWithPriceImpactParams}
   *    - `inToken`: The public key of the token to be swapped in.
   *    - `outToken`: The public key of the token to be swapped out.
   *    - `inAmount`: The amount of token to be swapped in.
   *    - `priceImpact`: Accepted price impact bps.
   *    - `lbPair`: The public key of the liquidity pool.
   *    - `user`: The public key of the user account.
   *    - `binArraysPubkey`: Array of bin arrays involved in the swap
   * @returns {Promise<Transaction>}
   */
  async swapWithPriceImpact({
    inToken,
    outToken,
    inAmount,
    lbPair,
    user,
    priceImpact,
    binArraysPubkey
  }) {
    const preInstructions = [];
    const postInstructions = [];
    const [
      { ataPubKey: userTokenIn, ix: createInTokenAccountIx },
      { ataPubKey: userTokenOut, ix: createOutTokenAccountIx }
    ] = await Promise.all([
      getOrCreateATAInstruction(
        this.program.provider.connection,
        inToken,
        user,
        this.tokenX.owner
      ),
      getOrCreateATAInstruction(
        this.program.provider.connection,
        outToken,
        user,
        this.tokenY.owner
      )
    ]);
    createInTokenAccountIx && preInstructions.push(createInTokenAccountIx);
    createOutTokenAccountIx && preInstructions.push(createOutTokenAccountIx);
    if (inToken.equals(NATIVE_MINT) && !this.opt?.skipSolWrappingOperation) {
      const wrapSOLIx = wrapSOLInstruction(
        user,
        userTokenIn,
        BigInt(inAmount.toString())
      );
      preInstructions.push(...wrapSOLIx);
      const closeWrappedSOLIx = await unwrapSOLInstruction(user);
      closeWrappedSOLIx && postInstructions.push(closeWrappedSOLIx);
    }
    if (outToken.equals(NATIVE_MINT) && !this.opt?.skipSolWrappingOperation) {
      const closeWrappedSOLIx = await unwrapSOLInstruction(user);
      closeWrappedSOLIx && postInstructions.push(closeWrappedSOLIx);
    }
    const binArrays = binArraysPubkey.map((pubkey) => {
      return {
        isSigner: false,
        isWritable: true,
        pubkey
      };
    });
    const { slices, accounts: transferHookAccounts } = this.getPotentialToken2022IxDataAndAccounts(
      0
      /* Liquidity */
    );
    const swapIx = await this.program.methods.swapWithPriceImpact2(
      inAmount,
      this.lbPair.activeId,
      priceImpact.toNumber(),
      { slices }
    ).accountsPartial({
      lbPair,
      reserveX: this.lbPair.reserveX,
      reserveY: this.lbPair.reserveY,
      tokenXMint: this.lbPair.tokenXMint,
      tokenYMint: this.lbPair.tokenYMint,
      tokenXProgram: this.tokenX.owner,
      tokenYProgram: this.tokenY.owner,
      user,
      userTokenIn,
      userTokenOut,
      binArrayBitmapExtension: this.binArrayBitmapExtension ? this.binArrayBitmapExtension.publicKey : null,
      oracle: this.lbPair.oracle,
      hostFeeIn: null,
      memoProgram: MEMO_PROGRAM_ID
    }).remainingAccounts(transferHookAccounts).remainingAccounts(binArrays).instruction();
    const instructions = [...preInstructions, swapIx, ...postInstructions];
    const setCUIx = await getEstimatedComputeUnitIxWithBuffer(
      this.program.provider.connection,
      instructions,
      user
    );
    instructions.unshift(setCUIx);
    const { blockhash, lastValidBlockHeight } = await this.program.provider.connection.getLatestBlockhash("confirmed");
    return new import_web311.Transaction({
      blockhash,
      lastValidBlockHeight,
      feePayer: user
    }).add(...instructions);
  }
  /**
   * Returns a transaction to be signed and sent by user performing swap.
   * @param {SwapParams}
   *    - `inToken`: The public key of the token to be swapped in.
   *    - `outToken`: The public key of the token to be swapped out.
   *    - `inAmount`: The amount of token to be swapped in.
   *    - `minOutAmount`: The minimum amount of token to be swapped out.
   *    - `lbPair`: The public key of the liquidity pool.
   *    - `user`: The public key of the user account.
   *    - `binArraysPubkey`: Array of bin arrays involved in the swap
   * @returns {Promise<Transaction>}
   */
  async swap({
    inToken,
    outToken,
    inAmount,
    minOutAmount,
    lbPair,
    user,
    binArraysPubkey
  }) {
    const preInstructions = [];
    const postInstructions = [];
    const [inTokenProgram, outTokenProgram] = inToken.equals(
      this.lbPair.tokenXMint
    ) ? [this.tokenX.owner, this.tokenY.owner] : [this.tokenY.owner, this.tokenX.owner];
    const [
      { ataPubKey: userTokenIn, ix: createInTokenAccountIx },
      { ataPubKey: userTokenOut, ix: createOutTokenAccountIx }
    ] = await Promise.all([
      getOrCreateATAInstruction(
        this.program.provider.connection,
        inToken,
        user,
        inTokenProgram
      ),
      getOrCreateATAInstruction(
        this.program.provider.connection,
        outToken,
        user,
        outTokenProgram
      )
    ]);
    createInTokenAccountIx && preInstructions.push(createInTokenAccountIx);
    createOutTokenAccountIx && preInstructions.push(createOutTokenAccountIx);
    if (inToken.equals(NATIVE_MINT) && !this.opt?.skipSolWrappingOperation) {
      const wrapSOLIx = wrapSOLInstruction(
        user,
        userTokenIn,
        BigInt(inAmount.toString())
      );
      preInstructions.push(...wrapSOLIx);
      const closeWrappedSOLIx = await unwrapSOLInstruction(user);
      closeWrappedSOLIx && postInstructions.push(closeWrappedSOLIx);
    }
    if (outToken.equals(NATIVE_MINT) && !this.opt?.skipSolWrappingOperation) {
      const closeWrappedSOLIx = await unwrapSOLInstruction(user);
      closeWrappedSOLIx && postInstructions.push(closeWrappedSOLIx);
    }
    const binArrays = binArraysPubkey.map((pubkey) => {
      return {
        isSigner: false,
        isWritable: true,
        pubkey
      };
    });
    const { slices, accounts: transferHookAccounts } = this.getPotentialToken2022IxDataAndAccounts(
      0
      /* Liquidity */
    );
    const swapIx = await this.program.methods.swap2(inAmount, minOutAmount, { slices }).accountsPartial({
      lbPair,
      reserveX: this.lbPair.reserveX,
      reserveY: this.lbPair.reserveY,
      tokenXMint: this.lbPair.tokenXMint,
      tokenYMint: this.lbPair.tokenYMint,
      tokenXProgram: this.tokenX.owner,
      tokenYProgram: this.tokenY.owner,
      user,
      userTokenIn,
      userTokenOut,
      binArrayBitmapExtension: this.binArrayBitmapExtension ? this.binArrayBitmapExtension.publicKey : null,
      oracle: this.lbPair.oracle,
      hostFeeIn: null,
      memoProgram: MEMO_PROGRAM_ID
    }).remainingAccounts(transferHookAccounts).remainingAccounts(binArrays).instruction();
    const instructions = [...preInstructions, swapIx, ...postInstructions];
    const setCUIx = await getEstimatedComputeUnitIxWithBuffer(
      this.program.provider.connection,
      instructions,
      user
    );
    instructions.unshift(setCUIx);
    const { blockhash, lastValidBlockHeight } = await this.program.provider.connection.getLatestBlockhash("confirmed");
    return new import_web311.Transaction({
      blockhash,
      lastValidBlockHeight,
      feePayer: user
    }).add(...instructions);
  }
  /**
   * The claimLMReward function is used to claim rewards for a specific position owned by a specific owner.
   * @param
   *    - `owner`: The public key of the owner of the position.
   *    - `position`: The public key of the position account.
   * @returns {Promise<Transaction[]>} Claim LM reward transactions.
   */
  async claimLMReward({
    owner,
    position
  }) {
    if (isPositionNoReward(position.positionData)) {
      throw new Error("No LM reward to claim");
    }
    const claimTransactions = await this.createClaimBuildMethod({
      owner,
      position
    });
    if (!claimTransactions.length)
      return;
    const claimTransactionWithCUIx = await Promise.all(
      claimTransactions.map(async (tx) => {
        const setCUIx = await getEstimatedComputeUnitIxWithBuffer(
          this.program.provider.connection,
          tx.instructions,
          owner
        );
        return [setCUIx, ...tx.instructions];
      })
    );
    const { blockhash, lastValidBlockHeight } = await this.program.provider.connection.getLatestBlockhash("confirmed");
    return claimTransactionWithCUIx.map((ixs) => {
      return new import_web311.Transaction({
        blockhash,
        lastValidBlockHeight,
        feePayer: owner
      }).add(...ixs);
    });
  }
  /**
   * The `claimAllLMRewards` function is used to claim all liquidity mining rewards for a given owner
   * and their positions.
   * @param
   *    - `owner`: The public key of the owner of the positions.
   *    - `positions`: An array of objects of type `PositionData` that represents the positions to claim rewards from.
   * @returns {Promise<Transaction[]>} Array of claim LM reward and fees transactions.
   */
  async claimAllLMRewards({
    owner,
    positions
  }) {
    if (positions.every((position) => isPositionNoReward(position.positionData))) {
      throw new Error("No LM reward to claim");
    }
    const claimAllTxs = (await Promise.all(
      positions.filter(
        ({ positionData: { rewardOne, rewardTwo } }) => !rewardOne.isZero() || !rewardTwo.isZero()
      ).map(async (position, idx) => {
        return await this.createClaimBuildMethod({
          owner,
          position
        });
      })
    )).flat();
    const chunkedClaimAllTx = chunks(claimAllTxs, MAX_CLAIM_ALL_ALLOWED);
    if (chunkedClaimAllTx.length === 0)
      return [];
    const chunkedClaimAllTxIx = await Promise.all(
      chunkedClaimAllTx.map(async (txs) => {
        const ixs = txs.map((t) => t.instructions).flat();
        const setCUIx = await getEstimatedComputeUnitIxWithBuffer(
          this.program.provider.connection,
          ixs,
          owner
        );
        return [setCUIx, ...ixs];
      })
    );
    const { blockhash, lastValidBlockHeight } = await this.program.provider.connection.getLatestBlockhash("confirmed");
    return Promise.all(
      chunkedClaimAllTxIx.map(async (claimAllTx) => {
        return new import_web311.Transaction({
          feePayer: owner,
          blockhash,
          lastValidBlockHeight
        }).add(...claimAllTx);
      })
    );
  }
  async setActivationPoint(activationPoint) {
    const setActivationPointTx = await this.program.methods.setActivationPoint(activationPoint).accountsPartial({
      lbPair: this.pubkey,
      admin: this.lbPair.creator
    }).transaction();
    const { blockhash, lastValidBlockHeight } = await this.program.provider.connection.getLatestBlockhash("confirmed");
    return new import_web311.Transaction({
      feePayer: this.lbPair.creator,
      blockhash,
      lastValidBlockHeight
    }).add(setActivationPointTx);
  }
  async setPairStatus(enabled) {
    const pairStatus = enabled ? 0 : 1;
    const tx = await this.program.methods.setPairStatus(pairStatus).accountsPartial({
      lbPair: this.pubkey,
      admin: this.lbPair.creator
    }).transaction();
    const { blockhash, lastValidBlockHeight } = await this.program.provider.connection.getLatestBlockhash("confirmed");
    return new import_web311.Transaction({
      feePayer: this.lbPair.creator,
      blockhash,
      lastValidBlockHeight
    }).add(tx);
  }
  /**
   * The function `claimSwapFee` is used to claim swap fees for a specific position owned by a specific owner.
   * @param
   *    - `owner`: The public key of the owner of the position.
   *    - `position`: The public key of the position account.
   *    - `binRange`: The bin range to claim swap fees for. If not provided, the function claim swap fees for full range.
   * @returns {Promise<Transaction[]>} Claim swap fee transactions.
   */
  async claimSwapFee({
    owner,
    position
  }) {
    if (isPositionNoFee(position.positionData)) {
      throw new Error("No fee to claim");
    }
    const claimFeeTxs = await this.createClaimSwapFeeMethod({
      owner,
      position
    });
    const claimFeeTxsWithCUIx = await Promise.all(
      claimFeeTxs.map(async (tx) => {
        const setCUIx = await getEstimatedComputeUnitIxWithBuffer(
          this.program.provider.connection,
          tx.instructions,
          owner
        );
        return [setCUIx, ...tx.instructions];
      })
    );
    const { blockhash, lastValidBlockHeight } = await this.program.provider.connection.getLatestBlockhash("confirmed");
    return claimFeeTxsWithCUIx.map((ixs) => {
      return new import_web311.Transaction({
        blockhash,
        lastValidBlockHeight,
        feePayer: owner
      }).add(...ixs);
    });
  }
  /**
   * The `claimAllSwapFee` function to claim swap fees for multiple positions owned by a specific owner.
   * @param
   *    - `owner`: The public key of the owner of the positions.
   *    - `positions`: An array of objects of type `PositionData` that represents the positions to claim swap fees from.
   * @returns {Promise<Transaction[]>} Array of claim swap fee transactions.
   */
  async claimAllSwapFee({
    owner,
    positions
  }) {
    if (positions.every((position) => isPositionNoFee(position.positionData))) {
      throw new Error("No fee to claim");
    }
    const claimAllTxs = (await Promise.all(
      positions.filter(
        ({ positionData: { feeX, feeY } }) => !feeX.isZero() || !feeY.isZero()
      ).map(async (position) => {
        return await this.createClaimSwapFeeMethod({
          owner,
          position
        });
      })
    )).flat();
    const chunkedClaimAllTx = chunks(claimAllTxs, MAX_CLAIM_ALL_ALLOWED);
    if (chunkedClaimAllTx.length === 0)
      return [];
    const chunkedClaimAllTxIxs = await Promise.all(
      chunkedClaimAllTx.map(async (tx) => {
        const ixs = tx.map((t) => t.instructions).flat();
        const setCUIx = await getEstimatedComputeUnitIxWithBuffer(
          this.program.provider.connection,
          ixs,
          owner
        );
        return [setCUIx, ...ixs];
      })
    );
    const { blockhash, lastValidBlockHeight } = await this.program.provider.connection.getLatestBlockhash("confirmed");
    return Promise.all(
      chunkedClaimAllTxIxs.map(async (claimAllTx) => {
        return new import_web311.Transaction({
          feePayer: owner,
          blockhash,
          lastValidBlockHeight
        }).add(...claimAllTx);
      })
    );
  }
  /**
   * The function `claimAllRewardsByPosition` allows a user to claim all rewards for a specific
   * position.
   * @param
   *    - `owner`: The public key of the owner of the position.
   *    - `position`: The public key of the position account.
   * @returns {Promise<Transaction[]>} Array of claim reward transactions.
   */
  async claimAllRewardsByPosition({
    owner,
    position
  }) {
    if (isPositionNoFee(position.positionData) && isPositionNoReward(position.positionData)) {
      throw new Error("No fee/reward to claim");
    }
    const claimAllSwapFeeTxs = await this.createClaimSwapFeeMethod({
      owner,
      position
    });
    const claimAllLMTxs = await this.createClaimBuildMethod({
      owner,
      position
    });
    const claimAllTxs = chunks(
      [...claimAllSwapFeeTxs, ...claimAllLMTxs],
      MAX_CLAIM_ALL_ALLOWED
    );
    const { blockhash, lastValidBlockHeight } = await this.program.provider.connection.getLatestBlockhash("confirmed");
    return Promise.all(
      claimAllTxs.map(async (txs) => {
        const instructions = txs.flatMap((tx) => tx.instructions);
        const setCUIx = await getEstimatedComputeUnitIxWithBuffer(
          this.program.provider.connection,
          instructions,
          owner
        );
        const transaction = new import_web311.Transaction({
          feePayer: owner,
          blockhash,
          lastValidBlockHeight
        }).add(setCUIx, ...instructions);
        return transaction;
      })
    );
  }
  /**
   * The `seedLiquidity` function create multiple grouped instructions. The grouped instructions will be [init ata + send lamport for token provde], [initialize bin array + initialize position instructions] and [deposit instruction]. Each grouped instructions can be executed parallelly.
   * @param
   *    - `owner`: The public key of the positions owner.
   *    - `seedAmount`: Lamport amount to be seeded to the pool.
   *    - `minPrice`: Start price in UI format
   *    - `maxPrice`: End price in UI format
   *    - `base`: Base key
   *    - `txPayer`: Account rental fee payer
   *    - `feeOwner`: Fee owner key. Default to position owner
   *    - `operator`: Operator key
   *    - `lockReleasePoint`: Timelock. Point (slot/timestamp) the position can withdraw the liquidity,
   *    - `shouldSeedPositionOwner` (optional): Whether to send 1 lamport amount of token X to the position owner to prove ownership.
   * @returns {Promise<SeedLiquidityResponse>}
   */
  async seedLiquidity(owner, seedAmount, curvature, minPrice, maxPrice, base, payer, feeOwner, operator, lockReleasePoint, shouldSeedPositionOwner = false) {
    let tokenOwnerProveAssociatedTokenAccountLamports = new import_anchor.BN(0);
    let totalPositionCount = new import_anchor.BN(0);
    let totalPositionLamports = new import_anchor.BN(0);
    let totalBinArraysCount = new import_anchor.BN(0);
    let totalBinArraysLamports = new import_anchor.BN(0);
    let binArrayBitmapLamports = new import_anchor.BN(0);
    const toLamportMultiplier = new decimal_default(
      10 ** (this.tokenY.mint.decimals - this.tokenX.mint.decimals)
    );
    const minPricePerLamport = new decimal_default(minPrice).mul(toLamportMultiplier);
    const maxPricePerLamport = new decimal_default(maxPrice).mul(toLamportMultiplier);
    const minBinId = new import_anchor.BN(
      DLMM.getBinIdFromPrice(minPricePerLamport, this.lbPair.binStep, false)
    );
    const maxBinId = new import_anchor.BN(
      DLMM.getBinIdFromPrice(maxPricePerLamport, this.lbPair.binStep, true)
    );
    if (minBinId.toNumber() < this.lbPair.activeId) {
      throw new Error("minPrice < current pair price");
    }
    if (minBinId.toNumber() >= maxBinId.toNumber()) {
      throw new Error("Price range too small");
    }
    const k = 1 / curvature;
    const binDepositAmount = generateAmountForBinRange(
      seedAmount,
      this.lbPair.binStep,
      this.tokenX.mint.decimals,
      this.tokenY.mint.decimals,
      minBinId,
      maxBinId,
      k
    );
    const decompressMultiplier = findOptimumDecompressMultiplier(
      binDepositAmount,
      new import_anchor.BN(this.tokenX.mint.decimals)
    );
    let { compressedBinAmount, compressionLoss } = compressBinAmount(
      binDepositAmount,
      decompressMultiplier
    );
    let {
      newCompressedBinAmount: compressedBinDepositAmount,
      loss: finalLoss
    } = distributeAmountToCompressedBinsByRatio(
      compressedBinAmount,
      compressionLoss,
      decompressMultiplier,
      new import_anchor.BN(2 ** 32 - 1)
      // u32
    );
    const positionCount = getPositionCount(minBinId, maxBinId.sub(new import_anchor.BN(1)));
    const seederTokenX = getAssociatedTokenAddressSync(
      this.lbPair.tokenXMint,
      operator,
      false,
      this.tokenX.owner
    );
    const seederTokenY = getAssociatedTokenAddressSync(
      this.lbPair.tokenYMint,
      operator,
      false,
      this.tokenY.owner
    );
    const ownerTokenX = getAssociatedTokenAddressSync(
      this.lbPair.tokenXMint,
      owner,
      false,
      this.tokenX.owner
    );
    const [binArrayBitmapExtension] = deriveBinArrayBitmapExtension(
      this.pubkey,
      this.program.programId
    );
    const sendPositionOwnerTokenProveIxs = [];
    const initializeBinArraysAndPositionIxs = [];
    const addLiquidityIxs = [];
    const appendedInitBinArrayIx = /* @__PURE__ */ new Set();
    let appendedInitBinArrayBitmap = false;
    if (shouldSeedPositionOwner) {
      const positionOwnerTokenX = await this.program.provider.connection.getAccountInfo(ownerTokenX);
      let requireTokenProve = false;
      if (positionOwnerTokenX) {
        const ownerTokenXState = unpackAccount(
          ownerTokenX,
          positionOwnerTokenX,
          this.tokenX.owner
        );
        requireTokenProve = ownerTokenXState.amount == 0n;
      } else {
        requireTokenProve = true;
      }
      if (requireTokenProve) {
        if (!positionOwnerTokenX) {
          tokenOwnerProveAssociatedTokenAccountLamports = tokenOwnerProveAssociatedTokenAccountLamports.add(
            TOKEN_ACCOUNT_FEE_BN
          );
        }
        const initPositionOwnerTokenX = createAssociatedTokenAccountIdempotentInstruction(
          payer,
          ownerTokenX,
          owner,
          this.lbPair.tokenXMint,
          this.tokenX.owner
        );
        const proveAmount = calculateTransferFeeIncludedAmount(
          new import_anchor.BN(1),
          this.tokenX.mint,
          this.clock.epoch.toNumber()
        ).amount;
        sendPositionOwnerTokenProveIxs.push(initPositionOwnerTokenX);
        const transferIx = createTransferCheckedInstruction(
          seederTokenX,
          this.lbPair.tokenXMint,
          ownerTokenX,
          operator,
          BigInt(proveAmount.toString()),
          this.tokenX.mint.decimals,
          [],
          this.tokenX.owner
        );
        transferIx.keys.push(...this.tokenX.transferHookAccountMetas);
        sendPositionOwnerTokenProveIxs.push(transferIx);
      }
    }
    const slices = [
      {
        accountsType: {
          transferHookX: {}
        },
        length: this.tokenX.transferHookAccountMetas.length
      }
    ];
    const transferHookAccountMetas = this.tokenX.transferHookAccountMetas;
    for (let i = 0; i < positionCount.toNumber(); i++) {
      const lowerBinId = minBinId.add(DEFAULT_BIN_PER_POSITION.mul(new import_anchor.BN(i)));
      const upperBinId = lowerBinId.add(DEFAULT_BIN_PER_POSITION).sub(new import_anchor.BN(1));
      const binArrayAccountMetas = getBinArrayAccountMetasCoverage(
        lowerBinId,
        upperBinId,
        this.pubkey,
        this.program.programId
      );
      const binArrayIndexes = getBinArrayIndexesCoverage(
        lowerBinId,
        upperBinId
      );
      const [positionPda, _bump] = derivePosition(
        this.pubkey,
        base,
        lowerBinId,
        DEFAULT_BIN_PER_POSITION,
        this.program.programId
      );
      const accounts = await this.program.provider.connection.getMultipleAccountsInfo([
        ...binArrayAccountMetas.map((acc) => acc.pubkey),
        positionPda
      ]);
      let instructions = [];
      const binArrayAccounts = accounts.splice(0, binArrayAccountMetas.length);
      for (let i2 = 0; i2 < binArrayAccountMetas.length; i2++) {
        const account = binArrayAccounts[i2];
        const pubkey = binArrayAccountMetas[i2].pubkey.toBase58();
        const index = binArrayIndexes[i2];
        if (!account && !appendedInitBinArrayIx.has(pubkey)) {
          totalBinArraysCount = totalBinArraysCount.add(new import_anchor.BN(1));
          totalBinArraysLamports = totalBinArraysLamports.add(BIN_ARRAY_FEE_BN);
          instructions.push(
            await this.program.methods.initializeBinArray(index).accountsPartial({
              lbPair: this.pubkey,
              binArray: pubkey,
              funder: payer
            }).instruction()
          );
        }
      }
      const positionAccount = accounts.pop();
      if (!positionAccount) {
        totalPositionCount = totalPositionCount.add(new import_anchor.BN(1));
        totalPositionLamports = totalPositionLamports.add(POSITION_FEE_BN);
        instructions.push(
          await this.program.methods.initializePositionByOperator(
            lowerBinId.toNumber(),
            DEFAULT_BIN_PER_POSITION.toNumber(),
            feeOwner,
            lockReleasePoint
          ).accountsPartial({
            lbPair: this.pubkey,
            position: positionPda,
            base,
            owner,
            operator,
            operatorTokenX: seederTokenX,
            ownerTokenX,
            systemProgram: import_web311.SystemProgram.programId,
            payer
          }).instruction()
        );
      }
      if (instructions.length > 0) {
        initializeBinArraysAndPositionIxs.push(instructions);
        instructions = [];
      }
      const positionDeposited = positionAccount && decodeAccount(
        this.program,
        "positionV2",
        positionAccount.data
      ).liquidityShares.reduce((total, cur) => total.add(cur), new import_anchor.BN(0)).gt(new import_anchor.BN(0));
      if (!positionDeposited) {
        let overflowDefaultBinArrayBitmap = false;
        for (const binArrayIndex of binArrayIndexes) {
          if (isOverflowDefaultBinArrayBitmap(binArrayIndex)) {
            if (!this.binArrayBitmapExtension && !appendedInitBinArrayBitmap) {
              initializeBinArraysAndPositionIxs.push(
                await this.program.methods.initializeBinArrayBitmapExtension().accountsPartial({
                  binArrayBitmapExtension,
                  funder: payer,
                  lbPair: this.pubkey
                }).instruction()
              );
              appendedInitBinArrayBitmap = true;
              binArrayBitmapLamports = binArrayBitmapLamports.add(
                BIN_ARRAY_BITMAP_FEE_BN
              );
            }
            overflowDefaultBinArrayBitmap = true;
          }
        }
        const cappedUpperBinId = Math.min(
          upperBinId.toNumber(),
          maxBinId.toNumber() - 1
        );
        const bins = [];
        for (let i2 = lowerBinId.toNumber(); i2 <= cappedUpperBinId; i2++) {
          bins.push({
            binId: i2,
            amount: compressedBinDepositAmount.get(i2).toNumber()
          });
        }
        instructions.push(
          await this.program.methods.addLiquidityOneSidePrecise2(
            {
              bins,
              decompressMultiplier,
              maxAmount: U64_MAX
            },
            {
              slices
            }
          ).accountsPartial({
            position: positionPda,
            lbPair: this.pubkey,
            binArrayBitmapExtension: overflowDefaultBinArrayBitmap ? binArrayBitmapExtension : this.program.programId,
            userToken: seederTokenX,
            reserve: this.lbPair.reserveX,
            tokenMint: this.lbPair.tokenXMint,
            sender: operator,
            tokenProgram: this.tokenX.owner
          }).remainingAccounts([
            ...transferHookAccountMetas,
            ...binArrayAccountMetas
          ]).instruction()
        );
        if (i + 1 >= positionCount.toNumber() && !finalLoss.isZero()) {
          const finalLossIncludesTransferFee = calculateTransferFeeIncludedAmount(
            finalLoss,
            this.tokenX.mint,
            this.clock.epoch.toNumber()
          ).amount;
          instructions.push(
            await this.program.methods.addLiquidity2(
              {
                amountX: finalLossIncludesTransferFee,
                amountY: new import_anchor.BN(0),
                binLiquidityDist: [
                  {
                    binId: cappedUpperBinId,
                    distributionX: BASIS_POINT_MAX,
                    distributionY: BASIS_POINT_MAX
                  }
                ]
              },
              {
                slices
              }
            ).accountsPartial({
              position: positionPda,
              lbPair: this.pubkey,
              binArrayBitmapExtension: overflowDefaultBinArrayBitmap ? binArrayBitmapExtension : this.program.programId,
              userTokenX: seederTokenX,
              userTokenY: seederTokenY,
              reserveX: this.lbPair.reserveX,
              reserveY: this.lbPair.reserveY,
              tokenXMint: this.lbPair.tokenXMint,
              tokenYMint: this.lbPair.tokenYMint,
              tokenXProgram: this.tokenX.owner,
              tokenYProgram: this.tokenY.owner,
              sender: operator
            }).remainingAccounts([
              ...transferHookAccountMetas,
              ...getBinArrayAccountMetasCoverage(
                new import_anchor.BN(cappedUpperBinId),
                new import_anchor.BN(cappedUpperBinId),
                this.pubkey,
                this.program.programId
              )
            ]).instruction()
          );
        }
        addLiquidityIxs.push([
          import_web311.ComputeBudgetProgram.setComputeUnitLimit({
            units: DEFAULT_ADD_LIQUIDITY_CU
          }),
          ...instructions
        ]);
      }
    }
    return {
      sendPositionOwnerTokenProveIxs,
      initializeBinArraysAndPositionIxs,
      addLiquidityIxs,
      costBreakdown: {
        tokenOwnerProveAssociatedTokenAccountLamports,
        totalBinArraysCount,
        totalBinArraysLamports,
        totalPositionCount,
        totalPositionLamports,
        binArrayBitmapLamports
      }
    };
  }
  /**
   * The `seedLiquiditySingleBin` function seed liquidity into a single bin.
   * @param
   *    - `payer`: The public key of the tx payer.
   *    - `base`: Base key
   *    - `seedAmount`: Token X lamport amount to be seeded to the pool.
   *    - `price`: TokenX/TokenY Price in UI format
   *    - `roundingUp`: Whether to round up the price
   *    - `positionOwner`: The owner of the position
   *    - `feeOwner`: Position fee owner
   *    - `operator`: Operator of the position. Operator able to manage the position on behalf of the position owner. However, liquidity withdrawal issue by the operator can only send to the position owner.
   *    - `lockReleasePoint`: The lock release point of the position.
   *    - `shouldSeedPositionOwner` (optional): Whether to send 1 lamport amount of token X to the position owner to prove ownership.
   *
   * The returned instructions need to be executed sequentially if it was separated into multiple transactions.
   * @returns {Promise<SeedLiquiditySingleBinResponse>}
   */
  async seedLiquiditySingleBin(payer, base, seedAmount, price, roundingUp, positionOwner, feeOwner, operator, lockReleasePoint, shouldSeedPositionOwner = false) {
    let tokenOwnerProveAssociatedTokenAccountLamports = new import_anchor.BN(0);
    let totalPositionCount = new import_anchor.BN(0);
    let totalPositionLamports = new import_anchor.BN(0);
    let totalBinArraysCount = new import_anchor.BN(0);
    let totalBinArraysLamports = new import_anchor.BN(0);
    let binArrayBitmapLamports = new import_anchor.BN(0);
    const pricePerLamport = DLMM.getPricePerLamport(
      this.tokenX.mint.decimals,
      this.tokenY.mint.decimals,
      price
    );
    const binIdNumber = DLMM.getBinIdFromPrice(
      pricePerLamport,
      this.lbPair.binStep,
      !roundingUp
    );
    const binId = new import_anchor.BN(binIdNumber);
    const [positionPda] = derivePosition(
      this.pubkey,
      base,
      binId,
      new import_anchor.BN(1),
      this.program.programId
    );
    const binArrayIndex = binIdToBinArrayIndex(binId);
    const [binArrayKey] = deriveBinArray(
      this.pubkey,
      binArrayIndex,
      this.program.programId
    );
    const preInstructions = [];
    const [
      { ataPubKey: userTokenX, ix: createPayerTokenXIx },
      { ataPubKey: userTokenY, ix: createPayerTokenYIx }
    ] = await Promise.all([
      getOrCreateATAInstruction(
        this.program.provider.connection,
        this.tokenX.publicKey,
        operator,
        this.tokenX.owner,
        payer
      ),
      getOrCreateATAInstruction(
        this.program.provider.connection,
        this.tokenY.publicKey,
        operator,
        this.tokenY.owner,
        payer
      )
    ]);
    createPayerTokenXIx && preInstructions.push(createPayerTokenXIx);
    createPayerTokenYIx && preInstructions.push(createPayerTokenYIx);
    let [binArrayBitmapExtension] = deriveBinArrayBitmapExtension(
      this.pubkey,
      this.program.programId
    );
    const [binArrayAccount, positionAccount, bitmapExtensionAccount] = await this.program.provider.connection.getMultipleAccountsInfo([
      binArrayKey,
      positionPda,
      binArrayBitmapExtension
    ]);
    if (isOverflowDefaultBinArrayBitmap(binArrayIndex)) {
      if (!bitmapExtensionAccount) {
        preInstructions.push(
          await this.program.methods.initializeBinArrayBitmapExtension().accountsPartial({
            binArrayBitmapExtension,
            funder: payer,
            lbPair: this.pubkey
          }).instruction()
        );
        binArrayBitmapLamports = binArrayBitmapLamports.add(
          BIN_ARRAY_BITMAP_FEE_BN
        );
      }
    } else {
      binArrayBitmapExtension = this.program.programId;
    }
    const operatorTokenX = getAssociatedTokenAddressSync(
      this.lbPair.tokenXMint,
      operator,
      true,
      this.tokenX.owner
    );
    const positionOwnerTokenX = getAssociatedTokenAddressSync(
      this.lbPair.tokenXMint,
      positionOwner,
      true,
      this.tokenX.owner
    );
    if (shouldSeedPositionOwner) {
      const positionOwnerTokenXAccount = await this.program.provider.connection.getAccountInfo(
        positionOwnerTokenX
      );
      const proveAmount = calculateTransferFeeIncludedAmount(
        new import_anchor.BN(1),
        this.tokenX.mint,
        this.clock.epoch.toNumber()
      ).amount;
      if (positionOwnerTokenXAccount) {
        const account = unpackAccount(
          positionOwnerTokenX,
          positionOwnerTokenXAccount,
          this.tokenX.owner
        );
        if (account.amount == BigInt(0)) {
          const transferIx = createTransferCheckedInstruction(
            operatorTokenX,
            this.lbPair.tokenXMint,
            positionOwnerTokenX,
            operator,
            BigInt(proveAmount.toString()),
            this.tokenX.mint.decimals,
            [],
            this.tokenX.owner
          );
          transferIx.keys.push(...this.tokenX.transferHookAccountMetas);
          preInstructions.push(transferIx);
        }
      } else {
        const createPositionOwnerTokenXIx = createAssociatedTokenAccountIdempotentInstruction(
          payer,
          positionOwnerTokenX,
          positionOwner,
          this.lbPair.tokenXMint,
          this.tokenX.owner
        );
        preInstructions.push(createPositionOwnerTokenXIx);
        const transferIx = createTransferCheckedInstruction(
          operatorTokenX,
          this.lbPair.tokenXMint,
          positionOwnerTokenX,
          operator,
          BigInt(proveAmount.toString()),
          this.tokenX.mint.decimals,
          [],
          this.tokenX.owner
        );
        transferIx.keys.push(...this.tokenX.transferHookAccountMetas);
        preInstructions.push(transferIx);
        tokenOwnerProveAssociatedTokenAccountLamports = tokenOwnerProveAssociatedTokenAccountLamports.add(
          TOKEN_ACCOUNT_FEE_BN
        );
      }
    }
    if (!binArrayAccount) {
      preInstructions.push(
        await this.program.methods.initializeBinArray(binArrayIndex).accountsPartial({
          binArray: binArrayKey,
          funder: payer,
          lbPair: this.pubkey
        }).instruction()
      );
      totalBinArraysCount = totalBinArraysCount.add(new import_anchor.BN(1));
      totalBinArraysLamports = totalBinArraysLamports.add(BIN_ARRAY_FEE_BN);
    }
    if (!positionAccount) {
      preInstructions.push(
        await this.program.methods.initializePositionByOperator(
          binId.toNumber(),
          1,
          feeOwner,
          lockReleasePoint
        ).accountsPartial({
          payer,
          base,
          position: positionPda,
          lbPair: this.pubkey,
          owner: positionOwner,
          operator,
          operatorTokenX,
          ownerTokenX: positionOwnerTokenX
        }).instruction()
      );
      totalPositionCount = totalPositionCount.add(new import_anchor.BN(1));
      totalPositionLamports = totalPositionLamports.add(POSITION_FEE_BN);
    }
    const slices = [
      {
        accountsType: {
          transferHookX: {}
        },
        length: this.tokenX.transferHookAccountMetas.length
      }
    ];
    const transferHookAccountMetas = this.tokenX.transferHookAccountMetas;
    const binLiquidityDist = {
      binId: binIdNumber,
      distributionX: BASIS_POINT_MAX,
      distributionY: BASIS_POINT_MAX
    };
    const seedAmountIncludeTransferFee = calculateTransferFeeIncludedAmount(
      seedAmount,
      this.tokenX.mint,
      this.clock.epoch.toNumber()
    ).amount;
    const addLiquidityParams = {
      amountX: seedAmountIncludeTransferFee,
      amountY: new import_anchor.BN(0),
      binLiquidityDist: [binLiquidityDist]
    };
    const depositLiquidityIx = await this.program.methods.addLiquidity2(addLiquidityParams, {
      slices
    }).accountsPartial({
      position: positionPda,
      lbPair: this.pubkey,
      binArrayBitmapExtension,
      userTokenX,
      userTokenY,
      reserveX: this.lbPair.reserveX,
      reserveY: this.lbPair.reserveY,
      tokenXMint: this.lbPair.tokenXMint,
      tokenYMint: this.lbPair.tokenYMint,
      sender: operator,
      tokenXProgram: this.tokenX.owner,
      tokenYProgram: this.tokenY.owner
    }).remainingAccounts([
      ...transferHookAccountMetas,
      {
        pubkey: binArrayKey,
        isSigner: false,
        isWritable: true
      }
    ]).instruction();
    const instructions = [...preInstructions, depositLiquidityIx];
    return {
      instructions,
      costBreakdown: {
        tokenOwnerProveAssociatedTokenAccountLamports,
        totalBinArraysCount,
        totalBinArraysLamports,
        totalPositionCount,
        totalPositionLamports,
        binArrayBitmapLamports
      }
    };
  }
  /**
   * Initializes bin arrays for the given bin array indexes if it wasn't initialized.
   *
   * @param {BN[]} binArrayIndexes - An array of bin array indexes to initialize.
   * @param {PublicKey} funder - The public key of the funder.
   * @return {Promise<TransactionInstruction[]>} An array of transaction instructions to initialize the bin arrays.
   */
  async initializeBinArrays(binArrayIndexes, funder) {
    const ixs = [];
    for (const idx of binArrayIndexes) {
      const [binArray] = deriveBinArray(
        this.pubkey,
        idx,
        this.program.programId
      );
      const binArrayAccount = await this.program.provider.connection.getAccountInfo(binArray);
      if (binArrayAccount === null) {
        const initBinArrayIx = await this.program.methods.initializeBinArray(idx).accountsPartial({
          binArray,
          funder,
          lbPair: this.pubkey
        }).instruction();
        ixs.push(initBinArrayIx);
      }
    }
    if (ixs.length > 0) {
      const setCUIx = await getEstimatedComputeUnitIxWithBuffer(
        this.program.provider.connection,
        ixs,
        funder
      );
      ixs.unshift(setCUIx);
    }
    return ixs;
  }
  /**
   *
   * @param
   *    - `lowerBinId`: Lower bin ID of the position. This represent the lowest price of the position
   *    - `positionWidth`: Width of the position. This will decide the upper bin id of the position, which represents the highest price of the position. UpperBinId = lowerBinId + positionWidth
   *    - `owner`: Owner of the position.
   *    - `operator`: Operator of the position. Operator able to manage the position on behalf of the position owner. However, liquidity withdrawal issue by the operator can only send to the position owner.
   *    - `base`: Base key
   *    - `feeOwner`: Owner of the fees earned by the position.
   *    - `payer`: Payer for the position account rental.
   *    - `lockReleasePoint`: The lock release point of the position.
   * @returns
   */
  async initializePositionByOperator({
    lowerBinId,
    positionWidth,
    owner,
    feeOwner,
    base,
    operator,
    payer,
    lockReleasePoint
  }) {
    const [positionPda, _bump] = derivePosition(
      this.pubkey,
      base,
      lowerBinId,
      positionWidth,
      this.program.programId
    );
    const operatorTokenX = getAssociatedTokenAddressSync(
      this.lbPair.tokenXMint,
      operator,
      true,
      this.tokenX.owner
    );
    const ownerTokenX = getAssociatedTokenAddressSync(
      this.lbPair.tokenXMint,
      owner,
      true,
      this.tokenY.owner
    );
    const initializePositionByOperatorTx = await this.program.methods.initializePositionByOperator(
      lowerBinId.toNumber(),
      DEFAULT_BIN_PER_POSITION.toNumber(),
      feeOwner,
      lockReleasePoint
    ).accountsPartial({
      lbPair: this.pubkey,
      position: positionPda,
      base,
      operator,
      owner,
      ownerTokenX,
      operatorTokenX,
      payer
    }).transaction();
    const { blockhash, lastValidBlockHeight } = await this.program.provider.connection.getLatestBlockhash("confirmed");
    return new import_web311.Transaction({
      feePayer: operator,
      blockhash,
      lastValidBlockHeight
    }).add(initializePositionByOperatorTx);
  }
  /**
   * The `claimAllRewards` function to claim swap fees and LM rewards for multiple positions owned by a specific owner.
   * @param
   *    - `owner`: The public key of the owner of the positions.
   *    - `positions`: An array of objects of type `PositionData` that represents the positions to claim swap fees and LM rewards from.
   * @returns {Promise<Transaction[]>} Array of claim swap fee and LM reward transactions.
   */
  async claimAllRewards({
    owner,
    positions
  }) {
    positions = positions.filter(
      ({ positionData: { feeX, feeY, rewardOne, rewardTwo } }) => !feeX.isZero() || !feeY.isZero() || !rewardOne.isZero() || !rewardTwo.isZero()
    );
    const claimAllSwapFeeTxs = (await Promise.all(
      positions.map(async (position) => {
        return await this.createClaimSwapFeeMethod({
          owner,
          position
        });
      })
    )).flat();
    const claimAllLMTxs = (await Promise.all(
      positions.map(async (position) => {
        return await this.createClaimBuildMethod({
          owner,
          position
        });
      })
    )).flat();
    const transactions = chunks(
      [...claimAllSwapFeeTxs, ...claimAllLMTxs],
      MAX_CLAIM_ALL_ALLOWED
    );
    const { blockhash, lastValidBlockHeight } = await this.program.provider.connection.getLatestBlockhash("confirmed");
    return Promise.all(
      transactions.map(async (txs) => {
        const instructions = txs.flatMap((i) => i.instructions);
        const setCUIx = await getEstimatedComputeUnitIxWithBuffer(
          this.program.provider.connection,
          instructions,
          owner
        );
        const transaction = new import_web311.Transaction({
          feePayer: owner,
          blockhash,
          lastValidBlockHeight
        }).add(setCUIx, ...instructions);
        return transaction;
      })
    );
  }
  canSyncWithMarketPrice(marketPrice, activeBinId) {
    const marketPriceBinId = this.getBinIdFromPrice(
      Number(
        DLMM.getPricePerLamport(
          this.tokenX.mint.decimals,
          this.tokenY.mint.decimals,
          marketPrice
        )
      ),
      false
    );
    const marketPriceBinArrayIndex = binIdToBinArrayIndex(
      new import_anchor.BN(marketPriceBinId)
    );
    const swapForY = marketPriceBinId < activeBinId;
    const toBinArrayIndex = findNextBinArrayIndexWithLiquidity(
      swapForY,
      new import_anchor.BN(activeBinId),
      this.lbPair,
      this.binArrayBitmapExtension?.account ?? null
    );
    if (toBinArrayIndex === null)
      return true;
    return swapForY ? marketPriceBinArrayIndex.gt(toBinArrayIndex) : marketPriceBinArrayIndex.lt(toBinArrayIndex);
  }
  /**
   * The `syncWithMarketPrice` function is used to sync the liquidity pool with the market price.
   * @param
   *    - `marketPrice`: The market price to sync with.
   *    - `owner`: The public key of the owner of the liquidity pool.
   * @returns {Promise<Transaction>}
   */
  async syncWithMarketPrice(marketPrice, owner) {
    const marketPriceBinId = this.getBinIdFromPrice(
      Number(
        DLMM.getPricePerLamport(
          this.tokenX.mint.decimals,
          this.tokenY.mint.decimals,
          marketPrice
        )
      ),
      false
    );
    const activeBin = await this.getActiveBin();
    const activeBinId = activeBin.binId;
    if (!this.canSyncWithMarketPrice(marketPrice, activeBinId)) {
      throw new Error(
        "Unable to sync with market price due to bin with liquidity between current and market price bin"
      );
    }
    const fromBinArrayIndex = binIdToBinArrayIndex(new import_anchor.BN(activeBinId));
    const swapForY = marketPriceBinId < activeBinId;
    const toBinArrayIndex = findNextBinArrayIndexWithLiquidity(
      swapForY,
      new import_anchor.BN(activeBinId),
      this.lbPair,
      this.binArrayBitmapExtension?.account ?? null
    );
    const marketPriceBinArrayIndex = binIdToBinArrayIndex(
      new import_anchor.BN(marketPriceBinId)
    );
    const accountsToFetch = [];
    const binArrayBitMapExtensionPubkey = isOverflowDefaultBinArrayBitmap(
      new import_anchor.BN(marketPriceBinArrayIndex)
    ) ? deriveBinArrayBitmapExtension(this.pubkey, this.program.programId)[0] : null;
    binArrayBitMapExtensionPubkey && accountsToFetch.push(binArrayBitMapExtensionPubkey);
    const [fromBinArrayPubkey] = deriveBinArray(
      this.pubkey,
      fromBinArrayIndex,
      this.program.programId
    );
    accountsToFetch.push(fromBinArrayPubkey);
    const toBinArrayPubkey = (() => {
      if (!toBinArrayIndex)
        return null;
      const [toBinArrayPubkey2] = deriveBinArray(
        this.pubkey,
        toBinArrayIndex,
        this.program.programId
      );
      accountsToFetch.push(toBinArrayPubkey2);
      return toBinArrayPubkey2;
    })();
    const binArrayAccounts = await this.program.provider.connection.getMultipleAccountsInfo(
      accountsToFetch
    );
    const preInstructions = [];
    let fromBinArray = null;
    let toBinArray = null;
    let binArrayBitmapExtension = null;
    if (binArrayBitMapExtensionPubkey) {
      binArrayBitmapExtension = binArrayBitMapExtensionPubkey;
      if (!binArrayAccounts?.[0]) {
        const initializeBitmapExtensionIx = await this.program.methods.initializeBinArrayBitmapExtension().accountsPartial({
          binArrayBitmapExtension: binArrayBitMapExtensionPubkey,
          funder: owner,
          lbPair: this.pubkey
        }).instruction();
        preInstructions.push(initializeBitmapExtensionIx);
      }
    }
    if (!!binArrayAccounts?.[1]) {
      fromBinArray = fromBinArrayPubkey;
    }
    if (!!binArrayAccounts?.[2] && !!toBinArrayIndex) {
      toBinArray = toBinArrayPubkey;
    }
    const { blockhash, lastValidBlockHeight } = await this.program.provider.connection.getLatestBlockhash("confirmed");
    const syncWithMarketPriceTx = await this.program.methods.goToABin(marketPriceBinId).accountsPartial({
      lbPair: this.pubkey,
      binArrayBitmapExtension,
      fromBinArray,
      toBinArray
    }).preInstructions(preInstructions).transaction();
    return new import_web311.Transaction({
      feePayer: owner,
      blockhash,
      lastValidBlockHeight
    }).add(syncWithMarketPriceTx);
  }
  async getMaxPriceInBinArrays(binArrayAccounts) {
    const sortedBinArrays = [...binArrayAccounts].sort(
      ({ account: { index: indexA } }, { account: { index: indexB } }) => indexA.toNumber() - indexB.toNumber()
    );
    let count = sortedBinArrays.length - 1;
    let binPriceWithLastLiquidity;
    while (count >= 0) {
      const binArray = sortedBinArrays[count];
      if (binArray) {
        const bins = binArray.account.bins;
        if (bins.every(({ amountX }) => amountX.isZero())) {
          count--;
        } else {
          const lastBinWithLiquidityIndex = bins.findLastIndex(
            ({ amountX }) => !amountX.isZero()
          );
          binPriceWithLastLiquidity = bins[lastBinWithLiquidityIndex].price.toString();
          count = -1;
        }
      }
    }
    return this.fromPricePerLamport(
      Number(binPriceWithLastLiquidity) / (2 ** 64 - 1)
    );
  }
  /**
   *
   * @param swapInitiator Address of the swap initiator
   * @returns
   */
  isSwapDisabled(swapInitiator) {
    if (this.lbPair.status == 1) {
      return true;
    }
    if (this.lbPair.pairType == 1) {
      const currentPoint = this.lbPair.activationType == 0 ? this.clock.slot : this.clock.unixTimestamp;
      const preActivationSwapPoint = this.lbPair.activationPoint.sub(
        this.lbPair.preActivationDuration
      );
      const activationPoint = !this.lbPair.preActivationSwapAddress.equals(import_web311.PublicKey.default) && this.lbPair.preActivationSwapAddress.equals(swapInitiator) ? preActivationSwapPoint : this.lbPair.activationPoint;
      if (currentPoint < activationPoint) {
        return true;
      }
    }
    return false;
  }
  /**
   * Decrease the length of a position. The segment of the position to be decreased must be empty.
   *
   * @param position The public key of the position to decrease.
   * @param side The side of the position to decrease.
   * @param length The amount of length to decrease.
   * @param allowParallelExecution If true, the instructions will be grouped to allow parallel execution. Otherwise, the instructions will be executed sequentially.
   * @returns An array of transactions if allowParallelExecution is true. Otherwise, an empty array.
   */
  async decreasePositionLength(position, side, length, allowParallelExecution = true) {
    const positionAccount = await this.program.provider.connection.getAccountInfo(position);
    const positionState = wrapPosition(this.program, position, positionAccount);
    const newWidth = positionState.width().sub(length);
    if (newWidth.lte(new import_anchor.BN(0))) {
      length = length.sub(newWidth.abs()).subn(1);
    }
    const groupedIxs = [];
    const promises = [];
    for (let i = length.toNumber(); i > 0; i -= MAX_RESIZE_LENGTH.toNumber()) {
      const lengthToReduce = Math.min(i, MAX_RESIZE_LENGTH.toNumber());
      const setCuIx = import_web311.ComputeBudgetProgram.setComputeUnitLimit({
        units: getDefaultExtendPositionCU(side)
      });
      const ixPromise = this.program.methods.decreasePositionLength(lengthToReduce, Number(side)).accountsPartial({
        position,
        owner: positionState.owner(),
        rentReceiver: positionState.owner()
      }).instruction().then((decreasePositionLengthIx) => {
        if (allowParallelExecution) {
          decreasePositionLengthIx.keys.push({
            isSigner: false,
            isWritable: false,
            pubkey: import_web311.PublicKey.unique()
          });
        }
        const ixs = [setCuIx, decreasePositionLengthIx];
        groupedIxs.push(ixs);
      });
      promises.push(ixPromise);
    }
    await Promise.all(promises);
    if (groupedIxs.length > 0) {
      const { blockhash, lastValidBlockHeight } = await this.program.provider.connection.getLatestBlockhash("confirmed");
      return groupedIxs.map((ixs) => {
        return new import_web311.Transaction({
          feePayer: positionState.owner(),
          blockhash,
          lastValidBlockHeight
        }).add(...ixs);
      });
    }
  }
  /**
   * Expand the position bin range to the left or right (lower or upper).
   *
   * @param position The address of the position to increase the length of.
   * @param side The side of the position to increase the length of. Must be either
   *             ResizeSide.Lower or ResizeSide.Upper.
   * @param length The number of bins to increase the length of. Position length after increase must be <= 1400.
   * @param funder The address to account rental and transaction fee.
   * @param allowParallelExecution Whether to allow parallel execution of the transaction.
   * @returns The transaction to execute this instruction.
   */
  async increasePositionLength(position, side, length, funder, allowParallelExecution = true) {
    const positionAccount = await this.program.provider.connection.getAccountInfo(position);
    const positionState = wrapPosition(this.program, position, positionAccount);
    const newWidth = positionState.width().add(length);
    if (newWidth.gt(POSITION_MAX_LENGTH)) {
      length = newWidth.sub(POSITION_MAX_LENGTH);
    }
    const groupedIxs = await this.increasePositionLengthIxs(
      position,
      side,
      length,
      funder,
      positionState.owner(),
      true,
      allowParallelExecution
    );
    if (groupedIxs.length > 0) {
      const { blockhash, lastValidBlockHeight } = await this.program.provider.connection.getLatestBlockhash("confirmed");
      return groupedIxs.map((ixs) => {
        return new import_web311.Transaction({
          feePayer: funder,
          blockhash,
          lastValidBlockHeight
        }).add(...ixs);
      });
    }
  }
  async simulateRebalancePositionWithBalancedStrategy(positionAddress, positionData, strategy, topUpAmountX, topUpAmountY, xWithdrawBps, yWithdrawBps) {
    const rebalancePosition = await RebalancePosition.create({
      program: this.program,
      positionAddress,
      positionData,
      shouldClaimFee: true,
      shouldClaimReward: true,
      pairAddress: this.pubkey
    });
    const rebalanceStrategyBuilder = new BalancedStrategyBuilder(
      new import_anchor.BN(rebalancePosition.lbPair.activeId),
      new import_anchor.BN(rebalancePosition.lbPair.binStep),
      positionData,
      topUpAmountX,
      topUpAmountY,
      xWithdrawBps,
      yWithdrawBps,
      strategy
    );
    return this.simulateRebalancePositionWithStrategy(
      rebalancePosition,
      rebalanceStrategyBuilder
    );
  }
  async simulateRebalancePositionWithStrategy(rebalancePosition, rebalanceStrategy) {
    const { deposits, withdraws } = rebalanceStrategy.buildRebalanceStrategyParameters();
    const simulationResult = await rebalancePosition.simulateRebalance(
      this.program.provider.connection,
      new import_anchor.BN(this.lbPair.binStep),
      new import_anchor.BN(this.tokenX.mint.decimals),
      new import_anchor.BN(this.tokenY.mint.decimals),
      withdraws,
      deposits
    );
    const binArrayQuoteResult = await this.quoteBinArrayAccountsRentalCost(
      simulationResult.depositParams,
      simulationResult.withdrawParams,
      new import_anchor.BN(rebalancePosition.lbPair.activeId)
    );
    return {
      rebalancePosition,
      simulationResult,
      ...binArrayQuoteResult
    };
  }
  async quoteBinArrayAccountsRentalCost(deposits, withdraws, activeId) {
    const { binArrayBitmap, binArrayIndexes } = getRebalanceBinArrayIndexesAndBitmapCoverage(
      deposits,
      withdraws,
      activeId.toNumber(),
      this.pubkey,
      this.program.programId
    );
    const binArrayPublicKeys = binArrayIndexes.map((index) => {
      const [binArrayPubkey] = deriveBinArray(
        this.pubkey,
        index,
        this.program.programId
      );
      return binArrayPubkey;
    });
    const accountPublicKeys = [...binArrayPublicKeys];
    if (!binArrayBitmap.equals(import_web311.PublicKey.default)) {
      accountPublicKeys.push(binArrayBitmap);
    }
    const accounts = await chunkedGetMultipleAccountInfos(
      this.program.provider.connection,
      binArrayPublicKeys
    );
    const binArrayAccounts = accounts.splice(0, binArrayPublicKeys.length);
    let binArrayCount = 0;
    let bitmapExtensionCost = 0;
    const binArraySet = /* @__PURE__ */ new Set();
    for (let i = 0; i < binArrayAccounts.length; i++) {
      const binArrayAccount = binArrayAccounts[i];
      const binArrayPubkey = binArrayPublicKeys[i];
      if (!binArrayAccount) {
        binArrayCount++;
      } else {
        binArraySet.add(binArrayPubkey.toBase58());
      }
    }
    if (!binArrayBitmap.equals(import_web311.PublicKey.default)) {
      const bitmapAccount = accounts.pop();
      if (!bitmapAccount) {
        bitmapExtensionCost = BIN_ARRAY_BITMAP_FEE;
      }
    }
    return {
      binArrayCost: binArrayCount * BIN_ARRAY_FEE,
      binArrayCount,
      binArrayExistence: binArraySet,
      bitmapExtensionCost
    };
  }
  /**
   * Simulates a rebalance operation on a position without actually executing it. It's recommended to use simulateRebalancePositionWithXStrategy instead unless you know what you're doing.
   *
   * @param positionAddress The address of the position to simulate rebalancing.
   * @param positionData The PositionData object associated with the position.
   * @param shouldClaimFee True if the fee should be claimed during rebalancing.
   * @param shouldClaimReward True if the reward should be claimed during rebalancing.
   * @param deposits An array of RebalanceWithDeposit objects representing the deposits to simulate.
   * @param withdraws An array of RebalanceWithWithdraw objects representing the withdraws to simulate.
   */
  async simulateRebalancePosition(positionAddress, positionData, shouldClaimFee, shouldClaimReward, deposits, withdraws) {
    const rebalancePosition = await RebalancePosition.create({
      program: this.program,
      positionAddress,
      positionData,
      shouldClaimFee,
      shouldClaimReward,
      pairAddress: this.pubkey
    });
    const simulationResult = await rebalancePosition.simulateRebalance(
      this.program.provider.connection,
      new import_anchor.BN(this.lbPair.binStep),
      new import_anchor.BN(this.tokenX.mint.decimals),
      new import_anchor.BN(this.tokenY.mint.decimals),
      withdraws,
      deposits
    );
    const binArrayQuoteResult = await this.quoteBinArrayAccountsRentalCost(
      simulationResult.depositParams,
      simulationResult.withdrawParams,
      new import_anchor.BN(rebalancePosition.lbPair.activeId)
    );
    return {
      rebalancePosition,
      simulationResult,
      ...binArrayQuoteResult
    };
  }
  /**
   * Rebalances a position and claim rewards if specified.
   *
   * @param rebalancePositionResponse The result of `simulateRebalancePosition`.
   * @param maxActiveBinSlippage The maximum slippage allowed for active bin selection.
   * @param slippage The slippage tolerance percentage for rebalncing.
   *
   * @returns An object containing the instructions to initialize new bin arrays and the instruction to rebalance the position.
   */
  async rebalancePosition(rebalancePositionResponse, maxActiveBinSlippage, rentPayer, slippage = 100) {
    const { rebalancePosition, simulationResult } = rebalancePositionResponse;
    const { lbPair, shouldClaimFee, shouldClaimReward, owner, address } = rebalancePosition;
    const { depositParams, withdrawParams } = simulationResult;
    const activeId = new import_anchor.BN(lbPair.activeId);
    const { slices, accounts: transferHookAccounts } = this.getPotentialToken2022IxDataAndAccounts(
      0
      /* Liquidity */
    );
    const preInstructions = [];
    const harvestRewardRemainingAccountMetas = [];
    if (shouldClaimReward) {
      for (const [idx, reward] of this.lbPair.rewardInfos.entries()) {
        if (!reward.mint.equals(import_web311.PublicKey.default)) {
          const rewardTokenInfo = this.rewards[idx];
          slices.push({
            accountsType: {
              transferHookMultiReward: {
                0: idx
              }
            },
            length: rewardTokenInfo.transferHookAccountMetas.length
          });
          transferHookAccounts.push(
            ...rewardTokenInfo.transferHookAccountMetas
          );
          const userTokenRewardAddress = getAssociatedTokenAddressSync(
            reward.mint,
            owner,
            true,
            rewardTokenInfo.owner
          );
          preInstructions.push(
            createAssociatedTokenAccountIdempotentInstruction(
              owner,
              userTokenRewardAddress,
              owner,
              reward.mint,
              rewardTokenInfo.owner
            )
          );
          const rewardVault = {
            pubkey: reward.vault,
            isSigner: false,
            isWritable: true
          };
          const userTokenReward = {
            pubkey: userTokenRewardAddress,
            isSigner: false,
            isWritable: true
          };
          const rewardMint = {
            pubkey: reward.mint,
            isSigner: false,
            isWritable: false
          };
          const rewardTokenProgram = {
            pubkey: rewardTokenInfo.owner,
            isSigner: false,
            isWritable: false
          };
          harvestRewardRemainingAccountMetas.push(
            rewardVault,
            userTokenReward,
            rewardMint,
            rewardTokenProgram
          );
        }
      }
    }
    const initBinArrayInstructions = [];
    const { binArrayBitmap, binArrayIndexes } = getRebalanceBinArrayIndexesAndBitmapCoverage(
      depositParams,
      withdrawParams,
      activeId.toNumber(),
      this.pubkey,
      this.program.programId
    );
    const binArrayPublicKeys = binArrayIndexes.map((index) => {
      const [binArrayPubkey] = deriveBinArray(
        this.pubkey,
        index,
        this.program.programId
      );
      return binArrayPubkey;
    });
    const binArrayAccounts = await chunkedGetMultipleAccountInfos(
      this.program.provider.connection,
      binArrayPublicKeys
    );
    for (let i = 0; i < binArrayAccounts.length; i++) {
      const binArrayAccount = binArrayAccounts[i];
      if (!binArrayAccount) {
        const binArrayPubkey = binArrayPublicKeys[i];
        const binArrayIndex = binArrayIndexes[i];
        const initBinArrayIx = await this.program.methods.initializeBinArray(binArrayIndex).accountsPartial({
          binArray: binArrayPubkey,
          funder: owner,
          lbPair: this.pubkey
        }).instruction();
        initBinArrayInstructions.push(initBinArrayIx);
      }
    }
    if (!binArrayBitmap.equals(import_web311.PublicKey.default)) {
      const bitmapAccount = await this.program.provider.connection.getAccountInfo(binArrayBitmap);
      if (!bitmapAccount) {
        const initBitmapExtensionIx = await this.program.methods.initializeBinArrayBitmapExtension().accountsPartial({
          binArrayBitmapExtension: binArrayBitmap,
          funder: owner,
          lbPair: this.pubkey
        }).preInstructions([
          import_web311.ComputeBudgetProgram.setComputeUnitLimit({
            units: DEFAULT_INIT_BIN_ARRAY_CU
          })
        ]).instruction();
        preInstructions.push(initBitmapExtensionIx);
      }
    }
    const [
      { ataPubKey: userTokenX, ix: createUserTokenXIx },
      { ataPubKey: userTokenY, ix: createUserTokenYIx }
    ] = await Promise.all([
      getOrCreateATAInstruction(
        this.program.provider.connection,
        this.tokenX.publicKey,
        owner,
        this.tokenX.owner
      ),
      getOrCreateATAInstruction(
        this.program.provider.connection,
        this.tokenY.publicKey,
        owner,
        this.tokenY.owner
      )
    ]);
    createUserTokenXIx && preInstructions.push(createUserTokenXIx);
    createUserTokenYIx && preInstructions.push(createUserTokenYIx);
    slippage = capSlippagePercentage(slippage);
    const maxDepositXAmount = getSlippageMaxAmount(
      simulationResult.actualAmountXDeposited,
      slippage
    );
    const maxDepositYAmount = getSlippageMaxAmount(
      simulationResult.actualAmountYDeposited,
      slippage
    );
    const minWithdrawXAmount = getSlippageMinAmount(
      simulationResult.actualAmountXWithdrawn,
      slippage
    );
    const minWithdrawYAmount = getSlippageMinAmount(
      simulationResult.actualAmountYWithdrawn,
      slippage
    );
    const postInstructions = [];
    if (this.tokenX.publicKey.equals(NATIVE_MINT) && simulationResult.actualAmountXDeposited.gtn(0) && !this.opt?.skipSolWrappingOperation) {
      const wrapSOLIx = wrapSOLInstruction(
        owner,
        userTokenX,
        BigInt(simulationResult.actualAmountXDeposited.toString())
      );
      preInstructions.push(...wrapSOLIx);
    }
    if (this.tokenY.publicKey.equals(NATIVE_MINT) && simulationResult.actualAmountYDeposited.gtn(0) && !this.opt?.skipSolWrappingOperation) {
      const wrapSOLIx = wrapSOLInstruction(
        owner,
        userTokenY,
        BigInt(simulationResult.actualAmountYDeposited.toString())
      );
      preInstructions.push(...wrapSOLIx);
    }
    if ((this.tokenX.publicKey.equals(NATIVE_MINT) || this.tokenY.publicKey.equals(NATIVE_MINT)) && !this.opt?.skipSolWrappingOperation) {
      const closeWrappedSOLIx = await unwrapSOLInstruction(owner);
      closeWrappedSOLIx && postInstructions.push(closeWrappedSOLIx);
    }
    const instruction = await this.program.methods.rebalanceLiquidity(
      {
        adds: depositParams,
        removes: withdrawParams,
        activeId: activeId.toNumber(),
        shouldClaimFee,
        shouldClaimReward,
        maxActiveBinSlippage: maxActiveBinSlippage.toNumber(),
        maxDepositXAmount,
        maxDepositYAmount,
        minWithdrawXAmount,
        minWithdrawYAmount,
        shrinkMode: 0,
        padding: REBALANCE_POSITION_PADDING
      },
      {
        slices
      }
    ).accountsPartial({
      lbPair: this.pubkey,
      binArrayBitmapExtension: binArrayBitmap,
      position: address,
      owner,
      userTokenX,
      userTokenY,
      reserveX: this.lbPair.reserveX,
      reserveY: this.lbPair.reserveY,
      tokenXMint: this.tokenX.publicKey,
      tokenYMint: this.tokenY.publicKey,
      tokenXProgram: this.tokenX.owner,
      tokenYProgram: this.tokenY.owner,
      memoProgram: MEMO_PROGRAM_ID,
      rentPayer: rentPayer ?? owner
    }).remainingAccounts(transferHookAccounts).remainingAccounts(
      binArrayPublicKeys.map((pubkey) => {
        return {
          pubkey,
          isSigner: false,
          isWritable: true
        };
      })
    ).instruction();
    const setCUIX = await getEstimatedComputeUnitIxWithBuffer(
      this.program.provider.connection,
      [instruction],
      owner
    );
    const rebalancePositionInstruction = [
      setCUIX,
      ...preInstructions,
      instruction,
      ...postInstructions
    ];
    return {
      initBinArrayInstructions,
      rebalancePositionInstruction
    };
  }
  /**
   * Create an extended empty position.
   *
   * @param lowerBinid The lowest bin of the position.
   * @param upperBinId The highest bin of the position.
   * @param position The public key of the position.
   * @param owner The owner of the position.
   * @returns The instructions to create the extended empty position.
   */
  async createExtendedEmptyPosition(lowerBinid, upperBinId, position, owner) {
    const positionWidth = upperBinId - lowerBinid + 1;
    const basePositionWidth = Math.min(
      positionWidth,
      DEFAULT_BIN_PER_POSITION.toNumber()
    );
    const ixs = await this.createInitAndExtendPositionIx(
      lowerBinid,
      upperBinId,
      basePositionWidth,
      owner,
      position
    );
    const latestBlockhashInfo = await this.program.provider.connection.getLatestBlockhash();
    const tx = new import_web311.Transaction({
      ...latestBlockhashInfo,
      feePayer: owner
    }).add(...ixs);
    return tx;
  }
  async createInitAndExtendPositionIx(lowerBinId, upperBinId, basePositionWidth, user, position) {
    const createPositionIx = await this.program.methods.initializePosition(lowerBinId, basePositionWidth).accountsPartial({
      payer: user,
      position,
      lbPair: this.pubkey,
      owner: user
    }).instruction();
    const extendedBinCount = getExtendedPositionBinCount(
      new import_anchor.BN(lowerBinId),
      new import_anchor.BN(upperBinId)
    );
    if (extendedBinCount.gt(new import_anchor.BN(0))) {
      const extendPositionIxs = await this.increasePositionLengthIxs(
        position,
        1,
        extendedBinCount,
        user,
        user,
        false,
        false
      );
      const extendPositionDefaultCU = getDefaultExtendPositionCU(
        1
        /* Upper */
      ) * extendedBinCount.toNumber();
      return [
        import_web311.ComputeBudgetProgram.setComputeUnitLimit({
          units: Math.min(
            DEFAULT_INIT_POSITION_CU + extendPositionDefaultCU,
            14e5
          )
        }),
        createPositionIx,
        ...extendPositionIxs.flat()
      ];
    } else {
      return [
        import_web311.ComputeBudgetProgram.setComputeUnitLimit({
          units: DEFAULT_INIT_POSITION_CU
        }),
        createPositionIx
      ];
    }
  }
  async increasePositionLengthIxs(position, side, length, funder, positionOwner, includeSetCuIx = true, allowParallelExecution = true) {
    const groupedIxs = [];
    const promises = [];
    for (let i = 0; i < length.toNumber(); i += MAX_RESIZE_LENGTH.toNumber()) {
      const lengthToAdd = Math.min(
        length.toNumber() - i,
        MAX_RESIZE_LENGTH.toNumber()
      );
      const setCuIx = import_web311.ComputeBudgetProgram.setComputeUnitLimit({
        units: getDefaultExtendPositionCU(side)
      });
      const ixPromise = this.program.methods.increasePositionLength(lengthToAdd, Number(side)).accountsPartial({
        lbPair: this.pubkey,
        position,
        owner: positionOwner,
        funder
      }).instruction().then((increasePositionLengthIx) => {
        if (allowParallelExecution) {
          increasePositionLengthIx.keys.push({
            isSigner: false,
            isWritable: false,
            pubkey: import_web311.PublicKey.unique()
          });
        }
        const ixs = [increasePositionLengthIx];
        if (includeSetCuIx) {
          ixs.unshift(setCuIx);
        }
        groupedIxs.push(ixs);
      });
      promises.push(ixPromise);
    }
    await Promise.all(promises);
    return groupedIxs;
  }
  /** Private static method */
  static async getBinArrays(program, lbPairPubkey) {
    return program.account.binArray.all([binArrayLbPairFilter(lbPairPubkey)]);
  }
  static async processPosition(program, lbPair, clock, position, baseMint, quoteMint, rewardMint0, rewardMint1, binArrayMap) {
    const lbPairKey = position.lbPair();
    const lowerBinId = position.lowerBinId();
    const upperBinId = position.upperBinId();
    const posShares = position.liquidityShares();
    const lastUpdatedAt = position.lastUpdatedAt();
    const feeInfos = position.feeInfos();
    const totalClaimedFeeXAmount = position.totalClaimedFeeXAmount();
    const totalClaimedFeeYAmount = position.totalClaimedFeeYAmount();
    const positionRewardInfos = position.rewardInfos();
    const feeOwner = position.feeOwner();
    const bins = this.getBinsBetweenLowerAndUpperBound(
      lbPairKey,
      lbPair,
      lowerBinId.toNumber(),
      upperBinId.toNumber(),
      baseMint.decimals,
      quoteMint.decimals,
      binArrayMap,
      program.programId
    );
    if (!bins.length)
      return null;
    const positionData = [];
    let totalXAmount = new decimal_default(0);
    let totalYAmount = new decimal_default(0);
    const ZERO = new import_anchor.BN(0);
    let feeX = ZERO;
    let feeY = ZERO;
    let rewards = [ZERO, ZERO];
    bins.forEach((bin, idx) => {
      const binSupply = bin.supply;
      const posShare = posShares[idx];
      const posBinRewardInfo = positionRewardInfos[idx];
      const positionXAmount = binSupply.eq(ZERO) ? ZERO : posShare.mul(bin.xAmount).div(binSupply);
      const positionYAmount = binSupply.eq(ZERO) ? ZERO : posShare.mul(bin.yAmount).div(binSupply);
      totalXAmount = totalXAmount.add(new decimal_default(positionXAmount.toString()));
      totalYAmount = totalYAmount.add(new decimal_default(positionYAmount.toString()));
      const feeInfo = feeInfos[idx];
      const newFeeX = posShare.isZero() ? new import_anchor.BN(0) : mulShr(
        posShares[idx].shrn(SCALE_OFFSET),
        bin.feeAmountXPerTokenStored.sub(feeInfo.feeXPerTokenComplete),
        SCALE_OFFSET,
        1
        /* Down */
      );
      const newFeeY = posShare.isZero() ? new import_anchor.BN(0) : mulShr(
        posShares[idx].shrn(SCALE_OFFSET),
        bin.feeAmountYPerTokenStored.sub(feeInfo.feeYPerTokenComplete),
        SCALE_OFFSET,
        1
        /* Down */
      );
      const claimableFeeX = newFeeX.add(feeInfo.feeXPending);
      const claimableFeeY = newFeeY.add(feeInfo.feeYPending);
      feeX = feeX.add(claimableFeeX);
      feeY = feeY.add(claimableFeeY);
      const claimableRewardsInBin = [new import_anchor.BN(0), new import_anchor.BN(0)];
      for (let j = 0; j < claimableRewardsInBin.length; j++) {
        const pairRewardInfo = lbPair.rewardInfos[j];
        if (!pairRewardInfo.mint.equals(import_web311.PublicKey.default)) {
          let rewardPerTokenStored = bin.rewardPerTokenStored[j];
          if (bin.binId == lbPair.activeId && !bin.supply.isZero()) {
            const currentTime = new import_anchor.BN(
              Math.min(
                clock.unixTimestamp.toNumber(),
                pairRewardInfo.rewardDurationEnd.toNumber()
              )
            );
            const delta2 = currentTime.sub(pairRewardInfo.lastUpdateTime);
            const liquiditySupply = bin.supply.shrn(SCALE_OFFSET);
            const rewardPerTokenStoredDelta = pairRewardInfo.rewardRate.mul(delta2).div(new import_anchor.BN(15)).div(liquiditySupply);
            rewardPerTokenStored = rewardPerTokenStored.add(
              rewardPerTokenStoredDelta
            );
          }
          const delta = rewardPerTokenStored.sub(
            posBinRewardInfo.rewardPerTokenCompletes[j]
          );
          const newReward = posShares[idx].isZero() ? new import_anchor.BN(0) : mulShr(
            delta,
            posShares[idx].shrn(SCALE_OFFSET),
            SCALE_OFFSET,
            1
            /* Down */
          );
          const claimableReward = newReward.add(
            posBinRewardInfo.rewardPendings[j]
          );
          claimableRewardsInBin[j] = claimableRewardsInBin[j].add(claimableReward);
          rewards[j] = rewards[j].add(claimableReward);
        }
      }
      positionData.push({
        binId: bin.binId,
        price: bin.price,
        pricePerToken: bin.pricePerToken,
        binXAmount: bin.xAmount.toString(),
        binYAmount: bin.yAmount.toString(),
        binLiquidity: binSupply.toString(),
        positionLiquidity: posShare.toString(),
        positionXAmount: positionXAmount.toString(),
        positionYAmount: positionYAmount.toString(),
        positionFeeXAmount: claimableFeeX.toString(),
        positionFeeYAmount: claimableFeeY.toString(),
        positionRewardAmount: claimableRewardsInBin.map(
          (amount) => amount.toString()
        )
      });
    });
    const currentEpoch = clock.epoch.toNumber();
    const feeXExcludeTransferFee = calculateTransferFeeExcludedAmount(
      feeX,
      baseMint,
      currentEpoch
    ).amount;
    const feeYExcludeTransferFee = calculateTransferFeeExcludedAmount(
      feeY,
      quoteMint,
      currentEpoch
    ).amount;
    const rewardOne = rewards[0];
    const rewardTwo = rewards[1];
    let rewardOneExcludeTransferFee = new import_anchor.BN(0);
    let rewardTwoExcludeTransferFee = new import_anchor.BN(0);
    if (rewardMint0) {
      rewardOneExcludeTransferFee = calculateTransferFeeExcludedAmount(
        rewardOne,
        rewardMint0,
        currentEpoch
      ).amount;
    }
    if (rewardMint1) {
      rewardTwoExcludeTransferFee = calculateTransferFeeExcludedAmount(
        rewardTwo,
        rewardMint1,
        currentEpoch
      ).amount;
    }
    const totalXAmountExcludeTransferFee = calculateTransferFeeExcludedAmount(
      new import_anchor.BN(totalXAmount.floor().toString()),
      baseMint,
      currentEpoch
    ).amount;
    const totalYAmountExcludeTransferFee = calculateTransferFeeExcludedAmount(
      new import_anchor.BN(totalYAmount.floor().toString()),
      quoteMint,
      currentEpoch
    ).amount;
    return {
      totalXAmount: totalXAmount.toString(),
      totalYAmount: totalYAmount.toString(),
      positionBinData: positionData,
      lastUpdatedAt,
      lowerBinId: lowerBinId.toNumber(),
      upperBinId: upperBinId.toNumber(),
      feeX,
      feeY,
      rewardOne,
      rewardTwo,
      feeOwner,
      totalClaimedFeeXAmount,
      totalClaimedFeeYAmount,
      totalXAmountExcludeTransferFee,
      totalYAmountExcludeTransferFee,
      rewardOneExcludeTransferFee,
      rewardTwoExcludeTransferFee,
      feeXExcludeTransferFee,
      feeYExcludeTransferFee,
      owner: position.owner()
    };
  }
  static getBinsBetweenLowerAndUpperBound(lbPairKey, lbPair, lowerBinId, upperBinId, baseTokenDecimal, quoteTokenDecimal, binArrayMap, programId) {
    const lowerBinArrayIndex = binIdToBinArrayIndex(new import_anchor.BN(lowerBinId));
    const upperBinArrayIndex = binIdToBinArrayIndex(new import_anchor.BN(upperBinId));
    let bins = [];
    const ZERO = new import_anchor.BN(0);
    for (let binArrayIndex = lowerBinArrayIndex.toNumber(); binArrayIndex <= upperBinArrayIndex.toNumber(); binArrayIndex++) {
      const binArrayIndexBN = new import_anchor.BN(binArrayIndex);
      const binArrayKey = deriveBinArray(
        lbPairKey,
        binArrayIndexBN,
        programId
      )[0];
      const [lowerBinIdForBinArray] = getBinArrayLowerUpperBinId(binArrayIndexBN);
      const binArray = binArrayMap.get(binArrayKey.toBase58());
      for (let i = 0; i < MAX_BIN_ARRAY_SIZE.toNumber(); i++) {
        const binId = lowerBinIdForBinArray.toNumber() + i;
        if (binId >= lowerBinId && binId <= upperBinId) {
          const pricePerLamport = getPriceOfBinByBinId(
            binId,
            lbPair.binStep
          ).toString();
          if (!binArray) {
            bins.push({
              binId,
              xAmount: ZERO,
              yAmount: ZERO,
              supply: ZERO,
              feeAmountXPerTokenStored: ZERO,
              feeAmountYPerTokenStored: ZERO,
              rewardPerTokenStored: [ZERO, ZERO],
              price: pricePerLamport,
              version: 2,
              pricePerToken: new decimal_default(pricePerLamport).mul(new decimal_default(10 ** (baseTokenDecimal - quoteTokenDecimal))).toString()
            });
          } else {
            const bin = binArray.bins[i];
            bins.push({
              binId,
              xAmount: bin.amountX,
              yAmount: bin.amountY,
              supply: bin.liquiditySupply,
              feeAmountXPerTokenStored: bin.feeAmountXPerTokenStored,
              feeAmountYPerTokenStored: bin.feeAmountYPerTokenStored,
              rewardPerTokenStored: bin.rewardPerTokenStored,
              price: pricePerLamport,
              version: binArray.version,
              pricePerToken: new decimal_default(pricePerLamport).mul(new decimal_default(10 ** (baseTokenDecimal - quoteTokenDecimal))).toString()
            });
          }
        }
      }
    }
    return bins;
  }
  /** Private method */
  processXYAmountDistribution(xYAmountDistribution) {
    let currentBinId = null;
    const xAmountDistribution = [];
    const yAmountDistribution = [];
    const binIds = [];
    xYAmountDistribution.forEach((binAndAmount) => {
      xAmountDistribution.push(binAndAmount.xAmountBpsOfTotal);
      yAmountDistribution.push(binAndAmount.yAmountBpsOfTotal);
      binIds.push(binAndAmount.binId);
      if (currentBinId && binAndAmount.binId !== currentBinId + 1) {
        throw new Error("Discontinuous Bin ID");
      } else {
        currentBinId = binAndAmount.binId;
      }
    });
    return {
      lowerBinId: xYAmountDistribution[0].binId,
      upperBinId: xYAmountDistribution[xYAmountDistribution.length - 1].binId,
      xAmountDistribution,
      yAmountDistribution,
      binIds
    };
  }
  async getBins(lbPairPubKey, lowerBinId, upperBinId, baseTokenDecimal, quoteTokenDecimal, lowerBinArray, upperBinArray) {
    const lowerBinArrayIndex = binIdToBinArrayIndex(new import_anchor.BN(lowerBinId));
    const upperBinArrayIndex = binIdToBinArrayIndex(new import_anchor.BN(upperBinId));
    const hasCachedLowerBinArray = lowerBinArray != null;
    const hasCachedUpperBinArray = upperBinArray != null;
    const isSingleBinArray = lowerBinArrayIndex.eq(upperBinArrayIndex);
    const lowerBinArrayIndexOffset = hasCachedLowerBinArray ? 1 : 0;
    const upperBinArrayIndexOffset = hasCachedUpperBinArray ? -1 : 0;
    const binArrayPubkeys = range(
      lowerBinArrayIndex.toNumber() + lowerBinArrayIndexOffset,
      upperBinArrayIndex.toNumber() + upperBinArrayIndexOffset,
      (i) => deriveBinArray(lbPairPubKey, new import_anchor.BN(i), this.program.programId)[0]
    );
    const fetchedBinArrays = binArrayPubkeys.length !== 0 ? await this.program.account.binArray.fetchMultiple(binArrayPubkeys) : [];
    const binArrays = [
      ...hasCachedLowerBinArray ? [lowerBinArray] : [],
      ...fetchedBinArrays,
      ...hasCachedUpperBinArray && !isSingleBinArray ? [upperBinArray] : []
    ];
    const binsById = new Map(
      binArrays.filter((x) => x != null).flatMap(({ bins, index }) => {
        const [lowerBinId2] = getBinArrayLowerUpperBinId(index);
        return bins.map(
          (b, i) => [lowerBinId2.toNumber() + i, b]
        );
      })
    );
    const version = binArrays.find((binArray) => binArray != null)?.version ?? 1;
    return Array.from(
      enumerateBins(
        binsById,
        lowerBinId,
        upperBinId,
        this.lbPair.binStep,
        baseTokenDecimal,
        quoteTokenDecimal,
        version
      )
    );
  }
  async binArraysToBeCreate(lowerBinArrayIndex, upperBinArrayIndex) {
    const binArrayIndexes = Array.from(
      { length: upperBinArrayIndex.sub(lowerBinArrayIndex).toNumber() + 1 },
      (_, index) => index + lowerBinArrayIndex.toNumber()
    ).map((idx) => new import_anchor.BN(idx));
    const binArrays = [];
    for (const idx of binArrayIndexes) {
      const [binArrayPubKey] = deriveBinArray(
        this.pubkey,
        idx,
        this.program.programId
      );
      binArrays.push(binArrayPubKey);
    }
    const binArrayAccounts = await this.program.provider.connection.getMultipleAccountsInfo(binArrays);
    return binArrayAccounts.filter((binArray) => binArray === null).map((_, index) => binArrays[index]);
  }
  async createBinArraysIfNeeded(binArrayIndexes, funder) {
    const ixs = [];
    for (const idx of binArrayIndexes) {
      const [binArrayKey] = deriveBinArray(
        this.pubkey,
        idx,
        this.program.programId
      );
      const binArrayAccount = await this.program.provider.connection.getAccountInfo(binArrayKey);
      if (binArrayAccount === null) {
        ixs.push(
          await this.program.methods.initializeBinArray(idx).accountsPartial({
            binArray: binArrayKey,
            funder,
            lbPair: this.pubkey
          }).instruction()
        );
      }
    }
    return ixs;
  }
  static updateVolatilityAccumulator(vParameter, sParameter, activeId) {
    const deltaId = Math.abs(vParameter.indexReference - activeId);
    const newVolatilityAccumulator = vParameter.volatilityReference + deltaId * BASIS_POINT_MAX;
    vParameter.volatilityAccumulator = Math.min(
      newVolatilityAccumulator,
      sParameter.maxVolatilityAccumulator
    );
  }
  static updateReference(activeId, vParameter, sParameter, currentTimestamp) {
    const elapsed = currentTimestamp - vParameter.lastUpdateTimestamp.toNumber();
    if (elapsed >= sParameter.filterPeriod) {
      vParameter.indexReference = activeId;
      if (elapsed < sParameter.decayPeriod) {
        const decayedVolatilityReference = Math.floor(
          vParameter.volatilityAccumulator * sParameter.reductionFactor / BASIS_POINT_MAX
        );
        vParameter.volatilityReference = decayedVolatilityReference;
      } else {
        vParameter.volatilityReference = 0;
      }
    }
  }
  async createClaimBuildMethod({
    owner,
    position
  }) {
    const maybeClaimableBinRange = getPositionLowerUpperBinIdWithLiquidity(
      position.positionData
    );
    if (!maybeClaimableBinRange)
      return [];
    const { lowerBinId, upperBinId } = maybeClaimableBinRange;
    const chunkedBinRange = chunkBinRange(
      lowerBinId.toNumber(),
      upperBinId.toNumber()
    );
    const claimTransactions = [];
    for (const {
      lowerBinId: chunkedLowerBinId,
      upperBinId: chunkedUpperBinId
    } of chunkedBinRange) {
      const binArrayAccountsMeta = getBinArrayAccountMetasCoverage(
        new import_anchor.BN(chunkedLowerBinId),
        new import_anchor.BN(chunkedUpperBinId),
        this.pubkey,
        this.program.programId
      );
      for (let i = 0; i < 2; i++) {
        const rewardInfo = this.lbPair.rewardInfos[i];
        if (!rewardInfo || rewardInfo.mint.equals(import_web311.PublicKey.default))
          continue;
        const preInstructions = [];
        const userRewardToken = getAssociatedTokenAddressSync(
          rewardInfo.mint,
          owner,
          true,
          this.rewards[i].owner
        );
        const createUserTokenIx = createAssociatedTokenAccountIdempotentInstruction(
          owner,
          userRewardToken,
          owner,
          rewardInfo.mint,
          this.rewards[i].owner
        );
        preInstructions.push(createUserTokenIx);
        const { slices, accounts: transferHookAccounts } = this.getPotentialToken2022IxDataAndAccounts(1, i);
        const claimTransaction = await this.program.methods.claimReward2(new import_anchor.BN(i), chunkedLowerBinId, chunkedUpperBinId, {
          slices
        }).accountsPartial({
          lbPair: this.pubkey,
          sender: owner,
          position: position.publicKey,
          rewardVault: rewardInfo.vault,
          rewardMint: rewardInfo.mint,
          tokenProgram: this.rewards[i].owner,
          userTokenAccount: userRewardToken,
          memoProgram: MEMO_PROGRAM_ID
        }).remainingAccounts(transferHookAccounts).remainingAccounts(binArrayAccountsMeta).preInstructions(preInstructions).transaction();
        claimTransactions.push(claimTransaction);
      }
    }
    return claimTransactions;
  }
  async createClaimSwapFeeMethod({
    owner,
    position
  }) {
    const maybeClaimableBinRange = getPositionLowerUpperBinIdWithLiquidity(
      position.positionData
    );
    if (!maybeClaimableBinRange)
      return [];
    const { lowerBinId, upperBinId } = maybeClaimableBinRange;
    const chunkedBinRange = chunkBinRange(
      lowerBinId.toNumber(),
      upperBinId.toNumber()
    );
    const claimFeeTxs = [];
    for (const {
      lowerBinId: chunkedLowerBinId,
      upperBinId: chunkedUpperBinId
    } of chunkedBinRange) {
      const binArrayAccountsMeta = getBinArrayAccountMetasCoverage(
        new import_anchor.BN(chunkedLowerBinId),
        new import_anchor.BN(chunkedUpperBinId),
        this.pubkey,
        this.program.programId
      );
      const { feeOwner } = position.positionData;
      const walletToReceiveFee = feeOwner.equals(import_web311.PublicKey.default) ? owner : feeOwner;
      const preInstructions = [];
      const userTokenX = getAssociatedTokenAddressSync(
        this.lbPair.tokenXMint,
        walletToReceiveFee,
        true,
        this.tokenX.owner
      );
      const userTokenY = getAssociatedTokenAddressSync(
        this.lbPair.tokenYMint,
        walletToReceiveFee,
        true,
        this.tokenY.owner
      );
      const createUserTokenXIx = createAssociatedTokenAccountIdempotentInstruction(
        owner,
        userTokenX,
        walletToReceiveFee,
        this.lbPair.tokenXMint,
        this.tokenX.owner
      );
      const createUserTokenYIx = createAssociatedTokenAccountIdempotentInstruction(
        owner,
        userTokenY,
        walletToReceiveFee,
        this.lbPair.tokenYMint,
        this.tokenY.owner
      );
      preInstructions.push(createUserTokenXIx);
      preInstructions.push(createUserTokenYIx);
      const postInstructions = [];
      if ([
        this.tokenX.publicKey.toBase58(),
        this.tokenY.publicKey.toBase58()
      ].includes(NATIVE_MINT.toBase58()) && !this.opt?.skipSolWrappingOperation) {
        const closeWrappedSOLIx = await unwrapSOLInstruction(owner);
        closeWrappedSOLIx && postInstructions.push(closeWrappedSOLIx);
      }
      const { slices, accounts: transferHookAccounts } = this.getPotentialToken2022IxDataAndAccounts(
        0
        /* Liquidity */
      );
      const claimFeeTx = await this.program.methods.claimFee2(chunkedLowerBinId, chunkedUpperBinId, {
        slices
      }).accountsPartial({
        lbPair: this.pubkey,
        sender: owner,
        position: position.publicKey,
        reserveX: this.lbPair.reserveX,
        reserveY: this.lbPair.reserveY,
        tokenProgramX: this.tokenX.owner,
        tokenProgramY: this.tokenY.owner,
        tokenXMint: this.tokenX.publicKey,
        tokenYMint: this.tokenY.publicKey,
        userTokenX,
        userTokenY,
        memoProgram: MEMO_PROGRAM_ID
      }).remainingAccounts(transferHookAccounts).remainingAccounts(binArrayAccountsMeta).preInstructions(preInstructions).postInstructions(postInstructions).transaction();
      claimFeeTxs.push(claimFeeTx);
    }
    return claimFeeTxs;
  }
  getPotentialToken2022IxDataAndAccounts(actionType, rewardIndex) {
    if (actionType == 0) {
      return {
        slices: [
          {
            accountsType: {
              transferHookX: {}
            },
            length: this.tokenX.transferHookAccountMetas.length
          },
          {
            accountsType: {
              transferHookY: {}
            },
            length: this.tokenY.transferHookAccountMetas.length
          }
        ],
        accounts: this.tokenX.transferHookAccountMetas.concat(
          this.tokenY.transferHookAccountMetas
        )
      };
    }
    return {
      slices: [
        {
          accountsType: {
            transferHookReward: {}
          },
          length: this.rewards[rewardIndex].transferHookAccountMetas.length
        }
      ],
      accounts: this.rewards[rewardIndex].transferHookAccountMetas
    };
  }
};
var src_default = DLMM;

// execution_engine.ts
var import_whirlpools_sdk = __toESM(require_dist3());
var import_anchor12 = require("@coral-xyz/anchor");
var import_common_sdk = __toESM(require_dist2());
var import_bs58 = __toESM(require_bs58());
var import_bn12 = __toESM(require_bn());
var RPC_URL = process.env.SOLANA_RPC_URL || "https://api.mainnet-beta.solana.com";
var DEFAULT_COMPUTE_UNITS = 4e5;
var DEFAULT_PRIORITY_FEE = 5e4;
var DEFAULT_SLIPPAGE_BPS = 100;
var HELIUS_API_KEY = process.env.HELIUS_API_KEY || "";
var HELIUS_SENDER_URL = HELIUS_API_KEY ? `https://mainnet.helius-rpc.com/?api-key=${HELIUS_API_KEY}` : "";
var JITO_TIP_ACCOUNTS = [
  "96gYZGLnJYVFmbjzopPSU6QiEV5fGqZNyN9nmNhvrZU5",
  "HFqU5x63VTqvQss8hp11i4wVV8bD44PvwucfZ2bU7gRE",
  "Cw8CFyM9FkoMi7K7Crf6HNQqf4uEMzpKw6QNghXLvLkY",
  "ADaUMid9yfUytqMBgTQ37Kq7PevX2dKS2nxMxSQrcFpM",
  "DfXygSm4jCyNCybVYYK6DwvWqjKee8pbDmJGcLWNDXjh",
  "ADuUkR4vqLUMWXxW9gh6D6L8pMSawimctcNZ5pGwDcEt",
  "DttWaMuVvTiduZRnguLF7jNxTgiMBZ1hyAumKUiL2KRL",
  "3AVi9Tg9Uo68tJfuvoKvqKNWKkC5wPdSSdeBnizKZ6jT"
];
var ExecutionEngine = class {
  connection;
  wallet;
  constructor() {
    this.connection = new import_web321.Connection(RPC_URL, "confirmed");
  }
  /**
   * Initialize wallet from private key
   */
  setWallet(privateKey) {
    try {
      const secretKey = import_bs58.default.decode(privateKey);
      this.wallet = import_web321.Keypair.fromSecretKey(secretKey);
    } catch (e) {
      throw new Error("Invalid private key format");
    }
  }
  /**
   * Build Compute Budget instructions for priority fees
   */
  buildComputeBudgetIxs(computeUnits, priorityFee) {
    return [
      import_web321.ComputeBudgetProgram.setComputeUnitLimit({ units: computeUnits }),
      import_web321.ComputeBudgetProgram.setComputeUnitPrice({ microLamports: priorityFee })
    ];
  }
  /**
   * Build Jito tip instruction
   * Tips a random Jito validator to include our bundle privately
   */
  buildJitoTipIx(lamports) {
    const randomTipAccount = new import_web321.PublicKey(
      JITO_TIP_ACCOUNTS[Math.floor(Math.random() * JITO_TIP_ACCOUNTS.length)]
    );
    return import_web321.SystemProgram.transfer({
      fromPubkey: this.wallet.publicKey,
      toPubkey: randomTipAccount,
      lamports
    });
  }
  /**
   * Send transaction via Helius Sender endpoint
   * Free 15 TPS, auto-routes to fastest validator
   */
  async sendViaHelius(tx) {
    if (!HELIUS_SENDER_URL) {
      throw new Error("HELIUS_API_KEY not configured");
    }
    const serialized = tx.serialize();
    const base64 = serialized.toString("base64");
    const response = await fetch(HELIUS_SENDER_URL, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        jsonrpc: "2.0",
        id: 1,
        method: "sendTransaction",
        params: [
          base64,
          {
            encoding: "base64",
            skipPreflight: false,
            preflightCommitment: "confirmed",
            maxRetries: 3
          }
        ]
      })
    });
    const result = await response.json();
    if (result.error) {
      throw new Error(`Helius send failed: ${JSON.stringify(result.error)}`);
    }
    return result.result;
  }
  /**
   * Wait for transaction confirmation
   */
  async confirmTransaction(signature, timeout = 3e4) {
    const startTime = Date.now();
    while (Date.now() - startTime < timeout) {
      try {
        const status = await this.connection.getSignatureStatus(signature);
        if (status.value?.confirmationStatus === "confirmed" || status.value?.confirmationStatus === "finalized") {
          return true;
        }
        if (status.value?.err) {
          return false;
        }
      } catch (e) {
      }
      await new Promise((resolve) => setTimeout(resolve, 500));
    }
    return false;
  }
  /**
   * Build Meteora DLMM swap instruction
   */
  async buildMeteoraSwap(leg) {
    const poolAddr = new import_web321.PublicKey(leg.pool);
    const dlmmPool = await src_default.create(this.connection, poolAddr);
    const inputMint = new import_web321.PublicKey(leg.inputMint);
    const isXtoY = inputMint.equals(dlmmPool.tokenX.publicKey);
    const binArrays = await dlmmPool.getBinArrayForSwap(isXtoY);
    const swapQuote = await dlmmPool.swapQuote(
      new import_bn12.default(leg.amount),
      isXtoY,
      new import_bn12.default(leg.slippageBps || DEFAULT_SLIPPAGE_BPS),
      binArrays
    );
    const swapTx = await dlmmPool.swap({
      inToken: inputMint,
      outToken: new import_web321.PublicKey(leg.outputMint),
      inAmount: new import_bn12.default(leg.amount),
      minOutAmount: swapQuote.minOutAmount,
      lbPair: dlmmPool.pubkey,
      user: this.wallet.publicKey,
      binArraysPubkey: swapQuote.binArraysPubkey
    });
    return {
      instructions: swapTx.instructions || [swapTx],
      quote: {
        inputAmount: leg.amount,
        outputAmount: swapQuote.outAmount.toNumber(),
        minOutputAmount: swapQuote.minOutAmount.toNumber(),
        priceImpact: swapQuote.priceImpact?.toNumber() || 0
      }
    };
  }
  /**
   * Build Orca Whirlpool swap instruction
   * Uses concentrated liquidity pools for efficient swaps
   */
  async buildOrcaSwap(leg) {
    const poolAddr = new import_web321.PublicKey(leg.pool);
    const inputMint = new import_web321.PublicKey(leg.inputMint);
    const anchorWallet = new import_anchor12.Wallet(this.wallet);
    const provider = new import_anchor12.AnchorProvider(
      this.connection,
      anchorWallet,
      { commitment: "confirmed" }
    );
    const ctx = import_whirlpools_sdk.WhirlpoolContext.from(
      this.connection,
      anchorWallet,
      import_whirlpools_sdk.ORCA_WHIRLPOOL_PROGRAM_ID
    );
    const client = (0, import_whirlpools_sdk.buildWhirlpoolClient)(ctx);
    const whirlpool = await client.getPool(poolAddr);
    const whirlpoolData = whirlpool.getData();
    const aToB = inputMint.equals(whirlpoolData.tokenMintA);
    const slippage = import_common_sdk.Percentage.fromFraction(
      leg.slippageBps || DEFAULT_SLIPPAGE_BPS,
      1e4
    );
    const quote = await (0, import_whirlpools_sdk.swapQuoteByInputToken)(
      whirlpool,
      inputMint,
      new import_bn12.default(leg.amount),
      slippage,
      import_whirlpools_sdk.ORCA_WHIRLPOOL_PROGRAM_ID,
      await client.getFetcher(),
      { maxAge: 0 }
      // Force refresh of account data
    );
    const swapTx = await whirlpool.swap(quote);
    return {
      instructions: swapTx.compressIx ? [swapTx.compressIx] : [],
      quote: {
        inputAmount: leg.amount,
        outputAmount: quote.estimatedAmountOut.toNumber(),
        minOutputAmount: quote.otherAmountThreshold.toNumber(),
        priceImpact: 0
        // Orca doesn't provide this directly
      }
    };
  }
  /**
   * Execute atomic multi-leg swap
   * @param simulateOnly If true, simulate but don't send (seatbelt mode)
   * @param jitoTipLamports Tip amount for Jito bundles (0 = no tip)
   */
  async executeSwap(legs, privateKey, priorityFee, simulateOnly = false, jitoTipLamports = 0) {
    const timestamp = Date.now();
    try {
      this.setWallet(privateKey);
      if (legs.length === 0) {
        return { success: false, command: "swap", error: "No swap legs provided", timestamp };
      }
      const allInstructions = [];
      const legResults = [];
      const computeBudgetIxs = this.buildComputeBudgetIxs(
        DEFAULT_COMPUTE_UNITS * legs.length,
        priorityFee || DEFAULT_PRIORITY_FEE
      );
      allInstructions.push(...computeBudgetIxs);
      for (const leg of legs) {
        let swapResult;
        switch (leg.dex) {
          case "meteora":
            swapResult = await this.buildMeteoraSwap(leg);
            break;
          case "orca":
            swapResult = await this.buildOrcaSwap(leg);
            break;
          case "jupiter":
            throw new Error("Jupiter integration uses REST API - not batched here");
          default:
            throw new Error(`Unknown DEX: ${leg.dex}`);
        }
        if (Array.isArray(swapResult.instructions)) {
          allInstructions.push(...swapResult.instructions);
        } else {
          allInstructions.push(swapResult.instructions);
        }
        legResults.push({
          dex: leg.dex,
          inputMint: leg.inputMint,
          outputMint: leg.outputMint,
          inputAmount: swapResult.quote.inputAmount,
          outputAmount: swapResult.quote.outputAmount,
          priceImpact: swapResult.quote.priceImpact
        });
      }
      const { blockhash, lastValidBlockHeight } = await this.connection.getLatestBlockhash();
      const tx = new import_web321.Transaction();
      tx.recentBlockhash = blockhash;
      tx.lastValidBlockHeight = lastValidBlockHeight;
      tx.feePayer = this.wallet.publicKey;
      for (const ix of allInstructions) {
        if (ix.keys && ix.programId) {
          tx.add(ix);
        }
      }
      if (jitoTipLamports > 0) {
        const tipIx = this.buildJitoTipIx(jitoTipLamports);
        tx.add(tipIx);
      }
      tx.sign(this.wallet);
      const simulation = await this.connection.simulateTransaction(tx);
      if (simulation.value.err) {
        const simError = JSON.stringify(simulation.value.err);
        return {
          success: false,
          command: simulateOnly ? "simulate" : "swap",
          legs: legResults,
          simulationSuccess: false,
          simulationError: `Simulation failed: ${simError}`,
          computeUnitsUsed: simulation.value.unitsConsumed,
          error: `Transaction would fail: ${simError}`,
          timestamp
        };
      }
      if (simulateOnly) {
        return {
          success: true,
          command: "simulate",
          legs: legResults,
          simulationSuccess: true,
          computeUnitsUsed: simulation.value.unitsConsumed,
          timestamp
        };
      }
      let signature;
      if (HELIUS_SENDER_URL) {
        signature = await this.sendViaHelius(tx);
        const confirmed = await this.confirmTransaction(signature);
        if (!confirmed) {
          return {
            success: false,
            command: "swap",
            signature,
            legs: legResults,
            error: "Transaction not confirmed within timeout",
            timestamp
          };
        }
      } else {
        signature = await (0, import_web321.sendAndConfirmTransaction)(
          this.connection,
          tx,
          [this.wallet],
          { commitment: "confirmed", maxRetries: 3 }
        );
      }
      return {
        success: true,
        command: "swap",
        signature,
        legs: legResults,
        simulationSuccess: true,
        computeUnitsUsed: simulation.value.unitsConsumed,
        timestamp
      };
    } catch (e) {
      return {
        success: false,
        command: "swap",
        error: e.message || String(e),
        timestamp
      };
    }
  }
  /**
   * Get quotes without executing
   */
  async getQuotes(legs) {
    const timestamp = Date.now();
    try {
      this.wallet = import_web321.Keypair.generate();
      const legResults = [];
      for (const leg of legs) {
        if (leg.dex === "meteora") {
          const poolAddr = new import_web321.PublicKey(leg.pool);
          const dlmmPool = await src_default.create(this.connection, poolAddr);
          const inputMint = new import_web321.PublicKey(leg.inputMint);
          const isXtoY = inputMint.equals(dlmmPool.tokenX.publicKey);
          const binArrays = await dlmmPool.getBinArrayForSwap(isXtoY);
          const swapQuote = await dlmmPool.swapQuote(
            new import_bn12.default(leg.amount),
            isXtoY,
            new import_bn12.default(leg.slippageBps || DEFAULT_SLIPPAGE_BPS),
            binArrays
          );
          legResults.push({
            dex: leg.dex,
            inputMint: leg.inputMint,
            outputMint: leg.outputMint,
            inputAmount: leg.amount,
            outputAmount: swapQuote.outAmount.toNumber(),
            priceImpact: swapQuote.priceImpact?.toNumber() || 0
          });
        } else {
          legResults.push({
            dex: leg.dex,
            inputMint: leg.inputMint,
            outputMint: leg.outputMint,
            inputAmount: leg.amount,
            outputAmount: 0,
            priceImpact: 0
          });
        }
      }
      return {
        success: true,
        command: "quote",
        legs: legResults,
        timestamp
      };
    } catch (e) {
      return {
        success: false,
        command: "quote",
        error: e.message || String(e),
        timestamp
      };
    }
  }
  /**
   * Health check
   */
  async healthCheck() {
    const timestamp = Date.now();
    try {
      const slot = await this.connection.getSlot();
      return {
        success: true,
        command: "health",
        timestamp
      };
    } catch (e) {
      return {
        success: false,
        command: "health",
        error: e.message || String(e),
        timestamp
      };
    }
  }
};
async function main() {
  const engine = new ExecutionEngine();
  const input = process.argv[2];
  if (!input) {
    console.log(JSON.stringify({
      success: false,
      error: "No command provided",
      usage: `node execution_engine.js '{"command":"health"}'`,
      timestamp: Date.now()
    }));
    process.exit(1);
  }
  let cmd;
  try {
    cmd = JSON.parse(input);
  } catch (e) {
    console.log(JSON.stringify({
      success: false,
      error: "Invalid JSON input",
      timestamp: Date.now()
    }));
    process.exit(1);
  }
  let result;
  switch (cmd.command) {
    case "health":
      result = await engine.healthCheck();
      break;
    case "quote":
      if (!cmd.legs || cmd.legs.length === 0) {
        result = { success: false, command: "quote", error: "No legs provided", timestamp: Date.now() };
      } else {
        result = await engine.getQuotes(cmd.legs);
      }
      break;
    case "simulate":
      if (!cmd.privateKey) {
        result = { success: false, command: "simulate", error: "No private key provided", timestamp: Date.now() };
      } else if (!cmd.legs || cmd.legs.length === 0) {
        result = { success: false, command: "simulate", error: "No legs provided", timestamp: Date.now() };
      } else {
        result = await engine.executeSwap(
          cmd.legs,
          cmd.privateKey,
          cmd.priorityFee,
          true,
          cmd.jitoTipLamports || 0
        );
      }
      break;
    case "swap":
      if (!cmd.privateKey) {
        result = { success: false, command: "swap", error: "No private key provided", timestamp: Date.now() };
      } else if (!cmd.legs || cmd.legs.length === 0) {
        result = { success: false, command: "swap", error: "No legs provided", timestamp: Date.now() };
      } else {
        result = await engine.executeSwap(
          cmd.legs,
          cmd.privateKey,
          cmd.priorityFee,
          cmd.simulateOnly || false,
          cmd.jitoTipLamports || 0
        );
      }
      break;
    default:
      result = { success: false, command: "unknown", error: `Unknown command: ${cmd.command}`, timestamp: Date.now() };
  }
  console.log(JSON.stringify(result));
}
main().catch((e) => {
  console.log(JSON.stringify({
    success: false,
    error: e.message || String(e),
    timestamp: Date.now()
  }));
  process.exit(1);
});
/*! Bundled license information:

@solana/buffer-layout/lib/Layout.js:
  (**
   * Support for translating between Uint8Array instances and JavaScript
   * native types.
   *
   * {@link module:Layout~Layout|Layout} is the basis of a class
   * hierarchy that associates property names with sequences of encoded
   * bytes.
   *
   * Layouts are supported for these scalar (numeric) types:
   * * {@link module:Layout~UInt|Unsigned integers in little-endian
   *   format} with {@link module:Layout.u8|8-bit}, {@link
   *   module:Layout.u16|16-bit}, {@link module:Layout.u24|24-bit},
   *   {@link module:Layout.u32|32-bit}, {@link
   *   module:Layout.u40|40-bit}, and {@link module:Layout.u48|48-bit}
   *   representation ranges;
   * * {@link module:Layout~UIntBE|Unsigned integers in big-endian
   *   format} with {@link module:Layout.u16be|16-bit}, {@link
   *   module:Layout.u24be|24-bit}, {@link module:Layout.u32be|32-bit},
   *   {@link module:Layout.u40be|40-bit}, and {@link
   *   module:Layout.u48be|48-bit} representation ranges;
   * * {@link module:Layout~Int|Signed integers in little-endian
   *   format} with {@link module:Layout.s8|8-bit}, {@link
   *   module:Layout.s16|16-bit}, {@link module:Layout.s24|24-bit},
   *   {@link module:Layout.s32|32-bit}, {@link
   *   module:Layout.s40|40-bit}, and {@link module:Layout.s48|48-bit}
   *   representation ranges;
   * * {@link module:Layout~IntBE|Signed integers in big-endian format}
   *   with {@link module:Layout.s16be|16-bit}, {@link
   *   module:Layout.s24be|24-bit}, {@link module:Layout.s32be|32-bit},
   *   {@link module:Layout.s40be|40-bit}, and {@link
   *   module:Layout.s48be|48-bit} representation ranges;
   * * 64-bit integral values that decode to an exact (if magnitude is
   *   less than 2^53) or nearby integral Number in {@link
   *   module:Layout.nu64|unsigned little-endian}, {@link
   *   module:Layout.nu64be|unsigned big-endian}, {@link
   *   module:Layout.ns64|signed little-endian}, and {@link
   *   module:Layout.ns64be|unsigned big-endian} encodings;
   * * 32-bit floating point values with {@link
   *   module:Layout.f32|little-endian} and {@link
   *   module:Layout.f32be|big-endian} representations;
   * * 64-bit floating point values with {@link
   *   module:Layout.f64|little-endian} and {@link
   *   module:Layout.f64be|big-endian} representations;
   * * {@link module:Layout.const|Constants} that take no space in the
   *   encoded expression.
   *
   * and for these aggregate types:
   * * {@link module:Layout.seq|Sequence}s of instances of a {@link
   *   module:Layout~Layout|Layout}, with JavaScript representation as
   *   an Array and constant or data-dependent {@link
   *   module:Layout~Sequence#count|length};
   * * {@link module:Layout.struct|Structure}s that aggregate a
   *   heterogeneous sequence of {@link module:Layout~Layout|Layout}
   *   instances, with JavaScript representation as an Object;
   * * {@link module:Layout.union|Union}s that support multiple {@link
   *   module:Layout~VariantLayout|variant layouts} over a fixed
   *   (padded) or variable (not padded) span of bytes, using an
   *   unsigned integer at the start of the data or a separate {@link
   *   module:Layout.unionLayoutDiscriminator|layout element} to
   *   determine which layout to use when interpreting the buffer
   *   contents;
   * * {@link module:Layout.bits|BitStructure}s that contain a sequence
   *   of individual {@link
   *   module:Layout~BitStructure#addField|BitField}s packed into an 8,
   *   16, 24, or 32-bit unsigned integer starting at the least- or
   *   most-significant bit;
   * * {@link module:Layout.cstr|C strings} of varying length;
   * * {@link module:Layout.blob|Blobs} of fixed- or variable-{@link
   *   module:Layout~Blob#length|length} raw data.
   *
   * All {@link module:Layout~Layout|Layout} instances are immutable
   * after construction, to prevent internal state from becoming
   * inconsistent.
   *
   * @local Layout
   * @local ExternalLayout
   * @local GreedyCount
   * @local OffsetLayout
   * @local UInt
   * @local UIntBE
   * @local Int
   * @local IntBE
   * @local NearUInt64
   * @local NearUInt64BE
   * @local NearInt64
   * @local NearInt64BE
   * @local Float
   * @local FloatBE
   * @local Double
   * @local DoubleBE
   * @local Sequence
   * @local Structure
   * @local UnionDiscriminator
   * @local UnionLayoutDiscriminator
   * @local Union
   * @local VariantLayout
   * @local BitStructure
   * @local BitField
   * @local Boolean
   * @local Blob
   * @local CString
   * @local Constant
   * @local bindConstructorLayout
   * @module Layout
   * @license MIT
   * @author Peter A. Bigot
   * @see {@link https://github.com/pabigot/buffer-layout|buffer-layout on GitHub}
   *)

buffer-layout/lib/Layout.js:
  (**
   * Support for translating between Buffer instances and JavaScript
   * native types.
   *
   * {@link module:Layout~Layout|Layout} is the basis of a class
   * hierarchy that associates property names with sequences of encoded
   * bytes.
   *
   * Layouts are supported for these scalar (numeric) types:
   * * {@link module:Layout~UInt|Unsigned integers in little-endian
   *   format} with {@link module:Layout.u8|8-bit}, {@link
   *   module:Layout.u16|16-bit}, {@link module:Layout.u24|24-bit},
   *   {@link module:Layout.u32|32-bit}, {@link
   *   module:Layout.u40|40-bit}, and {@link module:Layout.u48|48-bit}
   *   representation ranges;
   * * {@link module:Layout~UIntBE|Unsigned integers in big-endian
   *   format} with {@link module:Layout.u16be|16-bit}, {@link
   *   module:Layout.u24be|24-bit}, {@link module:Layout.u32be|32-bit},
   *   {@link module:Layout.u40be|40-bit}, and {@link
   *   module:Layout.u48be|48-bit} representation ranges;
   * * {@link module:Layout~Int|Signed integers in little-endian
   *   format} with {@link module:Layout.s8|8-bit}, {@link
   *   module:Layout.s16|16-bit}, {@link module:Layout.s24|24-bit},
   *   {@link module:Layout.s32|32-bit}, {@link
   *   module:Layout.s40|40-bit}, and {@link module:Layout.s48|48-bit}
   *   representation ranges;
   * * {@link module:Layout~IntBE|Signed integers in big-endian format}
   *   with {@link module:Layout.s16be|16-bit}, {@link
   *   module:Layout.s24be|24-bit}, {@link module:Layout.s32be|32-bit},
   *   {@link module:Layout.s40be|40-bit}, and {@link
   *   module:Layout.s48be|48-bit} representation ranges;
   * * 64-bit integral values that decode to an exact (if magnitude is
   *   less than 2^53) or nearby integral Number in {@link
   *   module:Layout.nu64|unsigned little-endian}, {@link
   *   module:Layout.nu64be|unsigned big-endian}, {@link
   *   module:Layout.ns64|signed little-endian}, and {@link
   *   module:Layout.ns64be|unsigned big-endian} encodings;
   * * 32-bit floating point values with {@link
   *   module:Layout.f32|little-endian} and {@link
   *   module:Layout.f32be|big-endian} representations;
   * * 64-bit floating point values with {@link
   *   module:Layout.f64|little-endian} and {@link
   *   module:Layout.f64be|big-endian} representations;
   * * {@link module:Layout.const|Constants} that take no space in the
   *   encoded expression.
   *
   * and for these aggregate types:
   * * {@link module:Layout.seq|Sequence}s of instances of a {@link
   *   module:Layout~Layout|Layout}, with JavaScript representation as
   *   an Array and constant or data-dependent {@link
   *   module:Layout~Sequence#count|length};
   * * {@link module:Layout.struct|Structure}s that aggregate a
   *   heterogeneous sequence of {@link module:Layout~Layout|Layout}
   *   instances, with JavaScript representation as an Object;
   * * {@link module:Layout.union|Union}s that support multiple {@link
   *   module:Layout~VariantLayout|variant layouts} over a fixed
   *   (padded) or variable (not padded) span of bytes, using an
   *   unsigned integer at the start of the data or a separate {@link
   *   module:Layout.unionLayoutDiscriminator|layout element} to
   *   determine which layout to use when interpreting the buffer
   *   contents;
   * * {@link module:Layout.bits|BitStructure}s that contain a sequence
   *   of individual {@link
   *   module:Layout~BitStructure#addField|BitField}s packed into an 8,
   *   16, 24, or 32-bit unsigned integer starting at the least- or
   *   most-significant bit;
   * * {@link module:Layout.cstr|C strings} of varying length;
   * * {@link module:Layout.blob|Blobs} of fixed- or variable-{@link
   *   module:Layout~Blob#length|length} raw data.
   *
   * All {@link module:Layout~Layout|Layout} instances are immutable
   * after construction, to prevent internal state from becoming
   * inconsistent.
   *
   * @local Layout
   * @local ExternalLayout
   * @local GreedyCount
   * @local OffsetLayout
   * @local UInt
   * @local UIntBE
   * @local Int
   * @local IntBE
   * @local NearUInt64
   * @local NearUInt64BE
   * @local NearInt64
   * @local NearInt64BE
   * @local Float
   * @local FloatBE
   * @local Double
   * @local DoubleBE
   * @local Sequence
   * @local Structure
   * @local UnionDiscriminator
   * @local UnionLayoutDiscriminator
   * @local Union
   * @local VariantLayout
   * @local BitStructure
   * @local BitField
   * @local Boolean
   * @local Blob
   * @local CString
   * @local Constant
   * @local bindConstructorLayout
   * @module Layout
   * @license MIT
   * @author Peter A. Bigot
   * @see {@link https://github.com/pabigot/buffer-layout|buffer-layout on GitHub}
   *)

decimal.js/decimal.js:
  (*!
   *  decimal.js v10.6.0
   *  An arbitrary-precision Decimal type for JavaScript.
   *  https://github.com/MikeMcl/decimal.js
   *  Copyright (c) 2025 Michael Mclaughlin <M8ch88l@gmail.com>
   *  MIT Licence
   *)

@noble/hashes/utils.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

decimal.js/decimal.mjs:
  (*!
   *  decimal.js v10.6.0
   *  An arbitrary-precision Decimal type for JavaScript.
   *  https://github.com/MikeMcl/decimal.js
   *  Copyright (c) 2025 Michael Mclaughlin <M8ch88l@gmail.com>
   *  MIT Licence
   *)
*/
