var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod2) => function __require() {
  return mod2 || (0, cb[__getOwnPropNames(cb)[0]])((mod2 = { exports: {} }).exports, mod2), mod2.exports;
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod2, isNodeMode, target) => (target = mod2 != null ? __create(__getProtoOf(mod2)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod2 || !mod2.__esModule ? __defProp(target, "default", { value: mod2, enumerable: true }) : target,
  mod2
));

// node_modules/delayed-stream/lib/delayed_stream.js
var require_delayed_stream = __commonJS({
  "node_modules/delayed-stream/lib/delayed_stream.js"(exports2, module2) {
    var Stream = require("stream").Stream;
    var util = require("util");
    module2.exports = DelayedStream;
    function DelayedStream() {
      this.source = null;
      this.dataSize = 0;
      this.maxDataSize = 1024 * 1024;
      this.pauseStream = true;
      this._maxDataSizeExceeded = false;
      this._released = false;
      this._bufferedEvents = [];
    }
    util.inherits(DelayedStream, Stream);
    DelayedStream.create = function(source, options) {
      var delayedStream = new this();
      options = options || {};
      for (var option2 in options) {
        delayedStream[option2] = options[option2];
      }
      delayedStream.source = source;
      var realEmit = source.emit;
      source.emit = function() {
        delayedStream._handleEmit(arguments);
        return realEmit.apply(source, arguments);
      };
      source.on("error", function() {
      });
      if (delayedStream.pauseStream) {
        source.pause();
      }
      return delayedStream;
    };
    Object.defineProperty(DelayedStream.prototype, "readable", {
      configurable: true,
      enumerable: true,
      get: function() {
        return this.source.readable;
      }
    });
    DelayedStream.prototype.setEncoding = function() {
      return this.source.setEncoding.apply(this.source, arguments);
    };
    DelayedStream.prototype.resume = function() {
      if (!this._released) {
        this.release();
      }
      this.source.resume();
    };
    DelayedStream.prototype.pause = function() {
      this.source.pause();
    };
    DelayedStream.prototype.release = function() {
      this._released = true;
      this._bufferedEvents.forEach(function(args) {
        this.emit.apply(this, args);
      }.bind(this));
      this._bufferedEvents = [];
    };
    DelayedStream.prototype.pipe = function() {
      var r = Stream.prototype.pipe.apply(this, arguments);
      this.resume();
      return r;
    };
    DelayedStream.prototype._handleEmit = function(args) {
      if (this._released) {
        this.emit.apply(this, args);
        return;
      }
      if (args[0] === "data") {
        this.dataSize += args[1].length;
        this._checkIfMaxDataSizeExceeded();
      }
      this._bufferedEvents.push(args);
    };
    DelayedStream.prototype._checkIfMaxDataSizeExceeded = function() {
      if (this._maxDataSizeExceeded) {
        return;
      }
      if (this.dataSize <= this.maxDataSize) {
        return;
      }
      this._maxDataSizeExceeded = true;
      var message = "DelayedStream#maxDataSize of " + this.maxDataSize + " bytes exceeded.";
      this.emit("error", new Error(message));
    };
  }
});

// node_modules/combined-stream/lib/combined_stream.js
var require_combined_stream = __commonJS({
  "node_modules/combined-stream/lib/combined_stream.js"(exports2, module2) {
    var util = require("util");
    var Stream = require("stream").Stream;
    var DelayedStream = require_delayed_stream();
    module2.exports = CombinedStream;
    function CombinedStream() {
      this.writable = false;
      this.readable = true;
      this.dataSize = 0;
      this.maxDataSize = 2 * 1024 * 1024;
      this.pauseStreams = true;
      this._released = false;
      this._streams = [];
      this._currentStream = null;
      this._insideLoop = false;
      this._pendingNext = false;
    }
    util.inherits(CombinedStream, Stream);
    CombinedStream.create = function(options) {
      var combinedStream = new this();
      options = options || {};
      for (var option2 in options) {
        combinedStream[option2] = options[option2];
      }
      return combinedStream;
    };
    CombinedStream.isStreamLike = function(stream) {
      return typeof stream !== "function" && typeof stream !== "string" && typeof stream !== "boolean" && typeof stream !== "number" && !Buffer.isBuffer(stream);
    };
    CombinedStream.prototype.append = function(stream) {
      var isStreamLike = CombinedStream.isStreamLike(stream);
      if (isStreamLike) {
        if (!(stream instanceof DelayedStream)) {
          var newStream = DelayedStream.create(stream, {
            maxDataSize: Infinity,
            pauseStream: this.pauseStreams
          });
          stream.on("data", this._checkDataSize.bind(this));
          stream = newStream;
        }
        this._handleErrors(stream);
        if (this.pauseStreams) {
          stream.pause();
        }
      }
      this._streams.push(stream);
      return this;
    };
    CombinedStream.prototype.pipe = function(dest, options) {
      Stream.prototype.pipe.call(this, dest, options);
      this.resume();
      return dest;
    };
    CombinedStream.prototype._getNext = function() {
      this._currentStream = null;
      if (this._insideLoop) {
        this._pendingNext = true;
        return;
      }
      this._insideLoop = true;
      try {
        do {
          this._pendingNext = false;
          this._realGetNext();
        } while (this._pendingNext);
      } finally {
        this._insideLoop = false;
      }
    };
    CombinedStream.prototype._realGetNext = function() {
      var stream = this._streams.shift();
      if (typeof stream == "undefined") {
        this.end();
        return;
      }
      if (typeof stream !== "function") {
        this._pipeNext(stream);
        return;
      }
      var getStream = stream;
      getStream(function(stream2) {
        var isStreamLike = CombinedStream.isStreamLike(stream2);
        if (isStreamLike) {
          stream2.on("data", this._checkDataSize.bind(this));
          this._handleErrors(stream2);
        }
        this._pipeNext(stream2);
      }.bind(this));
    };
    CombinedStream.prototype._pipeNext = function(stream) {
      this._currentStream = stream;
      var isStreamLike = CombinedStream.isStreamLike(stream);
      if (isStreamLike) {
        stream.on("end", this._getNext.bind(this));
        stream.pipe(this, { end: false });
        return;
      }
      var value = stream;
      this.write(value);
      this._getNext();
    };
    CombinedStream.prototype._handleErrors = function(stream) {
      var self2 = this;
      stream.on("error", function(err) {
        self2._emitError(err);
      });
    };
    CombinedStream.prototype.write = function(data) {
      this.emit("data", data);
    };
    CombinedStream.prototype.pause = function() {
      if (!this.pauseStreams) {
        return;
      }
      if (this.pauseStreams && this._currentStream && typeof this._currentStream.pause == "function")
        this._currentStream.pause();
      this.emit("pause");
    };
    CombinedStream.prototype.resume = function() {
      if (!this._released) {
        this._released = true;
        this.writable = true;
        this._getNext();
      }
      if (this.pauseStreams && this._currentStream && typeof this._currentStream.resume == "function")
        this._currentStream.resume();
      this.emit("resume");
    };
    CombinedStream.prototype.end = function() {
      this._reset();
      this.emit("end");
    };
    CombinedStream.prototype.destroy = function() {
      this._reset();
      this.emit("close");
    };
    CombinedStream.prototype._reset = function() {
      this.writable = false;
      this._streams = [];
      this._currentStream = null;
    };
    CombinedStream.prototype._checkDataSize = function() {
      this._updateDataSize();
      if (this.dataSize <= this.maxDataSize) {
        return;
      }
      var message = "DelayedStream#maxDataSize of " + this.maxDataSize + " bytes exceeded.";
      this._emitError(new Error(message));
    };
    CombinedStream.prototype._updateDataSize = function() {
      this.dataSize = 0;
      var self2 = this;
      this._streams.forEach(function(stream) {
        if (!stream.dataSize) {
          return;
        }
        self2.dataSize += stream.dataSize;
      });
      if (this._currentStream && this._currentStream.dataSize) {
        this.dataSize += this._currentStream.dataSize;
      }
    };
    CombinedStream.prototype._emitError = function(err) {
      this._reset();
      this.emit("error", err);
    };
  }
});

// node_modules/mime-db/db.json
var require_db = __commonJS({
  "node_modules/mime-db/db.json"(exports2, module2) {
    module2.exports = {
      "application/1d-interleaved-parityfec": {
        source: "iana"
      },
      "application/3gpdash-qoe-report+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/3gpp-ims+xml": {
        source: "iana",
        compressible: true
      },
      "application/3gpphal+json": {
        source: "iana",
        compressible: true
      },
      "application/3gpphalforms+json": {
        source: "iana",
        compressible: true
      },
      "application/a2l": {
        source: "iana"
      },
      "application/ace+cbor": {
        source: "iana"
      },
      "application/activemessage": {
        source: "iana"
      },
      "application/activity+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-costmap+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-costmapfilter+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-directory+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointcost+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointcostparams+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointprop+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointpropparams+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-error+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-networkmap+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-networkmapfilter+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-updatestreamcontrol+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-updatestreamparams+json": {
        source: "iana",
        compressible: true
      },
      "application/aml": {
        source: "iana"
      },
      "application/andrew-inset": {
        source: "iana",
        extensions: ["ez"]
      },
      "application/applefile": {
        source: "iana"
      },
      "application/applixware": {
        source: "apache",
        extensions: ["aw"]
      },
      "application/at+jwt": {
        source: "iana"
      },
      "application/atf": {
        source: "iana"
      },
      "application/atfx": {
        source: "iana"
      },
      "application/atom+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atom"]
      },
      "application/atomcat+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atomcat"]
      },
      "application/atomdeleted+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atomdeleted"]
      },
      "application/atomicmail": {
        source: "iana"
      },
      "application/atomsvc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atomsvc"]
      },
      "application/atsc-dwd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["dwd"]
      },
      "application/atsc-dynamic-event-message": {
        source: "iana"
      },
      "application/atsc-held+xml": {
        source: "iana",
        compressible: true,
        extensions: ["held"]
      },
      "application/atsc-rdt+json": {
        source: "iana",
        compressible: true
      },
      "application/atsc-rsat+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rsat"]
      },
      "application/atxml": {
        source: "iana"
      },
      "application/auth-policy+xml": {
        source: "iana",
        compressible: true
      },
      "application/bacnet-xdd+zip": {
        source: "iana",
        compressible: false
      },
      "application/batch-smtp": {
        source: "iana"
      },
      "application/bdoc": {
        compressible: false,
        extensions: ["bdoc"]
      },
      "application/beep+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/calendar+json": {
        source: "iana",
        compressible: true
      },
      "application/calendar+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xcs"]
      },
      "application/call-completion": {
        source: "iana"
      },
      "application/cals-1840": {
        source: "iana"
      },
      "application/captive+json": {
        source: "iana",
        compressible: true
      },
      "application/cbor": {
        source: "iana"
      },
      "application/cbor-seq": {
        source: "iana"
      },
      "application/cccex": {
        source: "iana"
      },
      "application/ccmp+xml": {
        source: "iana",
        compressible: true
      },
      "application/ccxml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ccxml"]
      },
      "application/cdfx+xml": {
        source: "iana",
        compressible: true,
        extensions: ["cdfx"]
      },
      "application/cdmi-capability": {
        source: "iana",
        extensions: ["cdmia"]
      },
      "application/cdmi-container": {
        source: "iana",
        extensions: ["cdmic"]
      },
      "application/cdmi-domain": {
        source: "iana",
        extensions: ["cdmid"]
      },
      "application/cdmi-object": {
        source: "iana",
        extensions: ["cdmio"]
      },
      "application/cdmi-queue": {
        source: "iana",
        extensions: ["cdmiq"]
      },
      "application/cdni": {
        source: "iana"
      },
      "application/cea": {
        source: "iana"
      },
      "application/cea-2018+xml": {
        source: "iana",
        compressible: true
      },
      "application/cellml+xml": {
        source: "iana",
        compressible: true
      },
      "application/cfw": {
        source: "iana"
      },
      "application/city+json": {
        source: "iana",
        compressible: true
      },
      "application/clr": {
        source: "iana"
      },
      "application/clue+xml": {
        source: "iana",
        compressible: true
      },
      "application/clue_info+xml": {
        source: "iana",
        compressible: true
      },
      "application/cms": {
        source: "iana"
      },
      "application/cnrp+xml": {
        source: "iana",
        compressible: true
      },
      "application/coap-group+json": {
        source: "iana",
        compressible: true
      },
      "application/coap-payload": {
        source: "iana"
      },
      "application/commonground": {
        source: "iana"
      },
      "application/conference-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/cose": {
        source: "iana"
      },
      "application/cose-key": {
        source: "iana"
      },
      "application/cose-key-set": {
        source: "iana"
      },
      "application/cpl+xml": {
        source: "iana",
        compressible: true,
        extensions: ["cpl"]
      },
      "application/csrattrs": {
        source: "iana"
      },
      "application/csta+xml": {
        source: "iana",
        compressible: true
      },
      "application/cstadata+xml": {
        source: "iana",
        compressible: true
      },
      "application/csvm+json": {
        source: "iana",
        compressible: true
      },
      "application/cu-seeme": {
        source: "apache",
        extensions: ["cu"]
      },
      "application/cwt": {
        source: "iana"
      },
      "application/cybercash": {
        source: "iana"
      },
      "application/dart": {
        compressible: true
      },
      "application/dash+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpd"]
      },
      "application/dash-patch+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpp"]
      },
      "application/dashdelta": {
        source: "iana"
      },
      "application/davmount+xml": {
        source: "iana",
        compressible: true,
        extensions: ["davmount"]
      },
      "application/dca-rft": {
        source: "iana"
      },
      "application/dcd": {
        source: "iana"
      },
      "application/dec-dx": {
        source: "iana"
      },
      "application/dialog-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/dicom": {
        source: "iana"
      },
      "application/dicom+json": {
        source: "iana",
        compressible: true
      },
      "application/dicom+xml": {
        source: "iana",
        compressible: true
      },
      "application/dii": {
        source: "iana"
      },
      "application/dit": {
        source: "iana"
      },
      "application/dns": {
        source: "iana"
      },
      "application/dns+json": {
        source: "iana",
        compressible: true
      },
      "application/dns-message": {
        source: "iana"
      },
      "application/docbook+xml": {
        source: "apache",
        compressible: true,
        extensions: ["dbk"]
      },
      "application/dots+cbor": {
        source: "iana"
      },
      "application/dskpp+xml": {
        source: "iana",
        compressible: true
      },
      "application/dssc+der": {
        source: "iana",
        extensions: ["dssc"]
      },
      "application/dssc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xdssc"]
      },
      "application/dvcs": {
        source: "iana"
      },
      "application/ecmascript": {
        source: "iana",
        compressible: true,
        extensions: ["es", "ecma"]
      },
      "application/edi-consent": {
        source: "iana"
      },
      "application/edi-x12": {
        source: "iana",
        compressible: false
      },
      "application/edifact": {
        source: "iana",
        compressible: false
      },
      "application/efi": {
        source: "iana"
      },
      "application/elm+json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/elm+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.cap+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/emergencycalldata.comment+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.control+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.deviceinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.ecall.msd": {
        source: "iana"
      },
      "application/emergencycalldata.providerinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.serviceinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.subscriberinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.veds+xml": {
        source: "iana",
        compressible: true
      },
      "application/emma+xml": {
        source: "iana",
        compressible: true,
        extensions: ["emma"]
      },
      "application/emotionml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["emotionml"]
      },
      "application/encaprtp": {
        source: "iana"
      },
      "application/epp+xml": {
        source: "iana",
        compressible: true
      },
      "application/epub+zip": {
        source: "iana",
        compressible: false,
        extensions: ["epub"]
      },
      "application/eshop": {
        source: "iana"
      },
      "application/exi": {
        source: "iana",
        extensions: ["exi"]
      },
      "application/expect-ct-report+json": {
        source: "iana",
        compressible: true
      },
      "application/express": {
        source: "iana",
        extensions: ["exp"]
      },
      "application/fastinfoset": {
        source: "iana"
      },
      "application/fastsoap": {
        source: "iana"
      },
      "application/fdt+xml": {
        source: "iana",
        compressible: true,
        extensions: ["fdt"]
      },
      "application/fhir+json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/fhir+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/fido.trusted-apps+json": {
        compressible: true
      },
      "application/fits": {
        source: "iana"
      },
      "application/flexfec": {
        source: "iana"
      },
      "application/font-sfnt": {
        source: "iana"
      },
      "application/font-tdpfr": {
        source: "iana",
        extensions: ["pfr"]
      },
      "application/font-woff": {
        source: "iana",
        compressible: false
      },
      "application/framework-attributes+xml": {
        source: "iana",
        compressible: true
      },
      "application/geo+json": {
        source: "iana",
        compressible: true,
        extensions: ["geojson"]
      },
      "application/geo+json-seq": {
        source: "iana"
      },
      "application/geopackage+sqlite3": {
        source: "iana"
      },
      "application/geoxacml+xml": {
        source: "iana",
        compressible: true
      },
      "application/gltf-buffer": {
        source: "iana"
      },
      "application/gml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["gml"]
      },
      "application/gpx+xml": {
        source: "apache",
        compressible: true,
        extensions: ["gpx"]
      },
      "application/gxf": {
        source: "apache",
        extensions: ["gxf"]
      },
      "application/gzip": {
        source: "iana",
        compressible: false,
        extensions: ["gz"]
      },
      "application/h224": {
        source: "iana"
      },
      "application/held+xml": {
        source: "iana",
        compressible: true
      },
      "application/hjson": {
        extensions: ["hjson"]
      },
      "application/http": {
        source: "iana"
      },
      "application/hyperstudio": {
        source: "iana",
        extensions: ["stk"]
      },
      "application/ibe-key-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/ibe-pkg-reply+xml": {
        source: "iana",
        compressible: true
      },
      "application/ibe-pp-data": {
        source: "iana"
      },
      "application/iges": {
        source: "iana"
      },
      "application/im-iscomposing+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/index": {
        source: "iana"
      },
      "application/index.cmd": {
        source: "iana"
      },
      "application/index.obj": {
        source: "iana"
      },
      "application/index.response": {
        source: "iana"
      },
      "application/index.vnd": {
        source: "iana"
      },
      "application/inkml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ink", "inkml"]
      },
      "application/iotp": {
        source: "iana"
      },
      "application/ipfix": {
        source: "iana",
        extensions: ["ipfix"]
      },
      "application/ipp": {
        source: "iana"
      },
      "application/isup": {
        source: "iana"
      },
      "application/its+xml": {
        source: "iana",
        compressible: true,
        extensions: ["its"]
      },
      "application/java-archive": {
        source: "apache",
        compressible: false,
        extensions: ["jar", "war", "ear"]
      },
      "application/java-serialized-object": {
        source: "apache",
        compressible: false,
        extensions: ["ser"]
      },
      "application/java-vm": {
        source: "apache",
        compressible: false,
        extensions: ["class"]
      },
      "application/javascript": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["js", "mjs"]
      },
      "application/jf2feed+json": {
        source: "iana",
        compressible: true
      },
      "application/jose": {
        source: "iana"
      },
      "application/jose+json": {
        source: "iana",
        compressible: true
      },
      "application/jrd+json": {
        source: "iana",
        compressible: true
      },
      "application/jscalendar+json": {
        source: "iana",
        compressible: true
      },
      "application/json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["json", "map"]
      },
      "application/json-patch+json": {
        source: "iana",
        compressible: true
      },
      "application/json-seq": {
        source: "iana"
      },
      "application/json5": {
        extensions: ["json5"]
      },
      "application/jsonml+json": {
        source: "apache",
        compressible: true,
        extensions: ["jsonml"]
      },
      "application/jwk+json": {
        source: "iana",
        compressible: true
      },
      "application/jwk-set+json": {
        source: "iana",
        compressible: true
      },
      "application/jwt": {
        source: "iana"
      },
      "application/kpml-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/kpml-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/ld+json": {
        source: "iana",
        compressible: true,
        extensions: ["jsonld"]
      },
      "application/lgr+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lgr"]
      },
      "application/link-format": {
        source: "iana"
      },
      "application/load-control+xml": {
        source: "iana",
        compressible: true
      },
      "application/lost+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lostxml"]
      },
      "application/lostsync+xml": {
        source: "iana",
        compressible: true
      },
      "application/lpf+zip": {
        source: "iana",
        compressible: false
      },
      "application/lxf": {
        source: "iana"
      },
      "application/mac-binhex40": {
        source: "iana",
        extensions: ["hqx"]
      },
      "application/mac-compactpro": {
        source: "apache",
        extensions: ["cpt"]
      },
      "application/macwriteii": {
        source: "iana"
      },
      "application/mads+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mads"]
      },
      "application/manifest+json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["webmanifest"]
      },
      "application/marc": {
        source: "iana",
        extensions: ["mrc"]
      },
      "application/marcxml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mrcx"]
      },
      "application/mathematica": {
        source: "iana",
        extensions: ["ma", "nb", "mb"]
      },
      "application/mathml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mathml"]
      },
      "application/mathml-content+xml": {
        source: "iana",
        compressible: true
      },
      "application/mathml-presentation+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-associated-procedure-description+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-deregister+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-envelope+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-msk+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-msk-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-protection-description+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-reception-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-register+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-register-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-schedule+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-user-service-description+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbox": {
        source: "iana",
        extensions: ["mbox"]
      },
      "application/media-policy-dataset+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpf"]
      },
      "application/media_control+xml": {
        source: "iana",
        compressible: true
      },
      "application/mediaservercontrol+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mscml"]
      },
      "application/merge-patch+json": {
        source: "iana",
        compressible: true
      },
      "application/metalink+xml": {
        source: "apache",
        compressible: true,
        extensions: ["metalink"]
      },
      "application/metalink4+xml": {
        source: "iana",
        compressible: true,
        extensions: ["meta4"]
      },
      "application/mets+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mets"]
      },
      "application/mf4": {
        source: "iana"
      },
      "application/mikey": {
        source: "iana"
      },
      "application/mipc": {
        source: "iana"
      },
      "application/missing-blocks+cbor-seq": {
        source: "iana"
      },
      "application/mmt-aei+xml": {
        source: "iana",
        compressible: true,
        extensions: ["maei"]
      },
      "application/mmt-usd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["musd"]
      },
      "application/mods+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mods"]
      },
      "application/moss-keys": {
        source: "iana"
      },
      "application/moss-signature": {
        source: "iana"
      },
      "application/mosskey-data": {
        source: "iana"
      },
      "application/mosskey-request": {
        source: "iana"
      },
      "application/mp21": {
        source: "iana",
        extensions: ["m21", "mp21"]
      },
      "application/mp4": {
        source: "iana",
        extensions: ["mp4s", "m4p"]
      },
      "application/mpeg4-generic": {
        source: "iana"
      },
      "application/mpeg4-iod": {
        source: "iana"
      },
      "application/mpeg4-iod-xmt": {
        source: "iana"
      },
      "application/mrb-consumer+xml": {
        source: "iana",
        compressible: true
      },
      "application/mrb-publish+xml": {
        source: "iana",
        compressible: true
      },
      "application/msc-ivr+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/msc-mixer+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/msword": {
        source: "iana",
        compressible: false,
        extensions: ["doc", "dot"]
      },
      "application/mud+json": {
        source: "iana",
        compressible: true
      },
      "application/multipart-core": {
        source: "iana"
      },
      "application/mxf": {
        source: "iana",
        extensions: ["mxf"]
      },
      "application/n-quads": {
        source: "iana",
        extensions: ["nq"]
      },
      "application/n-triples": {
        source: "iana",
        extensions: ["nt"]
      },
      "application/nasdata": {
        source: "iana"
      },
      "application/news-checkgroups": {
        source: "iana",
        charset: "US-ASCII"
      },
      "application/news-groupinfo": {
        source: "iana",
        charset: "US-ASCII"
      },
      "application/news-transmission": {
        source: "iana"
      },
      "application/nlsml+xml": {
        source: "iana",
        compressible: true
      },
      "application/node": {
        source: "iana",
        extensions: ["cjs"]
      },
      "application/nss": {
        source: "iana"
      },
      "application/oauth-authz-req+jwt": {
        source: "iana"
      },
      "application/oblivious-dns-message": {
        source: "iana"
      },
      "application/ocsp-request": {
        source: "iana"
      },
      "application/ocsp-response": {
        source: "iana"
      },
      "application/octet-stream": {
        source: "iana",
        compressible: false,
        extensions: ["bin", "dms", "lrf", "mar", "so", "dist", "distz", "pkg", "bpk", "dump", "elc", "deploy", "exe", "dll", "deb", "dmg", "iso", "img", "msi", "msp", "msm", "buffer"]
      },
      "application/oda": {
        source: "iana",
        extensions: ["oda"]
      },
      "application/odm+xml": {
        source: "iana",
        compressible: true
      },
      "application/odx": {
        source: "iana"
      },
      "application/oebps-package+xml": {
        source: "iana",
        compressible: true,
        extensions: ["opf"]
      },
      "application/ogg": {
        source: "iana",
        compressible: false,
        extensions: ["ogx"]
      },
      "application/omdoc+xml": {
        source: "apache",
        compressible: true,
        extensions: ["omdoc"]
      },
      "application/onenote": {
        source: "apache",
        extensions: ["onetoc", "onetoc2", "onetmp", "onepkg"]
      },
      "application/opc-nodeset+xml": {
        source: "iana",
        compressible: true
      },
      "application/oscore": {
        source: "iana"
      },
      "application/oxps": {
        source: "iana",
        extensions: ["oxps"]
      },
      "application/p21": {
        source: "iana"
      },
      "application/p21+zip": {
        source: "iana",
        compressible: false
      },
      "application/p2p-overlay+xml": {
        source: "iana",
        compressible: true,
        extensions: ["relo"]
      },
      "application/parityfec": {
        source: "iana"
      },
      "application/passport": {
        source: "iana"
      },
      "application/patch-ops-error+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xer"]
      },
      "application/pdf": {
        source: "iana",
        compressible: false,
        extensions: ["pdf"]
      },
      "application/pdx": {
        source: "iana"
      },
      "application/pem-certificate-chain": {
        source: "iana"
      },
      "application/pgp-encrypted": {
        source: "iana",
        compressible: false,
        extensions: ["pgp"]
      },
      "application/pgp-keys": {
        source: "iana",
        extensions: ["asc"]
      },
      "application/pgp-signature": {
        source: "iana",
        extensions: ["asc", "sig"]
      },
      "application/pics-rules": {
        source: "apache",
        extensions: ["prf"]
      },
      "application/pidf+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/pidf-diff+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/pkcs10": {
        source: "iana",
        extensions: ["p10"]
      },
      "application/pkcs12": {
        source: "iana"
      },
      "application/pkcs7-mime": {
        source: "iana",
        extensions: ["p7m", "p7c"]
      },
      "application/pkcs7-signature": {
        source: "iana",
        extensions: ["p7s"]
      },
      "application/pkcs8": {
        source: "iana",
        extensions: ["p8"]
      },
      "application/pkcs8-encrypted": {
        source: "iana"
      },
      "application/pkix-attr-cert": {
        source: "iana",
        extensions: ["ac"]
      },
      "application/pkix-cert": {
        source: "iana",
        extensions: ["cer"]
      },
      "application/pkix-crl": {
        source: "iana",
        extensions: ["crl"]
      },
      "application/pkix-pkipath": {
        source: "iana",
        extensions: ["pkipath"]
      },
      "application/pkixcmp": {
        source: "iana",
        extensions: ["pki"]
      },
      "application/pls+xml": {
        source: "iana",
        compressible: true,
        extensions: ["pls"]
      },
      "application/poc-settings+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/postscript": {
        source: "iana",
        compressible: true,
        extensions: ["ai", "eps", "ps"]
      },
      "application/ppsp-tracker+json": {
        source: "iana",
        compressible: true
      },
      "application/problem+json": {
        source: "iana",
        compressible: true
      },
      "application/problem+xml": {
        source: "iana",
        compressible: true
      },
      "application/provenance+xml": {
        source: "iana",
        compressible: true,
        extensions: ["provx"]
      },
      "application/prs.alvestrand.titrax-sheet": {
        source: "iana"
      },
      "application/prs.cww": {
        source: "iana",
        extensions: ["cww"]
      },
      "application/prs.cyn": {
        source: "iana",
        charset: "7-BIT"
      },
      "application/prs.hpub+zip": {
        source: "iana",
        compressible: false
      },
      "application/prs.nprend": {
        source: "iana"
      },
      "application/prs.plucker": {
        source: "iana"
      },
      "application/prs.rdf-xml-crypt": {
        source: "iana"
      },
      "application/prs.xsf+xml": {
        source: "iana",
        compressible: true
      },
      "application/pskc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["pskcxml"]
      },
      "application/pvd+json": {
        source: "iana",
        compressible: true
      },
      "application/qsig": {
        source: "iana"
      },
      "application/raml+yaml": {
        compressible: true,
        extensions: ["raml"]
      },
      "application/raptorfec": {
        source: "iana"
      },
      "application/rdap+json": {
        source: "iana",
        compressible: true
      },
      "application/rdf+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rdf", "owl"]
      },
      "application/reginfo+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rif"]
      },
      "application/relax-ng-compact-syntax": {
        source: "iana",
        extensions: ["rnc"]
      },
      "application/remote-printing": {
        source: "iana"
      },
      "application/reputon+json": {
        source: "iana",
        compressible: true
      },
      "application/resource-lists+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rl"]
      },
      "application/resource-lists-diff+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rld"]
      },
      "application/rfc+xml": {
        source: "iana",
        compressible: true
      },
      "application/riscos": {
        source: "iana"
      },
      "application/rlmi+xml": {
        source: "iana",
        compressible: true
      },
      "application/rls-services+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rs"]
      },
      "application/route-apd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rapd"]
      },
      "application/route-s-tsid+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sls"]
      },
      "application/route-usd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rusd"]
      },
      "application/rpki-ghostbusters": {
        source: "iana",
        extensions: ["gbr"]
      },
      "application/rpki-manifest": {
        source: "iana",
        extensions: ["mft"]
      },
      "application/rpki-publication": {
        source: "iana"
      },
      "application/rpki-roa": {
        source: "iana",
        extensions: ["roa"]
      },
      "application/rpki-updown": {
        source: "iana"
      },
      "application/rsd+xml": {
        source: "apache",
        compressible: true,
        extensions: ["rsd"]
      },
      "application/rss+xml": {
        source: "apache",
        compressible: true,
        extensions: ["rss"]
      },
      "application/rtf": {
        source: "iana",
        compressible: true,
        extensions: ["rtf"]
      },
      "application/rtploopback": {
        source: "iana"
      },
      "application/rtx": {
        source: "iana"
      },
      "application/samlassertion+xml": {
        source: "iana",
        compressible: true
      },
      "application/samlmetadata+xml": {
        source: "iana",
        compressible: true
      },
      "application/sarif+json": {
        source: "iana",
        compressible: true
      },
      "application/sarif-external-properties+json": {
        source: "iana",
        compressible: true
      },
      "application/sbe": {
        source: "iana"
      },
      "application/sbml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sbml"]
      },
      "application/scaip+xml": {
        source: "iana",
        compressible: true
      },
      "application/scim+json": {
        source: "iana",
        compressible: true
      },
      "application/scvp-cv-request": {
        source: "iana",
        extensions: ["scq"]
      },
      "application/scvp-cv-response": {
        source: "iana",
        extensions: ["scs"]
      },
      "application/scvp-vp-request": {
        source: "iana",
        extensions: ["spq"]
      },
      "application/scvp-vp-response": {
        source: "iana",
        extensions: ["spp"]
      },
      "application/sdp": {
        source: "iana",
        extensions: ["sdp"]
      },
      "application/secevent+jwt": {
        source: "iana"
      },
      "application/senml+cbor": {
        source: "iana"
      },
      "application/senml+json": {
        source: "iana",
        compressible: true
      },
      "application/senml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["senmlx"]
      },
      "application/senml-etch+cbor": {
        source: "iana"
      },
      "application/senml-etch+json": {
        source: "iana",
        compressible: true
      },
      "application/senml-exi": {
        source: "iana"
      },
      "application/sensml+cbor": {
        source: "iana"
      },
      "application/sensml+json": {
        source: "iana",
        compressible: true
      },
      "application/sensml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sensmlx"]
      },
      "application/sensml-exi": {
        source: "iana"
      },
      "application/sep+xml": {
        source: "iana",
        compressible: true
      },
      "application/sep-exi": {
        source: "iana"
      },
      "application/session-info": {
        source: "iana"
      },
      "application/set-payment": {
        source: "iana"
      },
      "application/set-payment-initiation": {
        source: "iana",
        extensions: ["setpay"]
      },
      "application/set-registration": {
        source: "iana"
      },
      "application/set-registration-initiation": {
        source: "iana",
        extensions: ["setreg"]
      },
      "application/sgml": {
        source: "iana"
      },
      "application/sgml-open-catalog": {
        source: "iana"
      },
      "application/shf+xml": {
        source: "iana",
        compressible: true,
        extensions: ["shf"]
      },
      "application/sieve": {
        source: "iana",
        extensions: ["siv", "sieve"]
      },
      "application/simple-filter+xml": {
        source: "iana",
        compressible: true
      },
      "application/simple-message-summary": {
        source: "iana"
      },
      "application/simplesymbolcontainer": {
        source: "iana"
      },
      "application/sipc": {
        source: "iana"
      },
      "application/slate": {
        source: "iana"
      },
      "application/smil": {
        source: "iana"
      },
      "application/smil+xml": {
        source: "iana",
        compressible: true,
        extensions: ["smi", "smil"]
      },
      "application/smpte336m": {
        source: "iana"
      },
      "application/soap+fastinfoset": {
        source: "iana"
      },
      "application/soap+xml": {
        source: "iana",
        compressible: true
      },
      "application/sparql-query": {
        source: "iana",
        extensions: ["rq"]
      },
      "application/sparql-results+xml": {
        source: "iana",
        compressible: true,
        extensions: ["srx"]
      },
      "application/spdx+json": {
        source: "iana",
        compressible: true
      },
      "application/spirits-event+xml": {
        source: "iana",
        compressible: true
      },
      "application/sql": {
        source: "iana"
      },
      "application/srgs": {
        source: "iana",
        extensions: ["gram"]
      },
      "application/srgs+xml": {
        source: "iana",
        compressible: true,
        extensions: ["grxml"]
      },
      "application/sru+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sru"]
      },
      "application/ssdl+xml": {
        source: "apache",
        compressible: true,
        extensions: ["ssdl"]
      },
      "application/ssml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ssml"]
      },
      "application/stix+json": {
        source: "iana",
        compressible: true
      },
      "application/swid+xml": {
        source: "iana",
        compressible: true,
        extensions: ["swidtag"]
      },
      "application/tamp-apex-update": {
        source: "iana"
      },
      "application/tamp-apex-update-confirm": {
        source: "iana"
      },
      "application/tamp-community-update": {
        source: "iana"
      },
      "application/tamp-community-update-confirm": {
        source: "iana"
      },
      "application/tamp-error": {
        source: "iana"
      },
      "application/tamp-sequence-adjust": {
        source: "iana"
      },
      "application/tamp-sequence-adjust-confirm": {
        source: "iana"
      },
      "application/tamp-status-query": {
        source: "iana"
      },
      "application/tamp-status-response": {
        source: "iana"
      },
      "application/tamp-update": {
        source: "iana"
      },
      "application/tamp-update-confirm": {
        source: "iana"
      },
      "application/tar": {
        compressible: true
      },
      "application/taxii+json": {
        source: "iana",
        compressible: true
      },
      "application/td+json": {
        source: "iana",
        compressible: true
      },
      "application/tei+xml": {
        source: "iana",
        compressible: true,
        extensions: ["tei", "teicorpus"]
      },
      "application/tetra_isi": {
        source: "iana"
      },
      "application/thraud+xml": {
        source: "iana",
        compressible: true,
        extensions: ["tfi"]
      },
      "application/timestamp-query": {
        source: "iana"
      },
      "application/timestamp-reply": {
        source: "iana"
      },
      "application/timestamped-data": {
        source: "iana",
        extensions: ["tsd"]
      },
      "application/tlsrpt+gzip": {
        source: "iana"
      },
      "application/tlsrpt+json": {
        source: "iana",
        compressible: true
      },
      "application/tnauthlist": {
        source: "iana"
      },
      "application/token-introspection+jwt": {
        source: "iana"
      },
      "application/toml": {
        compressible: true,
        extensions: ["toml"]
      },
      "application/trickle-ice-sdpfrag": {
        source: "iana"
      },
      "application/trig": {
        source: "iana",
        extensions: ["trig"]
      },
      "application/ttml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ttml"]
      },
      "application/tve-trigger": {
        source: "iana"
      },
      "application/tzif": {
        source: "iana"
      },
      "application/tzif-leap": {
        source: "iana"
      },
      "application/ubjson": {
        compressible: false,
        extensions: ["ubj"]
      },
      "application/ulpfec": {
        source: "iana"
      },
      "application/urc-grpsheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/urc-ressheet+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rsheet"]
      },
      "application/urc-targetdesc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["td"]
      },
      "application/urc-uisocketdesc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vcard+json": {
        source: "iana",
        compressible: true
      },
      "application/vcard+xml": {
        source: "iana",
        compressible: true
      },
      "application/vemmi": {
        source: "iana"
      },
      "application/vividence.scriptfile": {
        source: "apache"
      },
      "application/vnd.1000minds.decision-model+xml": {
        source: "iana",
        compressible: true,
        extensions: ["1km"]
      },
      "application/vnd.3gpp-prose+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp-prose-pc3ch+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp-v2x-local-service-information": {
        source: "iana"
      },
      "application/vnd.3gpp.5gnas": {
        source: "iana"
      },
      "application/vnd.3gpp.access-transfer-events+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.bsf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.gmop+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.gtpc": {
        source: "iana"
      },
      "application/vnd.3gpp.interworking-data": {
        source: "iana"
      },
      "application/vnd.3gpp.lpp": {
        source: "iana"
      },
      "application/vnd.3gpp.mc-signalling-ear": {
        source: "iana"
      },
      "application/vnd.3gpp.mcdata-affiliation-command+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-payload": {
        source: "iana"
      },
      "application/vnd.3gpp.mcdata-service-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-signalling": {
        source: "iana"
      },
      "application/vnd.3gpp.mcdata-ue-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-user-profile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-affiliation-command+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-floor-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-location-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-mbms-usage-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-service-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-signed+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-ue-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-ue-init-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-user-profile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-affiliation-command+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-affiliation-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-location-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-mbms-usage-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-service-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-transmission-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-ue-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-user-profile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mid-call+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.ngap": {
        source: "iana"
      },
      "application/vnd.3gpp.pfcp": {
        source: "iana"
      },
      "application/vnd.3gpp.pic-bw-large": {
        source: "iana",
        extensions: ["plb"]
      },
      "application/vnd.3gpp.pic-bw-small": {
        source: "iana",
        extensions: ["psb"]
      },
      "application/vnd.3gpp.pic-bw-var": {
        source: "iana",
        extensions: ["pvb"]
      },
      "application/vnd.3gpp.s1ap": {
        source: "iana"
      },
      "application/vnd.3gpp.sms": {
        source: "iana"
      },
      "application/vnd.3gpp.sms+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.srvcc-ext+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.srvcc-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.state-and-event-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.ussd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp2.bcmcsinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp2.sms": {
        source: "iana"
      },
      "application/vnd.3gpp2.tcap": {
        source: "iana",
        extensions: ["tcap"]
      },
      "application/vnd.3lightssoftware.imagescal": {
        source: "iana"
      },
      "application/vnd.3m.post-it-notes": {
        source: "iana",
        extensions: ["pwn"]
      },
      "application/vnd.accpac.simply.aso": {
        source: "iana",
        extensions: ["aso"]
      },
      "application/vnd.accpac.simply.imp": {
        source: "iana",
        extensions: ["imp"]
      },
      "application/vnd.acucobol": {
        source: "iana",
        extensions: ["acu"]
      },
      "application/vnd.acucorp": {
        source: "iana",
        extensions: ["atc", "acutc"]
      },
      "application/vnd.adobe.air-application-installer-package+zip": {
        source: "apache",
        compressible: false,
        extensions: ["air"]
      },
      "application/vnd.adobe.flash.movie": {
        source: "iana"
      },
      "application/vnd.adobe.formscentral.fcdt": {
        source: "iana",
        extensions: ["fcdt"]
      },
      "application/vnd.adobe.fxp": {
        source: "iana",
        extensions: ["fxp", "fxpl"]
      },
      "application/vnd.adobe.partial-upload": {
        source: "iana"
      },
      "application/vnd.adobe.xdp+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xdp"]
      },
      "application/vnd.adobe.xfdf": {
        source: "iana",
        extensions: ["xfdf"]
      },
      "application/vnd.aether.imp": {
        source: "iana"
      },
      "application/vnd.afpc.afplinedata": {
        source: "iana"
      },
      "application/vnd.afpc.afplinedata-pagedef": {
        source: "iana"
      },
      "application/vnd.afpc.cmoca-cmresource": {
        source: "iana"
      },
      "application/vnd.afpc.foca-charset": {
        source: "iana"
      },
      "application/vnd.afpc.foca-codedfont": {
        source: "iana"
      },
      "application/vnd.afpc.foca-codepage": {
        source: "iana"
      },
      "application/vnd.afpc.modca": {
        source: "iana"
      },
      "application/vnd.afpc.modca-cmtable": {
        source: "iana"
      },
      "application/vnd.afpc.modca-formdef": {
        source: "iana"
      },
      "application/vnd.afpc.modca-mediummap": {
        source: "iana"
      },
      "application/vnd.afpc.modca-objectcontainer": {
        source: "iana"
      },
      "application/vnd.afpc.modca-overlay": {
        source: "iana"
      },
      "application/vnd.afpc.modca-pagesegment": {
        source: "iana"
      },
      "application/vnd.age": {
        source: "iana",
        extensions: ["age"]
      },
      "application/vnd.ah-barcode": {
        source: "iana"
      },
      "application/vnd.ahead.space": {
        source: "iana",
        extensions: ["ahead"]
      },
      "application/vnd.airzip.filesecure.azf": {
        source: "iana",
        extensions: ["azf"]
      },
      "application/vnd.airzip.filesecure.azs": {
        source: "iana",
        extensions: ["azs"]
      },
      "application/vnd.amadeus+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.amazon.ebook": {
        source: "apache",
        extensions: ["azw"]
      },
      "application/vnd.amazon.mobi8-ebook": {
        source: "iana"
      },
      "application/vnd.americandynamics.acc": {
        source: "iana",
        extensions: ["acc"]
      },
      "application/vnd.amiga.ami": {
        source: "iana",
        extensions: ["ami"]
      },
      "application/vnd.amundsen.maze+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.android.ota": {
        source: "iana"
      },
      "application/vnd.android.package-archive": {
        source: "apache",
        compressible: false,
        extensions: ["apk"]
      },
      "application/vnd.anki": {
        source: "iana"
      },
      "application/vnd.anser-web-certificate-issue-initiation": {
        source: "iana",
        extensions: ["cii"]
      },
      "application/vnd.anser-web-funds-transfer-initiation": {
        source: "apache",
        extensions: ["fti"]
      },
      "application/vnd.antix.game-component": {
        source: "iana",
        extensions: ["atx"]
      },
      "application/vnd.apache.arrow.file": {
        source: "iana"
      },
      "application/vnd.apache.arrow.stream": {
        source: "iana"
      },
      "application/vnd.apache.thrift.binary": {
        source: "iana"
      },
      "application/vnd.apache.thrift.compact": {
        source: "iana"
      },
      "application/vnd.apache.thrift.json": {
        source: "iana"
      },
      "application/vnd.api+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.aplextor.warrp+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.apothekende.reservation+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.apple.installer+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpkg"]
      },
      "application/vnd.apple.keynote": {
        source: "iana",
        extensions: ["key"]
      },
      "application/vnd.apple.mpegurl": {
        source: "iana",
        extensions: ["m3u8"]
      },
      "application/vnd.apple.numbers": {
        source: "iana",
        extensions: ["numbers"]
      },
      "application/vnd.apple.pages": {
        source: "iana",
        extensions: ["pages"]
      },
      "application/vnd.apple.pkpass": {
        compressible: false,
        extensions: ["pkpass"]
      },
      "application/vnd.arastra.swi": {
        source: "iana"
      },
      "application/vnd.aristanetworks.swi": {
        source: "iana",
        extensions: ["swi"]
      },
      "application/vnd.artisan+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.artsquare": {
        source: "iana"
      },
      "application/vnd.astraea-software.iota": {
        source: "iana",
        extensions: ["iota"]
      },
      "application/vnd.audiograph": {
        source: "iana",
        extensions: ["aep"]
      },
      "application/vnd.autopackage": {
        source: "iana"
      },
      "application/vnd.avalon+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.avistar+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.balsamiq.bmml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["bmml"]
      },
      "application/vnd.balsamiq.bmpr": {
        source: "iana"
      },
      "application/vnd.banana-accounting": {
        source: "iana"
      },
      "application/vnd.bbf.usp.error": {
        source: "iana"
      },
      "application/vnd.bbf.usp.msg": {
        source: "iana"
      },
      "application/vnd.bbf.usp.msg+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.bekitzur-stech+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.bint.med-content": {
        source: "iana"
      },
      "application/vnd.biopax.rdf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.blink-idb-value-wrapper": {
        source: "iana"
      },
      "application/vnd.blueice.multipass": {
        source: "iana",
        extensions: ["mpm"]
      },
      "application/vnd.bluetooth.ep.oob": {
        source: "iana"
      },
      "application/vnd.bluetooth.le.oob": {
        source: "iana"
      },
      "application/vnd.bmi": {
        source: "iana",
        extensions: ["bmi"]
      },
      "application/vnd.bpf": {
        source: "iana"
      },
      "application/vnd.bpf3": {
        source: "iana"
      },
      "application/vnd.businessobjects": {
        source: "iana",
        extensions: ["rep"]
      },
      "application/vnd.byu.uapi+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cab-jscript": {
        source: "iana"
      },
      "application/vnd.canon-cpdl": {
        source: "iana"
      },
      "application/vnd.canon-lips": {
        source: "iana"
      },
      "application/vnd.capasystems-pg+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cendio.thinlinc.clientconf": {
        source: "iana"
      },
      "application/vnd.century-systems.tcp_stream": {
        source: "iana"
      },
      "application/vnd.chemdraw+xml": {
        source: "iana",
        compressible: true,
        extensions: ["cdxml"]
      },
      "application/vnd.chess-pgn": {
        source: "iana"
      },
      "application/vnd.chipnuts.karaoke-mmd": {
        source: "iana",
        extensions: ["mmd"]
      },
      "application/vnd.ciedi": {
        source: "iana"
      },
      "application/vnd.cinderella": {
        source: "iana",
        extensions: ["cdy"]
      },
      "application/vnd.cirpack.isdn-ext": {
        source: "iana"
      },
      "application/vnd.citationstyles.style+xml": {
        source: "iana",
        compressible: true,
        extensions: ["csl"]
      },
      "application/vnd.claymore": {
        source: "iana",
        extensions: ["cla"]
      },
      "application/vnd.cloanto.rp9": {
        source: "iana",
        extensions: ["rp9"]
      },
      "application/vnd.clonk.c4group": {
        source: "iana",
        extensions: ["c4g", "c4d", "c4f", "c4p", "c4u"]
      },
      "application/vnd.cluetrust.cartomobile-config": {
        source: "iana",
        extensions: ["c11amc"]
      },
      "application/vnd.cluetrust.cartomobile-config-pkg": {
        source: "iana",
        extensions: ["c11amz"]
      },
      "application/vnd.coffeescript": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.document": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.document-template": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.presentation": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.presentation-template": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.spreadsheet": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.spreadsheet-template": {
        source: "iana"
      },
      "application/vnd.collection+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.collection.doc+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.collection.next+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.comicbook+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.comicbook-rar": {
        source: "iana"
      },
      "application/vnd.commerce-battelle": {
        source: "iana"
      },
      "application/vnd.commonspace": {
        source: "iana",
        extensions: ["csp"]
      },
      "application/vnd.contact.cmsg": {
        source: "iana",
        extensions: ["cdbcmsg"]
      },
      "application/vnd.coreos.ignition+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cosmocaller": {
        source: "iana",
        extensions: ["cmc"]
      },
      "application/vnd.crick.clicker": {
        source: "iana",
        extensions: ["clkx"]
      },
      "application/vnd.crick.clicker.keyboard": {
        source: "iana",
        extensions: ["clkk"]
      },
      "application/vnd.crick.clicker.palette": {
        source: "iana",
        extensions: ["clkp"]
      },
      "application/vnd.crick.clicker.template": {
        source: "iana",
        extensions: ["clkt"]
      },
      "application/vnd.crick.clicker.wordbank": {
        source: "iana",
        extensions: ["clkw"]
      },
      "application/vnd.criticaltools.wbs+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wbs"]
      },
      "application/vnd.cryptii.pipe+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.crypto-shade-file": {
        source: "iana"
      },
      "application/vnd.cryptomator.encrypted": {
        source: "iana"
      },
      "application/vnd.cryptomator.vault": {
        source: "iana"
      },
      "application/vnd.ctc-posml": {
        source: "iana",
        extensions: ["pml"]
      },
      "application/vnd.ctct.ws+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cups-pdf": {
        source: "iana"
      },
      "application/vnd.cups-postscript": {
        source: "iana"
      },
      "application/vnd.cups-ppd": {
        source: "iana",
        extensions: ["ppd"]
      },
      "application/vnd.cups-raster": {
        source: "iana"
      },
      "application/vnd.cups-raw": {
        source: "iana"
      },
      "application/vnd.curl": {
        source: "iana"
      },
      "application/vnd.curl.car": {
        source: "apache",
        extensions: ["car"]
      },
      "application/vnd.curl.pcurl": {
        source: "apache",
        extensions: ["pcurl"]
      },
      "application/vnd.cyan.dean.root+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cybank": {
        source: "iana"
      },
      "application/vnd.cyclonedx+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cyclonedx+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.d2l.coursepackage1p0+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.d3m-dataset": {
        source: "iana"
      },
      "application/vnd.d3m-problem": {
        source: "iana"
      },
      "application/vnd.dart": {
        source: "iana",
        compressible: true,
        extensions: ["dart"]
      },
      "application/vnd.data-vision.rdz": {
        source: "iana",
        extensions: ["rdz"]
      },
      "application/vnd.datapackage+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dataresource+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dbf": {
        source: "iana",
        extensions: ["dbf"]
      },
      "application/vnd.debian.binary-package": {
        source: "iana"
      },
      "application/vnd.dece.data": {
        source: "iana",
        extensions: ["uvf", "uvvf", "uvd", "uvvd"]
      },
      "application/vnd.dece.ttml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["uvt", "uvvt"]
      },
      "application/vnd.dece.unspecified": {
        source: "iana",
        extensions: ["uvx", "uvvx"]
      },
      "application/vnd.dece.zip": {
        source: "iana",
        extensions: ["uvz", "uvvz"]
      },
      "application/vnd.denovo.fcselayout-link": {
        source: "iana",
        extensions: ["fe_launch"]
      },
      "application/vnd.desmume.movie": {
        source: "iana"
      },
      "application/vnd.dir-bi.plate-dl-nosuffix": {
        source: "iana"
      },
      "application/vnd.dm.delegation+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dna": {
        source: "iana",
        extensions: ["dna"]
      },
      "application/vnd.document+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dolby.mlp": {
        source: "apache",
        extensions: ["mlp"]
      },
      "application/vnd.dolby.mobile.1": {
        source: "iana"
      },
      "application/vnd.dolby.mobile.2": {
        source: "iana"
      },
      "application/vnd.doremir.scorecloud-binary-document": {
        source: "iana"
      },
      "application/vnd.dpgraph": {
        source: "iana",
        extensions: ["dpg"]
      },
      "application/vnd.dreamfactory": {
        source: "iana",
        extensions: ["dfac"]
      },
      "application/vnd.drive+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ds-keypoint": {
        source: "apache",
        extensions: ["kpxx"]
      },
      "application/vnd.dtg.local": {
        source: "iana"
      },
      "application/vnd.dtg.local.flash": {
        source: "iana"
      },
      "application/vnd.dtg.local.html": {
        source: "iana"
      },
      "application/vnd.dvb.ait": {
        source: "iana",
        extensions: ["ait"]
      },
      "application/vnd.dvb.dvbisl+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.dvbj": {
        source: "iana"
      },
      "application/vnd.dvb.esgcontainer": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcdftnotifaccess": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcesgaccess": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcesgaccess2": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcesgpdd": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcroaming": {
        source: "iana"
      },
      "application/vnd.dvb.iptv.alfec-base": {
        source: "iana"
      },
      "application/vnd.dvb.iptv.alfec-enhancement": {
        source: "iana"
      },
      "application/vnd.dvb.notif-aggregate-root+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-container+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-generic+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-ia-msglist+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-ia-registration-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-ia-registration-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-init+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.pfr": {
        source: "iana"
      },
      "application/vnd.dvb.service": {
        source: "iana",
        extensions: ["svc"]
      },
      "application/vnd.dxr": {
        source: "iana"
      },
      "application/vnd.dynageo": {
        source: "iana",
        extensions: ["geo"]
      },
      "application/vnd.dzr": {
        source: "iana"
      },
      "application/vnd.easykaraoke.cdgdownload": {
        source: "iana"
      },
      "application/vnd.ecdis-update": {
        source: "iana"
      },
      "application/vnd.ecip.rlp": {
        source: "iana"
      },
      "application/vnd.eclipse.ditto+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ecowin.chart": {
        source: "iana",
        extensions: ["mag"]
      },
      "application/vnd.ecowin.filerequest": {
        source: "iana"
      },
      "application/vnd.ecowin.fileupdate": {
        source: "iana"
      },
      "application/vnd.ecowin.series": {
        source: "iana"
      },
      "application/vnd.ecowin.seriesrequest": {
        source: "iana"
      },
      "application/vnd.ecowin.seriesupdate": {
        source: "iana"
      },
      "application/vnd.efi.img": {
        source: "iana"
      },
      "application/vnd.efi.iso": {
        source: "iana"
      },
      "application/vnd.emclient.accessrequest+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.enliven": {
        source: "iana",
        extensions: ["nml"]
      },
      "application/vnd.enphase.envoy": {
        source: "iana"
      },
      "application/vnd.eprints.data+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.epson.esf": {
        source: "iana",
        extensions: ["esf"]
      },
      "application/vnd.epson.msf": {
        source: "iana",
        extensions: ["msf"]
      },
      "application/vnd.epson.quickanime": {
        source: "iana",
        extensions: ["qam"]
      },
      "application/vnd.epson.salt": {
        source: "iana",
        extensions: ["slt"]
      },
      "application/vnd.epson.ssf": {
        source: "iana",
        extensions: ["ssf"]
      },
      "application/vnd.ericsson.quickcall": {
        source: "iana"
      },
      "application/vnd.espass-espass+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.eszigno3+xml": {
        source: "iana",
        compressible: true,
        extensions: ["es3", "et3"]
      },
      "application/vnd.etsi.aoc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.asic-e+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.etsi.asic-s+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.etsi.cug+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvcommand+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvdiscovery+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsad-bc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsad-cod+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsad-npvr+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvservice+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsync+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvueprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.mcid+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.mheg5": {
        source: "iana"
      },
      "application/vnd.etsi.overload-control-policy-dataset+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.pstn+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.sci+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.simservs+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.timestamp-token": {
        source: "iana"
      },
      "application/vnd.etsi.tsl+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.tsl.der": {
        source: "iana"
      },
      "application/vnd.eu.kasparian.car+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.eudora.data": {
        source: "iana"
      },
      "application/vnd.evolv.ecig.profile": {
        source: "iana"
      },
      "application/vnd.evolv.ecig.settings": {
        source: "iana"
      },
      "application/vnd.evolv.ecig.theme": {
        source: "iana"
      },
      "application/vnd.exstream-empower+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.exstream-package": {
        source: "iana"
      },
      "application/vnd.ezpix-album": {
        source: "iana",
        extensions: ["ez2"]
      },
      "application/vnd.ezpix-package": {
        source: "iana",
        extensions: ["ez3"]
      },
      "application/vnd.f-secure.mobile": {
        source: "iana"
      },
      "application/vnd.familysearch.gedcom+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.fastcopy-disk-image": {
        source: "iana"
      },
      "application/vnd.fdf": {
        source: "iana",
        extensions: ["fdf"]
      },
      "application/vnd.fdsn.mseed": {
        source: "iana",
        extensions: ["mseed"]
      },
      "application/vnd.fdsn.seed": {
        source: "iana",
        extensions: ["seed", "dataless"]
      },
      "application/vnd.ffsns": {
        source: "iana"
      },
      "application/vnd.ficlab.flb+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.filmit.zfc": {
        source: "iana"
      },
      "application/vnd.fints": {
        source: "iana"
      },
      "application/vnd.firemonkeys.cloudcell": {
        source: "iana"
      },
      "application/vnd.flographit": {
        source: "iana",
        extensions: ["gph"]
      },
      "application/vnd.fluxtime.clip": {
        source: "iana",
        extensions: ["ftc"]
      },
      "application/vnd.font-fontforge-sfd": {
        source: "iana"
      },
      "application/vnd.framemaker": {
        source: "iana",
        extensions: ["fm", "frame", "maker", "book"]
      },
      "application/vnd.frogans.fnc": {
        source: "iana",
        extensions: ["fnc"]
      },
      "application/vnd.frogans.ltf": {
        source: "iana",
        extensions: ["ltf"]
      },
      "application/vnd.fsc.weblaunch": {
        source: "iana",
        extensions: ["fsc"]
      },
      "application/vnd.fujifilm.fb.docuworks": {
        source: "iana"
      },
      "application/vnd.fujifilm.fb.docuworks.binder": {
        source: "iana"
      },
      "application/vnd.fujifilm.fb.docuworks.container": {
        source: "iana"
      },
      "application/vnd.fujifilm.fb.jfi+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.fujitsu.oasys": {
        source: "iana",
        extensions: ["oas"]
      },
      "application/vnd.fujitsu.oasys2": {
        source: "iana",
        extensions: ["oa2"]
      },
      "application/vnd.fujitsu.oasys3": {
        source: "iana",
        extensions: ["oa3"]
      },
      "application/vnd.fujitsu.oasysgp": {
        source: "iana",
        extensions: ["fg5"]
      },
      "application/vnd.fujitsu.oasysprs": {
        source: "iana",
        extensions: ["bh2"]
      },
      "application/vnd.fujixerox.art-ex": {
        source: "iana"
      },
      "application/vnd.fujixerox.art4": {
        source: "iana"
      },
      "application/vnd.fujixerox.ddd": {
        source: "iana",
        extensions: ["ddd"]
      },
      "application/vnd.fujixerox.docuworks": {
        source: "iana",
        extensions: ["xdw"]
      },
      "application/vnd.fujixerox.docuworks.binder": {
        source: "iana",
        extensions: ["xbd"]
      },
      "application/vnd.fujixerox.docuworks.container": {
        source: "iana"
      },
      "application/vnd.fujixerox.hbpl": {
        source: "iana"
      },
      "application/vnd.fut-misnet": {
        source: "iana"
      },
      "application/vnd.futoin+cbor": {
        source: "iana"
      },
      "application/vnd.futoin+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.fuzzysheet": {
        source: "iana",
        extensions: ["fzs"]
      },
      "application/vnd.genomatix.tuxedo": {
        source: "iana",
        extensions: ["txd"]
      },
      "application/vnd.gentics.grd+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.geo+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.geocube+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.geogebra.file": {
        source: "iana",
        extensions: ["ggb"]
      },
      "application/vnd.geogebra.slides": {
        source: "iana"
      },
      "application/vnd.geogebra.tool": {
        source: "iana",
        extensions: ["ggt"]
      },
      "application/vnd.geometry-explorer": {
        source: "iana",
        extensions: ["gex", "gre"]
      },
      "application/vnd.geonext": {
        source: "iana",
        extensions: ["gxt"]
      },
      "application/vnd.geoplan": {
        source: "iana",
        extensions: ["g2w"]
      },
      "application/vnd.geospace": {
        source: "iana",
        extensions: ["g3w"]
      },
      "application/vnd.gerber": {
        source: "iana"
      },
      "application/vnd.globalplatform.card-content-mgt": {
        source: "iana"
      },
      "application/vnd.globalplatform.card-content-mgt-response": {
        source: "iana"
      },
      "application/vnd.gmx": {
        source: "iana",
        extensions: ["gmx"]
      },
      "application/vnd.google-apps.document": {
        compressible: false,
        extensions: ["gdoc"]
      },
      "application/vnd.google-apps.presentation": {
        compressible: false,
        extensions: ["gslides"]
      },
      "application/vnd.google-apps.spreadsheet": {
        compressible: false,
        extensions: ["gsheet"]
      },
      "application/vnd.google-earth.kml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["kml"]
      },
      "application/vnd.google-earth.kmz": {
        source: "iana",
        compressible: false,
        extensions: ["kmz"]
      },
      "application/vnd.gov.sk.e-form+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.gov.sk.e-form+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.gov.sk.xmldatacontainer+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.grafeq": {
        source: "iana",
        extensions: ["gqf", "gqs"]
      },
      "application/vnd.gridmp": {
        source: "iana"
      },
      "application/vnd.groove-account": {
        source: "iana",
        extensions: ["gac"]
      },
      "application/vnd.groove-help": {
        source: "iana",
        extensions: ["ghf"]
      },
      "application/vnd.groove-identity-message": {
        source: "iana",
        extensions: ["gim"]
      },
      "application/vnd.groove-injector": {
        source: "iana",
        extensions: ["grv"]
      },
      "application/vnd.groove-tool-message": {
        source: "iana",
        extensions: ["gtm"]
      },
      "application/vnd.groove-tool-template": {
        source: "iana",
        extensions: ["tpl"]
      },
      "application/vnd.groove-vcard": {
        source: "iana",
        extensions: ["vcg"]
      },
      "application/vnd.hal+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hal+xml": {
        source: "iana",
        compressible: true,
        extensions: ["hal"]
      },
      "application/vnd.handheld-entertainment+xml": {
        source: "iana",
        compressible: true,
        extensions: ["zmm"]
      },
      "application/vnd.hbci": {
        source: "iana",
        extensions: ["hbci"]
      },
      "application/vnd.hc+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hcl-bireports": {
        source: "iana"
      },
      "application/vnd.hdt": {
        source: "iana"
      },
      "application/vnd.heroku+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hhe.lesson-player": {
        source: "iana",
        extensions: ["les"]
      },
      "application/vnd.hl7cda+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.hl7v2+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.hp-hpgl": {
        source: "iana",
        extensions: ["hpgl"]
      },
      "application/vnd.hp-hpid": {
        source: "iana",
        extensions: ["hpid"]
      },
      "application/vnd.hp-hps": {
        source: "iana",
        extensions: ["hps"]
      },
      "application/vnd.hp-jlyt": {
        source: "iana",
        extensions: ["jlt"]
      },
      "application/vnd.hp-pcl": {
        source: "iana",
        extensions: ["pcl"]
      },
      "application/vnd.hp-pclxl": {
        source: "iana",
        extensions: ["pclxl"]
      },
      "application/vnd.httphone": {
        source: "iana"
      },
      "application/vnd.hydrostatix.sof-data": {
        source: "iana",
        extensions: ["sfd-hdstx"]
      },
      "application/vnd.hyper+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hyper-item+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hyperdrive+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hzn-3d-crossword": {
        source: "iana"
      },
      "application/vnd.ibm.afplinedata": {
        source: "iana"
      },
      "application/vnd.ibm.electronic-media": {
        source: "iana"
      },
      "application/vnd.ibm.minipay": {
        source: "iana",
        extensions: ["mpy"]
      },
      "application/vnd.ibm.modcap": {
        source: "iana",
        extensions: ["afp", "listafp", "list3820"]
      },
      "application/vnd.ibm.rights-management": {
        source: "iana",
        extensions: ["irm"]
      },
      "application/vnd.ibm.secure-container": {
        source: "iana",
        extensions: ["sc"]
      },
      "application/vnd.iccprofile": {
        source: "iana",
        extensions: ["icc", "icm"]
      },
      "application/vnd.ieee.1905": {
        source: "iana"
      },
      "application/vnd.igloader": {
        source: "iana",
        extensions: ["igl"]
      },
      "application/vnd.imagemeter.folder+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.imagemeter.image+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.immervision-ivp": {
        source: "iana",
        extensions: ["ivp"]
      },
      "application/vnd.immervision-ivu": {
        source: "iana",
        extensions: ["ivu"]
      },
      "application/vnd.ims.imsccv1p1": {
        source: "iana"
      },
      "application/vnd.ims.imsccv1p2": {
        source: "iana"
      },
      "application/vnd.ims.imsccv1p3": {
        source: "iana"
      },
      "application/vnd.ims.lis.v2.result+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolconsumerprofile+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolproxy+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolproxy.id+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolsettings+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolsettings.simple+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.informedcontrol.rms+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.informix-visionary": {
        source: "iana"
      },
      "application/vnd.infotech.project": {
        source: "iana"
      },
      "application/vnd.infotech.project+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.innopath.wamp.notification": {
        source: "iana"
      },
      "application/vnd.insors.igm": {
        source: "iana",
        extensions: ["igm"]
      },
      "application/vnd.intercon.formnet": {
        source: "iana",
        extensions: ["xpw", "xpx"]
      },
      "application/vnd.intergeo": {
        source: "iana",
        extensions: ["i2g"]
      },
      "application/vnd.intertrust.digibox": {
        source: "iana"
      },
      "application/vnd.intertrust.nncp": {
        source: "iana"
      },
      "application/vnd.intu.qbo": {
        source: "iana",
        extensions: ["qbo"]
      },
      "application/vnd.intu.qfx": {
        source: "iana",
        extensions: ["qfx"]
      },
      "application/vnd.iptc.g2.catalogitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.conceptitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.knowledgeitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.newsitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.newsmessage+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.packageitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.planningitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ipunplugged.rcprofile": {
        source: "iana",
        extensions: ["rcprofile"]
      },
      "application/vnd.irepository.package+xml": {
        source: "iana",
        compressible: true,
        extensions: ["irp"]
      },
      "application/vnd.is-xpr": {
        source: "iana",
        extensions: ["xpr"]
      },
      "application/vnd.isac.fcs": {
        source: "iana",
        extensions: ["fcs"]
      },
      "application/vnd.iso11783-10+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.jam": {
        source: "iana",
        extensions: ["jam"]
      },
      "application/vnd.japannet-directory-service": {
        source: "iana"
      },
      "application/vnd.japannet-jpnstore-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-payment-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-registration": {
        source: "iana"
      },
      "application/vnd.japannet-registration-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-setstore-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-verification": {
        source: "iana"
      },
      "application/vnd.japannet-verification-wakeup": {
        source: "iana"
      },
      "application/vnd.jcp.javame.midlet-rms": {
        source: "iana",
        extensions: ["rms"]
      },
      "application/vnd.jisp": {
        source: "iana",
        extensions: ["jisp"]
      },
      "application/vnd.joost.joda-archive": {
        source: "iana",
        extensions: ["joda"]
      },
      "application/vnd.jsk.isdn-ngn": {
        source: "iana"
      },
      "application/vnd.kahootz": {
        source: "iana",
        extensions: ["ktz", "ktr"]
      },
      "application/vnd.kde.karbon": {
        source: "iana",
        extensions: ["karbon"]
      },
      "application/vnd.kde.kchart": {
        source: "iana",
        extensions: ["chrt"]
      },
      "application/vnd.kde.kformula": {
        source: "iana",
        extensions: ["kfo"]
      },
      "application/vnd.kde.kivio": {
        source: "iana",
        extensions: ["flw"]
      },
      "application/vnd.kde.kontour": {
        source: "iana",
        extensions: ["kon"]
      },
      "application/vnd.kde.kpresenter": {
        source: "iana",
        extensions: ["kpr", "kpt"]
      },
      "application/vnd.kde.kspread": {
        source: "iana",
        extensions: ["ksp"]
      },
      "application/vnd.kde.kword": {
        source: "iana",
        extensions: ["kwd", "kwt"]
      },
      "application/vnd.kenameaapp": {
        source: "iana",
        extensions: ["htke"]
      },
      "application/vnd.kidspiration": {
        source: "iana",
        extensions: ["kia"]
      },
      "application/vnd.kinar": {
        source: "iana",
        extensions: ["kne", "knp"]
      },
      "application/vnd.koan": {
        source: "iana",
        extensions: ["skp", "skd", "skt", "skm"]
      },
      "application/vnd.kodak-descriptor": {
        source: "iana",
        extensions: ["sse"]
      },
      "application/vnd.las": {
        source: "iana"
      },
      "application/vnd.las.las+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.las.las+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lasxml"]
      },
      "application/vnd.laszip": {
        source: "iana"
      },
      "application/vnd.leap+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.liberty-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.llamagraphics.life-balance.desktop": {
        source: "iana",
        extensions: ["lbd"]
      },
      "application/vnd.llamagraphics.life-balance.exchange+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lbe"]
      },
      "application/vnd.logipipe.circuit+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.loom": {
        source: "iana"
      },
      "application/vnd.lotus-1-2-3": {
        source: "iana",
        extensions: ["123"]
      },
      "application/vnd.lotus-approach": {
        source: "iana",
        extensions: ["apr"]
      },
      "application/vnd.lotus-freelance": {
        source: "iana",
        extensions: ["pre"]
      },
      "application/vnd.lotus-notes": {
        source: "iana",
        extensions: ["nsf"]
      },
      "application/vnd.lotus-organizer": {
        source: "iana",
        extensions: ["org"]
      },
      "application/vnd.lotus-screencam": {
        source: "iana",
        extensions: ["scm"]
      },
      "application/vnd.lotus-wordpro": {
        source: "iana",
        extensions: ["lwp"]
      },
      "application/vnd.macports.portpkg": {
        source: "iana",
        extensions: ["portpkg"]
      },
      "application/vnd.mapbox-vector-tile": {
        source: "iana",
        extensions: ["mvt"]
      },
      "application/vnd.marlin.drm.actiontoken+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.marlin.drm.conftoken+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.marlin.drm.license+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.marlin.drm.mdcf": {
        source: "iana"
      },
      "application/vnd.mason+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.maxar.archive.3tz+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.maxmind.maxmind-db": {
        source: "iana"
      },
      "application/vnd.mcd": {
        source: "iana",
        extensions: ["mcd"]
      },
      "application/vnd.medcalcdata": {
        source: "iana",
        extensions: ["mc1"]
      },
      "application/vnd.mediastation.cdkey": {
        source: "iana",
        extensions: ["cdkey"]
      },
      "application/vnd.meridian-slingshot": {
        source: "iana"
      },
      "application/vnd.mfer": {
        source: "iana",
        extensions: ["mwf"]
      },
      "application/vnd.mfmp": {
        source: "iana",
        extensions: ["mfm"]
      },
      "application/vnd.micro+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.micrografx.flo": {
        source: "iana",
        extensions: ["flo"]
      },
      "application/vnd.micrografx.igx": {
        source: "iana",
        extensions: ["igx"]
      },
      "application/vnd.microsoft.portable-executable": {
        source: "iana"
      },
      "application/vnd.microsoft.windows.thumbnail-cache": {
        source: "iana"
      },
      "application/vnd.miele+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.mif": {
        source: "iana",
        extensions: ["mif"]
      },
      "application/vnd.minisoft-hp3000-save": {
        source: "iana"
      },
      "application/vnd.mitsubishi.misty-guard.trustweb": {
        source: "iana"
      },
      "application/vnd.mobius.daf": {
        source: "iana",
        extensions: ["daf"]
      },
      "application/vnd.mobius.dis": {
        source: "iana",
        extensions: ["dis"]
      },
      "application/vnd.mobius.mbk": {
        source: "iana",
        extensions: ["mbk"]
      },
      "application/vnd.mobius.mqy": {
        source: "iana",
        extensions: ["mqy"]
      },
      "application/vnd.mobius.msl": {
        source: "iana",
        extensions: ["msl"]
      },
      "application/vnd.mobius.plc": {
        source: "iana",
        extensions: ["plc"]
      },
      "application/vnd.mobius.txf": {
        source: "iana",
        extensions: ["txf"]
      },
      "application/vnd.mophun.application": {
        source: "iana",
        extensions: ["mpn"]
      },
      "application/vnd.mophun.certificate": {
        source: "iana",
        extensions: ["mpc"]
      },
      "application/vnd.motorola.flexsuite": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.adsi": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.fis": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.gotap": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.kmr": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.ttc": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.wem": {
        source: "iana"
      },
      "application/vnd.motorola.iprm": {
        source: "iana"
      },
      "application/vnd.mozilla.xul+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xul"]
      },
      "application/vnd.ms-3mfdocument": {
        source: "iana"
      },
      "application/vnd.ms-artgalry": {
        source: "iana",
        extensions: ["cil"]
      },
      "application/vnd.ms-asf": {
        source: "iana"
      },
      "application/vnd.ms-cab-compressed": {
        source: "iana",
        extensions: ["cab"]
      },
      "application/vnd.ms-color.iccprofile": {
        source: "apache"
      },
      "application/vnd.ms-excel": {
        source: "iana",
        compressible: false,
        extensions: ["xls", "xlm", "xla", "xlc", "xlt", "xlw"]
      },
      "application/vnd.ms-excel.addin.macroenabled.12": {
        source: "iana",
        extensions: ["xlam"]
      },
      "application/vnd.ms-excel.sheet.binary.macroenabled.12": {
        source: "iana",
        extensions: ["xlsb"]
      },
      "application/vnd.ms-excel.sheet.macroenabled.12": {
        source: "iana",
        extensions: ["xlsm"]
      },
      "application/vnd.ms-excel.template.macroenabled.12": {
        source: "iana",
        extensions: ["xltm"]
      },
      "application/vnd.ms-fontobject": {
        source: "iana",
        compressible: true,
        extensions: ["eot"]
      },
      "application/vnd.ms-htmlhelp": {
        source: "iana",
        extensions: ["chm"]
      },
      "application/vnd.ms-ims": {
        source: "iana",
        extensions: ["ims"]
      },
      "application/vnd.ms-lrm": {
        source: "iana",
        extensions: ["lrm"]
      },
      "application/vnd.ms-office.activex+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-officetheme": {
        source: "iana",
        extensions: ["thmx"]
      },
      "application/vnd.ms-opentype": {
        source: "apache",
        compressible: true
      },
      "application/vnd.ms-outlook": {
        compressible: false,
        extensions: ["msg"]
      },
      "application/vnd.ms-package.obfuscated-opentype": {
        source: "apache"
      },
      "application/vnd.ms-pki.seccat": {
        source: "apache",
        extensions: ["cat"]
      },
      "application/vnd.ms-pki.stl": {
        source: "apache",
        extensions: ["stl"]
      },
      "application/vnd.ms-playready.initiator+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-powerpoint": {
        source: "iana",
        compressible: false,
        extensions: ["ppt", "pps", "pot"]
      },
      "application/vnd.ms-powerpoint.addin.macroenabled.12": {
        source: "iana",
        extensions: ["ppam"]
      },
      "application/vnd.ms-powerpoint.presentation.macroenabled.12": {
        source: "iana",
        extensions: ["pptm"]
      },
      "application/vnd.ms-powerpoint.slide.macroenabled.12": {
        source: "iana",
        extensions: ["sldm"]
      },
      "application/vnd.ms-powerpoint.slideshow.macroenabled.12": {
        source: "iana",
        extensions: ["ppsm"]
      },
      "application/vnd.ms-powerpoint.template.macroenabled.12": {
        source: "iana",
        extensions: ["potm"]
      },
      "application/vnd.ms-printdevicecapabilities+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-printing.printticket+xml": {
        source: "apache",
        compressible: true
      },
      "application/vnd.ms-printschematicket+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-project": {
        source: "iana",
        extensions: ["mpp", "mpt"]
      },
      "application/vnd.ms-tnef": {
        source: "iana"
      },
      "application/vnd.ms-windows.devicepairing": {
        source: "iana"
      },
      "application/vnd.ms-windows.nwprinting.oob": {
        source: "iana"
      },
      "application/vnd.ms-windows.printerpairing": {
        source: "iana"
      },
      "application/vnd.ms-windows.wsd.oob": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.lic-chlg-req": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.lic-resp": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.meter-chlg-req": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.meter-resp": {
        source: "iana"
      },
      "application/vnd.ms-word.document.macroenabled.12": {
        source: "iana",
        extensions: ["docm"]
      },
      "application/vnd.ms-word.template.macroenabled.12": {
        source: "iana",
        extensions: ["dotm"]
      },
      "application/vnd.ms-works": {
        source: "iana",
        extensions: ["wps", "wks", "wcm", "wdb"]
      },
      "application/vnd.ms-wpl": {
        source: "iana",
        extensions: ["wpl"]
      },
      "application/vnd.ms-xpsdocument": {
        source: "iana",
        compressible: false,
        extensions: ["xps"]
      },
      "application/vnd.msa-disk-image": {
        source: "iana"
      },
      "application/vnd.mseq": {
        source: "iana",
        extensions: ["mseq"]
      },
      "application/vnd.msign": {
        source: "iana"
      },
      "application/vnd.multiad.creator": {
        source: "iana"
      },
      "application/vnd.multiad.creator.cif": {
        source: "iana"
      },
      "application/vnd.music-niff": {
        source: "iana"
      },
      "application/vnd.musician": {
        source: "iana",
        extensions: ["mus"]
      },
      "application/vnd.muvee.style": {
        source: "iana",
        extensions: ["msty"]
      },
      "application/vnd.mynfc": {
        source: "iana",
        extensions: ["taglet"]
      },
      "application/vnd.nacamar.ybrid+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ncd.control": {
        source: "iana"
      },
      "application/vnd.ncd.reference": {
        source: "iana"
      },
      "application/vnd.nearst.inv+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nebumind.line": {
        source: "iana"
      },
      "application/vnd.nervana": {
        source: "iana"
      },
      "application/vnd.netfpx": {
        source: "iana"
      },
      "application/vnd.neurolanguage.nlu": {
        source: "iana",
        extensions: ["nlu"]
      },
      "application/vnd.nimn": {
        source: "iana"
      },
      "application/vnd.nintendo.nitro.rom": {
        source: "iana"
      },
      "application/vnd.nintendo.snes.rom": {
        source: "iana"
      },
      "application/vnd.nitf": {
        source: "iana",
        extensions: ["ntf", "nitf"]
      },
      "application/vnd.noblenet-directory": {
        source: "iana",
        extensions: ["nnd"]
      },
      "application/vnd.noblenet-sealer": {
        source: "iana",
        extensions: ["nns"]
      },
      "application/vnd.noblenet-web": {
        source: "iana",
        extensions: ["nnw"]
      },
      "application/vnd.nokia.catalogs": {
        source: "iana"
      },
      "application/vnd.nokia.conml+wbxml": {
        source: "iana"
      },
      "application/vnd.nokia.conml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.iptv.config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.isds-radio-presets": {
        source: "iana"
      },
      "application/vnd.nokia.landmark+wbxml": {
        source: "iana"
      },
      "application/vnd.nokia.landmark+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.landmarkcollection+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.n-gage.ac+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ac"]
      },
      "application/vnd.nokia.n-gage.data": {
        source: "iana",
        extensions: ["ngdat"]
      },
      "application/vnd.nokia.n-gage.symbian.install": {
        source: "iana",
        extensions: ["n-gage"]
      },
      "application/vnd.nokia.ncd": {
        source: "iana"
      },
      "application/vnd.nokia.pcd+wbxml": {
        source: "iana"
      },
      "application/vnd.nokia.pcd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.radio-preset": {
        source: "iana",
        extensions: ["rpst"]
      },
      "application/vnd.nokia.radio-presets": {
        source: "iana",
        extensions: ["rpss"]
      },
      "application/vnd.novadigm.edm": {
        source: "iana",
        extensions: ["edm"]
      },
      "application/vnd.novadigm.edx": {
        source: "iana",
        extensions: ["edx"]
      },
      "application/vnd.novadigm.ext": {
        source: "iana",
        extensions: ["ext"]
      },
      "application/vnd.ntt-local.content-share": {
        source: "iana"
      },
      "application/vnd.ntt-local.file-transfer": {
        source: "iana"
      },
      "application/vnd.ntt-local.ogw_remote-access": {
        source: "iana"
      },
      "application/vnd.ntt-local.sip-ta_remote": {
        source: "iana"
      },
      "application/vnd.ntt-local.sip-ta_tcp_stream": {
        source: "iana"
      },
      "application/vnd.oasis.opendocument.chart": {
        source: "iana",
        extensions: ["odc"]
      },
      "application/vnd.oasis.opendocument.chart-template": {
        source: "iana",
        extensions: ["otc"]
      },
      "application/vnd.oasis.opendocument.database": {
        source: "iana",
        extensions: ["odb"]
      },
      "application/vnd.oasis.opendocument.formula": {
        source: "iana",
        extensions: ["odf"]
      },
      "application/vnd.oasis.opendocument.formula-template": {
        source: "iana",
        extensions: ["odft"]
      },
      "application/vnd.oasis.opendocument.graphics": {
        source: "iana",
        compressible: false,
        extensions: ["odg"]
      },
      "application/vnd.oasis.opendocument.graphics-template": {
        source: "iana",
        extensions: ["otg"]
      },
      "application/vnd.oasis.opendocument.image": {
        source: "iana",
        extensions: ["odi"]
      },
      "application/vnd.oasis.opendocument.image-template": {
        source: "iana",
        extensions: ["oti"]
      },
      "application/vnd.oasis.opendocument.presentation": {
        source: "iana",
        compressible: false,
        extensions: ["odp"]
      },
      "application/vnd.oasis.opendocument.presentation-template": {
        source: "iana",
        extensions: ["otp"]
      },
      "application/vnd.oasis.opendocument.spreadsheet": {
        source: "iana",
        compressible: false,
        extensions: ["ods"]
      },
      "application/vnd.oasis.opendocument.spreadsheet-template": {
        source: "iana",
        extensions: ["ots"]
      },
      "application/vnd.oasis.opendocument.text": {
        source: "iana",
        compressible: false,
        extensions: ["odt"]
      },
      "application/vnd.oasis.opendocument.text-master": {
        source: "iana",
        extensions: ["odm"]
      },
      "application/vnd.oasis.opendocument.text-template": {
        source: "iana",
        extensions: ["ott"]
      },
      "application/vnd.oasis.opendocument.text-web": {
        source: "iana",
        extensions: ["oth"]
      },
      "application/vnd.obn": {
        source: "iana"
      },
      "application/vnd.ocf+cbor": {
        source: "iana"
      },
      "application/vnd.oci.image.manifest.v1+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oftn.l10n+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.contentaccessdownload+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.contentaccessstreaming+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.cspg-hexbinary": {
        source: "iana"
      },
      "application/vnd.oipf.dae.svg+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.dae.xhtml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.mippvcontrolmessage+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.pae.gem": {
        source: "iana"
      },
      "application/vnd.oipf.spdiscovery+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.spdlist+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.ueprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.userprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.olpc-sugar": {
        source: "iana",
        extensions: ["xo"]
      },
      "application/vnd.oma-scws-config": {
        source: "iana"
      },
      "application/vnd.oma-scws-http-request": {
        source: "iana"
      },
      "application/vnd.oma-scws-http-response": {
        source: "iana"
      },
      "application/vnd.oma.bcast.associated-procedure-parameter+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.drm-trigger+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.imd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.ltkm": {
        source: "iana"
      },
      "application/vnd.oma.bcast.notification+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.provisioningtrigger": {
        source: "iana"
      },
      "application/vnd.oma.bcast.sgboot": {
        source: "iana"
      },
      "application/vnd.oma.bcast.sgdd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.sgdu": {
        source: "iana"
      },
      "application/vnd.oma.bcast.simple-symbol-container": {
        source: "iana"
      },
      "application/vnd.oma.bcast.smartcard-trigger+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.sprov+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.stkm": {
        source: "iana"
      },
      "application/vnd.oma.cab-address-book+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-feature-handler+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-pcc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-subs-invite+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-user-prefs+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.dcd": {
        source: "iana"
      },
      "application/vnd.oma.dcdc": {
        source: "iana"
      },
      "application/vnd.oma.dd2+xml": {
        source: "iana",
        compressible: true,
        extensions: ["dd2"]
      },
      "application/vnd.oma.drm.risd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.group-usage-list+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.lwm2m+cbor": {
        source: "iana"
      },
      "application/vnd.oma.lwm2m+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.lwm2m+tlv": {
        source: "iana"
      },
      "application/vnd.oma.pal+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.detailed-progress-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.final-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.groups+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.invocation-descriptor+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.optimized-progress-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.push": {
        source: "iana"
      },
      "application/vnd.oma.scidm.messages+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.xcap-directory+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.omads-email+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.omads-file+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.omads-folder+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.omaloc-supl-init": {
        source: "iana"
      },
      "application/vnd.onepager": {
        source: "iana"
      },
      "application/vnd.onepagertamp": {
        source: "iana"
      },
      "application/vnd.onepagertamx": {
        source: "iana"
      },
      "application/vnd.onepagertat": {
        source: "iana"
      },
      "application/vnd.onepagertatp": {
        source: "iana"
      },
      "application/vnd.onepagertatx": {
        source: "iana"
      },
      "application/vnd.openblox.game+xml": {
        source: "iana",
        compressible: true,
        extensions: ["obgx"]
      },
      "application/vnd.openblox.game-binary": {
        source: "iana"
      },
      "application/vnd.openeye.oeb": {
        source: "iana"
      },
      "application/vnd.openofficeorg.extension": {
        source: "apache",
        extensions: ["oxt"]
      },
      "application/vnd.openstreetmap.data+xml": {
        source: "iana",
        compressible: true,
        extensions: ["osm"]
      },
      "application/vnd.opentimestamps.ots": {
        source: "iana"
      },
      "application/vnd.openxmlformats-officedocument.custom-properties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.customxmlproperties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawing+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.chart+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.extended-properties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.comments+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.presentation": {
        source: "iana",
        compressible: false,
        extensions: ["pptx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.presprops+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slide": {
        source: "iana",
        extensions: ["sldx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slide+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slideshow": {
        source: "iana",
        extensions: ["ppsx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.tags+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.template": {
        source: "iana",
        extensions: ["potx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.template.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": {
        source: "iana",
        compressible: false,
        extensions: ["xlsx"]
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.template": {
        source: "iana",
        extensions: ["xltx"]
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.theme+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.themeoverride+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.vmldrawing": {
        source: "iana"
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document": {
        source: "iana",
        compressible: false,
        extensions: ["docx"]
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.template": {
        source: "iana",
        extensions: ["dotx"]
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-package.core-properties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-package.relationships+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oracle.resource+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.orange.indata": {
        source: "iana"
      },
      "application/vnd.osa.netdeploy": {
        source: "iana"
      },
      "application/vnd.osgeo.mapguide.package": {
        source: "iana",
        extensions: ["mgp"]
      },
      "application/vnd.osgi.bundle": {
        source: "iana"
      },
      "application/vnd.osgi.dp": {
        source: "iana",
        extensions: ["dp"]
      },
      "application/vnd.osgi.subsystem": {
        source: "iana",
        extensions: ["esa"]
      },
      "application/vnd.otps.ct-kip+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oxli.countgraph": {
        source: "iana"
      },
      "application/vnd.pagerduty+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.palm": {
        source: "iana",
        extensions: ["pdb", "pqa", "oprc"]
      },
      "application/vnd.panoply": {
        source: "iana"
      },
      "application/vnd.paos.xml": {
        source: "iana"
      },
      "application/vnd.patentdive": {
        source: "iana"
      },
      "application/vnd.patientecommsdoc": {
        source: "iana"
      },
      "application/vnd.pawaafile": {
        source: "iana",
        extensions: ["paw"]
      },
      "application/vnd.pcos": {
        source: "iana"
      },
      "application/vnd.pg.format": {
        source: "iana",
        extensions: ["str"]
      },
      "application/vnd.pg.osasli": {
        source: "iana",
        extensions: ["ei6"]
      },
      "application/vnd.piaccess.application-licence": {
        source: "iana"
      },
      "application/vnd.picsel": {
        source: "iana",
        extensions: ["efif"]
      },
      "application/vnd.pmi.widget": {
        source: "iana",
        extensions: ["wg"]
      },
      "application/vnd.poc.group-advertisement+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.pocketlearn": {
        source: "iana",
        extensions: ["plf"]
      },
      "application/vnd.powerbuilder6": {
        source: "iana",
        extensions: ["pbd"]
      },
      "application/vnd.powerbuilder6-s": {
        source: "iana"
      },
      "application/vnd.powerbuilder7": {
        source: "iana"
      },
      "application/vnd.powerbuilder7-s": {
        source: "iana"
      },
      "application/vnd.powerbuilder75": {
        source: "iana"
      },
      "application/vnd.powerbuilder75-s": {
        source: "iana"
      },
      "application/vnd.preminet": {
        source: "iana"
      },
      "application/vnd.previewsystems.box": {
        source: "iana",
        extensions: ["box"]
      },
      "application/vnd.proteus.magazine": {
        source: "iana",
        extensions: ["mgz"]
      },
      "application/vnd.psfs": {
        source: "iana"
      },
      "application/vnd.publishare-delta-tree": {
        source: "iana",
        extensions: ["qps"]
      },
      "application/vnd.pvi.ptid1": {
        source: "iana",
        extensions: ["ptid"]
      },
      "application/vnd.pwg-multiplexed": {
        source: "iana"
      },
      "application/vnd.pwg-xhtml-print+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.qualcomm.brew-app-res": {
        source: "iana"
      },
      "application/vnd.quarantainenet": {
        source: "iana"
      },
      "application/vnd.quark.quarkxpress": {
        source: "iana",
        extensions: ["qxd", "qxt", "qwd", "qwt", "qxl", "qxb"]
      },
      "application/vnd.quobject-quoxdocument": {
        source: "iana"
      },
      "application/vnd.radisys.moml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-conf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-conn+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-dialog+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-stream+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-conf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-base+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-fax-detect+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-fax-sendrecv+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-group+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-speech+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-transform+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.rainstor.data": {
        source: "iana"
      },
      "application/vnd.rapid": {
        source: "iana"
      },
      "application/vnd.rar": {
        source: "iana",
        extensions: ["rar"]
      },
      "application/vnd.realvnc.bed": {
        source: "iana",
        extensions: ["bed"]
      },
      "application/vnd.recordare.musicxml": {
        source: "iana",
        extensions: ["mxl"]
      },
      "application/vnd.recordare.musicxml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["musicxml"]
      },
      "application/vnd.renlearn.rlprint": {
        source: "iana"
      },
      "application/vnd.resilient.logic": {
        source: "iana"
      },
      "application/vnd.restful+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.rig.cryptonote": {
        source: "iana",
        extensions: ["cryptonote"]
      },
      "application/vnd.rim.cod": {
        source: "apache",
        extensions: ["cod"]
      },
      "application/vnd.rn-realmedia": {
        source: "apache",
        extensions: ["rm"]
      },
      "application/vnd.rn-realmedia-vbr": {
        source: "apache",
        extensions: ["rmvb"]
      },
      "application/vnd.route66.link66+xml": {
        source: "iana",
        compressible: true,
        extensions: ["link66"]
      },
      "application/vnd.rs-274x": {
        source: "iana"
      },
      "application/vnd.ruckus.download": {
        source: "iana"
      },
      "application/vnd.s3sms": {
        source: "iana"
      },
      "application/vnd.sailingtracker.track": {
        source: "iana",
        extensions: ["st"]
      },
      "application/vnd.sar": {
        source: "iana"
      },
      "application/vnd.sbm.cid": {
        source: "iana"
      },
      "application/vnd.sbm.mid2": {
        source: "iana"
      },
      "application/vnd.scribus": {
        source: "iana"
      },
      "application/vnd.sealed.3df": {
        source: "iana"
      },
      "application/vnd.sealed.csf": {
        source: "iana"
      },
      "application/vnd.sealed.doc": {
        source: "iana"
      },
      "application/vnd.sealed.eml": {
        source: "iana"
      },
      "application/vnd.sealed.mht": {
        source: "iana"
      },
      "application/vnd.sealed.net": {
        source: "iana"
      },
      "application/vnd.sealed.ppt": {
        source: "iana"
      },
      "application/vnd.sealed.tiff": {
        source: "iana"
      },
      "application/vnd.sealed.xls": {
        source: "iana"
      },
      "application/vnd.sealedmedia.softseal.html": {
        source: "iana"
      },
      "application/vnd.sealedmedia.softseal.pdf": {
        source: "iana"
      },
      "application/vnd.seemail": {
        source: "iana",
        extensions: ["see"]
      },
      "application/vnd.seis+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.sema": {
        source: "iana",
        extensions: ["sema"]
      },
      "application/vnd.semd": {
        source: "iana",
        extensions: ["semd"]
      },
      "application/vnd.semf": {
        source: "iana",
        extensions: ["semf"]
      },
      "application/vnd.shade-save-file": {
        source: "iana"
      },
      "application/vnd.shana.informed.formdata": {
        source: "iana",
        extensions: ["ifm"]
      },
      "application/vnd.shana.informed.formtemplate": {
        source: "iana",
        extensions: ["itp"]
      },
      "application/vnd.shana.informed.interchange": {
        source: "iana",
        extensions: ["iif"]
      },
      "application/vnd.shana.informed.package": {
        source: "iana",
        extensions: ["ipk"]
      },
      "application/vnd.shootproof+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.shopkick+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.shp": {
        source: "iana"
      },
      "application/vnd.shx": {
        source: "iana"
      },
      "application/vnd.sigrok.session": {
        source: "iana"
      },
      "application/vnd.simtech-mindmapper": {
        source: "iana",
        extensions: ["twd", "twds"]
      },
      "application/vnd.siren+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.smaf": {
        source: "iana",
        extensions: ["mmf"]
      },
      "application/vnd.smart.notebook": {
        source: "iana"
      },
      "application/vnd.smart.teacher": {
        source: "iana",
        extensions: ["teacher"]
      },
      "application/vnd.snesdev-page-table": {
        source: "iana"
      },
      "application/vnd.software602.filler.form+xml": {
        source: "iana",
        compressible: true,
        extensions: ["fo"]
      },
      "application/vnd.software602.filler.form-xml-zip": {
        source: "iana"
      },
      "application/vnd.solent.sdkm+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sdkm", "sdkd"]
      },
      "application/vnd.spotfire.dxp": {
        source: "iana",
        extensions: ["dxp"]
      },
      "application/vnd.spotfire.sfs": {
        source: "iana",
        extensions: ["sfs"]
      },
      "application/vnd.sqlite3": {
        source: "iana"
      },
      "application/vnd.sss-cod": {
        source: "iana"
      },
      "application/vnd.sss-dtf": {
        source: "iana"
      },
      "application/vnd.sss-ntf": {
        source: "iana"
      },
      "application/vnd.stardivision.calc": {
        source: "apache",
        extensions: ["sdc"]
      },
      "application/vnd.stardivision.draw": {
        source: "apache",
        extensions: ["sda"]
      },
      "application/vnd.stardivision.impress": {
        source: "apache",
        extensions: ["sdd"]
      },
      "application/vnd.stardivision.math": {
        source: "apache",
        extensions: ["smf"]
      },
      "application/vnd.stardivision.writer": {
        source: "apache",
        extensions: ["sdw", "vor"]
      },
      "application/vnd.stardivision.writer-global": {
        source: "apache",
        extensions: ["sgl"]
      },
      "application/vnd.stepmania.package": {
        source: "iana",
        extensions: ["smzip"]
      },
      "application/vnd.stepmania.stepchart": {
        source: "iana",
        extensions: ["sm"]
      },
      "application/vnd.street-stream": {
        source: "iana"
      },
      "application/vnd.sun.wadl+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wadl"]
      },
      "application/vnd.sun.xml.calc": {
        source: "apache",
        extensions: ["sxc"]
      },
      "application/vnd.sun.xml.calc.template": {
        source: "apache",
        extensions: ["stc"]
      },
      "application/vnd.sun.xml.draw": {
        source: "apache",
        extensions: ["sxd"]
      },
      "application/vnd.sun.xml.draw.template": {
        source: "apache",
        extensions: ["std"]
      },
      "application/vnd.sun.xml.impress": {
        source: "apache",
        extensions: ["sxi"]
      },
      "application/vnd.sun.xml.impress.template": {
        source: "apache",
        extensions: ["sti"]
      },
      "application/vnd.sun.xml.math": {
        source: "apache",
        extensions: ["sxm"]
      },
      "application/vnd.sun.xml.writer": {
        source: "apache",
        extensions: ["sxw"]
      },
      "application/vnd.sun.xml.writer.global": {
        source: "apache",
        extensions: ["sxg"]
      },
      "application/vnd.sun.xml.writer.template": {
        source: "apache",
        extensions: ["stw"]
      },
      "application/vnd.sus-calendar": {
        source: "iana",
        extensions: ["sus", "susp"]
      },
      "application/vnd.svd": {
        source: "iana",
        extensions: ["svd"]
      },
      "application/vnd.swiftview-ics": {
        source: "iana"
      },
      "application/vnd.sycle+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.syft+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.symbian.install": {
        source: "apache",
        extensions: ["sis", "sisx"]
      },
      "application/vnd.syncml+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["xsm"]
      },
      "application/vnd.syncml.dm+wbxml": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["bdm"]
      },
      "application/vnd.syncml.dm+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["xdm"]
      },
      "application/vnd.syncml.dm.notification": {
        source: "iana"
      },
      "application/vnd.syncml.dmddf+wbxml": {
        source: "iana"
      },
      "application/vnd.syncml.dmddf+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["ddf"]
      },
      "application/vnd.syncml.dmtnds+wbxml": {
        source: "iana"
      },
      "application/vnd.syncml.dmtnds+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.syncml.ds.notification": {
        source: "iana"
      },
      "application/vnd.tableschema+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.tao.intent-module-archive": {
        source: "iana",
        extensions: ["tao"]
      },
      "application/vnd.tcpdump.pcap": {
        source: "iana",
        extensions: ["pcap", "cap", "dmp"]
      },
      "application/vnd.think-cell.ppttc+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.tmd.mediaflex.api+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.tml": {
        source: "iana"
      },
      "application/vnd.tmobile-livetv": {
        source: "iana",
        extensions: ["tmo"]
      },
      "application/vnd.tri.onesource": {
        source: "iana"
      },
      "application/vnd.trid.tpt": {
        source: "iana",
        extensions: ["tpt"]
      },
      "application/vnd.triscape.mxs": {
        source: "iana",
        extensions: ["mxs"]
      },
      "application/vnd.trueapp": {
        source: "iana",
        extensions: ["tra"]
      },
      "application/vnd.truedoc": {
        source: "iana"
      },
      "application/vnd.ubisoft.webplayer": {
        source: "iana"
      },
      "application/vnd.ufdl": {
        source: "iana",
        extensions: ["ufd", "ufdl"]
      },
      "application/vnd.uiq.theme": {
        source: "iana",
        extensions: ["utz"]
      },
      "application/vnd.umajin": {
        source: "iana",
        extensions: ["umj"]
      },
      "application/vnd.unity": {
        source: "iana",
        extensions: ["unityweb"]
      },
      "application/vnd.uoml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["uoml"]
      },
      "application/vnd.uplanet.alert": {
        source: "iana"
      },
      "application/vnd.uplanet.alert-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.bearer-choice": {
        source: "iana"
      },
      "application/vnd.uplanet.bearer-choice-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.cacheop": {
        source: "iana"
      },
      "application/vnd.uplanet.cacheop-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.channel": {
        source: "iana"
      },
      "application/vnd.uplanet.channel-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.list": {
        source: "iana"
      },
      "application/vnd.uplanet.list-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.listcmd": {
        source: "iana"
      },
      "application/vnd.uplanet.listcmd-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.signal": {
        source: "iana"
      },
      "application/vnd.uri-map": {
        source: "iana"
      },
      "application/vnd.valve.source.material": {
        source: "iana"
      },
      "application/vnd.vcx": {
        source: "iana",
        extensions: ["vcx"]
      },
      "application/vnd.vd-study": {
        source: "iana"
      },
      "application/vnd.vectorworks": {
        source: "iana"
      },
      "application/vnd.vel+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.verimatrix.vcas": {
        source: "iana"
      },
      "application/vnd.veritone.aion+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.veryant.thin": {
        source: "iana"
      },
      "application/vnd.ves.encrypted": {
        source: "iana"
      },
      "application/vnd.vidsoft.vidconference": {
        source: "iana"
      },
      "application/vnd.visio": {
        source: "iana",
        extensions: ["vsd", "vst", "vss", "vsw"]
      },
      "application/vnd.visionary": {
        source: "iana",
        extensions: ["vis"]
      },
      "application/vnd.vividence.scriptfile": {
        source: "iana"
      },
      "application/vnd.vsf": {
        source: "iana",
        extensions: ["vsf"]
      },
      "application/vnd.wap.sic": {
        source: "iana"
      },
      "application/vnd.wap.slc": {
        source: "iana"
      },
      "application/vnd.wap.wbxml": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["wbxml"]
      },
      "application/vnd.wap.wmlc": {
        source: "iana",
        extensions: ["wmlc"]
      },
      "application/vnd.wap.wmlscriptc": {
        source: "iana",
        extensions: ["wmlsc"]
      },
      "application/vnd.webturbo": {
        source: "iana",
        extensions: ["wtb"]
      },
      "application/vnd.wfa.dpp": {
        source: "iana"
      },
      "application/vnd.wfa.p2p": {
        source: "iana"
      },
      "application/vnd.wfa.wsc": {
        source: "iana"
      },
      "application/vnd.windows.devicepairing": {
        source: "iana"
      },
      "application/vnd.wmc": {
        source: "iana"
      },
      "application/vnd.wmf.bootstrap": {
        source: "iana"
      },
      "application/vnd.wolfram.mathematica": {
        source: "iana"
      },
      "application/vnd.wolfram.mathematica.package": {
        source: "iana"
      },
      "application/vnd.wolfram.player": {
        source: "iana",
        extensions: ["nbp"]
      },
      "application/vnd.wordperfect": {
        source: "iana",
        extensions: ["wpd"]
      },
      "application/vnd.wqd": {
        source: "iana",
        extensions: ["wqd"]
      },
      "application/vnd.wrq-hp3000-labelled": {
        source: "iana"
      },
      "application/vnd.wt.stf": {
        source: "iana",
        extensions: ["stf"]
      },
      "application/vnd.wv.csp+wbxml": {
        source: "iana"
      },
      "application/vnd.wv.csp+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.wv.ssp+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.xacml+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.xara": {
        source: "iana",
        extensions: ["xar"]
      },
      "application/vnd.xfdl": {
        source: "iana",
        extensions: ["xfdl"]
      },
      "application/vnd.xfdl.webform": {
        source: "iana"
      },
      "application/vnd.xmi+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.xmpie.cpkg": {
        source: "iana"
      },
      "application/vnd.xmpie.dpkg": {
        source: "iana"
      },
      "application/vnd.xmpie.plan": {
        source: "iana"
      },
      "application/vnd.xmpie.ppkg": {
        source: "iana"
      },
      "application/vnd.xmpie.xlim": {
        source: "iana"
      },
      "application/vnd.yamaha.hv-dic": {
        source: "iana",
        extensions: ["hvd"]
      },
      "application/vnd.yamaha.hv-script": {
        source: "iana",
        extensions: ["hvs"]
      },
      "application/vnd.yamaha.hv-voice": {
        source: "iana",
        extensions: ["hvp"]
      },
      "application/vnd.yamaha.openscoreformat": {
        source: "iana",
        extensions: ["osf"]
      },
      "application/vnd.yamaha.openscoreformat.osfpvg+xml": {
        source: "iana",
        compressible: true,
        extensions: ["osfpvg"]
      },
      "application/vnd.yamaha.remote-setup": {
        source: "iana"
      },
      "application/vnd.yamaha.smaf-audio": {
        source: "iana",
        extensions: ["saf"]
      },
      "application/vnd.yamaha.smaf-phrase": {
        source: "iana",
        extensions: ["spf"]
      },
      "application/vnd.yamaha.through-ngn": {
        source: "iana"
      },
      "application/vnd.yamaha.tunnel-udpencap": {
        source: "iana"
      },
      "application/vnd.yaoweme": {
        source: "iana"
      },
      "application/vnd.yellowriver-custom-menu": {
        source: "iana",
        extensions: ["cmp"]
      },
      "application/vnd.youtube.yt": {
        source: "iana"
      },
      "application/vnd.zul": {
        source: "iana",
        extensions: ["zir", "zirz"]
      },
      "application/vnd.zzazz.deck+xml": {
        source: "iana",
        compressible: true,
        extensions: ["zaz"]
      },
      "application/voicexml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["vxml"]
      },
      "application/voucher-cms+json": {
        source: "iana",
        compressible: true
      },
      "application/vq-rtcpxr": {
        source: "iana"
      },
      "application/wasm": {
        source: "iana",
        compressible: true,
        extensions: ["wasm"]
      },
      "application/watcherinfo+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wif"]
      },
      "application/webpush-options+json": {
        source: "iana",
        compressible: true
      },
      "application/whoispp-query": {
        source: "iana"
      },
      "application/whoispp-response": {
        source: "iana"
      },
      "application/widget": {
        source: "iana",
        extensions: ["wgt"]
      },
      "application/winhlp": {
        source: "apache",
        extensions: ["hlp"]
      },
      "application/wita": {
        source: "iana"
      },
      "application/wordperfect5.1": {
        source: "iana"
      },
      "application/wsdl+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wsdl"]
      },
      "application/wspolicy+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wspolicy"]
      },
      "application/x-7z-compressed": {
        source: "apache",
        compressible: false,
        extensions: ["7z"]
      },
      "application/x-abiword": {
        source: "apache",
        extensions: ["abw"]
      },
      "application/x-ace-compressed": {
        source: "apache",
        extensions: ["ace"]
      },
      "application/x-amf": {
        source: "apache"
      },
      "application/x-apple-diskimage": {
        source: "apache",
        extensions: ["dmg"]
      },
      "application/x-arj": {
        compressible: false,
        extensions: ["arj"]
      },
      "application/x-authorware-bin": {
        source: "apache",
        extensions: ["aab", "x32", "u32", "vox"]
      },
      "application/x-authorware-map": {
        source: "apache",
        extensions: ["aam"]
      },
      "application/x-authorware-seg": {
        source: "apache",
        extensions: ["aas"]
      },
      "application/x-bcpio": {
        source: "apache",
        extensions: ["bcpio"]
      },
      "application/x-bdoc": {
        compressible: false,
        extensions: ["bdoc"]
      },
      "application/x-bittorrent": {
        source: "apache",
        extensions: ["torrent"]
      },
      "application/x-blorb": {
        source: "apache",
        extensions: ["blb", "blorb"]
      },
      "application/x-bzip": {
        source: "apache",
        compressible: false,
        extensions: ["bz"]
      },
      "application/x-bzip2": {
        source: "apache",
        compressible: false,
        extensions: ["bz2", "boz"]
      },
      "application/x-cbr": {
        source: "apache",
        extensions: ["cbr", "cba", "cbt", "cbz", "cb7"]
      },
      "application/x-cdlink": {
        source: "apache",
        extensions: ["vcd"]
      },
      "application/x-cfs-compressed": {
        source: "apache",
        extensions: ["cfs"]
      },
      "application/x-chat": {
        source: "apache",
        extensions: ["chat"]
      },
      "application/x-chess-pgn": {
        source: "apache",
        extensions: ["pgn"]
      },
      "application/x-chrome-extension": {
        extensions: ["crx"]
      },
      "application/x-cocoa": {
        source: "nginx",
        extensions: ["cco"]
      },
      "application/x-compress": {
        source: "apache"
      },
      "application/x-conference": {
        source: "apache",
        extensions: ["nsc"]
      },
      "application/x-cpio": {
        source: "apache",
        extensions: ["cpio"]
      },
      "application/x-csh": {
        source: "apache",
        extensions: ["csh"]
      },
      "application/x-deb": {
        compressible: false
      },
      "application/x-debian-package": {
        source: "apache",
        extensions: ["deb", "udeb"]
      },
      "application/x-dgc-compressed": {
        source: "apache",
        extensions: ["dgc"]
      },
      "application/x-director": {
        source: "apache",
        extensions: ["dir", "dcr", "dxr", "cst", "cct", "cxt", "w3d", "fgd", "swa"]
      },
      "application/x-doom": {
        source: "apache",
        extensions: ["wad"]
      },
      "application/x-dtbncx+xml": {
        source: "apache",
        compressible: true,
        extensions: ["ncx"]
      },
      "application/x-dtbook+xml": {
        source: "apache",
        compressible: true,
        extensions: ["dtb"]
      },
      "application/x-dtbresource+xml": {
        source: "apache",
        compressible: true,
        extensions: ["res"]
      },
      "application/x-dvi": {
        source: "apache",
        compressible: false,
        extensions: ["dvi"]
      },
      "application/x-envoy": {
        source: "apache",
        extensions: ["evy"]
      },
      "application/x-eva": {
        source: "apache",
        extensions: ["eva"]
      },
      "application/x-font-bdf": {
        source: "apache",
        extensions: ["bdf"]
      },
      "application/x-font-dos": {
        source: "apache"
      },
      "application/x-font-framemaker": {
        source: "apache"
      },
      "application/x-font-ghostscript": {
        source: "apache",
        extensions: ["gsf"]
      },
      "application/x-font-libgrx": {
        source: "apache"
      },
      "application/x-font-linux-psf": {
        source: "apache",
        extensions: ["psf"]
      },
      "application/x-font-pcf": {
        source: "apache",
        extensions: ["pcf"]
      },
      "application/x-font-snf": {
        source: "apache",
        extensions: ["snf"]
      },
      "application/x-font-speedo": {
        source: "apache"
      },
      "application/x-font-sunos-news": {
        source: "apache"
      },
      "application/x-font-type1": {
        source: "apache",
        extensions: ["pfa", "pfb", "pfm", "afm"]
      },
      "application/x-font-vfont": {
        source: "apache"
      },
      "application/x-freearc": {
        source: "apache",
        extensions: ["arc"]
      },
      "application/x-futuresplash": {
        source: "apache",
        extensions: ["spl"]
      },
      "application/x-gca-compressed": {
        source: "apache",
        extensions: ["gca"]
      },
      "application/x-glulx": {
        source: "apache",
        extensions: ["ulx"]
      },
      "application/x-gnumeric": {
        source: "apache",
        extensions: ["gnumeric"]
      },
      "application/x-gramps-xml": {
        source: "apache",
        extensions: ["gramps"]
      },
      "application/x-gtar": {
        source: "apache",
        extensions: ["gtar"]
      },
      "application/x-gzip": {
        source: "apache"
      },
      "application/x-hdf": {
        source: "apache",
        extensions: ["hdf"]
      },
      "application/x-httpd-php": {
        compressible: true,
        extensions: ["php"]
      },
      "application/x-install-instructions": {
        source: "apache",
        extensions: ["install"]
      },
      "application/x-iso9660-image": {
        source: "apache",
        extensions: ["iso"]
      },
      "application/x-iwork-keynote-sffkey": {
        extensions: ["key"]
      },
      "application/x-iwork-numbers-sffnumbers": {
        extensions: ["numbers"]
      },
      "application/x-iwork-pages-sffpages": {
        extensions: ["pages"]
      },
      "application/x-java-archive-diff": {
        source: "nginx",
        extensions: ["jardiff"]
      },
      "application/x-java-jnlp-file": {
        source: "apache",
        compressible: false,
        extensions: ["jnlp"]
      },
      "application/x-javascript": {
        compressible: true
      },
      "application/x-keepass2": {
        extensions: ["kdbx"]
      },
      "application/x-latex": {
        source: "apache",
        compressible: false,
        extensions: ["latex"]
      },
      "application/x-lua-bytecode": {
        extensions: ["luac"]
      },
      "application/x-lzh-compressed": {
        source: "apache",
        extensions: ["lzh", "lha"]
      },
      "application/x-makeself": {
        source: "nginx",
        extensions: ["run"]
      },
      "application/x-mie": {
        source: "apache",
        extensions: ["mie"]
      },
      "application/x-mobipocket-ebook": {
        source: "apache",
        extensions: ["prc", "mobi"]
      },
      "application/x-mpegurl": {
        compressible: false
      },
      "application/x-ms-application": {
        source: "apache",
        extensions: ["application"]
      },
      "application/x-ms-shortcut": {
        source: "apache",
        extensions: ["lnk"]
      },
      "application/x-ms-wmd": {
        source: "apache",
        extensions: ["wmd"]
      },
      "application/x-ms-wmz": {
        source: "apache",
        extensions: ["wmz"]
      },
      "application/x-ms-xbap": {
        source: "apache",
        extensions: ["xbap"]
      },
      "application/x-msaccess": {
        source: "apache",
        extensions: ["mdb"]
      },
      "application/x-msbinder": {
        source: "apache",
        extensions: ["obd"]
      },
      "application/x-mscardfile": {
        source: "apache",
        extensions: ["crd"]
      },
      "application/x-msclip": {
        source: "apache",
        extensions: ["clp"]
      },
      "application/x-msdos-program": {
        extensions: ["exe"]
      },
      "application/x-msdownload": {
        source: "apache",
        extensions: ["exe", "dll", "com", "bat", "msi"]
      },
      "application/x-msmediaview": {
        source: "apache",
        extensions: ["mvb", "m13", "m14"]
      },
      "application/x-msmetafile": {
        source: "apache",
        extensions: ["wmf", "wmz", "emf", "emz"]
      },
      "application/x-msmoney": {
        source: "apache",
        extensions: ["mny"]
      },
      "application/x-mspublisher": {
        source: "apache",
        extensions: ["pub"]
      },
      "application/x-msschedule": {
        source: "apache",
        extensions: ["scd"]
      },
      "application/x-msterminal": {
        source: "apache",
        extensions: ["trm"]
      },
      "application/x-mswrite": {
        source: "apache",
        extensions: ["wri"]
      },
      "application/x-netcdf": {
        source: "apache",
        extensions: ["nc", "cdf"]
      },
      "application/x-ns-proxy-autoconfig": {
        compressible: true,
        extensions: ["pac"]
      },
      "application/x-nzb": {
        source: "apache",
        extensions: ["nzb"]
      },
      "application/x-perl": {
        source: "nginx",
        extensions: ["pl", "pm"]
      },
      "application/x-pilot": {
        source: "nginx",
        extensions: ["prc", "pdb"]
      },
      "application/x-pkcs12": {
        source: "apache",
        compressible: false,
        extensions: ["p12", "pfx"]
      },
      "application/x-pkcs7-certificates": {
        source: "apache",
        extensions: ["p7b", "spc"]
      },
      "application/x-pkcs7-certreqresp": {
        source: "apache",
        extensions: ["p7r"]
      },
      "application/x-pki-message": {
        source: "iana"
      },
      "application/x-rar-compressed": {
        source: "apache",
        compressible: false,
        extensions: ["rar"]
      },
      "application/x-redhat-package-manager": {
        source: "nginx",
        extensions: ["rpm"]
      },
      "application/x-research-info-systems": {
        source: "apache",
        extensions: ["ris"]
      },
      "application/x-sea": {
        source: "nginx",
        extensions: ["sea"]
      },
      "application/x-sh": {
        source: "apache",
        compressible: true,
        extensions: ["sh"]
      },
      "application/x-shar": {
        source: "apache",
        extensions: ["shar"]
      },
      "application/x-shockwave-flash": {
        source: "apache",
        compressible: false,
        extensions: ["swf"]
      },
      "application/x-silverlight-app": {
        source: "apache",
        extensions: ["xap"]
      },
      "application/x-sql": {
        source: "apache",
        extensions: ["sql"]
      },
      "application/x-stuffit": {
        source: "apache",
        compressible: false,
        extensions: ["sit"]
      },
      "application/x-stuffitx": {
        source: "apache",
        extensions: ["sitx"]
      },
      "application/x-subrip": {
        source: "apache",
        extensions: ["srt"]
      },
      "application/x-sv4cpio": {
        source: "apache",
        extensions: ["sv4cpio"]
      },
      "application/x-sv4crc": {
        source: "apache",
        extensions: ["sv4crc"]
      },
      "application/x-t3vm-image": {
        source: "apache",
        extensions: ["t3"]
      },
      "application/x-tads": {
        source: "apache",
        extensions: ["gam"]
      },
      "application/x-tar": {
        source: "apache",
        compressible: true,
        extensions: ["tar"]
      },
      "application/x-tcl": {
        source: "apache",
        extensions: ["tcl", "tk"]
      },
      "application/x-tex": {
        source: "apache",
        extensions: ["tex"]
      },
      "application/x-tex-tfm": {
        source: "apache",
        extensions: ["tfm"]
      },
      "application/x-texinfo": {
        source: "apache",
        extensions: ["texinfo", "texi"]
      },
      "application/x-tgif": {
        source: "apache",
        extensions: ["obj"]
      },
      "application/x-ustar": {
        source: "apache",
        extensions: ["ustar"]
      },
      "application/x-virtualbox-hdd": {
        compressible: true,
        extensions: ["hdd"]
      },
      "application/x-virtualbox-ova": {
        compressible: true,
        extensions: ["ova"]
      },
      "application/x-virtualbox-ovf": {
        compressible: true,
        extensions: ["ovf"]
      },
      "application/x-virtualbox-vbox": {
        compressible: true,
        extensions: ["vbox"]
      },
      "application/x-virtualbox-vbox-extpack": {
        compressible: false,
        extensions: ["vbox-extpack"]
      },
      "application/x-virtualbox-vdi": {
        compressible: true,
        extensions: ["vdi"]
      },
      "application/x-virtualbox-vhd": {
        compressible: true,
        extensions: ["vhd"]
      },
      "application/x-virtualbox-vmdk": {
        compressible: true,
        extensions: ["vmdk"]
      },
      "application/x-wais-source": {
        source: "apache",
        extensions: ["src"]
      },
      "application/x-web-app-manifest+json": {
        compressible: true,
        extensions: ["webapp"]
      },
      "application/x-www-form-urlencoded": {
        source: "iana",
        compressible: true
      },
      "application/x-x509-ca-cert": {
        source: "iana",
        extensions: ["der", "crt", "pem"]
      },
      "application/x-x509-ca-ra-cert": {
        source: "iana"
      },
      "application/x-x509-next-ca-cert": {
        source: "iana"
      },
      "application/x-xfig": {
        source: "apache",
        extensions: ["fig"]
      },
      "application/x-xliff+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xlf"]
      },
      "application/x-xpinstall": {
        source: "apache",
        compressible: false,
        extensions: ["xpi"]
      },
      "application/x-xz": {
        source: "apache",
        extensions: ["xz"]
      },
      "application/x-zmachine": {
        source: "apache",
        extensions: ["z1", "z2", "z3", "z4", "z5", "z6", "z7", "z8"]
      },
      "application/x400-bp": {
        source: "iana"
      },
      "application/xacml+xml": {
        source: "iana",
        compressible: true
      },
      "application/xaml+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xaml"]
      },
      "application/xcap-att+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xav"]
      },
      "application/xcap-caps+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xca"]
      },
      "application/xcap-diff+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xdf"]
      },
      "application/xcap-el+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xel"]
      },
      "application/xcap-error+xml": {
        source: "iana",
        compressible: true
      },
      "application/xcap-ns+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xns"]
      },
      "application/xcon-conference-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/xcon-conference-info-diff+xml": {
        source: "iana",
        compressible: true
      },
      "application/xenc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xenc"]
      },
      "application/xhtml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xhtml", "xht"]
      },
      "application/xhtml-voice+xml": {
        source: "apache",
        compressible: true
      },
      "application/xliff+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xlf"]
      },
      "application/xml": {
        source: "iana",
        compressible: true,
        extensions: ["xml", "xsl", "xsd", "rng"]
      },
      "application/xml-dtd": {
        source: "iana",
        compressible: true,
        extensions: ["dtd"]
      },
      "application/xml-external-parsed-entity": {
        source: "iana"
      },
      "application/xml-patch+xml": {
        source: "iana",
        compressible: true
      },
      "application/xmpp+xml": {
        source: "iana",
        compressible: true
      },
      "application/xop+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xop"]
      },
      "application/xproc+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xpl"]
      },
      "application/xslt+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xsl", "xslt"]
      },
      "application/xspf+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xspf"]
      },
      "application/xv+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mxml", "xhvml", "xvml", "xvm"]
      },
      "application/yang": {
        source: "iana",
        extensions: ["yang"]
      },
      "application/yang-data+json": {
        source: "iana",
        compressible: true
      },
      "application/yang-data+xml": {
        source: "iana",
        compressible: true
      },
      "application/yang-patch+json": {
        source: "iana",
        compressible: true
      },
      "application/yang-patch+xml": {
        source: "iana",
        compressible: true
      },
      "application/yin+xml": {
        source: "iana",
        compressible: true,
        extensions: ["yin"]
      },
      "application/zip": {
        source: "iana",
        compressible: false,
        extensions: ["zip"]
      },
      "application/zlib": {
        source: "iana"
      },
      "application/zstd": {
        source: "iana"
      },
      "audio/1d-interleaved-parityfec": {
        source: "iana"
      },
      "audio/32kadpcm": {
        source: "iana"
      },
      "audio/3gpp": {
        source: "iana",
        compressible: false,
        extensions: ["3gpp"]
      },
      "audio/3gpp2": {
        source: "iana"
      },
      "audio/aac": {
        source: "iana"
      },
      "audio/ac3": {
        source: "iana"
      },
      "audio/adpcm": {
        source: "apache",
        extensions: ["adp"]
      },
      "audio/amr": {
        source: "iana",
        extensions: ["amr"]
      },
      "audio/amr-wb": {
        source: "iana"
      },
      "audio/amr-wb+": {
        source: "iana"
      },
      "audio/aptx": {
        source: "iana"
      },
      "audio/asc": {
        source: "iana"
      },
      "audio/atrac-advanced-lossless": {
        source: "iana"
      },
      "audio/atrac-x": {
        source: "iana"
      },
      "audio/atrac3": {
        source: "iana"
      },
      "audio/basic": {
        source: "iana",
        compressible: false,
        extensions: ["au", "snd"]
      },
      "audio/bv16": {
        source: "iana"
      },
      "audio/bv32": {
        source: "iana"
      },
      "audio/clearmode": {
        source: "iana"
      },
      "audio/cn": {
        source: "iana"
      },
      "audio/dat12": {
        source: "iana"
      },
      "audio/dls": {
        source: "iana"
      },
      "audio/dsr-es201108": {
        source: "iana"
      },
      "audio/dsr-es202050": {
        source: "iana"
      },
      "audio/dsr-es202211": {
        source: "iana"
      },
      "audio/dsr-es202212": {
        source: "iana"
      },
      "audio/dv": {
        source: "iana"
      },
      "audio/dvi4": {
        source: "iana"
      },
      "audio/eac3": {
        source: "iana"
      },
      "audio/encaprtp": {
        source: "iana"
      },
      "audio/evrc": {
        source: "iana"
      },
      "audio/evrc-qcp": {
        source: "iana"
      },
      "audio/evrc0": {
        source: "iana"
      },
      "audio/evrc1": {
        source: "iana"
      },
      "audio/evrcb": {
        source: "iana"
      },
      "audio/evrcb0": {
        source: "iana"
      },
      "audio/evrcb1": {
        source: "iana"
      },
      "audio/evrcnw": {
        source: "iana"
      },
      "audio/evrcnw0": {
        source: "iana"
      },
      "audio/evrcnw1": {
        source: "iana"
      },
      "audio/evrcwb": {
        source: "iana"
      },
      "audio/evrcwb0": {
        source: "iana"
      },
      "audio/evrcwb1": {
        source: "iana"
      },
      "audio/evs": {
        source: "iana"
      },
      "audio/flexfec": {
        source: "iana"
      },
      "audio/fwdred": {
        source: "iana"
      },
      "audio/g711-0": {
        source: "iana"
      },
      "audio/g719": {
        source: "iana"
      },
      "audio/g722": {
        source: "iana"
      },
      "audio/g7221": {
        source: "iana"
      },
      "audio/g723": {
        source: "iana"
      },
      "audio/g726-16": {
        source: "iana"
      },
      "audio/g726-24": {
        source: "iana"
      },
      "audio/g726-32": {
        source: "iana"
      },
      "audio/g726-40": {
        source: "iana"
      },
      "audio/g728": {
        source: "iana"
      },
      "audio/g729": {
        source: "iana"
      },
      "audio/g7291": {
        source: "iana"
      },
      "audio/g729d": {
        source: "iana"
      },
      "audio/g729e": {
        source: "iana"
      },
      "audio/gsm": {
        source: "iana"
      },
      "audio/gsm-efr": {
        source: "iana"
      },
      "audio/gsm-hr-08": {
        source: "iana"
      },
      "audio/ilbc": {
        source: "iana"
      },
      "audio/ip-mr_v2.5": {
        source: "iana"
      },
      "audio/isac": {
        source: "apache"
      },
      "audio/l16": {
        source: "iana"
      },
      "audio/l20": {
        source: "iana"
      },
      "audio/l24": {
        source: "iana",
        compressible: false
      },
      "audio/l8": {
        source: "iana"
      },
      "audio/lpc": {
        source: "iana"
      },
      "audio/melp": {
        source: "iana"
      },
      "audio/melp1200": {
        source: "iana"
      },
      "audio/melp2400": {
        source: "iana"
      },
      "audio/melp600": {
        source: "iana"
      },
      "audio/mhas": {
        source: "iana"
      },
      "audio/midi": {
        source: "apache",
        extensions: ["mid", "midi", "kar", "rmi"]
      },
      "audio/mobile-xmf": {
        source: "iana",
        extensions: ["mxmf"]
      },
      "audio/mp3": {
        compressible: false,
        extensions: ["mp3"]
      },
      "audio/mp4": {
        source: "iana",
        compressible: false,
        extensions: ["m4a", "mp4a"]
      },
      "audio/mp4a-latm": {
        source: "iana"
      },
      "audio/mpa": {
        source: "iana"
      },
      "audio/mpa-robust": {
        source: "iana"
      },
      "audio/mpeg": {
        source: "iana",
        compressible: false,
        extensions: ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"]
      },
      "audio/mpeg4-generic": {
        source: "iana"
      },
      "audio/musepack": {
        source: "apache"
      },
      "audio/ogg": {
        source: "iana",
        compressible: false,
        extensions: ["oga", "ogg", "spx", "opus"]
      },
      "audio/opus": {
        source: "iana"
      },
      "audio/parityfec": {
        source: "iana"
      },
      "audio/pcma": {
        source: "iana"
      },
      "audio/pcma-wb": {
        source: "iana"
      },
      "audio/pcmu": {
        source: "iana"
      },
      "audio/pcmu-wb": {
        source: "iana"
      },
      "audio/prs.sid": {
        source: "iana"
      },
      "audio/qcelp": {
        source: "iana"
      },
      "audio/raptorfec": {
        source: "iana"
      },
      "audio/red": {
        source: "iana"
      },
      "audio/rtp-enc-aescm128": {
        source: "iana"
      },
      "audio/rtp-midi": {
        source: "iana"
      },
      "audio/rtploopback": {
        source: "iana"
      },
      "audio/rtx": {
        source: "iana"
      },
      "audio/s3m": {
        source: "apache",
        extensions: ["s3m"]
      },
      "audio/scip": {
        source: "iana"
      },
      "audio/silk": {
        source: "apache",
        extensions: ["sil"]
      },
      "audio/smv": {
        source: "iana"
      },
      "audio/smv-qcp": {
        source: "iana"
      },
      "audio/smv0": {
        source: "iana"
      },
      "audio/sofa": {
        source: "iana"
      },
      "audio/sp-midi": {
        source: "iana"
      },
      "audio/speex": {
        source: "iana"
      },
      "audio/t140c": {
        source: "iana"
      },
      "audio/t38": {
        source: "iana"
      },
      "audio/telephone-event": {
        source: "iana"
      },
      "audio/tetra_acelp": {
        source: "iana"
      },
      "audio/tetra_acelp_bb": {
        source: "iana"
      },
      "audio/tone": {
        source: "iana"
      },
      "audio/tsvcis": {
        source: "iana"
      },
      "audio/uemclip": {
        source: "iana"
      },
      "audio/ulpfec": {
        source: "iana"
      },
      "audio/usac": {
        source: "iana"
      },
      "audio/vdvi": {
        source: "iana"
      },
      "audio/vmr-wb": {
        source: "iana"
      },
      "audio/vnd.3gpp.iufp": {
        source: "iana"
      },
      "audio/vnd.4sb": {
        source: "iana"
      },
      "audio/vnd.audiokoz": {
        source: "iana"
      },
      "audio/vnd.celp": {
        source: "iana"
      },
      "audio/vnd.cisco.nse": {
        source: "iana"
      },
      "audio/vnd.cmles.radio-events": {
        source: "iana"
      },
      "audio/vnd.cns.anp1": {
        source: "iana"
      },
      "audio/vnd.cns.inf1": {
        source: "iana"
      },
      "audio/vnd.dece.audio": {
        source: "iana",
        extensions: ["uva", "uvva"]
      },
      "audio/vnd.digital-winds": {
        source: "iana",
        extensions: ["eol"]
      },
      "audio/vnd.dlna.adts": {
        source: "iana"
      },
      "audio/vnd.dolby.heaac.1": {
        source: "iana"
      },
      "audio/vnd.dolby.heaac.2": {
        source: "iana"
      },
      "audio/vnd.dolby.mlp": {
        source: "iana"
      },
      "audio/vnd.dolby.mps": {
        source: "iana"
      },
      "audio/vnd.dolby.pl2": {
        source: "iana"
      },
      "audio/vnd.dolby.pl2x": {
        source: "iana"
      },
      "audio/vnd.dolby.pl2z": {
        source: "iana"
      },
      "audio/vnd.dolby.pulse.1": {
        source: "iana"
      },
      "audio/vnd.dra": {
        source: "iana",
        extensions: ["dra"]
      },
      "audio/vnd.dts": {
        source: "iana",
        extensions: ["dts"]
      },
      "audio/vnd.dts.hd": {
        source: "iana",
        extensions: ["dtshd"]
      },
      "audio/vnd.dts.uhd": {
        source: "iana"
      },
      "audio/vnd.dvb.file": {
        source: "iana"
      },
      "audio/vnd.everad.plj": {
        source: "iana"
      },
      "audio/vnd.hns.audio": {
        source: "iana"
      },
      "audio/vnd.lucent.voice": {
        source: "iana",
        extensions: ["lvp"]
      },
      "audio/vnd.ms-playready.media.pya": {
        source: "iana",
        extensions: ["pya"]
      },
      "audio/vnd.nokia.mobile-xmf": {
        source: "iana"
      },
      "audio/vnd.nortel.vbk": {
        source: "iana"
      },
      "audio/vnd.nuera.ecelp4800": {
        source: "iana",
        extensions: ["ecelp4800"]
      },
      "audio/vnd.nuera.ecelp7470": {
        source: "iana",
        extensions: ["ecelp7470"]
      },
      "audio/vnd.nuera.ecelp9600": {
        source: "iana",
        extensions: ["ecelp9600"]
      },
      "audio/vnd.octel.sbc": {
        source: "iana"
      },
      "audio/vnd.presonus.multitrack": {
        source: "iana"
      },
      "audio/vnd.qcelp": {
        source: "iana"
      },
      "audio/vnd.rhetorex.32kadpcm": {
        source: "iana"
      },
      "audio/vnd.rip": {
        source: "iana",
        extensions: ["rip"]
      },
      "audio/vnd.rn-realaudio": {
        compressible: false
      },
      "audio/vnd.sealedmedia.softseal.mpeg": {
        source: "iana"
      },
      "audio/vnd.vmx.cvsd": {
        source: "iana"
      },
      "audio/vnd.wave": {
        compressible: false
      },
      "audio/vorbis": {
        source: "iana",
        compressible: false
      },
      "audio/vorbis-config": {
        source: "iana"
      },
      "audio/wav": {
        compressible: false,
        extensions: ["wav"]
      },
      "audio/wave": {
        compressible: false,
        extensions: ["wav"]
      },
      "audio/webm": {
        source: "apache",
        compressible: false,
        extensions: ["weba"]
      },
      "audio/x-aac": {
        source: "apache",
        compressible: false,
        extensions: ["aac"]
      },
      "audio/x-aiff": {
        source: "apache",
        extensions: ["aif", "aiff", "aifc"]
      },
      "audio/x-caf": {
        source: "apache",
        compressible: false,
        extensions: ["caf"]
      },
      "audio/x-flac": {
        source: "apache",
        extensions: ["flac"]
      },
      "audio/x-m4a": {
        source: "nginx",
        extensions: ["m4a"]
      },
      "audio/x-matroska": {
        source: "apache",
        extensions: ["mka"]
      },
      "audio/x-mpegurl": {
        source: "apache",
        extensions: ["m3u"]
      },
      "audio/x-ms-wax": {
        source: "apache",
        extensions: ["wax"]
      },
      "audio/x-ms-wma": {
        source: "apache",
        extensions: ["wma"]
      },
      "audio/x-pn-realaudio": {
        source: "apache",
        extensions: ["ram", "ra"]
      },
      "audio/x-pn-realaudio-plugin": {
        source: "apache",
        extensions: ["rmp"]
      },
      "audio/x-realaudio": {
        source: "nginx",
        extensions: ["ra"]
      },
      "audio/x-tta": {
        source: "apache"
      },
      "audio/x-wav": {
        source: "apache",
        extensions: ["wav"]
      },
      "audio/xm": {
        source: "apache",
        extensions: ["xm"]
      },
      "chemical/x-cdx": {
        source: "apache",
        extensions: ["cdx"]
      },
      "chemical/x-cif": {
        source: "apache",
        extensions: ["cif"]
      },
      "chemical/x-cmdf": {
        source: "apache",
        extensions: ["cmdf"]
      },
      "chemical/x-cml": {
        source: "apache",
        extensions: ["cml"]
      },
      "chemical/x-csml": {
        source: "apache",
        extensions: ["csml"]
      },
      "chemical/x-pdb": {
        source: "apache"
      },
      "chemical/x-xyz": {
        source: "apache",
        extensions: ["xyz"]
      },
      "font/collection": {
        source: "iana",
        extensions: ["ttc"]
      },
      "font/otf": {
        source: "iana",
        compressible: true,
        extensions: ["otf"]
      },
      "font/sfnt": {
        source: "iana"
      },
      "font/ttf": {
        source: "iana",
        compressible: true,
        extensions: ["ttf"]
      },
      "font/woff": {
        source: "iana",
        extensions: ["woff"]
      },
      "font/woff2": {
        source: "iana",
        extensions: ["woff2"]
      },
      "image/aces": {
        source: "iana",
        extensions: ["exr"]
      },
      "image/apng": {
        compressible: false,
        extensions: ["apng"]
      },
      "image/avci": {
        source: "iana",
        extensions: ["avci"]
      },
      "image/avcs": {
        source: "iana",
        extensions: ["avcs"]
      },
      "image/avif": {
        source: "iana",
        compressible: false,
        extensions: ["avif"]
      },
      "image/bmp": {
        source: "iana",
        compressible: true,
        extensions: ["bmp"]
      },
      "image/cgm": {
        source: "iana",
        extensions: ["cgm"]
      },
      "image/dicom-rle": {
        source: "iana",
        extensions: ["drle"]
      },
      "image/emf": {
        source: "iana",
        extensions: ["emf"]
      },
      "image/fits": {
        source: "iana",
        extensions: ["fits"]
      },
      "image/g3fax": {
        source: "iana",
        extensions: ["g3"]
      },
      "image/gif": {
        source: "iana",
        compressible: false,
        extensions: ["gif"]
      },
      "image/heic": {
        source: "iana",
        extensions: ["heic"]
      },
      "image/heic-sequence": {
        source: "iana",
        extensions: ["heics"]
      },
      "image/heif": {
        source: "iana",
        extensions: ["heif"]
      },
      "image/heif-sequence": {
        source: "iana",
        extensions: ["heifs"]
      },
      "image/hej2k": {
        source: "iana",
        extensions: ["hej2"]
      },
      "image/hsj2": {
        source: "iana",
        extensions: ["hsj2"]
      },
      "image/ief": {
        source: "iana",
        extensions: ["ief"]
      },
      "image/jls": {
        source: "iana",
        extensions: ["jls"]
      },
      "image/jp2": {
        source: "iana",
        compressible: false,
        extensions: ["jp2", "jpg2"]
      },
      "image/jpeg": {
        source: "iana",
        compressible: false,
        extensions: ["jpeg", "jpg", "jpe"]
      },
      "image/jph": {
        source: "iana",
        extensions: ["jph"]
      },
      "image/jphc": {
        source: "iana",
        extensions: ["jhc"]
      },
      "image/jpm": {
        source: "iana",
        compressible: false,
        extensions: ["jpm"]
      },
      "image/jpx": {
        source: "iana",
        compressible: false,
        extensions: ["jpx", "jpf"]
      },
      "image/jxr": {
        source: "iana",
        extensions: ["jxr"]
      },
      "image/jxra": {
        source: "iana",
        extensions: ["jxra"]
      },
      "image/jxrs": {
        source: "iana",
        extensions: ["jxrs"]
      },
      "image/jxs": {
        source: "iana",
        extensions: ["jxs"]
      },
      "image/jxsc": {
        source: "iana",
        extensions: ["jxsc"]
      },
      "image/jxsi": {
        source: "iana",
        extensions: ["jxsi"]
      },
      "image/jxss": {
        source: "iana",
        extensions: ["jxss"]
      },
      "image/ktx": {
        source: "iana",
        extensions: ["ktx"]
      },
      "image/ktx2": {
        source: "iana",
        extensions: ["ktx2"]
      },
      "image/naplps": {
        source: "iana"
      },
      "image/pjpeg": {
        compressible: false
      },
      "image/png": {
        source: "iana",
        compressible: false,
        extensions: ["png"]
      },
      "image/prs.btif": {
        source: "iana",
        extensions: ["btif"]
      },
      "image/prs.pti": {
        source: "iana",
        extensions: ["pti"]
      },
      "image/pwg-raster": {
        source: "iana"
      },
      "image/sgi": {
        source: "apache",
        extensions: ["sgi"]
      },
      "image/svg+xml": {
        source: "iana",
        compressible: true,
        extensions: ["svg", "svgz"]
      },
      "image/t38": {
        source: "iana",
        extensions: ["t38"]
      },
      "image/tiff": {
        source: "iana",
        compressible: false,
        extensions: ["tif", "tiff"]
      },
      "image/tiff-fx": {
        source: "iana",
        extensions: ["tfx"]
      },
      "image/vnd.adobe.photoshop": {
        source: "iana",
        compressible: true,
        extensions: ["psd"]
      },
      "image/vnd.airzip.accelerator.azv": {
        source: "iana",
        extensions: ["azv"]
      },
      "image/vnd.cns.inf2": {
        source: "iana"
      },
      "image/vnd.dece.graphic": {
        source: "iana",
        extensions: ["uvi", "uvvi", "uvg", "uvvg"]
      },
      "image/vnd.djvu": {
        source: "iana",
        extensions: ["djvu", "djv"]
      },
      "image/vnd.dvb.subtitle": {
        source: "iana",
        extensions: ["sub"]
      },
      "image/vnd.dwg": {
        source: "iana",
        extensions: ["dwg"]
      },
      "image/vnd.dxf": {
        source: "iana",
        extensions: ["dxf"]
      },
      "image/vnd.fastbidsheet": {
        source: "iana",
        extensions: ["fbs"]
      },
      "image/vnd.fpx": {
        source: "iana",
        extensions: ["fpx"]
      },
      "image/vnd.fst": {
        source: "iana",
        extensions: ["fst"]
      },
      "image/vnd.fujixerox.edmics-mmr": {
        source: "iana",
        extensions: ["mmr"]
      },
      "image/vnd.fujixerox.edmics-rlc": {
        source: "iana",
        extensions: ["rlc"]
      },
      "image/vnd.globalgraphics.pgb": {
        source: "iana"
      },
      "image/vnd.microsoft.icon": {
        source: "iana",
        compressible: true,
        extensions: ["ico"]
      },
      "image/vnd.mix": {
        source: "iana"
      },
      "image/vnd.mozilla.apng": {
        source: "iana"
      },
      "image/vnd.ms-dds": {
        compressible: true,
        extensions: ["dds"]
      },
      "image/vnd.ms-modi": {
        source: "iana",
        extensions: ["mdi"]
      },
      "image/vnd.ms-photo": {
        source: "apache",
        extensions: ["wdp"]
      },
      "image/vnd.net-fpx": {
        source: "iana",
        extensions: ["npx"]
      },
      "image/vnd.pco.b16": {
        source: "iana",
        extensions: ["b16"]
      },
      "image/vnd.radiance": {
        source: "iana"
      },
      "image/vnd.sealed.png": {
        source: "iana"
      },
      "image/vnd.sealedmedia.softseal.gif": {
        source: "iana"
      },
      "image/vnd.sealedmedia.softseal.jpg": {
        source: "iana"
      },
      "image/vnd.svf": {
        source: "iana"
      },
      "image/vnd.tencent.tap": {
        source: "iana",
        extensions: ["tap"]
      },
      "image/vnd.valve.source.texture": {
        source: "iana",
        extensions: ["vtf"]
      },
      "image/vnd.wap.wbmp": {
        source: "iana",
        extensions: ["wbmp"]
      },
      "image/vnd.xiff": {
        source: "iana",
        extensions: ["xif"]
      },
      "image/vnd.zbrush.pcx": {
        source: "iana",
        extensions: ["pcx"]
      },
      "image/webp": {
        source: "apache",
        extensions: ["webp"]
      },
      "image/wmf": {
        source: "iana",
        extensions: ["wmf"]
      },
      "image/x-3ds": {
        source: "apache",
        extensions: ["3ds"]
      },
      "image/x-cmu-raster": {
        source: "apache",
        extensions: ["ras"]
      },
      "image/x-cmx": {
        source: "apache",
        extensions: ["cmx"]
      },
      "image/x-freehand": {
        source: "apache",
        extensions: ["fh", "fhc", "fh4", "fh5", "fh7"]
      },
      "image/x-icon": {
        source: "apache",
        compressible: true,
        extensions: ["ico"]
      },
      "image/x-jng": {
        source: "nginx",
        extensions: ["jng"]
      },
      "image/x-mrsid-image": {
        source: "apache",
        extensions: ["sid"]
      },
      "image/x-ms-bmp": {
        source: "nginx",
        compressible: true,
        extensions: ["bmp"]
      },
      "image/x-pcx": {
        source: "apache",
        extensions: ["pcx"]
      },
      "image/x-pict": {
        source: "apache",
        extensions: ["pic", "pct"]
      },
      "image/x-portable-anymap": {
        source: "apache",
        extensions: ["pnm"]
      },
      "image/x-portable-bitmap": {
        source: "apache",
        extensions: ["pbm"]
      },
      "image/x-portable-graymap": {
        source: "apache",
        extensions: ["pgm"]
      },
      "image/x-portable-pixmap": {
        source: "apache",
        extensions: ["ppm"]
      },
      "image/x-rgb": {
        source: "apache",
        extensions: ["rgb"]
      },
      "image/x-tga": {
        source: "apache",
        extensions: ["tga"]
      },
      "image/x-xbitmap": {
        source: "apache",
        extensions: ["xbm"]
      },
      "image/x-xcf": {
        compressible: false
      },
      "image/x-xpixmap": {
        source: "apache",
        extensions: ["xpm"]
      },
      "image/x-xwindowdump": {
        source: "apache",
        extensions: ["xwd"]
      },
      "message/cpim": {
        source: "iana"
      },
      "message/delivery-status": {
        source: "iana"
      },
      "message/disposition-notification": {
        source: "iana",
        extensions: [
          "disposition-notification"
        ]
      },
      "message/external-body": {
        source: "iana"
      },
      "message/feedback-report": {
        source: "iana"
      },
      "message/global": {
        source: "iana",
        extensions: ["u8msg"]
      },
      "message/global-delivery-status": {
        source: "iana",
        extensions: ["u8dsn"]
      },
      "message/global-disposition-notification": {
        source: "iana",
        extensions: ["u8mdn"]
      },
      "message/global-headers": {
        source: "iana",
        extensions: ["u8hdr"]
      },
      "message/http": {
        source: "iana",
        compressible: false
      },
      "message/imdn+xml": {
        source: "iana",
        compressible: true
      },
      "message/news": {
        source: "iana"
      },
      "message/partial": {
        source: "iana",
        compressible: false
      },
      "message/rfc822": {
        source: "iana",
        compressible: true,
        extensions: ["eml", "mime"]
      },
      "message/s-http": {
        source: "iana"
      },
      "message/sip": {
        source: "iana"
      },
      "message/sipfrag": {
        source: "iana"
      },
      "message/tracking-status": {
        source: "iana"
      },
      "message/vnd.si.simp": {
        source: "iana"
      },
      "message/vnd.wfa.wsc": {
        source: "iana",
        extensions: ["wsc"]
      },
      "model/3mf": {
        source: "iana",
        extensions: ["3mf"]
      },
      "model/e57": {
        source: "iana"
      },
      "model/gltf+json": {
        source: "iana",
        compressible: true,
        extensions: ["gltf"]
      },
      "model/gltf-binary": {
        source: "iana",
        compressible: true,
        extensions: ["glb"]
      },
      "model/iges": {
        source: "iana",
        compressible: false,
        extensions: ["igs", "iges"]
      },
      "model/mesh": {
        source: "iana",
        compressible: false,
        extensions: ["msh", "mesh", "silo"]
      },
      "model/mtl": {
        source: "iana",
        extensions: ["mtl"]
      },
      "model/obj": {
        source: "iana",
        extensions: ["obj"]
      },
      "model/step": {
        source: "iana"
      },
      "model/step+xml": {
        source: "iana",
        compressible: true,
        extensions: ["stpx"]
      },
      "model/step+zip": {
        source: "iana",
        compressible: false,
        extensions: ["stpz"]
      },
      "model/step-xml+zip": {
        source: "iana",
        compressible: false,
        extensions: ["stpxz"]
      },
      "model/stl": {
        source: "iana",
        extensions: ["stl"]
      },
      "model/vnd.collada+xml": {
        source: "iana",
        compressible: true,
        extensions: ["dae"]
      },
      "model/vnd.dwf": {
        source: "iana",
        extensions: ["dwf"]
      },
      "model/vnd.flatland.3dml": {
        source: "iana"
      },
      "model/vnd.gdl": {
        source: "iana",
        extensions: ["gdl"]
      },
      "model/vnd.gs-gdl": {
        source: "apache"
      },
      "model/vnd.gs.gdl": {
        source: "iana"
      },
      "model/vnd.gtw": {
        source: "iana",
        extensions: ["gtw"]
      },
      "model/vnd.moml+xml": {
        source: "iana",
        compressible: true
      },
      "model/vnd.mts": {
        source: "iana",
        extensions: ["mts"]
      },
      "model/vnd.opengex": {
        source: "iana",
        extensions: ["ogex"]
      },
      "model/vnd.parasolid.transmit.binary": {
        source: "iana",
        extensions: ["x_b"]
      },
      "model/vnd.parasolid.transmit.text": {
        source: "iana",
        extensions: ["x_t"]
      },
      "model/vnd.pytha.pyox": {
        source: "iana"
      },
      "model/vnd.rosette.annotated-data-model": {
        source: "iana"
      },
      "model/vnd.sap.vds": {
        source: "iana",
        extensions: ["vds"]
      },
      "model/vnd.usdz+zip": {
        source: "iana",
        compressible: false,
        extensions: ["usdz"]
      },
      "model/vnd.valve.source.compiled-map": {
        source: "iana",
        extensions: ["bsp"]
      },
      "model/vnd.vtu": {
        source: "iana",
        extensions: ["vtu"]
      },
      "model/vrml": {
        source: "iana",
        compressible: false,
        extensions: ["wrl", "vrml"]
      },
      "model/x3d+binary": {
        source: "apache",
        compressible: false,
        extensions: ["x3db", "x3dbz"]
      },
      "model/x3d+fastinfoset": {
        source: "iana",
        extensions: ["x3db"]
      },
      "model/x3d+vrml": {
        source: "apache",
        compressible: false,
        extensions: ["x3dv", "x3dvz"]
      },
      "model/x3d+xml": {
        source: "iana",
        compressible: true,
        extensions: ["x3d", "x3dz"]
      },
      "model/x3d-vrml": {
        source: "iana",
        extensions: ["x3dv"]
      },
      "multipart/alternative": {
        source: "iana",
        compressible: false
      },
      "multipart/appledouble": {
        source: "iana"
      },
      "multipart/byteranges": {
        source: "iana"
      },
      "multipart/digest": {
        source: "iana"
      },
      "multipart/encrypted": {
        source: "iana",
        compressible: false
      },
      "multipart/form-data": {
        source: "iana",
        compressible: false
      },
      "multipart/header-set": {
        source: "iana"
      },
      "multipart/mixed": {
        source: "iana"
      },
      "multipart/multilingual": {
        source: "iana"
      },
      "multipart/parallel": {
        source: "iana"
      },
      "multipart/related": {
        source: "iana",
        compressible: false
      },
      "multipart/report": {
        source: "iana"
      },
      "multipart/signed": {
        source: "iana",
        compressible: false
      },
      "multipart/vnd.bint.med-plus": {
        source: "iana"
      },
      "multipart/voice-message": {
        source: "iana"
      },
      "multipart/x-mixed-replace": {
        source: "iana"
      },
      "text/1d-interleaved-parityfec": {
        source: "iana"
      },
      "text/cache-manifest": {
        source: "iana",
        compressible: true,
        extensions: ["appcache", "manifest"]
      },
      "text/calendar": {
        source: "iana",
        extensions: ["ics", "ifb"]
      },
      "text/calender": {
        compressible: true
      },
      "text/cmd": {
        compressible: true
      },
      "text/coffeescript": {
        extensions: ["coffee", "litcoffee"]
      },
      "text/cql": {
        source: "iana"
      },
      "text/cql-expression": {
        source: "iana"
      },
      "text/cql-identifier": {
        source: "iana"
      },
      "text/css": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["css"]
      },
      "text/csv": {
        source: "iana",
        compressible: true,
        extensions: ["csv"]
      },
      "text/csv-schema": {
        source: "iana"
      },
      "text/directory": {
        source: "iana"
      },
      "text/dns": {
        source: "iana"
      },
      "text/ecmascript": {
        source: "iana"
      },
      "text/encaprtp": {
        source: "iana"
      },
      "text/enriched": {
        source: "iana"
      },
      "text/fhirpath": {
        source: "iana"
      },
      "text/flexfec": {
        source: "iana"
      },
      "text/fwdred": {
        source: "iana"
      },
      "text/gff3": {
        source: "iana"
      },
      "text/grammar-ref-list": {
        source: "iana"
      },
      "text/html": {
        source: "iana",
        compressible: true,
        extensions: ["html", "htm", "shtml"]
      },
      "text/jade": {
        extensions: ["jade"]
      },
      "text/javascript": {
        source: "iana",
        compressible: true
      },
      "text/jcr-cnd": {
        source: "iana"
      },
      "text/jsx": {
        compressible: true,
        extensions: ["jsx"]
      },
      "text/less": {
        compressible: true,
        extensions: ["less"]
      },
      "text/markdown": {
        source: "iana",
        compressible: true,
        extensions: ["markdown", "md"]
      },
      "text/mathml": {
        source: "nginx",
        extensions: ["mml"]
      },
      "text/mdx": {
        compressible: true,
        extensions: ["mdx"]
      },
      "text/mizar": {
        source: "iana"
      },
      "text/n3": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["n3"]
      },
      "text/parameters": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/parityfec": {
        source: "iana"
      },
      "text/plain": {
        source: "iana",
        compressible: true,
        extensions: ["txt", "text", "conf", "def", "list", "log", "in", "ini"]
      },
      "text/provenance-notation": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/prs.fallenstein.rst": {
        source: "iana"
      },
      "text/prs.lines.tag": {
        source: "iana",
        extensions: ["dsc"]
      },
      "text/prs.prop.logic": {
        source: "iana"
      },
      "text/raptorfec": {
        source: "iana"
      },
      "text/red": {
        source: "iana"
      },
      "text/rfc822-headers": {
        source: "iana"
      },
      "text/richtext": {
        source: "iana",
        compressible: true,
        extensions: ["rtx"]
      },
      "text/rtf": {
        source: "iana",
        compressible: true,
        extensions: ["rtf"]
      },
      "text/rtp-enc-aescm128": {
        source: "iana"
      },
      "text/rtploopback": {
        source: "iana"
      },
      "text/rtx": {
        source: "iana"
      },
      "text/sgml": {
        source: "iana",
        extensions: ["sgml", "sgm"]
      },
      "text/shaclc": {
        source: "iana"
      },
      "text/shex": {
        source: "iana",
        extensions: ["shex"]
      },
      "text/slim": {
        extensions: ["slim", "slm"]
      },
      "text/spdx": {
        source: "iana",
        extensions: ["spdx"]
      },
      "text/strings": {
        source: "iana"
      },
      "text/stylus": {
        extensions: ["stylus", "styl"]
      },
      "text/t140": {
        source: "iana"
      },
      "text/tab-separated-values": {
        source: "iana",
        compressible: true,
        extensions: ["tsv"]
      },
      "text/troff": {
        source: "iana",
        extensions: ["t", "tr", "roff", "man", "me", "ms"]
      },
      "text/turtle": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["ttl"]
      },
      "text/ulpfec": {
        source: "iana"
      },
      "text/uri-list": {
        source: "iana",
        compressible: true,
        extensions: ["uri", "uris", "urls"]
      },
      "text/vcard": {
        source: "iana",
        compressible: true,
        extensions: ["vcard"]
      },
      "text/vnd.a": {
        source: "iana"
      },
      "text/vnd.abc": {
        source: "iana"
      },
      "text/vnd.ascii-art": {
        source: "iana"
      },
      "text/vnd.curl": {
        source: "iana",
        extensions: ["curl"]
      },
      "text/vnd.curl.dcurl": {
        source: "apache",
        extensions: ["dcurl"]
      },
      "text/vnd.curl.mcurl": {
        source: "apache",
        extensions: ["mcurl"]
      },
      "text/vnd.curl.scurl": {
        source: "apache",
        extensions: ["scurl"]
      },
      "text/vnd.debian.copyright": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/vnd.dmclientscript": {
        source: "iana"
      },
      "text/vnd.dvb.subtitle": {
        source: "iana",
        extensions: ["sub"]
      },
      "text/vnd.esmertec.theme-descriptor": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/vnd.familysearch.gedcom": {
        source: "iana",
        extensions: ["ged"]
      },
      "text/vnd.ficlab.flt": {
        source: "iana"
      },
      "text/vnd.fly": {
        source: "iana",
        extensions: ["fly"]
      },
      "text/vnd.fmi.flexstor": {
        source: "iana",
        extensions: ["flx"]
      },
      "text/vnd.gml": {
        source: "iana"
      },
      "text/vnd.graphviz": {
        source: "iana",
        extensions: ["gv"]
      },
      "text/vnd.hans": {
        source: "iana"
      },
      "text/vnd.hgl": {
        source: "iana"
      },
      "text/vnd.in3d.3dml": {
        source: "iana",
        extensions: ["3dml"]
      },
      "text/vnd.in3d.spot": {
        source: "iana",
        extensions: ["spot"]
      },
      "text/vnd.iptc.newsml": {
        source: "iana"
      },
      "text/vnd.iptc.nitf": {
        source: "iana"
      },
      "text/vnd.latex-z": {
        source: "iana"
      },
      "text/vnd.motorola.reflex": {
        source: "iana"
      },
      "text/vnd.ms-mediapackage": {
        source: "iana"
      },
      "text/vnd.net2phone.commcenter.command": {
        source: "iana"
      },
      "text/vnd.radisys.msml-basic-layout": {
        source: "iana"
      },
      "text/vnd.senx.warpscript": {
        source: "iana"
      },
      "text/vnd.si.uricatalogue": {
        source: "iana"
      },
      "text/vnd.sosi": {
        source: "iana"
      },
      "text/vnd.sun.j2me.app-descriptor": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["jad"]
      },
      "text/vnd.trolltech.linguist": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/vnd.wap.si": {
        source: "iana"
      },
      "text/vnd.wap.sl": {
        source: "iana"
      },
      "text/vnd.wap.wml": {
        source: "iana",
        extensions: ["wml"]
      },
      "text/vnd.wap.wmlscript": {
        source: "iana",
        extensions: ["wmls"]
      },
      "text/vtt": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["vtt"]
      },
      "text/x-asm": {
        source: "apache",
        extensions: ["s", "asm"]
      },
      "text/x-c": {
        source: "apache",
        extensions: ["c", "cc", "cxx", "cpp", "h", "hh", "dic"]
      },
      "text/x-component": {
        source: "nginx",
        extensions: ["htc"]
      },
      "text/x-fortran": {
        source: "apache",
        extensions: ["f", "for", "f77", "f90"]
      },
      "text/x-gwt-rpc": {
        compressible: true
      },
      "text/x-handlebars-template": {
        extensions: ["hbs"]
      },
      "text/x-java-source": {
        source: "apache",
        extensions: ["java"]
      },
      "text/x-jquery-tmpl": {
        compressible: true
      },
      "text/x-lua": {
        extensions: ["lua"]
      },
      "text/x-markdown": {
        compressible: true,
        extensions: ["mkd"]
      },
      "text/x-nfo": {
        source: "apache",
        extensions: ["nfo"]
      },
      "text/x-opml": {
        source: "apache",
        extensions: ["opml"]
      },
      "text/x-org": {
        compressible: true,
        extensions: ["org"]
      },
      "text/x-pascal": {
        source: "apache",
        extensions: ["p", "pas"]
      },
      "text/x-processing": {
        compressible: true,
        extensions: ["pde"]
      },
      "text/x-sass": {
        extensions: ["sass"]
      },
      "text/x-scss": {
        extensions: ["scss"]
      },
      "text/x-setext": {
        source: "apache",
        extensions: ["etx"]
      },
      "text/x-sfv": {
        source: "apache",
        extensions: ["sfv"]
      },
      "text/x-suse-ymp": {
        compressible: true,
        extensions: ["ymp"]
      },
      "text/x-uuencode": {
        source: "apache",
        extensions: ["uu"]
      },
      "text/x-vcalendar": {
        source: "apache",
        extensions: ["vcs"]
      },
      "text/x-vcard": {
        source: "apache",
        extensions: ["vcf"]
      },
      "text/xml": {
        source: "iana",
        compressible: true,
        extensions: ["xml"]
      },
      "text/xml-external-parsed-entity": {
        source: "iana"
      },
      "text/yaml": {
        compressible: true,
        extensions: ["yaml", "yml"]
      },
      "video/1d-interleaved-parityfec": {
        source: "iana"
      },
      "video/3gpp": {
        source: "iana",
        extensions: ["3gp", "3gpp"]
      },
      "video/3gpp-tt": {
        source: "iana"
      },
      "video/3gpp2": {
        source: "iana",
        extensions: ["3g2"]
      },
      "video/av1": {
        source: "iana"
      },
      "video/bmpeg": {
        source: "iana"
      },
      "video/bt656": {
        source: "iana"
      },
      "video/celb": {
        source: "iana"
      },
      "video/dv": {
        source: "iana"
      },
      "video/encaprtp": {
        source: "iana"
      },
      "video/ffv1": {
        source: "iana"
      },
      "video/flexfec": {
        source: "iana"
      },
      "video/h261": {
        source: "iana",
        extensions: ["h261"]
      },
      "video/h263": {
        source: "iana",
        extensions: ["h263"]
      },
      "video/h263-1998": {
        source: "iana"
      },
      "video/h263-2000": {
        source: "iana"
      },
      "video/h264": {
        source: "iana",
        extensions: ["h264"]
      },
      "video/h264-rcdo": {
        source: "iana"
      },
      "video/h264-svc": {
        source: "iana"
      },
      "video/h265": {
        source: "iana"
      },
      "video/iso.segment": {
        source: "iana",
        extensions: ["m4s"]
      },
      "video/jpeg": {
        source: "iana",
        extensions: ["jpgv"]
      },
      "video/jpeg2000": {
        source: "iana"
      },
      "video/jpm": {
        source: "apache",
        extensions: ["jpm", "jpgm"]
      },
      "video/jxsv": {
        source: "iana"
      },
      "video/mj2": {
        source: "iana",
        extensions: ["mj2", "mjp2"]
      },
      "video/mp1s": {
        source: "iana"
      },
      "video/mp2p": {
        source: "iana"
      },
      "video/mp2t": {
        source: "iana",
        extensions: ["ts"]
      },
      "video/mp4": {
        source: "iana",
        compressible: false,
        extensions: ["mp4", "mp4v", "mpg4"]
      },
      "video/mp4v-es": {
        source: "iana"
      },
      "video/mpeg": {
        source: "iana",
        compressible: false,
        extensions: ["mpeg", "mpg", "mpe", "m1v", "m2v"]
      },
      "video/mpeg4-generic": {
        source: "iana"
      },
      "video/mpv": {
        source: "iana"
      },
      "video/nv": {
        source: "iana"
      },
      "video/ogg": {
        source: "iana",
        compressible: false,
        extensions: ["ogv"]
      },
      "video/parityfec": {
        source: "iana"
      },
      "video/pointer": {
        source: "iana"
      },
      "video/quicktime": {
        source: "iana",
        compressible: false,
        extensions: ["qt", "mov"]
      },
      "video/raptorfec": {
        source: "iana"
      },
      "video/raw": {
        source: "iana"
      },
      "video/rtp-enc-aescm128": {
        source: "iana"
      },
      "video/rtploopback": {
        source: "iana"
      },
      "video/rtx": {
        source: "iana"
      },
      "video/scip": {
        source: "iana"
      },
      "video/smpte291": {
        source: "iana"
      },
      "video/smpte292m": {
        source: "iana"
      },
      "video/ulpfec": {
        source: "iana"
      },
      "video/vc1": {
        source: "iana"
      },
      "video/vc2": {
        source: "iana"
      },
      "video/vnd.cctv": {
        source: "iana"
      },
      "video/vnd.dece.hd": {
        source: "iana",
        extensions: ["uvh", "uvvh"]
      },
      "video/vnd.dece.mobile": {
        source: "iana",
        extensions: ["uvm", "uvvm"]
      },
      "video/vnd.dece.mp4": {
        source: "iana"
      },
      "video/vnd.dece.pd": {
        source: "iana",
        extensions: ["uvp", "uvvp"]
      },
      "video/vnd.dece.sd": {
        source: "iana",
        extensions: ["uvs", "uvvs"]
      },
      "video/vnd.dece.video": {
        source: "iana",
        extensions: ["uvv", "uvvv"]
      },
      "video/vnd.directv.mpeg": {
        source: "iana"
      },
      "video/vnd.directv.mpeg-tts": {
        source: "iana"
      },
      "video/vnd.dlna.mpeg-tts": {
        source: "iana"
      },
      "video/vnd.dvb.file": {
        source: "iana",
        extensions: ["dvb"]
      },
      "video/vnd.fvt": {
        source: "iana",
        extensions: ["fvt"]
      },
      "video/vnd.hns.video": {
        source: "iana"
      },
      "video/vnd.iptvforum.1dparityfec-1010": {
        source: "iana"
      },
      "video/vnd.iptvforum.1dparityfec-2005": {
        source: "iana"
      },
      "video/vnd.iptvforum.2dparityfec-1010": {
        source: "iana"
      },
      "video/vnd.iptvforum.2dparityfec-2005": {
        source: "iana"
      },
      "video/vnd.iptvforum.ttsavc": {
        source: "iana"
      },
      "video/vnd.iptvforum.ttsmpeg2": {
        source: "iana"
      },
      "video/vnd.motorola.video": {
        source: "iana"
      },
      "video/vnd.motorola.videop": {
        source: "iana"
      },
      "video/vnd.mpegurl": {
        source: "iana",
        extensions: ["mxu", "m4u"]
      },
      "video/vnd.ms-playready.media.pyv": {
        source: "iana",
        extensions: ["pyv"]
      },
      "video/vnd.nokia.interleaved-multimedia": {
        source: "iana"
      },
      "video/vnd.nokia.mp4vr": {
        source: "iana"
      },
      "video/vnd.nokia.videovoip": {
        source: "iana"
      },
      "video/vnd.objectvideo": {
        source: "iana"
      },
      "video/vnd.radgamettools.bink": {
        source: "iana"
      },
      "video/vnd.radgamettools.smacker": {
        source: "iana"
      },
      "video/vnd.sealed.mpeg1": {
        source: "iana"
      },
      "video/vnd.sealed.mpeg4": {
        source: "iana"
      },
      "video/vnd.sealed.swf": {
        source: "iana"
      },
      "video/vnd.sealedmedia.softseal.mov": {
        source: "iana"
      },
      "video/vnd.uvvu.mp4": {
        source: "iana",
        extensions: ["uvu", "uvvu"]
      },
      "video/vnd.vivo": {
        source: "iana",
        extensions: ["viv"]
      },
      "video/vnd.youtube.yt": {
        source: "iana"
      },
      "video/vp8": {
        source: "iana"
      },
      "video/vp9": {
        source: "iana"
      },
      "video/webm": {
        source: "apache",
        compressible: false,
        extensions: ["webm"]
      },
      "video/x-f4v": {
        source: "apache",
        extensions: ["f4v"]
      },
      "video/x-fli": {
        source: "apache",
        extensions: ["fli"]
      },
      "video/x-flv": {
        source: "apache",
        compressible: false,
        extensions: ["flv"]
      },
      "video/x-m4v": {
        source: "apache",
        extensions: ["m4v"]
      },
      "video/x-matroska": {
        source: "apache",
        compressible: false,
        extensions: ["mkv", "mk3d", "mks"]
      },
      "video/x-mng": {
        source: "apache",
        extensions: ["mng"]
      },
      "video/x-ms-asf": {
        source: "apache",
        extensions: ["asf", "asx"]
      },
      "video/x-ms-vob": {
        source: "apache",
        extensions: ["vob"]
      },
      "video/x-ms-wm": {
        source: "apache",
        extensions: ["wm"]
      },
      "video/x-ms-wmv": {
        source: "apache",
        compressible: false,
        extensions: ["wmv"]
      },
      "video/x-ms-wmx": {
        source: "apache",
        extensions: ["wmx"]
      },
      "video/x-ms-wvx": {
        source: "apache",
        extensions: ["wvx"]
      },
      "video/x-msvideo": {
        source: "apache",
        extensions: ["avi"]
      },
      "video/x-sgi-movie": {
        source: "apache",
        extensions: ["movie"]
      },
      "video/x-smv": {
        source: "apache",
        extensions: ["smv"]
      },
      "x-conference/x-cooltalk": {
        source: "apache",
        extensions: ["ice"]
      },
      "x-shader/x-fragment": {
        compressible: true
      },
      "x-shader/x-vertex": {
        compressible: true
      }
    };
  }
});

// node_modules/mime-db/index.js
var require_mime_db = __commonJS({
  "node_modules/mime-db/index.js"(exports2, module2) {
    module2.exports = require_db();
  }
});

// node_modules/mime-types/index.js
var require_mime_types = __commonJS({
  "node_modules/mime-types/index.js"(exports2) {
    "use strict";
    var db = require_mime_db();
    var extname = require("path").extname;
    var EXTRACT_TYPE_REGEXP = /^\s*([^;\s]*)(?:;|\s|$)/;
    var TEXT_TYPE_REGEXP = /^text\//i;
    exports2.charset = charset;
    exports2.charsets = { lookup: charset };
    exports2.contentType = contentType;
    exports2.extension = extension;
    exports2.extensions = /* @__PURE__ */ Object.create(null);
    exports2.lookup = lookup;
    exports2.types = /* @__PURE__ */ Object.create(null);
    populateMaps(exports2.extensions, exports2.types);
    function charset(type) {
      if (!type || typeof type !== "string") {
        return false;
      }
      var match = EXTRACT_TYPE_REGEXP.exec(type);
      var mime = match && db[match[1].toLowerCase()];
      if (mime && mime.charset) {
        return mime.charset;
      }
      if (match && TEXT_TYPE_REGEXP.test(match[1])) {
        return "UTF-8";
      }
      return false;
    }
    function contentType(str2) {
      if (!str2 || typeof str2 !== "string") {
        return false;
      }
      var mime = str2.indexOf("/") === -1 ? exports2.lookup(str2) : str2;
      if (!mime) {
        return false;
      }
      if (mime.indexOf("charset") === -1) {
        var charset2 = exports2.charset(mime);
        if (charset2)
          mime += "; charset=" + charset2.toLowerCase();
      }
      return mime;
    }
    function extension(type) {
      if (!type || typeof type !== "string") {
        return false;
      }
      var match = EXTRACT_TYPE_REGEXP.exec(type);
      var exts = match && exports2.extensions[match[1].toLowerCase()];
      if (!exts || !exts.length) {
        return false;
      }
      return exts[0];
    }
    function lookup(path) {
      if (!path || typeof path !== "string") {
        return false;
      }
      var extension2 = extname("x." + path).toLowerCase().substr(1);
      if (!extension2) {
        return false;
      }
      return exports2.types[extension2] || false;
    }
    function populateMaps(extensions, types) {
      var preference = ["nginx", "apache", void 0, "iana"];
      Object.keys(db).forEach(function forEachMimeType(type) {
        var mime = db[type];
        var exts = mime.extensions;
        if (!exts || !exts.length) {
          return;
        }
        extensions[type] = exts;
        for (var i = 0; i < exts.length; i++) {
          var extension2 = exts[i];
          if (types[extension2]) {
            var from = preference.indexOf(db[types[extension2]].source);
            var to = preference.indexOf(mime.source);
            if (types[extension2] !== "application/octet-stream" && (from > to || from === to && types[extension2].substr(0, 12) === "application/")) {
              continue;
            }
          }
          types[extension2] = type;
        }
      });
    }
  }
});

// node_modules/asynckit/lib/defer.js
var require_defer = __commonJS({
  "node_modules/asynckit/lib/defer.js"(exports2, module2) {
    module2.exports = defer;
    function defer(fn) {
      var nextTick = typeof setImmediate == "function" ? setImmediate : typeof process == "object" && typeof process.nextTick == "function" ? process.nextTick : null;
      if (nextTick) {
        nextTick(fn);
      } else {
        setTimeout(fn, 0);
      }
    }
  }
});

// node_modules/asynckit/lib/async.js
var require_async = __commonJS({
  "node_modules/asynckit/lib/async.js"(exports2, module2) {
    var defer = require_defer();
    module2.exports = async;
    function async(callback) {
      var isAsync = false;
      defer(function() {
        isAsync = true;
      });
      return function async_callback(err, result) {
        if (isAsync) {
          callback(err, result);
        } else {
          defer(function nextTick_callback() {
            callback(err, result);
          });
        }
      };
    }
  }
});

// node_modules/asynckit/lib/abort.js
var require_abort = __commonJS({
  "node_modules/asynckit/lib/abort.js"(exports2, module2) {
    module2.exports = abort;
    function abort(state) {
      Object.keys(state.jobs).forEach(clean.bind(state));
      state.jobs = {};
    }
    function clean(key) {
      if (typeof this.jobs[key] == "function") {
        this.jobs[key]();
      }
    }
  }
});

// node_modules/asynckit/lib/iterate.js
var require_iterate = __commonJS({
  "node_modules/asynckit/lib/iterate.js"(exports2, module2) {
    var async = require_async();
    var abort = require_abort();
    module2.exports = iterate;
    function iterate(list, iterator, state, callback) {
      var key = state["keyedList"] ? state["keyedList"][state.index] : state.index;
      state.jobs[key] = runJob(iterator, key, list[key], function(error, output) {
        if (!(key in state.jobs)) {
          return;
        }
        delete state.jobs[key];
        if (error) {
          abort(state);
        } else {
          state.results[key] = output;
        }
        callback(error, state.results);
      });
    }
    function runJob(iterator, key, item, callback) {
      var aborter;
      if (iterator.length == 2) {
        aborter = iterator(item, async(callback));
      } else {
        aborter = iterator(item, key, async(callback));
      }
      return aborter;
    }
  }
});

// node_modules/asynckit/lib/state.js
var require_state = __commonJS({
  "node_modules/asynckit/lib/state.js"(exports2, module2) {
    module2.exports = state;
    function state(list, sortMethod) {
      var isNamedList = !Array.isArray(list), initState = {
        index: 0,
        keyedList: isNamedList || sortMethod ? Object.keys(list) : null,
        jobs: {},
        results: isNamedList ? {} : [],
        size: isNamedList ? Object.keys(list).length : list.length
      };
      if (sortMethod) {
        initState.keyedList.sort(isNamedList ? sortMethod : function(a, b) {
          return sortMethod(list[a], list[b]);
        });
      }
      return initState;
    }
  }
});

// node_modules/asynckit/lib/terminator.js
var require_terminator = __commonJS({
  "node_modules/asynckit/lib/terminator.js"(exports2, module2) {
    var abort = require_abort();
    var async = require_async();
    module2.exports = terminator;
    function terminator(callback) {
      if (!Object.keys(this.jobs).length) {
        return;
      }
      this.index = this.size;
      abort(this);
      async(callback)(null, this.results);
    }
  }
});

// node_modules/asynckit/parallel.js
var require_parallel = __commonJS({
  "node_modules/asynckit/parallel.js"(exports2, module2) {
    var iterate = require_iterate();
    var initState = require_state();
    var terminator = require_terminator();
    module2.exports = parallel;
    function parallel(list, iterator, callback) {
      var state = initState(list);
      while (state.index < (state["keyedList"] || list).length) {
        iterate(list, iterator, state, function(error, result) {
          if (error) {
            callback(error, result);
            return;
          }
          if (Object.keys(state.jobs).length === 0) {
            callback(null, state.results);
            return;
          }
        });
        state.index++;
      }
      return terminator.bind(state, callback);
    }
  }
});

// node_modules/asynckit/serialOrdered.js
var require_serialOrdered = __commonJS({
  "node_modules/asynckit/serialOrdered.js"(exports2, module2) {
    var iterate = require_iterate();
    var initState = require_state();
    var terminator = require_terminator();
    module2.exports = serialOrdered;
    module2.exports.ascending = ascending;
    module2.exports.descending = descending;
    function serialOrdered(list, iterator, sortMethod, callback) {
      var state = initState(list, sortMethod);
      iterate(list, iterator, state, function iteratorHandler(error, result) {
        if (error) {
          callback(error, result);
          return;
        }
        state.index++;
        if (state.index < (state["keyedList"] || list).length) {
          iterate(list, iterator, state, iteratorHandler);
          return;
        }
        callback(null, state.results);
      });
      return terminator.bind(state, callback);
    }
    function ascending(a, b) {
      return a < b ? -1 : a > b ? 1 : 0;
    }
    function descending(a, b) {
      return -1 * ascending(a, b);
    }
  }
});

// node_modules/asynckit/serial.js
var require_serial = __commonJS({
  "node_modules/asynckit/serial.js"(exports2, module2) {
    var serialOrdered = require_serialOrdered();
    module2.exports = serial;
    function serial(list, iterator, callback) {
      return serialOrdered(list, iterator, null, callback);
    }
  }
});

// node_modules/asynckit/index.js
var require_asynckit = __commonJS({
  "node_modules/asynckit/index.js"(exports2, module2) {
    module2.exports = {
      parallel: require_parallel(),
      serial: require_serial(),
      serialOrdered: require_serialOrdered()
    };
  }
});

// node_modules/es-object-atoms/index.js
var require_es_object_atoms = __commonJS({
  "node_modules/es-object-atoms/index.js"(exports2, module2) {
    "use strict";
    module2.exports = Object;
  }
});

// node_modules/es-errors/index.js
var require_es_errors = __commonJS({
  "node_modules/es-errors/index.js"(exports2, module2) {
    "use strict";
    module2.exports = Error;
  }
});

// node_modules/es-errors/eval.js
var require_eval = __commonJS({
  "node_modules/es-errors/eval.js"(exports2, module2) {
    "use strict";
    module2.exports = EvalError;
  }
});

// node_modules/es-errors/range.js
var require_range = __commonJS({
  "node_modules/es-errors/range.js"(exports2, module2) {
    "use strict";
    module2.exports = RangeError;
  }
});

// node_modules/es-errors/ref.js
var require_ref = __commonJS({
  "node_modules/es-errors/ref.js"(exports2, module2) {
    "use strict";
    module2.exports = ReferenceError;
  }
});

// node_modules/es-errors/syntax.js
var require_syntax = __commonJS({
  "node_modules/es-errors/syntax.js"(exports2, module2) {
    "use strict";
    module2.exports = SyntaxError;
  }
});

// node_modules/es-errors/type.js
var require_type = __commonJS({
  "node_modules/es-errors/type.js"(exports2, module2) {
    "use strict";
    module2.exports = TypeError;
  }
});

// node_modules/es-errors/uri.js
var require_uri = __commonJS({
  "node_modules/es-errors/uri.js"(exports2, module2) {
    "use strict";
    module2.exports = URIError;
  }
});

// node_modules/math-intrinsics/abs.js
var require_abs = __commonJS({
  "node_modules/math-intrinsics/abs.js"(exports2, module2) {
    "use strict";
    module2.exports = Math.abs;
  }
});

// node_modules/math-intrinsics/floor.js
var require_floor = __commonJS({
  "node_modules/math-intrinsics/floor.js"(exports2, module2) {
    "use strict";
    module2.exports = Math.floor;
  }
});

// node_modules/math-intrinsics/max.js
var require_max = __commonJS({
  "node_modules/math-intrinsics/max.js"(exports2, module2) {
    "use strict";
    module2.exports = Math.max;
  }
});

// node_modules/math-intrinsics/min.js
var require_min = __commonJS({
  "node_modules/math-intrinsics/min.js"(exports2, module2) {
    "use strict";
    module2.exports = Math.min;
  }
});

// node_modules/math-intrinsics/pow.js
var require_pow = __commonJS({
  "node_modules/math-intrinsics/pow.js"(exports2, module2) {
    "use strict";
    module2.exports = Math.pow;
  }
});

// node_modules/math-intrinsics/round.js
var require_round = __commonJS({
  "node_modules/math-intrinsics/round.js"(exports2, module2) {
    "use strict";
    module2.exports = Math.round;
  }
});

// node_modules/math-intrinsics/isNaN.js
var require_isNaN = __commonJS({
  "node_modules/math-intrinsics/isNaN.js"(exports2, module2) {
    "use strict";
    module2.exports = Number.isNaN || function isNaN2(a) {
      return a !== a;
    };
  }
});

// node_modules/math-intrinsics/sign.js
var require_sign = __commonJS({
  "node_modules/math-intrinsics/sign.js"(exports2, module2) {
    "use strict";
    var $isNaN = require_isNaN();
    module2.exports = function sign2(number) {
      if ($isNaN(number) || number === 0) {
        return number;
      }
      return number < 0 ? -1 : 1;
    };
  }
});

// node_modules/gopd/gOPD.js
var require_gOPD = __commonJS({
  "node_modules/gopd/gOPD.js"(exports2, module2) {
    "use strict";
    module2.exports = Object.getOwnPropertyDescriptor;
  }
});

// node_modules/gopd/index.js
var require_gopd = __commonJS({
  "node_modules/gopd/index.js"(exports2, module2) {
    "use strict";
    var $gOPD = require_gOPD();
    if ($gOPD) {
      try {
        $gOPD([], "length");
      } catch (e) {
        $gOPD = null;
      }
    }
    module2.exports = $gOPD;
  }
});

// node_modules/es-define-property/index.js
var require_es_define_property = __commonJS({
  "node_modules/es-define-property/index.js"(exports2, module2) {
    "use strict";
    var $defineProperty = Object.defineProperty || false;
    if ($defineProperty) {
      try {
        $defineProperty({}, "a", { value: 1 });
      } catch (e) {
        $defineProperty = false;
      }
    }
    module2.exports = $defineProperty;
  }
});

// node_modules/has-symbols/shams.js
var require_shams = __commonJS({
  "node_modules/has-symbols/shams.js"(exports2, module2) {
    "use strict";
    module2.exports = function hasSymbols() {
      if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
        return false;
      }
      if (typeof Symbol.iterator === "symbol") {
        return true;
      }
      var obj = {};
      var sym = Symbol("test");
      var symObj = Object(sym);
      if (typeof sym === "string") {
        return false;
      }
      if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
        return false;
      }
      if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
        return false;
      }
      var symVal = 42;
      obj[sym] = symVal;
      for (var _ in obj) {
        return false;
      }
      if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
        return false;
      }
      if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
        return false;
      }
      var syms = Object.getOwnPropertySymbols(obj);
      if (syms.length !== 1 || syms[0] !== sym) {
        return false;
      }
      if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
        return false;
      }
      if (typeof Object.getOwnPropertyDescriptor === "function") {
        var descriptor = (
          /** @type {PropertyDescriptor} */
          Object.getOwnPropertyDescriptor(obj, sym)
        );
        if (descriptor.value !== symVal || descriptor.enumerable !== true) {
          return false;
        }
      }
      return true;
    };
  }
});

// node_modules/has-symbols/index.js
var require_has_symbols = __commonJS({
  "node_modules/has-symbols/index.js"(exports2, module2) {
    "use strict";
    var origSymbol = typeof Symbol !== "undefined" && Symbol;
    var hasSymbolSham = require_shams();
    module2.exports = function hasNativeSymbols() {
      if (typeof origSymbol !== "function") {
        return false;
      }
      if (typeof Symbol !== "function") {
        return false;
      }
      if (typeof origSymbol("foo") !== "symbol") {
        return false;
      }
      if (typeof Symbol("bar") !== "symbol") {
        return false;
      }
      return hasSymbolSham();
    };
  }
});

// node_modules/get-proto/Reflect.getPrototypeOf.js
var require_Reflect_getPrototypeOf = __commonJS({
  "node_modules/get-proto/Reflect.getPrototypeOf.js"(exports2, module2) {
    "use strict";
    module2.exports = typeof Reflect !== "undefined" && Reflect.getPrototypeOf || null;
  }
});

// node_modules/get-proto/Object.getPrototypeOf.js
var require_Object_getPrototypeOf = __commonJS({
  "node_modules/get-proto/Object.getPrototypeOf.js"(exports2, module2) {
    "use strict";
    var $Object = require_es_object_atoms();
    module2.exports = $Object.getPrototypeOf || null;
  }
});

// node_modules/function-bind/implementation.js
var require_implementation = __commonJS({
  "node_modules/function-bind/implementation.js"(exports2, module2) {
    "use strict";
    var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
    var toStr = Object.prototype.toString;
    var max2 = Math.max;
    var funcType = "[object Function]";
    var concatty = function concatty2(a, b) {
      var arr = [];
      for (var i = 0; i < a.length; i += 1) {
        arr[i] = a[i];
      }
      for (var j = 0; j < b.length; j += 1) {
        arr[j + a.length] = b[j];
      }
      return arr;
    };
    var slicy = function slicy2(arrLike, offset2) {
      var arr = [];
      for (var i = offset2 || 0, j = 0; i < arrLike.length; i += 1, j += 1) {
        arr[j] = arrLike[i];
      }
      return arr;
    };
    var joiny = function(arr, joiner) {
      var str2 = "";
      for (var i = 0; i < arr.length; i += 1) {
        str2 += arr[i];
        if (i + 1 < arr.length) {
          str2 += joiner;
        }
      }
      return str2;
    };
    module2.exports = function bind(that) {
      var target = this;
      if (typeof target !== "function" || toStr.apply(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
      }
      var args = slicy(arguments, 1);
      var bound;
      var binder = function() {
        if (this instanceof bound) {
          var result = target.apply(
            this,
            concatty(args, arguments)
          );
          if (Object(result) === result) {
            return result;
          }
          return this;
        }
        return target.apply(
          that,
          concatty(args, arguments)
        );
      };
      var boundLength = max2(0, target.length - args.length);
      var boundArgs = [];
      for (var i = 0; i < boundLength; i++) {
        boundArgs[i] = "$" + i;
      }
      bound = Function("binder", "return function (" + joiny(boundArgs, ",") + "){ return binder.apply(this,arguments); }")(binder);
      if (target.prototype) {
        var Empty = function Empty2() {
        };
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
      }
      return bound;
    };
  }
});

// node_modules/function-bind/index.js
var require_function_bind = __commonJS({
  "node_modules/function-bind/index.js"(exports2, module2) {
    "use strict";
    var implementation = require_implementation();
    module2.exports = Function.prototype.bind || implementation;
  }
});

// node_modules/call-bind-apply-helpers/functionCall.js
var require_functionCall = __commonJS({
  "node_modules/call-bind-apply-helpers/functionCall.js"(exports2, module2) {
    "use strict";
    module2.exports = Function.prototype.call;
  }
});

// node_modules/call-bind-apply-helpers/functionApply.js
var require_functionApply = __commonJS({
  "node_modules/call-bind-apply-helpers/functionApply.js"(exports2, module2) {
    "use strict";
    module2.exports = Function.prototype.apply;
  }
});

// node_modules/call-bind-apply-helpers/reflectApply.js
var require_reflectApply = __commonJS({
  "node_modules/call-bind-apply-helpers/reflectApply.js"(exports2, module2) {
    "use strict";
    module2.exports = typeof Reflect !== "undefined" && Reflect && Reflect.apply;
  }
});

// node_modules/call-bind-apply-helpers/actualApply.js
var require_actualApply = __commonJS({
  "node_modules/call-bind-apply-helpers/actualApply.js"(exports2, module2) {
    "use strict";
    var bind = require_function_bind();
    var $apply = require_functionApply();
    var $call = require_functionCall();
    var $reflectApply = require_reflectApply();
    module2.exports = $reflectApply || bind.call($call, $apply);
  }
});

// node_modules/call-bind-apply-helpers/index.js
var require_call_bind_apply_helpers = __commonJS({
  "node_modules/call-bind-apply-helpers/index.js"(exports2, module2) {
    "use strict";
    var bind = require_function_bind();
    var $TypeError = require_type();
    var $call = require_functionCall();
    var $actualApply = require_actualApply();
    module2.exports = function callBindBasic(args) {
      if (args.length < 1 || typeof args[0] !== "function") {
        throw new $TypeError("a function is required");
      }
      return $actualApply(bind, $call, args);
    };
  }
});

// node_modules/dunder-proto/get.js
var require_get = __commonJS({
  "node_modules/dunder-proto/get.js"(exports2, module2) {
    "use strict";
    var callBind = require_call_bind_apply_helpers();
    var gOPD = require_gopd();
    var hasProtoAccessor;
    try {
      hasProtoAccessor = /** @type {{ __proto__?: typeof Array.prototype }} */
      [].__proto__ === Array.prototype;
    } catch (e) {
      if (!e || typeof e !== "object" || !("code" in e) || e.code !== "ERR_PROTO_ACCESS") {
        throw e;
      }
    }
    var desc = !!hasProtoAccessor && gOPD && gOPD(
      Object.prototype,
      /** @type {keyof typeof Object.prototype} */
      "__proto__"
    );
    var $Object = Object;
    var $getPrototypeOf = $Object.getPrototypeOf;
    module2.exports = desc && typeof desc.get === "function" ? callBind([desc.get]) : typeof $getPrototypeOf === "function" ? (
      /** @type {import('./get')} */
      function getDunder(value) {
        return $getPrototypeOf(value == null ? value : $Object(value));
      }
    ) : false;
  }
});

// node_modules/get-proto/index.js
var require_get_proto = __commonJS({
  "node_modules/get-proto/index.js"(exports2, module2) {
    "use strict";
    var reflectGetProto = require_Reflect_getPrototypeOf();
    var originalGetProto = require_Object_getPrototypeOf();
    var getDunderProto = require_get();
    module2.exports = reflectGetProto ? function getProto(O) {
      return reflectGetProto(O);
    } : originalGetProto ? function getProto(O) {
      if (!O || typeof O !== "object" && typeof O !== "function") {
        throw new TypeError("getProto: not an object");
      }
      return originalGetProto(O);
    } : getDunderProto ? function getProto(O) {
      return getDunderProto(O);
    } : null;
  }
});

// node_modules/hasown/index.js
var require_hasown = __commonJS({
  "node_modules/hasown/index.js"(exports2, module2) {
    "use strict";
    var call = Function.prototype.call;
    var $hasOwn = Object.prototype.hasOwnProperty;
    var bind = require_function_bind();
    module2.exports = bind.call(call, $hasOwn);
  }
});

// node_modules/get-intrinsic/index.js
var require_get_intrinsic = __commonJS({
  "node_modules/get-intrinsic/index.js"(exports2, module2) {
    "use strict";
    var undefined2;
    var $Object = require_es_object_atoms();
    var $Error = require_es_errors();
    var $EvalError = require_eval();
    var $RangeError = require_range();
    var $ReferenceError = require_ref();
    var $SyntaxError = require_syntax();
    var $TypeError = require_type();
    var $URIError = require_uri();
    var abs2 = require_abs();
    var floor2 = require_floor();
    var max2 = require_max();
    var min2 = require_min();
    var pow2 = require_pow();
    var round2 = require_round();
    var sign2 = require_sign();
    var $Function = Function;
    var getEvalledConstructor = function(expressionSyntax) {
      try {
        return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
      } catch (e) {
      }
    };
    var $gOPD = require_gopd();
    var $defineProperty = require_es_define_property();
    var throwTypeError = function() {
      throw new $TypeError();
    };
    var ThrowTypeError = $gOPD ? function() {
      try {
        arguments.callee;
        return throwTypeError;
      } catch (calleeThrows) {
        try {
          return $gOPD(arguments, "callee").get;
        } catch (gOPDthrows) {
          return throwTypeError;
        }
      }
    }() : throwTypeError;
    var hasSymbols = require_has_symbols()();
    var getProto = require_get_proto();
    var $ObjectGPO = require_Object_getPrototypeOf();
    var $ReflectGPO = require_Reflect_getPrototypeOf();
    var $apply = require_functionApply();
    var $call = require_functionCall();
    var needsEval = {};
    var TypedArray = typeof Uint8Array === "undefined" || !getProto ? undefined2 : getProto(Uint8Array);
    var INTRINSICS = {
      __proto__: null,
      "%AggregateError%": typeof AggregateError === "undefined" ? undefined2 : AggregateError,
      "%Array%": Array,
      "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined2 : ArrayBuffer,
      "%ArrayIteratorPrototype%": hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined2,
      "%AsyncFromSyncIteratorPrototype%": undefined2,
      "%AsyncFunction%": needsEval,
      "%AsyncGenerator%": needsEval,
      "%AsyncGeneratorFunction%": needsEval,
      "%AsyncIteratorPrototype%": needsEval,
      "%Atomics%": typeof Atomics === "undefined" ? undefined2 : Atomics,
      "%BigInt%": typeof BigInt === "undefined" ? undefined2 : BigInt,
      "%BigInt64Array%": typeof BigInt64Array === "undefined" ? undefined2 : BigInt64Array,
      "%BigUint64Array%": typeof BigUint64Array === "undefined" ? undefined2 : BigUint64Array,
      "%Boolean%": Boolean,
      "%DataView%": typeof DataView === "undefined" ? undefined2 : DataView,
      "%Date%": Date,
      "%decodeURI%": decodeURI,
      "%decodeURIComponent%": decodeURIComponent,
      "%encodeURI%": encodeURI,
      "%encodeURIComponent%": encodeURIComponent,
      "%Error%": $Error,
      "%eval%": eval,
      // eslint-disable-line no-eval
      "%EvalError%": $EvalError,
      "%Float16Array%": typeof Float16Array === "undefined" ? undefined2 : Float16Array,
      "%Float32Array%": typeof Float32Array === "undefined" ? undefined2 : Float32Array,
      "%Float64Array%": typeof Float64Array === "undefined" ? undefined2 : Float64Array,
      "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined2 : FinalizationRegistry,
      "%Function%": $Function,
      "%GeneratorFunction%": needsEval,
      "%Int8Array%": typeof Int8Array === "undefined" ? undefined2 : Int8Array,
      "%Int16Array%": typeof Int16Array === "undefined" ? undefined2 : Int16Array,
      "%Int32Array%": typeof Int32Array === "undefined" ? undefined2 : Int32Array,
      "%isFinite%": isFinite,
      "%isNaN%": isNaN,
      "%IteratorPrototype%": hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined2,
      "%JSON%": typeof JSON === "object" ? JSON : undefined2,
      "%Map%": typeof Map === "undefined" ? undefined2 : Map,
      "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols || !getProto ? undefined2 : getProto((/* @__PURE__ */ new Map())[Symbol.iterator]()),
      "%Math%": Math,
      "%Number%": Number,
      "%Object%": $Object,
      "%Object.getOwnPropertyDescriptor%": $gOPD,
      "%parseFloat%": parseFloat,
      "%parseInt%": parseInt,
      "%Promise%": typeof Promise === "undefined" ? undefined2 : Promise,
      "%Proxy%": typeof Proxy === "undefined" ? undefined2 : Proxy,
      "%RangeError%": $RangeError,
      "%ReferenceError%": $ReferenceError,
      "%Reflect%": typeof Reflect === "undefined" ? undefined2 : Reflect,
      "%RegExp%": RegExp,
      "%Set%": typeof Set === "undefined" ? undefined2 : Set,
      "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols || !getProto ? undefined2 : getProto((/* @__PURE__ */ new Set())[Symbol.iterator]()),
      "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined2 : SharedArrayBuffer,
      "%String%": String,
      "%StringIteratorPrototype%": hasSymbols && getProto ? getProto(""[Symbol.iterator]()) : undefined2,
      "%Symbol%": hasSymbols ? Symbol : undefined2,
      "%SyntaxError%": $SyntaxError,
      "%ThrowTypeError%": ThrowTypeError,
      "%TypedArray%": TypedArray,
      "%TypeError%": $TypeError,
      "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined2 : Uint8Array,
      "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined2 : Uint8ClampedArray,
      "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined2 : Uint16Array,
      "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined2 : Uint32Array,
      "%URIError%": $URIError,
      "%WeakMap%": typeof WeakMap === "undefined" ? undefined2 : WeakMap,
      "%WeakRef%": typeof WeakRef === "undefined" ? undefined2 : WeakRef,
      "%WeakSet%": typeof WeakSet === "undefined" ? undefined2 : WeakSet,
      "%Function.prototype.call%": $call,
      "%Function.prototype.apply%": $apply,
      "%Object.defineProperty%": $defineProperty,
      "%Object.getPrototypeOf%": $ObjectGPO,
      "%Math.abs%": abs2,
      "%Math.floor%": floor2,
      "%Math.max%": max2,
      "%Math.min%": min2,
      "%Math.pow%": pow2,
      "%Math.round%": round2,
      "%Math.sign%": sign2,
      "%Reflect.getPrototypeOf%": $ReflectGPO
    };
    if (getProto) {
      try {
        null.error;
      } catch (e) {
        errorProto = getProto(getProto(e));
        INTRINSICS["%Error.prototype%"] = errorProto;
      }
    }
    var errorProto;
    var doEval = function doEval2(name) {
      var value;
      if (name === "%AsyncFunction%") {
        value = getEvalledConstructor("async function () {}");
      } else if (name === "%GeneratorFunction%") {
        value = getEvalledConstructor("function* () {}");
      } else if (name === "%AsyncGeneratorFunction%") {
        value = getEvalledConstructor("async function* () {}");
      } else if (name === "%AsyncGenerator%") {
        var fn = doEval2("%AsyncGeneratorFunction%");
        if (fn) {
          value = fn.prototype;
        }
      } else if (name === "%AsyncIteratorPrototype%") {
        var gen = doEval2("%AsyncGenerator%");
        if (gen && getProto) {
          value = getProto(gen.prototype);
        }
      }
      INTRINSICS[name] = value;
      return value;
    };
    var LEGACY_ALIASES = {
      __proto__: null,
      "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
      "%ArrayPrototype%": ["Array", "prototype"],
      "%ArrayProto_entries%": ["Array", "prototype", "entries"],
      "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
      "%ArrayProto_keys%": ["Array", "prototype", "keys"],
      "%ArrayProto_values%": ["Array", "prototype", "values"],
      "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
      "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
      "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
      "%BooleanPrototype%": ["Boolean", "prototype"],
      "%DataViewPrototype%": ["DataView", "prototype"],
      "%DatePrototype%": ["Date", "prototype"],
      "%ErrorPrototype%": ["Error", "prototype"],
      "%EvalErrorPrototype%": ["EvalError", "prototype"],
      "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
      "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
      "%FunctionPrototype%": ["Function", "prototype"],
      "%Generator%": ["GeneratorFunction", "prototype"],
      "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
      "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
      "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
      "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
      "%JSONParse%": ["JSON", "parse"],
      "%JSONStringify%": ["JSON", "stringify"],
      "%MapPrototype%": ["Map", "prototype"],
      "%NumberPrototype%": ["Number", "prototype"],
      "%ObjectPrototype%": ["Object", "prototype"],
      "%ObjProto_toString%": ["Object", "prototype", "toString"],
      "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
      "%PromisePrototype%": ["Promise", "prototype"],
      "%PromiseProto_then%": ["Promise", "prototype", "then"],
      "%Promise_all%": ["Promise", "all"],
      "%Promise_reject%": ["Promise", "reject"],
      "%Promise_resolve%": ["Promise", "resolve"],
      "%RangeErrorPrototype%": ["RangeError", "prototype"],
      "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
      "%RegExpPrototype%": ["RegExp", "prototype"],
      "%SetPrototype%": ["Set", "prototype"],
      "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
      "%StringPrototype%": ["String", "prototype"],
      "%SymbolPrototype%": ["Symbol", "prototype"],
      "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
      "%TypedArrayPrototype%": ["TypedArray", "prototype"],
      "%TypeErrorPrototype%": ["TypeError", "prototype"],
      "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
      "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
      "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
      "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
      "%URIErrorPrototype%": ["URIError", "prototype"],
      "%WeakMapPrototype%": ["WeakMap", "prototype"],
      "%WeakSetPrototype%": ["WeakSet", "prototype"]
    };
    var bind = require_function_bind();
    var hasOwn = require_hasown();
    var $concat = bind.call($call, Array.prototype.concat);
    var $spliceApply = bind.call($apply, Array.prototype.splice);
    var $replace = bind.call($call, String.prototype.replace);
    var $strSlice = bind.call($call, String.prototype.slice);
    var $exec = bind.call($call, RegExp.prototype.exec);
    var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
    var reEscapeChar = /\\(\\)?/g;
    var stringToPath = function stringToPath2(string) {
      var first = $strSlice(string, 0, 1);
      var last = $strSlice(string, -1);
      if (first === "%" && last !== "%") {
        throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
      } else if (last === "%" && first !== "%") {
        throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
      }
      var result = [];
      $replace(string, rePropName, function(match, number, quote, subString) {
        result[result.length] = quote ? $replace(subString, reEscapeChar, "$1") : number || match;
      });
      return result;
    };
    var getBaseIntrinsic = function getBaseIntrinsic2(name, allowMissing) {
      var intrinsicName = name;
      var alias;
      if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
        alias = LEGACY_ALIASES[intrinsicName];
        intrinsicName = "%" + alias[0] + "%";
      }
      if (hasOwn(INTRINSICS, intrinsicName)) {
        var value = INTRINSICS[intrinsicName];
        if (value === needsEval) {
          value = doEval(intrinsicName);
        }
        if (typeof value === "undefined" && !allowMissing) {
          throw new $TypeError("intrinsic " + name + " exists, but is not available. Please file an issue!");
        }
        return {
          alias,
          name: intrinsicName,
          value
        };
      }
      throw new $SyntaxError("intrinsic " + name + " does not exist!");
    };
    module2.exports = function GetIntrinsic(name, allowMissing) {
      if (typeof name !== "string" || name.length === 0) {
        throw new $TypeError("intrinsic name must be a non-empty string");
      }
      if (arguments.length > 1 && typeof allowMissing !== "boolean") {
        throw new $TypeError('"allowMissing" argument must be a boolean');
      }
      if ($exec(/^%?[^%]*%?$/, name) === null) {
        throw new $SyntaxError("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
      }
      var parts = stringToPath(name);
      var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
      var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
      var intrinsicRealName = intrinsic.name;
      var value = intrinsic.value;
      var skipFurtherCaching = false;
      var alias = intrinsic.alias;
      if (alias) {
        intrinsicBaseName = alias[0];
        $spliceApply(parts, $concat([0, 1], alias));
      }
      for (var i = 1, isOwn = true; i < parts.length; i += 1) {
        var part = parts[i];
        var first = $strSlice(part, 0, 1);
        var last = $strSlice(part, -1);
        if ((first === '"' || first === "'" || first === "`" || (last === '"' || last === "'" || last === "`")) && first !== last) {
          throw new $SyntaxError("property names with quotes must have matching quotes");
        }
        if (part === "constructor" || !isOwn) {
          skipFurtherCaching = true;
        }
        intrinsicBaseName += "." + part;
        intrinsicRealName = "%" + intrinsicBaseName + "%";
        if (hasOwn(INTRINSICS, intrinsicRealName)) {
          value = INTRINSICS[intrinsicRealName];
        } else if (value != null) {
          if (!(part in value)) {
            if (!allowMissing) {
              throw new $TypeError("base intrinsic for " + name + " exists, but the property is not available.");
            }
            return void 0;
          }
          if ($gOPD && i + 1 >= parts.length) {
            var desc = $gOPD(value, part);
            isOwn = !!desc;
            if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
              value = desc.get;
            } else {
              value = value[part];
            }
          } else {
            isOwn = hasOwn(value, part);
            value = value[part];
          }
          if (isOwn && !skipFurtherCaching) {
            INTRINSICS[intrinsicRealName] = value;
          }
        }
      }
      return value;
    };
  }
});

// node_modules/has-tostringtag/shams.js
var require_shams2 = __commonJS({
  "node_modules/has-tostringtag/shams.js"(exports2, module2) {
    "use strict";
    var hasSymbols = require_shams();
    module2.exports = function hasToStringTagShams() {
      return hasSymbols() && !!Symbol.toStringTag;
    };
  }
});

// node_modules/es-set-tostringtag/index.js
var require_es_set_tostringtag = __commonJS({
  "node_modules/es-set-tostringtag/index.js"(exports2, module2) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var $defineProperty = GetIntrinsic("%Object.defineProperty%", true);
    var hasToStringTag = require_shams2()();
    var hasOwn = require_hasown();
    var $TypeError = require_type();
    var toStringTag = hasToStringTag ? Symbol.toStringTag : null;
    module2.exports = function setToStringTag(object, value) {
      var overrideIfSet = arguments.length > 2 && !!arguments[2] && arguments[2].force;
      var nonConfigurable = arguments.length > 2 && !!arguments[2] && arguments[2].nonConfigurable;
      if (typeof overrideIfSet !== "undefined" && typeof overrideIfSet !== "boolean" || typeof nonConfigurable !== "undefined" && typeof nonConfigurable !== "boolean") {
        throw new $TypeError("if provided, the `overrideIfSet` and `nonConfigurable` options must be booleans");
      }
      if (toStringTag && (overrideIfSet || !hasOwn(object, toStringTag))) {
        if ($defineProperty) {
          $defineProperty(object, toStringTag, {
            configurable: !nonConfigurable,
            enumerable: false,
            value,
            writable: false
          });
        } else {
          object[toStringTag] = value;
        }
      }
    };
  }
});

// node_modules/form-data/lib/populate.js
var require_populate = __commonJS({
  "node_modules/form-data/lib/populate.js"(exports2, module2) {
    "use strict";
    module2.exports = function(dst, src) {
      Object.keys(src).forEach(function(prop) {
        dst[prop] = dst[prop] || src[prop];
      });
      return dst;
    };
  }
});

// node_modules/form-data/lib/form_data.js
var require_form_data = __commonJS({
  "node_modules/form-data/lib/form_data.js"(exports2, module2) {
    "use strict";
    var CombinedStream = require_combined_stream();
    var util = require("util");
    var path = require("path");
    var http = require("http");
    var https = require("https");
    var parseUrl = require("url").parse;
    var fs = require("fs");
    var Stream = require("stream").Stream;
    var crypto2 = require("crypto");
    var mime = require_mime_types();
    var asynckit = require_asynckit();
    var setToStringTag = require_es_set_tostringtag();
    var hasOwn = require_hasown();
    var populate = require_populate();
    function FormData2(options) {
      if (!(this instanceof FormData2)) {
        return new FormData2(options);
      }
      this._overheadLength = 0;
      this._valueLength = 0;
      this._valuesToMeasure = [];
      CombinedStream.call(this);
      options = options || {};
      for (var option2 in options) {
        this[option2] = options[option2];
      }
    }
    util.inherits(FormData2, CombinedStream);
    FormData2.LINE_BREAK = "\r\n";
    FormData2.DEFAULT_CONTENT_TYPE = "application/octet-stream";
    FormData2.prototype.append = function(field, value, options) {
      options = options || {};
      if (typeof options === "string") {
        options = { filename: options };
      }
      var append = CombinedStream.prototype.append.bind(this);
      if (typeof value === "number" || value == null) {
        value = String(value);
      }
      if (Array.isArray(value)) {
        this._error(new Error("Arrays are not supported."));
        return;
      }
      var header = this._multiPartHeader(field, value, options);
      var footer = this._multiPartFooter();
      append(header);
      append(value);
      append(footer);
      this._trackLength(header, value, options);
    };
    FormData2.prototype._trackLength = function(header, value, options) {
      var valueLength = 0;
      if (options.knownLength != null) {
        valueLength += Number(options.knownLength);
      } else if (Buffer.isBuffer(value)) {
        valueLength = value.length;
      } else if (typeof value === "string") {
        valueLength = Buffer.byteLength(value);
      }
      this._valueLength += valueLength;
      this._overheadLength += Buffer.byteLength(header) + FormData2.LINE_BREAK.length;
      if (!value || !value.path && !(value.readable && hasOwn(value, "httpVersion")) && !(value instanceof Stream)) {
        return;
      }
      if (!options.knownLength) {
        this._valuesToMeasure.push(value);
      }
    };
    FormData2.prototype._lengthRetriever = function(value, callback) {
      if (hasOwn(value, "fd")) {
        if (value.end != void 0 && value.end != Infinity && value.start != void 0) {
          callback(null, value.end + 1 - (value.start ? value.start : 0));
        } else {
          fs.stat(value.path, function(err, stat) {
            if (err) {
              callback(err);
              return;
            }
            var fileSize = stat.size - (value.start ? value.start : 0);
            callback(null, fileSize);
          });
        }
      } else if (hasOwn(value, "httpVersion")) {
        callback(null, Number(value.headers["content-length"]));
      } else if (hasOwn(value, "httpModule")) {
        value.on("response", function(response) {
          value.pause();
          callback(null, Number(response.headers["content-length"]));
        });
        value.resume();
      } else {
        callback("Unknown stream");
      }
    };
    FormData2.prototype._multiPartHeader = function(field, value, options) {
      if (typeof options.header === "string") {
        return options.header;
      }
      var contentDisposition = this._getContentDisposition(value, options);
      var contentType = this._getContentType(value, options);
      var contents = "";
      var headers = {
        // add custom disposition as third element or keep it two elements if not
        "Content-Disposition": ["form-data", 'name="' + field + '"'].concat(contentDisposition || []),
        // if no content type. allow it to be empty array
        "Content-Type": [].concat(contentType || [])
      };
      if (typeof options.header === "object") {
        populate(headers, options.header);
      }
      var header;
      for (var prop in headers) {
        if (hasOwn(headers, prop)) {
          header = headers[prop];
          if (header == null) {
            continue;
          }
          if (!Array.isArray(header)) {
            header = [header];
          }
          if (header.length) {
            contents += prop + ": " + header.join("; ") + FormData2.LINE_BREAK;
          }
        }
      }
      return "--" + this.getBoundary() + FormData2.LINE_BREAK + contents + FormData2.LINE_BREAK;
    };
    FormData2.prototype._getContentDisposition = function(value, options) {
      var filename;
      if (typeof options.filepath === "string") {
        filename = path.normalize(options.filepath).replace(/\\/g, "/");
      } else if (options.filename || value && (value.name || value.path)) {
        filename = path.basename(options.filename || value && (value.name || value.path));
      } else if (value && value.readable && hasOwn(value, "httpVersion")) {
        filename = path.basename(value.client._httpMessage.path || "");
      }
      if (filename) {
        return 'filename="' + filename + '"';
      }
    };
    FormData2.prototype._getContentType = function(value, options) {
      var contentType = options.contentType;
      if (!contentType && value && value.name) {
        contentType = mime.lookup(value.name);
      }
      if (!contentType && value && value.path) {
        contentType = mime.lookup(value.path);
      }
      if (!contentType && value && value.readable && hasOwn(value, "httpVersion")) {
        contentType = value.headers["content-type"];
      }
      if (!contentType && (options.filepath || options.filename)) {
        contentType = mime.lookup(options.filepath || options.filename);
      }
      if (!contentType && value && typeof value === "object") {
        contentType = FormData2.DEFAULT_CONTENT_TYPE;
      }
      return contentType;
    };
    FormData2.prototype._multiPartFooter = function() {
      return function(next) {
        var footer = FormData2.LINE_BREAK;
        var lastPart = this._streams.length === 0;
        if (lastPart) {
          footer += this._lastBoundary();
        }
        next(footer);
      }.bind(this);
    };
    FormData2.prototype._lastBoundary = function() {
      return "--" + this.getBoundary() + "--" + FormData2.LINE_BREAK;
    };
    FormData2.prototype.getHeaders = function(userHeaders) {
      var header;
      var formHeaders = {
        "content-type": "multipart/form-data; boundary=" + this.getBoundary()
      };
      for (header in userHeaders) {
        if (hasOwn(userHeaders, header)) {
          formHeaders[header.toLowerCase()] = userHeaders[header];
        }
      }
      return formHeaders;
    };
    FormData2.prototype.setBoundary = function(boundary) {
      if (typeof boundary !== "string") {
        throw new TypeError("FormData boundary must be a string");
      }
      this._boundary = boundary;
    };
    FormData2.prototype.getBoundary = function() {
      if (!this._boundary) {
        this._generateBoundary();
      }
      return this._boundary;
    };
    FormData2.prototype.getBuffer = function() {
      var dataBuffer = new Buffer.alloc(0);
      var boundary = this.getBoundary();
      for (var i = 0, len = this._streams.length; i < len; i++) {
        if (typeof this._streams[i] !== "function") {
          if (Buffer.isBuffer(this._streams[i])) {
            dataBuffer = Buffer.concat([dataBuffer, this._streams[i]]);
          } else {
            dataBuffer = Buffer.concat([dataBuffer, Buffer.from(this._streams[i])]);
          }
          if (typeof this._streams[i] !== "string" || this._streams[i].substring(2, boundary.length + 2) !== boundary) {
            dataBuffer = Buffer.concat([dataBuffer, Buffer.from(FormData2.LINE_BREAK)]);
          }
        }
      }
      return Buffer.concat([dataBuffer, Buffer.from(this._lastBoundary())]);
    };
    FormData2.prototype._generateBoundary = function() {
      this._boundary = "--------------------------" + crypto2.randomBytes(12).toString("hex");
    };
    FormData2.prototype.getLengthSync = function() {
      var knownLength = this._overheadLength + this._valueLength;
      if (this._streams.length) {
        knownLength += this._lastBoundary().length;
      }
      if (!this.hasKnownLength()) {
        this._error(new Error("Cannot calculate proper length in synchronous way."));
      }
      return knownLength;
    };
    FormData2.prototype.hasKnownLength = function() {
      var hasKnownLength = true;
      if (this._valuesToMeasure.length) {
        hasKnownLength = false;
      }
      return hasKnownLength;
    };
    FormData2.prototype.getLength = function(cb) {
      var knownLength = this._overheadLength + this._valueLength;
      if (this._streams.length) {
        knownLength += this._lastBoundary().length;
      }
      if (!this._valuesToMeasure.length) {
        process.nextTick(cb.bind(this, null, knownLength));
        return;
      }
      asynckit.parallel(this._valuesToMeasure, this._lengthRetriever, function(err, values) {
        if (err) {
          cb(err);
          return;
        }
        values.forEach(function(length) {
          knownLength += length;
        });
        cb(null, knownLength);
      });
    };
    FormData2.prototype.submit = function(params, cb) {
      var request;
      var options;
      var defaults = { method: "post" };
      if (typeof params === "string") {
        params = parseUrl(params);
        options = populate({
          port: params.port,
          path: params.pathname,
          host: params.hostname,
          protocol: params.protocol
        }, defaults);
      } else {
        options = populate(params, defaults);
        if (!options.port) {
          options.port = options.protocol === "https:" ? 443 : 80;
        }
      }
      options.headers = this.getHeaders(params.headers);
      if (options.protocol === "https:") {
        request = https.request(options);
      } else {
        request = http.request(options);
      }
      this.getLength(function(err, length) {
        if (err && err !== "Unknown stream") {
          this._error(err);
          return;
        }
        if (length) {
          request.setHeader("Content-Length", length);
        }
        this.pipe(request);
        if (cb) {
          var onResponse;
          var callback = function(error, responce) {
            request.removeListener("error", callback);
            request.removeListener("response", onResponse);
            return cb.call(this, error, responce);
          };
          onResponse = callback.bind(this, null);
          request.on("error", callback);
          request.on("response", onResponse);
        }
      }.bind(this));
      return request;
    };
    FormData2.prototype._error = function(err) {
      if (!this.error) {
        this.error = err;
        this.pause();
        this.emit("error", err);
      }
    };
    FormData2.prototype.toString = function() {
      return "[object FormData]";
    };
    setToStringTag(FormData2.prototype, "FormData");
    module2.exports = FormData2;
  }
});

// node_modules/proxy-from-env/index.js
var require_proxy_from_env = __commonJS({
  "node_modules/proxy-from-env/index.js"(exports2) {
    "use strict";
    var parseUrl = require("url").parse;
    var DEFAULT_PORTS = {
      ftp: 21,
      gopher: 70,
      http: 80,
      https: 443,
      ws: 80,
      wss: 443
    };
    var stringEndsWith = String.prototype.endsWith || function(s) {
      return s.length <= this.length && this.indexOf(s, this.length - s.length) !== -1;
    };
    function getProxyForUrl(url) {
      var parsedUrl = typeof url === "string" ? parseUrl(url) : url || {};
      var proto = parsedUrl.protocol;
      var hostname = parsedUrl.host;
      var port = parsedUrl.port;
      if (typeof hostname !== "string" || !hostname || typeof proto !== "string") {
        return "";
      }
      proto = proto.split(":", 1)[0];
      hostname = hostname.replace(/:\d*$/, "");
      port = parseInt(port) || DEFAULT_PORTS[proto] || 0;
      if (!shouldProxy(hostname, port)) {
        return "";
      }
      var proxy = getEnv("npm_config_" + proto + "_proxy") || getEnv(proto + "_proxy") || getEnv("npm_config_proxy") || getEnv("all_proxy");
      if (proxy && proxy.indexOf("://") === -1) {
        proxy = proto + "://" + proxy;
      }
      return proxy;
    }
    function shouldProxy(hostname, port) {
      var NO_PROXY = (getEnv("npm_config_no_proxy") || getEnv("no_proxy")).toLowerCase();
      if (!NO_PROXY) {
        return true;
      }
      if (NO_PROXY === "*") {
        return false;
      }
      return NO_PROXY.split(/[,\s]/).every(function(proxy) {
        if (!proxy) {
          return true;
        }
        var parsedProxy = proxy.match(/^(.+):(\d+)$/);
        var parsedProxyHostname = parsedProxy ? parsedProxy[1] : proxy;
        var parsedProxyPort = parsedProxy ? parseInt(parsedProxy[2]) : 0;
        if (parsedProxyPort && parsedProxyPort !== port) {
          return true;
        }
        if (!/^[.*]/.test(parsedProxyHostname)) {
          return hostname !== parsedProxyHostname;
        }
        if (parsedProxyHostname.charAt(0) === "*") {
          parsedProxyHostname = parsedProxyHostname.slice(1);
        }
        return !stringEndsWith.call(hostname, parsedProxyHostname);
      });
    }
    function getEnv(key) {
      return process.env[key.toLowerCase()] || process.env[key.toUpperCase()] || "";
    }
    exports2.getProxyForUrl = getProxyForUrl;
  }
});

// node_modules/ms/index.js
var require_ms = __commonJS({
  "node_modules/ms/index.js"(exports2, module2) {
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var y = d * 365.25;
    module2.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse(val);
      } else if (type === "number" && isNaN(val) === false) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse(str2) {
      str2 = String(str2);
      if (str2.length > 100) {
        return;
      }
      var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(
        str2
      );
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      if (ms >= d) {
        return Math.round(ms / d) + "d";
      }
      if (ms >= h) {
        return Math.round(ms / h) + "h";
      }
      if (ms >= m) {
        return Math.round(ms / m) + "m";
      }
      if (ms >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      return plural(ms, d, "day") || plural(ms, h, "hour") || plural(ms, m, "minute") || plural(ms, s, "second") || ms + " ms";
    }
    function plural(ms, n, name) {
      if (ms < n) {
        return;
      }
      if (ms < n * 1.5) {
        return Math.floor(ms / n) + " " + name;
      }
      return Math.ceil(ms / n) + " " + name + "s";
    }
  }
});

// node_modules/debug/src/debug.js
var require_debug = __commonJS({
  "node_modules/debug/src/debug.js"(exports2, module2) {
    exports2 = module2.exports = createDebug.debug = createDebug["default"] = createDebug;
    exports2.coerce = coerce;
    exports2.disable = disable;
    exports2.enable = enable;
    exports2.enabled = enabled;
    exports2.humanize = require_ms();
    exports2.names = [];
    exports2.skips = [];
    exports2.formatters = {};
    var prevTime;
    function selectColor(namespace) {
      var hash = 0, i;
      for (i in namespace) {
        hash = (hash << 5) - hash + namespace.charCodeAt(i);
        hash |= 0;
      }
      return exports2.colors[Math.abs(hash) % exports2.colors.length];
    }
    function createDebug(namespace) {
      function debug() {
        if (!debug.enabled)
          return;
        var self2 = debug;
        var curr = +/* @__PURE__ */ new Date();
        var ms = curr - (prevTime || curr);
        self2.diff = ms;
        self2.prev = prevTime;
        self2.curr = curr;
        prevTime = curr;
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i];
        }
        args[0] = exports2.coerce(args[0]);
        if ("string" !== typeof args[0]) {
          args.unshift("%O");
        }
        var index = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {
          if (match === "%%")
            return match;
          index++;
          var formatter = exports2.formatters[format];
          if ("function" === typeof formatter) {
            var val = args[index];
            match = formatter.call(self2, val);
            args.splice(index, 1);
            index--;
          }
          return match;
        });
        exports2.formatArgs.call(self2, args);
        var logFn = debug.log || exports2.log || console.log.bind(console);
        logFn.apply(self2, args);
      }
      debug.namespace = namespace;
      debug.enabled = exports2.enabled(namespace);
      debug.useColors = exports2.useColors();
      debug.color = selectColor(namespace);
      if ("function" === typeof exports2.init) {
        exports2.init(debug);
      }
      return debug;
    }
    function enable(namespaces) {
      exports2.save(namespaces);
      exports2.names = [];
      exports2.skips = [];
      var split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
      var len = split.length;
      for (var i = 0; i < len; i++) {
        if (!split[i])
          continue;
        namespaces = split[i].replace(/\*/g, ".*?");
        if (namespaces[0] === "-") {
          exports2.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
        } else {
          exports2.names.push(new RegExp("^" + namespaces + "$"));
        }
      }
    }
    function disable() {
      exports2.enable("");
    }
    function enabled(name) {
      var i, len;
      for (i = 0, len = exports2.skips.length; i < len; i++) {
        if (exports2.skips[i].test(name)) {
          return false;
        }
      }
      for (i = 0, len = exports2.names.length; i < len; i++) {
        if (exports2.names[i].test(name)) {
          return true;
        }
      }
      return false;
    }
    function coerce(val) {
      if (val instanceof Error)
        return val.stack || val.message;
      return val;
    }
  }
});

// node_modules/debug/src/browser.js
var require_browser = __commonJS({
  "node_modules/debug/src/browser.js"(exports2, module2) {
    exports2 = module2.exports = require_debug();
    exports2.log = log3;
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.storage = "undefined" != typeof chrome && "undefined" != typeof chrome.storage ? chrome.storage.local : localstorage();
    exports2.colors = [
      "lightseagreen",
      "forestgreen",
      "goldenrod",
      "dodgerblue",
      "darkorchid",
      "crimson"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && window.process.type === "renderer") {
        return true;
      }
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    exports2.formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (err) {
        return "[UnexpectedJSONParseError]: " + err.message;
      }
    };
    function formatArgs(args) {
      var useColors2 = this.useColors;
      args[0] = (useColors2 ? "%c" : "") + this.namespace + (useColors2 ? " %c" : " ") + args[0] + (useColors2 ? "%c " : " ") + "+" + exports2.humanize(this.diff);
      if (!useColors2)
        return;
      var c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      var index = 0;
      var lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, function(match) {
        if ("%%" === match)
          return;
        index++;
        if ("%c" === match) {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }
    function log3() {
      return "object" === typeof console && console.log && Function.prototype.apply.call(console.log, console, arguments);
    }
    function save(namespaces) {
      try {
        if (null == namespaces) {
          exports2.storage.removeItem("debug");
        } else {
          exports2.storage.debug = namespaces;
        }
      } catch (e) {
      }
    }
    function load() {
      var r;
      try {
        r = exports2.storage.debug;
      } catch (e) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    exports2.enable(load());
    function localstorage() {
      try {
        return window.localStorage;
      } catch (e) {
      }
    }
  }
});

// node_modules/debug/src/node.js
var require_node = __commonJS({
  "node_modules/debug/src/node.js"(exports2, module2) {
    var tty = require("tty");
    var util = require("util");
    exports2 = module2.exports = require_debug();
    exports2.init = init;
    exports2.log = log3;
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.colors = [6, 2, 3, 4, 5, 1];
    exports2.inspectOpts = Object.keys(process.env).filter(function(key) {
      return /^debug_/i.test(key);
    }).reduce(function(obj, key) {
      var prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, function(_, k) {
        return k.toUpperCase();
      });
      var val = process.env[key];
      if (/^(yes|on|true|enabled)$/i.test(val))
        val = true;
      else if (/^(no|off|false|disabled)$/i.test(val))
        val = false;
      else if (val === "null")
        val = null;
      else
        val = Number(val);
      obj[prop] = val;
      return obj;
    }, {});
    var fd = parseInt(process.env.DEBUG_FD, 10) || 2;
    if (1 !== fd && 2 !== fd) {
      util.deprecate(function() {
      }, "except for stderr(2) and stdout(1), any other usage of DEBUG_FD is deprecated. Override debug.log if you want to use a different log function (https://git.io/debug_fd)")();
    }
    var stream = 1 === fd ? process.stdout : 2 === fd ? process.stderr : createWritableStdioStream(fd);
    function useColors() {
      return "colors" in exports2.inspectOpts ? Boolean(exports2.inspectOpts.colors) : tty.isatty(fd);
    }
    exports2.formatters.o = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts).split("\n").map(function(str2) {
        return str2.trim();
      }).join(" ");
    };
    exports2.formatters.O = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts);
    };
    function formatArgs(args) {
      var name = this.namespace;
      var useColors2 = this.useColors;
      if (useColors2) {
        var c = this.color;
        var prefix = "  \x1B[3" + c + ";1m" + name + " \x1B[0m";
        args[0] = prefix + args[0].split("\n").join("\n" + prefix);
        args.push("\x1B[3" + c + "m+" + exports2.humanize(this.diff) + "\x1B[0m");
      } else {
        args[0] = (/* @__PURE__ */ new Date()).toUTCString() + " " + name + " " + args[0];
      }
    }
    function log3() {
      return stream.write(util.format.apply(util, arguments) + "\n");
    }
    function save(namespaces) {
      if (null == namespaces) {
        delete process.env.DEBUG;
      } else {
        process.env.DEBUG = namespaces;
      }
    }
    function load() {
      return process.env.DEBUG;
    }
    function createWritableStdioStream(fd2) {
      var stream2;
      var tty_wrap = process.binding("tty_wrap");
      switch (tty_wrap.guessHandleType(fd2)) {
        case "TTY":
          stream2 = new tty.WriteStream(fd2);
          stream2._type = "tty";
          if (stream2._handle && stream2._handle.unref) {
            stream2._handle.unref();
          }
          break;
        case "FILE":
          var fs = require("fs");
          stream2 = new fs.SyncWriteStream(fd2, { autoClose: false });
          stream2._type = "fs";
          break;
        case "PIPE":
        case "TCP":
          var net = require("net");
          stream2 = new net.Socket({
            fd: fd2,
            readable: false,
            writable: true
          });
          stream2.readable = false;
          stream2.read = null;
          stream2._type = "pipe";
          if (stream2._handle && stream2._handle.unref) {
            stream2._handle.unref();
          }
          break;
        default:
          throw new Error("Implement me. Unknown stream file type!");
      }
      stream2.fd = fd2;
      stream2._isStdio = true;
      return stream2;
    }
    function init(debug) {
      debug.inspectOpts = {};
      var keys = Object.keys(exports2.inspectOpts);
      for (var i = 0; i < keys.length; i++) {
        debug.inspectOpts[keys[i]] = exports2.inspectOpts[keys[i]];
      }
    }
    exports2.enable(load());
  }
});

// node_modules/debug/src/index.js
var require_src = __commonJS({
  "node_modules/debug/src/index.js"(exports2, module2) {
    if (typeof process !== "undefined" && process.type === "renderer") {
      module2.exports = require_browser();
    } else {
      module2.exports = require_node();
    }
  }
});

// node_modules/follow-redirects/debug.js
var require_debug2 = __commonJS({
  "node_modules/follow-redirects/debug.js"(exports2, module2) {
    var debug;
    module2.exports = function() {
      if (!debug) {
        try {
          debug = require_src()("follow-redirects");
        } catch (error) {
        }
        if (typeof debug !== "function") {
          debug = function() {
          };
        }
      }
      debug.apply(null, arguments);
    };
  }
});

// node_modules/follow-redirects/index.js
var require_follow_redirects = __commonJS({
  "node_modules/follow-redirects/index.js"(exports2, module2) {
    var url = require("url");
    var URL2 = url.URL;
    var http = require("http");
    var https = require("https");
    var Writable = require("stream").Writable;
    var assert = require("assert");
    var debug = require_debug2();
    (function detectUnsupportedEnvironment() {
      var looksLikeNode = typeof process !== "undefined";
      var looksLikeBrowser = typeof window !== "undefined" && typeof document !== "undefined";
      var looksLikeV8 = isFunction(Error.captureStackTrace);
      if (!looksLikeNode && (looksLikeBrowser || !looksLikeV8)) {
        console.warn("The follow-redirects package should be excluded from browser builds.");
      }
    })();
    var useNativeURL = false;
    try {
      assert(new URL2(""));
    } catch (error) {
      useNativeURL = error.code === "ERR_INVALID_URL";
    }
    var preservedUrlFields = [
      "auth",
      "host",
      "hostname",
      "href",
      "path",
      "pathname",
      "port",
      "protocol",
      "query",
      "search",
      "hash"
    ];
    var events = ["abort", "aborted", "connect", "error", "socket", "timeout"];
    var eventHandlers = /* @__PURE__ */ Object.create(null);
    events.forEach(function(event) {
      eventHandlers[event] = function(arg1, arg2, arg3) {
        this._redirectable.emit(event, arg1, arg2, arg3);
      };
    });
    var InvalidUrlError = createErrorType(
      "ERR_INVALID_URL",
      "Invalid URL",
      TypeError
    );
    var RedirectionError = createErrorType(
      "ERR_FR_REDIRECTION_FAILURE",
      "Redirected request failed"
    );
    var TooManyRedirectsError = createErrorType(
      "ERR_FR_TOO_MANY_REDIRECTS",
      "Maximum number of redirects exceeded",
      RedirectionError
    );
    var MaxBodyLengthExceededError = createErrorType(
      "ERR_FR_MAX_BODY_LENGTH_EXCEEDED",
      "Request body larger than maxBodyLength limit"
    );
    var WriteAfterEndError = createErrorType(
      "ERR_STREAM_WRITE_AFTER_END",
      "write after end"
    );
    var destroy = Writable.prototype.destroy || noop;
    function RedirectableRequest(options, responseCallback) {
      Writable.call(this);
      this._sanitizeOptions(options);
      this._options = options;
      this._ended = false;
      this._ending = false;
      this._redirectCount = 0;
      this._redirects = [];
      this._requestBodyLength = 0;
      this._requestBodyBuffers = [];
      if (responseCallback) {
        this.on("response", responseCallback);
      }
      var self2 = this;
      this._onNativeResponse = function(response) {
        try {
          self2._processResponse(response);
        } catch (cause) {
          self2.emit("error", cause instanceof RedirectionError ? cause : new RedirectionError({ cause }));
        }
      };
      this._performRequest();
    }
    RedirectableRequest.prototype = Object.create(Writable.prototype);
    RedirectableRequest.prototype.abort = function() {
      destroyRequest(this._currentRequest);
      this._currentRequest.abort();
      this.emit("abort");
    };
    RedirectableRequest.prototype.destroy = function(error) {
      destroyRequest(this._currentRequest, error);
      destroy.call(this, error);
      return this;
    };
    RedirectableRequest.prototype.write = function(data, encoding, callback) {
      if (this._ending) {
        throw new WriteAfterEndError();
      }
      if (!isString(data) && !isBuffer(data)) {
        throw new TypeError("data should be a string, Buffer or Uint8Array");
      }
      if (isFunction(encoding)) {
        callback = encoding;
        encoding = null;
      }
      if (data.length === 0) {
        if (callback) {
          callback();
        }
        return;
      }
      if (this._requestBodyLength + data.length <= this._options.maxBodyLength) {
        this._requestBodyLength += data.length;
        this._requestBodyBuffers.push({ data, encoding });
        this._currentRequest.write(data, encoding, callback);
      } else {
        this.emit("error", new MaxBodyLengthExceededError());
        this.abort();
      }
    };
    RedirectableRequest.prototype.end = function(data, encoding, callback) {
      if (isFunction(data)) {
        callback = data;
        data = encoding = null;
      } else if (isFunction(encoding)) {
        callback = encoding;
        encoding = null;
      }
      if (!data) {
        this._ended = this._ending = true;
        this._currentRequest.end(null, null, callback);
      } else {
        var self2 = this;
        var currentRequest = this._currentRequest;
        this.write(data, encoding, function() {
          self2._ended = true;
          currentRequest.end(null, null, callback);
        });
        this._ending = true;
      }
    };
    RedirectableRequest.prototype.setHeader = function(name, value) {
      this._options.headers[name] = value;
      this._currentRequest.setHeader(name, value);
    };
    RedirectableRequest.prototype.removeHeader = function(name) {
      delete this._options.headers[name];
      this._currentRequest.removeHeader(name);
    };
    RedirectableRequest.prototype.setTimeout = function(msecs, callback) {
      var self2 = this;
      function destroyOnTimeout(socket) {
        socket.setTimeout(msecs);
        socket.removeListener("timeout", socket.destroy);
        socket.addListener("timeout", socket.destroy);
      }
      function startTimer(socket) {
        if (self2._timeout) {
          clearTimeout(self2._timeout);
        }
        self2._timeout = setTimeout(function() {
          self2.emit("timeout");
          clearTimer();
        }, msecs);
        destroyOnTimeout(socket);
      }
      function clearTimer() {
        if (self2._timeout) {
          clearTimeout(self2._timeout);
          self2._timeout = null;
        }
        self2.removeListener("abort", clearTimer);
        self2.removeListener("error", clearTimer);
        self2.removeListener("response", clearTimer);
        self2.removeListener("close", clearTimer);
        if (callback) {
          self2.removeListener("timeout", callback);
        }
        if (!self2.socket) {
          self2._currentRequest.removeListener("socket", startTimer);
        }
      }
      if (callback) {
        this.on("timeout", callback);
      }
      if (this.socket) {
        startTimer(this.socket);
      } else {
        this._currentRequest.once("socket", startTimer);
      }
      this.on("socket", destroyOnTimeout);
      this.on("abort", clearTimer);
      this.on("error", clearTimer);
      this.on("response", clearTimer);
      this.on("close", clearTimer);
      return this;
    };
    [
      "flushHeaders",
      "getHeader",
      "setNoDelay",
      "setSocketKeepAlive"
    ].forEach(function(method) {
      RedirectableRequest.prototype[method] = function(a, b) {
        return this._currentRequest[method](a, b);
      };
    });
    ["aborted", "connection", "socket"].forEach(function(property) {
      Object.defineProperty(RedirectableRequest.prototype, property, {
        get: function() {
          return this._currentRequest[property];
        }
      });
    });
    RedirectableRequest.prototype._sanitizeOptions = function(options) {
      if (!options.headers) {
        options.headers = {};
      }
      if (options.host) {
        if (!options.hostname) {
          options.hostname = options.host;
        }
        delete options.host;
      }
      if (!options.pathname && options.path) {
        var searchPos = options.path.indexOf("?");
        if (searchPos < 0) {
          options.pathname = options.path;
        } else {
          options.pathname = options.path.substring(0, searchPos);
          options.search = options.path.substring(searchPos);
        }
      }
    };
    RedirectableRequest.prototype._performRequest = function() {
      var protocol = this._options.protocol;
      var nativeProtocol = this._options.nativeProtocols[protocol];
      if (!nativeProtocol) {
        throw new TypeError("Unsupported protocol " + protocol);
      }
      if (this._options.agents) {
        var scheme = protocol.slice(0, -1);
        this._options.agent = this._options.agents[scheme];
      }
      var request = this._currentRequest = nativeProtocol.request(this._options, this._onNativeResponse);
      request._redirectable = this;
      for (var event of events) {
        request.on(event, eventHandlers[event]);
      }
      this._currentUrl = /^\//.test(this._options.path) ? url.format(this._options) : (
        // When making a request to a proxy, []
        // a client MUST send the target URI in absolute-form [].
        this._options.path
      );
      if (this._isRedirect) {
        var i = 0;
        var self2 = this;
        var buffers = this._requestBodyBuffers;
        (function writeNext(error) {
          if (request === self2._currentRequest) {
            if (error) {
              self2.emit("error", error);
            } else if (i < buffers.length) {
              var buffer = buffers[i++];
              if (!request.finished) {
                request.write(buffer.data, buffer.encoding, writeNext);
              }
            } else if (self2._ended) {
              request.end();
            }
          }
        })();
      }
    };
    RedirectableRequest.prototype._processResponse = function(response) {
      var statusCode = response.statusCode;
      if (this._options.trackRedirects) {
        this._redirects.push({
          url: this._currentUrl,
          headers: response.headers,
          statusCode
        });
      }
      var location = response.headers.location;
      if (!location || this._options.followRedirects === false || statusCode < 300 || statusCode >= 400) {
        response.responseUrl = this._currentUrl;
        response.redirects = this._redirects;
        this.emit("response", response);
        this._requestBodyBuffers = [];
        return;
      }
      destroyRequest(this._currentRequest);
      response.destroy();
      if (++this._redirectCount > this._options.maxRedirects) {
        throw new TooManyRedirectsError();
      }
      var requestHeaders;
      var beforeRedirect = this._options.beforeRedirect;
      if (beforeRedirect) {
        requestHeaders = Object.assign({
          // The Host header was set by nativeProtocol.request
          Host: response.req.getHeader("host")
        }, this._options.headers);
      }
      var method = this._options.method;
      if ((statusCode === 301 || statusCode === 302) && this._options.method === "POST" || // RFC72316.4.4: The 303 (See Other) status code indicates that
      // the server is redirecting the user agent to a different resource []
      // A user agent can perform a retrieval request targeting that URI
      // (a GET or HEAD request if using HTTP) []
      statusCode === 303 && !/^(?:GET|HEAD)$/.test(this._options.method)) {
        this._options.method = "GET";
        this._requestBodyBuffers = [];
        removeMatchingHeaders(/^content-/i, this._options.headers);
      }
      var currentHostHeader = removeMatchingHeaders(/^host$/i, this._options.headers);
      var currentUrlParts = parseUrl(this._currentUrl);
      var currentHost = currentHostHeader || currentUrlParts.host;
      var currentUrl = /^\w+:/.test(location) ? this._currentUrl : url.format(Object.assign(currentUrlParts, { host: currentHost }));
      var redirectUrl = resolveUrl(location, currentUrl);
      debug("redirecting to", redirectUrl.href);
      this._isRedirect = true;
      spreadUrlObject(redirectUrl, this._options);
      if (redirectUrl.protocol !== currentUrlParts.protocol && redirectUrl.protocol !== "https:" || redirectUrl.host !== currentHost && !isSubdomain(redirectUrl.host, currentHost)) {
        removeMatchingHeaders(/^(?:(?:proxy-)?authorization|cookie)$/i, this._options.headers);
      }
      if (isFunction(beforeRedirect)) {
        var responseDetails = {
          headers: response.headers,
          statusCode
        };
        var requestDetails = {
          url: currentUrl,
          method,
          headers: requestHeaders
        };
        beforeRedirect(this._options, responseDetails, requestDetails);
        this._sanitizeOptions(this._options);
      }
      this._performRequest();
    };
    function wrap(protocols) {
      var exports3 = {
        maxRedirects: 21,
        maxBodyLength: 10 * 1024 * 1024
      };
      var nativeProtocols = {};
      Object.keys(protocols).forEach(function(scheme) {
        var protocol = scheme + ":";
        var nativeProtocol = nativeProtocols[protocol] = protocols[scheme];
        var wrappedProtocol = exports3[scheme] = Object.create(nativeProtocol);
        function request(input, options, callback) {
          if (isURL(input)) {
            input = spreadUrlObject(input);
          } else if (isString(input)) {
            input = spreadUrlObject(parseUrl(input));
          } else {
            callback = options;
            options = validateUrl(input);
            input = { protocol };
          }
          if (isFunction(options)) {
            callback = options;
            options = null;
          }
          options = Object.assign({
            maxRedirects: exports3.maxRedirects,
            maxBodyLength: exports3.maxBodyLength
          }, input, options);
          options.nativeProtocols = nativeProtocols;
          if (!isString(options.host) && !isString(options.hostname)) {
            options.hostname = "::1";
          }
          assert.equal(options.protocol, protocol, "protocol mismatch");
          debug("options", options);
          return new RedirectableRequest(options, callback);
        }
        function get(input, options, callback) {
          var wrappedRequest = wrappedProtocol.request(input, options, callback);
          wrappedRequest.end();
          return wrappedRequest;
        }
        Object.defineProperties(wrappedProtocol, {
          request: { value: request, configurable: true, enumerable: true, writable: true },
          get: { value: get, configurable: true, enumerable: true, writable: true }
        });
      });
      return exports3;
    }
    function noop() {
    }
    function parseUrl(input) {
      var parsed;
      if (useNativeURL) {
        parsed = new URL2(input);
      } else {
        parsed = validateUrl(url.parse(input));
        if (!isString(parsed.protocol)) {
          throw new InvalidUrlError({ input });
        }
      }
      return parsed;
    }
    function resolveUrl(relative, base) {
      return useNativeURL ? new URL2(relative, base) : parseUrl(url.resolve(base, relative));
    }
    function validateUrl(input) {
      if (/^\[/.test(input.hostname) && !/^\[[:0-9a-f]+\]$/i.test(input.hostname)) {
        throw new InvalidUrlError({ input: input.href || input });
      }
      if (/^\[/.test(input.host) && !/^\[[:0-9a-f]+\](:\d+)?$/i.test(input.host)) {
        throw new InvalidUrlError({ input: input.href || input });
      }
      return input;
    }
    function spreadUrlObject(urlObject, target) {
      var spread = target || {};
      for (var key of preservedUrlFields) {
        spread[key] = urlObject[key];
      }
      if (spread.hostname.startsWith("[")) {
        spread.hostname = spread.hostname.slice(1, -1);
      }
      if (spread.port !== "") {
        spread.port = Number(spread.port);
      }
      spread.path = spread.search ? spread.pathname + spread.search : spread.pathname;
      return spread;
    }
    function removeMatchingHeaders(regex, headers) {
      var lastValue;
      for (var header in headers) {
        if (regex.test(header)) {
          lastValue = headers[header];
          delete headers[header];
        }
      }
      return lastValue === null || typeof lastValue === "undefined" ? void 0 : String(lastValue).trim();
    }
    function createErrorType(code, message, baseClass) {
      function CustomError(properties) {
        if (isFunction(Error.captureStackTrace)) {
          Error.captureStackTrace(this, this.constructor);
        }
        Object.assign(this, properties || {});
        this.code = code;
        this.message = this.cause ? message + ": " + this.cause.message : message;
      }
      CustomError.prototype = new (baseClass || Error)();
      Object.defineProperties(CustomError.prototype, {
        constructor: {
          value: CustomError,
          enumerable: false
        },
        name: {
          value: "Error [" + code + "]",
          enumerable: false
        }
      });
      return CustomError;
    }
    function destroyRequest(request, error) {
      for (var event of events) {
        request.removeListener(event, eventHandlers[event]);
      }
      request.on("error", noop);
      request.destroy(error);
    }
    function isSubdomain(subdomain, domain) {
      assert(isString(subdomain) && isString(domain));
      var dot = subdomain.length - domain.length - 1;
      return dot > 0 && subdomain[dot] === "." && subdomain.endsWith(domain);
    }
    function isString(value) {
      return typeof value === "string" || value instanceof String;
    }
    function isFunction(value) {
      return typeof value === "function";
    }
    function isBuffer(value) {
      return typeof value === "object" && "length" in value;
    }
    function isURL(value) {
      return URL2 && value instanceof URL2;
    }
    module2.exports = wrap({ http, https });
    module2.exports.wrap = wrap;
  }
});

// node_modules/axios/dist/node/axios.cjs
var require_axios = __commonJS({
  "node_modules/axios/dist/node/axios.cjs"(exports2, module2) {
    "use strict";
    var FormData$1 = require_form_data();
    var crypto2 = require("crypto");
    var url = require("url");
    var proxyFromEnv = require_proxy_from_env();
    var http = require("http");
    var https = require("https");
    var http2 = require("http2");
    var util = require("util");
    var followRedirects = require_follow_redirects();
    var zlib = require("zlib");
    var stream = require("stream");
    var events = require("events");
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e : { "default": e };
    }
    var FormData__default = /* @__PURE__ */ _interopDefaultLegacy(FormData$1);
    var crypto__default = /* @__PURE__ */ _interopDefaultLegacy(crypto2);
    var url__default = /* @__PURE__ */ _interopDefaultLegacy(url);
    var proxyFromEnv__default = /* @__PURE__ */ _interopDefaultLegacy(proxyFromEnv);
    var http__default = /* @__PURE__ */ _interopDefaultLegacy(http);
    var https__default = /* @__PURE__ */ _interopDefaultLegacy(https);
    var http2__default = /* @__PURE__ */ _interopDefaultLegacy(http2);
    var util__default = /* @__PURE__ */ _interopDefaultLegacy(util);
    var followRedirects__default = /* @__PURE__ */ _interopDefaultLegacy(followRedirects);
    var zlib__default = /* @__PURE__ */ _interopDefaultLegacy(zlib);
    var stream__default = /* @__PURE__ */ _interopDefaultLegacy(stream);
    function bind(fn, thisArg) {
      return function wrap() {
        return fn.apply(thisArg, arguments);
      };
    }
    var { toString } = Object.prototype;
    var { getPrototypeOf } = Object;
    var { iterator, toStringTag } = Symbol;
    var kindOf = /* @__PURE__ */ ((cache) => (thing) => {
      const str2 = toString.call(thing);
      return cache[str2] || (cache[str2] = str2.slice(8, -1).toLowerCase());
    })(/* @__PURE__ */ Object.create(null));
    var kindOfTest = (type) => {
      type = type.toLowerCase();
      return (thing) => kindOf(thing) === type;
    };
    var typeOfTest = (type) => (thing) => typeof thing === type;
    var { isArray } = Array;
    var isUndefined = typeOfTest("undefined");
    function isBuffer(val) {
      return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && isFunction$1(val.constructor.isBuffer) && val.constructor.isBuffer(val);
    }
    var isArrayBuffer = kindOfTest("ArrayBuffer");
    function isArrayBufferView(val) {
      let result;
      if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
        result = ArrayBuffer.isView(val);
      } else {
        result = val && val.buffer && isArrayBuffer(val.buffer);
      }
      return result;
    }
    var isString = typeOfTest("string");
    var isFunction$1 = typeOfTest("function");
    var isNumber2 = typeOfTest("number");
    var isObject = (thing) => thing !== null && typeof thing === "object";
    var isBoolean = (thing) => thing === true || thing === false;
    var isPlainObject = (val) => {
      if (kindOf(val) !== "object") {
        return false;
      }
      const prototype2 = getPrototypeOf(val);
      return (prototype2 === null || prototype2 === Object.prototype || Object.getPrototypeOf(prototype2) === null) && !(toStringTag in val) && !(iterator in val);
    };
    var isEmptyObject = (val) => {
      if (!isObject(val) || isBuffer(val)) {
        return false;
      }
      try {
        return Object.keys(val).length === 0 && Object.getPrototypeOf(val) === Object.prototype;
      } catch (e) {
        return false;
      }
    };
    var isDate = kindOfTest("Date");
    var isFile = kindOfTest("File");
    var isBlob = kindOfTest("Blob");
    var isFileList = kindOfTest("FileList");
    var isStream = (val) => isObject(val) && isFunction$1(val.pipe);
    var isFormData = (thing) => {
      let kind;
      return thing && (typeof FormData === "function" && thing instanceof FormData || isFunction$1(thing.append) && ((kind = kindOf(thing)) === "formdata" || // detect form-data instance
      kind === "object" && isFunction$1(thing.toString) && thing.toString() === "[object FormData]"));
    };
    var isURLSearchParams = kindOfTest("URLSearchParams");
    var [isReadableStream, isRequest, isResponse, isHeaders] = ["ReadableStream", "Request", "Response", "Headers"].map(kindOfTest);
    var trim = (str2) => str2.trim ? str2.trim() : str2.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
    function forEach(obj, fn, { allOwnKeys = false } = {}) {
      if (obj === null || typeof obj === "undefined") {
        return;
      }
      let i;
      let l;
      if (typeof obj !== "object") {
        obj = [obj];
      }
      if (isArray(obj)) {
        for (i = 0, l = obj.length; i < l; i++) {
          fn.call(null, obj[i], i, obj);
        }
      } else {
        if (isBuffer(obj)) {
          return;
        }
        const keys = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
        const len = keys.length;
        let key;
        for (i = 0; i < len; i++) {
          key = keys[i];
          fn.call(null, obj[key], key, obj);
        }
      }
    }
    function findKey(obj, key) {
      if (isBuffer(obj)) {
        return null;
      }
      key = key.toLowerCase();
      const keys = Object.keys(obj);
      let i = keys.length;
      let _key;
      while (i-- > 0) {
        _key = keys[i];
        if (key === _key.toLowerCase()) {
          return _key;
        }
      }
      return null;
    }
    var _global = (() => {
      if (typeof globalThis !== "undefined")
        return globalThis;
      return typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : global;
    })();
    var isContextDefined = (context) => !isUndefined(context) && context !== _global;
    function merge() {
      const { caseless, skipUndefined } = isContextDefined(this) && this || {};
      const result = {};
      const assignValue = (val, key) => {
        const targetKey = caseless && findKey(result, key) || key;
        if (isPlainObject(result[targetKey]) && isPlainObject(val)) {
          result[targetKey] = merge(result[targetKey], val);
        } else if (isPlainObject(val)) {
          result[targetKey] = merge({}, val);
        } else if (isArray(val)) {
          result[targetKey] = val.slice();
        } else if (!skipUndefined || !isUndefined(val)) {
          result[targetKey] = val;
        }
      };
      for (let i = 0, l = arguments.length; i < l; i++) {
        arguments[i] && forEach(arguments[i], assignValue);
      }
      return result;
    }
    var extend = (a, b, thisArg, { allOwnKeys } = {}) => {
      forEach(b, (val, key) => {
        if (thisArg && isFunction$1(val)) {
          a[key] = bind(val, thisArg);
        } else {
          a[key] = val;
        }
      }, { allOwnKeys });
      return a;
    };
    var stripBOM = (content) => {
      if (content.charCodeAt(0) === 65279) {
        content = content.slice(1);
      }
      return content;
    };
    var inherits = (constructor, superConstructor, props, descriptors2) => {
      constructor.prototype = Object.create(superConstructor.prototype, descriptors2);
      constructor.prototype.constructor = constructor;
      Object.defineProperty(constructor, "super", {
        value: superConstructor.prototype
      });
      props && Object.assign(constructor.prototype, props);
    };
    var toFlatObject = (sourceObj, destObj, filter, propFilter) => {
      let props;
      let i;
      let prop;
      const merged = {};
      destObj = destObj || {};
      if (sourceObj == null)
        return destObj;
      do {
        props = Object.getOwnPropertyNames(sourceObj);
        i = props.length;
        while (i-- > 0) {
          prop = props[i];
          if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
            destObj[prop] = sourceObj[prop];
            merged[prop] = true;
          }
        }
        sourceObj = filter !== false && getPrototypeOf(sourceObj);
      } while (sourceObj && (!filter || filter(sourceObj, destObj)) && sourceObj !== Object.prototype);
      return destObj;
    };
    var endsWith = (str2, searchString, position) => {
      str2 = String(str2);
      if (position === void 0 || position > str2.length) {
        position = str2.length;
      }
      position -= searchString.length;
      const lastIndex = str2.indexOf(searchString, position);
      return lastIndex !== -1 && lastIndex === position;
    };
    var toArray = (thing) => {
      if (!thing)
        return null;
      if (isArray(thing))
        return thing;
      let i = thing.length;
      if (!isNumber2(i))
        return null;
      const arr = new Array(i);
      while (i-- > 0) {
        arr[i] = thing[i];
      }
      return arr;
    };
    var isTypedArray = /* @__PURE__ */ ((TypedArray) => {
      return (thing) => {
        return TypedArray && thing instanceof TypedArray;
      };
    })(typeof Uint8Array !== "undefined" && getPrototypeOf(Uint8Array));
    var forEachEntry = (obj, fn) => {
      const generator = obj && obj[iterator];
      const _iterator = generator.call(obj);
      let result;
      while ((result = _iterator.next()) && !result.done) {
        const pair = result.value;
        fn.call(obj, pair[0], pair[1]);
      }
    };
    var matchAll = (regExp, str2) => {
      let matches;
      const arr = [];
      while ((matches = regExp.exec(str2)) !== null) {
        arr.push(matches);
      }
      return arr;
    };
    var isHTMLForm = kindOfTest("HTMLFormElement");
    var toCamelCase = (str2) => {
      return str2.toLowerCase().replace(
        /[-_\s]([a-z\d])(\w*)/g,
        function replacer(m, p1, p2) {
          return p1.toUpperCase() + p2;
        }
      );
    };
    var hasOwnProperty = (({ hasOwnProperty: hasOwnProperty2 }) => (obj, prop) => hasOwnProperty2.call(obj, prop))(Object.prototype);
    var isRegExp = kindOfTest("RegExp");
    var reduceDescriptors = (obj, reducer) => {
      const descriptors2 = Object.getOwnPropertyDescriptors(obj);
      const reducedDescriptors = {};
      forEach(descriptors2, (descriptor, name) => {
        let ret;
        if ((ret = reducer(descriptor, name, obj)) !== false) {
          reducedDescriptors[name] = ret || descriptor;
        }
      });
      Object.defineProperties(obj, reducedDescriptors);
    };
    var freezeMethods = (obj) => {
      reduceDescriptors(obj, (descriptor, name) => {
        if (isFunction$1(obj) && ["arguments", "caller", "callee"].indexOf(name) !== -1) {
          return false;
        }
        const value = obj[name];
        if (!isFunction$1(value))
          return;
        descriptor.enumerable = false;
        if ("writable" in descriptor) {
          descriptor.writable = false;
          return;
        }
        if (!descriptor.set) {
          descriptor.set = () => {
            throw Error("Can not rewrite read-only method '" + name + "'");
          };
        }
      });
    };
    var toObjectSet = (arrayOrString, delimiter) => {
      const obj = {};
      const define2 = (arr) => {
        arr.forEach((value) => {
          obj[value] = true;
        });
      };
      isArray(arrayOrString) ? define2(arrayOrString) : define2(String(arrayOrString).split(delimiter));
      return obj;
    };
    var noop = () => {
    };
    var toFiniteNumber = (value, defaultValue) => {
      return value != null && Number.isFinite(value = +value) ? value : defaultValue;
    };
    function isSpecCompliantForm(thing) {
      return !!(thing && isFunction$1(thing.append) && thing[toStringTag] === "FormData" && thing[iterator]);
    }
    var toJSONObject = (obj) => {
      const stack = new Array(10);
      const visit = (source, i) => {
        if (isObject(source)) {
          if (stack.indexOf(source) >= 0) {
            return;
          }
          if (isBuffer(source)) {
            return source;
          }
          if (!("toJSON" in source)) {
            stack[i] = source;
            const target = isArray(source) ? [] : {};
            forEach(source, (value, key) => {
              const reducedValue = visit(value, i + 1);
              !isUndefined(reducedValue) && (target[key] = reducedValue);
            });
            stack[i] = void 0;
            return target;
          }
        }
        return source;
      };
      return visit(obj, 0);
    };
    var isAsyncFn = kindOfTest("AsyncFunction");
    var isThenable = (thing) => thing && (isObject(thing) || isFunction$1(thing)) && isFunction$1(thing.then) && isFunction$1(thing.catch);
    var _setImmediate = ((setImmediateSupported, postMessageSupported) => {
      if (setImmediateSupported) {
        return setImmediate;
      }
      return postMessageSupported ? ((token, callbacks) => {
        _global.addEventListener("message", ({ source, data }) => {
          if (source === _global && data === token) {
            callbacks.length && callbacks.shift()();
          }
        }, false);
        return (cb) => {
          callbacks.push(cb);
          _global.postMessage(token, "*");
        };
      })(`axios@${Math.random()}`, []) : (cb) => setTimeout(cb);
    })(
      typeof setImmediate === "function",
      isFunction$1(_global.postMessage)
    );
    var asap = typeof queueMicrotask !== "undefined" ? queueMicrotask.bind(_global) : typeof process !== "undefined" && process.nextTick || _setImmediate;
    var isIterable = (thing) => thing != null && isFunction$1(thing[iterator]);
    var utils$1 = {
      isArray,
      isArrayBuffer,
      isBuffer,
      isFormData,
      isArrayBufferView,
      isString,
      isNumber: isNumber2,
      isBoolean,
      isObject,
      isPlainObject,
      isEmptyObject,
      isReadableStream,
      isRequest,
      isResponse,
      isHeaders,
      isUndefined,
      isDate,
      isFile,
      isBlob,
      isRegExp,
      isFunction: isFunction$1,
      isStream,
      isURLSearchParams,
      isTypedArray,
      isFileList,
      forEach,
      merge,
      extend,
      trim,
      stripBOM,
      inherits,
      toFlatObject,
      kindOf,
      kindOfTest,
      endsWith,
      toArray,
      forEachEntry,
      matchAll,
      isHTMLForm,
      hasOwnProperty,
      hasOwnProp: hasOwnProperty,
      // an alias to avoid ESLint no-prototype-builtins detection
      reduceDescriptors,
      freezeMethods,
      toObjectSet,
      toCamelCase,
      noop,
      toFiniteNumber,
      findKey,
      global: _global,
      isContextDefined,
      isSpecCompliantForm,
      toJSONObject,
      isAsyncFn,
      isThenable,
      setImmediate: _setImmediate,
      asap,
      isIterable
    };
    function AxiosError(message, code, config2, request, response) {
      Error.call(this);
      if (Error.captureStackTrace) {
        Error.captureStackTrace(this, this.constructor);
      } else {
        this.stack = new Error().stack;
      }
      this.message = message;
      this.name = "AxiosError";
      code && (this.code = code);
      config2 && (this.config = config2);
      request && (this.request = request);
      if (response) {
        this.response = response;
        this.status = response.status ? response.status : null;
      }
    }
    utils$1.inherits(AxiosError, Error, {
      toJSON: function toJSON() {
        return {
          // Standard
          message: this.message,
          name: this.name,
          // Microsoft
          description: this.description,
          number: this.number,
          // Mozilla
          fileName: this.fileName,
          lineNumber: this.lineNumber,
          columnNumber: this.columnNumber,
          stack: this.stack,
          // Axios
          config: utils$1.toJSONObject(this.config),
          code: this.code,
          status: this.status
        };
      }
    });
    var prototype$1 = AxiosError.prototype;
    var descriptors = {};
    [
      "ERR_BAD_OPTION_VALUE",
      "ERR_BAD_OPTION",
      "ECONNABORTED",
      "ETIMEDOUT",
      "ERR_NETWORK",
      "ERR_FR_TOO_MANY_REDIRECTS",
      "ERR_DEPRECATED",
      "ERR_BAD_RESPONSE",
      "ERR_BAD_REQUEST",
      "ERR_CANCELED",
      "ERR_NOT_SUPPORT",
      "ERR_INVALID_URL"
      // eslint-disable-next-line func-names
    ].forEach((code) => {
      descriptors[code] = { value: code };
    });
    Object.defineProperties(AxiosError, descriptors);
    Object.defineProperty(prototype$1, "isAxiosError", { value: true });
    AxiosError.from = (error, code, config2, request, response, customProps) => {
      const axiosError = Object.create(prototype$1);
      utils$1.toFlatObject(error, axiosError, function filter(obj) {
        return obj !== Error.prototype;
      }, (prop) => {
        return prop !== "isAxiosError";
      });
      const msg = error && error.message ? error.message : "Error";
      const errCode = code == null && error ? error.code : code;
      AxiosError.call(axiosError, msg, errCode, config2, request, response);
      if (error && axiosError.cause == null) {
        Object.defineProperty(axiosError, "cause", { value: error, configurable: true });
      }
      axiosError.name = error && error.name || "Error";
      customProps && Object.assign(axiosError, customProps);
      return axiosError;
    };
    function isVisitable(thing) {
      return utils$1.isPlainObject(thing) || utils$1.isArray(thing);
    }
    function removeBrackets(key) {
      return utils$1.endsWith(key, "[]") ? key.slice(0, -2) : key;
    }
    function renderKey(path, key, dots) {
      if (!path)
        return key;
      return path.concat(key).map(function each(token, i) {
        token = removeBrackets(token);
        return !dots && i ? "[" + token + "]" : token;
      }).join(dots ? "." : "");
    }
    function isFlatArray(arr) {
      return utils$1.isArray(arr) && !arr.some(isVisitable);
    }
    var predicates = utils$1.toFlatObject(utils$1, {}, null, function filter(prop) {
      return /^is[A-Z]/.test(prop);
    });
    function toFormData(obj, formData, options) {
      if (!utils$1.isObject(obj)) {
        throw new TypeError("target must be an object");
      }
      formData = formData || new (FormData__default["default"] || FormData)();
      options = utils$1.toFlatObject(options, {
        metaTokens: true,
        dots: false,
        indexes: false
      }, false, function defined(option2, source) {
        return !utils$1.isUndefined(source[option2]);
      });
      const metaTokens = options.metaTokens;
      const visitor = options.visitor || defaultVisitor;
      const dots = options.dots;
      const indexes = options.indexes;
      const _Blob = options.Blob || typeof Blob !== "undefined" && Blob;
      const useBlob = _Blob && utils$1.isSpecCompliantForm(formData);
      if (!utils$1.isFunction(visitor)) {
        throw new TypeError("visitor must be a function");
      }
      function convertValue(value) {
        if (value === null)
          return "";
        if (utils$1.isDate(value)) {
          return value.toISOString();
        }
        if (utils$1.isBoolean(value)) {
          return value.toString();
        }
        if (!useBlob && utils$1.isBlob(value)) {
          throw new AxiosError("Blob is not supported. Use a Buffer instead.");
        }
        if (utils$1.isArrayBuffer(value) || utils$1.isTypedArray(value)) {
          return useBlob && typeof Blob === "function" ? new Blob([value]) : Buffer.from(value);
        }
        return value;
      }
      function defaultVisitor(value, key, path) {
        let arr = value;
        if (value && !path && typeof value === "object") {
          if (utils$1.endsWith(key, "{}")) {
            key = metaTokens ? key : key.slice(0, -2);
            value = JSON.stringify(value);
          } else if (utils$1.isArray(value) && isFlatArray(value) || (utils$1.isFileList(value) || utils$1.endsWith(key, "[]")) && (arr = utils$1.toArray(value))) {
            key = removeBrackets(key);
            arr.forEach(function each(el, index) {
              !(utils$1.isUndefined(el) || el === null) && formData.append(
                // eslint-disable-next-line no-nested-ternary
                indexes === true ? renderKey([key], index, dots) : indexes === null ? key : key + "[]",
                convertValue(el)
              );
            });
            return false;
          }
        }
        if (isVisitable(value)) {
          return true;
        }
        formData.append(renderKey(path, key, dots), convertValue(value));
        return false;
      }
      const stack = [];
      const exposedHelpers = Object.assign(predicates, {
        defaultVisitor,
        convertValue,
        isVisitable
      });
      function build(value, path) {
        if (utils$1.isUndefined(value))
          return;
        if (stack.indexOf(value) !== -1) {
          throw Error("Circular reference detected in " + path.join("."));
        }
        stack.push(value);
        utils$1.forEach(value, function each(el, key) {
          const result = !(utils$1.isUndefined(el) || el === null) && visitor.call(
            formData,
            el,
            utils$1.isString(key) ? key.trim() : key,
            path,
            exposedHelpers
          );
          if (result === true) {
            build(el, path ? path.concat(key) : [key]);
          }
        });
        stack.pop();
      }
      if (!utils$1.isObject(obj)) {
        throw new TypeError("data must be an object");
      }
      build(obj);
      return formData;
    }
    function encode$1(str2) {
      const charMap = {
        "!": "%21",
        "'": "%27",
        "(": "%28",
        ")": "%29",
        "~": "%7E",
        "%20": "+",
        "%00": "\0"
      };
      return encodeURIComponent(str2).replace(/[!'()~]|%20|%00/g, function replacer(match) {
        return charMap[match];
      });
    }
    function AxiosURLSearchParams(params, options) {
      this._pairs = [];
      params && toFormData(params, this, options);
    }
    var prototype = AxiosURLSearchParams.prototype;
    prototype.append = function append(name, value) {
      this._pairs.push([name, value]);
    };
    prototype.toString = function toString2(encoder) {
      const _encode = encoder ? function(value) {
        return encoder.call(this, value, encode$1);
      } : encode$1;
      return this._pairs.map(function each(pair) {
        return _encode(pair[0]) + "=" + _encode(pair[1]);
      }, "").join("&");
    };
    function encode(val) {
      return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+");
    }
    function buildURL(url2, params, options) {
      if (!params) {
        return url2;
      }
      const _encode = options && options.encode || encode;
      if (utils$1.isFunction(options)) {
        options = {
          serialize: options
        };
      }
      const serializeFn = options && options.serialize;
      let serializedParams;
      if (serializeFn) {
        serializedParams = serializeFn(params, options);
      } else {
        serializedParams = utils$1.isURLSearchParams(params) ? params.toString() : new AxiosURLSearchParams(params, options).toString(_encode);
      }
      if (serializedParams) {
        const hashmarkIndex = url2.indexOf("#");
        if (hashmarkIndex !== -1) {
          url2 = url2.slice(0, hashmarkIndex);
        }
        url2 += (url2.indexOf("?") === -1 ? "?" : "&") + serializedParams;
      }
      return url2;
    }
    var InterceptorManager = class {
      constructor() {
        this.handlers = [];
      }
      /**
       * Add a new interceptor to the stack
       *
       * @param {Function} fulfilled The function to handle `then` for a `Promise`
       * @param {Function} rejected The function to handle `reject` for a `Promise`
       *
       * @return {Number} An ID used to remove interceptor later
       */
      use(fulfilled, rejected, options) {
        this.handlers.push({
          fulfilled,
          rejected,
          synchronous: options ? options.synchronous : false,
          runWhen: options ? options.runWhen : null
        });
        return this.handlers.length - 1;
      }
      /**
       * Remove an interceptor from the stack
       *
       * @param {Number} id The ID that was returned by `use`
       *
       * @returns {void}
       */
      eject(id) {
        if (this.handlers[id]) {
          this.handlers[id] = null;
        }
      }
      /**
       * Clear all interceptors from the stack
       *
       * @returns {void}
       */
      clear() {
        if (this.handlers) {
          this.handlers = [];
        }
      }
      /**
       * Iterate over all the registered interceptors
       *
       * This method is particularly useful for skipping over any
       * interceptors that may have become `null` calling `eject`.
       *
       * @param {Function} fn The function to call for each interceptor
       *
       * @returns {void}
       */
      forEach(fn) {
        utils$1.forEach(this.handlers, function forEachHandler(h) {
          if (h !== null) {
            fn(h);
          }
        });
      }
    };
    var InterceptorManager$1 = InterceptorManager;
    var transitionalDefaults = {
      silentJSONParsing: true,
      forcedJSONParsing: true,
      clarifyTimeoutError: false
    };
    var URLSearchParams = url__default["default"].URLSearchParams;
    var ALPHA = "abcdefghijklmnopqrstuvwxyz";
    var DIGIT = "0123456789";
    var ALPHABET = {
      DIGIT,
      ALPHA,
      ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT
    };
    var generateString = (size = 16, alphabet = ALPHABET.ALPHA_DIGIT) => {
      let str2 = "";
      const { length } = alphabet;
      const randomValues = new Uint32Array(size);
      crypto__default["default"].randomFillSync(randomValues);
      for (let i = 0; i < size; i++) {
        str2 += alphabet[randomValues[i] % length];
      }
      return str2;
    };
    var platform$1 = {
      isNode: true,
      classes: {
        URLSearchParams,
        FormData: FormData__default["default"],
        Blob: typeof Blob !== "undefined" && Blob || null
      },
      ALPHABET,
      generateString,
      protocols: ["http", "https", "file", "data"]
    };
    var hasBrowserEnv = typeof window !== "undefined" && typeof document !== "undefined";
    var _navigator = typeof navigator === "object" && navigator || void 0;
    var hasStandardBrowserEnv = hasBrowserEnv && (!_navigator || ["ReactNative", "NativeScript", "NS"].indexOf(_navigator.product) < 0);
    var hasStandardBrowserWebWorkerEnv = (() => {
      return typeof WorkerGlobalScope !== "undefined" && // eslint-disable-next-line no-undef
      self instanceof WorkerGlobalScope && typeof self.importScripts === "function";
    })();
    var origin = hasBrowserEnv && window.location.href || "http://localhost";
    var utils = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      hasBrowserEnv,
      hasStandardBrowserWebWorkerEnv,
      hasStandardBrowserEnv,
      navigator: _navigator,
      origin
    });
    var platform = {
      ...utils,
      ...platform$1
    };
    function toURLEncodedForm(data, options) {
      return toFormData(data, new platform.classes.URLSearchParams(), {
        visitor: function(value, key, path, helpers) {
          if (platform.isNode && utils$1.isBuffer(value)) {
            this.append(key, value.toString("base64"));
            return false;
          }
          return helpers.defaultVisitor.apply(this, arguments);
        },
        ...options
      });
    }
    function parsePropPath(name) {
      return utils$1.matchAll(/\w+|\[(\w*)]/g, name).map((match) => {
        return match[0] === "[]" ? "" : match[1] || match[0];
      });
    }
    function arrayToObject(arr) {
      const obj = {};
      const keys = Object.keys(arr);
      let i;
      const len = keys.length;
      let key;
      for (i = 0; i < len; i++) {
        key = keys[i];
        obj[key] = arr[key];
      }
      return obj;
    }
    function formDataToJSON(formData) {
      function buildPath(path, value, target, index) {
        let name = path[index++];
        if (name === "__proto__")
          return true;
        const isNumericKey = Number.isFinite(+name);
        const isLast = index >= path.length;
        name = !name && utils$1.isArray(target) ? target.length : name;
        if (isLast) {
          if (utils$1.hasOwnProp(target, name)) {
            target[name] = [target[name], value];
          } else {
            target[name] = value;
          }
          return !isNumericKey;
        }
        if (!target[name] || !utils$1.isObject(target[name])) {
          target[name] = [];
        }
        const result = buildPath(path, value, target[name], index);
        if (result && utils$1.isArray(target[name])) {
          target[name] = arrayToObject(target[name]);
        }
        return !isNumericKey;
      }
      if (utils$1.isFormData(formData) && utils$1.isFunction(formData.entries)) {
        const obj = {};
        utils$1.forEachEntry(formData, (name, value) => {
          buildPath(parsePropPath(name), value, obj, 0);
        });
        return obj;
      }
      return null;
    }
    function stringifySafely(rawValue, parser, encoder) {
      if (utils$1.isString(rawValue)) {
        try {
          (parser || JSON.parse)(rawValue);
          return utils$1.trim(rawValue);
        } catch (e) {
          if (e.name !== "SyntaxError") {
            throw e;
          }
        }
      }
      return (encoder || JSON.stringify)(rawValue);
    }
    var defaults = {
      transitional: transitionalDefaults,
      adapter: ["xhr", "http", "fetch"],
      transformRequest: [function transformRequest(data, headers) {
        const contentType = headers.getContentType() || "";
        const hasJSONContentType = contentType.indexOf("application/json") > -1;
        const isObjectPayload = utils$1.isObject(data);
        if (isObjectPayload && utils$1.isHTMLForm(data)) {
          data = new FormData(data);
        }
        const isFormData2 = utils$1.isFormData(data);
        if (isFormData2) {
          return hasJSONContentType ? JSON.stringify(formDataToJSON(data)) : data;
        }
        if (utils$1.isArrayBuffer(data) || utils$1.isBuffer(data) || utils$1.isStream(data) || utils$1.isFile(data) || utils$1.isBlob(data) || utils$1.isReadableStream(data)) {
          return data;
        }
        if (utils$1.isArrayBufferView(data)) {
          return data.buffer;
        }
        if (utils$1.isURLSearchParams(data)) {
          headers.setContentType("application/x-www-form-urlencoded;charset=utf-8", false);
          return data.toString();
        }
        let isFileList2;
        if (isObjectPayload) {
          if (contentType.indexOf("application/x-www-form-urlencoded") > -1) {
            return toURLEncodedForm(data, this.formSerializer).toString();
          }
          if ((isFileList2 = utils$1.isFileList(data)) || contentType.indexOf("multipart/form-data") > -1) {
            const _FormData = this.env && this.env.FormData;
            return toFormData(
              isFileList2 ? { "files[]": data } : data,
              _FormData && new _FormData(),
              this.formSerializer
            );
          }
        }
        if (isObjectPayload || hasJSONContentType) {
          headers.setContentType("application/json", false);
          return stringifySafely(data);
        }
        return data;
      }],
      transformResponse: [function transformResponse(data) {
        const transitional = this.transitional || defaults.transitional;
        const forcedJSONParsing = transitional && transitional.forcedJSONParsing;
        const JSONRequested = this.responseType === "json";
        if (utils$1.isResponse(data) || utils$1.isReadableStream(data)) {
          return data;
        }
        if (data && utils$1.isString(data) && (forcedJSONParsing && !this.responseType || JSONRequested)) {
          const silentJSONParsing = transitional && transitional.silentJSONParsing;
          const strictJSONParsing = !silentJSONParsing && JSONRequested;
          try {
            return JSON.parse(data, this.parseReviver);
          } catch (e) {
            if (strictJSONParsing) {
              if (e.name === "SyntaxError") {
                throw AxiosError.from(e, AxiosError.ERR_BAD_RESPONSE, this, null, this.response);
              }
              throw e;
            }
          }
        }
        return data;
      }],
      /**
       * A timeout in milliseconds to abort a request. If set to 0 (default) a
       * timeout is not created.
       */
      timeout: 0,
      xsrfCookieName: "XSRF-TOKEN",
      xsrfHeaderName: "X-XSRF-TOKEN",
      maxContentLength: -1,
      maxBodyLength: -1,
      env: {
        FormData: platform.classes.FormData,
        Blob: platform.classes.Blob
      },
      validateStatus: function validateStatus(status) {
        return status >= 200 && status < 300;
      },
      headers: {
        common: {
          "Accept": "application/json, text/plain, */*",
          "Content-Type": void 0
        }
      }
    };
    utils$1.forEach(["delete", "get", "head", "post", "put", "patch"], (method) => {
      defaults.headers[method] = {};
    });
    var defaults$1 = defaults;
    var ignoreDuplicateOf = utils$1.toObjectSet([
      "age",
      "authorization",
      "content-length",
      "content-type",
      "etag",
      "expires",
      "from",
      "host",
      "if-modified-since",
      "if-unmodified-since",
      "last-modified",
      "location",
      "max-forwards",
      "proxy-authorization",
      "referer",
      "retry-after",
      "user-agent"
    ]);
    var parseHeaders = (rawHeaders) => {
      const parsed = {};
      let key;
      let val;
      let i;
      rawHeaders && rawHeaders.split("\n").forEach(function parser(line) {
        i = line.indexOf(":");
        key = line.substring(0, i).trim().toLowerCase();
        val = line.substring(i + 1).trim();
        if (!key || parsed[key] && ignoreDuplicateOf[key]) {
          return;
        }
        if (key === "set-cookie") {
          if (parsed[key]) {
            parsed[key].push(val);
          } else {
            parsed[key] = [val];
          }
        } else {
          parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
        }
      });
      return parsed;
    };
    var $internals = Symbol("internals");
    function normalizeHeader(header) {
      return header && String(header).trim().toLowerCase();
    }
    function normalizeValue(value) {
      if (value === false || value == null) {
        return value;
      }
      return utils$1.isArray(value) ? value.map(normalizeValue) : String(value);
    }
    function parseTokens(str2) {
      const tokens = /* @__PURE__ */ Object.create(null);
      const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
      let match;
      while (match = tokensRE.exec(str2)) {
        tokens[match[1]] = match[2];
      }
      return tokens;
    }
    var isValidHeaderName = (str2) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str2.trim());
    function matchHeaderValue(context, value, header, filter, isHeaderNameFilter) {
      if (utils$1.isFunction(filter)) {
        return filter.call(this, value, header);
      }
      if (isHeaderNameFilter) {
        value = header;
      }
      if (!utils$1.isString(value))
        return;
      if (utils$1.isString(filter)) {
        return value.indexOf(filter) !== -1;
      }
      if (utils$1.isRegExp(filter)) {
        return filter.test(value);
      }
    }
    function formatHeader(header) {
      return header.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (w, char, str2) => {
        return char.toUpperCase() + str2;
      });
    }
    function buildAccessors(obj, header) {
      const accessorName = utils$1.toCamelCase(" " + header);
      ["get", "set", "has"].forEach((methodName) => {
        Object.defineProperty(obj, methodName + accessorName, {
          value: function(arg1, arg2, arg3) {
            return this[methodName].call(this, header, arg1, arg2, arg3);
          },
          configurable: true
        });
      });
    }
    var AxiosHeaders = class {
      constructor(headers) {
        headers && this.set(headers);
      }
      set(header, valueOrRewrite, rewrite) {
        const self2 = this;
        function setHeader(_value, _header, _rewrite) {
          const lHeader = normalizeHeader(_header);
          if (!lHeader) {
            throw new Error("header name must be a non-empty string");
          }
          const key = utils$1.findKey(self2, lHeader);
          if (!key || self2[key] === void 0 || _rewrite === true || _rewrite === void 0 && self2[key] !== false) {
            self2[key || _header] = normalizeValue(_value);
          }
        }
        const setHeaders = (headers, _rewrite) => utils$1.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));
        if (utils$1.isPlainObject(header) || header instanceof this.constructor) {
          setHeaders(header, valueOrRewrite);
        } else if (utils$1.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
          setHeaders(parseHeaders(header), valueOrRewrite);
        } else if (utils$1.isObject(header) && utils$1.isIterable(header)) {
          let obj = {}, dest, key;
          for (const entry of header) {
            if (!utils$1.isArray(entry)) {
              throw TypeError("Object iterator must return a key-value pair");
            }
            obj[key = entry[0]] = (dest = obj[key]) ? utils$1.isArray(dest) ? [...dest, entry[1]] : [dest, entry[1]] : entry[1];
          }
          setHeaders(obj, valueOrRewrite);
        } else {
          header != null && setHeader(valueOrRewrite, header, rewrite);
        }
        return this;
      }
      get(header, parser) {
        header = normalizeHeader(header);
        if (header) {
          const key = utils$1.findKey(this, header);
          if (key) {
            const value = this[key];
            if (!parser) {
              return value;
            }
            if (parser === true) {
              return parseTokens(value);
            }
            if (utils$1.isFunction(parser)) {
              return parser.call(this, value, key);
            }
            if (utils$1.isRegExp(parser)) {
              return parser.exec(value);
            }
            throw new TypeError("parser must be boolean|regexp|function");
          }
        }
      }
      has(header, matcher) {
        header = normalizeHeader(header);
        if (header) {
          const key = utils$1.findKey(this, header);
          return !!(key && this[key] !== void 0 && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
        }
        return false;
      }
      delete(header, matcher) {
        const self2 = this;
        let deleted = false;
        function deleteHeader(_header) {
          _header = normalizeHeader(_header);
          if (_header) {
            const key = utils$1.findKey(self2, _header);
            if (key && (!matcher || matchHeaderValue(self2, self2[key], key, matcher))) {
              delete self2[key];
              deleted = true;
            }
          }
        }
        if (utils$1.isArray(header)) {
          header.forEach(deleteHeader);
        } else {
          deleteHeader(header);
        }
        return deleted;
      }
      clear(matcher) {
        const keys = Object.keys(this);
        let i = keys.length;
        let deleted = false;
        while (i--) {
          const key = keys[i];
          if (!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {
            delete this[key];
            deleted = true;
          }
        }
        return deleted;
      }
      normalize(format) {
        const self2 = this;
        const headers = {};
        utils$1.forEach(this, (value, header) => {
          const key = utils$1.findKey(headers, header);
          if (key) {
            self2[key] = normalizeValue(value);
            delete self2[header];
            return;
          }
          const normalized = format ? formatHeader(header) : String(header).trim();
          if (normalized !== header) {
            delete self2[header];
          }
          self2[normalized] = normalizeValue(value);
          headers[normalized] = true;
        });
        return this;
      }
      concat(...targets) {
        return this.constructor.concat(this, ...targets);
      }
      toJSON(asStrings) {
        const obj = /* @__PURE__ */ Object.create(null);
        utils$1.forEach(this, (value, header) => {
          value != null && value !== false && (obj[header] = asStrings && utils$1.isArray(value) ? value.join(", ") : value);
        });
        return obj;
      }
      [Symbol.iterator]() {
        return Object.entries(this.toJSON())[Symbol.iterator]();
      }
      toString() {
        return Object.entries(this.toJSON()).map(([header, value]) => header + ": " + value).join("\n");
      }
      getSetCookie() {
        return this.get("set-cookie") || [];
      }
      get [Symbol.toStringTag]() {
        return "AxiosHeaders";
      }
      static from(thing) {
        return thing instanceof this ? thing : new this(thing);
      }
      static concat(first, ...targets) {
        const computed = new this(first);
        targets.forEach((target) => computed.set(target));
        return computed;
      }
      static accessor(header) {
        const internals = this[$internals] = this[$internals] = {
          accessors: {}
        };
        const accessors = internals.accessors;
        const prototype2 = this.prototype;
        function defineAccessor(_header) {
          const lHeader = normalizeHeader(_header);
          if (!accessors[lHeader]) {
            buildAccessors(prototype2, _header);
            accessors[lHeader] = true;
          }
        }
        utils$1.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);
        return this;
      }
    };
    AxiosHeaders.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
    utils$1.reduceDescriptors(AxiosHeaders.prototype, ({ value }, key) => {
      let mapped = key[0].toUpperCase() + key.slice(1);
      return {
        get: () => value,
        set(headerValue) {
          this[mapped] = headerValue;
        }
      };
    });
    utils$1.freezeMethods(AxiosHeaders);
    var AxiosHeaders$1 = AxiosHeaders;
    function transformData(fns, response) {
      const config2 = this || defaults$1;
      const context = response || config2;
      const headers = AxiosHeaders$1.from(context.headers);
      let data = context.data;
      utils$1.forEach(fns, function transform(fn) {
        data = fn.call(config2, data, headers.normalize(), response ? response.status : void 0);
      });
      headers.normalize();
      return data;
    }
    function isCancel(value) {
      return !!(value && value.__CANCEL__);
    }
    function CanceledError(message, config2, request) {
      AxiosError.call(this, message == null ? "canceled" : message, AxiosError.ERR_CANCELED, config2, request);
      this.name = "CanceledError";
    }
    utils$1.inherits(CanceledError, AxiosError, {
      __CANCEL__: true
    });
    function settle(resolve, reject, response) {
      const validateStatus = response.config.validateStatus;
      if (!response.status || !validateStatus || validateStatus(response.status)) {
        resolve(response);
      } else {
        reject(new AxiosError(
          "Request failed with status code " + response.status,
          [AxiosError.ERR_BAD_REQUEST, AxiosError.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
          response.config,
          response.request,
          response
        ));
      }
    }
    function isAbsoluteURL(url2) {
      return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url2);
    }
    function combineURLs(baseURL, relativeURL) {
      return relativeURL ? baseURL.replace(/\/?\/$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
    }
    function buildFullPath(baseURL, requestedURL, allowAbsoluteUrls) {
      let isRelativeUrl = !isAbsoluteURL(requestedURL);
      if (baseURL && (isRelativeUrl || allowAbsoluteUrls == false)) {
        return combineURLs(baseURL, requestedURL);
      }
      return requestedURL;
    }
    var VERSION = "1.13.2";
    function parseProtocol(url2) {
      const match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url2);
      return match && match[1] || "";
    }
    var DATA_URL_PATTERN = /^(?:([^;]+);)?(?:[^;]+;)?(base64|),([\s\S]*)$/;
    function fromDataURI(uri, asBlob, options) {
      const _Blob = options && options.Blob || platform.classes.Blob;
      const protocol = parseProtocol(uri);
      if (asBlob === void 0 && _Blob) {
        asBlob = true;
      }
      if (protocol === "data") {
        uri = protocol.length ? uri.slice(protocol.length + 1) : uri;
        const match = DATA_URL_PATTERN.exec(uri);
        if (!match) {
          throw new AxiosError("Invalid URL", AxiosError.ERR_INVALID_URL);
        }
        const mime = match[1];
        const isBase64 = match[2];
        const body = match[3];
        const buffer = Buffer.from(decodeURIComponent(body), isBase64 ? "base64" : "utf8");
        if (asBlob) {
          if (!_Blob) {
            throw new AxiosError("Blob is not supported", AxiosError.ERR_NOT_SUPPORT);
          }
          return new _Blob([buffer], { type: mime });
        }
        return buffer;
      }
      throw new AxiosError("Unsupported protocol " + protocol, AxiosError.ERR_NOT_SUPPORT);
    }
    var kInternals = Symbol("internals");
    var AxiosTransformStream = class extends stream__default["default"].Transform {
      constructor(options) {
        options = utils$1.toFlatObject(options, {
          maxRate: 0,
          chunkSize: 64 * 1024,
          minChunkSize: 100,
          timeWindow: 500,
          ticksRate: 2,
          samplesCount: 15
        }, null, (prop, source) => {
          return !utils$1.isUndefined(source[prop]);
        });
        super({
          readableHighWaterMark: options.chunkSize
        });
        const internals = this[kInternals] = {
          timeWindow: options.timeWindow,
          chunkSize: options.chunkSize,
          maxRate: options.maxRate,
          minChunkSize: options.minChunkSize,
          bytesSeen: 0,
          isCaptured: false,
          notifiedBytesLoaded: 0,
          ts: Date.now(),
          bytes: 0,
          onReadCallback: null
        };
        this.on("newListener", (event) => {
          if (event === "progress") {
            if (!internals.isCaptured) {
              internals.isCaptured = true;
            }
          }
        });
      }
      _read(size) {
        const internals = this[kInternals];
        if (internals.onReadCallback) {
          internals.onReadCallback();
        }
        return super._read(size);
      }
      _transform(chunk, encoding, callback) {
        const internals = this[kInternals];
        const maxRate = internals.maxRate;
        const readableHighWaterMark = this.readableHighWaterMark;
        const timeWindow = internals.timeWindow;
        const divider = 1e3 / timeWindow;
        const bytesThreshold = maxRate / divider;
        const minChunkSize = internals.minChunkSize !== false ? Math.max(internals.minChunkSize, bytesThreshold * 0.01) : 0;
        const pushChunk = (_chunk, _callback) => {
          const bytes = Buffer.byteLength(_chunk);
          internals.bytesSeen += bytes;
          internals.bytes += bytes;
          internals.isCaptured && this.emit("progress", internals.bytesSeen);
          if (this.push(_chunk)) {
            process.nextTick(_callback);
          } else {
            internals.onReadCallback = () => {
              internals.onReadCallback = null;
              process.nextTick(_callback);
            };
          }
        };
        const transformChunk = (_chunk, _callback) => {
          const chunkSize = Buffer.byteLength(_chunk);
          let chunkRemainder = null;
          let maxChunkSize = readableHighWaterMark;
          let bytesLeft;
          let passed = 0;
          if (maxRate) {
            const now = Date.now();
            if (!internals.ts || (passed = now - internals.ts) >= timeWindow) {
              internals.ts = now;
              bytesLeft = bytesThreshold - internals.bytes;
              internals.bytes = bytesLeft < 0 ? -bytesLeft : 0;
              passed = 0;
            }
            bytesLeft = bytesThreshold - internals.bytes;
          }
          if (maxRate) {
            if (bytesLeft <= 0) {
              return setTimeout(() => {
                _callback(null, _chunk);
              }, timeWindow - passed);
            }
            if (bytesLeft < maxChunkSize) {
              maxChunkSize = bytesLeft;
            }
          }
          if (maxChunkSize && chunkSize > maxChunkSize && chunkSize - maxChunkSize > minChunkSize) {
            chunkRemainder = _chunk.subarray(maxChunkSize);
            _chunk = _chunk.subarray(0, maxChunkSize);
          }
          pushChunk(_chunk, chunkRemainder ? () => {
            process.nextTick(_callback, null, chunkRemainder);
          } : _callback);
        };
        transformChunk(chunk, function transformNextChunk(err, _chunk) {
          if (err) {
            return callback(err);
          }
          if (_chunk) {
            transformChunk(_chunk, transformNextChunk);
          } else {
            callback(null);
          }
        });
      }
    };
    var AxiosTransformStream$1 = AxiosTransformStream;
    var { asyncIterator } = Symbol;
    var readBlob = async function* (blob4) {
      if (blob4.stream) {
        yield* blob4.stream();
      } else if (blob4.arrayBuffer) {
        yield await blob4.arrayBuffer();
      } else if (blob4[asyncIterator]) {
        yield* blob4[asyncIterator]();
      } else {
        yield blob4;
      }
    };
    var readBlob$1 = readBlob;
    var BOUNDARY_ALPHABET = platform.ALPHABET.ALPHA_DIGIT + "-_";
    var textEncoder = typeof TextEncoder === "function" ? new TextEncoder() : new util__default["default"].TextEncoder();
    var CRLF = "\r\n";
    var CRLF_BYTES = textEncoder.encode(CRLF);
    var CRLF_BYTES_COUNT = 2;
    var FormDataPart = class {
      constructor(name, value) {
        const { escapeName } = this.constructor;
        const isStringValue = utils$1.isString(value);
        let headers = `Content-Disposition: form-data; name="${escapeName(name)}"${!isStringValue && value.name ? `; filename="${escapeName(value.name)}"` : ""}${CRLF}`;
        if (isStringValue) {
          value = textEncoder.encode(String(value).replace(/\r?\n|\r\n?/g, CRLF));
        } else {
          headers += `Content-Type: ${value.type || "application/octet-stream"}${CRLF}`;
        }
        this.headers = textEncoder.encode(headers + CRLF);
        this.contentLength = isStringValue ? value.byteLength : value.size;
        this.size = this.headers.byteLength + this.contentLength + CRLF_BYTES_COUNT;
        this.name = name;
        this.value = value;
      }
      async *encode() {
        yield this.headers;
        const { value } = this;
        if (utils$1.isTypedArray(value)) {
          yield value;
        } else {
          yield* readBlob$1(value);
        }
        yield CRLF_BYTES;
      }
      static escapeName(name) {
        return String(name).replace(/[\r\n"]/g, (match) => ({
          "\r": "%0D",
          "\n": "%0A",
          '"': "%22"
        })[match]);
      }
    };
    var formDataToStream = (form, headersHandler, options) => {
      const {
        tag: tag2 = "form-data-boundary",
        size = 25,
        boundary = tag2 + "-" + platform.generateString(size, BOUNDARY_ALPHABET)
      } = options || {};
      if (!utils$1.isFormData(form)) {
        throw TypeError("FormData instance required");
      }
      if (boundary.length < 1 || boundary.length > 70) {
        throw Error("boundary must be 10-70 characters long");
      }
      const boundaryBytes = textEncoder.encode("--" + boundary + CRLF);
      const footerBytes = textEncoder.encode("--" + boundary + "--" + CRLF);
      let contentLength = footerBytes.byteLength;
      const parts = Array.from(form.entries()).map(([name, value]) => {
        const part = new FormDataPart(name, value);
        contentLength += part.size;
        return part;
      });
      contentLength += boundaryBytes.byteLength * parts.length;
      contentLength = utils$1.toFiniteNumber(contentLength);
      const computedHeaders = {
        "Content-Type": `multipart/form-data; boundary=${boundary}`
      };
      if (Number.isFinite(contentLength)) {
        computedHeaders["Content-Length"] = contentLength;
      }
      headersHandler && headersHandler(computedHeaders);
      return stream.Readable.from(async function* () {
        for (const part of parts) {
          yield boundaryBytes;
          yield* part.encode();
        }
        yield footerBytes;
      }());
    };
    var formDataToStream$1 = formDataToStream;
    var ZlibHeaderTransformStream = class extends stream__default["default"].Transform {
      __transform(chunk, encoding, callback) {
        this.push(chunk);
        callback();
      }
      _transform(chunk, encoding, callback) {
        if (chunk.length !== 0) {
          this._transform = this.__transform;
          if (chunk[0] !== 120) {
            const header = Buffer.alloc(2);
            header[0] = 120;
            header[1] = 156;
            this.push(header, encoding);
          }
        }
        this.__transform(chunk, encoding, callback);
      }
    };
    var ZlibHeaderTransformStream$1 = ZlibHeaderTransformStream;
    var callbackify = (fn, reducer) => {
      return utils$1.isAsyncFn(fn) ? function(...args) {
        const cb = args.pop();
        fn.apply(this, args).then((value) => {
          try {
            reducer ? cb(null, ...reducer(value)) : cb(null, value);
          } catch (err) {
            cb(err);
          }
        }, cb);
      } : fn;
    };
    var callbackify$1 = callbackify;
    function speedometer(samplesCount, min2) {
      samplesCount = samplesCount || 10;
      const bytes = new Array(samplesCount);
      const timestamps = new Array(samplesCount);
      let head = 0;
      let tail = 0;
      let firstSampleTS;
      min2 = min2 !== void 0 ? min2 : 1e3;
      return function push(chunkLength) {
        const now = Date.now();
        const startedAt = timestamps[tail];
        if (!firstSampleTS) {
          firstSampleTS = now;
        }
        bytes[head] = chunkLength;
        timestamps[head] = now;
        let i = tail;
        let bytesCount = 0;
        while (i !== head) {
          bytesCount += bytes[i++];
          i = i % samplesCount;
        }
        head = (head + 1) % samplesCount;
        if (head === tail) {
          tail = (tail + 1) % samplesCount;
        }
        if (now - firstSampleTS < min2) {
          return;
        }
        const passed = startedAt && now - startedAt;
        return passed ? Math.round(bytesCount * 1e3 / passed) : void 0;
      };
    }
    function throttle(fn, freq) {
      let timestamp = 0;
      let threshold = 1e3 / freq;
      let lastArgs;
      let timer;
      const invoke = (args, now = Date.now()) => {
        timestamp = now;
        lastArgs = null;
        if (timer) {
          clearTimeout(timer);
          timer = null;
        }
        fn(...args);
      };
      const throttled = (...args) => {
        const now = Date.now();
        const passed = now - timestamp;
        if (passed >= threshold) {
          invoke(args, now);
        } else {
          lastArgs = args;
          if (!timer) {
            timer = setTimeout(() => {
              timer = null;
              invoke(lastArgs);
            }, threshold - passed);
          }
        }
      };
      const flush = () => lastArgs && invoke(lastArgs);
      return [throttled, flush];
    }
    var progressEventReducer = (listener, isDownloadStream, freq = 3) => {
      let bytesNotified = 0;
      const _speedometer = speedometer(50, 250);
      return throttle((e) => {
        const loaded = e.loaded;
        const total = e.lengthComputable ? e.total : void 0;
        const progressBytes = loaded - bytesNotified;
        const rate = _speedometer(progressBytes);
        const inRange = loaded <= total;
        bytesNotified = loaded;
        const data = {
          loaded,
          total,
          progress: total ? loaded / total : void 0,
          bytes: progressBytes,
          rate: rate ? rate : void 0,
          estimated: rate && total && inRange ? (total - loaded) / rate : void 0,
          event: e,
          lengthComputable: total != null,
          [isDownloadStream ? "download" : "upload"]: true
        };
        listener(data);
      }, freq);
    };
    var progressEventDecorator = (total, throttled) => {
      const lengthComputable = total != null;
      return [(loaded) => throttled[0]({
        lengthComputable,
        total,
        loaded
      }), throttled[1]];
    };
    var asyncDecorator = (fn) => (...args) => utils$1.asap(() => fn(...args));
    function estimateDataURLDecodedBytes(url2) {
      if (!url2 || typeof url2 !== "string")
        return 0;
      if (!url2.startsWith("data:"))
        return 0;
      const comma = url2.indexOf(",");
      if (comma < 0)
        return 0;
      const meta = url2.slice(5, comma);
      const body = url2.slice(comma + 1);
      const isBase64 = /;base64/i.test(meta);
      if (isBase64) {
        let effectiveLen = body.length;
        const len = body.length;
        for (let i = 0; i < len; i++) {
          if (body.charCodeAt(i) === 37 && i + 2 < len) {
            const a = body.charCodeAt(i + 1);
            const b = body.charCodeAt(i + 2);
            const isHex2 = (a >= 48 && a <= 57 || a >= 65 && a <= 70 || a >= 97 && a <= 102) && (b >= 48 && b <= 57 || b >= 65 && b <= 70 || b >= 97 && b <= 102);
            if (isHex2) {
              effectiveLen -= 2;
              i += 2;
            }
          }
        }
        let pad = 0;
        let idx = len - 1;
        const tailIsPct3D = (j) => j >= 2 && body.charCodeAt(j - 2) === 37 && // '%'
        body.charCodeAt(j - 1) === 51 && // '3'
        (body.charCodeAt(j) === 68 || body.charCodeAt(j) === 100);
        if (idx >= 0) {
          if (body.charCodeAt(idx) === 61) {
            pad++;
            idx--;
          } else if (tailIsPct3D(idx)) {
            pad++;
            idx -= 3;
          }
        }
        if (pad === 1 && idx >= 0) {
          if (body.charCodeAt(idx) === 61) {
            pad++;
          } else if (tailIsPct3D(idx)) {
            pad++;
          }
        }
        const groups = Math.floor(effectiveLen / 4);
        const bytes = groups * 3 - (pad || 0);
        return bytes > 0 ? bytes : 0;
      }
      return Buffer.byteLength(body, "utf8");
    }
    var zlibOptions = {
      flush: zlib__default["default"].constants.Z_SYNC_FLUSH,
      finishFlush: zlib__default["default"].constants.Z_SYNC_FLUSH
    };
    var brotliOptions = {
      flush: zlib__default["default"].constants.BROTLI_OPERATION_FLUSH,
      finishFlush: zlib__default["default"].constants.BROTLI_OPERATION_FLUSH
    };
    var isBrotliSupported = utils$1.isFunction(zlib__default["default"].createBrotliDecompress);
    var { http: httpFollow, https: httpsFollow } = followRedirects__default["default"];
    var isHttps = /https:?/;
    var supportedProtocols = platform.protocols.map((protocol) => {
      return protocol + ":";
    });
    var flushOnFinish = (stream2, [throttled, flush]) => {
      stream2.on("end", flush).on("error", flush);
      return throttled;
    };
    var Http2Sessions = class {
      constructor() {
        this.sessions = /* @__PURE__ */ Object.create(null);
      }
      getSession(authority, options) {
        options = Object.assign({
          sessionTimeout: 1e3
        }, options);
        let authoritySessions = this.sessions[authority];
        if (authoritySessions) {
          let len = authoritySessions.length;
          for (let i = 0; i < len; i++) {
            const [sessionHandle, sessionOptions] = authoritySessions[i];
            if (!sessionHandle.destroyed && !sessionHandle.closed && util__default["default"].isDeepStrictEqual(sessionOptions, options)) {
              return sessionHandle;
            }
          }
        }
        const session = http2__default["default"].connect(authority, options);
        let removed;
        const removeSession = () => {
          if (removed) {
            return;
          }
          removed = true;
          let entries = authoritySessions, len = entries.length, i = len;
          while (i--) {
            if (entries[i][0] === session) {
              if (len === 1) {
                delete this.sessions[authority];
              } else {
                entries.splice(i, 1);
              }
              return;
            }
          }
        };
        const originalRequestFn = session.request;
        const { sessionTimeout } = options;
        if (sessionTimeout != null) {
          let timer;
          let streamsCount = 0;
          session.request = function() {
            const stream2 = originalRequestFn.apply(this, arguments);
            streamsCount++;
            if (timer) {
              clearTimeout(timer);
              timer = null;
            }
            stream2.once("close", () => {
              if (!--streamsCount) {
                timer = setTimeout(() => {
                  timer = null;
                  removeSession();
                }, sessionTimeout);
              }
            });
            return stream2;
          };
        }
        session.once("close", removeSession);
        let entry = [
          session,
          options
        ];
        authoritySessions ? authoritySessions.push(entry) : authoritySessions = this.sessions[authority] = [entry];
        return session;
      }
    };
    var http2Sessions = new Http2Sessions();
    function dispatchBeforeRedirect(options, responseDetails) {
      if (options.beforeRedirects.proxy) {
        options.beforeRedirects.proxy(options);
      }
      if (options.beforeRedirects.config) {
        options.beforeRedirects.config(options, responseDetails);
      }
    }
    function setProxy(options, configProxy, location) {
      let proxy = configProxy;
      if (!proxy && proxy !== false) {
        const proxyUrl = proxyFromEnv__default["default"].getProxyForUrl(location);
        if (proxyUrl) {
          proxy = new URL(proxyUrl);
        }
      }
      if (proxy) {
        if (proxy.username) {
          proxy.auth = (proxy.username || "") + ":" + (proxy.password || "");
        }
        if (proxy.auth) {
          if (proxy.auth.username || proxy.auth.password) {
            proxy.auth = (proxy.auth.username || "") + ":" + (proxy.auth.password || "");
          }
          const base64 = Buffer.from(proxy.auth, "utf8").toString("base64");
          options.headers["Proxy-Authorization"] = "Basic " + base64;
        }
        options.headers.host = options.hostname + (options.port ? ":" + options.port : "");
        const proxyHost = proxy.hostname || proxy.host;
        options.hostname = proxyHost;
        options.host = proxyHost;
        options.port = proxy.port;
        options.path = location;
        if (proxy.protocol) {
          options.protocol = proxy.protocol.includes(":") ? proxy.protocol : `${proxy.protocol}:`;
        }
      }
      options.beforeRedirects.proxy = function beforeRedirect(redirectOptions) {
        setProxy(redirectOptions, configProxy, redirectOptions.href);
      };
    }
    var isHttpAdapterSupported = typeof process !== "undefined" && utils$1.kindOf(process) === "process";
    var wrapAsync = (asyncExecutor) => {
      return new Promise((resolve, reject) => {
        let onDone;
        let isDone;
        const done = (value, isRejected) => {
          if (isDone)
            return;
          isDone = true;
          onDone && onDone(value, isRejected);
        };
        const _resolve = (value) => {
          done(value);
          resolve(value);
        };
        const _reject = (reason) => {
          done(reason, true);
          reject(reason);
        };
        asyncExecutor(_resolve, _reject, (onDoneHandler) => onDone = onDoneHandler).catch(_reject);
      });
    };
    var resolveFamily = ({ address, family }) => {
      if (!utils$1.isString(address)) {
        throw TypeError("address must be a string");
      }
      return {
        address,
        family: family || (address.indexOf(".") < 0 ? 6 : 4)
      };
    };
    var buildAddressEntry = (address, family) => resolveFamily(utils$1.isObject(address) ? address : { address, family });
    var http2Transport = {
      request(options, cb) {
        const authority = options.protocol + "//" + options.hostname + ":" + (options.port || 80);
        const { http2Options, headers } = options;
        const session = http2Sessions.getSession(authority, http2Options);
        const {
          HTTP2_HEADER_SCHEME,
          HTTP2_HEADER_METHOD,
          HTTP2_HEADER_PATH,
          HTTP2_HEADER_STATUS
        } = http2__default["default"].constants;
        const http2Headers = {
          [HTTP2_HEADER_SCHEME]: options.protocol.replace(":", ""),
          [HTTP2_HEADER_METHOD]: options.method,
          [HTTP2_HEADER_PATH]: options.path
        };
        utils$1.forEach(headers, (header, name) => {
          name.charAt(0) !== ":" && (http2Headers[name] = header);
        });
        const req = session.request(http2Headers);
        req.once("response", (responseHeaders) => {
          const response = req;
          responseHeaders = Object.assign({}, responseHeaders);
          const status = responseHeaders[HTTP2_HEADER_STATUS];
          delete responseHeaders[HTTP2_HEADER_STATUS];
          response.headers = responseHeaders;
          response.statusCode = +status;
          cb(response);
        });
        return req;
      }
    };
    var httpAdapter = isHttpAdapterSupported && function httpAdapter2(config2) {
      return wrapAsync(async function dispatchHttpRequest(resolve, reject, onDone) {
        let { data, lookup, family, httpVersion = 1, http2Options } = config2;
        const { responseType, responseEncoding } = config2;
        const method = config2.method.toUpperCase();
        let isDone;
        let rejected = false;
        let req;
        httpVersion = +httpVersion;
        if (Number.isNaN(httpVersion)) {
          throw TypeError(`Invalid protocol version: '${config2.httpVersion}' is not a number`);
        }
        if (httpVersion !== 1 && httpVersion !== 2) {
          throw TypeError(`Unsupported protocol version '${httpVersion}'`);
        }
        const isHttp2 = httpVersion === 2;
        if (lookup) {
          const _lookup = callbackify$1(lookup, (value) => utils$1.isArray(value) ? value : [value]);
          lookup = (hostname, opt, cb) => {
            _lookup(hostname, opt, (err, arg0, arg1) => {
              if (err) {
                return cb(err);
              }
              const addresses = utils$1.isArray(arg0) ? arg0.map((addr) => buildAddressEntry(addr)) : [buildAddressEntry(arg0, arg1)];
              opt.all ? cb(err, addresses) : cb(err, addresses[0].address, addresses[0].family);
            });
          };
        }
        const abortEmitter = new events.EventEmitter();
        function abort(reason) {
          try {
            abortEmitter.emit("abort", !reason || reason.type ? new CanceledError(null, config2, req) : reason);
          } catch (err) {
            console.warn("emit error", err);
          }
        }
        abortEmitter.once("abort", reject);
        const onFinished = () => {
          if (config2.cancelToken) {
            config2.cancelToken.unsubscribe(abort);
          }
          if (config2.signal) {
            config2.signal.removeEventListener("abort", abort);
          }
          abortEmitter.removeAllListeners();
        };
        if (config2.cancelToken || config2.signal) {
          config2.cancelToken && config2.cancelToken.subscribe(abort);
          if (config2.signal) {
            config2.signal.aborted ? abort() : config2.signal.addEventListener("abort", abort);
          }
        }
        onDone((response, isRejected) => {
          isDone = true;
          if (isRejected) {
            rejected = true;
            onFinished();
            return;
          }
          const { data: data2 } = response;
          if (data2 instanceof stream__default["default"].Readable || data2 instanceof stream__default["default"].Duplex) {
            const offListeners = stream__default["default"].finished(data2, () => {
              offListeners();
              onFinished();
            });
          } else {
            onFinished();
          }
        });
        const fullPath = buildFullPath(config2.baseURL, config2.url, config2.allowAbsoluteUrls);
        const parsed = new URL(fullPath, platform.hasBrowserEnv ? platform.origin : void 0);
        const protocol = parsed.protocol || supportedProtocols[0];
        if (protocol === "data:") {
          if (config2.maxContentLength > -1) {
            const dataUrl = String(config2.url || fullPath || "");
            const estimated = estimateDataURLDecodedBytes(dataUrl);
            if (estimated > config2.maxContentLength) {
              return reject(new AxiosError(
                "maxContentLength size of " + config2.maxContentLength + " exceeded",
                AxiosError.ERR_BAD_RESPONSE,
                config2
              ));
            }
          }
          let convertedData;
          if (method !== "GET") {
            return settle(resolve, reject, {
              status: 405,
              statusText: "method not allowed",
              headers: {},
              config: config2
            });
          }
          try {
            convertedData = fromDataURI(config2.url, responseType === "blob", {
              Blob: config2.env && config2.env.Blob
            });
          } catch (err) {
            throw AxiosError.from(err, AxiosError.ERR_BAD_REQUEST, config2);
          }
          if (responseType === "text") {
            convertedData = convertedData.toString(responseEncoding);
            if (!responseEncoding || responseEncoding === "utf8") {
              convertedData = utils$1.stripBOM(convertedData);
            }
          } else if (responseType === "stream") {
            convertedData = stream__default["default"].Readable.from(convertedData);
          }
          return settle(resolve, reject, {
            data: convertedData,
            status: 200,
            statusText: "OK",
            headers: new AxiosHeaders$1(),
            config: config2
          });
        }
        if (supportedProtocols.indexOf(protocol) === -1) {
          return reject(new AxiosError(
            "Unsupported protocol " + protocol,
            AxiosError.ERR_BAD_REQUEST,
            config2
          ));
        }
        const headers = AxiosHeaders$1.from(config2.headers).normalize();
        headers.set("User-Agent", "axios/" + VERSION, false);
        const { onUploadProgress, onDownloadProgress } = config2;
        const maxRate = config2.maxRate;
        let maxUploadRate = void 0;
        let maxDownloadRate = void 0;
        if (utils$1.isSpecCompliantForm(data)) {
          const userBoundary = headers.getContentType(/boundary=([-_\w\d]{10,70})/i);
          data = formDataToStream$1(data, (formHeaders) => {
            headers.set(formHeaders);
          }, {
            tag: `axios-${VERSION}-boundary`,
            boundary: userBoundary && userBoundary[1] || void 0
          });
        } else if (utils$1.isFormData(data) && utils$1.isFunction(data.getHeaders)) {
          headers.set(data.getHeaders());
          if (!headers.hasContentLength()) {
            try {
              const knownLength = await util__default["default"].promisify(data.getLength).call(data);
              Number.isFinite(knownLength) && knownLength >= 0 && headers.setContentLength(knownLength);
            } catch (e) {
            }
          }
        } else if (utils$1.isBlob(data) || utils$1.isFile(data)) {
          data.size && headers.setContentType(data.type || "application/octet-stream");
          headers.setContentLength(data.size || 0);
          data = stream__default["default"].Readable.from(readBlob$1(data));
        } else if (data && !utils$1.isStream(data)) {
          if (Buffer.isBuffer(data))
            ;
          else if (utils$1.isArrayBuffer(data)) {
            data = Buffer.from(new Uint8Array(data));
          } else if (utils$1.isString(data)) {
            data = Buffer.from(data, "utf-8");
          } else {
            return reject(new AxiosError(
              "Data after transformation must be a string, an ArrayBuffer, a Buffer, or a Stream",
              AxiosError.ERR_BAD_REQUEST,
              config2
            ));
          }
          headers.setContentLength(data.length, false);
          if (config2.maxBodyLength > -1 && data.length > config2.maxBodyLength) {
            return reject(new AxiosError(
              "Request body larger than maxBodyLength limit",
              AxiosError.ERR_BAD_REQUEST,
              config2
            ));
          }
        }
        const contentLength = utils$1.toFiniteNumber(headers.getContentLength());
        if (utils$1.isArray(maxRate)) {
          maxUploadRate = maxRate[0];
          maxDownloadRate = maxRate[1];
        } else {
          maxUploadRate = maxDownloadRate = maxRate;
        }
        if (data && (onUploadProgress || maxUploadRate)) {
          if (!utils$1.isStream(data)) {
            data = stream__default["default"].Readable.from(data, { objectMode: false });
          }
          data = stream__default["default"].pipeline([data, new AxiosTransformStream$1({
            maxRate: utils$1.toFiniteNumber(maxUploadRate)
          })], utils$1.noop);
          onUploadProgress && data.on("progress", flushOnFinish(
            data,
            progressEventDecorator(
              contentLength,
              progressEventReducer(asyncDecorator(onUploadProgress), false, 3)
            )
          ));
        }
        let auth = void 0;
        if (config2.auth) {
          const username = config2.auth.username || "";
          const password = config2.auth.password || "";
          auth = username + ":" + password;
        }
        if (!auth && parsed.username) {
          const urlUsername = parsed.username;
          const urlPassword = parsed.password;
          auth = urlUsername + ":" + urlPassword;
        }
        auth && headers.delete("authorization");
        let path;
        try {
          path = buildURL(
            parsed.pathname + parsed.search,
            config2.params,
            config2.paramsSerializer
          ).replace(/^\?/, "");
        } catch (err) {
          const customErr = new Error(err.message);
          customErr.config = config2;
          customErr.url = config2.url;
          customErr.exists = true;
          return reject(customErr);
        }
        headers.set(
          "Accept-Encoding",
          "gzip, compress, deflate" + (isBrotliSupported ? ", br" : ""),
          false
        );
        const options = {
          path,
          method,
          headers: headers.toJSON(),
          agents: { http: config2.httpAgent, https: config2.httpsAgent },
          auth,
          protocol,
          family,
          beforeRedirect: dispatchBeforeRedirect,
          beforeRedirects: {},
          http2Options
        };
        !utils$1.isUndefined(lookup) && (options.lookup = lookup);
        if (config2.socketPath) {
          options.socketPath = config2.socketPath;
        } else {
          options.hostname = parsed.hostname.startsWith("[") ? parsed.hostname.slice(1, -1) : parsed.hostname;
          options.port = parsed.port;
          setProxy(options, config2.proxy, protocol + "//" + parsed.hostname + (parsed.port ? ":" + parsed.port : "") + options.path);
        }
        let transport;
        const isHttpsRequest = isHttps.test(options.protocol);
        options.agent = isHttpsRequest ? config2.httpsAgent : config2.httpAgent;
        if (isHttp2) {
          transport = http2Transport;
        } else {
          if (config2.transport) {
            transport = config2.transport;
          } else if (config2.maxRedirects === 0) {
            transport = isHttpsRequest ? https__default["default"] : http__default["default"];
          } else {
            if (config2.maxRedirects) {
              options.maxRedirects = config2.maxRedirects;
            }
            if (config2.beforeRedirect) {
              options.beforeRedirects.config = config2.beforeRedirect;
            }
            transport = isHttpsRequest ? httpsFollow : httpFollow;
          }
        }
        if (config2.maxBodyLength > -1) {
          options.maxBodyLength = config2.maxBodyLength;
        } else {
          options.maxBodyLength = Infinity;
        }
        if (config2.insecureHTTPParser) {
          options.insecureHTTPParser = config2.insecureHTTPParser;
        }
        req = transport.request(options, function handleResponse(res) {
          if (req.destroyed)
            return;
          const streams = [res];
          const responseLength = utils$1.toFiniteNumber(res.headers["content-length"]);
          if (onDownloadProgress || maxDownloadRate) {
            const transformStream = new AxiosTransformStream$1({
              maxRate: utils$1.toFiniteNumber(maxDownloadRate)
            });
            onDownloadProgress && transformStream.on("progress", flushOnFinish(
              transformStream,
              progressEventDecorator(
                responseLength,
                progressEventReducer(asyncDecorator(onDownloadProgress), true, 3)
              )
            ));
            streams.push(transformStream);
          }
          let responseStream = res;
          const lastRequest = res.req || req;
          if (config2.decompress !== false && res.headers["content-encoding"]) {
            if (method === "HEAD" || res.statusCode === 204) {
              delete res.headers["content-encoding"];
            }
            switch ((res.headers["content-encoding"] || "").toLowerCase()) {
              case "gzip":
              case "x-gzip":
              case "compress":
              case "x-compress":
                streams.push(zlib__default["default"].createUnzip(zlibOptions));
                delete res.headers["content-encoding"];
                break;
              case "deflate":
                streams.push(new ZlibHeaderTransformStream$1());
                streams.push(zlib__default["default"].createUnzip(zlibOptions));
                delete res.headers["content-encoding"];
                break;
              case "br":
                if (isBrotliSupported) {
                  streams.push(zlib__default["default"].createBrotliDecompress(brotliOptions));
                  delete res.headers["content-encoding"];
                }
            }
          }
          responseStream = streams.length > 1 ? stream__default["default"].pipeline(streams, utils$1.noop) : streams[0];
          const response = {
            status: res.statusCode,
            statusText: res.statusMessage,
            headers: new AxiosHeaders$1(res.headers),
            config: config2,
            request: lastRequest
          };
          if (responseType === "stream") {
            response.data = responseStream;
            settle(resolve, reject, response);
          } else {
            const responseBuffer = [];
            let totalResponseBytes = 0;
            responseStream.on("data", function handleStreamData(chunk) {
              responseBuffer.push(chunk);
              totalResponseBytes += chunk.length;
              if (config2.maxContentLength > -1 && totalResponseBytes > config2.maxContentLength) {
                rejected = true;
                responseStream.destroy();
                abort(new AxiosError(
                  "maxContentLength size of " + config2.maxContentLength + " exceeded",
                  AxiosError.ERR_BAD_RESPONSE,
                  config2,
                  lastRequest
                ));
              }
            });
            responseStream.on("aborted", function handlerStreamAborted() {
              if (rejected) {
                return;
              }
              const err = new AxiosError(
                "stream has been aborted",
                AxiosError.ERR_BAD_RESPONSE,
                config2,
                lastRequest
              );
              responseStream.destroy(err);
              reject(err);
            });
            responseStream.on("error", function handleStreamError(err) {
              if (req.destroyed)
                return;
              reject(AxiosError.from(err, null, config2, lastRequest));
            });
            responseStream.on("end", function handleStreamEnd() {
              try {
                let responseData = responseBuffer.length === 1 ? responseBuffer[0] : Buffer.concat(responseBuffer);
                if (responseType !== "arraybuffer") {
                  responseData = responseData.toString(responseEncoding);
                  if (!responseEncoding || responseEncoding === "utf8") {
                    responseData = utils$1.stripBOM(responseData);
                  }
                }
                response.data = responseData;
              } catch (err) {
                return reject(AxiosError.from(err, null, config2, response.request, response));
              }
              settle(resolve, reject, response);
            });
          }
          abortEmitter.once("abort", (err) => {
            if (!responseStream.destroyed) {
              responseStream.emit("error", err);
              responseStream.destroy();
            }
          });
        });
        abortEmitter.once("abort", (err) => {
          if (req.close) {
            req.close();
          } else {
            req.destroy(err);
          }
        });
        req.on("error", function handleRequestError(err) {
          reject(AxiosError.from(err, null, config2, req));
        });
        req.on("socket", function handleRequestSocket(socket) {
          socket.setKeepAlive(true, 1e3 * 60);
        });
        if (config2.timeout) {
          const timeout = parseInt(config2.timeout, 10);
          if (Number.isNaN(timeout)) {
            abort(new AxiosError(
              "error trying to parse `config.timeout` to int",
              AxiosError.ERR_BAD_OPTION_VALUE,
              config2,
              req
            ));
            return;
          }
          req.setTimeout(timeout, function handleRequestTimeout() {
            if (isDone)
              return;
            let timeoutErrorMessage = config2.timeout ? "timeout of " + config2.timeout + "ms exceeded" : "timeout exceeded";
            const transitional = config2.transitional || transitionalDefaults;
            if (config2.timeoutErrorMessage) {
              timeoutErrorMessage = config2.timeoutErrorMessage;
            }
            abort(new AxiosError(
              timeoutErrorMessage,
              transitional.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED,
              config2,
              req
            ));
          });
        } else {
          req.setTimeout(0);
        }
        if (utils$1.isStream(data)) {
          let ended = false;
          let errored = false;
          data.on("end", () => {
            ended = true;
          });
          data.once("error", (err) => {
            errored = true;
            req.destroy(err);
          });
          data.on("close", () => {
            if (!ended && !errored) {
              abort(new CanceledError("Request stream has been aborted", config2, req));
            }
          });
          data.pipe(req);
        } else {
          data && req.write(data);
          req.end();
        }
      });
    };
    var isURLSameOrigin = platform.hasStandardBrowserEnv ? /* @__PURE__ */ ((origin2, isMSIE) => (url2) => {
      url2 = new URL(url2, platform.origin);
      return origin2.protocol === url2.protocol && origin2.host === url2.host && (isMSIE || origin2.port === url2.port);
    })(
      new URL(platform.origin),
      platform.navigator && /(msie|trident)/i.test(platform.navigator.userAgent)
    ) : () => true;
    var cookies = platform.hasStandardBrowserEnv ? (
      // Standard browser envs support document.cookie
      {
        write(name, value, expires, path, domain, secure, sameSite) {
          if (typeof document === "undefined")
            return;
          const cookie = [`${name}=${encodeURIComponent(value)}`];
          if (utils$1.isNumber(expires)) {
            cookie.push(`expires=${new Date(expires).toUTCString()}`);
          }
          if (utils$1.isString(path)) {
            cookie.push(`path=${path}`);
          }
          if (utils$1.isString(domain)) {
            cookie.push(`domain=${domain}`);
          }
          if (secure === true) {
            cookie.push("secure");
          }
          if (utils$1.isString(sameSite)) {
            cookie.push(`SameSite=${sameSite}`);
          }
          document.cookie = cookie.join("; ");
        },
        read(name) {
          if (typeof document === "undefined")
            return null;
          const match = document.cookie.match(new RegExp("(?:^|; )" + name + "=([^;]*)"));
          return match ? decodeURIComponent(match[1]) : null;
        },
        remove(name) {
          this.write(name, "", Date.now() - 864e5, "/");
        }
      }
    ) : (
      // Non-standard browser env (web workers, react-native) lack needed support.
      {
        write() {
        },
        read() {
          return null;
        },
        remove() {
        }
      }
    );
    var headersToObject = (thing) => thing instanceof AxiosHeaders$1 ? { ...thing } : thing;
    function mergeConfig(config1, config2) {
      config2 = config2 || {};
      const config3 = {};
      function getMergedValue(target, source, prop, caseless) {
        if (utils$1.isPlainObject(target) && utils$1.isPlainObject(source)) {
          return utils$1.merge.call({ caseless }, target, source);
        } else if (utils$1.isPlainObject(source)) {
          return utils$1.merge({}, source);
        } else if (utils$1.isArray(source)) {
          return source.slice();
        }
        return source;
      }
      function mergeDeepProperties(a, b, prop, caseless) {
        if (!utils$1.isUndefined(b)) {
          return getMergedValue(a, b, prop, caseless);
        } else if (!utils$1.isUndefined(a)) {
          return getMergedValue(void 0, a, prop, caseless);
        }
      }
      function valueFromConfig2(a, b) {
        if (!utils$1.isUndefined(b)) {
          return getMergedValue(void 0, b);
        }
      }
      function defaultToConfig2(a, b) {
        if (!utils$1.isUndefined(b)) {
          return getMergedValue(void 0, b);
        } else if (!utils$1.isUndefined(a)) {
          return getMergedValue(void 0, a);
        }
      }
      function mergeDirectKeys(a, b, prop) {
        if (prop in config2) {
          return getMergedValue(a, b);
        } else if (prop in config1) {
          return getMergedValue(void 0, a);
        }
      }
      const mergeMap = {
        url: valueFromConfig2,
        method: valueFromConfig2,
        data: valueFromConfig2,
        baseURL: defaultToConfig2,
        transformRequest: defaultToConfig2,
        transformResponse: defaultToConfig2,
        paramsSerializer: defaultToConfig2,
        timeout: defaultToConfig2,
        timeoutMessage: defaultToConfig2,
        withCredentials: defaultToConfig2,
        withXSRFToken: defaultToConfig2,
        adapter: defaultToConfig2,
        responseType: defaultToConfig2,
        xsrfCookieName: defaultToConfig2,
        xsrfHeaderName: defaultToConfig2,
        onUploadProgress: defaultToConfig2,
        onDownloadProgress: defaultToConfig2,
        decompress: defaultToConfig2,
        maxContentLength: defaultToConfig2,
        maxBodyLength: defaultToConfig2,
        beforeRedirect: defaultToConfig2,
        transport: defaultToConfig2,
        httpAgent: defaultToConfig2,
        httpsAgent: defaultToConfig2,
        cancelToken: defaultToConfig2,
        socketPath: defaultToConfig2,
        responseEncoding: defaultToConfig2,
        validateStatus: mergeDirectKeys,
        headers: (a, b, prop) => mergeDeepProperties(headersToObject(a), headersToObject(b), prop, true)
      };
      utils$1.forEach(Object.keys({ ...config1, ...config2 }), function computeConfigValue(prop) {
        const merge2 = mergeMap[prop] || mergeDeepProperties;
        const configValue = merge2(config1[prop], config2[prop], prop);
        utils$1.isUndefined(configValue) && merge2 !== mergeDirectKeys || (config3[prop] = configValue);
      });
      return config3;
    }
    var resolveConfig = (config2) => {
      const newConfig = mergeConfig({}, config2);
      let { data, withXSRFToken, xsrfHeaderName, xsrfCookieName, headers, auth } = newConfig;
      newConfig.headers = headers = AxiosHeaders$1.from(headers);
      newConfig.url = buildURL(buildFullPath(newConfig.baseURL, newConfig.url, newConfig.allowAbsoluteUrls), config2.params, config2.paramsSerializer);
      if (auth) {
        headers.set(
          "Authorization",
          "Basic " + btoa((auth.username || "") + ":" + (auth.password ? unescape(encodeURIComponent(auth.password)) : ""))
        );
      }
      if (utils$1.isFormData(data)) {
        if (platform.hasStandardBrowserEnv || platform.hasStandardBrowserWebWorkerEnv) {
          headers.setContentType(void 0);
        } else if (utils$1.isFunction(data.getHeaders)) {
          const formHeaders = data.getHeaders();
          const allowedHeaders = ["content-type", "content-length"];
          Object.entries(formHeaders).forEach(([key, val]) => {
            if (allowedHeaders.includes(key.toLowerCase())) {
              headers.set(key, val);
            }
          });
        }
      }
      if (platform.hasStandardBrowserEnv) {
        withXSRFToken && utils$1.isFunction(withXSRFToken) && (withXSRFToken = withXSRFToken(newConfig));
        if (withXSRFToken || withXSRFToken !== false && isURLSameOrigin(newConfig.url)) {
          const xsrfValue = xsrfHeaderName && xsrfCookieName && cookies.read(xsrfCookieName);
          if (xsrfValue) {
            headers.set(xsrfHeaderName, xsrfValue);
          }
        }
      }
      return newConfig;
    };
    var isXHRAdapterSupported = typeof XMLHttpRequest !== "undefined";
    var xhrAdapter = isXHRAdapterSupported && function(config2) {
      return new Promise(function dispatchXhrRequest(resolve, reject) {
        const _config = resolveConfig(config2);
        let requestData = _config.data;
        const requestHeaders = AxiosHeaders$1.from(_config.headers).normalize();
        let { responseType, onUploadProgress, onDownloadProgress } = _config;
        let onCanceled;
        let uploadThrottled, downloadThrottled;
        let flushUpload, flushDownload;
        function done() {
          flushUpload && flushUpload();
          flushDownload && flushDownload();
          _config.cancelToken && _config.cancelToken.unsubscribe(onCanceled);
          _config.signal && _config.signal.removeEventListener("abort", onCanceled);
        }
        let request = new XMLHttpRequest();
        request.open(_config.method.toUpperCase(), _config.url, true);
        request.timeout = _config.timeout;
        function onloadend() {
          if (!request) {
            return;
          }
          const responseHeaders = AxiosHeaders$1.from(
            "getAllResponseHeaders" in request && request.getAllResponseHeaders()
          );
          const responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
          const response = {
            data: responseData,
            status: request.status,
            statusText: request.statusText,
            headers: responseHeaders,
            config: config2,
            request
          };
          settle(function _resolve(value) {
            resolve(value);
            done();
          }, function _reject(err) {
            reject(err);
            done();
          }, response);
          request = null;
        }
        if ("onloadend" in request) {
          request.onloadend = onloadend;
        } else {
          request.onreadystatechange = function handleLoad() {
            if (!request || request.readyState !== 4) {
              return;
            }
            if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
              return;
            }
            setTimeout(onloadend);
          };
        }
        request.onabort = function handleAbort() {
          if (!request) {
            return;
          }
          reject(new AxiosError("Request aborted", AxiosError.ECONNABORTED, config2, request));
          request = null;
        };
        request.onerror = function handleError(event) {
          const msg = event && event.message ? event.message : "Network Error";
          const err = new AxiosError(msg, AxiosError.ERR_NETWORK, config2, request);
          err.event = event || null;
          reject(err);
          request = null;
        };
        request.ontimeout = function handleTimeout() {
          let timeoutErrorMessage = _config.timeout ? "timeout of " + _config.timeout + "ms exceeded" : "timeout exceeded";
          const transitional = _config.transitional || transitionalDefaults;
          if (_config.timeoutErrorMessage) {
            timeoutErrorMessage = _config.timeoutErrorMessage;
          }
          reject(new AxiosError(
            timeoutErrorMessage,
            transitional.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED,
            config2,
            request
          ));
          request = null;
        };
        requestData === void 0 && requestHeaders.setContentType(null);
        if ("setRequestHeader" in request) {
          utils$1.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
            request.setRequestHeader(key, val);
          });
        }
        if (!utils$1.isUndefined(_config.withCredentials)) {
          request.withCredentials = !!_config.withCredentials;
        }
        if (responseType && responseType !== "json") {
          request.responseType = _config.responseType;
        }
        if (onDownloadProgress) {
          [downloadThrottled, flushDownload] = progressEventReducer(onDownloadProgress, true);
          request.addEventListener("progress", downloadThrottled);
        }
        if (onUploadProgress && request.upload) {
          [uploadThrottled, flushUpload] = progressEventReducer(onUploadProgress);
          request.upload.addEventListener("progress", uploadThrottled);
          request.upload.addEventListener("loadend", flushUpload);
        }
        if (_config.cancelToken || _config.signal) {
          onCanceled = (cancel) => {
            if (!request) {
              return;
            }
            reject(!cancel || cancel.type ? new CanceledError(null, config2, request) : cancel);
            request.abort();
            request = null;
          };
          _config.cancelToken && _config.cancelToken.subscribe(onCanceled);
          if (_config.signal) {
            _config.signal.aborted ? onCanceled() : _config.signal.addEventListener("abort", onCanceled);
          }
        }
        const protocol = parseProtocol(_config.url);
        if (protocol && platform.protocols.indexOf(protocol) === -1) {
          reject(new AxiosError("Unsupported protocol " + protocol + ":", AxiosError.ERR_BAD_REQUEST, config2));
          return;
        }
        request.send(requestData || null);
      });
    };
    var composeSignals = (signals, timeout) => {
      const { length } = signals = signals ? signals.filter(Boolean) : [];
      if (timeout || length) {
        let controller = new AbortController();
        let aborted;
        const onabort = function(reason) {
          if (!aborted) {
            aborted = true;
            unsubscribe();
            const err = reason instanceof Error ? reason : this.reason;
            controller.abort(err instanceof AxiosError ? err : new CanceledError(err instanceof Error ? err.message : err));
          }
        };
        let timer = timeout && setTimeout(() => {
          timer = null;
          onabort(new AxiosError(`timeout ${timeout} of ms exceeded`, AxiosError.ETIMEDOUT));
        }, timeout);
        const unsubscribe = () => {
          if (signals) {
            timer && clearTimeout(timer);
            timer = null;
            signals.forEach((signal2) => {
              signal2.unsubscribe ? signal2.unsubscribe(onabort) : signal2.removeEventListener("abort", onabort);
            });
            signals = null;
          }
        };
        signals.forEach((signal2) => signal2.addEventListener("abort", onabort));
        const { signal } = controller;
        signal.unsubscribe = () => utils$1.asap(unsubscribe);
        return signal;
      }
    };
    var composeSignals$1 = composeSignals;
    var streamChunk = function* (chunk, chunkSize) {
      let len = chunk.byteLength;
      if (!chunkSize || len < chunkSize) {
        yield chunk;
        return;
      }
      let pos = 0;
      let end;
      while (pos < len) {
        end = pos + chunkSize;
        yield chunk.slice(pos, end);
        pos = end;
      }
    };
    var readBytes = async function* (iterable, chunkSize) {
      for await (const chunk of readStream(iterable)) {
        yield* streamChunk(chunk, chunkSize);
      }
    };
    var readStream = async function* (stream2) {
      if (stream2[Symbol.asyncIterator]) {
        yield* stream2;
        return;
      }
      const reader = stream2.getReader();
      try {
        for (; ; ) {
          const { done, value } = await reader.read();
          if (done) {
            break;
          }
          yield value;
        }
      } finally {
        await reader.cancel();
      }
    };
    var trackStream = (stream2, chunkSize, onProgress, onFinish) => {
      const iterator2 = readBytes(stream2, chunkSize);
      let bytes = 0;
      let done;
      let _onFinish = (e) => {
        if (!done) {
          done = true;
          onFinish && onFinish(e);
        }
      };
      return new ReadableStream({
        async pull(controller) {
          try {
            const { done: done2, value } = await iterator2.next();
            if (done2) {
              _onFinish();
              controller.close();
              return;
            }
            let len = value.byteLength;
            if (onProgress) {
              let loadedBytes = bytes += len;
              onProgress(loadedBytes);
            }
            controller.enqueue(new Uint8Array(value));
          } catch (err) {
            _onFinish(err);
            throw err;
          }
        },
        cancel(reason) {
          _onFinish(reason);
          return iterator2.return();
        }
      }, {
        highWaterMark: 2
      });
    };
    var DEFAULT_CHUNK_SIZE = 64 * 1024;
    var { isFunction } = utils$1;
    var globalFetchAPI = (({ Request, Response }) => ({
      Request,
      Response
    }))(utils$1.global);
    var {
      ReadableStream: ReadableStream$1,
      TextEncoder: TextEncoder$1
    } = utils$1.global;
    var test = (fn, ...args) => {
      try {
        return !!fn(...args);
      } catch (e) {
        return false;
      }
    };
    var factory = (env) => {
      env = utils$1.merge.call({
        skipUndefined: true
      }, globalFetchAPI, env);
      const { fetch: envFetch, Request, Response } = env;
      const isFetchSupported = envFetch ? isFunction(envFetch) : typeof fetch === "function";
      const isRequestSupported = isFunction(Request);
      const isResponseSupported = isFunction(Response);
      if (!isFetchSupported) {
        return false;
      }
      const isReadableStreamSupported = isFetchSupported && isFunction(ReadableStream$1);
      const encodeText = isFetchSupported && (typeof TextEncoder$1 === "function" ? /* @__PURE__ */ ((encoder) => (str2) => encoder.encode(str2))(new TextEncoder$1()) : async (str2) => new Uint8Array(await new Request(str2).arrayBuffer()));
      const supportsRequestStream = isRequestSupported && isReadableStreamSupported && test(() => {
        let duplexAccessed = false;
        const hasContentType = new Request(platform.origin, {
          body: new ReadableStream$1(),
          method: "POST",
          get duplex() {
            duplexAccessed = true;
            return "half";
          }
        }).headers.has("Content-Type");
        return duplexAccessed && !hasContentType;
      });
      const supportsResponseStream = isResponseSupported && isReadableStreamSupported && test(() => utils$1.isReadableStream(new Response("").body));
      const resolvers = {
        stream: supportsResponseStream && ((res) => res.body)
      };
      isFetchSupported && (() => {
        ["text", "arrayBuffer", "blob", "formData", "stream"].forEach((type) => {
          !resolvers[type] && (resolvers[type] = (res, config2) => {
            let method = res && res[type];
            if (method) {
              return method.call(res);
            }
            throw new AxiosError(`Response type '${type}' is not supported`, AxiosError.ERR_NOT_SUPPORT, config2);
          });
        });
      })();
      const getBodyLength = async (body) => {
        if (body == null) {
          return 0;
        }
        if (utils$1.isBlob(body)) {
          return body.size;
        }
        if (utils$1.isSpecCompliantForm(body)) {
          const _request = new Request(platform.origin, {
            method: "POST",
            body
          });
          return (await _request.arrayBuffer()).byteLength;
        }
        if (utils$1.isArrayBufferView(body) || utils$1.isArrayBuffer(body)) {
          return body.byteLength;
        }
        if (utils$1.isURLSearchParams(body)) {
          body = body + "";
        }
        if (utils$1.isString(body)) {
          return (await encodeText(body)).byteLength;
        }
      };
      const resolveBodyLength = async (headers, body) => {
        const length = utils$1.toFiniteNumber(headers.getContentLength());
        return length == null ? getBodyLength(body) : length;
      };
      return async (config2) => {
        let {
          url: url2,
          method,
          data,
          signal,
          cancelToken,
          timeout,
          onDownloadProgress,
          onUploadProgress,
          responseType,
          headers,
          withCredentials = "same-origin",
          fetchOptions
        } = resolveConfig(config2);
        let _fetch = envFetch || fetch;
        responseType = responseType ? (responseType + "").toLowerCase() : "text";
        let composedSignal = composeSignals$1([signal, cancelToken && cancelToken.toAbortSignal()], timeout);
        let request = null;
        const unsubscribe = composedSignal && composedSignal.unsubscribe && (() => {
          composedSignal.unsubscribe();
        });
        let requestContentLength;
        try {
          if (onUploadProgress && supportsRequestStream && method !== "get" && method !== "head" && (requestContentLength = await resolveBodyLength(headers, data)) !== 0) {
            let _request = new Request(url2, {
              method: "POST",
              body: data,
              duplex: "half"
            });
            let contentTypeHeader;
            if (utils$1.isFormData(data) && (contentTypeHeader = _request.headers.get("content-type"))) {
              headers.setContentType(contentTypeHeader);
            }
            if (_request.body) {
              const [onProgress, flush] = progressEventDecorator(
                requestContentLength,
                progressEventReducer(asyncDecorator(onUploadProgress))
              );
              data = trackStream(_request.body, DEFAULT_CHUNK_SIZE, onProgress, flush);
            }
          }
          if (!utils$1.isString(withCredentials)) {
            withCredentials = withCredentials ? "include" : "omit";
          }
          const isCredentialsSupported = isRequestSupported && "credentials" in Request.prototype;
          const resolvedOptions = {
            ...fetchOptions,
            signal: composedSignal,
            method: method.toUpperCase(),
            headers: headers.normalize().toJSON(),
            body: data,
            duplex: "half",
            credentials: isCredentialsSupported ? withCredentials : void 0
          };
          request = isRequestSupported && new Request(url2, resolvedOptions);
          let response = await (isRequestSupported ? _fetch(request, fetchOptions) : _fetch(url2, resolvedOptions));
          const isStreamResponse = supportsResponseStream && (responseType === "stream" || responseType === "response");
          if (supportsResponseStream && (onDownloadProgress || isStreamResponse && unsubscribe)) {
            const options = {};
            ["status", "statusText", "headers"].forEach((prop) => {
              options[prop] = response[prop];
            });
            const responseContentLength = utils$1.toFiniteNumber(response.headers.get("content-length"));
            const [onProgress, flush] = onDownloadProgress && progressEventDecorator(
              responseContentLength,
              progressEventReducer(asyncDecorator(onDownloadProgress), true)
            ) || [];
            response = new Response(
              trackStream(response.body, DEFAULT_CHUNK_SIZE, onProgress, () => {
                flush && flush();
                unsubscribe && unsubscribe();
              }),
              options
            );
          }
          responseType = responseType || "text";
          let responseData = await resolvers[utils$1.findKey(resolvers, responseType) || "text"](response, config2);
          !isStreamResponse && unsubscribe && unsubscribe();
          return await new Promise((resolve, reject) => {
            settle(resolve, reject, {
              data: responseData,
              headers: AxiosHeaders$1.from(response.headers),
              status: response.status,
              statusText: response.statusText,
              config: config2,
              request
            });
          });
        } catch (err) {
          unsubscribe && unsubscribe();
          if (err && err.name === "TypeError" && /Load failed|fetch/i.test(err.message)) {
            throw Object.assign(
              new AxiosError("Network Error", AxiosError.ERR_NETWORK, config2, request),
              {
                cause: err.cause || err
              }
            );
          }
          throw AxiosError.from(err, err && err.code, config2, request);
        }
      };
    };
    var seedCache = /* @__PURE__ */ new Map();
    var getFetch = (config2) => {
      let env = config2 && config2.env || {};
      const { fetch: fetch2, Request, Response } = env;
      const seeds = [
        Request,
        Response,
        fetch2
      ];
      let len = seeds.length, i = len, seed, target, map = seedCache;
      while (i--) {
        seed = seeds[i];
        target = map.get(seed);
        target === void 0 && map.set(seed, target = i ? /* @__PURE__ */ new Map() : factory(env));
        map = target;
      }
      return target;
    };
    getFetch();
    var knownAdapters = {
      http: httpAdapter,
      xhr: xhrAdapter,
      fetch: {
        get: getFetch
      }
    };
    utils$1.forEach(knownAdapters, (fn, value) => {
      if (fn) {
        try {
          Object.defineProperty(fn, "name", { value });
        } catch (e) {
        }
        Object.defineProperty(fn, "adapterName", { value });
      }
    });
    var renderReason = (reason) => `- ${reason}`;
    var isResolvedHandle = (adapter) => utils$1.isFunction(adapter) || adapter === null || adapter === false;
    function getAdapter(adapters2, config2) {
      adapters2 = utils$1.isArray(adapters2) ? adapters2 : [adapters2];
      const { length } = adapters2;
      let nameOrAdapter;
      let adapter;
      const rejectedReasons = {};
      for (let i = 0; i < length; i++) {
        nameOrAdapter = adapters2[i];
        let id;
        adapter = nameOrAdapter;
        if (!isResolvedHandle(nameOrAdapter)) {
          adapter = knownAdapters[(id = String(nameOrAdapter)).toLowerCase()];
          if (adapter === void 0) {
            throw new AxiosError(`Unknown adapter '${id}'`);
          }
        }
        if (adapter && (utils$1.isFunction(adapter) || (adapter = adapter.get(config2)))) {
          break;
        }
        rejectedReasons[id || "#" + i] = adapter;
      }
      if (!adapter) {
        const reasons = Object.entries(rejectedReasons).map(
          ([id, state]) => `adapter ${id} ` + (state === false ? "is not supported by the environment" : "is not available in the build")
        );
        let s = length ? reasons.length > 1 ? "since :\n" + reasons.map(renderReason).join("\n") : " " + renderReason(reasons[0]) : "as no adapter specified";
        throw new AxiosError(
          `There is no suitable adapter to dispatch the request ` + s,
          "ERR_NOT_SUPPORT"
        );
      }
      return adapter;
    }
    var adapters = {
      /**
       * Resolve an adapter from a list of adapter names or functions.
       * @type {Function}
       */
      getAdapter,
      /**
       * Exposes all known adapters
       * @type {Object<string, Function|Object>}
       */
      adapters: knownAdapters
    };
    function throwIfCancellationRequested(config2) {
      if (config2.cancelToken) {
        config2.cancelToken.throwIfRequested();
      }
      if (config2.signal && config2.signal.aborted) {
        throw new CanceledError(null, config2);
      }
    }
    function dispatchRequest(config2) {
      throwIfCancellationRequested(config2);
      config2.headers = AxiosHeaders$1.from(config2.headers);
      config2.data = transformData.call(
        config2,
        config2.transformRequest
      );
      if (["post", "put", "patch"].indexOf(config2.method) !== -1) {
        config2.headers.setContentType("application/x-www-form-urlencoded", false);
      }
      const adapter = adapters.getAdapter(config2.adapter || defaults$1.adapter, config2);
      return adapter(config2).then(function onAdapterResolution(response) {
        throwIfCancellationRequested(config2);
        response.data = transformData.call(
          config2,
          config2.transformResponse,
          response
        );
        response.headers = AxiosHeaders$1.from(response.headers);
        return response;
      }, function onAdapterRejection(reason) {
        if (!isCancel(reason)) {
          throwIfCancellationRequested(config2);
          if (reason && reason.response) {
            reason.response.data = transformData.call(
              config2,
              config2.transformResponse,
              reason.response
            );
            reason.response.headers = AxiosHeaders$1.from(reason.response.headers);
          }
        }
        return Promise.reject(reason);
      });
    }
    var validators$1 = {};
    ["object", "boolean", "number", "function", "string", "symbol"].forEach((type, i) => {
      validators$1[type] = function validator2(thing) {
        return typeof thing === type || "a" + (i < 1 ? "n " : " ") + type;
      };
    });
    var deprecatedWarnings = {};
    validators$1.transitional = function transitional(validator2, version, message) {
      function formatMessage(opt, desc) {
        return "[Axios v" + VERSION + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
      }
      return (value, opt, opts) => {
        if (validator2 === false) {
          throw new AxiosError(
            formatMessage(opt, " has been removed" + (version ? " in " + version : "")),
            AxiosError.ERR_DEPRECATED
          );
        }
        if (version && !deprecatedWarnings[opt]) {
          deprecatedWarnings[opt] = true;
          console.warn(
            formatMessage(
              opt,
              " has been deprecated since v" + version + " and will be removed in the near future"
            )
          );
        }
        return validator2 ? validator2(value, opt, opts) : true;
      };
    };
    validators$1.spelling = function spelling(correctSpelling) {
      return (value, opt) => {
        console.warn(`${opt} is likely a misspelling of ${correctSpelling}`);
        return true;
      };
    };
    function assertOptions(options, schema, allowUnknown) {
      if (typeof options !== "object") {
        throw new AxiosError("options must be an object", AxiosError.ERR_BAD_OPTION_VALUE);
      }
      const keys = Object.keys(options);
      let i = keys.length;
      while (i-- > 0) {
        const opt = keys[i];
        const validator2 = schema[opt];
        if (validator2) {
          const value = options[opt];
          const result = value === void 0 || validator2(value, opt, options);
          if (result !== true) {
            throw new AxiosError("option " + opt + " must be " + result, AxiosError.ERR_BAD_OPTION_VALUE);
          }
          continue;
        }
        if (allowUnknown !== true) {
          throw new AxiosError("Unknown option " + opt, AxiosError.ERR_BAD_OPTION);
        }
      }
    }
    var validator = {
      assertOptions,
      validators: validators$1
    };
    var validators = validator.validators;
    var Axios = class {
      constructor(instanceConfig) {
        this.defaults = instanceConfig || {};
        this.interceptors = {
          request: new InterceptorManager$1(),
          response: new InterceptorManager$1()
        };
      }
      /**
       * Dispatch a request
       *
       * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
       * @param {?Object} config
       *
       * @returns {Promise} The Promise to be fulfilled
       */
      async request(configOrUrl, config2) {
        try {
          return await this._request(configOrUrl, config2);
        } catch (err) {
          if (err instanceof Error) {
            let dummy = {};
            Error.captureStackTrace ? Error.captureStackTrace(dummy) : dummy = new Error();
            const stack = dummy.stack ? dummy.stack.replace(/^.+\n/, "") : "";
            try {
              if (!err.stack) {
                err.stack = stack;
              } else if (stack && !String(err.stack).endsWith(stack.replace(/^.+\n.+\n/, ""))) {
                err.stack += "\n" + stack;
              }
            } catch (e) {
            }
          }
          throw err;
        }
      }
      _request(configOrUrl, config2) {
        if (typeof configOrUrl === "string") {
          config2 = config2 || {};
          config2.url = configOrUrl;
        } else {
          config2 = configOrUrl || {};
        }
        config2 = mergeConfig(this.defaults, config2);
        const { transitional, paramsSerializer, headers } = config2;
        if (transitional !== void 0) {
          validator.assertOptions(transitional, {
            silentJSONParsing: validators.transitional(validators.boolean),
            forcedJSONParsing: validators.transitional(validators.boolean),
            clarifyTimeoutError: validators.transitional(validators.boolean)
          }, false);
        }
        if (paramsSerializer != null) {
          if (utils$1.isFunction(paramsSerializer)) {
            config2.paramsSerializer = {
              serialize: paramsSerializer
            };
          } else {
            validator.assertOptions(paramsSerializer, {
              encode: validators.function,
              serialize: validators.function
            }, true);
          }
        }
        if (config2.allowAbsoluteUrls !== void 0)
          ;
        else if (this.defaults.allowAbsoluteUrls !== void 0) {
          config2.allowAbsoluteUrls = this.defaults.allowAbsoluteUrls;
        } else {
          config2.allowAbsoluteUrls = true;
        }
        validator.assertOptions(config2, {
          baseUrl: validators.spelling("baseURL"),
          withXsrfToken: validators.spelling("withXSRFToken")
        }, true);
        config2.method = (config2.method || this.defaults.method || "get").toLowerCase();
        let contextHeaders = headers && utils$1.merge(
          headers.common,
          headers[config2.method]
        );
        headers && utils$1.forEach(
          ["delete", "get", "head", "post", "put", "patch", "common"],
          (method) => {
            delete headers[method];
          }
        );
        config2.headers = AxiosHeaders$1.concat(contextHeaders, headers);
        const requestInterceptorChain = [];
        let synchronousRequestInterceptors = true;
        this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
          if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config2) === false) {
            return;
          }
          synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
          requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
        });
        const responseInterceptorChain = [];
        this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
          responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
        });
        let promise;
        let i = 0;
        let len;
        if (!synchronousRequestInterceptors) {
          const chain = [dispatchRequest.bind(this), void 0];
          chain.unshift(...requestInterceptorChain);
          chain.push(...responseInterceptorChain);
          len = chain.length;
          promise = Promise.resolve(config2);
          while (i < len) {
            promise = promise.then(chain[i++], chain[i++]);
          }
          return promise;
        }
        len = requestInterceptorChain.length;
        let newConfig = config2;
        while (i < len) {
          const onFulfilled = requestInterceptorChain[i++];
          const onRejected = requestInterceptorChain[i++];
          try {
            newConfig = onFulfilled(newConfig);
          } catch (error) {
            onRejected.call(this, error);
            break;
          }
        }
        try {
          promise = dispatchRequest.call(this, newConfig);
        } catch (error) {
          return Promise.reject(error);
        }
        i = 0;
        len = responseInterceptorChain.length;
        while (i < len) {
          promise = promise.then(responseInterceptorChain[i++], responseInterceptorChain[i++]);
        }
        return promise;
      }
      getUri(config2) {
        config2 = mergeConfig(this.defaults, config2);
        const fullPath = buildFullPath(config2.baseURL, config2.url, config2.allowAbsoluteUrls);
        return buildURL(fullPath, config2.params, config2.paramsSerializer);
      }
    };
    utils$1.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
      Axios.prototype[method] = function(url2, config2) {
        return this.request(mergeConfig(config2 || {}, {
          method,
          url: url2,
          data: (config2 || {}).data
        }));
      };
    });
    utils$1.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
      function generateHTTPMethod(isForm) {
        return function httpMethod(url2, data, config2) {
          return this.request(mergeConfig(config2 || {}, {
            method,
            headers: isForm ? {
              "Content-Type": "multipart/form-data"
            } : {},
            url: url2,
            data
          }));
        };
      }
      Axios.prototype[method] = generateHTTPMethod();
      Axios.prototype[method + "Form"] = generateHTTPMethod(true);
    });
    var Axios$1 = Axios;
    var CancelToken = class _CancelToken {
      constructor(executor) {
        if (typeof executor !== "function") {
          throw new TypeError("executor must be a function.");
        }
        let resolvePromise;
        this.promise = new Promise(function promiseExecutor(resolve) {
          resolvePromise = resolve;
        });
        const token = this;
        this.promise.then((cancel) => {
          if (!token._listeners)
            return;
          let i = token._listeners.length;
          while (i-- > 0) {
            token._listeners[i](cancel);
          }
          token._listeners = null;
        });
        this.promise.then = (onfulfilled) => {
          let _resolve;
          const promise = new Promise((resolve) => {
            token.subscribe(resolve);
            _resolve = resolve;
          }).then(onfulfilled);
          promise.cancel = function reject() {
            token.unsubscribe(_resolve);
          };
          return promise;
        };
        executor(function cancel(message, config2, request) {
          if (token.reason) {
            return;
          }
          token.reason = new CanceledError(message, config2, request);
          resolvePromise(token.reason);
        });
      }
      /**
       * Throws a `CanceledError` if cancellation has been requested.
       */
      throwIfRequested() {
        if (this.reason) {
          throw this.reason;
        }
      }
      /**
       * Subscribe to the cancel signal
       */
      subscribe(listener) {
        if (this.reason) {
          listener(this.reason);
          return;
        }
        if (this._listeners) {
          this._listeners.push(listener);
        } else {
          this._listeners = [listener];
        }
      }
      /**
       * Unsubscribe from the cancel signal
       */
      unsubscribe(listener) {
        if (!this._listeners) {
          return;
        }
        const index = this._listeners.indexOf(listener);
        if (index !== -1) {
          this._listeners.splice(index, 1);
        }
      }
      toAbortSignal() {
        const controller = new AbortController();
        const abort = (err) => {
          controller.abort(err);
        };
        this.subscribe(abort);
        controller.signal.unsubscribe = () => this.unsubscribe(abort);
        return controller.signal;
      }
      /**
       * Returns an object that contains a new `CancelToken` and a function that, when called,
       * cancels the `CancelToken`.
       */
      static source() {
        let cancel;
        const token = new _CancelToken(function executor(c) {
          cancel = c;
        });
        return {
          token,
          cancel
        };
      }
    };
    var CancelToken$1 = CancelToken;
    function spread(callback) {
      return function wrap(arr) {
        return callback.apply(null, arr);
      };
    }
    function isAxiosError(payload) {
      return utils$1.isObject(payload) && payload.isAxiosError === true;
    }
    var HttpStatusCode = {
      Continue: 100,
      SwitchingProtocols: 101,
      Processing: 102,
      EarlyHints: 103,
      Ok: 200,
      Created: 201,
      Accepted: 202,
      NonAuthoritativeInformation: 203,
      NoContent: 204,
      ResetContent: 205,
      PartialContent: 206,
      MultiStatus: 207,
      AlreadyReported: 208,
      ImUsed: 226,
      MultipleChoices: 300,
      MovedPermanently: 301,
      Found: 302,
      SeeOther: 303,
      NotModified: 304,
      UseProxy: 305,
      Unused: 306,
      TemporaryRedirect: 307,
      PermanentRedirect: 308,
      BadRequest: 400,
      Unauthorized: 401,
      PaymentRequired: 402,
      Forbidden: 403,
      NotFound: 404,
      MethodNotAllowed: 405,
      NotAcceptable: 406,
      ProxyAuthenticationRequired: 407,
      RequestTimeout: 408,
      Conflict: 409,
      Gone: 410,
      LengthRequired: 411,
      PreconditionFailed: 412,
      PayloadTooLarge: 413,
      UriTooLong: 414,
      UnsupportedMediaType: 415,
      RangeNotSatisfiable: 416,
      ExpectationFailed: 417,
      ImATeapot: 418,
      MisdirectedRequest: 421,
      UnprocessableEntity: 422,
      Locked: 423,
      FailedDependency: 424,
      TooEarly: 425,
      UpgradeRequired: 426,
      PreconditionRequired: 428,
      TooManyRequests: 429,
      RequestHeaderFieldsTooLarge: 431,
      UnavailableForLegalReasons: 451,
      InternalServerError: 500,
      NotImplemented: 501,
      BadGateway: 502,
      ServiceUnavailable: 503,
      GatewayTimeout: 504,
      HttpVersionNotSupported: 505,
      VariantAlsoNegotiates: 506,
      InsufficientStorage: 507,
      LoopDetected: 508,
      NotExtended: 510,
      NetworkAuthenticationRequired: 511,
      WebServerIsDown: 521,
      ConnectionTimedOut: 522,
      OriginIsUnreachable: 523,
      TimeoutOccurred: 524,
      SslHandshakeFailed: 525,
      InvalidSslCertificate: 526
    };
    Object.entries(HttpStatusCode).forEach(([key, value]) => {
      HttpStatusCode[value] = key;
    });
    var HttpStatusCode$1 = HttpStatusCode;
    function createInstance(defaultConfig) {
      const context = new Axios$1(defaultConfig);
      const instance = bind(Axios$1.prototype.request, context);
      utils$1.extend(instance, Axios$1.prototype, context, { allOwnKeys: true });
      utils$1.extend(instance, context, null, { allOwnKeys: true });
      instance.create = function create(instanceConfig) {
        return createInstance(mergeConfig(defaultConfig, instanceConfig));
      };
      return instance;
    }
    var axios = createInstance(defaults$1);
    axios.Axios = Axios$1;
    axios.CanceledError = CanceledError;
    axios.CancelToken = CancelToken$1;
    axios.isCancel = isCancel;
    axios.VERSION = VERSION;
    axios.toFormData = toFormData;
    axios.AxiosError = AxiosError;
    axios.Cancel = axios.CanceledError;
    axios.all = function all(promises) {
      return Promise.all(promises);
    };
    axios.spread = spread;
    axios.isAxiosError = isAxiosError;
    axios.mergeConfig = mergeConfig;
    axios.AxiosHeaders = AxiosHeaders$1;
    axios.formToJSON = (thing) => formDataToJSON(utils$1.isHTMLForm(thing) ? new FormData(thing) : thing);
    axios.getAdapter = adapters.getAdapter;
    axios.HttpStatusCode = HttpStatusCode$1;
    axios.default = axios;
    module2.exports = axios;
  }
});

// node_modules/lodash/lodash.js
var require_lodash = __commonJS({
  "node_modules/lodash/lodash.js"(exports2, module2) {
    (function() {
      var undefined2;
      var VERSION = "4.17.21";
      var LARGE_ARRAY_SIZE = 200;
      var CORE_ERROR_TEXT = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", FUNC_ERROR_TEXT = "Expected a function", INVALID_TEMPL_VAR_ERROR_TEXT = "Invalid `variable` option passed into `_.template`";
      var HASH_UNDEFINED = "__lodash_hash_undefined__";
      var MAX_MEMOIZE_SIZE = 500;
      var PLACEHOLDER = "__lodash_placeholder__";
      var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4;
      var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
      var WRAP_BIND_FLAG = 1, WRAP_BIND_KEY_FLAG = 2, WRAP_CURRY_BOUND_FLAG = 4, WRAP_CURRY_FLAG = 8, WRAP_CURRY_RIGHT_FLAG = 16, WRAP_PARTIAL_FLAG = 32, WRAP_PARTIAL_RIGHT_FLAG = 64, WRAP_ARY_FLAG = 128, WRAP_REARG_FLAG = 256, WRAP_FLIP_FLAG = 512;
      var DEFAULT_TRUNC_LENGTH = 30, DEFAULT_TRUNC_OMISSION = "...";
      var HOT_COUNT = 800, HOT_SPAN = 16;
      var LAZY_FILTER_FLAG = 1, LAZY_MAP_FLAG = 2, LAZY_WHILE_FLAG = 3;
      var INFINITY = 1 / 0, MAX_SAFE_INTEGER3 = 9007199254740991, MAX_INTEGER = 17976931348623157e292, NAN = 0 / 0;
      var MAX_ARRAY_LENGTH = 4294967295, MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1, HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
      var wrapFlags = [
        ["ary", WRAP_ARY_FLAG],
        ["bind", WRAP_BIND_FLAG],
        ["bindKey", WRAP_BIND_KEY_FLAG],
        ["curry", WRAP_CURRY_FLAG],
        ["curryRight", WRAP_CURRY_RIGHT_FLAG],
        ["flip", WRAP_FLIP_FLAG],
        ["partial", WRAP_PARTIAL_FLAG],
        ["partialRight", WRAP_PARTIAL_RIGHT_FLAG],
        ["rearg", WRAP_REARG_FLAG]
      ];
      var argsTag = "[object Arguments]", arrayTag = "[object Array]", asyncTag = "[object AsyncFunction]", boolTag = "[object Boolean]", dateTag = "[object Date]", domExcTag = "[object DOMException]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", nullTag = "[object Null]", objectTag = "[object Object]", promiseTag = "[object Promise]", proxyTag = "[object Proxy]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", undefinedTag = "[object Undefined]", weakMapTag = "[object WeakMap]", weakSetTag = "[object WeakSet]";
      var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
      var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
      var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g, reUnescapedHtml = /[&<>"']/g, reHasEscapedHtml = RegExp(reEscapedHtml.source), reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
      var reEscape = /<%-([\s\S]+?)%>/g, reEvaluate = /<%([\s\S]+?)%>/g, reInterpolate = /<%=([\s\S]+?)%>/g;
      var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
      var reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar.source);
      var reTrimStart = /^\s+/;
      var reWhitespace = /\s/;
      var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/, reSplitDetails = /,? & /;
      var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
      var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;
      var reEscapeChar = /\\(\\)?/g;
      var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
      var reFlags = /\w*$/;
      var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
      var reIsBinary = /^0b[01]+$/i;
      var reIsHostCtor = /^\[object .+?Constructor\]$/;
      var reIsOctal = /^0o[0-7]+$/i;
      var reIsUint = /^(?:0|[1-9]\d*)$/;
      var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
      var reNoMatch = /($^)/;
      var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
      var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsDingbatRange = "\\u2700-\\u27bf", rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff", rsMathOpRange = "\\xac\\xb1\\xd7\\xf7", rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", rsPunctuationRange = "\\u2000-\\u206f", rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde", rsVarRange = "\\ufe0e\\ufe0f", rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
      var rsApos = "['\u2019]", rsAstral = "[" + rsAstralRange + "]", rsBreak = "[" + rsBreakRange + "]", rsCombo = "[" + rsComboRange + "]", rsDigits = "\\d+", rsDingbat = "[" + rsDingbatRange + "]", rsLower = "[" + rsLowerRange + "]", rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsUpper = "[" + rsUpperRange + "]", rsZWJ = "\\u200d";
      var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")", rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")", rsOptContrLower = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?", rsOptContrUpper = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?", reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq, rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
      var reApos = RegExp(rsApos, "g");
      var reComboMark = RegExp(rsCombo, "g");
      var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
      var reUnicodeWord = RegExp([
        rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
        rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
        rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
        rsUpper + "+" + rsOptContrUpper,
        rsOrdUpper,
        rsOrdLower,
        rsDigits,
        rsEmoji
      ].join("|"), "g");
      var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
      var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
      var contextProps = [
        "Array",
        "Buffer",
        "DataView",
        "Date",
        "Error",
        "Float32Array",
        "Float64Array",
        "Function",
        "Int8Array",
        "Int16Array",
        "Int32Array",
        "Map",
        "Math",
        "Object",
        "Promise",
        "RegExp",
        "Set",
        "String",
        "Symbol",
        "TypeError",
        "Uint8Array",
        "Uint8ClampedArray",
        "Uint16Array",
        "Uint32Array",
        "WeakMap",
        "_",
        "clearTimeout",
        "isFinite",
        "parseInt",
        "setTimeout"
      ];
      var templateCounter = -1;
      var typedArrayTags = {};
      typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
      typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
      var cloneableTags = {};
      cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
      cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
      var deburredLetters = {
        // Latin-1 Supplement block.
        "\xC0": "A",
        "\xC1": "A",
        "\xC2": "A",
        "\xC3": "A",
        "\xC4": "A",
        "\xC5": "A",
        "\xE0": "a",
        "\xE1": "a",
        "\xE2": "a",
        "\xE3": "a",
        "\xE4": "a",
        "\xE5": "a",
        "\xC7": "C",
        "\xE7": "c",
        "\xD0": "D",
        "\xF0": "d",
        "\xC8": "E",
        "\xC9": "E",
        "\xCA": "E",
        "\xCB": "E",
        "\xE8": "e",
        "\xE9": "e",
        "\xEA": "e",
        "\xEB": "e",
        "\xCC": "I",
        "\xCD": "I",
        "\xCE": "I",
        "\xCF": "I",
        "\xEC": "i",
        "\xED": "i",
        "\xEE": "i",
        "\xEF": "i",
        "\xD1": "N",
        "\xF1": "n",
        "\xD2": "O",
        "\xD3": "O",
        "\xD4": "O",
        "\xD5": "O",
        "\xD6": "O",
        "\xD8": "O",
        "\xF2": "o",
        "\xF3": "o",
        "\xF4": "o",
        "\xF5": "o",
        "\xF6": "o",
        "\xF8": "o",
        "\xD9": "U",
        "\xDA": "U",
        "\xDB": "U",
        "\xDC": "U",
        "\xF9": "u",
        "\xFA": "u",
        "\xFB": "u",
        "\xFC": "u",
        "\xDD": "Y",
        "\xFD": "y",
        "\xFF": "y",
        "\xC6": "Ae",
        "\xE6": "ae",
        "\xDE": "Th",
        "\xFE": "th",
        "\xDF": "ss",
        // Latin Extended-A block.
        "\u0100": "A",
        "\u0102": "A",
        "\u0104": "A",
        "\u0101": "a",
        "\u0103": "a",
        "\u0105": "a",
        "\u0106": "C",
        "\u0108": "C",
        "\u010A": "C",
        "\u010C": "C",
        "\u0107": "c",
        "\u0109": "c",
        "\u010B": "c",
        "\u010D": "c",
        "\u010E": "D",
        "\u0110": "D",
        "\u010F": "d",
        "\u0111": "d",
        "\u0112": "E",
        "\u0114": "E",
        "\u0116": "E",
        "\u0118": "E",
        "\u011A": "E",
        "\u0113": "e",
        "\u0115": "e",
        "\u0117": "e",
        "\u0119": "e",
        "\u011B": "e",
        "\u011C": "G",
        "\u011E": "G",
        "\u0120": "G",
        "\u0122": "G",
        "\u011D": "g",
        "\u011F": "g",
        "\u0121": "g",
        "\u0123": "g",
        "\u0124": "H",
        "\u0126": "H",
        "\u0125": "h",
        "\u0127": "h",
        "\u0128": "I",
        "\u012A": "I",
        "\u012C": "I",
        "\u012E": "I",
        "\u0130": "I",
        "\u0129": "i",
        "\u012B": "i",
        "\u012D": "i",
        "\u012F": "i",
        "\u0131": "i",
        "\u0134": "J",
        "\u0135": "j",
        "\u0136": "K",
        "\u0137": "k",
        "\u0138": "k",
        "\u0139": "L",
        "\u013B": "L",
        "\u013D": "L",
        "\u013F": "L",
        "\u0141": "L",
        "\u013A": "l",
        "\u013C": "l",
        "\u013E": "l",
        "\u0140": "l",
        "\u0142": "l",
        "\u0143": "N",
        "\u0145": "N",
        "\u0147": "N",
        "\u014A": "N",
        "\u0144": "n",
        "\u0146": "n",
        "\u0148": "n",
        "\u014B": "n",
        "\u014C": "O",
        "\u014E": "O",
        "\u0150": "O",
        "\u014D": "o",
        "\u014F": "o",
        "\u0151": "o",
        "\u0154": "R",
        "\u0156": "R",
        "\u0158": "R",
        "\u0155": "r",
        "\u0157": "r",
        "\u0159": "r",
        "\u015A": "S",
        "\u015C": "S",
        "\u015E": "S",
        "\u0160": "S",
        "\u015B": "s",
        "\u015D": "s",
        "\u015F": "s",
        "\u0161": "s",
        "\u0162": "T",
        "\u0164": "T",
        "\u0166": "T",
        "\u0163": "t",
        "\u0165": "t",
        "\u0167": "t",
        "\u0168": "U",
        "\u016A": "U",
        "\u016C": "U",
        "\u016E": "U",
        "\u0170": "U",
        "\u0172": "U",
        "\u0169": "u",
        "\u016B": "u",
        "\u016D": "u",
        "\u016F": "u",
        "\u0171": "u",
        "\u0173": "u",
        "\u0174": "W",
        "\u0175": "w",
        "\u0176": "Y",
        "\u0177": "y",
        "\u0178": "Y",
        "\u0179": "Z",
        "\u017B": "Z",
        "\u017D": "Z",
        "\u017A": "z",
        "\u017C": "z",
        "\u017E": "z",
        "\u0132": "IJ",
        "\u0133": "ij",
        "\u0152": "Oe",
        "\u0153": "oe",
        "\u0149": "'n",
        "\u017F": "s"
      };
      var htmlEscapes = {
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        '"': "&quot;",
        "'": "&#39;"
      };
      var htmlUnescapes = {
        "&amp;": "&",
        "&lt;": "<",
        "&gt;": ">",
        "&quot;": '"',
        "&#39;": "'"
      };
      var stringEscapes = {
        "\\": "\\",
        "'": "'",
        "\n": "n",
        "\r": "r",
        "\u2028": "u2028",
        "\u2029": "u2029"
      };
      var freeParseFloat = parseFloat, freeParseInt = parseInt;
      var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
      var freeSelf = typeof self == "object" && self && self.Object === Object && self;
      var root = freeGlobal || freeSelf || Function("return this")();
      var freeExports = typeof exports2 == "object" && exports2 && !exports2.nodeType && exports2;
      var freeModule = freeExports && typeof module2 == "object" && module2 && !module2.nodeType && module2;
      var moduleExports = freeModule && freeModule.exports === freeExports;
      var freeProcess = moduleExports && freeGlobal.process;
      var nodeUtil = function() {
        try {
          var types = freeModule && freeModule.require && freeModule.require("util").types;
          if (types) {
            return types;
          }
          return freeProcess && freeProcess.binding && freeProcess.binding("util");
        } catch (e) {
        }
      }();
      var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer, nodeIsDate = nodeUtil && nodeUtil.isDate, nodeIsMap = nodeUtil && nodeUtil.isMap, nodeIsRegExp = nodeUtil && nodeUtil.isRegExp, nodeIsSet = nodeUtil && nodeUtil.isSet, nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
      function apply(func, thisArg, args) {
        switch (args.length) {
          case 0:
            return func.call(thisArg);
          case 1:
            return func.call(thisArg, args[0]);
          case 2:
            return func.call(thisArg, args[0], args[1]);
          case 3:
            return func.call(thisArg, args[0], args[1], args[2]);
        }
        return func.apply(thisArg, args);
      }
      function arrayAggregator(array2, setter, iteratee, accumulator) {
        var index = -1, length = array2 == null ? 0 : array2.length;
        while (++index < length) {
          var value = array2[index];
          setter(accumulator, value, iteratee(value), array2);
        }
        return accumulator;
      }
      function arrayEach(array2, iteratee) {
        var index = -1, length = array2 == null ? 0 : array2.length;
        while (++index < length) {
          if (iteratee(array2[index], index, array2) === false) {
            break;
          }
        }
        return array2;
      }
      function arrayEachRight(array2, iteratee) {
        var length = array2 == null ? 0 : array2.length;
        while (length--) {
          if (iteratee(array2[length], length, array2) === false) {
            break;
          }
        }
        return array2;
      }
      function arrayEvery(array2, predicate) {
        var index = -1, length = array2 == null ? 0 : array2.length;
        while (++index < length) {
          if (!predicate(array2[index], index, array2)) {
            return false;
          }
        }
        return true;
      }
      function arrayFilter(array2, predicate) {
        var index = -1, length = array2 == null ? 0 : array2.length, resIndex = 0, result = [];
        while (++index < length) {
          var value = array2[index];
          if (predicate(value, index, array2)) {
            result[resIndex++] = value;
          }
        }
        return result;
      }
      function arrayIncludes(array2, value) {
        var length = array2 == null ? 0 : array2.length;
        return !!length && baseIndexOf(array2, value, 0) > -1;
      }
      function arrayIncludesWith(array2, value, comparator) {
        var index = -1, length = array2 == null ? 0 : array2.length;
        while (++index < length) {
          if (comparator(value, array2[index])) {
            return true;
          }
        }
        return false;
      }
      function arrayMap(array2, iteratee) {
        var index = -1, length = array2 == null ? 0 : array2.length, result = Array(length);
        while (++index < length) {
          result[index] = iteratee(array2[index], index, array2);
        }
        return result;
      }
      function arrayPush(array2, values) {
        var index = -1, length = values.length, offset2 = array2.length;
        while (++index < length) {
          array2[offset2 + index] = values[index];
        }
        return array2;
      }
      function arrayReduce(array2, iteratee, accumulator, initAccum) {
        var index = -1, length = array2 == null ? 0 : array2.length;
        if (initAccum && length) {
          accumulator = array2[++index];
        }
        while (++index < length) {
          accumulator = iteratee(accumulator, array2[index], index, array2);
        }
        return accumulator;
      }
      function arrayReduceRight(array2, iteratee, accumulator, initAccum) {
        var length = array2 == null ? 0 : array2.length;
        if (initAccum && length) {
          accumulator = array2[--length];
        }
        while (length--) {
          accumulator = iteratee(accumulator, array2[length], length, array2);
        }
        return accumulator;
      }
      function arraySome(array2, predicate) {
        var index = -1, length = array2 == null ? 0 : array2.length;
        while (++index < length) {
          if (predicate(array2[index], index, array2)) {
            return true;
          }
        }
        return false;
      }
      var asciiSize = baseProperty("length");
      function asciiToArray(string) {
        return string.split("");
      }
      function asciiWords(string) {
        return string.match(reAsciiWord) || [];
      }
      function baseFindKey(collection, predicate, eachFunc) {
        var result;
        eachFunc(collection, function(value, key, collection2) {
          if (predicate(value, key, collection2)) {
            result = key;
            return false;
          }
        });
        return result;
      }
      function baseFindIndex(array2, predicate, fromIndex, fromRight) {
        var length = array2.length, index = fromIndex + (fromRight ? 1 : -1);
        while (fromRight ? index-- : ++index < length) {
          if (predicate(array2[index], index, array2)) {
            return index;
          }
        }
        return -1;
      }
      function baseIndexOf(array2, value, fromIndex) {
        return value === value ? strictIndexOf(array2, value, fromIndex) : baseFindIndex(array2, baseIsNaN, fromIndex);
      }
      function baseIndexOfWith(array2, value, fromIndex, comparator) {
        var index = fromIndex - 1, length = array2.length;
        while (++index < length) {
          if (comparator(array2[index], value)) {
            return index;
          }
        }
        return -1;
      }
      function baseIsNaN(value) {
        return value !== value;
      }
      function baseMean(array2, iteratee) {
        var length = array2 == null ? 0 : array2.length;
        return length ? baseSum(array2, iteratee) / length : NAN;
      }
      function baseProperty(key) {
        return function(object) {
          return object == null ? undefined2 : object[key];
        };
      }
      function basePropertyOf(object) {
        return function(key) {
          return object == null ? undefined2 : object[key];
        };
      }
      function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
        eachFunc(collection, function(value, index, collection2) {
          accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index, collection2);
        });
        return accumulator;
      }
      function baseSortBy(array2, comparer) {
        var length = array2.length;
        array2.sort(comparer);
        while (length--) {
          array2[length] = array2[length].value;
        }
        return array2;
      }
      function baseSum(array2, iteratee) {
        var result, index = -1, length = array2.length;
        while (++index < length) {
          var current = iteratee(array2[index]);
          if (current !== undefined2) {
            result = result === undefined2 ? current : result + current;
          }
        }
        return result;
      }
      function baseTimes(n, iteratee) {
        var index = -1, result = Array(n);
        while (++index < n) {
          result[index] = iteratee(index);
        }
        return result;
      }
      function baseToPairs(object, props) {
        return arrayMap(props, function(key) {
          return [key, object[key]];
        });
      }
      function baseTrim(string) {
        return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
      }
      function baseUnary(func) {
        return function(value) {
          return func(value);
        };
      }
      function baseValues(object, props) {
        return arrayMap(props, function(key) {
          return object[key];
        });
      }
      function cacheHas(cache, key) {
        return cache.has(key);
      }
      function charsStartIndex(strSymbols, chrSymbols) {
        var index = -1, length = strSymbols.length;
        while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
        }
        return index;
      }
      function charsEndIndex(strSymbols, chrSymbols) {
        var index = strSymbols.length;
        while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
        }
        return index;
      }
      function countHolders(array2, placeholder) {
        var length = array2.length, result = 0;
        while (length--) {
          if (array2[length] === placeholder) {
            ++result;
          }
        }
        return result;
      }
      var deburrLetter = basePropertyOf(deburredLetters);
      var escapeHtmlChar = basePropertyOf(htmlEscapes);
      function escapeStringChar(chr) {
        return "\\" + stringEscapes[chr];
      }
      function getValue(object, key) {
        return object == null ? undefined2 : object[key];
      }
      function hasUnicode(string) {
        return reHasUnicode.test(string);
      }
      function hasUnicodeWord(string) {
        return reHasUnicodeWord.test(string);
      }
      function iteratorToArray(iterator) {
        var data, result = [];
        while (!(data = iterator.next()).done) {
          result.push(data.value);
        }
        return result;
      }
      function mapToArray(map) {
        var index = -1, result = Array(map.size);
        map.forEach(function(value, key) {
          result[++index] = [key, value];
        });
        return result;
      }
      function overArg(func, transform) {
        return function(arg) {
          return func(transform(arg));
        };
      }
      function replaceHolders(array2, placeholder) {
        var index = -1, length = array2.length, resIndex = 0, result = [];
        while (++index < length) {
          var value = array2[index];
          if (value === placeholder || value === PLACEHOLDER) {
            array2[index] = PLACEHOLDER;
            result[resIndex++] = index;
          }
        }
        return result;
      }
      function setToArray(set) {
        var index = -1, result = Array(set.size);
        set.forEach(function(value) {
          result[++index] = value;
        });
        return result;
      }
      function setToPairs(set) {
        var index = -1, result = Array(set.size);
        set.forEach(function(value) {
          result[++index] = [value, value];
        });
        return result;
      }
      function strictIndexOf(array2, value, fromIndex) {
        var index = fromIndex - 1, length = array2.length;
        while (++index < length) {
          if (array2[index] === value) {
            return index;
          }
        }
        return -1;
      }
      function strictLastIndexOf(array2, value, fromIndex) {
        var index = fromIndex + 1;
        while (index--) {
          if (array2[index] === value) {
            return index;
          }
        }
        return index;
      }
      function stringSize(string) {
        return hasUnicode(string) ? unicodeSize(string) : asciiSize(string);
      }
      function stringToArray(string) {
        return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
      }
      function trimmedEndIndex(string) {
        var index = string.length;
        while (index-- && reWhitespace.test(string.charAt(index))) {
        }
        return index;
      }
      var unescapeHtmlChar = basePropertyOf(htmlUnescapes);
      function unicodeSize(string) {
        var result = reUnicode.lastIndex = 0;
        while (reUnicode.test(string)) {
          ++result;
        }
        return result;
      }
      function unicodeToArray(string) {
        return string.match(reUnicode) || [];
      }
      function unicodeWords(string) {
        return string.match(reUnicodeWord) || [];
      }
      var runInContext = function runInContext2(context) {
        context = context == null ? root : _.defaults(root.Object(), context, _.pick(root, contextProps));
        var Array2 = context.Array, Date2 = context.Date, Error2 = context.Error, Function2 = context.Function, Math2 = context.Math, Object2 = context.Object, RegExp2 = context.RegExp, String2 = context.String, TypeError2 = context.TypeError;
        var arrayProto = Array2.prototype, funcProto = Function2.prototype, objectProto = Object2.prototype;
        var coreJsData = context["__core-js_shared__"];
        var funcToString = funcProto.toString;
        var hasOwnProperty = objectProto.hasOwnProperty;
        var idCounter = 0;
        var maskSrcKey = function() {
          var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
          return uid ? "Symbol(src)_1." + uid : "";
        }();
        var nativeObjectToString = objectProto.toString;
        var objectCtorString = funcToString.call(Object2);
        var oldDash = root._;
        var reIsNative = RegExp2(
          "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
        );
        var Buffer2 = moduleExports ? context.Buffer : undefined2, Symbol2 = context.Symbol, Uint8Array2 = context.Uint8Array, allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : undefined2, getPrototype = overArg(Object2.getPrototypeOf, Object2), objectCreate = Object2.create, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice, spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : undefined2, symIterator = Symbol2 ? Symbol2.iterator : undefined2, symToStringTag = Symbol2 ? Symbol2.toStringTag : undefined2;
        var defineProperty = function() {
          try {
            var func = getNative(Object2, "defineProperty");
            func({}, "", {});
            return func;
          } catch (e) {
          }
        }();
        var ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout, ctxNow = Date2 && Date2.now !== root.Date.now && Date2.now, ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout;
        var nativeCeil = Math2.ceil, nativeFloor = Math2.floor, nativeGetSymbols = Object2.getOwnPropertySymbols, nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : undefined2, nativeIsFinite = context.isFinite, nativeJoin = arrayProto.join, nativeKeys = overArg(Object2.keys, Object2), nativeMax = Math2.max, nativeMin = Math2.min, nativeNow = Date2.now, nativeParseInt = context.parseInt, nativeRandom = Math2.random, nativeReverse = arrayProto.reverse;
        var DataView2 = getNative(context, "DataView"), Map2 = getNative(context, "Map"), Promise2 = getNative(context, "Promise"), Set2 = getNative(context, "Set"), WeakMap2 = getNative(context, "WeakMap"), nativeCreate = getNative(Object2, "create");
        var metaMap = WeakMap2 && new WeakMap2();
        var realNames = {};
        var dataViewCtorString = toSource(DataView2), mapCtorString = toSource(Map2), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set2), weakMapCtorString = toSource(WeakMap2);
        var symbolProto = Symbol2 ? Symbol2.prototype : undefined2, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined2, symbolToString = symbolProto ? symbolProto.toString : undefined2;
        function lodash(value) {
          if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
            if (value instanceof LodashWrapper) {
              return value;
            }
            if (hasOwnProperty.call(value, "__wrapped__")) {
              return wrapperClone(value);
            }
          }
          return new LodashWrapper(value);
        }
        var baseCreate = /* @__PURE__ */ function() {
          function object() {
          }
          return function(proto) {
            if (!isObject(proto)) {
              return {};
            }
            if (objectCreate) {
              return objectCreate(proto);
            }
            object.prototype = proto;
            var result2 = new object();
            object.prototype = undefined2;
            return result2;
          };
        }();
        function baseLodash() {
        }
        function LodashWrapper(value, chainAll) {
          this.__wrapped__ = value;
          this.__actions__ = [];
          this.__chain__ = !!chainAll;
          this.__index__ = 0;
          this.__values__ = undefined2;
        }
        lodash.templateSettings = {
          /**
           * Used to detect `data` property values to be HTML-escaped.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          "escape": reEscape,
          /**
           * Used to detect code to be evaluated.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          "evaluate": reEvaluate,
          /**
           * Used to detect `data` property values to inject.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          "interpolate": reInterpolate,
          /**
           * Used to reference the data object in the template text.
           *
           * @memberOf _.templateSettings
           * @type {string}
           */
          "variable": "",
          /**
           * Used to import variables into the compiled template.
           *
           * @memberOf _.templateSettings
           * @type {Object}
           */
          "imports": {
            /**
             * A reference to the `lodash` function.
             *
             * @memberOf _.templateSettings.imports
             * @type {Function}
             */
            "_": lodash
          }
        };
        lodash.prototype = baseLodash.prototype;
        lodash.prototype.constructor = lodash;
        LodashWrapper.prototype = baseCreate(baseLodash.prototype);
        LodashWrapper.prototype.constructor = LodashWrapper;
        function LazyWrapper(value) {
          this.__wrapped__ = value;
          this.__actions__ = [];
          this.__dir__ = 1;
          this.__filtered__ = false;
          this.__iteratees__ = [];
          this.__takeCount__ = MAX_ARRAY_LENGTH;
          this.__views__ = [];
        }
        function lazyClone() {
          var result2 = new LazyWrapper(this.__wrapped__);
          result2.__actions__ = copyArray(this.__actions__);
          result2.__dir__ = this.__dir__;
          result2.__filtered__ = this.__filtered__;
          result2.__iteratees__ = copyArray(this.__iteratees__);
          result2.__takeCount__ = this.__takeCount__;
          result2.__views__ = copyArray(this.__views__);
          return result2;
        }
        function lazyReverse() {
          if (this.__filtered__) {
            var result2 = new LazyWrapper(this);
            result2.__dir__ = -1;
            result2.__filtered__ = true;
          } else {
            result2 = this.clone();
            result2.__dir__ *= -1;
          }
          return result2;
        }
        function lazyValue() {
          var array2 = this.__wrapped__.value(), dir = this.__dir__, isArr = isArray(array2), isRight = dir < 0, arrLength = isArr ? array2.length : 0, view = getView(0, arrLength, this.__views__), start = view.start, end = view.end, length = end - start, index = isRight ? end : start - 1, iteratees = this.__iteratees__, iterLength = iteratees.length, resIndex = 0, takeCount = nativeMin(length, this.__takeCount__);
          if (!isArr || !isRight && arrLength == length && takeCount == length) {
            return baseWrapperValue(array2, this.__actions__);
          }
          var result2 = [];
          outer:
            while (length-- && resIndex < takeCount) {
              index += dir;
              var iterIndex = -1, value = array2[index];
              while (++iterIndex < iterLength) {
                var data = iteratees[iterIndex], iteratee2 = data.iteratee, type = data.type, computed = iteratee2(value);
                if (type == LAZY_MAP_FLAG) {
                  value = computed;
                } else if (!computed) {
                  if (type == LAZY_FILTER_FLAG) {
                    continue outer;
                  } else {
                    break outer;
                  }
                }
              }
              result2[resIndex++] = value;
            }
          return result2;
        }
        LazyWrapper.prototype = baseCreate(baseLodash.prototype);
        LazyWrapper.prototype.constructor = LazyWrapper;
        function Hash(entries) {
          var index = -1, length = entries == null ? 0 : entries.length;
          this.clear();
          while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }
        function hashClear() {
          this.__data__ = nativeCreate ? nativeCreate(null) : {};
          this.size = 0;
        }
        function hashDelete(key) {
          var result2 = this.has(key) && delete this.__data__[key];
          this.size -= result2 ? 1 : 0;
          return result2;
        }
        function hashGet(key) {
          var data = this.__data__;
          if (nativeCreate) {
            var result2 = data[key];
            return result2 === HASH_UNDEFINED ? undefined2 : result2;
          }
          return hasOwnProperty.call(data, key) ? data[key] : undefined2;
        }
        function hashHas(key) {
          var data = this.__data__;
          return nativeCreate ? data[key] !== undefined2 : hasOwnProperty.call(data, key);
        }
        function hashSet(key, value) {
          var data = this.__data__;
          this.size += this.has(key) ? 0 : 1;
          data[key] = nativeCreate && value === undefined2 ? HASH_UNDEFINED : value;
          return this;
        }
        Hash.prototype.clear = hashClear;
        Hash.prototype["delete"] = hashDelete;
        Hash.prototype.get = hashGet;
        Hash.prototype.has = hashHas;
        Hash.prototype.set = hashSet;
        function ListCache(entries) {
          var index = -1, length = entries == null ? 0 : entries.length;
          this.clear();
          while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }
        function listCacheClear() {
          this.__data__ = [];
          this.size = 0;
        }
        function listCacheDelete(key) {
          var data = this.__data__, index = assocIndexOf(data, key);
          if (index < 0) {
            return false;
          }
          var lastIndex = data.length - 1;
          if (index == lastIndex) {
            data.pop();
          } else {
            splice.call(data, index, 1);
          }
          --this.size;
          return true;
        }
        function listCacheGet(key) {
          var data = this.__data__, index = assocIndexOf(data, key);
          return index < 0 ? undefined2 : data[index][1];
        }
        function listCacheHas(key) {
          return assocIndexOf(this.__data__, key) > -1;
        }
        function listCacheSet(key, value) {
          var data = this.__data__, index = assocIndexOf(data, key);
          if (index < 0) {
            ++this.size;
            data.push([key, value]);
          } else {
            data[index][1] = value;
          }
          return this;
        }
        ListCache.prototype.clear = listCacheClear;
        ListCache.prototype["delete"] = listCacheDelete;
        ListCache.prototype.get = listCacheGet;
        ListCache.prototype.has = listCacheHas;
        ListCache.prototype.set = listCacheSet;
        function MapCache(entries) {
          var index = -1, length = entries == null ? 0 : entries.length;
          this.clear();
          while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }
        function mapCacheClear() {
          this.size = 0;
          this.__data__ = {
            "hash": new Hash(),
            "map": new (Map2 || ListCache)(),
            "string": new Hash()
          };
        }
        function mapCacheDelete(key) {
          var result2 = getMapData(this, key)["delete"](key);
          this.size -= result2 ? 1 : 0;
          return result2;
        }
        function mapCacheGet(key) {
          return getMapData(this, key).get(key);
        }
        function mapCacheHas(key) {
          return getMapData(this, key).has(key);
        }
        function mapCacheSet(key, value) {
          var data = getMapData(this, key), size2 = data.size;
          data.set(key, value);
          this.size += data.size == size2 ? 0 : 1;
          return this;
        }
        MapCache.prototype.clear = mapCacheClear;
        MapCache.prototype["delete"] = mapCacheDelete;
        MapCache.prototype.get = mapCacheGet;
        MapCache.prototype.has = mapCacheHas;
        MapCache.prototype.set = mapCacheSet;
        function SetCache(values2) {
          var index = -1, length = values2 == null ? 0 : values2.length;
          this.__data__ = new MapCache();
          while (++index < length) {
            this.add(values2[index]);
          }
        }
        function setCacheAdd(value) {
          this.__data__.set(value, HASH_UNDEFINED);
          return this;
        }
        function setCacheHas(value) {
          return this.__data__.has(value);
        }
        SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
        SetCache.prototype.has = setCacheHas;
        function Stack(entries) {
          var data = this.__data__ = new ListCache(entries);
          this.size = data.size;
        }
        function stackClear() {
          this.__data__ = new ListCache();
          this.size = 0;
        }
        function stackDelete(key) {
          var data = this.__data__, result2 = data["delete"](key);
          this.size = data.size;
          return result2;
        }
        function stackGet(key) {
          return this.__data__.get(key);
        }
        function stackHas(key) {
          return this.__data__.has(key);
        }
        function stackSet(key, value) {
          var data = this.__data__;
          if (data instanceof ListCache) {
            var pairs = data.__data__;
            if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
              pairs.push([key, value]);
              this.size = ++data.size;
              return this;
            }
            data = this.__data__ = new MapCache(pairs);
          }
          data.set(key, value);
          this.size = data.size;
          return this;
        }
        Stack.prototype.clear = stackClear;
        Stack.prototype["delete"] = stackDelete;
        Stack.prototype.get = stackGet;
        Stack.prototype.has = stackHas;
        Stack.prototype.set = stackSet;
        function arrayLikeKeys(value, inherited) {
          var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result2 = skipIndexes ? baseTimes(value.length, String2) : [], length = result2.length;
          for (var key in value) {
            if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
            (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
            isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
            isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
            isIndex(key, length)))) {
              result2.push(key);
            }
          }
          return result2;
        }
        function arraySample(array2) {
          var length = array2.length;
          return length ? array2[baseRandom(0, length - 1)] : undefined2;
        }
        function arraySampleSize(array2, n) {
          return shuffleSelf(copyArray(array2), baseClamp(n, 0, array2.length));
        }
        function arrayShuffle(array2) {
          return shuffleSelf(copyArray(array2));
        }
        function assignMergeValue(object, key, value) {
          if (value !== undefined2 && !eq2(object[key], value) || value === undefined2 && !(key in object)) {
            baseAssignValue(object, key, value);
          }
        }
        function assignValue(object, key, value) {
          var objValue = object[key];
          if (!(hasOwnProperty.call(object, key) && eq2(objValue, value)) || value === undefined2 && !(key in object)) {
            baseAssignValue(object, key, value);
          }
        }
        function assocIndexOf(array2, key) {
          var length = array2.length;
          while (length--) {
            if (eq2(array2[length][0], key)) {
              return length;
            }
          }
          return -1;
        }
        function baseAggregator(collection, setter, iteratee2, accumulator) {
          baseEach(collection, function(value, key, collection2) {
            setter(accumulator, value, iteratee2(value), collection2);
          });
          return accumulator;
        }
        function baseAssign(object, source) {
          return object && copyObject(source, keys(source), object);
        }
        function baseAssignIn(object, source) {
          return object && copyObject(source, keysIn(source), object);
        }
        function baseAssignValue(object, key, value) {
          if (key == "__proto__" && defineProperty) {
            defineProperty(object, key, {
              "configurable": true,
              "enumerable": true,
              "value": value,
              "writable": true
            });
          } else {
            object[key] = value;
          }
        }
        function baseAt(object, paths) {
          var index = -1, length = paths.length, result2 = Array2(length), skip = object == null;
          while (++index < length) {
            result2[index] = skip ? undefined2 : get(object, paths[index]);
          }
          return result2;
        }
        function baseClamp(number, lower, upper) {
          if (number === number) {
            if (upper !== undefined2) {
              number = number <= upper ? number : upper;
            }
            if (lower !== undefined2) {
              number = number >= lower ? number : lower;
            }
          }
          return number;
        }
        function baseClone(value, bitmask, customizer, key, object, stack) {
          var result2, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
          if (customizer) {
            result2 = object ? customizer(value, key, object, stack) : customizer(value);
          }
          if (result2 !== undefined2) {
            return result2;
          }
          if (!isObject(value)) {
            return value;
          }
          var isArr = isArray(value);
          if (isArr) {
            result2 = initCloneArray(value);
            if (!isDeep) {
              return copyArray(value, result2);
            }
          } else {
            var tag2 = getTag(value), isFunc = tag2 == funcTag || tag2 == genTag;
            if (isBuffer(value)) {
              return cloneBuffer(value, isDeep);
            }
            if (tag2 == objectTag || tag2 == argsTag || isFunc && !object) {
              result2 = isFlat || isFunc ? {} : initCloneObject(value);
              if (!isDeep) {
                return isFlat ? copySymbolsIn(value, baseAssignIn(result2, value)) : copySymbols(value, baseAssign(result2, value));
              }
            } else {
              if (!cloneableTags[tag2]) {
                return object ? value : {};
              }
              result2 = initCloneByTag(value, tag2, isDeep);
            }
          }
          stack || (stack = new Stack());
          var stacked = stack.get(value);
          if (stacked) {
            return stacked;
          }
          stack.set(value, result2);
          if (isSet(value)) {
            value.forEach(function(subValue) {
              result2.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
            });
          } else if (isMap(value)) {
            value.forEach(function(subValue, key2) {
              result2.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
            });
          }
          var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
          var props = isArr ? undefined2 : keysFunc(value);
          arrayEach(props || value, function(subValue, key2) {
            if (props) {
              key2 = subValue;
              subValue = value[key2];
            }
            assignValue(result2, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
          });
          return result2;
        }
        function baseConforms(source) {
          var props = keys(source);
          return function(object) {
            return baseConformsTo(object, source, props);
          };
        }
        function baseConformsTo(object, source, props) {
          var length = props.length;
          if (object == null) {
            return !length;
          }
          object = Object2(object);
          while (length--) {
            var key = props[length], predicate = source[key], value = object[key];
            if (value === undefined2 && !(key in object) || !predicate(value)) {
              return false;
            }
          }
          return true;
        }
        function baseDelay(func, wait, args) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          return setTimeout2(function() {
            func.apply(undefined2, args);
          }, wait);
        }
        function baseDifference(array2, values2, iteratee2, comparator) {
          var index = -1, includes2 = arrayIncludes, isCommon = true, length = array2.length, result2 = [], valuesLength = values2.length;
          if (!length) {
            return result2;
          }
          if (iteratee2) {
            values2 = arrayMap(values2, baseUnary(iteratee2));
          }
          if (comparator) {
            includes2 = arrayIncludesWith;
            isCommon = false;
          } else if (values2.length >= LARGE_ARRAY_SIZE) {
            includes2 = cacheHas;
            isCommon = false;
            values2 = new SetCache(values2);
          }
          outer:
            while (++index < length) {
              var value = array2[index], computed = iteratee2 == null ? value : iteratee2(value);
              value = comparator || value !== 0 ? value : 0;
              if (isCommon && computed === computed) {
                var valuesIndex = valuesLength;
                while (valuesIndex--) {
                  if (values2[valuesIndex] === computed) {
                    continue outer;
                  }
                }
                result2.push(value);
              } else if (!includes2(values2, computed, comparator)) {
                result2.push(value);
              }
            }
          return result2;
        }
        var baseEach = createBaseEach(baseForOwn);
        var baseEachRight = createBaseEach(baseForOwnRight, true);
        function baseEvery(collection, predicate) {
          var result2 = true;
          baseEach(collection, function(value, index, collection2) {
            result2 = !!predicate(value, index, collection2);
            return result2;
          });
          return result2;
        }
        function baseExtremum(array2, iteratee2, comparator) {
          var index = -1, length = array2.length;
          while (++index < length) {
            var value = array2[index], current = iteratee2(value);
            if (current != null && (computed === undefined2 ? current === current && !isSymbol(current) : comparator(current, computed))) {
              var computed = current, result2 = value;
            }
          }
          return result2;
        }
        function baseFill(array2, value, start, end) {
          var length = array2.length;
          start = toInteger(start);
          if (start < 0) {
            start = -start > length ? 0 : length + start;
          }
          end = end === undefined2 || end > length ? length : toInteger(end);
          if (end < 0) {
            end += length;
          }
          end = start > end ? 0 : toLength(end);
          while (start < end) {
            array2[start++] = value;
          }
          return array2;
        }
        function baseFilter(collection, predicate) {
          var result2 = [];
          baseEach(collection, function(value, index, collection2) {
            if (predicate(value, index, collection2)) {
              result2.push(value);
            }
          });
          return result2;
        }
        function baseFlatten(array2, depth, predicate, isStrict, result2) {
          var index = -1, length = array2.length;
          predicate || (predicate = isFlattenable);
          result2 || (result2 = []);
          while (++index < length) {
            var value = array2[index];
            if (depth > 0 && predicate(value)) {
              if (depth > 1) {
                baseFlatten(value, depth - 1, predicate, isStrict, result2);
              } else {
                arrayPush(result2, value);
              }
            } else if (!isStrict) {
              result2[result2.length] = value;
            }
          }
          return result2;
        }
        var baseFor = createBaseFor();
        var baseForRight = createBaseFor(true);
        function baseForOwn(object, iteratee2) {
          return object && baseFor(object, iteratee2, keys);
        }
        function baseForOwnRight(object, iteratee2) {
          return object && baseForRight(object, iteratee2, keys);
        }
        function baseFunctions(object, props) {
          return arrayFilter(props, function(key) {
            return isFunction(object[key]);
          });
        }
        function baseGet(object, path) {
          path = castPath(path, object);
          var index = 0, length = path.length;
          while (object != null && index < length) {
            object = object[toKey(path[index++])];
          }
          return index && index == length ? object : undefined2;
        }
        function baseGetAllKeys(object, keysFunc, symbolsFunc) {
          var result2 = keysFunc(object);
          return isArray(object) ? result2 : arrayPush(result2, symbolsFunc(object));
        }
        function baseGetTag(value) {
          if (value == null) {
            return value === undefined2 ? undefinedTag : nullTag;
          }
          return symToStringTag && symToStringTag in Object2(value) ? getRawTag(value) : objectToString(value);
        }
        function baseGt(value, other) {
          return value > other;
        }
        function baseHas(object, key) {
          return object != null && hasOwnProperty.call(object, key);
        }
        function baseHasIn(object, key) {
          return object != null && key in Object2(object);
        }
        function baseInRange(number, start, end) {
          return number >= nativeMin(start, end) && number < nativeMax(start, end);
        }
        function baseIntersection(arrays, iteratee2, comparator) {
          var includes2 = comparator ? arrayIncludesWith : arrayIncludes, length = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array2(othLength), maxLength = Infinity, result2 = [];
          while (othIndex--) {
            var array2 = arrays[othIndex];
            if (othIndex && iteratee2) {
              array2 = arrayMap(array2, baseUnary(iteratee2));
            }
            maxLength = nativeMin(array2.length, maxLength);
            caches[othIndex] = !comparator && (iteratee2 || length >= 120 && array2.length >= 120) ? new SetCache(othIndex && array2) : undefined2;
          }
          array2 = arrays[0];
          var index = -1, seen = caches[0];
          outer:
            while (++index < length && result2.length < maxLength) {
              var value = array2[index], computed = iteratee2 ? iteratee2(value) : value;
              value = comparator || value !== 0 ? value : 0;
              if (!(seen ? cacheHas(seen, computed) : includes2(result2, computed, comparator))) {
                othIndex = othLength;
                while (--othIndex) {
                  var cache = caches[othIndex];
                  if (!(cache ? cacheHas(cache, computed) : includes2(arrays[othIndex], computed, comparator))) {
                    continue outer;
                  }
                }
                if (seen) {
                  seen.push(computed);
                }
                result2.push(value);
              }
            }
          return result2;
        }
        function baseInverter(object, setter, iteratee2, accumulator) {
          baseForOwn(object, function(value, key, object2) {
            setter(accumulator, iteratee2(value), key, object2);
          });
          return accumulator;
        }
        function baseInvoke(object, path, args) {
          path = castPath(path, object);
          object = parent(object, path);
          var func = object == null ? object : object[toKey(last(path))];
          return func == null ? undefined2 : apply(func, object, args);
        }
        function baseIsArguments(value) {
          return isObjectLike(value) && baseGetTag(value) == argsTag;
        }
        function baseIsArrayBuffer(value) {
          return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
        }
        function baseIsDate(value) {
          return isObjectLike(value) && baseGetTag(value) == dateTag;
        }
        function baseIsEqual(value, other, bitmask, customizer, stack) {
          if (value === other) {
            return true;
          }
          if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
            return value !== value && other !== other;
          }
          return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
        }
        function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
          var objIsArr = isArray(object), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
          objTag = objTag == argsTag ? objectTag : objTag;
          othTag = othTag == argsTag ? objectTag : othTag;
          var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
          if (isSameTag && isBuffer(object)) {
            if (!isBuffer(other)) {
              return false;
            }
            objIsArr = true;
            objIsObj = false;
          }
          if (isSameTag && !objIsObj) {
            stack || (stack = new Stack());
            return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
          }
          if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
            var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
            if (objIsWrapped || othIsWrapped) {
              var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
              stack || (stack = new Stack());
              return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
            }
          }
          if (!isSameTag) {
            return false;
          }
          stack || (stack = new Stack());
          return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
        }
        function baseIsMap(value) {
          return isObjectLike(value) && getTag(value) == mapTag;
        }
        function baseIsMatch(object, source, matchData, customizer) {
          var index = matchData.length, length = index, noCustomizer = !customizer;
          if (object == null) {
            return !length;
          }
          object = Object2(object);
          while (index--) {
            var data = matchData[index];
            if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
              return false;
            }
          }
          while (++index < length) {
            data = matchData[index];
            var key = data[0], objValue = object[key], srcValue = data[1];
            if (noCustomizer && data[2]) {
              if (objValue === undefined2 && !(key in object)) {
                return false;
              }
            } else {
              var stack = new Stack();
              if (customizer) {
                var result2 = customizer(objValue, srcValue, key, object, source, stack);
              }
              if (!(result2 === undefined2 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result2)) {
                return false;
              }
            }
          }
          return true;
        }
        function baseIsNative(value) {
          if (!isObject(value) || isMasked(value)) {
            return false;
          }
          var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
          return pattern.test(toSource(value));
        }
        function baseIsRegExp(value) {
          return isObjectLike(value) && baseGetTag(value) == regexpTag;
        }
        function baseIsSet(value) {
          return isObjectLike(value) && getTag(value) == setTag;
        }
        function baseIsTypedArray(value) {
          return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
        }
        function baseIteratee(value) {
          if (typeof value == "function") {
            return value;
          }
          if (value == null) {
            return identity;
          }
          if (typeof value == "object") {
            return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
          }
          return property(value);
        }
        function baseKeys(object) {
          if (!isPrototype(object)) {
            return nativeKeys(object);
          }
          var result2 = [];
          for (var key in Object2(object)) {
            if (hasOwnProperty.call(object, key) && key != "constructor") {
              result2.push(key);
            }
          }
          return result2;
        }
        function baseKeysIn(object) {
          if (!isObject(object)) {
            return nativeKeysIn(object);
          }
          var isProto = isPrototype(object), result2 = [];
          for (var key in object) {
            if (!(key == "constructor" && (isProto || !hasOwnProperty.call(object, key)))) {
              result2.push(key);
            }
          }
          return result2;
        }
        function baseLt(value, other) {
          return value < other;
        }
        function baseMap(collection, iteratee2) {
          var index = -1, result2 = isArrayLike(collection) ? Array2(collection.length) : [];
          baseEach(collection, function(value, key, collection2) {
            result2[++index] = iteratee2(value, key, collection2);
          });
          return result2;
        }
        function baseMatches(source) {
          var matchData = getMatchData(source);
          if (matchData.length == 1 && matchData[0][2]) {
            return matchesStrictComparable(matchData[0][0], matchData[0][1]);
          }
          return function(object) {
            return object === source || baseIsMatch(object, source, matchData);
          };
        }
        function baseMatchesProperty(path, srcValue) {
          if (isKey(path) && isStrictComparable(srcValue)) {
            return matchesStrictComparable(toKey(path), srcValue);
          }
          return function(object) {
            var objValue = get(object, path);
            return objValue === undefined2 && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
          };
        }
        function baseMerge(object, source, srcIndex, customizer, stack) {
          if (object === source) {
            return;
          }
          baseFor(source, function(srcValue, key) {
            stack || (stack = new Stack());
            if (isObject(srcValue)) {
              baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
            } else {
              var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack) : undefined2;
              if (newValue === undefined2) {
                newValue = srcValue;
              }
              assignMergeValue(object, key, newValue);
            }
          }, keysIn);
        }
        function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
          var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
          if (stacked) {
            assignMergeValue(object, key, stacked);
            return;
          }
          var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : undefined2;
          var isCommon = newValue === undefined2;
          if (isCommon) {
            var isArr = isArray(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
            newValue = srcValue;
            if (isArr || isBuff || isTyped) {
              if (isArray(objValue)) {
                newValue = objValue;
              } else if (isArrayLikeObject(objValue)) {
                newValue = copyArray(objValue);
              } else if (isBuff) {
                isCommon = false;
                newValue = cloneBuffer(srcValue, true);
              } else if (isTyped) {
                isCommon = false;
                newValue = cloneTypedArray(srcValue, true);
              } else {
                newValue = [];
              }
            } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
              newValue = objValue;
              if (isArguments(objValue)) {
                newValue = toPlainObject(objValue);
              } else if (!isObject(objValue) || isFunction(objValue)) {
                newValue = initCloneObject(srcValue);
              }
            } else {
              isCommon = false;
            }
          }
          if (isCommon) {
            stack.set(srcValue, newValue);
            mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
            stack["delete"](srcValue);
          }
          assignMergeValue(object, key, newValue);
        }
        function baseNth(array2, n) {
          var length = array2.length;
          if (!length) {
            return;
          }
          n += n < 0 ? length : 0;
          return isIndex(n, length) ? array2[n] : undefined2;
        }
        function baseOrderBy(collection, iteratees, orders) {
          if (iteratees.length) {
            iteratees = arrayMap(iteratees, function(iteratee2) {
              if (isArray(iteratee2)) {
                return function(value) {
                  return baseGet(value, iteratee2.length === 1 ? iteratee2[0] : iteratee2);
                };
              }
              return iteratee2;
            });
          } else {
            iteratees = [identity];
          }
          var index = -1;
          iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
          var result2 = baseMap(collection, function(value, key, collection2) {
            var criteria = arrayMap(iteratees, function(iteratee2) {
              return iteratee2(value);
            });
            return { "criteria": criteria, "index": ++index, "value": value };
          });
          return baseSortBy(result2, function(object, other) {
            return compareMultiple(object, other, orders);
          });
        }
        function basePick(object, paths) {
          return basePickBy(object, paths, function(value, path) {
            return hasIn(object, path);
          });
        }
        function basePickBy(object, paths, predicate) {
          var index = -1, length = paths.length, result2 = {};
          while (++index < length) {
            var path = paths[index], value = baseGet(object, path);
            if (predicate(value, path)) {
              baseSet(result2, castPath(path, object), value);
            }
          }
          return result2;
        }
        function basePropertyDeep(path) {
          return function(object) {
            return baseGet(object, path);
          };
        }
        function basePullAll(array2, values2, iteratee2, comparator) {
          var indexOf2 = comparator ? baseIndexOfWith : baseIndexOf, index = -1, length = values2.length, seen = array2;
          if (array2 === values2) {
            values2 = copyArray(values2);
          }
          if (iteratee2) {
            seen = arrayMap(array2, baseUnary(iteratee2));
          }
          while (++index < length) {
            var fromIndex = 0, value = values2[index], computed = iteratee2 ? iteratee2(value) : value;
            while ((fromIndex = indexOf2(seen, computed, fromIndex, comparator)) > -1) {
              if (seen !== array2) {
                splice.call(seen, fromIndex, 1);
              }
              splice.call(array2, fromIndex, 1);
            }
          }
          return array2;
        }
        function basePullAt(array2, indexes) {
          var length = array2 ? indexes.length : 0, lastIndex = length - 1;
          while (length--) {
            var index = indexes[length];
            if (length == lastIndex || index !== previous) {
              var previous = index;
              if (isIndex(index)) {
                splice.call(array2, index, 1);
              } else {
                baseUnset(array2, index);
              }
            }
          }
          return array2;
        }
        function baseRandom(lower, upper) {
          return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
        }
        function baseRange(start, end, step, fromRight) {
          var index = -1, length = nativeMax(nativeCeil((end - start) / (step || 1)), 0), result2 = Array2(length);
          while (length--) {
            result2[fromRight ? length : ++index] = start;
            start += step;
          }
          return result2;
        }
        function baseRepeat(string, n) {
          var result2 = "";
          if (!string || n < 1 || n > MAX_SAFE_INTEGER3) {
            return result2;
          }
          do {
            if (n % 2) {
              result2 += string;
            }
            n = nativeFloor(n / 2);
            if (n) {
              string += string;
            }
          } while (n);
          return result2;
        }
        function baseRest(func, start) {
          return setToString(overRest(func, start, identity), func + "");
        }
        function baseSample(collection) {
          return arraySample(values(collection));
        }
        function baseSampleSize(collection, n) {
          var array2 = values(collection);
          return shuffleSelf(array2, baseClamp(n, 0, array2.length));
        }
        function baseSet(object, path, value, customizer) {
          if (!isObject(object)) {
            return object;
          }
          path = castPath(path, object);
          var index = -1, length = path.length, lastIndex = length - 1, nested = object;
          while (nested != null && ++index < length) {
            var key = toKey(path[index]), newValue = value;
            if (key === "__proto__" || key === "constructor" || key === "prototype") {
              return object;
            }
            if (index != lastIndex) {
              var objValue = nested[key];
              newValue = customizer ? customizer(objValue, key, nested) : undefined2;
              if (newValue === undefined2) {
                newValue = isObject(objValue) ? objValue : isIndex(path[index + 1]) ? [] : {};
              }
            }
            assignValue(nested, key, newValue);
            nested = nested[key];
          }
          return object;
        }
        var baseSetData = !metaMap ? identity : function(func, data) {
          metaMap.set(func, data);
          return func;
        };
        var baseSetToString = !defineProperty ? identity : function(func, string) {
          return defineProperty(func, "toString", {
            "configurable": true,
            "enumerable": false,
            "value": constant(string),
            "writable": true
          });
        };
        function baseShuffle(collection) {
          return shuffleSelf(values(collection));
        }
        function baseSlice(array2, start, end) {
          var index = -1, length = array2.length;
          if (start < 0) {
            start = -start > length ? 0 : length + start;
          }
          end = end > length ? length : end;
          if (end < 0) {
            end += length;
          }
          length = start > end ? 0 : end - start >>> 0;
          start >>>= 0;
          var result2 = Array2(length);
          while (++index < length) {
            result2[index] = array2[index + start];
          }
          return result2;
        }
        function baseSome(collection, predicate) {
          var result2;
          baseEach(collection, function(value, index, collection2) {
            result2 = predicate(value, index, collection2);
            return !result2;
          });
          return !!result2;
        }
        function baseSortedIndex(array2, value, retHighest) {
          var low = 0, high = array2 == null ? low : array2.length;
          if (typeof value == "number" && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
            while (low < high) {
              var mid = low + high >>> 1, computed = array2[mid];
              if (computed !== null && !isSymbol(computed) && (retHighest ? computed <= value : computed < value)) {
                low = mid + 1;
              } else {
                high = mid;
              }
            }
            return high;
          }
          return baseSortedIndexBy(array2, value, identity, retHighest);
        }
        function baseSortedIndexBy(array2, value, iteratee2, retHighest) {
          var low = 0, high = array2 == null ? 0 : array2.length;
          if (high === 0) {
            return 0;
          }
          value = iteratee2(value);
          var valIsNaN = value !== value, valIsNull = value === null, valIsSymbol = isSymbol(value), valIsUndefined = value === undefined2;
          while (low < high) {
            var mid = nativeFloor((low + high) / 2), computed = iteratee2(array2[mid]), othIsDefined = computed !== undefined2, othIsNull = computed === null, othIsReflexive = computed === computed, othIsSymbol = isSymbol(computed);
            if (valIsNaN) {
              var setLow = retHighest || othIsReflexive;
            } else if (valIsUndefined) {
              setLow = othIsReflexive && (retHighest || othIsDefined);
            } else if (valIsNull) {
              setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
            } else if (valIsSymbol) {
              setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
            } else if (othIsNull || othIsSymbol) {
              setLow = false;
            } else {
              setLow = retHighest ? computed <= value : computed < value;
            }
            if (setLow) {
              low = mid + 1;
            } else {
              high = mid;
            }
          }
          return nativeMin(high, MAX_ARRAY_INDEX);
        }
        function baseSortedUniq(array2, iteratee2) {
          var index = -1, length = array2.length, resIndex = 0, result2 = [];
          while (++index < length) {
            var value = array2[index], computed = iteratee2 ? iteratee2(value) : value;
            if (!index || !eq2(computed, seen)) {
              var seen = computed;
              result2[resIndex++] = value === 0 ? 0 : value;
            }
          }
          return result2;
        }
        function baseToNumber(value) {
          if (typeof value == "number") {
            return value;
          }
          if (isSymbol(value)) {
            return NAN;
          }
          return +value;
        }
        function baseToString(value) {
          if (typeof value == "string") {
            return value;
          }
          if (isArray(value)) {
            return arrayMap(value, baseToString) + "";
          }
          if (isSymbol(value)) {
            return symbolToString ? symbolToString.call(value) : "";
          }
          var result2 = value + "";
          return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
        }
        function baseUniq(array2, iteratee2, comparator) {
          var index = -1, includes2 = arrayIncludes, length = array2.length, isCommon = true, result2 = [], seen = result2;
          if (comparator) {
            isCommon = false;
            includes2 = arrayIncludesWith;
          } else if (length >= LARGE_ARRAY_SIZE) {
            var set2 = iteratee2 ? null : createSet(array2);
            if (set2) {
              return setToArray(set2);
            }
            isCommon = false;
            includes2 = cacheHas;
            seen = new SetCache();
          } else {
            seen = iteratee2 ? [] : result2;
          }
          outer:
            while (++index < length) {
              var value = array2[index], computed = iteratee2 ? iteratee2(value) : value;
              value = comparator || value !== 0 ? value : 0;
              if (isCommon && computed === computed) {
                var seenIndex = seen.length;
                while (seenIndex--) {
                  if (seen[seenIndex] === computed) {
                    continue outer;
                  }
                }
                if (iteratee2) {
                  seen.push(computed);
                }
                result2.push(value);
              } else if (!includes2(seen, computed, comparator)) {
                if (seen !== result2) {
                  seen.push(computed);
                }
                result2.push(value);
              }
            }
          return result2;
        }
        function baseUnset(object, path) {
          path = castPath(path, object);
          object = parent(object, path);
          return object == null || delete object[toKey(last(path))];
        }
        function baseUpdate(object, path, updater, customizer) {
          return baseSet(object, path, updater(baseGet(object, path)), customizer);
        }
        function baseWhile(array2, predicate, isDrop, fromRight) {
          var length = array2.length, index = fromRight ? length : -1;
          while ((fromRight ? index-- : ++index < length) && predicate(array2[index], index, array2)) {
          }
          return isDrop ? baseSlice(array2, fromRight ? 0 : index, fromRight ? index + 1 : length) : baseSlice(array2, fromRight ? index + 1 : 0, fromRight ? length : index);
        }
        function baseWrapperValue(value, actions) {
          var result2 = value;
          if (result2 instanceof LazyWrapper) {
            result2 = result2.value();
          }
          return arrayReduce(actions, function(result3, action) {
            return action.func.apply(action.thisArg, arrayPush([result3], action.args));
          }, result2);
        }
        function baseXor(arrays, iteratee2, comparator) {
          var length = arrays.length;
          if (length < 2) {
            return length ? baseUniq(arrays[0]) : [];
          }
          var index = -1, result2 = Array2(length);
          while (++index < length) {
            var array2 = arrays[index], othIndex = -1;
            while (++othIndex < length) {
              if (othIndex != index) {
                result2[index] = baseDifference(result2[index] || array2, arrays[othIndex], iteratee2, comparator);
              }
            }
          }
          return baseUniq(baseFlatten(result2, 1), iteratee2, comparator);
        }
        function baseZipObject(props, values2, assignFunc) {
          var index = -1, length = props.length, valsLength = values2.length, result2 = {};
          while (++index < length) {
            var value = index < valsLength ? values2[index] : undefined2;
            assignFunc(result2, props[index], value);
          }
          return result2;
        }
        function castArrayLikeObject(value) {
          return isArrayLikeObject(value) ? value : [];
        }
        function castFunction(value) {
          return typeof value == "function" ? value : identity;
        }
        function castPath(value, object) {
          if (isArray(value)) {
            return value;
          }
          return isKey(value, object) ? [value] : stringToPath(toString(value));
        }
        var castRest = baseRest;
        function castSlice(array2, start, end) {
          var length = array2.length;
          end = end === undefined2 ? length : end;
          return !start && end >= length ? array2 : baseSlice(array2, start, end);
        }
        var clearTimeout2 = ctxClearTimeout || function(id) {
          return root.clearTimeout(id);
        };
        function cloneBuffer(buffer, isDeep) {
          if (isDeep) {
            return buffer.slice();
          }
          var length = buffer.length, result2 = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
          buffer.copy(result2);
          return result2;
        }
        function cloneArrayBuffer(arrayBuffer) {
          var result2 = new arrayBuffer.constructor(arrayBuffer.byteLength);
          new Uint8Array2(result2).set(new Uint8Array2(arrayBuffer));
          return result2;
        }
        function cloneDataView(dataView, isDeep) {
          var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
          return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
        }
        function cloneRegExp(regexp) {
          var result2 = new regexp.constructor(regexp.source, reFlags.exec(regexp));
          result2.lastIndex = regexp.lastIndex;
          return result2;
        }
        function cloneSymbol(symbol) {
          return symbolValueOf ? Object2(symbolValueOf.call(symbol)) : {};
        }
        function cloneTypedArray(typedArray, isDeep) {
          var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
          return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
        }
        function compareAscending(value, other) {
          if (value !== other) {
            var valIsDefined = value !== undefined2, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol(value);
            var othIsDefined = other !== undefined2, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol(other);
            if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
              return 1;
            }
            if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
              return -1;
            }
          }
          return 0;
        }
        function compareMultiple(object, other, orders) {
          var index = -1, objCriteria = object.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
          while (++index < length) {
            var result2 = compareAscending(objCriteria[index], othCriteria[index]);
            if (result2) {
              if (index >= ordersLength) {
                return result2;
              }
              var order = orders[index];
              return result2 * (order == "desc" ? -1 : 1);
            }
          }
          return object.index - other.index;
        }
        function composeArgs(args, partials, holders, isCurried) {
          var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(leftLength + rangeLength), isUncurried = !isCurried;
          while (++leftIndex < leftLength) {
            result2[leftIndex] = partials[leftIndex];
          }
          while (++argsIndex < holdersLength) {
            if (isUncurried || argsIndex < argsLength) {
              result2[holders[argsIndex]] = args[argsIndex];
            }
          }
          while (rangeLength--) {
            result2[leftIndex++] = args[argsIndex++];
          }
          return result2;
        }
        function composeArgsRight(args, partials, holders, isCurried) {
          var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(rangeLength + rightLength), isUncurried = !isCurried;
          while (++argsIndex < rangeLength) {
            result2[argsIndex] = args[argsIndex];
          }
          var offset2 = argsIndex;
          while (++rightIndex < rightLength) {
            result2[offset2 + rightIndex] = partials[rightIndex];
          }
          while (++holdersIndex < holdersLength) {
            if (isUncurried || argsIndex < argsLength) {
              result2[offset2 + holders[holdersIndex]] = args[argsIndex++];
            }
          }
          return result2;
        }
        function copyArray(source, array2) {
          var index = -1, length = source.length;
          array2 || (array2 = Array2(length));
          while (++index < length) {
            array2[index] = source[index];
          }
          return array2;
        }
        function copyObject(source, props, object, customizer) {
          var isNew = !object;
          object || (object = {});
          var index = -1, length = props.length;
          while (++index < length) {
            var key = props[index];
            var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined2;
            if (newValue === undefined2) {
              newValue = source[key];
            }
            if (isNew) {
              baseAssignValue(object, key, newValue);
            } else {
              assignValue(object, key, newValue);
            }
          }
          return object;
        }
        function copySymbols(source, object) {
          return copyObject(source, getSymbols(source), object);
        }
        function copySymbolsIn(source, object) {
          return copyObject(source, getSymbolsIn(source), object);
        }
        function createAggregator(setter, initializer) {
          return function(collection, iteratee2) {
            var func = isArray(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
            return func(collection, setter, getIteratee(iteratee2, 2), accumulator);
          };
        }
        function createAssigner(assigner) {
          return baseRest(function(object, sources) {
            var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : undefined2, guard = length > 2 ? sources[2] : undefined2;
            customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : undefined2;
            if (guard && isIterateeCall(sources[0], sources[1], guard)) {
              customizer = length < 3 ? undefined2 : customizer;
              length = 1;
            }
            object = Object2(object);
            while (++index < length) {
              var source = sources[index];
              if (source) {
                assigner(object, source, index, customizer);
              }
            }
            return object;
          });
        }
        function createBaseEach(eachFunc, fromRight) {
          return function(collection, iteratee2) {
            if (collection == null) {
              return collection;
            }
            if (!isArrayLike(collection)) {
              return eachFunc(collection, iteratee2);
            }
            var length = collection.length, index = fromRight ? length : -1, iterable = Object2(collection);
            while (fromRight ? index-- : ++index < length) {
              if (iteratee2(iterable[index], index, iterable) === false) {
                break;
              }
            }
            return collection;
          };
        }
        function createBaseFor(fromRight) {
          return function(object, iteratee2, keysFunc) {
            var index = -1, iterable = Object2(object), props = keysFunc(object), length = props.length;
            while (length--) {
              var key = props[fromRight ? length : ++index];
              if (iteratee2(iterable[key], key, iterable) === false) {
                break;
              }
            }
            return object;
          };
        }
        function createBind(func, bitmask, thisArg) {
          var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
          function wrapper() {
            var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
            return fn.apply(isBind ? thisArg : this, arguments);
          }
          return wrapper;
        }
        function createCaseFirst(methodName) {
          return function(string) {
            string = toString(string);
            var strSymbols = hasUnicode(string) ? stringToArray(string) : undefined2;
            var chr = strSymbols ? strSymbols[0] : string.charAt(0);
            var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string.slice(1);
            return chr[methodName]() + trailing;
          };
        }
        function createCompounder(callback) {
          return function(string) {
            return arrayReduce(words(deburr(string).replace(reApos, "")), callback, "");
          };
        }
        function createCtor(Ctor) {
          return function() {
            var args = arguments;
            switch (args.length) {
              case 0:
                return new Ctor();
              case 1:
                return new Ctor(args[0]);
              case 2:
                return new Ctor(args[0], args[1]);
              case 3:
                return new Ctor(args[0], args[1], args[2]);
              case 4:
                return new Ctor(args[0], args[1], args[2], args[3]);
              case 5:
                return new Ctor(args[0], args[1], args[2], args[3], args[4]);
              case 6:
                return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
              case 7:
                return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
            }
            var thisBinding = baseCreate(Ctor.prototype), result2 = Ctor.apply(thisBinding, args);
            return isObject(result2) ? result2 : thisBinding;
          };
        }
        function createCurry(func, bitmask, arity) {
          var Ctor = createCtor(func);
          function wrapper() {
            var length = arguments.length, args = Array2(length), index = length, placeholder = getHolder(wrapper);
            while (index--) {
              args[index] = arguments[index];
            }
            var holders = length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder ? [] : replaceHolders(args, placeholder);
            length -= holders.length;
            if (length < arity) {
              return createRecurry(
                func,
                bitmask,
                createHybrid,
                wrapper.placeholder,
                undefined2,
                args,
                holders,
                undefined2,
                undefined2,
                arity - length
              );
            }
            var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
            return apply(fn, this, args);
          }
          return wrapper;
        }
        function createFind(findIndexFunc) {
          return function(collection, predicate, fromIndex) {
            var iterable = Object2(collection);
            if (!isArrayLike(collection)) {
              var iteratee2 = getIteratee(predicate, 3);
              collection = keys(collection);
              predicate = function(key) {
                return iteratee2(iterable[key], key, iterable);
              };
            }
            var index = findIndexFunc(collection, predicate, fromIndex);
            return index > -1 ? iterable[iteratee2 ? collection[index] : index] : undefined2;
          };
        }
        function createFlow(fromRight) {
          return flatRest(function(funcs) {
            var length = funcs.length, index = length, prereq = LodashWrapper.prototype.thru;
            if (fromRight) {
              funcs.reverse();
            }
            while (index--) {
              var func = funcs[index];
              if (typeof func != "function") {
                throw new TypeError2(FUNC_ERROR_TEXT);
              }
              if (prereq && !wrapper && getFuncName(func) == "wrapper") {
                var wrapper = new LodashWrapper([], true);
              }
            }
            index = wrapper ? index : length;
            while (++index < length) {
              func = funcs[index];
              var funcName = getFuncName(func), data = funcName == "wrapper" ? getData(func) : undefined2;
              if (data && isLaziable(data[0]) && data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) && !data[4].length && data[9] == 1) {
                wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
              } else {
                wrapper = func.length == 1 && isLaziable(func) ? wrapper[funcName]() : wrapper.thru(func);
              }
            }
            return function() {
              var args = arguments, value = args[0];
              if (wrapper && args.length == 1 && isArray(value)) {
                return wrapper.plant(value).value();
              }
              var index2 = 0, result2 = length ? funcs[index2].apply(this, args) : value;
              while (++index2 < length) {
                result2 = funcs[index2].call(this, result2);
              }
              return result2;
            };
          });
        }
        function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary2, arity) {
          var isAry = bitmask & WRAP_ARY_FLAG, isBind = bitmask & WRAP_BIND_FLAG, isBindKey = bitmask & WRAP_BIND_KEY_FLAG, isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG), isFlip = bitmask & WRAP_FLIP_FLAG, Ctor = isBindKey ? undefined2 : createCtor(func);
          function wrapper() {
            var length = arguments.length, args = Array2(length), index = length;
            while (index--) {
              args[index] = arguments[index];
            }
            if (isCurried) {
              var placeholder = getHolder(wrapper), holdersCount = countHolders(args, placeholder);
            }
            if (partials) {
              args = composeArgs(args, partials, holders, isCurried);
            }
            if (partialsRight) {
              args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
            }
            length -= holdersCount;
            if (isCurried && length < arity) {
              var newHolders = replaceHolders(args, placeholder);
              return createRecurry(
                func,
                bitmask,
                createHybrid,
                wrapper.placeholder,
                thisArg,
                args,
                newHolders,
                argPos,
                ary2,
                arity - length
              );
            }
            var thisBinding = isBind ? thisArg : this, fn = isBindKey ? thisBinding[func] : func;
            length = args.length;
            if (argPos) {
              args = reorder(args, argPos);
            } else if (isFlip && length > 1) {
              args.reverse();
            }
            if (isAry && ary2 < length) {
              args.length = ary2;
            }
            if (this && this !== root && this instanceof wrapper) {
              fn = Ctor || createCtor(fn);
            }
            return fn.apply(thisBinding, args);
          }
          return wrapper;
        }
        function createInverter(setter, toIteratee) {
          return function(object, iteratee2) {
            return baseInverter(object, setter, toIteratee(iteratee2), {});
          };
        }
        function createMathOperation(operator, defaultValue) {
          return function(value, other) {
            var result2;
            if (value === undefined2 && other === undefined2) {
              return defaultValue;
            }
            if (value !== undefined2) {
              result2 = value;
            }
            if (other !== undefined2) {
              if (result2 === undefined2) {
                return other;
              }
              if (typeof value == "string" || typeof other == "string") {
                value = baseToString(value);
                other = baseToString(other);
              } else {
                value = baseToNumber(value);
                other = baseToNumber(other);
              }
              result2 = operator(value, other);
            }
            return result2;
          };
        }
        function createOver(arrayFunc) {
          return flatRest(function(iteratees) {
            iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
            return baseRest(function(args) {
              var thisArg = this;
              return arrayFunc(iteratees, function(iteratee2) {
                return apply(iteratee2, thisArg, args);
              });
            });
          });
        }
        function createPadding(length, chars) {
          chars = chars === undefined2 ? " " : baseToString(chars);
          var charsLength = chars.length;
          if (charsLength < 2) {
            return charsLength ? baseRepeat(chars, length) : chars;
          }
          var result2 = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
          return hasUnicode(chars) ? castSlice(stringToArray(result2), 0, length).join("") : result2.slice(0, length);
        }
        function createPartial(func, bitmask, thisArg, partials) {
          var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
          function wrapper() {
            var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array2(leftLength + argsLength), fn = this && this !== root && this instanceof wrapper ? Ctor : func;
            while (++leftIndex < leftLength) {
              args[leftIndex] = partials[leftIndex];
            }
            while (argsLength--) {
              args[leftIndex++] = arguments[++argsIndex];
            }
            return apply(fn, isBind ? thisArg : this, args);
          }
          return wrapper;
        }
        function createRange(fromRight) {
          return function(start, end, step) {
            if (step && typeof step != "number" && isIterateeCall(start, end, step)) {
              end = step = undefined2;
            }
            start = toFinite(start);
            if (end === undefined2) {
              end = start;
              start = 0;
            } else {
              end = toFinite(end);
            }
            step = step === undefined2 ? start < end ? 1 : -1 : toFinite(step);
            return baseRange(start, end, step, fromRight);
          };
        }
        function createRelationalOperation(operator) {
          return function(value, other) {
            if (!(typeof value == "string" && typeof other == "string")) {
              value = toNumber(value);
              other = toNumber(other);
            }
            return operator(value, other);
          };
        }
        function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary2, arity) {
          var isCurry = bitmask & WRAP_CURRY_FLAG, newHolders = isCurry ? holders : undefined2, newHoldersRight = isCurry ? undefined2 : holders, newPartials = isCurry ? partials : undefined2, newPartialsRight = isCurry ? undefined2 : partials;
          bitmask |= isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG;
          bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);
          if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
            bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
          }
          var newData = [
            func,
            bitmask,
            thisArg,
            newPartials,
            newHolders,
            newPartialsRight,
            newHoldersRight,
            argPos,
            ary2,
            arity
          ];
          var result2 = wrapFunc.apply(undefined2, newData);
          if (isLaziable(func)) {
            setData(result2, newData);
          }
          result2.placeholder = placeholder;
          return setWrapToString(result2, func, bitmask);
        }
        function createRound(methodName) {
          var func = Math2[methodName];
          return function(number, precision) {
            number = toNumber(number);
            precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
            if (precision && nativeIsFinite(number)) {
              var pair = (toString(number) + "e").split("e"), value = func(pair[0] + "e" + (+pair[1] + precision));
              pair = (toString(value) + "e").split("e");
              return +(pair[0] + "e" + (+pair[1] - precision));
            }
            return func(number);
          };
        }
        var createSet = !(Set2 && 1 / setToArray(new Set2([, -0]))[1] == INFINITY) ? noop : function(values2) {
          return new Set2(values2);
        };
        function createToPairs(keysFunc) {
          return function(object) {
            var tag2 = getTag(object);
            if (tag2 == mapTag) {
              return mapToArray(object);
            }
            if (tag2 == setTag) {
              return setToPairs(object);
            }
            return baseToPairs(object, keysFunc(object));
          };
        }
        function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary2, arity) {
          var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
          if (!isBindKey && typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          var length = partials ? partials.length : 0;
          if (!length) {
            bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
            partials = holders = undefined2;
          }
          ary2 = ary2 === undefined2 ? ary2 : nativeMax(toInteger(ary2), 0);
          arity = arity === undefined2 ? arity : toInteger(arity);
          length -= holders ? holders.length : 0;
          if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
            var partialsRight = partials, holdersRight = holders;
            partials = holders = undefined2;
          }
          var data = isBindKey ? undefined2 : getData(func);
          var newData = [
            func,
            bitmask,
            thisArg,
            partials,
            holders,
            partialsRight,
            holdersRight,
            argPos,
            ary2,
            arity
          ];
          if (data) {
            mergeData(newData, data);
          }
          func = newData[0];
          bitmask = newData[1];
          thisArg = newData[2];
          partials = newData[3];
          holders = newData[4];
          arity = newData[9] = newData[9] === undefined2 ? isBindKey ? 0 : func.length : nativeMax(newData[9] - length, 0);
          if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
            bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
          }
          if (!bitmask || bitmask == WRAP_BIND_FLAG) {
            var result2 = createBind(func, bitmask, thisArg);
          } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
            result2 = createCurry(func, bitmask, arity);
          } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
            result2 = createPartial(func, bitmask, thisArg, partials);
          } else {
            result2 = createHybrid.apply(undefined2, newData);
          }
          var setter = data ? baseSetData : setData;
          return setWrapToString(setter(result2, newData), func, bitmask);
        }
        function customDefaultsAssignIn(objValue, srcValue, key, object) {
          if (objValue === undefined2 || eq2(objValue, objectProto[key]) && !hasOwnProperty.call(object, key)) {
            return srcValue;
          }
          return objValue;
        }
        function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
          if (isObject(objValue) && isObject(srcValue)) {
            stack.set(srcValue, objValue);
            baseMerge(objValue, srcValue, undefined2, customDefaultsMerge, stack);
            stack["delete"](srcValue);
          }
          return objValue;
        }
        function customOmitClone(value) {
          return isPlainObject(value) ? undefined2 : value;
        }
        function equalArrays(array2, other, bitmask, customizer, equalFunc, stack) {
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array2.length, othLength = other.length;
          if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
            return false;
          }
          var arrStacked = stack.get(array2);
          var othStacked = stack.get(other);
          if (arrStacked && othStacked) {
            return arrStacked == other && othStacked == array2;
          }
          var index = -1, result2 = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined2;
          stack.set(array2, other);
          stack.set(other, array2);
          while (++index < arrLength) {
            var arrValue = array2[index], othValue = other[index];
            if (customizer) {
              var compared = isPartial ? customizer(othValue, arrValue, index, other, array2, stack) : customizer(arrValue, othValue, index, array2, other, stack);
            }
            if (compared !== undefined2) {
              if (compared) {
                continue;
              }
              result2 = false;
              break;
            }
            if (seen) {
              if (!arraySome(other, function(othValue2, othIndex) {
                if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
                  return seen.push(othIndex);
                }
              })) {
                result2 = false;
                break;
              }
            } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
              result2 = false;
              break;
            }
          }
          stack["delete"](array2);
          stack["delete"](other);
          return result2;
        }
        function equalByTag(object, other, tag2, bitmask, customizer, equalFunc, stack) {
          switch (tag2) {
            case dataViewTag:
              if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
                return false;
              }
              object = object.buffer;
              other = other.buffer;
            case arrayBufferTag:
              if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
                return false;
              }
              return true;
            case boolTag:
            case dateTag:
            case numberTag:
              return eq2(+object, +other);
            case errorTag:
              return object.name == other.name && object.message == other.message;
            case regexpTag:
            case stringTag:
              return object == other + "";
            case mapTag:
              var convert = mapToArray;
            case setTag:
              var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
              convert || (convert = setToArray);
              if (object.size != other.size && !isPartial) {
                return false;
              }
              var stacked = stack.get(object);
              if (stacked) {
                return stacked == other;
              }
              bitmask |= COMPARE_UNORDERED_FLAG;
              stack.set(object, other);
              var result2 = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
              stack["delete"](object);
              return result2;
            case symbolTag:
              if (symbolValueOf) {
                return symbolValueOf.call(object) == symbolValueOf.call(other);
              }
          }
          return false;
        }
        function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
          if (objLength != othLength && !isPartial) {
            return false;
          }
          var index = objLength;
          while (index--) {
            var key = objProps[index];
            if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
              return false;
            }
          }
          var objStacked = stack.get(object);
          var othStacked = stack.get(other);
          if (objStacked && othStacked) {
            return objStacked == other && othStacked == object;
          }
          var result2 = true;
          stack.set(object, other);
          stack.set(other, object);
          var skipCtor = isPartial;
          while (++index < objLength) {
            key = objProps[index];
            var objValue = object[key], othValue = other[key];
            if (customizer) {
              var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
            }
            if (!(compared === undefined2 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
              result2 = false;
              break;
            }
            skipCtor || (skipCtor = key == "constructor");
          }
          if (result2 && !skipCtor) {
            var objCtor = object.constructor, othCtor = other.constructor;
            if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
              result2 = false;
            }
          }
          stack["delete"](object);
          stack["delete"](other);
          return result2;
        }
        function flatRest(func) {
          return setToString(overRest(func, undefined2, flatten), func + "");
        }
        function getAllKeys(object) {
          return baseGetAllKeys(object, keys, getSymbols);
        }
        function getAllKeysIn(object) {
          return baseGetAllKeys(object, keysIn, getSymbolsIn);
        }
        var getData = !metaMap ? noop : function(func) {
          return metaMap.get(func);
        };
        function getFuncName(func) {
          var result2 = func.name + "", array2 = realNames[result2], length = hasOwnProperty.call(realNames, result2) ? array2.length : 0;
          while (length--) {
            var data = array2[length], otherFunc = data.func;
            if (otherFunc == null || otherFunc == func) {
              return data.name;
            }
          }
          return result2;
        }
        function getHolder(func) {
          var object = hasOwnProperty.call(lodash, "placeholder") ? lodash : func;
          return object.placeholder;
        }
        function getIteratee() {
          var result2 = lodash.iteratee || iteratee;
          result2 = result2 === iteratee ? baseIteratee : result2;
          return arguments.length ? result2(arguments[0], arguments[1]) : result2;
        }
        function getMapData(map2, key) {
          var data = map2.__data__;
          return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
        }
        function getMatchData(object) {
          var result2 = keys(object), length = result2.length;
          while (length--) {
            var key = result2[length], value = object[key];
            result2[length] = [key, value, isStrictComparable(value)];
          }
          return result2;
        }
        function getNative(object, key) {
          var value = getValue(object, key);
          return baseIsNative(value) ? value : undefined2;
        }
        function getRawTag(value) {
          var isOwn = hasOwnProperty.call(value, symToStringTag), tag2 = value[symToStringTag];
          try {
            value[symToStringTag] = undefined2;
            var unmasked = true;
          } catch (e) {
          }
          var result2 = nativeObjectToString.call(value);
          if (unmasked) {
            if (isOwn) {
              value[symToStringTag] = tag2;
            } else {
              delete value[symToStringTag];
            }
          }
          return result2;
        }
        var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
          if (object == null) {
            return [];
          }
          object = Object2(object);
          return arrayFilter(nativeGetSymbols(object), function(symbol) {
            return propertyIsEnumerable.call(object, symbol);
          });
        };
        var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
          var result2 = [];
          while (object) {
            arrayPush(result2, getSymbols(object));
            object = getPrototype(object);
          }
          return result2;
        };
        var getTag = baseGetTag;
        if (DataView2 && getTag(new DataView2(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
          getTag = function(value) {
            var result2 = baseGetTag(value), Ctor = result2 == objectTag ? value.constructor : undefined2, ctorString = Ctor ? toSource(Ctor) : "";
            if (ctorString) {
              switch (ctorString) {
                case dataViewCtorString:
                  return dataViewTag;
                case mapCtorString:
                  return mapTag;
                case promiseCtorString:
                  return promiseTag;
                case setCtorString:
                  return setTag;
                case weakMapCtorString:
                  return weakMapTag;
              }
            }
            return result2;
          };
        }
        function getView(start, end, transforms) {
          var index = -1, length = transforms.length;
          while (++index < length) {
            var data = transforms[index], size2 = data.size;
            switch (data.type) {
              case "drop":
                start += size2;
                break;
              case "dropRight":
                end -= size2;
                break;
              case "take":
                end = nativeMin(end, start + size2);
                break;
              case "takeRight":
                start = nativeMax(start, end - size2);
                break;
            }
          }
          return { "start": start, "end": end };
        }
        function getWrapDetails(source) {
          var match = source.match(reWrapDetails);
          return match ? match[1].split(reSplitDetails) : [];
        }
        function hasPath(object, path, hasFunc) {
          path = castPath(path, object);
          var index = -1, length = path.length, result2 = false;
          while (++index < length) {
            var key = toKey(path[index]);
            if (!(result2 = object != null && hasFunc(object, key))) {
              break;
            }
            object = object[key];
          }
          if (result2 || ++index != length) {
            return result2;
          }
          length = object == null ? 0 : object.length;
          return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
        }
        function initCloneArray(array2) {
          var length = array2.length, result2 = new array2.constructor(length);
          if (length && typeof array2[0] == "string" && hasOwnProperty.call(array2, "index")) {
            result2.index = array2.index;
            result2.input = array2.input;
          }
          return result2;
        }
        function initCloneObject(object) {
          return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
        }
        function initCloneByTag(object, tag2, isDeep) {
          var Ctor = object.constructor;
          switch (tag2) {
            case arrayBufferTag:
              return cloneArrayBuffer(object);
            case boolTag:
            case dateTag:
              return new Ctor(+object);
            case dataViewTag:
              return cloneDataView(object, isDeep);
            case float32Tag:
            case float64Tag:
            case int8Tag:
            case int16Tag:
            case int32Tag:
            case uint8Tag:
            case uint8ClampedTag:
            case uint16Tag:
            case uint32Tag:
              return cloneTypedArray(object, isDeep);
            case mapTag:
              return new Ctor();
            case numberTag:
            case stringTag:
              return new Ctor(object);
            case regexpTag:
              return cloneRegExp(object);
            case setTag:
              return new Ctor();
            case symbolTag:
              return cloneSymbol(object);
          }
        }
        function insertWrapDetails(source, details) {
          var length = details.length;
          if (!length) {
            return source;
          }
          var lastIndex = length - 1;
          details[lastIndex] = (length > 1 ? "& " : "") + details[lastIndex];
          details = details.join(length > 2 ? ", " : " ");
          return source.replace(reWrapComment, "{\n/* [wrapped with " + details + "] */\n");
        }
        function isFlattenable(value) {
          return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
        }
        function isIndex(value, length) {
          var type = typeof value;
          length = length == null ? MAX_SAFE_INTEGER3 : length;
          return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
        }
        function isIterateeCall(value, index, object) {
          if (!isObject(object)) {
            return false;
          }
          var type = typeof index;
          if (type == "number" ? isArrayLike(object) && isIndex(index, object.length) : type == "string" && index in object) {
            return eq2(object[index], value);
          }
          return false;
        }
        function isKey(value, object) {
          if (isArray(value)) {
            return false;
          }
          var type = typeof value;
          if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
            return true;
          }
          return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object2(object);
        }
        function isKeyable(value) {
          var type = typeof value;
          return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
        }
        function isLaziable(func) {
          var funcName = getFuncName(func), other = lodash[funcName];
          if (typeof other != "function" || !(funcName in LazyWrapper.prototype)) {
            return false;
          }
          if (func === other) {
            return true;
          }
          var data = getData(other);
          return !!data && func === data[0];
        }
        function isMasked(func) {
          return !!maskSrcKey && maskSrcKey in func;
        }
        var isMaskable = coreJsData ? isFunction : stubFalse;
        function isPrototype(value) {
          var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
          return value === proto;
        }
        function isStrictComparable(value) {
          return value === value && !isObject(value);
        }
        function matchesStrictComparable(key, srcValue) {
          return function(object) {
            if (object == null) {
              return false;
            }
            return object[key] === srcValue && (srcValue !== undefined2 || key in Object2(object));
          };
        }
        function memoizeCapped(func) {
          var result2 = memoize(func, function(key) {
            if (cache.size === MAX_MEMOIZE_SIZE) {
              cache.clear();
            }
            return key;
          });
          var cache = result2.cache;
          return result2;
        }
        function mergeData(data, source) {
          var bitmask = data[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);
          var isCombo = srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_CURRY_FLAG || srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_REARG_FLAG && data[7].length <= source[8] || srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG) && source[7].length <= source[8] && bitmask == WRAP_CURRY_FLAG;
          if (!(isCommon || isCombo)) {
            return data;
          }
          if (srcBitmask & WRAP_BIND_FLAG) {
            data[2] = source[2];
            newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
          }
          var value = source[3];
          if (value) {
            var partials = data[3];
            data[3] = partials ? composeArgs(partials, value, source[4]) : value;
            data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
          }
          value = source[5];
          if (value) {
            partials = data[5];
            data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
            data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
          }
          value = source[7];
          if (value) {
            data[7] = value;
          }
          if (srcBitmask & WRAP_ARY_FLAG) {
            data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
          }
          if (data[9] == null) {
            data[9] = source[9];
          }
          data[0] = source[0];
          data[1] = newBitmask;
          return data;
        }
        function nativeKeysIn(object) {
          var result2 = [];
          if (object != null) {
            for (var key in Object2(object)) {
              result2.push(key);
            }
          }
          return result2;
        }
        function objectToString(value) {
          return nativeObjectToString.call(value);
        }
        function overRest(func, start, transform2) {
          start = nativeMax(start === undefined2 ? func.length - 1 : start, 0);
          return function() {
            var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array2 = Array2(length);
            while (++index < length) {
              array2[index] = args[start + index];
            }
            index = -1;
            var otherArgs = Array2(start + 1);
            while (++index < start) {
              otherArgs[index] = args[index];
            }
            otherArgs[start] = transform2(array2);
            return apply(func, this, otherArgs);
          };
        }
        function parent(object, path) {
          return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
        }
        function reorder(array2, indexes) {
          var arrLength = array2.length, length = nativeMin(indexes.length, arrLength), oldArray = copyArray(array2);
          while (length--) {
            var index = indexes[length];
            array2[length] = isIndex(index, arrLength) ? oldArray[index] : undefined2;
          }
          return array2;
        }
        function safeGet(object, key) {
          if (key === "constructor" && typeof object[key] === "function") {
            return;
          }
          if (key == "__proto__") {
            return;
          }
          return object[key];
        }
        var setData = shortOut(baseSetData);
        var setTimeout2 = ctxSetTimeout || function(func, wait) {
          return root.setTimeout(func, wait);
        };
        var setToString = shortOut(baseSetToString);
        function setWrapToString(wrapper, reference, bitmask) {
          var source = reference + "";
          return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
        }
        function shortOut(func) {
          var count = 0, lastCalled = 0;
          return function() {
            var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
            lastCalled = stamp;
            if (remaining > 0) {
              if (++count >= HOT_COUNT) {
                return arguments[0];
              }
            } else {
              count = 0;
            }
            return func.apply(undefined2, arguments);
          };
        }
        function shuffleSelf(array2, size2) {
          var index = -1, length = array2.length, lastIndex = length - 1;
          size2 = size2 === undefined2 ? length : size2;
          while (++index < size2) {
            var rand = baseRandom(index, lastIndex), value = array2[rand];
            array2[rand] = array2[index];
            array2[index] = value;
          }
          array2.length = size2;
          return array2;
        }
        var stringToPath = memoizeCapped(function(string) {
          var result2 = [];
          if (string.charCodeAt(0) === 46) {
            result2.push("");
          }
          string.replace(rePropName, function(match, number, quote, subString) {
            result2.push(quote ? subString.replace(reEscapeChar, "$1") : number || match);
          });
          return result2;
        });
        function toKey(value) {
          if (typeof value == "string" || isSymbol(value)) {
            return value;
          }
          var result2 = value + "";
          return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
        }
        function toSource(func) {
          if (func != null) {
            try {
              return funcToString.call(func);
            } catch (e) {
            }
            try {
              return func + "";
            } catch (e) {
            }
          }
          return "";
        }
        function updateWrapDetails(details, bitmask) {
          arrayEach(wrapFlags, function(pair) {
            var value = "_." + pair[0];
            if (bitmask & pair[1] && !arrayIncludes(details, value)) {
              details.push(value);
            }
          });
          return details.sort();
        }
        function wrapperClone(wrapper) {
          if (wrapper instanceof LazyWrapper) {
            return wrapper.clone();
          }
          var result2 = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
          result2.__actions__ = copyArray(wrapper.__actions__);
          result2.__index__ = wrapper.__index__;
          result2.__values__ = wrapper.__values__;
          return result2;
        }
        function chunk(array2, size2, guard) {
          if (guard ? isIterateeCall(array2, size2, guard) : size2 === undefined2) {
            size2 = 1;
          } else {
            size2 = nativeMax(toInteger(size2), 0);
          }
          var length = array2 == null ? 0 : array2.length;
          if (!length || size2 < 1) {
            return [];
          }
          var index = 0, resIndex = 0, result2 = Array2(nativeCeil(length / size2));
          while (index < length) {
            result2[resIndex++] = baseSlice(array2, index, index += size2);
          }
          return result2;
        }
        function compact(array2) {
          var index = -1, length = array2 == null ? 0 : array2.length, resIndex = 0, result2 = [];
          while (++index < length) {
            var value = array2[index];
            if (value) {
              result2[resIndex++] = value;
            }
          }
          return result2;
        }
        function concat() {
          var length = arguments.length;
          if (!length) {
            return [];
          }
          var args = Array2(length - 1), array2 = arguments[0], index = length;
          while (index--) {
            args[index - 1] = arguments[index];
          }
          return arrayPush(isArray(array2) ? copyArray(array2) : [array2], baseFlatten(args, 1));
        }
        var difference = baseRest(function(array2, values2) {
          return isArrayLikeObject(array2) ? baseDifference(array2, baseFlatten(values2, 1, isArrayLikeObject, true)) : [];
        });
        var differenceBy = baseRest(function(array2, values2) {
          var iteratee2 = last(values2);
          if (isArrayLikeObject(iteratee2)) {
            iteratee2 = undefined2;
          }
          return isArrayLikeObject(array2) ? baseDifference(array2, baseFlatten(values2, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2)) : [];
        });
        var differenceWith = baseRest(function(array2, values2) {
          var comparator = last(values2);
          if (isArrayLikeObject(comparator)) {
            comparator = undefined2;
          }
          return isArrayLikeObject(array2) ? baseDifference(array2, baseFlatten(values2, 1, isArrayLikeObject, true), undefined2, comparator) : [];
        });
        function drop(array2, n, guard) {
          var length = array2 == null ? 0 : array2.length;
          if (!length) {
            return [];
          }
          n = guard || n === undefined2 ? 1 : toInteger(n);
          return baseSlice(array2, n < 0 ? 0 : n, length);
        }
        function dropRight(array2, n, guard) {
          var length = array2 == null ? 0 : array2.length;
          if (!length) {
            return [];
          }
          n = guard || n === undefined2 ? 1 : toInteger(n);
          n = length - n;
          return baseSlice(array2, 0, n < 0 ? 0 : n);
        }
        function dropRightWhile(array2, predicate) {
          return array2 && array2.length ? baseWhile(array2, getIteratee(predicate, 3), true, true) : [];
        }
        function dropWhile(array2, predicate) {
          return array2 && array2.length ? baseWhile(array2, getIteratee(predicate, 3), true) : [];
        }
        function fill(array2, value, start, end) {
          var length = array2 == null ? 0 : array2.length;
          if (!length) {
            return [];
          }
          if (start && typeof start != "number" && isIterateeCall(array2, value, start)) {
            start = 0;
            end = length;
          }
          return baseFill(array2, value, start, end);
        }
        function findIndex(array2, predicate, fromIndex) {
          var length = array2 == null ? 0 : array2.length;
          if (!length) {
            return -1;
          }
          var index = fromIndex == null ? 0 : toInteger(fromIndex);
          if (index < 0) {
            index = nativeMax(length + index, 0);
          }
          return baseFindIndex(array2, getIteratee(predicate, 3), index);
        }
        function findLastIndex(array2, predicate, fromIndex) {
          var length = array2 == null ? 0 : array2.length;
          if (!length) {
            return -1;
          }
          var index = length - 1;
          if (fromIndex !== undefined2) {
            index = toInteger(fromIndex);
            index = fromIndex < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
          }
          return baseFindIndex(array2, getIteratee(predicate, 3), index, true);
        }
        function flatten(array2) {
          var length = array2 == null ? 0 : array2.length;
          return length ? baseFlatten(array2, 1) : [];
        }
        function flattenDeep(array2) {
          var length = array2 == null ? 0 : array2.length;
          return length ? baseFlatten(array2, INFINITY) : [];
        }
        function flattenDepth(array2, depth) {
          var length = array2 == null ? 0 : array2.length;
          if (!length) {
            return [];
          }
          depth = depth === undefined2 ? 1 : toInteger(depth);
          return baseFlatten(array2, depth);
        }
        function fromPairs(pairs) {
          var index = -1, length = pairs == null ? 0 : pairs.length, result2 = {};
          while (++index < length) {
            var pair = pairs[index];
            result2[pair[0]] = pair[1];
          }
          return result2;
        }
        function head(array2) {
          return array2 && array2.length ? array2[0] : undefined2;
        }
        function indexOf(array2, value, fromIndex) {
          var length = array2 == null ? 0 : array2.length;
          if (!length) {
            return -1;
          }
          var index = fromIndex == null ? 0 : toInteger(fromIndex);
          if (index < 0) {
            index = nativeMax(length + index, 0);
          }
          return baseIndexOf(array2, value, index);
        }
        function initial(array2) {
          var length = array2 == null ? 0 : array2.length;
          return length ? baseSlice(array2, 0, -1) : [];
        }
        var intersection2 = baseRest(function(arrays) {
          var mapped = arrayMap(arrays, castArrayLikeObject);
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
        });
        var intersectionBy = baseRest(function(arrays) {
          var iteratee2 = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
          if (iteratee2 === last(mapped)) {
            iteratee2 = undefined2;
          } else {
            mapped.pop();
          }
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, getIteratee(iteratee2, 2)) : [];
        });
        var intersectionWith = baseRest(function(arrays) {
          var comparator = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
          comparator = typeof comparator == "function" ? comparator : undefined2;
          if (comparator) {
            mapped.pop();
          }
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, undefined2, comparator) : [];
        });
        function join(array2, separator) {
          return array2 == null ? "" : nativeJoin.call(array2, separator);
        }
        function last(array2) {
          var length = array2 == null ? 0 : array2.length;
          return length ? array2[length - 1] : undefined2;
        }
        function lastIndexOf(array2, value, fromIndex) {
          var length = array2 == null ? 0 : array2.length;
          if (!length) {
            return -1;
          }
          var index = length;
          if (fromIndex !== undefined2) {
            index = toInteger(fromIndex);
            index = index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
          }
          return value === value ? strictLastIndexOf(array2, value, index) : baseFindIndex(array2, baseIsNaN, index, true);
        }
        function nth(array2, n) {
          return array2 && array2.length ? baseNth(array2, toInteger(n)) : undefined2;
        }
        var pull = baseRest(pullAll);
        function pullAll(array2, values2) {
          return array2 && array2.length && values2 && values2.length ? basePullAll(array2, values2) : array2;
        }
        function pullAllBy(array2, values2, iteratee2) {
          return array2 && array2.length && values2 && values2.length ? basePullAll(array2, values2, getIteratee(iteratee2, 2)) : array2;
        }
        function pullAllWith(array2, values2, comparator) {
          return array2 && array2.length && values2 && values2.length ? basePullAll(array2, values2, undefined2, comparator) : array2;
        }
        var pullAt = flatRest(function(array2, indexes) {
          var length = array2 == null ? 0 : array2.length, result2 = baseAt(array2, indexes);
          basePullAt(array2, arrayMap(indexes, function(index) {
            return isIndex(index, length) ? +index : index;
          }).sort(compareAscending));
          return result2;
        });
        function remove(array2, predicate) {
          var result2 = [];
          if (!(array2 && array2.length)) {
            return result2;
          }
          var index = -1, indexes = [], length = array2.length;
          predicate = getIteratee(predicate, 3);
          while (++index < length) {
            var value = array2[index];
            if (predicate(value, index, array2)) {
              result2.push(value);
              indexes.push(index);
            }
          }
          basePullAt(array2, indexes);
          return result2;
        }
        function reverse(array2) {
          return array2 == null ? array2 : nativeReverse.call(array2);
        }
        function slice(array2, start, end) {
          var length = array2 == null ? 0 : array2.length;
          if (!length) {
            return [];
          }
          if (end && typeof end != "number" && isIterateeCall(array2, start, end)) {
            start = 0;
            end = length;
          } else {
            start = start == null ? 0 : toInteger(start);
            end = end === undefined2 ? length : toInteger(end);
          }
          return baseSlice(array2, start, end);
        }
        function sortedIndex(array2, value) {
          return baseSortedIndex(array2, value);
        }
        function sortedIndexBy(array2, value, iteratee2) {
          return baseSortedIndexBy(array2, value, getIteratee(iteratee2, 2));
        }
        function sortedIndexOf(array2, value) {
          var length = array2 == null ? 0 : array2.length;
          if (length) {
            var index = baseSortedIndex(array2, value);
            if (index < length && eq2(array2[index], value)) {
              return index;
            }
          }
          return -1;
        }
        function sortedLastIndex(array2, value) {
          return baseSortedIndex(array2, value, true);
        }
        function sortedLastIndexBy(array2, value, iteratee2) {
          return baseSortedIndexBy(array2, value, getIteratee(iteratee2, 2), true);
        }
        function sortedLastIndexOf(array2, value) {
          var length = array2 == null ? 0 : array2.length;
          if (length) {
            var index = baseSortedIndex(array2, value, true) - 1;
            if (eq2(array2[index], value)) {
              return index;
            }
          }
          return -1;
        }
        function sortedUniq(array2) {
          return array2 && array2.length ? baseSortedUniq(array2) : [];
        }
        function sortedUniqBy(array2, iteratee2) {
          return array2 && array2.length ? baseSortedUniq(array2, getIteratee(iteratee2, 2)) : [];
        }
        function tail(array2) {
          var length = array2 == null ? 0 : array2.length;
          return length ? baseSlice(array2, 1, length) : [];
        }
        function take(array2, n, guard) {
          if (!(array2 && array2.length)) {
            return [];
          }
          n = guard || n === undefined2 ? 1 : toInteger(n);
          return baseSlice(array2, 0, n < 0 ? 0 : n);
        }
        function takeRight(array2, n, guard) {
          var length = array2 == null ? 0 : array2.length;
          if (!length) {
            return [];
          }
          n = guard || n === undefined2 ? 1 : toInteger(n);
          n = length - n;
          return baseSlice(array2, n < 0 ? 0 : n, length);
        }
        function takeRightWhile(array2, predicate) {
          return array2 && array2.length ? baseWhile(array2, getIteratee(predicate, 3), false, true) : [];
        }
        function takeWhile(array2, predicate) {
          return array2 && array2.length ? baseWhile(array2, getIteratee(predicate, 3)) : [];
        }
        var union2 = baseRest(function(arrays) {
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
        });
        var unionBy = baseRest(function(arrays) {
          var iteratee2 = last(arrays);
          if (isArrayLikeObject(iteratee2)) {
            iteratee2 = undefined2;
          }
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2));
        });
        var unionWith = baseRest(function(arrays) {
          var comparator = last(arrays);
          comparator = typeof comparator == "function" ? comparator : undefined2;
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined2, comparator);
        });
        function uniq2(array2) {
          return array2 && array2.length ? baseUniq(array2) : [];
        }
        function uniqBy(array2, iteratee2) {
          return array2 && array2.length ? baseUniq(array2, getIteratee(iteratee2, 2)) : [];
        }
        function uniqWith(array2, comparator) {
          comparator = typeof comparator == "function" ? comparator : undefined2;
          return array2 && array2.length ? baseUniq(array2, undefined2, comparator) : [];
        }
        function unzip(array2) {
          if (!(array2 && array2.length)) {
            return [];
          }
          var length = 0;
          array2 = arrayFilter(array2, function(group) {
            if (isArrayLikeObject(group)) {
              length = nativeMax(group.length, length);
              return true;
            }
          });
          return baseTimes(length, function(index) {
            return arrayMap(array2, baseProperty(index));
          });
        }
        function unzipWith(array2, iteratee2) {
          if (!(array2 && array2.length)) {
            return [];
          }
          var result2 = unzip(array2);
          if (iteratee2 == null) {
            return result2;
          }
          return arrayMap(result2, function(group) {
            return apply(iteratee2, undefined2, group);
          });
        }
        var without = baseRest(function(array2, values2) {
          return isArrayLikeObject(array2) ? baseDifference(array2, values2) : [];
        });
        var xor2 = baseRest(function(arrays) {
          return baseXor(arrayFilter(arrays, isArrayLikeObject));
        });
        var xorBy = baseRest(function(arrays) {
          var iteratee2 = last(arrays);
          if (isArrayLikeObject(iteratee2)) {
            iteratee2 = undefined2;
          }
          return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee2, 2));
        });
        var xorWith = baseRest(function(arrays) {
          var comparator = last(arrays);
          comparator = typeof comparator == "function" ? comparator : undefined2;
          return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined2, comparator);
        });
        var zip = baseRest(unzip);
        function zipObject(props, values2) {
          return baseZipObject(props || [], values2 || [], assignValue);
        }
        function zipObjectDeep(props, values2) {
          return baseZipObject(props || [], values2 || [], baseSet);
        }
        var zipWith = baseRest(function(arrays) {
          var length = arrays.length, iteratee2 = length > 1 ? arrays[length - 1] : undefined2;
          iteratee2 = typeof iteratee2 == "function" ? (arrays.pop(), iteratee2) : undefined2;
          return unzipWith(arrays, iteratee2);
        });
        function chain(value) {
          var result2 = lodash(value);
          result2.__chain__ = true;
          return result2;
        }
        function tap(value, interceptor) {
          interceptor(value);
          return value;
        }
        function thru(value, interceptor) {
          return interceptor(value);
        }
        var wrapperAt = flatRest(function(paths) {
          var length = paths.length, start = length ? paths[0] : 0, value = this.__wrapped__, interceptor = function(object) {
            return baseAt(object, paths);
          };
          if (length > 1 || this.__actions__.length || !(value instanceof LazyWrapper) || !isIndex(start)) {
            return this.thru(interceptor);
          }
          value = value.slice(start, +start + (length ? 1 : 0));
          value.__actions__.push({
            "func": thru,
            "args": [interceptor],
            "thisArg": undefined2
          });
          return new LodashWrapper(value, this.__chain__).thru(function(array2) {
            if (length && !array2.length) {
              array2.push(undefined2);
            }
            return array2;
          });
        });
        function wrapperChain() {
          return chain(this);
        }
        function wrapperCommit() {
          return new LodashWrapper(this.value(), this.__chain__);
        }
        function wrapperNext() {
          if (this.__values__ === undefined2) {
            this.__values__ = toArray(this.value());
          }
          var done = this.__index__ >= this.__values__.length, value = done ? undefined2 : this.__values__[this.__index__++];
          return { "done": done, "value": value };
        }
        function wrapperToIterator() {
          return this;
        }
        function wrapperPlant(value) {
          var result2, parent2 = this;
          while (parent2 instanceof baseLodash) {
            var clone4 = wrapperClone(parent2);
            clone4.__index__ = 0;
            clone4.__values__ = undefined2;
            if (result2) {
              previous.__wrapped__ = clone4;
            } else {
              result2 = clone4;
            }
            var previous = clone4;
            parent2 = parent2.__wrapped__;
          }
          previous.__wrapped__ = value;
          return result2;
        }
        function wrapperReverse() {
          var value = this.__wrapped__;
          if (value instanceof LazyWrapper) {
            var wrapped = value;
            if (this.__actions__.length) {
              wrapped = new LazyWrapper(this);
            }
            wrapped = wrapped.reverse();
            wrapped.__actions__.push({
              "func": thru,
              "args": [reverse],
              "thisArg": undefined2
            });
            return new LodashWrapper(wrapped, this.__chain__);
          }
          return this.thru(reverse);
        }
        function wrapperValue() {
          return baseWrapperValue(this.__wrapped__, this.__actions__);
        }
        var countBy = createAggregator(function(result2, value, key) {
          if (hasOwnProperty.call(result2, key)) {
            ++result2[key];
          } else {
            baseAssignValue(result2, key, 1);
          }
        });
        function every(collection, predicate, guard) {
          var func = isArray(collection) ? arrayEvery : baseEvery;
          if (guard && isIterateeCall(collection, predicate, guard)) {
            predicate = undefined2;
          }
          return func(collection, getIteratee(predicate, 3));
        }
        function filter(collection, predicate) {
          var func = isArray(collection) ? arrayFilter : baseFilter;
          return func(collection, getIteratee(predicate, 3));
        }
        var find = createFind(findIndex);
        var findLast = createFind(findLastIndex);
        function flatMap(collection, iteratee2) {
          return baseFlatten(map(collection, iteratee2), 1);
        }
        function flatMapDeep(collection, iteratee2) {
          return baseFlatten(map(collection, iteratee2), INFINITY);
        }
        function flatMapDepth(collection, iteratee2, depth) {
          depth = depth === undefined2 ? 1 : toInteger(depth);
          return baseFlatten(map(collection, iteratee2), depth);
        }
        function forEach(collection, iteratee2) {
          var func = isArray(collection) ? arrayEach : baseEach;
          return func(collection, getIteratee(iteratee2, 3));
        }
        function forEachRight(collection, iteratee2) {
          var func = isArray(collection) ? arrayEachRight : baseEachRight;
          return func(collection, getIteratee(iteratee2, 3));
        }
        var groupBy = createAggregator(function(result2, value, key) {
          if (hasOwnProperty.call(result2, key)) {
            result2[key].push(value);
          } else {
            baseAssignValue(result2, key, [value]);
          }
        });
        function includes(collection, value, fromIndex, guard) {
          collection = isArrayLike(collection) ? collection : values(collection);
          fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
          var length = collection.length;
          if (fromIndex < 0) {
            fromIndex = nativeMax(length + fromIndex, 0);
          }
          return isString(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection, value, fromIndex) > -1;
        }
        var invokeMap = baseRest(function(collection, path, args) {
          var index = -1, isFunc = typeof path == "function", result2 = isArrayLike(collection) ? Array2(collection.length) : [];
          baseEach(collection, function(value) {
            result2[++index] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);
          });
          return result2;
        });
        var keyBy = createAggregator(function(result2, value, key) {
          baseAssignValue(result2, key, value);
        });
        function map(collection, iteratee2) {
          var func = isArray(collection) ? arrayMap : baseMap;
          return func(collection, getIteratee(iteratee2, 3));
        }
        function orderBy(collection, iteratees, orders, guard) {
          if (collection == null) {
            return [];
          }
          if (!isArray(iteratees)) {
            iteratees = iteratees == null ? [] : [iteratees];
          }
          orders = guard ? undefined2 : orders;
          if (!isArray(orders)) {
            orders = orders == null ? [] : [orders];
          }
          return baseOrderBy(collection, iteratees, orders);
        }
        var partition = createAggregator(function(result2, value, key) {
          result2[key ? 0 : 1].push(value);
        }, function() {
          return [[], []];
        });
        function reduce(collection, iteratee2, accumulator) {
          var func = isArray(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
          return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEach);
        }
        function reduceRight(collection, iteratee2, accumulator) {
          var func = isArray(collection) ? arrayReduceRight : baseReduce, initAccum = arguments.length < 3;
          return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEachRight);
        }
        function reject(collection, predicate) {
          var func = isArray(collection) ? arrayFilter : baseFilter;
          return func(collection, negate(getIteratee(predicate, 3)));
        }
        function sample(collection) {
          var func = isArray(collection) ? arraySample : baseSample;
          return func(collection);
        }
        function sampleSize(collection, n, guard) {
          if (guard ? isIterateeCall(collection, n, guard) : n === undefined2) {
            n = 1;
          } else {
            n = toInteger(n);
          }
          var func = isArray(collection) ? arraySampleSize : baseSampleSize;
          return func(collection, n);
        }
        function shuffle(collection) {
          var func = isArray(collection) ? arrayShuffle : baseShuffle;
          return func(collection);
        }
        function size(collection) {
          if (collection == null) {
            return 0;
          }
          if (isArrayLike(collection)) {
            return isString(collection) ? stringSize(collection) : collection.length;
          }
          var tag2 = getTag(collection);
          if (tag2 == mapTag || tag2 == setTag) {
            return collection.size;
          }
          return baseKeys(collection).length;
        }
        function some(collection, predicate, guard) {
          var func = isArray(collection) ? arraySome : baseSome;
          if (guard && isIterateeCall(collection, predicate, guard)) {
            predicate = undefined2;
          }
          return func(collection, getIteratee(predicate, 3));
        }
        var sortBy = baseRest(function(collection, iteratees) {
          if (collection == null) {
            return [];
          }
          var length = iteratees.length;
          if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
            iteratees = [];
          } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
            iteratees = [iteratees[0]];
          }
          return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
        });
        var now = ctxNow || function() {
          return root.Date.now();
        };
        function after(n, func) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          n = toInteger(n);
          return function() {
            if (--n < 1) {
              return func.apply(this, arguments);
            }
          };
        }
        function ary(func, n, guard) {
          n = guard ? undefined2 : n;
          n = func && n == null ? func.length : n;
          return createWrap(func, WRAP_ARY_FLAG, undefined2, undefined2, undefined2, undefined2, n);
        }
        function before(n, func) {
          var result2;
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          n = toInteger(n);
          return function() {
            if (--n > 0) {
              result2 = func.apply(this, arguments);
            }
            if (n <= 1) {
              func = undefined2;
            }
            return result2;
          };
        }
        var bind = baseRest(function(func, thisArg, partials) {
          var bitmask = WRAP_BIND_FLAG;
          if (partials.length) {
            var holders = replaceHolders(partials, getHolder(bind));
            bitmask |= WRAP_PARTIAL_FLAG;
          }
          return createWrap(func, bitmask, thisArg, partials, holders);
        });
        var bindKey = baseRest(function(object, key, partials) {
          var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
          if (partials.length) {
            var holders = replaceHolders(partials, getHolder(bindKey));
            bitmask |= WRAP_PARTIAL_FLAG;
          }
          return createWrap(key, bitmask, object, partials, holders);
        });
        function curry(func, arity, guard) {
          arity = guard ? undefined2 : arity;
          var result2 = createWrap(func, WRAP_CURRY_FLAG, undefined2, undefined2, undefined2, undefined2, undefined2, arity);
          result2.placeholder = curry.placeholder;
          return result2;
        }
        function curryRight(func, arity, guard) {
          arity = guard ? undefined2 : arity;
          var result2 = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined2, undefined2, undefined2, undefined2, undefined2, arity);
          result2.placeholder = curryRight.placeholder;
          return result2;
        }
        function debounce(func, wait, options) {
          var lastArgs, lastThis, maxWait, result2, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          wait = toNumber(wait) || 0;
          if (isObject(options)) {
            leading = !!options.leading;
            maxing = "maxWait" in options;
            maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
            trailing = "trailing" in options ? !!options.trailing : trailing;
          }
          function invokeFunc(time) {
            var args = lastArgs, thisArg = lastThis;
            lastArgs = lastThis = undefined2;
            lastInvokeTime = time;
            result2 = func.apply(thisArg, args);
            return result2;
          }
          function leadingEdge(time) {
            lastInvokeTime = time;
            timerId = setTimeout2(timerExpired, wait);
            return leading ? invokeFunc(time) : result2;
          }
          function remainingWait(time) {
            var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
            return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
          }
          function shouldInvoke(time) {
            var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
            return lastCallTime === undefined2 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
          }
          function timerExpired() {
            var time = now();
            if (shouldInvoke(time)) {
              return trailingEdge(time);
            }
            timerId = setTimeout2(timerExpired, remainingWait(time));
          }
          function trailingEdge(time) {
            timerId = undefined2;
            if (trailing && lastArgs) {
              return invokeFunc(time);
            }
            lastArgs = lastThis = undefined2;
            return result2;
          }
          function cancel() {
            if (timerId !== undefined2) {
              clearTimeout2(timerId);
            }
            lastInvokeTime = 0;
            lastArgs = lastCallTime = lastThis = timerId = undefined2;
          }
          function flush() {
            return timerId === undefined2 ? result2 : trailingEdge(now());
          }
          function debounced() {
            var time = now(), isInvoking = shouldInvoke(time);
            lastArgs = arguments;
            lastThis = this;
            lastCallTime = time;
            if (isInvoking) {
              if (timerId === undefined2) {
                return leadingEdge(lastCallTime);
              }
              if (maxing) {
                clearTimeout2(timerId);
                timerId = setTimeout2(timerExpired, wait);
                return invokeFunc(lastCallTime);
              }
            }
            if (timerId === undefined2) {
              timerId = setTimeout2(timerExpired, wait);
            }
            return result2;
          }
          debounced.cancel = cancel;
          debounced.flush = flush;
          return debounced;
        }
        var defer = baseRest(function(func, args) {
          return baseDelay(func, 1, args);
        });
        var delay = baseRest(function(func, wait, args) {
          return baseDelay(func, toNumber(wait) || 0, args);
        });
        function flip(func) {
          return createWrap(func, WRAP_FLIP_FLAG);
        }
        function memoize(func, resolver) {
          if (typeof func != "function" || resolver != null && typeof resolver != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          var memoized = function() {
            var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
            if (cache.has(key)) {
              return cache.get(key);
            }
            var result2 = func.apply(this, args);
            memoized.cache = cache.set(key, result2) || cache;
            return result2;
          };
          memoized.cache = new (memoize.Cache || MapCache)();
          return memoized;
        }
        memoize.Cache = MapCache;
        function negate(predicate) {
          if (typeof predicate != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          return function() {
            var args = arguments;
            switch (args.length) {
              case 0:
                return !predicate.call(this);
              case 1:
                return !predicate.call(this, args[0]);
              case 2:
                return !predicate.call(this, args[0], args[1]);
              case 3:
                return !predicate.call(this, args[0], args[1], args[2]);
            }
            return !predicate.apply(this, args);
          };
        }
        function once(func) {
          return before(2, func);
        }
        var overArgs = castRest(function(func, transforms) {
          transforms = transforms.length == 1 && isArray(transforms[0]) ? arrayMap(transforms[0], baseUnary(getIteratee())) : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));
          var funcsLength = transforms.length;
          return baseRest(function(args) {
            var index = -1, length = nativeMin(args.length, funcsLength);
            while (++index < length) {
              args[index] = transforms[index].call(this, args[index]);
            }
            return apply(func, this, args);
          });
        });
        var partial = baseRest(function(func, partials) {
          var holders = replaceHolders(partials, getHolder(partial));
          return createWrap(func, WRAP_PARTIAL_FLAG, undefined2, partials, holders);
        });
        var partialRight = baseRest(function(func, partials) {
          var holders = replaceHolders(partials, getHolder(partialRight));
          return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined2, partials, holders);
        });
        var rearg = flatRest(function(func, indexes) {
          return createWrap(func, WRAP_REARG_FLAG, undefined2, undefined2, undefined2, indexes);
        });
        function rest(func, start) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          start = start === undefined2 ? start : toInteger(start);
          return baseRest(func, start);
        }
        function spread(func, start) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          start = start == null ? 0 : nativeMax(toInteger(start), 0);
          return baseRest(function(args) {
            var array2 = args[start], otherArgs = castSlice(args, 0, start);
            if (array2) {
              arrayPush(otherArgs, array2);
            }
            return apply(func, this, otherArgs);
          });
        }
        function throttle(func, wait, options) {
          var leading = true, trailing = true;
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          if (isObject(options)) {
            leading = "leading" in options ? !!options.leading : leading;
            trailing = "trailing" in options ? !!options.trailing : trailing;
          }
          return debounce(func, wait, {
            "leading": leading,
            "maxWait": wait,
            "trailing": trailing
          });
        }
        function unary(func) {
          return ary(func, 1);
        }
        function wrap(value, wrapper) {
          return partial(castFunction(wrapper), value);
        }
        function castArray() {
          if (!arguments.length) {
            return [];
          }
          var value = arguments[0];
          return isArray(value) ? value : [value];
        }
        function clone3(value) {
          return baseClone(value, CLONE_SYMBOLS_FLAG);
        }
        function cloneWith(value, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
        }
        function cloneDeep(value) {
          return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
        }
        function cloneDeepWith(value, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
        }
        function conformsTo(object, source) {
          return source == null || baseConformsTo(object, source, keys(source));
        }
        function eq2(value, other) {
          return value === other || value !== value && other !== other;
        }
        var gt = createRelationalOperation(baseGt);
        var gte2 = createRelationalOperation(function(value, other) {
          return value >= other;
        });
        var isArguments = baseIsArguments(/* @__PURE__ */ function() {
          return arguments;
        }()) ? baseIsArguments : function(value) {
          return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
        };
        var isArray = Array2.isArray;
        var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;
        function isArrayLike(value) {
          return value != null && isLength(value.length) && !isFunction(value);
        }
        function isArrayLikeObject(value) {
          return isObjectLike(value) && isArrayLike(value);
        }
        function isBoolean(value) {
          return value === true || value === false || isObjectLike(value) && baseGetTag(value) == boolTag;
        }
        var isBuffer = nativeIsBuffer || stubFalse;
        var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;
        function isElement(value) {
          return isObjectLike(value) && value.nodeType === 1 && !isPlainObject(value);
        }
        function isEmpty(value) {
          if (value == null) {
            return true;
          }
          if (isArrayLike(value) && (isArray(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer(value) || isTypedArray(value) || isArguments(value))) {
            return !value.length;
          }
          var tag2 = getTag(value);
          if (tag2 == mapTag || tag2 == setTag) {
            return !value.size;
          }
          if (isPrototype(value)) {
            return !baseKeys(value).length;
          }
          for (var key in value) {
            if (hasOwnProperty.call(value, key)) {
              return false;
            }
          }
          return true;
        }
        function isEqual(value, other) {
          return baseIsEqual(value, other);
        }
        function isEqualWith(value, other, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          var result2 = customizer ? customizer(value, other) : undefined2;
          return result2 === undefined2 ? baseIsEqual(value, other, undefined2, customizer) : !!result2;
        }
        function isError(value) {
          if (!isObjectLike(value)) {
            return false;
          }
          var tag2 = baseGetTag(value);
          return tag2 == errorTag || tag2 == domExcTag || typeof value.message == "string" && typeof value.name == "string" && !isPlainObject(value);
        }
        function isFinite2(value) {
          return typeof value == "number" && nativeIsFinite(value);
        }
        function isFunction(value) {
          if (!isObject(value)) {
            return false;
          }
          var tag2 = baseGetTag(value);
          return tag2 == funcTag || tag2 == genTag || tag2 == asyncTag || tag2 == proxyTag;
        }
        function isInteger(value) {
          return typeof value == "number" && value == toInteger(value);
        }
        function isLength(value) {
          return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER3;
        }
        function isObject(value) {
          var type = typeof value;
          return value != null && (type == "object" || type == "function");
        }
        function isObjectLike(value) {
          return value != null && typeof value == "object";
        }
        var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
        function isMatch(object, source) {
          return object === source || baseIsMatch(object, source, getMatchData(source));
        }
        function isMatchWith(object, source, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return baseIsMatch(object, source, getMatchData(source), customizer);
        }
        function isNaN2(value) {
          return isNumber2(value) && value != +value;
        }
        function isNative(value) {
          if (isMaskable(value)) {
            throw new Error2(CORE_ERROR_TEXT);
          }
          return baseIsNative(value);
        }
        function isNull(value) {
          return value === null;
        }
        function isNil(value) {
          return value == null;
        }
        function isNumber2(value) {
          return typeof value == "number" || isObjectLike(value) && baseGetTag(value) == numberTag;
        }
        function isPlainObject(value) {
          if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
            return false;
          }
          var proto = getPrototype(value);
          if (proto === null) {
            return true;
          }
          var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
          return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
        }
        var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;
        function isSafeInteger(value) {
          return isInteger(value) && value >= -MAX_SAFE_INTEGER3 && value <= MAX_SAFE_INTEGER3;
        }
        var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
        function isString(value) {
          return typeof value == "string" || !isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag;
        }
        function isSymbol(value) {
          return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
        }
        var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
        function isUndefined(value) {
          return value === undefined2;
        }
        function isWeakMap(value) {
          return isObjectLike(value) && getTag(value) == weakMapTag;
        }
        function isWeakSet(value) {
          return isObjectLike(value) && baseGetTag(value) == weakSetTag;
        }
        var lt = createRelationalOperation(baseLt);
        var lte2 = createRelationalOperation(function(value, other) {
          return value <= other;
        });
        function toArray(value) {
          if (!value) {
            return [];
          }
          if (isArrayLike(value)) {
            return isString(value) ? stringToArray(value) : copyArray(value);
          }
          if (symIterator && value[symIterator]) {
            return iteratorToArray(value[symIterator]());
          }
          var tag2 = getTag(value), func = tag2 == mapTag ? mapToArray : tag2 == setTag ? setToArray : values;
          return func(value);
        }
        function toFinite(value) {
          if (!value) {
            return value === 0 ? value : 0;
          }
          value = toNumber(value);
          if (value === INFINITY || value === -INFINITY) {
            var sign2 = value < 0 ? -1 : 1;
            return sign2 * MAX_INTEGER;
          }
          return value === value ? value : 0;
        }
        function toInteger(value) {
          var result2 = toFinite(value), remainder = result2 % 1;
          return result2 === result2 ? remainder ? result2 - remainder : result2 : 0;
        }
        function toLength(value) {
          return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
        }
        function toNumber(value) {
          if (typeof value == "number") {
            return value;
          }
          if (isSymbol(value)) {
            return NAN;
          }
          if (isObject(value)) {
            var other = typeof value.valueOf == "function" ? value.valueOf() : value;
            value = isObject(other) ? other + "" : other;
          }
          if (typeof value != "string") {
            return value === 0 ? value : +value;
          }
          value = baseTrim(value);
          var isBinary2 = reIsBinary.test(value);
          return isBinary2 || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary2 ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
        }
        function toPlainObject(value) {
          return copyObject(value, keysIn(value));
        }
        function toSafeInteger(value) {
          return value ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER3, MAX_SAFE_INTEGER3) : value === 0 ? value : 0;
        }
        function toString(value) {
          return value == null ? "" : baseToString(value);
        }
        var assign = createAssigner(function(object, source) {
          if (isPrototype(source) || isArrayLike(source)) {
            copyObject(source, keys(source), object);
            return;
          }
          for (var key in source) {
            if (hasOwnProperty.call(source, key)) {
              assignValue(object, key, source[key]);
            }
          }
        });
        var assignIn = createAssigner(function(object, source) {
          copyObject(source, keysIn(source), object);
        });
        var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
          copyObject(source, keysIn(source), object, customizer);
        });
        var assignWith = createAssigner(function(object, source, srcIndex, customizer) {
          copyObject(source, keys(source), object, customizer);
        });
        var at = flatRest(baseAt);
        function create(prototype, properties) {
          var result2 = baseCreate(prototype);
          return properties == null ? result2 : baseAssign(result2, properties);
        }
        var defaults = baseRest(function(object, sources) {
          object = Object2(object);
          var index = -1;
          var length = sources.length;
          var guard = length > 2 ? sources[2] : undefined2;
          if (guard && isIterateeCall(sources[0], sources[1], guard)) {
            length = 1;
          }
          while (++index < length) {
            var source = sources[index];
            var props = keysIn(source);
            var propsIndex = -1;
            var propsLength = props.length;
            while (++propsIndex < propsLength) {
              var key = props[propsIndex];
              var value = object[key];
              if (value === undefined2 || eq2(value, objectProto[key]) && !hasOwnProperty.call(object, key)) {
                object[key] = source[key];
              }
            }
          }
          return object;
        });
        var defaultsDeep = baseRest(function(args) {
          args.push(undefined2, customDefaultsMerge);
          return apply(mergeWith, undefined2, args);
        });
        function findKey(object, predicate) {
          return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
        }
        function findLastKey(object, predicate) {
          return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
        }
        function forIn(object, iteratee2) {
          return object == null ? object : baseFor(object, getIteratee(iteratee2, 3), keysIn);
        }
        function forInRight(object, iteratee2) {
          return object == null ? object : baseForRight(object, getIteratee(iteratee2, 3), keysIn);
        }
        function forOwn(object, iteratee2) {
          return object && baseForOwn(object, getIteratee(iteratee2, 3));
        }
        function forOwnRight(object, iteratee2) {
          return object && baseForOwnRight(object, getIteratee(iteratee2, 3));
        }
        function functions(object) {
          return object == null ? [] : baseFunctions(object, keys(object));
        }
        function functionsIn(object) {
          return object == null ? [] : baseFunctions(object, keysIn(object));
        }
        function get(object, path, defaultValue) {
          var result2 = object == null ? undefined2 : baseGet(object, path);
          return result2 === undefined2 ? defaultValue : result2;
        }
        function has(object, path) {
          return object != null && hasPath(object, path, baseHas);
        }
        function hasIn(object, path) {
          return object != null && hasPath(object, path, baseHasIn);
        }
        var invert = createInverter(function(result2, value, key) {
          if (value != null && typeof value.toString != "function") {
            value = nativeObjectToString.call(value);
          }
          result2[value] = key;
        }, constant(identity));
        var invertBy = createInverter(function(result2, value, key) {
          if (value != null && typeof value.toString != "function") {
            value = nativeObjectToString.call(value);
          }
          if (hasOwnProperty.call(result2, value)) {
            result2[value].push(key);
          } else {
            result2[value] = [key];
          }
        }, getIteratee);
        var invoke = baseRest(baseInvoke);
        function keys(object) {
          return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
        }
        function keysIn(object) {
          return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
        }
        function mapKeys(object, iteratee2) {
          var result2 = {};
          iteratee2 = getIteratee(iteratee2, 3);
          baseForOwn(object, function(value, key, object2) {
            baseAssignValue(result2, iteratee2(value, key, object2), value);
          });
          return result2;
        }
        function mapValues(object, iteratee2) {
          var result2 = {};
          iteratee2 = getIteratee(iteratee2, 3);
          baseForOwn(object, function(value, key, object2) {
            baseAssignValue(result2, key, iteratee2(value, key, object2));
          });
          return result2;
        }
        var merge = createAssigner(function(object, source, srcIndex) {
          baseMerge(object, source, srcIndex);
        });
        var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
          baseMerge(object, source, srcIndex, customizer);
        });
        var omit = flatRest(function(object, paths) {
          var result2 = {};
          if (object == null) {
            return result2;
          }
          var isDeep = false;
          paths = arrayMap(paths, function(path) {
            path = castPath(path, object);
            isDeep || (isDeep = path.length > 1);
            return path;
          });
          copyObject(object, getAllKeysIn(object), result2);
          if (isDeep) {
            result2 = baseClone(result2, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
          }
          var length = paths.length;
          while (length--) {
            baseUnset(result2, paths[length]);
          }
          return result2;
        });
        function omitBy(object, predicate) {
          return pickBy(object, negate(getIteratee(predicate)));
        }
        var pick = flatRest(function(object, paths) {
          return object == null ? {} : basePick(object, paths);
        });
        function pickBy(object, predicate) {
          if (object == null) {
            return {};
          }
          var props = arrayMap(getAllKeysIn(object), function(prop) {
            return [prop];
          });
          predicate = getIteratee(predicate);
          return basePickBy(object, props, function(value, path) {
            return predicate(value, path[0]);
          });
        }
        function result(object, path, defaultValue) {
          path = castPath(path, object);
          var index = -1, length = path.length;
          if (!length) {
            length = 1;
            object = undefined2;
          }
          while (++index < length) {
            var value = object == null ? undefined2 : object[toKey(path[index])];
            if (value === undefined2) {
              index = length;
              value = defaultValue;
            }
            object = isFunction(value) ? value.call(object) : value;
          }
          return object;
        }
        function set(object, path, value) {
          return object == null ? object : baseSet(object, path, value);
        }
        function setWith(object, path, value, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return object == null ? object : baseSet(object, path, value, customizer);
        }
        var toPairs = createToPairs(keys);
        var toPairsIn = createToPairs(keysIn);
        function transform(object, iteratee2, accumulator) {
          var isArr = isArray(object), isArrLike = isArr || isBuffer(object) || isTypedArray(object);
          iteratee2 = getIteratee(iteratee2, 4);
          if (accumulator == null) {
            var Ctor = object && object.constructor;
            if (isArrLike) {
              accumulator = isArr ? new Ctor() : [];
            } else if (isObject(object)) {
              accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};
            } else {
              accumulator = {};
            }
          }
          (isArrLike ? arrayEach : baseForOwn)(object, function(value, index, object2) {
            return iteratee2(accumulator, value, index, object2);
          });
          return accumulator;
        }
        function unset(object, path) {
          return object == null ? true : baseUnset(object, path);
        }
        function update(object, path, updater) {
          return object == null ? object : baseUpdate(object, path, castFunction(updater));
        }
        function updateWith(object, path, updater, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);
        }
        function values(object) {
          return object == null ? [] : baseValues(object, keys(object));
        }
        function valuesIn(object) {
          return object == null ? [] : baseValues(object, keysIn(object));
        }
        function clamp2(number, lower, upper) {
          if (upper === undefined2) {
            upper = lower;
            lower = undefined2;
          }
          if (upper !== undefined2) {
            upper = toNumber(upper);
            upper = upper === upper ? upper : 0;
          }
          if (lower !== undefined2) {
            lower = toNumber(lower);
            lower = lower === lower ? lower : 0;
          }
          return baseClamp(toNumber(number), lower, upper);
        }
        function inRange(number, start, end) {
          start = toFinite(start);
          if (end === undefined2) {
            end = start;
            start = 0;
          } else {
            end = toFinite(end);
          }
          number = toNumber(number);
          return baseInRange(number, start, end);
        }
        function random2(lower, upper, floating) {
          if (floating && typeof floating != "boolean" && isIterateeCall(lower, upper, floating)) {
            upper = floating = undefined2;
          }
          if (floating === undefined2) {
            if (typeof upper == "boolean") {
              floating = upper;
              upper = undefined2;
            } else if (typeof lower == "boolean") {
              floating = lower;
              lower = undefined2;
            }
          }
          if (lower === undefined2 && upper === undefined2) {
            lower = 0;
            upper = 1;
          } else {
            lower = toFinite(lower);
            if (upper === undefined2) {
              upper = lower;
              lower = 0;
            } else {
              upper = toFinite(upper);
            }
          }
          if (lower > upper) {
            var temp = lower;
            lower = upper;
            upper = temp;
          }
          if (floating || lower % 1 || upper % 1) {
            var rand = nativeRandom();
            return nativeMin(lower + rand * (upper - lower + freeParseFloat("1e-" + ((rand + "").length - 1))), upper);
          }
          return baseRandom(lower, upper);
        }
        var camelCase = createCompounder(function(result2, word, index) {
          word = word.toLowerCase();
          return result2 + (index ? capitalize(word) : word);
        });
        function capitalize(string) {
          return upperFirst(toString(string).toLowerCase());
        }
        function deburr(string) {
          string = toString(string);
          return string && string.replace(reLatin, deburrLetter).replace(reComboMark, "");
        }
        function endsWith(string, target, position) {
          string = toString(string);
          target = baseToString(target);
          var length = string.length;
          position = position === undefined2 ? length : baseClamp(toInteger(position), 0, length);
          var end = position;
          position -= target.length;
          return position >= 0 && string.slice(position, end) == target;
        }
        function escape(string) {
          string = toString(string);
          return string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string;
        }
        function escapeRegExp(string) {
          string = toString(string);
          return string && reHasRegExpChar.test(string) ? string.replace(reRegExpChar, "\\$&") : string;
        }
        var kebabCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? "-" : "") + word.toLowerCase();
        });
        var lowerCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? " " : "") + word.toLowerCase();
        });
        var lowerFirst = createCaseFirst("toLowerCase");
        function pad(string, length, chars) {
          string = toString(string);
          length = toInteger(length);
          var strLength = length ? stringSize(string) : 0;
          if (!length || strLength >= length) {
            return string;
          }
          var mid = (length - strLength) / 2;
          return createPadding(nativeFloor(mid), chars) + string + createPadding(nativeCeil(mid), chars);
        }
        function padEnd(string, length, chars) {
          string = toString(string);
          length = toInteger(length);
          var strLength = length ? stringSize(string) : 0;
          return length && strLength < length ? string + createPadding(length - strLength, chars) : string;
        }
        function padStart(string, length, chars) {
          string = toString(string);
          length = toInteger(length);
          var strLength = length ? stringSize(string) : 0;
          return length && strLength < length ? createPadding(length - strLength, chars) + string : string;
        }
        function parseInt2(string, radix, guard) {
          if (guard || radix == null) {
            radix = 0;
          } else if (radix) {
            radix = +radix;
          }
          return nativeParseInt(toString(string).replace(reTrimStart, ""), radix || 0);
        }
        function repeat(string, n, guard) {
          if (guard ? isIterateeCall(string, n, guard) : n === undefined2) {
            n = 1;
          } else {
            n = toInteger(n);
          }
          return baseRepeat(toString(string), n);
        }
        function replace() {
          var args = arguments, string = toString(args[0]);
          return args.length < 3 ? string : string.replace(args[1], args[2]);
        }
        var snakeCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? "_" : "") + word.toLowerCase();
        });
        function split(string, separator, limit) {
          if (limit && typeof limit != "number" && isIterateeCall(string, separator, limit)) {
            separator = limit = undefined2;
          }
          limit = limit === undefined2 ? MAX_ARRAY_LENGTH : limit >>> 0;
          if (!limit) {
            return [];
          }
          string = toString(string);
          if (string && (typeof separator == "string" || separator != null && !isRegExp(separator))) {
            separator = baseToString(separator);
            if (!separator && hasUnicode(string)) {
              return castSlice(stringToArray(string), 0, limit);
            }
          }
          return string.split(separator, limit);
        }
        var startCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? " " : "") + upperFirst(word);
        });
        function startsWith(string, target, position) {
          string = toString(string);
          position = position == null ? 0 : baseClamp(toInteger(position), 0, string.length);
          target = baseToString(target);
          return string.slice(position, position + target.length) == target;
        }
        function template(string, options, guard) {
          var settings = lodash.templateSettings;
          if (guard && isIterateeCall(string, options, guard)) {
            options = undefined2;
          }
          string = toString(string);
          options = assignInWith({}, options, settings, customDefaultsAssignIn);
          var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn), importsKeys = keys(imports), importsValues = baseValues(imports, importsKeys);
          var isEscaping, isEvaluating, index = 0, interpolate = options.interpolate || reNoMatch, source = "__p += '";
          var reDelimiters = RegExp2(
            (options.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options.evaluate || reNoMatch).source + "|$",
            "g"
          );
          var sourceURL = "//# sourceURL=" + (hasOwnProperty.call(options, "sourceURL") ? (options.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++templateCounter + "]") + "\n";
          string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset2) {
            interpolateValue || (interpolateValue = esTemplateValue);
            source += string.slice(index, offset2).replace(reUnescapedString, escapeStringChar);
            if (escapeValue) {
              isEscaping = true;
              source += "' +\n__e(" + escapeValue + ") +\n'";
            }
            if (evaluateValue) {
              isEvaluating = true;
              source += "';\n" + evaluateValue + ";\n__p += '";
            }
            if (interpolateValue) {
              source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
            }
            index = offset2 + match.length;
            return match;
          });
          source += "';\n";
          var variable = hasOwnProperty.call(options, "variable") && options.variable;
          if (!variable) {
            source = "with (obj) {\n" + source + "\n}\n";
          } else if (reForbiddenIdentifierChars.test(variable)) {
            throw new Error2(INVALID_TEMPL_VAR_ERROR_TEXT);
          }
          source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");
          source = "function(" + (variable || "obj") + ") {\n" + (variable ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + source + "return __p\n}";
          var result2 = attempt(function() {
            return Function2(importsKeys, sourceURL + "return " + source).apply(undefined2, importsValues);
          });
          result2.source = source;
          if (isError(result2)) {
            throw result2;
          }
          return result2;
        }
        function toLower(value) {
          return toString(value).toLowerCase();
        }
        function toUpper(value) {
          return toString(value).toUpperCase();
        }
        function trim(string, chars, guard) {
          string = toString(string);
          if (string && (guard || chars === undefined2)) {
            return baseTrim(string);
          }
          if (!string || !(chars = baseToString(chars))) {
            return string;
          }
          var strSymbols = stringToArray(string), chrSymbols = stringToArray(chars), start = charsStartIndex(strSymbols, chrSymbols), end = charsEndIndex(strSymbols, chrSymbols) + 1;
          return castSlice(strSymbols, start, end).join("");
        }
        function trimEnd(string, chars, guard) {
          string = toString(string);
          if (string && (guard || chars === undefined2)) {
            return string.slice(0, trimmedEndIndex(string) + 1);
          }
          if (!string || !(chars = baseToString(chars))) {
            return string;
          }
          var strSymbols = stringToArray(string), end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;
          return castSlice(strSymbols, 0, end).join("");
        }
        function trimStart(string, chars, guard) {
          string = toString(string);
          if (string && (guard || chars === undefined2)) {
            return string.replace(reTrimStart, "");
          }
          if (!string || !(chars = baseToString(chars))) {
            return string;
          }
          var strSymbols = stringToArray(string), start = charsStartIndex(strSymbols, stringToArray(chars));
          return castSlice(strSymbols, start).join("");
        }
        function truncate2(string, options) {
          var length = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;
          if (isObject(options)) {
            var separator = "separator" in options ? options.separator : separator;
            length = "length" in options ? toInteger(options.length) : length;
            omission = "omission" in options ? baseToString(options.omission) : omission;
          }
          string = toString(string);
          var strLength = string.length;
          if (hasUnicode(string)) {
            var strSymbols = stringToArray(string);
            strLength = strSymbols.length;
          }
          if (length >= strLength) {
            return string;
          }
          var end = length - stringSize(omission);
          if (end < 1) {
            return omission;
          }
          var result2 = strSymbols ? castSlice(strSymbols, 0, end).join("") : string.slice(0, end);
          if (separator === undefined2) {
            return result2 + omission;
          }
          if (strSymbols) {
            end += result2.length - end;
          }
          if (isRegExp(separator)) {
            if (string.slice(end).search(separator)) {
              var match, substring = result2;
              if (!separator.global) {
                separator = RegExp2(separator.source, toString(reFlags.exec(separator)) + "g");
              }
              separator.lastIndex = 0;
              while (match = separator.exec(substring)) {
                var newEnd = match.index;
              }
              result2 = result2.slice(0, newEnd === undefined2 ? end : newEnd);
            }
          } else if (string.indexOf(baseToString(separator), end) != end) {
            var index = result2.lastIndexOf(separator);
            if (index > -1) {
              result2 = result2.slice(0, index);
            }
          }
          return result2 + omission;
        }
        function unescape2(string) {
          string = toString(string);
          return string && reHasEscapedHtml.test(string) ? string.replace(reEscapedHtml, unescapeHtmlChar) : string;
        }
        var upperCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? " " : "") + word.toUpperCase();
        });
        var upperFirst = createCaseFirst("toUpperCase");
        function words(string, pattern, guard) {
          string = toString(string);
          pattern = guard ? undefined2 : pattern;
          if (pattern === undefined2) {
            return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
          }
          return string.match(pattern) || [];
        }
        var attempt = baseRest(function(func, args) {
          try {
            return apply(func, undefined2, args);
          } catch (e) {
            return isError(e) ? e : new Error2(e);
          }
        });
        var bindAll = flatRest(function(object, methodNames) {
          arrayEach(methodNames, function(key) {
            key = toKey(key);
            baseAssignValue(object, key, bind(object[key], object));
          });
          return object;
        });
        function cond(pairs) {
          var length = pairs == null ? 0 : pairs.length, toIteratee = getIteratee();
          pairs = !length ? [] : arrayMap(pairs, function(pair) {
            if (typeof pair[1] != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            return [toIteratee(pair[0]), pair[1]];
          });
          return baseRest(function(args) {
            var index = -1;
            while (++index < length) {
              var pair = pairs[index];
              if (apply(pair[0], this, args)) {
                return apply(pair[1], this, args);
              }
            }
          });
        }
        function conforms(source) {
          return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
        }
        function constant(value) {
          return function() {
            return value;
          };
        }
        function defaultTo(value, defaultValue) {
          return value == null || value !== value ? defaultValue : value;
        }
        var flow = createFlow();
        var flowRight = createFlow(true);
        function identity(value) {
          return value;
        }
        function iteratee(func) {
          return baseIteratee(typeof func == "function" ? func : baseClone(func, CLONE_DEEP_FLAG));
        }
        function matches(source) {
          return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
        }
        function matchesProperty(path, srcValue) {
          return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));
        }
        var method = baseRest(function(path, args) {
          return function(object) {
            return baseInvoke(object, path, args);
          };
        });
        var methodOf = baseRest(function(object, args) {
          return function(path) {
            return baseInvoke(object, path, args);
          };
        });
        function mixin(object, source, options) {
          var props = keys(source), methodNames = baseFunctions(source, props);
          if (options == null && !(isObject(source) && (methodNames.length || !props.length))) {
            options = source;
            source = object;
            object = this;
            methodNames = baseFunctions(source, keys(source));
          }
          var chain2 = !(isObject(options) && "chain" in options) || !!options.chain, isFunc = isFunction(object);
          arrayEach(methodNames, function(methodName) {
            var func = source[methodName];
            object[methodName] = func;
            if (isFunc) {
              object.prototype[methodName] = function() {
                var chainAll = this.__chain__;
                if (chain2 || chainAll) {
                  var result2 = object(this.__wrapped__), actions = result2.__actions__ = copyArray(this.__actions__);
                  actions.push({ "func": func, "args": arguments, "thisArg": object });
                  result2.__chain__ = chainAll;
                  return result2;
                }
                return func.apply(object, arrayPush([this.value()], arguments));
              };
            }
          });
          return object;
        }
        function noConflict() {
          if (root._ === this) {
            root._ = oldDash;
          }
          return this;
        }
        function noop() {
        }
        function nthArg(n) {
          n = toInteger(n);
          return baseRest(function(args) {
            return baseNth(args, n);
          });
        }
        var over = createOver(arrayMap);
        var overEvery = createOver(arrayEvery);
        var overSome = createOver(arraySome);
        function property(path) {
          return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
        }
        function propertyOf(object) {
          return function(path) {
            return object == null ? undefined2 : baseGet(object, path);
          };
        }
        var range = createRange();
        var rangeRight = createRange(true);
        function stubArray() {
          return [];
        }
        function stubFalse() {
          return false;
        }
        function stubObject() {
          return {};
        }
        function stubString() {
          return "";
        }
        function stubTrue() {
          return true;
        }
        function times(n, iteratee2) {
          n = toInteger(n);
          if (n < 1 || n > MAX_SAFE_INTEGER3) {
            return [];
          }
          var index = MAX_ARRAY_LENGTH, length = nativeMin(n, MAX_ARRAY_LENGTH);
          iteratee2 = getIteratee(iteratee2);
          n -= MAX_ARRAY_LENGTH;
          var result2 = baseTimes(length, iteratee2);
          while (++index < n) {
            iteratee2(index);
          }
          return result2;
        }
        function toPath(value) {
          if (isArray(value)) {
            return arrayMap(value, toKey);
          }
          return isSymbol(value) ? [value] : copyArray(stringToPath(toString(value)));
        }
        function uniqueId(prefix) {
          var id = ++idCounter;
          return toString(prefix) + id;
        }
        var add3 = createMathOperation(function(augend, addend) {
          return augend + addend;
        }, 0);
        var ceil2 = createRound("ceil");
        var divide2 = createMathOperation(function(dividend, divisor) {
          return dividend / divisor;
        }, 1);
        var floor2 = createRound("floor");
        function max2(array2) {
          return array2 && array2.length ? baseExtremum(array2, identity, baseGt) : undefined2;
        }
        function maxBy(array2, iteratee2) {
          return array2 && array2.length ? baseExtremum(array2, getIteratee(iteratee2, 2), baseGt) : undefined2;
        }
        function mean(array2) {
          return baseMean(array2, identity);
        }
        function meanBy(array2, iteratee2) {
          return baseMean(array2, getIteratee(iteratee2, 2));
        }
        function min2(array2) {
          return array2 && array2.length ? baseExtremum(array2, identity, baseLt) : undefined2;
        }
        function minBy(array2, iteratee2) {
          return array2 && array2.length ? baseExtremum(array2, getIteratee(iteratee2, 2), baseLt) : undefined2;
        }
        var multiply = createMathOperation(function(multiplier, multiplicand) {
          return multiplier * multiplicand;
        }, 1);
        var round2 = createRound("round");
        var subtract = createMathOperation(function(minuend, subtrahend) {
          return minuend - subtrahend;
        }, 0);
        function sum2(array2) {
          return array2 && array2.length ? baseSum(array2, identity) : 0;
        }
        function sumBy(array2, iteratee2) {
          return array2 && array2.length ? baseSum(array2, getIteratee(iteratee2, 2)) : 0;
        }
        lodash.after = after;
        lodash.ary = ary;
        lodash.assign = assign;
        lodash.assignIn = assignIn;
        lodash.assignInWith = assignInWith;
        lodash.assignWith = assignWith;
        lodash.at = at;
        lodash.before = before;
        lodash.bind = bind;
        lodash.bindAll = bindAll;
        lodash.bindKey = bindKey;
        lodash.castArray = castArray;
        lodash.chain = chain;
        lodash.chunk = chunk;
        lodash.compact = compact;
        lodash.concat = concat;
        lodash.cond = cond;
        lodash.conforms = conforms;
        lodash.constant = constant;
        lodash.countBy = countBy;
        lodash.create = create;
        lodash.curry = curry;
        lodash.curryRight = curryRight;
        lodash.debounce = debounce;
        lodash.defaults = defaults;
        lodash.defaultsDeep = defaultsDeep;
        lodash.defer = defer;
        lodash.delay = delay;
        lodash.difference = difference;
        lodash.differenceBy = differenceBy;
        lodash.differenceWith = differenceWith;
        lodash.drop = drop;
        lodash.dropRight = dropRight;
        lodash.dropRightWhile = dropRightWhile;
        lodash.dropWhile = dropWhile;
        lodash.fill = fill;
        lodash.filter = filter;
        lodash.flatMap = flatMap;
        lodash.flatMapDeep = flatMapDeep;
        lodash.flatMapDepth = flatMapDepth;
        lodash.flatten = flatten;
        lodash.flattenDeep = flattenDeep;
        lodash.flattenDepth = flattenDepth;
        lodash.flip = flip;
        lodash.flow = flow;
        lodash.flowRight = flowRight;
        lodash.fromPairs = fromPairs;
        lodash.functions = functions;
        lodash.functionsIn = functionsIn;
        lodash.groupBy = groupBy;
        lodash.initial = initial;
        lodash.intersection = intersection2;
        lodash.intersectionBy = intersectionBy;
        lodash.intersectionWith = intersectionWith;
        lodash.invert = invert;
        lodash.invertBy = invertBy;
        lodash.invokeMap = invokeMap;
        lodash.iteratee = iteratee;
        lodash.keyBy = keyBy;
        lodash.keys = keys;
        lodash.keysIn = keysIn;
        lodash.map = map;
        lodash.mapKeys = mapKeys;
        lodash.mapValues = mapValues;
        lodash.matches = matches;
        lodash.matchesProperty = matchesProperty;
        lodash.memoize = memoize;
        lodash.merge = merge;
        lodash.mergeWith = mergeWith;
        lodash.method = method;
        lodash.methodOf = methodOf;
        lodash.mixin = mixin;
        lodash.negate = negate;
        lodash.nthArg = nthArg;
        lodash.omit = omit;
        lodash.omitBy = omitBy;
        lodash.once = once;
        lodash.orderBy = orderBy;
        lodash.over = over;
        lodash.overArgs = overArgs;
        lodash.overEvery = overEvery;
        lodash.overSome = overSome;
        lodash.partial = partial;
        lodash.partialRight = partialRight;
        lodash.partition = partition;
        lodash.pick = pick;
        lodash.pickBy = pickBy;
        lodash.property = property;
        lodash.propertyOf = propertyOf;
        lodash.pull = pull;
        lodash.pullAll = pullAll;
        lodash.pullAllBy = pullAllBy;
        lodash.pullAllWith = pullAllWith;
        lodash.pullAt = pullAt;
        lodash.range = range;
        lodash.rangeRight = rangeRight;
        lodash.rearg = rearg;
        lodash.reject = reject;
        lodash.remove = remove;
        lodash.rest = rest;
        lodash.reverse = reverse;
        lodash.sampleSize = sampleSize;
        lodash.set = set;
        lodash.setWith = setWith;
        lodash.shuffle = shuffle;
        lodash.slice = slice;
        lodash.sortBy = sortBy;
        lodash.sortedUniq = sortedUniq;
        lodash.sortedUniqBy = sortedUniqBy;
        lodash.split = split;
        lodash.spread = spread;
        lodash.tail = tail;
        lodash.take = take;
        lodash.takeRight = takeRight;
        lodash.takeRightWhile = takeRightWhile;
        lodash.takeWhile = takeWhile;
        lodash.tap = tap;
        lodash.throttle = throttle;
        lodash.thru = thru;
        lodash.toArray = toArray;
        lodash.toPairs = toPairs;
        lodash.toPairsIn = toPairsIn;
        lodash.toPath = toPath;
        lodash.toPlainObject = toPlainObject;
        lodash.transform = transform;
        lodash.unary = unary;
        lodash.union = union2;
        lodash.unionBy = unionBy;
        lodash.unionWith = unionWith;
        lodash.uniq = uniq2;
        lodash.uniqBy = uniqBy;
        lodash.uniqWith = uniqWith;
        lodash.unset = unset;
        lodash.unzip = unzip;
        lodash.unzipWith = unzipWith;
        lodash.update = update;
        lodash.updateWith = updateWith;
        lodash.values = values;
        lodash.valuesIn = valuesIn;
        lodash.without = without;
        lodash.words = words;
        lodash.wrap = wrap;
        lodash.xor = xor2;
        lodash.xorBy = xorBy;
        lodash.xorWith = xorWith;
        lodash.zip = zip;
        lodash.zipObject = zipObject;
        lodash.zipObjectDeep = zipObjectDeep;
        lodash.zipWith = zipWith;
        lodash.entries = toPairs;
        lodash.entriesIn = toPairsIn;
        lodash.extend = assignIn;
        lodash.extendWith = assignInWith;
        mixin(lodash, lodash);
        lodash.add = add3;
        lodash.attempt = attempt;
        lodash.camelCase = camelCase;
        lodash.capitalize = capitalize;
        lodash.ceil = ceil2;
        lodash.clamp = clamp2;
        lodash.clone = clone3;
        lodash.cloneDeep = cloneDeep;
        lodash.cloneDeepWith = cloneDeepWith;
        lodash.cloneWith = cloneWith;
        lodash.conformsTo = conformsTo;
        lodash.deburr = deburr;
        lodash.defaultTo = defaultTo;
        lodash.divide = divide2;
        lodash.endsWith = endsWith;
        lodash.eq = eq2;
        lodash.escape = escape;
        lodash.escapeRegExp = escapeRegExp;
        lodash.every = every;
        lodash.find = find;
        lodash.findIndex = findIndex;
        lodash.findKey = findKey;
        lodash.findLast = findLast;
        lodash.findLastIndex = findLastIndex;
        lodash.findLastKey = findLastKey;
        lodash.floor = floor2;
        lodash.forEach = forEach;
        lodash.forEachRight = forEachRight;
        lodash.forIn = forIn;
        lodash.forInRight = forInRight;
        lodash.forOwn = forOwn;
        lodash.forOwnRight = forOwnRight;
        lodash.get = get;
        lodash.gt = gt;
        lodash.gte = gte2;
        lodash.has = has;
        lodash.hasIn = hasIn;
        lodash.head = head;
        lodash.identity = identity;
        lodash.includes = includes;
        lodash.indexOf = indexOf;
        lodash.inRange = inRange;
        lodash.invoke = invoke;
        lodash.isArguments = isArguments;
        lodash.isArray = isArray;
        lodash.isArrayBuffer = isArrayBuffer;
        lodash.isArrayLike = isArrayLike;
        lodash.isArrayLikeObject = isArrayLikeObject;
        lodash.isBoolean = isBoolean;
        lodash.isBuffer = isBuffer;
        lodash.isDate = isDate;
        lodash.isElement = isElement;
        lodash.isEmpty = isEmpty;
        lodash.isEqual = isEqual;
        lodash.isEqualWith = isEqualWith;
        lodash.isError = isError;
        lodash.isFinite = isFinite2;
        lodash.isFunction = isFunction;
        lodash.isInteger = isInteger;
        lodash.isLength = isLength;
        lodash.isMap = isMap;
        lodash.isMatch = isMatch;
        lodash.isMatchWith = isMatchWith;
        lodash.isNaN = isNaN2;
        lodash.isNative = isNative;
        lodash.isNil = isNil;
        lodash.isNull = isNull;
        lodash.isNumber = isNumber2;
        lodash.isObject = isObject;
        lodash.isObjectLike = isObjectLike;
        lodash.isPlainObject = isPlainObject;
        lodash.isRegExp = isRegExp;
        lodash.isSafeInteger = isSafeInteger;
        lodash.isSet = isSet;
        lodash.isString = isString;
        lodash.isSymbol = isSymbol;
        lodash.isTypedArray = isTypedArray;
        lodash.isUndefined = isUndefined;
        lodash.isWeakMap = isWeakMap;
        lodash.isWeakSet = isWeakSet;
        lodash.join = join;
        lodash.kebabCase = kebabCase;
        lodash.last = last;
        lodash.lastIndexOf = lastIndexOf;
        lodash.lowerCase = lowerCase;
        lodash.lowerFirst = lowerFirst;
        lodash.lt = lt;
        lodash.lte = lte2;
        lodash.max = max2;
        lodash.maxBy = maxBy;
        lodash.mean = mean;
        lodash.meanBy = meanBy;
        lodash.min = min2;
        lodash.minBy = minBy;
        lodash.stubArray = stubArray;
        lodash.stubFalse = stubFalse;
        lodash.stubObject = stubObject;
        lodash.stubString = stubString;
        lodash.stubTrue = stubTrue;
        lodash.multiply = multiply;
        lodash.nth = nth;
        lodash.noConflict = noConflict;
        lodash.noop = noop;
        lodash.now = now;
        lodash.pad = pad;
        lodash.padEnd = padEnd;
        lodash.padStart = padStart;
        lodash.parseInt = parseInt2;
        lodash.random = random2;
        lodash.reduce = reduce;
        lodash.reduceRight = reduceRight;
        lodash.repeat = repeat;
        lodash.replace = replace;
        lodash.result = result;
        lodash.round = round2;
        lodash.runInContext = runInContext2;
        lodash.sample = sample;
        lodash.size = size;
        lodash.snakeCase = snakeCase;
        lodash.some = some;
        lodash.sortedIndex = sortedIndex;
        lodash.sortedIndexBy = sortedIndexBy;
        lodash.sortedIndexOf = sortedIndexOf;
        lodash.sortedLastIndex = sortedLastIndex;
        lodash.sortedLastIndexBy = sortedLastIndexBy;
        lodash.sortedLastIndexOf = sortedLastIndexOf;
        lodash.startCase = startCase;
        lodash.startsWith = startsWith;
        lodash.subtract = subtract;
        lodash.sum = sum2;
        lodash.sumBy = sumBy;
        lodash.template = template;
        lodash.times = times;
        lodash.toFinite = toFinite;
        lodash.toInteger = toInteger;
        lodash.toLength = toLength;
        lodash.toLower = toLower;
        lodash.toNumber = toNumber;
        lodash.toSafeInteger = toSafeInteger;
        lodash.toString = toString;
        lodash.toUpper = toUpper;
        lodash.trim = trim;
        lodash.trimEnd = trimEnd;
        lodash.trimStart = trimStart;
        lodash.truncate = truncate2;
        lodash.unescape = unescape2;
        lodash.uniqueId = uniqueId;
        lodash.upperCase = upperCase;
        lodash.upperFirst = upperFirst;
        lodash.each = forEach;
        lodash.eachRight = forEachRight;
        lodash.first = head;
        mixin(lodash, function() {
          var source = {};
          baseForOwn(lodash, function(func, methodName) {
            if (!hasOwnProperty.call(lodash.prototype, methodName)) {
              source[methodName] = func;
            }
          });
          return source;
        }(), { "chain": false });
        lodash.VERSION = VERSION;
        arrayEach(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(methodName) {
          lodash[methodName].placeholder = lodash;
        });
        arrayEach(["drop", "take"], function(methodName, index) {
          LazyWrapper.prototype[methodName] = function(n) {
            n = n === undefined2 ? 1 : nativeMax(toInteger(n), 0);
            var result2 = this.__filtered__ && !index ? new LazyWrapper(this) : this.clone();
            if (result2.__filtered__) {
              result2.__takeCount__ = nativeMin(n, result2.__takeCount__);
            } else {
              result2.__views__.push({
                "size": nativeMin(n, MAX_ARRAY_LENGTH),
                "type": methodName + (result2.__dir__ < 0 ? "Right" : "")
              });
            }
            return result2;
          };
          LazyWrapper.prototype[methodName + "Right"] = function(n) {
            return this.reverse()[methodName](n).reverse();
          };
        });
        arrayEach(["filter", "map", "takeWhile"], function(methodName, index) {
          var type = index + 1, isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;
          LazyWrapper.prototype[methodName] = function(iteratee2) {
            var result2 = this.clone();
            result2.__iteratees__.push({
              "iteratee": getIteratee(iteratee2, 3),
              "type": type
            });
            result2.__filtered__ = result2.__filtered__ || isFilter;
            return result2;
          };
        });
        arrayEach(["head", "last"], function(methodName, index) {
          var takeName = "take" + (index ? "Right" : "");
          LazyWrapper.prototype[methodName] = function() {
            return this[takeName](1).value()[0];
          };
        });
        arrayEach(["initial", "tail"], function(methodName, index) {
          var dropName = "drop" + (index ? "" : "Right");
          LazyWrapper.prototype[methodName] = function() {
            return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
          };
        });
        LazyWrapper.prototype.compact = function() {
          return this.filter(identity);
        };
        LazyWrapper.prototype.find = function(predicate) {
          return this.filter(predicate).head();
        };
        LazyWrapper.prototype.findLast = function(predicate) {
          return this.reverse().find(predicate);
        };
        LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {
          if (typeof path == "function") {
            return new LazyWrapper(this);
          }
          return this.map(function(value) {
            return baseInvoke(value, path, args);
          });
        });
        LazyWrapper.prototype.reject = function(predicate) {
          return this.filter(negate(getIteratee(predicate)));
        };
        LazyWrapper.prototype.slice = function(start, end) {
          start = toInteger(start);
          var result2 = this;
          if (result2.__filtered__ && (start > 0 || end < 0)) {
            return new LazyWrapper(result2);
          }
          if (start < 0) {
            result2 = result2.takeRight(-start);
          } else if (start) {
            result2 = result2.drop(start);
          }
          if (end !== undefined2) {
            end = toInteger(end);
            result2 = end < 0 ? result2.dropRight(-end) : result2.take(end - start);
          }
          return result2;
        };
        LazyWrapper.prototype.takeRightWhile = function(predicate) {
          return this.reverse().takeWhile(predicate).reverse();
        };
        LazyWrapper.prototype.toArray = function() {
          return this.take(MAX_ARRAY_LENGTH);
        };
        baseForOwn(LazyWrapper.prototype, function(func, methodName) {
          var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName), isTaker = /^(?:head|last)$/.test(methodName), lodashFunc = lodash[isTaker ? "take" + (methodName == "last" ? "Right" : "") : methodName], retUnwrapped = isTaker || /^find/.test(methodName);
          if (!lodashFunc) {
            return;
          }
          lodash.prototype[methodName] = function() {
            var value = this.__wrapped__, args = isTaker ? [1] : arguments, isLazy = value instanceof LazyWrapper, iteratee2 = args[0], useLazy = isLazy || isArray(value);
            var interceptor = function(value2) {
              var result3 = lodashFunc.apply(lodash, arrayPush([value2], args));
              return isTaker && chainAll ? result3[0] : result3;
            };
            if (useLazy && checkIteratee && typeof iteratee2 == "function" && iteratee2.length != 1) {
              isLazy = useLazy = false;
            }
            var chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isUnwrapped = retUnwrapped && !chainAll, onlyLazy = isLazy && !isHybrid;
            if (!retUnwrapped && useLazy) {
              value = onlyLazy ? value : new LazyWrapper(this);
              var result2 = func.apply(value, args);
              result2.__actions__.push({ "func": thru, "args": [interceptor], "thisArg": undefined2 });
              return new LodashWrapper(result2, chainAll);
            }
            if (isUnwrapped && onlyLazy) {
              return func.apply(this, args);
            }
            result2 = this.thru(interceptor);
            return isUnwrapped ? isTaker ? result2.value()[0] : result2.value() : result2;
          };
        });
        arrayEach(["pop", "push", "shift", "sort", "splice", "unshift"], function(methodName) {
          var func = arrayProto[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? "tap" : "thru", retUnwrapped = /^(?:pop|shift)$/.test(methodName);
          lodash.prototype[methodName] = function() {
            var args = arguments;
            if (retUnwrapped && !this.__chain__) {
              var value = this.value();
              return func.apply(isArray(value) ? value : [], args);
            }
            return this[chainName](function(value2) {
              return func.apply(isArray(value2) ? value2 : [], args);
            });
          };
        });
        baseForOwn(LazyWrapper.prototype, function(func, methodName) {
          var lodashFunc = lodash[methodName];
          if (lodashFunc) {
            var key = lodashFunc.name + "";
            if (!hasOwnProperty.call(realNames, key)) {
              realNames[key] = [];
            }
            realNames[key].push({ "name": methodName, "func": lodashFunc });
          }
        });
        realNames[createHybrid(undefined2, WRAP_BIND_KEY_FLAG).name] = [{
          "name": "wrapper",
          "func": undefined2
        }];
        LazyWrapper.prototype.clone = lazyClone;
        LazyWrapper.prototype.reverse = lazyReverse;
        LazyWrapper.prototype.value = lazyValue;
        lodash.prototype.at = wrapperAt;
        lodash.prototype.chain = wrapperChain;
        lodash.prototype.commit = wrapperCommit;
        lodash.prototype.next = wrapperNext;
        lodash.prototype.plant = wrapperPlant;
        lodash.prototype.reverse = wrapperReverse;
        lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;
        lodash.prototype.first = lodash.prototype.head;
        if (symIterator) {
          lodash.prototype[symIterator] = wrapperToIterator;
        }
        return lodash;
      };
      var _ = runInContext();
      if (typeof define == "function" && typeof define.amd == "object" && define.amd) {
        root._ = _;
        define(function() {
          return _;
        });
      } else if (freeModule) {
        (freeModule.exports = _)._ = _;
        freeExports._ = _;
      } else {
        root._ = _;
      }
    }).call(exports2);
  }
});

// node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/constants.js
var require_constants = __commonJS({
  "node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/constants.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.NATIVE_MINT_2022 = exports2.NATIVE_MINT = exports2.ASSOCIATED_TOKEN_PROGRAM_ID = exports2.TOKEN_2022_PROGRAM_ID = exports2.TOKEN_PROGRAM_ID = void 0;
    exports2.programSupportsExtensions = programSupportsExtensions;
    var web3_js_1 = require("@solana/web3.js");
    exports2.TOKEN_PROGRAM_ID = new web3_js_1.PublicKey("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA");
    exports2.TOKEN_2022_PROGRAM_ID = new web3_js_1.PublicKey("TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb");
    exports2.ASSOCIATED_TOKEN_PROGRAM_ID = new web3_js_1.PublicKey("ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL");
    exports2.NATIVE_MINT = new web3_js_1.PublicKey("So11111111111111111111111111111111111111112");
    exports2.NATIVE_MINT_2022 = new web3_js_1.PublicKey("9pan9bMn5HatX4EJdBwg9VgCa7Uz5HL8N1m5D3NdXejP");
    function programSupportsExtensions(programId) {
      if (programId.equals(exports2.TOKEN_PROGRAM_ID)) {
        return false;
      } else {
        return true;
      }
    }
  }
});

// node_modules/@solana/buffer-layout/lib/Layout.js
var require_Layout = __commonJS({
  "node_modules/@solana/buffer-layout/lib/Layout.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.s16 = exports2.s8 = exports2.nu64be = exports2.u48be = exports2.u40be = exports2.u32be = exports2.u24be = exports2.u16be = exports2.nu64 = exports2.u48 = exports2.u40 = exports2.u32 = exports2.u24 = exports2.u16 = exports2.u8 = exports2.offset = exports2.greedy = exports2.Constant = exports2.UTF8 = exports2.CString = exports2.Blob = exports2.Boolean = exports2.BitField = exports2.BitStructure = exports2.VariantLayout = exports2.Union = exports2.UnionLayoutDiscriminator = exports2.UnionDiscriminator = exports2.Structure = exports2.Sequence = exports2.DoubleBE = exports2.Double = exports2.FloatBE = exports2.Float = exports2.NearInt64BE = exports2.NearInt64 = exports2.NearUInt64BE = exports2.NearUInt64 = exports2.IntBE = exports2.Int = exports2.UIntBE = exports2.UInt = exports2.OffsetLayout = exports2.GreedyCount = exports2.ExternalLayout = exports2.bindConstructorLayout = exports2.nameWithProperty = exports2.Layout = exports2.uint8ArrayToBuffer = exports2.checkUint8Array = void 0;
    exports2.constant = exports2.utf8 = exports2.cstr = exports2.blob = exports2.unionLayoutDiscriminator = exports2.union = exports2.seq = exports2.bits = exports2.struct = exports2.f64be = exports2.f64 = exports2.f32be = exports2.f32 = exports2.ns64be = exports2.s48be = exports2.s40be = exports2.s32be = exports2.s24be = exports2.s16be = exports2.ns64 = exports2.s48 = exports2.s40 = exports2.s32 = exports2.s24 = void 0;
    var buffer_1 = require("buffer");
    function checkUint8Array(b) {
      if (!(b instanceof Uint8Array)) {
        throw new TypeError("b must be a Uint8Array");
      }
    }
    exports2.checkUint8Array = checkUint8Array;
    function uint8ArrayToBuffer(b) {
      checkUint8Array(b);
      return buffer_1.Buffer.from(b.buffer, b.byteOffset, b.length);
    }
    exports2.uint8ArrayToBuffer = uint8ArrayToBuffer;
    var Layout2 = class {
      constructor(span, property) {
        if (!Number.isInteger(span)) {
          throw new TypeError("span must be an integer");
        }
        this.span = span;
        this.property = property;
      }
      /** Function to create an Object into which decoded properties will
       * be written.
       *
       * Used only for layouts that {@link Layout#decode|decode} to Object
       * instances, which means:
       * * {@link Structure}
       * * {@link Union}
       * * {@link VariantLayout}
       * * {@link BitStructure}
       *
       * If left undefined the JavaScript representation of these layouts
       * will be Object instances.
       *
       * See {@link bindConstructorLayout}.
       */
      makeDestinationObject() {
        return {};
      }
      /**
       * Calculate the span of a specific instance of a layout.
       *
       * @param {Uint8Array} b - the buffer that contains an encoded instance.
       *
       * @param {Number} [offset] - the offset at which the encoded instance
       * starts.  If absent a zero offset is inferred.
       *
       * @return {Number} - the number of bytes covered by the layout
       * instance.  If this method is not overridden in a subclass the
       * definition-time constant {@link Layout#span|span} will be
       * returned.
       *
       * @throws {RangeError} - if the length of the value cannot be
       * determined.
       */
      getSpan(b, offset2) {
        if (0 > this.span) {
          throw new RangeError("indeterminate span");
        }
        return this.span;
      }
      /**
       * Replicate the layout using a new property.
       *
       * This function must be used to get a structurally-equivalent layout
       * with a different name since all {@link Layout} instances are
       * immutable.
       *
       * **NOTE** This is a shallow copy.  All fields except {@link
       * Layout#property|property} are strictly equal to the origin layout.
       *
       * @param {String} property - the value for {@link
       * Layout#property|property} in the replica.
       *
       * @returns {Layout} - the copy with {@link Layout#property|property}
       * set to `property`.
       */
      replicate(property) {
        const rv = Object.create(this.constructor.prototype);
        Object.assign(rv, this);
        rv.property = property;
        return rv;
      }
      /**
       * Create an object from layout properties and an array of values.
       *
       * **NOTE** This function returns `undefined` if invoked on a layout
       * that does not return its value as an Object.  Objects are
       * returned for things that are a {@link Structure}, which includes
       * {@link VariantLayout|variant layouts} if they are structures, and
       * excludes {@link Union}s.  If you want this feature for a union
       * you must use {@link Union.getVariant|getVariant} to select the
       * desired layout.
       *
       * @param {Array} values - an array of values that correspond to the
       * default order for properties.  As with {@link Layout#decode|decode}
       * layout elements that have no property name are skipped when
       * iterating over the array values.  Only the top-level properties are
       * assigned; arguments are not assigned to properties of contained
       * layouts.  Any unused values are ignored.
       *
       * @return {(Object|undefined)}
       */
      fromArray(values) {
        return void 0;
      }
    };
    exports2.Layout = Layout2;
    function nameWithProperty(name, lo) {
      if (lo.property) {
        return name + "[" + lo.property + "]";
      }
      return name;
    }
    exports2.nameWithProperty = nameWithProperty;
    function bindConstructorLayout(Class, layout) {
      if ("function" !== typeof Class) {
        throw new TypeError("Class must be constructor");
      }
      if (Object.prototype.hasOwnProperty.call(Class, "layout_")) {
        throw new Error("Class is already bound to a layout");
      }
      if (!(layout && layout instanceof Layout2)) {
        throw new TypeError("layout must be a Layout");
      }
      if (Object.prototype.hasOwnProperty.call(layout, "boundConstructor_")) {
        throw new Error("layout is already bound to a constructor");
      }
      Class.layout_ = layout;
      layout.boundConstructor_ = Class;
      layout.makeDestinationObject = () => new Class();
      Object.defineProperty(Class.prototype, "encode", {
        value(b, offset2) {
          return layout.encode(this, b, offset2);
        },
        writable: true
      });
      Object.defineProperty(Class, "decode", {
        value(b, offset2) {
          return layout.decode(b, offset2);
        },
        writable: true
      });
    }
    exports2.bindConstructorLayout = bindConstructorLayout;
    var ExternalLayout = class extends Layout2 {
      /**
       * Return `true` iff the external layout decodes to an unsigned
       * integer layout.
       *
       * In that case it can be used as the source of {@link
       * Sequence#count|Sequence counts}, {@link Blob#length|Blob lengths},
       * or as {@link UnionLayoutDiscriminator#layout|external union
       * discriminators}.
       *
       * @abstract
       */
      isCount() {
        throw new Error("ExternalLayout is abstract");
      }
    };
    exports2.ExternalLayout = ExternalLayout;
    var GreedyCount = class extends ExternalLayout {
      constructor(elementSpan = 1, property) {
        if (!Number.isInteger(elementSpan) || 0 >= elementSpan) {
          throw new TypeError("elementSpan must be a (positive) integer");
        }
        super(-1, property);
        this.elementSpan = elementSpan;
      }
      /** @override */
      isCount() {
        return true;
      }
      /** @override */
      decode(b, offset2 = 0) {
        checkUint8Array(b);
        const rem = b.length - offset2;
        return Math.floor(rem / this.elementSpan);
      }
      /** @override */
      encode(src, b, offset2) {
        return 0;
      }
    };
    exports2.GreedyCount = GreedyCount;
    var OffsetLayout = class extends ExternalLayout {
      constructor(layout, offset2 = 0, property) {
        if (!(layout instanceof Layout2)) {
          throw new TypeError("layout must be a Layout");
        }
        if (!Number.isInteger(offset2)) {
          throw new TypeError("offset must be integer or undefined");
        }
        super(layout.span, property || layout.property);
        this.layout = layout;
        this.offset = offset2;
      }
      /** @override */
      isCount() {
        return this.layout instanceof UInt2 || this.layout instanceof UIntBE;
      }
      /** @override */
      decode(b, offset2 = 0) {
        return this.layout.decode(b, offset2 + this.offset);
      }
      /** @override */
      encode(src, b, offset2 = 0) {
        return this.layout.encode(src, b, offset2 + this.offset);
      }
    };
    exports2.OffsetLayout = OffsetLayout;
    var UInt2 = class extends Layout2 {
      constructor(span, property) {
        super(span, property);
        if (6 < this.span) {
          throw new RangeError("span must not exceed 6 bytes");
        }
      }
      /** @override */
      decode(b, offset2 = 0) {
        return uint8ArrayToBuffer(b).readUIntLE(offset2, this.span);
      }
      /** @override */
      encode(src, b, offset2 = 0) {
        uint8ArrayToBuffer(b).writeUIntLE(src, offset2, this.span);
        return this.span;
      }
    };
    exports2.UInt = UInt2;
    var UIntBE = class extends Layout2 {
      constructor(span, property) {
        super(span, property);
        if (6 < this.span) {
          throw new RangeError("span must not exceed 6 bytes");
        }
      }
      /** @override */
      decode(b, offset2 = 0) {
        return uint8ArrayToBuffer(b).readUIntBE(offset2, this.span);
      }
      /** @override */
      encode(src, b, offset2 = 0) {
        uint8ArrayToBuffer(b).writeUIntBE(src, offset2, this.span);
        return this.span;
      }
    };
    exports2.UIntBE = UIntBE;
    var Int = class extends Layout2 {
      constructor(span, property) {
        super(span, property);
        if (6 < this.span) {
          throw new RangeError("span must not exceed 6 bytes");
        }
      }
      /** @override */
      decode(b, offset2 = 0) {
        return uint8ArrayToBuffer(b).readIntLE(offset2, this.span);
      }
      /** @override */
      encode(src, b, offset2 = 0) {
        uint8ArrayToBuffer(b).writeIntLE(src, offset2, this.span);
        return this.span;
      }
    };
    exports2.Int = Int;
    var IntBE = class extends Layout2 {
      constructor(span, property) {
        super(span, property);
        if (6 < this.span) {
          throw new RangeError("span must not exceed 6 bytes");
        }
      }
      /** @override */
      decode(b, offset2 = 0) {
        return uint8ArrayToBuffer(b).readIntBE(offset2, this.span);
      }
      /** @override */
      encode(src, b, offset2 = 0) {
        uint8ArrayToBuffer(b).writeIntBE(src, offset2, this.span);
        return this.span;
      }
    };
    exports2.IntBE = IntBE;
    var V2E32 = Math.pow(2, 32);
    function divmodInt64(src) {
      const hi32 = Math.floor(src / V2E32);
      const lo32 = src - hi32 * V2E32;
      return { hi32, lo32 };
    }
    function roundedInt64(hi32, lo32) {
      return hi32 * V2E32 + lo32;
    }
    var NearUInt64 = class extends Layout2 {
      constructor(property) {
        super(8, property);
      }
      /** @override */
      decode(b, offset2 = 0) {
        const buffer = uint8ArrayToBuffer(b);
        const lo32 = buffer.readUInt32LE(offset2);
        const hi32 = buffer.readUInt32LE(offset2 + 4);
        return roundedInt64(hi32, lo32);
      }
      /** @override */
      encode(src, b, offset2 = 0) {
        const split = divmodInt64(src);
        const buffer = uint8ArrayToBuffer(b);
        buffer.writeUInt32LE(split.lo32, offset2);
        buffer.writeUInt32LE(split.hi32, offset2 + 4);
        return 8;
      }
    };
    exports2.NearUInt64 = NearUInt64;
    var NearUInt64BE = class extends Layout2 {
      constructor(property) {
        super(8, property);
      }
      /** @override */
      decode(b, offset2 = 0) {
        const buffer = uint8ArrayToBuffer(b);
        const hi32 = buffer.readUInt32BE(offset2);
        const lo32 = buffer.readUInt32BE(offset2 + 4);
        return roundedInt64(hi32, lo32);
      }
      /** @override */
      encode(src, b, offset2 = 0) {
        const split = divmodInt64(src);
        const buffer = uint8ArrayToBuffer(b);
        buffer.writeUInt32BE(split.hi32, offset2);
        buffer.writeUInt32BE(split.lo32, offset2 + 4);
        return 8;
      }
    };
    exports2.NearUInt64BE = NearUInt64BE;
    var NearInt64 = class extends Layout2 {
      constructor(property) {
        super(8, property);
      }
      /** @override */
      decode(b, offset2 = 0) {
        const buffer = uint8ArrayToBuffer(b);
        const lo32 = buffer.readUInt32LE(offset2);
        const hi32 = buffer.readInt32LE(offset2 + 4);
        return roundedInt64(hi32, lo32);
      }
      /** @override */
      encode(src, b, offset2 = 0) {
        const split = divmodInt64(src);
        const buffer = uint8ArrayToBuffer(b);
        buffer.writeUInt32LE(split.lo32, offset2);
        buffer.writeInt32LE(split.hi32, offset2 + 4);
        return 8;
      }
    };
    exports2.NearInt64 = NearInt64;
    var NearInt64BE = class extends Layout2 {
      constructor(property) {
        super(8, property);
      }
      /** @override */
      decode(b, offset2 = 0) {
        const buffer = uint8ArrayToBuffer(b);
        const hi32 = buffer.readInt32BE(offset2);
        const lo32 = buffer.readUInt32BE(offset2 + 4);
        return roundedInt64(hi32, lo32);
      }
      /** @override */
      encode(src, b, offset2 = 0) {
        const split = divmodInt64(src);
        const buffer = uint8ArrayToBuffer(b);
        buffer.writeInt32BE(split.hi32, offset2);
        buffer.writeUInt32BE(split.lo32, offset2 + 4);
        return 8;
      }
    };
    exports2.NearInt64BE = NearInt64BE;
    var Float = class extends Layout2 {
      constructor(property) {
        super(4, property);
      }
      /** @override */
      decode(b, offset2 = 0) {
        return uint8ArrayToBuffer(b).readFloatLE(offset2);
      }
      /** @override */
      encode(src, b, offset2 = 0) {
        uint8ArrayToBuffer(b).writeFloatLE(src, offset2);
        return 4;
      }
    };
    exports2.Float = Float;
    var FloatBE = class extends Layout2 {
      constructor(property) {
        super(4, property);
      }
      /** @override */
      decode(b, offset2 = 0) {
        return uint8ArrayToBuffer(b).readFloatBE(offset2);
      }
      /** @override */
      encode(src, b, offset2 = 0) {
        uint8ArrayToBuffer(b).writeFloatBE(src, offset2);
        return 4;
      }
    };
    exports2.FloatBE = FloatBE;
    var Double = class extends Layout2 {
      constructor(property) {
        super(8, property);
      }
      /** @override */
      decode(b, offset2 = 0) {
        return uint8ArrayToBuffer(b).readDoubleLE(offset2);
      }
      /** @override */
      encode(src, b, offset2 = 0) {
        uint8ArrayToBuffer(b).writeDoubleLE(src, offset2);
        return 8;
      }
    };
    exports2.Double = Double;
    var DoubleBE = class extends Layout2 {
      constructor(property) {
        super(8, property);
      }
      /** @override */
      decode(b, offset2 = 0) {
        return uint8ArrayToBuffer(b).readDoubleBE(offset2);
      }
      /** @override */
      encode(src, b, offset2 = 0) {
        uint8ArrayToBuffer(b).writeDoubleBE(src, offset2);
        return 8;
      }
    };
    exports2.DoubleBE = DoubleBE;
    var Sequence = class extends Layout2 {
      constructor(elementLayout, count, property) {
        if (!(elementLayout instanceof Layout2)) {
          throw new TypeError("elementLayout must be a Layout");
        }
        if (!(count instanceof ExternalLayout && count.isCount() || Number.isInteger(count) && 0 <= count)) {
          throw new TypeError("count must be non-negative integer or an unsigned integer ExternalLayout");
        }
        let span = -1;
        if (!(count instanceof ExternalLayout) && 0 < elementLayout.span) {
          span = count * elementLayout.span;
        }
        super(span, property);
        this.elementLayout = elementLayout;
        this.count = count;
      }
      /** @override */
      getSpan(b, offset2 = 0) {
        if (0 <= this.span) {
          return this.span;
        }
        let span = 0;
        let count = this.count;
        if (count instanceof ExternalLayout) {
          count = count.decode(b, offset2);
        }
        if (0 < this.elementLayout.span) {
          span = count * this.elementLayout.span;
        } else {
          let idx = 0;
          while (idx < count) {
            span += this.elementLayout.getSpan(b, offset2 + span);
            ++idx;
          }
        }
        return span;
      }
      /** @override */
      decode(b, offset2 = 0) {
        const rv = [];
        let i = 0;
        let count = this.count;
        if (count instanceof ExternalLayout) {
          count = count.decode(b, offset2);
        }
        while (i < count) {
          rv.push(this.elementLayout.decode(b, offset2));
          offset2 += this.elementLayout.getSpan(b, offset2);
          i += 1;
        }
        return rv;
      }
      /** Implement {@link Layout#encode|encode} for {@link Sequence}.
       *
       * **NOTE** If `src` is shorter than {@link Sequence#count|count} then
       * the unused space in the buffer is left unchanged.  If `src` is
       * longer than {@link Sequence#count|count} the unneeded elements are
       * ignored.
       *
       * **NOTE** If {@link Layout#count|count} is an instance of {@link
       * ExternalLayout} then the length of `src` will be encoded as the
       * count after `src` is encoded. */
      encode(src, b, offset2 = 0) {
        const elo = this.elementLayout;
        const span = src.reduce((span2, v) => {
          return span2 + elo.encode(v, b, offset2 + span2);
        }, 0);
        if (this.count instanceof ExternalLayout) {
          this.count.encode(src.length, b, offset2);
        }
        return span;
      }
    };
    exports2.Sequence = Sequence;
    var Structure2 = class extends Layout2 {
      constructor(fields, property, decodePrefixes) {
        if (!(Array.isArray(fields) && fields.reduce((acc, v) => acc && v instanceof Layout2, true))) {
          throw new TypeError("fields must be array of Layout instances");
        }
        if ("boolean" === typeof property && void 0 === decodePrefixes) {
          decodePrefixes = property;
          property = void 0;
        }
        for (const fd of fields) {
          if (0 > fd.span && void 0 === fd.property) {
            throw new Error("fields cannot contain unnamed variable-length layout");
          }
        }
        let span = -1;
        try {
          span = fields.reduce((span2, fd) => span2 + fd.getSpan(), 0);
        } catch (e) {
        }
        super(span, property);
        this.fields = fields;
        this.decodePrefixes = !!decodePrefixes;
      }
      /** @override */
      getSpan(b, offset2 = 0) {
        if (0 <= this.span) {
          return this.span;
        }
        let span = 0;
        try {
          span = this.fields.reduce((span2, fd) => {
            const fsp = fd.getSpan(b, offset2);
            offset2 += fsp;
            return span2 + fsp;
          }, 0);
        } catch (e) {
          throw new RangeError("indeterminate span");
        }
        return span;
      }
      /** @override */
      decode(b, offset2 = 0) {
        checkUint8Array(b);
        const dest = this.makeDestinationObject();
        for (const fd of this.fields) {
          if (void 0 !== fd.property) {
            dest[fd.property] = fd.decode(b, offset2);
          }
          offset2 += fd.getSpan(b, offset2);
          if (this.decodePrefixes && b.length === offset2) {
            break;
          }
        }
        return dest;
      }
      /** Implement {@link Layout#encode|encode} for {@link Structure}.
       *
       * If `src` is missing a property for a member with a defined {@link
       * Layout#property|property} the corresponding region of the buffer is
       * left unmodified. */
      encode(src, b, offset2 = 0) {
        const firstOffset = offset2;
        let lastOffset = 0;
        let lastWrote = 0;
        for (const fd of this.fields) {
          let span = fd.span;
          lastWrote = 0 < span ? span : 0;
          if (void 0 !== fd.property) {
            const fv = src[fd.property];
            if (void 0 !== fv) {
              lastWrote = fd.encode(fv, b, offset2);
              if (0 > span) {
                span = fd.getSpan(b, offset2);
              }
            }
          }
          lastOffset = offset2;
          offset2 += span;
        }
        return lastOffset + lastWrote - firstOffset;
      }
      /** @override */
      fromArray(values) {
        const dest = this.makeDestinationObject();
        for (const fd of this.fields) {
          if (void 0 !== fd.property && 0 < values.length) {
            dest[fd.property] = values.shift();
          }
        }
        return dest;
      }
      /**
       * Get access to the layout of a given property.
       *
       * @param {String} property - the structure member of interest.
       *
       * @return {Layout} - the layout associated with `property`, or
       * undefined if there is no such property.
       */
      layoutFor(property) {
        if ("string" !== typeof property) {
          throw new TypeError("property must be string");
        }
        for (const fd of this.fields) {
          if (fd.property === property) {
            return fd;
          }
        }
        return void 0;
      }
      /**
       * Get the offset of a structure member.
       *
       * @param {String} property - the structure member of interest.
       *
       * @return {Number} - the offset in bytes to the start of `property`
       * within the structure, or undefined if `property` is not a field
       * within the structure.  If the property is a member but follows a
       * variable-length structure member a negative number will be
       * returned.
       */
      offsetOf(property) {
        if ("string" !== typeof property) {
          throw new TypeError("property must be string");
        }
        let offset2 = 0;
        for (const fd of this.fields) {
          if (fd.property === property) {
            return offset2;
          }
          if (0 > fd.span) {
            offset2 = -1;
          } else if (0 <= offset2) {
            offset2 += fd.span;
          }
        }
        return void 0;
      }
    };
    exports2.Structure = Structure2;
    var UnionDiscriminator = class {
      constructor(property) {
        this.property = property;
      }
      /** Analog to {@link Layout#decode|Layout decode} for union discriminators.
       *
       * The implementation of this method need not reference the buffer if
       * variant information is available through other means. */
      decode(b, offset2) {
        throw new Error("UnionDiscriminator is abstract");
      }
      /** Analog to {@link Layout#decode|Layout encode} for union discriminators.
       *
       * The implementation of this method need not store the value if
       * variant information is maintained through other means. */
      encode(src, b, offset2) {
        throw new Error("UnionDiscriminator is abstract");
      }
    };
    exports2.UnionDiscriminator = UnionDiscriminator;
    var UnionLayoutDiscriminator = class extends UnionDiscriminator {
      constructor(layout, property) {
        if (!(layout instanceof ExternalLayout && layout.isCount())) {
          throw new TypeError("layout must be an unsigned integer ExternalLayout");
        }
        super(property || layout.property || "variant");
        this.layout = layout;
      }
      /** Delegate decoding to {@link UnionLayoutDiscriminator#layout|layout}. */
      decode(b, offset2) {
        return this.layout.decode(b, offset2);
      }
      /** Delegate encoding to {@link UnionLayoutDiscriminator#layout|layout}. */
      encode(src, b, offset2) {
        return this.layout.encode(src, b, offset2);
      }
    };
    exports2.UnionLayoutDiscriminator = UnionLayoutDiscriminator;
    var Union2 = class extends Layout2 {
      constructor(discr, defaultLayout, property) {
        let discriminator;
        if (discr instanceof UInt2 || discr instanceof UIntBE) {
          discriminator = new UnionLayoutDiscriminator(new OffsetLayout(discr));
        } else if (discr instanceof ExternalLayout && discr.isCount()) {
          discriminator = new UnionLayoutDiscriminator(discr);
        } else if (!(discr instanceof UnionDiscriminator)) {
          throw new TypeError("discr must be a UnionDiscriminator or an unsigned integer layout");
        } else {
          discriminator = discr;
        }
        if (void 0 === defaultLayout) {
          defaultLayout = null;
        }
        if (!(null === defaultLayout || defaultLayout instanceof Layout2)) {
          throw new TypeError("defaultLayout must be null or a Layout");
        }
        if (null !== defaultLayout) {
          if (0 > defaultLayout.span) {
            throw new Error("defaultLayout must have constant span");
          }
          if (void 0 === defaultLayout.property) {
            defaultLayout = defaultLayout.replicate("content");
          }
        }
        let span = -1;
        if (defaultLayout) {
          span = defaultLayout.span;
          if (0 <= span && (discr instanceof UInt2 || discr instanceof UIntBE)) {
            span += discriminator.layout.span;
          }
        }
        super(span, property);
        this.discriminator = discriminator;
        this.usesPrefixDiscriminator = discr instanceof UInt2 || discr instanceof UIntBE;
        this.defaultLayout = defaultLayout;
        this.registry = {};
        let boundGetSourceVariant = this.defaultGetSourceVariant.bind(this);
        this.getSourceVariant = function(src) {
          return boundGetSourceVariant(src);
        };
        this.configGetSourceVariant = function(gsv) {
          boundGetSourceVariant = gsv.bind(this);
        };
      }
      /** @override */
      getSpan(b, offset2 = 0) {
        if (0 <= this.span) {
          return this.span;
        }
        const vlo = this.getVariant(b, offset2);
        if (!vlo) {
          throw new Error("unable to determine span for unrecognized variant");
        }
        return vlo.getSpan(b, offset2);
      }
      /**
       * Method to infer a registered Union variant compatible with `src`.
       *
       * The first satisfied rule in the following sequence defines the
       * return value:
       * * If `src` has properties matching the Union discriminator and
       *   the default layout, `undefined` is returned regardless of the
       *   value of the discriminator property (this ensures the default
       *   layout will be used);
       * * If `src` has a property matching the Union discriminator, the
       *   value of the discriminator identifies a registered variant, and
       *   either (a) the variant has no layout, or (b) `src` has the
       *   variant's property, then the variant is returned (because the
       *   source satisfies the constraints of the variant it identifies);
       * * If `src` does not have a property matching the Union
       *   discriminator, but does have a property matching a registered
       *   variant, then the variant is returned (because the source
       *   matches a variant without an explicit conflict);
       * * An error is thrown (because we either can't identify a variant,
       *   or we were explicitly told the variant but can't satisfy it).
       *
       * @param {Object} src - an object presumed to be compatible with
       * the content of the Union.
       *
       * @return {(undefined|VariantLayout)} - as described above.
       *
       * @throws {Error} - if `src` cannot be associated with a default or
       * registered variant.
       */
      defaultGetSourceVariant(src) {
        if (Object.prototype.hasOwnProperty.call(src, this.discriminator.property)) {
          if (this.defaultLayout && this.defaultLayout.property && Object.prototype.hasOwnProperty.call(src, this.defaultLayout.property)) {
            return void 0;
          }
          const vlo = this.registry[src[this.discriminator.property]];
          if (vlo && (!vlo.layout || vlo.property && Object.prototype.hasOwnProperty.call(src, vlo.property))) {
            return vlo;
          }
        } else {
          for (const tag2 in this.registry) {
            const vlo = this.registry[tag2];
            if (vlo.property && Object.prototype.hasOwnProperty.call(src, vlo.property)) {
              return vlo;
            }
          }
        }
        throw new Error("unable to infer src variant");
      }
      /** Implement {@link Layout#decode|decode} for {@link Union}.
       *
       * If the variant is {@link Union#addVariant|registered} the return
       * value is an instance of that variant, with no explicit
       * discriminator.  Otherwise the {@link Union#defaultLayout|default
       * layout} is used to decode the content. */
      decode(b, offset2 = 0) {
        let dest;
        const dlo = this.discriminator;
        const discr = dlo.decode(b, offset2);
        const clo = this.registry[discr];
        if (void 0 === clo) {
          const defaultLayout = this.defaultLayout;
          let contentOffset = 0;
          if (this.usesPrefixDiscriminator) {
            contentOffset = dlo.layout.span;
          }
          dest = this.makeDestinationObject();
          dest[dlo.property] = discr;
          dest[defaultLayout.property] = defaultLayout.decode(b, offset2 + contentOffset);
        } else {
          dest = clo.decode(b, offset2);
        }
        return dest;
      }
      /** Implement {@link Layout#encode|encode} for {@link Union}.
       *
       * This API assumes the `src` object is consistent with the union's
       * {@link Union#defaultLayout|default layout}.  To encode variants
       * use the appropriate variant-specific {@link VariantLayout#encode}
       * method. */
      encode(src, b, offset2 = 0) {
        const vlo = this.getSourceVariant(src);
        if (void 0 === vlo) {
          const dlo = this.discriminator;
          const clo = this.defaultLayout;
          let contentOffset = 0;
          if (this.usesPrefixDiscriminator) {
            contentOffset = dlo.layout.span;
          }
          dlo.encode(src[dlo.property], b, offset2);
          return contentOffset + clo.encode(src[clo.property], b, offset2 + contentOffset);
        }
        return vlo.encode(src, b, offset2);
      }
      /** Register a new variant structure within a union.  The newly
       * created variant is returned.
       *
       * @param {Number} variant - initializer for {@link
       * VariantLayout#variant|variant}.
       *
       * @param {Layout} layout - initializer for {@link
       * VariantLayout#layout|layout}.
       *
       * @param {String} property - initializer for {@link
       * Layout#property|property}.
       *
       * @return {VariantLayout} */
      addVariant(variant, layout, property) {
        const rv = new VariantLayout(this, variant, layout, property);
        this.registry[variant] = rv;
        return rv;
      }
      /**
       * Get the layout associated with a registered variant.
       *
       * If `vb` does not produce a registered variant the function returns
       * `undefined`.
       *
       * @param {(Number|Uint8Array)} vb - either the variant number, or a
       * buffer from which the discriminator is to be read.
       *
       * @param {Number} offset - offset into `vb` for the start of the
       * union.  Used only when `vb` is an instance of {Uint8Array}.
       *
       * @return {({VariantLayout}|undefined)}
       */
      getVariant(vb, offset2 = 0) {
        let variant;
        if (vb instanceof Uint8Array) {
          variant = this.discriminator.decode(vb, offset2);
        } else {
          variant = vb;
        }
        return this.registry[variant];
      }
    };
    exports2.Union = Union2;
    var VariantLayout = class extends Layout2 {
      constructor(union2, variant, layout, property) {
        if (!(union2 instanceof Union2)) {
          throw new TypeError("union must be a Union");
        }
        if (!Number.isInteger(variant) || 0 > variant) {
          throw new TypeError("variant must be a (non-negative) integer");
        }
        if ("string" === typeof layout && void 0 === property) {
          property = layout;
          layout = null;
        }
        if (layout) {
          if (!(layout instanceof Layout2)) {
            throw new TypeError("layout must be a Layout");
          }
          if (null !== union2.defaultLayout && 0 <= layout.span && layout.span > union2.defaultLayout.span) {
            throw new Error("variant span exceeds span of containing union");
          }
          if ("string" !== typeof property) {
            throw new TypeError("variant must have a String property");
          }
        }
        let span = union2.span;
        if (0 > union2.span) {
          span = layout ? layout.span : 0;
          if (0 <= span && union2.usesPrefixDiscriminator) {
            span += union2.discriminator.layout.span;
          }
        }
        super(span, property);
        this.union = union2;
        this.variant = variant;
        this.layout = layout || null;
      }
      /** @override */
      getSpan(b, offset2 = 0) {
        if (0 <= this.span) {
          return this.span;
        }
        let contentOffset = 0;
        if (this.union.usesPrefixDiscriminator) {
          contentOffset = this.union.discriminator.layout.span;
        }
        let span = 0;
        if (this.layout) {
          span = this.layout.getSpan(b, offset2 + contentOffset);
        }
        return contentOffset + span;
      }
      /** @override */
      decode(b, offset2 = 0) {
        const dest = this.makeDestinationObject();
        if (this !== this.union.getVariant(b, offset2)) {
          throw new Error("variant mismatch");
        }
        let contentOffset = 0;
        if (this.union.usesPrefixDiscriminator) {
          contentOffset = this.union.discriminator.layout.span;
        }
        if (this.layout) {
          dest[this.property] = this.layout.decode(b, offset2 + contentOffset);
        } else if (this.property) {
          dest[this.property] = true;
        } else if (this.union.usesPrefixDiscriminator) {
          dest[this.union.discriminator.property] = this.variant;
        }
        return dest;
      }
      /** @override */
      encode(src, b, offset2 = 0) {
        let contentOffset = 0;
        if (this.union.usesPrefixDiscriminator) {
          contentOffset = this.union.discriminator.layout.span;
        }
        if (this.layout && !Object.prototype.hasOwnProperty.call(src, this.property)) {
          throw new TypeError("variant lacks property " + this.property);
        }
        this.union.discriminator.encode(this.variant, b, offset2);
        let span = contentOffset;
        if (this.layout) {
          this.layout.encode(src[this.property], b, offset2 + contentOffset);
          span += this.layout.getSpan(b, offset2 + contentOffset);
          if (0 <= this.union.span && span > this.union.span) {
            throw new Error("encoded variant overruns containing union");
          }
        }
        return span;
      }
      /** Delegate {@link Layout#fromArray|fromArray} to {@link
       * VariantLayout#layout|layout}. */
      fromArray(values) {
        if (this.layout) {
          return this.layout.fromArray(values);
        }
        return void 0;
      }
    };
    exports2.VariantLayout = VariantLayout;
    function fixBitwiseResult(v) {
      if (0 > v) {
        v += 4294967296;
      }
      return v;
    }
    var BitStructure2 = class extends Layout2 {
      constructor(word, msb, property) {
        if (!(word instanceof UInt2 || word instanceof UIntBE)) {
          throw new TypeError("word must be a UInt or UIntBE layout");
        }
        if ("string" === typeof msb && void 0 === property) {
          property = msb;
          msb = false;
        }
        if (4 < word.span) {
          throw new RangeError("word cannot exceed 32 bits");
        }
        super(word.span, property);
        this.word = word;
        this.msb = !!msb;
        this.fields = [];
        let value = 0;
        this._packedSetValue = function(v) {
          value = fixBitwiseResult(v);
          return this;
        };
        this._packedGetValue = function() {
          return value;
        };
      }
      /** @override */
      decode(b, offset2 = 0) {
        const dest = this.makeDestinationObject();
        const value = this.word.decode(b, offset2);
        this._packedSetValue(value);
        for (const fd of this.fields) {
          if (void 0 !== fd.property) {
            dest[fd.property] = fd.decode(b);
          }
        }
        return dest;
      }
      /** Implement {@link Layout#encode|encode} for {@link BitStructure}.
       *
       * If `src` is missing a property for a member with a defined {@link
       * Layout#property|property} the corresponding region of the packed
       * value is left unmodified.  Unused bits are also left unmodified. */
      encode(src, b, offset2 = 0) {
        const value = this.word.decode(b, offset2);
        this._packedSetValue(value);
        for (const fd of this.fields) {
          if (void 0 !== fd.property) {
            const fv = src[fd.property];
            if (void 0 !== fv) {
              fd.encode(fv);
            }
          }
        }
        return this.word.encode(this._packedGetValue(), b, offset2);
      }
      /** Register a new bitfield with a containing bit structure.  The
       * resulting bitfield is returned.
       *
       * @param {Number} bits - initializer for {@link BitField#bits|bits}.
       *
       * @param {string} property - initializer for {@link
       * Layout#property|property}.
       *
       * @return {BitField} */
      addField(bits2, property) {
        const bf = new BitField(this, bits2, property);
        this.fields.push(bf);
        return bf;
      }
      /** As with {@link BitStructure#addField|addField} for single-bit
       * fields with `boolean` value representation.
       *
       * @param {string} property - initializer for {@link
       * Layout#property|property}.
       *
       * @return {Boolean} */
      // `Boolean` conflicts with the native primitive type
      // eslint-disable-next-line @typescript-eslint/ban-types
      addBoolean(property) {
        const bf = new Boolean2(this, property);
        this.fields.push(bf);
        return bf;
      }
      /**
       * Get access to the bit field for a given property.
       *
       * @param {String} property - the bit field of interest.
       *
       * @return {BitField} - the field associated with `property`, or
       * undefined if there is no such property.
       */
      fieldFor(property) {
        if ("string" !== typeof property) {
          throw new TypeError("property must be string");
        }
        for (const fd of this.fields) {
          if (fd.property === property) {
            return fd;
          }
        }
        return void 0;
      }
    };
    exports2.BitStructure = BitStructure2;
    var BitField = class {
      constructor(container, bits2, property) {
        if (!(container instanceof BitStructure2)) {
          throw new TypeError("container must be a BitStructure");
        }
        if (!Number.isInteger(bits2) || 0 >= bits2) {
          throw new TypeError("bits must be positive integer");
        }
        const totalBits = 8 * container.span;
        const usedBits = container.fields.reduce((sum2, fd) => sum2 + fd.bits, 0);
        if (bits2 + usedBits > totalBits) {
          throw new Error("bits too long for span remainder (" + (totalBits - usedBits) + " of " + totalBits + " remain)");
        }
        this.container = container;
        this.bits = bits2;
        this.valueMask = (1 << bits2) - 1;
        if (32 === bits2) {
          this.valueMask = 4294967295;
        }
        this.start = usedBits;
        if (this.container.msb) {
          this.start = totalBits - usedBits - bits2;
        }
        this.wordMask = fixBitwiseResult(this.valueMask << this.start);
        this.property = property;
      }
      /** Store a value into the corresponding subsequence of the containing
       * bit field. */
      decode(b, offset2) {
        const word = this.container._packedGetValue();
        const wordValue = fixBitwiseResult(word & this.wordMask);
        const value = wordValue >>> this.start;
        return value;
      }
      /** Store a value into the corresponding subsequence of the containing
       * bit field.
       *
       * **NOTE** This is not a specialization of {@link
       * Layout#encode|Layout.encode} and there is no return value. */
      encode(value) {
        if ("number" !== typeof value || !Number.isInteger(value) || value !== fixBitwiseResult(value & this.valueMask)) {
          throw new TypeError(nameWithProperty("BitField.encode", this) + " value must be integer not exceeding " + this.valueMask);
        }
        const word = this.container._packedGetValue();
        const wordValue = fixBitwiseResult(value << this.start);
        this.container._packedSetValue(fixBitwiseResult(word & ~this.wordMask) | wordValue);
      }
    };
    exports2.BitField = BitField;
    var Boolean2 = class extends BitField {
      constructor(container, property) {
        super(container, 1, property);
      }
      /** Override {@link BitField#decode|decode} for {@link Boolean|Boolean}.
       *
       * @returns {boolean} */
      decode(b, offset2) {
        return !!super.decode(b, offset2);
      }
      /** @override */
      encode(value) {
        if ("boolean" === typeof value) {
          value = +value;
        }
        super.encode(value);
      }
    };
    exports2.Boolean = Boolean2;
    var Blob2 = class extends Layout2 {
      constructor(length, property) {
        if (!(length instanceof ExternalLayout && length.isCount() || Number.isInteger(length) && 0 <= length)) {
          throw new TypeError("length must be positive integer or an unsigned integer ExternalLayout");
        }
        let span = -1;
        if (!(length instanceof ExternalLayout)) {
          span = length;
        }
        super(span, property);
        this.length = length;
      }
      /** @override */
      getSpan(b, offset2) {
        let span = this.span;
        if (0 > span) {
          span = this.length.decode(b, offset2);
        }
        return span;
      }
      /** @override */
      decode(b, offset2 = 0) {
        let span = this.span;
        if (0 > span) {
          span = this.length.decode(b, offset2);
        }
        return uint8ArrayToBuffer(b).slice(offset2, offset2 + span);
      }
      /** Implement {@link Layout#encode|encode} for {@link Blob}.
       *
       * **NOTE** If {@link Layout#count|count} is an instance of {@link
       * ExternalLayout} then the length of `src` will be encoded as the
       * count after `src` is encoded. */
      encode(src, b, offset2) {
        let span = this.length;
        if (this.length instanceof ExternalLayout) {
          span = src.length;
        }
        if (!(src instanceof Uint8Array && span === src.length)) {
          throw new TypeError(nameWithProperty("Blob.encode", this) + " requires (length " + span + ") Uint8Array as src");
        }
        if (offset2 + span > b.length) {
          throw new RangeError("encoding overruns Uint8Array");
        }
        const srcBuffer = uint8ArrayToBuffer(src);
        uint8ArrayToBuffer(b).write(srcBuffer.toString("hex"), offset2, span, "hex");
        if (this.length instanceof ExternalLayout) {
          this.length.encode(span, b, offset2);
        }
        return span;
      }
    };
    exports2.Blob = Blob2;
    var CString = class extends Layout2 {
      constructor(property) {
        super(-1, property);
      }
      /** @override */
      getSpan(b, offset2 = 0) {
        checkUint8Array(b);
        let idx = offset2;
        while (idx < b.length && 0 !== b[idx]) {
          idx += 1;
        }
        return 1 + idx - offset2;
      }
      /** @override */
      decode(b, offset2 = 0) {
        const span = this.getSpan(b, offset2);
        return uint8ArrayToBuffer(b).slice(offset2, offset2 + span - 1).toString("utf-8");
      }
      /** @override */
      encode(src, b, offset2 = 0) {
        if ("string" !== typeof src) {
          src = String(src);
        }
        const srcb = buffer_1.Buffer.from(src, "utf8");
        const span = srcb.length;
        if (offset2 + span > b.length) {
          throw new RangeError("encoding overruns Buffer");
        }
        const buffer = uint8ArrayToBuffer(b);
        srcb.copy(buffer, offset2);
        buffer[offset2 + span] = 0;
        return span + 1;
      }
    };
    exports2.CString = CString;
    var UTF8 = class extends Layout2 {
      constructor(maxSpan, property) {
        if ("string" === typeof maxSpan && void 0 === property) {
          property = maxSpan;
          maxSpan = void 0;
        }
        if (void 0 === maxSpan) {
          maxSpan = -1;
        } else if (!Number.isInteger(maxSpan)) {
          throw new TypeError("maxSpan must be an integer");
        }
        super(-1, property);
        this.maxSpan = maxSpan;
      }
      /** @override */
      getSpan(b, offset2 = 0) {
        checkUint8Array(b);
        return b.length - offset2;
      }
      /** @override */
      decode(b, offset2 = 0) {
        const span = this.getSpan(b, offset2);
        if (0 <= this.maxSpan && this.maxSpan < span) {
          throw new RangeError("text length exceeds maxSpan");
        }
        return uint8ArrayToBuffer(b).slice(offset2, offset2 + span).toString("utf-8");
      }
      /** @override */
      encode(src, b, offset2 = 0) {
        if ("string" !== typeof src) {
          src = String(src);
        }
        const srcb = buffer_1.Buffer.from(src, "utf8");
        const span = srcb.length;
        if (0 <= this.maxSpan && this.maxSpan < span) {
          throw new RangeError("text length exceeds maxSpan");
        }
        if (offset2 + span > b.length) {
          throw new RangeError("encoding overruns Buffer");
        }
        srcb.copy(uint8ArrayToBuffer(b), offset2);
        return span;
      }
    };
    exports2.UTF8 = UTF8;
    var Constant = class extends Layout2 {
      constructor(value, property) {
        super(0, property);
        this.value = value;
      }
      /** @override */
      decode(b, offset2) {
        return this.value;
      }
      /** @override */
      encode(src, b, offset2) {
        return 0;
      }
    };
    exports2.Constant = Constant;
    exports2.greedy = (elementSpan, property) => new GreedyCount(elementSpan, property);
    exports2.offset = (layout, offset2, property) => new OffsetLayout(layout, offset2, property);
    exports2.u8 = (property) => new UInt2(1, property);
    exports2.u16 = (property) => new UInt2(2, property);
    exports2.u24 = (property) => new UInt2(3, property);
    exports2.u32 = (property) => new UInt2(4, property);
    exports2.u40 = (property) => new UInt2(5, property);
    exports2.u48 = (property) => new UInt2(6, property);
    exports2.nu64 = (property) => new NearUInt64(property);
    exports2.u16be = (property) => new UIntBE(2, property);
    exports2.u24be = (property) => new UIntBE(3, property);
    exports2.u32be = (property) => new UIntBE(4, property);
    exports2.u40be = (property) => new UIntBE(5, property);
    exports2.u48be = (property) => new UIntBE(6, property);
    exports2.nu64be = (property) => new NearUInt64BE(property);
    exports2.s8 = (property) => new Int(1, property);
    exports2.s16 = (property) => new Int(2, property);
    exports2.s24 = (property) => new Int(3, property);
    exports2.s32 = (property) => new Int(4, property);
    exports2.s40 = (property) => new Int(5, property);
    exports2.s48 = (property) => new Int(6, property);
    exports2.ns64 = (property) => new NearInt64(property);
    exports2.s16be = (property) => new IntBE(2, property);
    exports2.s24be = (property) => new IntBE(3, property);
    exports2.s32be = (property) => new IntBE(4, property);
    exports2.s40be = (property) => new IntBE(5, property);
    exports2.s48be = (property) => new IntBE(6, property);
    exports2.ns64be = (property) => new NearInt64BE(property);
    exports2.f32 = (property) => new Float(property);
    exports2.f32be = (property) => new FloatBE(property);
    exports2.f64 = (property) => new Double(property);
    exports2.f64be = (property) => new DoubleBE(property);
    exports2.struct = (fields, property, decodePrefixes) => new Structure2(fields, property, decodePrefixes);
    exports2.bits = (word, msb, property) => new BitStructure2(word, msb, property);
    exports2.seq = (elementLayout, count, property) => new Sequence(elementLayout, count, property);
    exports2.union = (discr, defaultLayout, property) => new Union2(discr, defaultLayout, property);
    exports2.unionLayoutDiscriminator = (layout, property) => new UnionLayoutDiscriminator(layout, property);
    exports2.blob = (length, property) => new Blob2(length, property);
    exports2.cstr = (property) => new CString(property);
    exports2.utf8 = (maxSpan, property) => new UTF8(maxSpan, property);
    exports2.constant = (value, property) => new Constant(value, property);
  }
});

// node_modules/@solana/buffer-layout-utils/lib/cjs/base.js
var require_base = __commonJS({
  "node_modules/@solana/buffer-layout-utils/lib/cjs/base.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.encodeDecode = void 0;
    var encodeDecode2 = (layout) => {
      const decode = layout.decode.bind(layout);
      const encode = layout.encode.bind(layout);
      return { decode, encode };
    };
    exports2.encodeDecode = encodeDecode2;
  }
});

// node_modules/file-uri-to-path/index.js
var require_file_uri_to_path = __commonJS({
  "node_modules/file-uri-to-path/index.js"(exports2, module2) {
    var sep = require("path").sep || "/";
    module2.exports = fileUriToPath;
    function fileUriToPath(uri) {
      if ("string" != typeof uri || uri.length <= 7 || "file://" != uri.substring(0, 7)) {
        throw new TypeError("must pass in a file:// URI to convert to a file path");
      }
      var rest = decodeURI(uri.substring(7));
      var firstSlash = rest.indexOf("/");
      var host = rest.substring(0, firstSlash);
      var path = rest.substring(firstSlash + 1);
      if ("localhost" == host)
        host = "";
      if (host) {
        host = sep + sep + host;
      }
      path = path.replace(/^(.+)\|/, "$1:");
      if (sep == "\\") {
        path = path.replace(/\//g, "\\");
      }
      if (/^.+\:/.test(path)) {
      } else {
        path = sep + path;
      }
      return host + path;
    }
  }
});

// node_modules/bindings/bindings.js
var require_bindings = __commonJS({
  "node_modules/bindings/bindings.js"(exports2, module2) {
    var fs = require("fs");
    var path = require("path");
    var fileURLToPath = require_file_uri_to_path();
    var join = path.join;
    var dirname = path.dirname;
    var exists = fs.accessSync && function(path2) {
      try {
        fs.accessSync(path2);
      } catch (e) {
        return false;
      }
      return true;
    } || fs.existsSync || path.existsSync;
    var defaults = {
      arrow: process.env.NODE_BINDINGS_ARROW || " \u2192 ",
      compiled: process.env.NODE_BINDINGS_COMPILED_DIR || "compiled",
      platform: process.platform,
      arch: process.arch,
      nodePreGyp: "node-v" + process.versions.modules + "-" + process.platform + "-" + process.arch,
      version: process.versions.node,
      bindings: "bindings.node",
      try: [
        // node-gyp's linked version in the "build" dir
        ["module_root", "build", "bindings"],
        // node-waf and gyp_addon (a.k.a node-gyp)
        ["module_root", "build", "Debug", "bindings"],
        ["module_root", "build", "Release", "bindings"],
        // Debug files, for development (legacy behavior, remove for node v0.9)
        ["module_root", "out", "Debug", "bindings"],
        ["module_root", "Debug", "bindings"],
        // Release files, but manually compiled (legacy behavior, remove for node v0.9)
        ["module_root", "out", "Release", "bindings"],
        ["module_root", "Release", "bindings"],
        // Legacy from node-waf, node <= 0.4.x
        ["module_root", "build", "default", "bindings"],
        // Production "Release" buildtype binary (meh...)
        ["module_root", "compiled", "version", "platform", "arch", "bindings"],
        // node-qbs builds
        ["module_root", "addon-build", "release", "install-root", "bindings"],
        ["module_root", "addon-build", "debug", "install-root", "bindings"],
        ["module_root", "addon-build", "default", "install-root", "bindings"],
        // node-pre-gyp path ./lib/binding/{node_abi}-{platform}-{arch}
        ["module_root", "lib", "binding", "nodePreGyp", "bindings"]
      ]
    };
    function bindings(opts) {
      if (typeof opts == "string") {
        opts = { bindings: opts };
      } else if (!opts) {
        opts = {};
      }
      Object.keys(defaults).map(function(i2) {
        if (!(i2 in opts))
          opts[i2] = defaults[i2];
      });
      if (!opts.module_root) {
        opts.module_root = exports2.getRoot(exports2.getFileName());
      }
      if (path.extname(opts.bindings) != ".node") {
        opts.bindings += ".node";
      }
      var requireFunc = typeof __webpack_require__ === "function" ? __non_webpack_require__ : require;
      var tries = [], i = 0, l = opts.try.length, n, b, err;
      for (; i < l; i++) {
        n = join.apply(
          null,
          opts.try[i].map(function(p) {
            return opts[p] || p;
          })
        );
        tries.push(n);
        try {
          b = opts.path ? requireFunc.resolve(n) : requireFunc(n);
          if (!opts.path) {
            b.path = n;
          }
          return b;
        } catch (e) {
          if (e.code !== "MODULE_NOT_FOUND" && e.code !== "QUALIFIED_PATH_RESOLUTION_FAILED" && !/not find/i.test(e.message)) {
            throw e;
          }
        }
      }
      err = new Error(
        "Could not locate the bindings file. Tried:\n" + tries.map(function(a) {
          return opts.arrow + a;
        }).join("\n")
      );
      err.tries = tries;
      throw err;
    }
    module2.exports = exports2 = bindings;
    exports2.getFileName = function getFileName(calling_file) {
      var origPST = Error.prepareStackTrace, origSTL = Error.stackTraceLimit, dummy = {}, fileName;
      Error.stackTraceLimit = 10;
      Error.prepareStackTrace = function(e, st) {
        for (var i = 0, l = st.length; i < l; i++) {
          fileName = st[i].getFileName();
          if (fileName !== __filename) {
            if (calling_file) {
              if (fileName !== calling_file) {
                return;
              }
            } else {
              return;
            }
          }
        }
      };
      Error.captureStackTrace(dummy);
      dummy.stack;
      Error.prepareStackTrace = origPST;
      Error.stackTraceLimit = origSTL;
      var fileSchema = "file://";
      if (fileName.indexOf(fileSchema) === 0) {
        fileName = fileURLToPath(fileName);
      }
      return fileName;
    };
    exports2.getRoot = function getRoot(file) {
      var dir = dirname(file), prev;
      while (true) {
        if (dir === ".") {
          dir = process.cwd();
        }
        if (exists(join(dir, "package.json")) || exists(join(dir, "node_modules"))) {
          return dir;
        }
        if (prev === dir) {
          throw new Error(
            'Could not find module root given file: "' + file + '". Do you have a `package.json` file? '
          );
        }
        prev = dir;
        dir = join(dir, "..");
      }
    };
  }
});

// node_modules/bigint-buffer/dist/node.js
var require_node2 = __commonJS({
  "node_modules/bigint-buffer/dist/node.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var converter;
    {
      try {
        converter = require_bindings()("bigint_buffer");
      } catch (e) {
        console.warn("bigint: Failed to load bindings, pure JS will be used (try npm run rebuild?)");
      }
    }
    function toBigIntLE2(buf) {
      if (converter === void 0) {
        const reversed = Buffer.from(buf);
        reversed.reverse();
        const hex = reversed.toString("hex");
        if (hex.length === 0) {
          return BigInt(0);
        }
        return BigInt(`0x${hex}`);
      }
      return converter.toBigInt(buf, false);
    }
    exports2.toBigIntLE = toBigIntLE2;
    function toBigIntBE2(buf) {
      if (converter === void 0) {
        const hex = buf.toString("hex");
        if (hex.length === 0) {
          return BigInt(0);
        }
        return BigInt(`0x${hex}`);
      }
      return converter.toBigInt(buf, true);
    }
    exports2.toBigIntBE = toBigIntBE2;
    function toBufferLE2(num, width) {
      if (converter === void 0) {
        const hex = num.toString(16);
        const buffer = Buffer.from(hex.padStart(width * 2, "0").slice(0, width * 2), "hex");
        buffer.reverse();
        return buffer;
      }
      return converter.fromBigInt(num, Buffer.allocUnsafe(width), false);
    }
    exports2.toBufferLE = toBufferLE2;
    function toBufferBE2(num, width) {
      if (converter === void 0) {
        const hex = num.toString(16);
        return Buffer.from(hex.padStart(width * 2, "0").slice(0, width * 2), "hex");
      }
      return converter.fromBigInt(num, Buffer.allocUnsafe(width), true);
    }
    exports2.toBufferBE = toBufferBE2;
  }
});

// node_modules/@solana/buffer-layout-utils/lib/cjs/bigint.js
var require_bigint = __commonJS({
  "node_modules/@solana/buffer-layout-utils/lib/cjs/bigint.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.u256be = exports2.u256 = exports2.u192be = exports2.u192 = exports2.u128be = exports2.u128 = exports2.u64be = exports2.u64 = exports2.bigIntBE = exports2.bigInt = void 0;
    var buffer_layout_1 = require_Layout();
    var bigint_buffer_1 = require_node2();
    var base_1 = require_base();
    var bigInt2 = (length) => (property) => {
      const layout = (0, buffer_layout_1.blob)(length, property);
      const { encode, decode } = (0, base_1.encodeDecode)(layout);
      const bigIntLayout = layout;
      bigIntLayout.decode = (buffer, offset2) => {
        const src = decode(buffer, offset2);
        return (0, bigint_buffer_1.toBigIntLE)(Buffer.from(src));
      };
      bigIntLayout.encode = (bigInt3, buffer, offset2) => {
        const src = (0, bigint_buffer_1.toBufferLE)(bigInt3, length);
        return encode(src, buffer, offset2);
      };
      return bigIntLayout;
    };
    exports2.bigInt = bigInt2;
    var bigIntBE2 = (length) => (property) => {
      const layout = (0, buffer_layout_1.blob)(length, property);
      const { encode, decode } = (0, base_1.encodeDecode)(layout);
      const bigIntLayout = layout;
      bigIntLayout.decode = (buffer, offset2) => {
        const src = decode(buffer, offset2);
        return (0, bigint_buffer_1.toBigIntBE)(Buffer.from(src));
      };
      bigIntLayout.encode = (bigInt3, buffer, offset2) => {
        const src = (0, bigint_buffer_1.toBufferBE)(bigInt3, length);
        return encode(src, buffer, offset2);
      };
      return bigIntLayout;
    };
    exports2.bigIntBE = bigIntBE2;
    exports2.u64 = (0, exports2.bigInt)(8);
    exports2.u64be = (0, exports2.bigIntBE)(8);
    exports2.u128 = (0, exports2.bigInt)(16);
    exports2.u128be = (0, exports2.bigIntBE)(16);
    exports2.u192 = (0, exports2.bigInt)(24);
    exports2.u192be = (0, exports2.bigIntBE)(24);
    exports2.u256 = (0, exports2.bigInt)(32);
    exports2.u256be = (0, exports2.bigIntBE)(32);
  }
});

// node_modules/bignumber.js/bignumber.js
var require_bignumber = __commonJS({
  "node_modules/bignumber.js/bignumber.js"(exports2, module2) {
    (function(globalObject) {
      "use strict";
      var BigNumber2, isNumeric2 = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i, mathceil2 = Math.ceil, mathfloor3 = Math.floor, bignumberError2 = "[BigNumber Error] ", tooManyDigits2 = bignumberError2 + "Number primitive has more than 15 significant digits: ", BASE3 = 1e14, LOG_BASE3 = 14, MAX_SAFE_INTEGER3 = 9007199254740991, POWS_TEN2 = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13], SQRT_BASE2 = 1e7, MAX2 = 1e9;
      function clone3(configObject) {
        var div3, convertBase2, parseNumeric, P2 = BigNumber3.prototype = { constructor: BigNumber3, toString: null, valueOf: null }, ONE2 = new BigNumber3(1), DECIMAL_PLACES = 20, ROUNDING_MODE = 4, TO_EXP_NEG = -7, TO_EXP_POS = 21, MIN_EXP = -1e7, MAX_EXP = 1e7, CRYPTO = false, MODULO_MODE = 1, POW_PRECISION = 0, FORMAT = {
          prefix: "",
          groupSize: 3,
          secondaryGroupSize: 0,
          groupSeparator: ",",
          decimalSeparator: ".",
          fractionGroupSize: 0,
          fractionGroupSeparator: "\xA0",
          // non-breaking space
          suffix: ""
        }, ALPHABET = "0123456789abcdefghijklmnopqrstuvwxyz", alphabetHasNormalDecimalDigits = true;
        function BigNumber3(v, b) {
          var alphabet, c, caseChanged, e, i, isNum, len, str2, x = this;
          if (!(x instanceof BigNumber3))
            return new BigNumber3(v, b);
          if (b == null) {
            if (v && v._isBigNumber === true) {
              x.s = v.s;
              if (!v.c || v.e > MAX_EXP) {
                x.c = x.e = null;
              } else if (v.e < MIN_EXP) {
                x.c = [x.e = 0];
              } else {
                x.e = v.e;
                x.c = v.c.slice();
              }
              return;
            }
            if ((isNum = typeof v == "number") && v * 0 == 0) {
              x.s = 1 / v < 0 ? (v = -v, -1) : 1;
              if (v === ~~v) {
                for (e = 0, i = v; i >= 10; i /= 10, e++)
                  ;
                if (e > MAX_EXP) {
                  x.c = x.e = null;
                } else {
                  x.e = e;
                  x.c = [v];
                }
                return;
              }
              str2 = String(v);
            } else {
              if (!isNumeric2.test(str2 = String(v)))
                return parseNumeric(x, str2, isNum);
              x.s = str2.charCodeAt(0) == 45 ? (str2 = str2.slice(1), -1) : 1;
            }
            if ((e = str2.indexOf(".")) > -1)
              str2 = str2.replace(".", "");
            if ((i = str2.search(/e/i)) > 0) {
              if (e < 0)
                e = i;
              e += +str2.slice(i + 1);
              str2 = str2.substring(0, i);
            } else if (e < 0) {
              e = str2.length;
            }
          } else {
            intCheck2(b, 2, ALPHABET.length, "Base");
            if (b == 10 && alphabetHasNormalDecimalDigits) {
              x = new BigNumber3(v);
              return round2(x, DECIMAL_PLACES + x.e + 1, ROUNDING_MODE);
            }
            str2 = String(v);
            if (isNum = typeof v == "number") {
              if (v * 0 != 0)
                return parseNumeric(x, str2, isNum, b);
              x.s = 1 / v < 0 ? (str2 = str2.slice(1), -1) : 1;
              if (BigNumber3.DEBUG && str2.replace(/^0\.0*|\./, "").length > 15) {
                throw Error(tooManyDigits2 + v);
              }
            } else {
              x.s = str2.charCodeAt(0) === 45 ? (str2 = str2.slice(1), -1) : 1;
            }
            alphabet = ALPHABET.slice(0, b);
            e = i = 0;
            for (len = str2.length; i < len; i++) {
              if (alphabet.indexOf(c = str2.charAt(i)) < 0) {
                if (c == ".") {
                  if (i > e) {
                    e = len;
                    continue;
                  }
                } else if (!caseChanged) {
                  if (str2 == str2.toUpperCase() && (str2 = str2.toLowerCase()) || str2 == str2.toLowerCase() && (str2 = str2.toUpperCase())) {
                    caseChanged = true;
                    i = -1;
                    e = 0;
                    continue;
                  }
                }
                return parseNumeric(x, String(v), isNum, b);
              }
            }
            isNum = false;
            str2 = convertBase2(str2, b, 10, x.s);
            if ((e = str2.indexOf(".")) > -1)
              str2 = str2.replace(".", "");
            else
              e = str2.length;
          }
          for (i = 0; str2.charCodeAt(i) === 48; i++)
            ;
          for (len = str2.length; str2.charCodeAt(--len) === 48; )
            ;
          if (str2 = str2.slice(i, ++len)) {
            len -= i;
            if (isNum && BigNumber3.DEBUG && len > 15 && (v > MAX_SAFE_INTEGER3 || v !== mathfloor3(v))) {
              throw Error(tooManyDigits2 + x.s * v);
            }
            if ((e = e - i - 1) > MAX_EXP) {
              x.c = x.e = null;
            } else if (e < MIN_EXP) {
              x.c = [x.e = 0];
            } else {
              x.e = e;
              x.c = [];
              i = (e + 1) % LOG_BASE3;
              if (e < 0)
                i += LOG_BASE3;
              if (i < len) {
                if (i)
                  x.c.push(+str2.slice(0, i));
                for (len -= LOG_BASE3; i < len; ) {
                  x.c.push(+str2.slice(i, i += LOG_BASE3));
                }
                i = LOG_BASE3 - (str2 = str2.slice(i)).length;
              } else {
                i -= len;
              }
              for (; i--; str2 += "0")
                ;
              x.c.push(+str2);
            }
          } else {
            x.c = [x.e = 0];
          }
        }
        BigNumber3.clone = clone3;
        BigNumber3.ROUND_UP = 0;
        BigNumber3.ROUND_DOWN = 1;
        BigNumber3.ROUND_CEIL = 2;
        BigNumber3.ROUND_FLOOR = 3;
        BigNumber3.ROUND_HALF_UP = 4;
        BigNumber3.ROUND_HALF_DOWN = 5;
        BigNumber3.ROUND_HALF_EVEN = 6;
        BigNumber3.ROUND_HALF_CEIL = 7;
        BigNumber3.ROUND_HALF_FLOOR = 8;
        BigNumber3.EUCLID = 9;
        BigNumber3.config = BigNumber3.set = function(obj) {
          var p, v;
          if (obj != null) {
            if (typeof obj == "object") {
              if (obj.hasOwnProperty(p = "DECIMAL_PLACES")) {
                v = obj[p];
                intCheck2(v, 0, MAX2, p);
                DECIMAL_PLACES = v;
              }
              if (obj.hasOwnProperty(p = "ROUNDING_MODE")) {
                v = obj[p];
                intCheck2(v, 0, 8, p);
                ROUNDING_MODE = v;
              }
              if (obj.hasOwnProperty(p = "EXPONENTIAL_AT")) {
                v = obj[p];
                if (v && v.pop) {
                  intCheck2(v[0], -MAX2, 0, p);
                  intCheck2(v[1], 0, MAX2, p);
                  TO_EXP_NEG = v[0];
                  TO_EXP_POS = v[1];
                } else {
                  intCheck2(v, -MAX2, MAX2, p);
                  TO_EXP_NEG = -(TO_EXP_POS = v < 0 ? -v : v);
                }
              }
              if (obj.hasOwnProperty(p = "RANGE")) {
                v = obj[p];
                if (v && v.pop) {
                  intCheck2(v[0], -MAX2, -1, p);
                  intCheck2(v[1], 1, MAX2, p);
                  MIN_EXP = v[0];
                  MAX_EXP = v[1];
                } else {
                  intCheck2(v, -MAX2, MAX2, p);
                  if (v) {
                    MIN_EXP = -(MAX_EXP = v < 0 ? -v : v);
                  } else {
                    throw Error(bignumberError2 + p + " cannot be zero: " + v);
                  }
                }
              }
              if (obj.hasOwnProperty(p = "CRYPTO")) {
                v = obj[p];
                if (v === !!v) {
                  if (v) {
                    if (typeof crypto != "undefined" && crypto && (crypto.getRandomValues || crypto.randomBytes)) {
                      CRYPTO = v;
                    } else {
                      CRYPTO = !v;
                      throw Error(bignumberError2 + "crypto unavailable");
                    }
                  } else {
                    CRYPTO = v;
                  }
                } else {
                  throw Error(bignumberError2 + p + " not true or false: " + v);
                }
              }
              if (obj.hasOwnProperty(p = "MODULO_MODE")) {
                v = obj[p];
                intCheck2(v, 0, 9, p);
                MODULO_MODE = v;
              }
              if (obj.hasOwnProperty(p = "POW_PRECISION")) {
                v = obj[p];
                intCheck2(v, 0, MAX2, p);
                POW_PRECISION = v;
              }
              if (obj.hasOwnProperty(p = "FORMAT")) {
                v = obj[p];
                if (typeof v == "object")
                  FORMAT = v;
                else
                  throw Error(bignumberError2 + p + " not an object: " + v);
              }
              if (obj.hasOwnProperty(p = "ALPHABET")) {
                v = obj[p];
                if (typeof v == "string" && !/^.?$|[+\-.\s]|(.).*\1/.test(v)) {
                  alphabetHasNormalDecimalDigits = v.slice(0, 10) == "0123456789";
                  ALPHABET = v;
                } else {
                  throw Error(bignumberError2 + p + " invalid: " + v);
                }
              }
            } else {
              throw Error(bignumberError2 + "Object expected: " + obj);
            }
          }
          return {
            DECIMAL_PLACES,
            ROUNDING_MODE,
            EXPONENTIAL_AT: [TO_EXP_NEG, TO_EXP_POS],
            RANGE: [MIN_EXP, MAX_EXP],
            CRYPTO,
            MODULO_MODE,
            POW_PRECISION,
            FORMAT,
            ALPHABET
          };
        };
        BigNumber3.isBigNumber = function(v) {
          if (!v || v._isBigNumber !== true)
            return false;
          if (!BigNumber3.DEBUG)
            return true;
          var i, n, c = v.c, e = v.e, s = v.s;
          out:
            if ({}.toString.call(c) == "[object Array]") {
              if ((s === 1 || s === -1) && e >= -MAX2 && e <= MAX2 && e === mathfloor3(e)) {
                if (c[0] === 0) {
                  if (e === 0 && c.length === 1)
                    return true;
                  break out;
                }
                i = (e + 1) % LOG_BASE3;
                if (i < 1)
                  i += LOG_BASE3;
                if (String(c[0]).length == i) {
                  for (i = 0; i < c.length; i++) {
                    n = c[i];
                    if (n < 0 || n >= BASE3 || n !== mathfloor3(n))
                      break out;
                  }
                  if (n !== 0)
                    return true;
                }
              }
            } else if (c === null && e === null && (s === null || s === 1 || s === -1)) {
              return true;
            }
          throw Error(bignumberError2 + "Invalid BigNumber: " + v);
        };
        BigNumber3.maximum = BigNumber3.max = function() {
          return maxOrMin2(arguments, -1);
        };
        BigNumber3.minimum = BigNumber3.min = function() {
          return maxOrMin2(arguments, 1);
        };
        BigNumber3.random = function() {
          var pow2_53 = 9007199254740992;
          var random53bitInt = Math.random() * pow2_53 & 2097151 ? function() {
            return mathfloor3(Math.random() * pow2_53);
          } : function() {
            return (Math.random() * 1073741824 | 0) * 8388608 + (Math.random() * 8388608 | 0);
          };
          return function(dp) {
            var a, b, e, k, v, i = 0, c = [], rand = new BigNumber3(ONE2);
            if (dp == null)
              dp = DECIMAL_PLACES;
            else
              intCheck2(dp, 0, MAX2);
            k = mathceil2(dp / LOG_BASE3);
            if (CRYPTO) {
              if (crypto.getRandomValues) {
                a = crypto.getRandomValues(new Uint32Array(k *= 2));
                for (; i < k; ) {
                  v = a[i] * 131072 + (a[i + 1] >>> 11);
                  if (v >= 9e15) {
                    b = crypto.getRandomValues(new Uint32Array(2));
                    a[i] = b[0];
                    a[i + 1] = b[1];
                  } else {
                    c.push(v % 1e14);
                    i += 2;
                  }
                }
                i = k / 2;
              } else if (crypto.randomBytes) {
                a = crypto.randomBytes(k *= 7);
                for (; i < k; ) {
                  v = (a[i] & 31) * 281474976710656 + a[i + 1] * 1099511627776 + a[i + 2] * 4294967296 + a[i + 3] * 16777216 + (a[i + 4] << 16) + (a[i + 5] << 8) + a[i + 6];
                  if (v >= 9e15) {
                    crypto.randomBytes(7).copy(a, i);
                  } else {
                    c.push(v % 1e14);
                    i += 7;
                  }
                }
                i = k / 7;
              } else {
                CRYPTO = false;
                throw Error(bignumberError2 + "crypto unavailable");
              }
            }
            if (!CRYPTO) {
              for (; i < k; ) {
                v = random53bitInt();
                if (v < 9e15)
                  c[i++] = v % 1e14;
              }
            }
            k = c[--i];
            dp %= LOG_BASE3;
            if (k && dp) {
              v = POWS_TEN2[LOG_BASE3 - dp];
              c[i] = mathfloor3(k / v) * v;
            }
            for (; c[i] === 0; c.pop(), i--)
              ;
            if (i < 0) {
              c = [e = 0];
            } else {
              for (e = -1; c[0] === 0; c.splice(0, 1), e -= LOG_BASE3)
                ;
              for (i = 1, v = c[0]; v >= 10; v /= 10, i++)
                ;
              if (i < LOG_BASE3)
                e -= LOG_BASE3 - i;
            }
            rand.e = e;
            rand.c = c;
            return rand;
          };
        }();
        BigNumber3.sum = function() {
          var i = 1, args = arguments, sum2 = new BigNumber3(args[0]);
          for (; i < args.length; )
            sum2 = sum2.plus(args[i++]);
          return sum2;
        };
        convertBase2 = /* @__PURE__ */ function() {
          var decimal = "0123456789";
          function toBaseOut(str2, baseIn, baseOut, alphabet) {
            var j, arr = [0], arrL, i = 0, len = str2.length;
            for (; i < len; ) {
              for (arrL = arr.length; arrL--; arr[arrL] *= baseIn)
                ;
              arr[0] += alphabet.indexOf(str2.charAt(i++));
              for (j = 0; j < arr.length; j++) {
                if (arr[j] > baseOut - 1) {
                  if (arr[j + 1] == null)
                    arr[j + 1] = 0;
                  arr[j + 1] += arr[j] / baseOut | 0;
                  arr[j] %= baseOut;
                }
              }
            }
            return arr.reverse();
          }
          return function(str2, baseIn, baseOut, sign2, callerIsToString) {
            var alphabet, d, e, k, r, x, xc, y, i = str2.indexOf("."), dp = DECIMAL_PLACES, rm = ROUNDING_MODE;
            if (i >= 0) {
              k = POW_PRECISION;
              POW_PRECISION = 0;
              str2 = str2.replace(".", "");
              y = new BigNumber3(baseIn);
              x = y.pow(str2.length - i);
              POW_PRECISION = k;
              y.c = toBaseOut(
                toFixedPoint2(coeffToString2(x.c), x.e, "0"),
                10,
                baseOut,
                decimal
              );
              y.e = y.c.length;
            }
            xc = toBaseOut(str2, baseIn, baseOut, callerIsToString ? (alphabet = ALPHABET, decimal) : (alphabet = decimal, ALPHABET));
            e = k = xc.length;
            for (; xc[--k] == 0; xc.pop())
              ;
            if (!xc[0])
              return alphabet.charAt(0);
            if (i < 0) {
              --e;
            } else {
              x.c = xc;
              x.e = e;
              x.s = sign2;
              x = div3(x, y, dp, rm, baseOut);
              xc = x.c;
              r = x.r;
              e = x.e;
            }
            d = e + dp + 1;
            i = xc[d];
            k = baseOut / 2;
            r = r || d < 0 || xc[d + 1] != null;
            r = rm < 4 ? (i != null || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : i > k || i == k && (rm == 4 || r || rm == 6 && xc[d - 1] & 1 || rm == (x.s < 0 ? 8 : 7));
            if (d < 1 || !xc[0]) {
              str2 = r ? toFixedPoint2(alphabet.charAt(1), -dp, alphabet.charAt(0)) : alphabet.charAt(0);
            } else {
              xc.length = d;
              if (r) {
                for (--baseOut; ++xc[--d] > baseOut; ) {
                  xc[d] = 0;
                  if (!d) {
                    ++e;
                    xc = [1].concat(xc);
                  }
                }
              }
              for (k = xc.length; !xc[--k]; )
                ;
              for (i = 0, str2 = ""; i <= k; str2 += alphabet.charAt(xc[i++]))
                ;
              str2 = toFixedPoint2(str2, e, alphabet.charAt(0));
            }
            return str2;
          };
        }();
        div3 = /* @__PURE__ */ function() {
          function multiply(x, k, base) {
            var m, temp, xlo, xhi, carry = 0, i = x.length, klo = k % SQRT_BASE2, khi = k / SQRT_BASE2 | 0;
            for (x = x.slice(); i--; ) {
              xlo = x[i] % SQRT_BASE2;
              xhi = x[i] / SQRT_BASE2 | 0;
              m = khi * xlo + xhi * klo;
              temp = klo * xlo + m % SQRT_BASE2 * SQRT_BASE2 + carry;
              carry = (temp / base | 0) + (m / SQRT_BASE2 | 0) + khi * xhi;
              x[i] = temp % base;
            }
            if (carry)
              x = [carry].concat(x);
            return x;
          }
          function compare3(a, b, aL, bL) {
            var i, cmp;
            if (aL != bL) {
              cmp = aL > bL ? 1 : -1;
            } else {
              for (i = cmp = 0; i < aL; i++) {
                if (a[i] != b[i]) {
                  cmp = a[i] > b[i] ? 1 : -1;
                  break;
                }
              }
            }
            return cmp;
          }
          function subtract(a, b, aL, base) {
            var i = 0;
            for (; aL--; ) {
              a[aL] -= i;
              i = a[aL] < b[aL] ? 1 : 0;
              a[aL] = i * base + a[aL] - b[aL];
            }
            for (; !a[0] && a.length > 1; a.splice(0, 1))
              ;
          }
          return function(x, y, dp, rm, base) {
            var cmp, e, i, more, n, prod, prodL, q, qc, rem, remL, rem0, xi, xL, yc0, yL, yz, s = x.s == y.s ? 1 : -1, xc = x.c, yc = y.c;
            if (!xc || !xc[0] || !yc || !yc[0]) {
              return new BigNumber3(
                // Return NaN if either NaN, or both Infinity or 0.
                !x.s || !y.s || (xc ? yc && xc[0] == yc[0] : !yc) ? NaN : (
                  // Return 0 if x is 0 or y is Infinity, or return Infinity as y is 0.
                  xc && xc[0] == 0 || !yc ? s * 0 : s / 0
                )
              );
            }
            q = new BigNumber3(s);
            qc = q.c = [];
            e = x.e - y.e;
            s = dp + e + 1;
            if (!base) {
              base = BASE3;
              e = bitFloor2(x.e / LOG_BASE3) - bitFloor2(y.e / LOG_BASE3);
              s = s / LOG_BASE3 | 0;
            }
            for (i = 0; yc[i] == (xc[i] || 0); i++)
              ;
            if (yc[i] > (xc[i] || 0))
              e--;
            if (s < 0) {
              qc.push(1);
              more = true;
            } else {
              xL = xc.length;
              yL = yc.length;
              i = 0;
              s += 2;
              n = mathfloor3(base / (yc[0] + 1));
              if (n > 1) {
                yc = multiply(yc, n, base);
                xc = multiply(xc, n, base);
                yL = yc.length;
                xL = xc.length;
              }
              xi = yL;
              rem = xc.slice(0, yL);
              remL = rem.length;
              for (; remL < yL; rem[remL++] = 0)
                ;
              yz = yc.slice();
              yz = [0].concat(yz);
              yc0 = yc[0];
              if (yc[1] >= base / 2)
                yc0++;
              do {
                n = 0;
                cmp = compare3(yc, rem, yL, remL);
                if (cmp < 0) {
                  rem0 = rem[0];
                  if (yL != remL)
                    rem0 = rem0 * base + (rem[1] || 0);
                  n = mathfloor3(rem0 / yc0);
                  if (n > 1) {
                    if (n >= base)
                      n = base - 1;
                    prod = multiply(yc, n, base);
                    prodL = prod.length;
                    remL = rem.length;
                    while (compare3(prod, rem, prodL, remL) == 1) {
                      n--;
                      subtract(prod, yL < prodL ? yz : yc, prodL, base);
                      prodL = prod.length;
                      cmp = 1;
                    }
                  } else {
                    if (n == 0) {
                      cmp = n = 1;
                    }
                    prod = yc.slice();
                    prodL = prod.length;
                  }
                  if (prodL < remL)
                    prod = [0].concat(prod);
                  subtract(rem, prod, remL, base);
                  remL = rem.length;
                  if (cmp == -1) {
                    while (compare3(yc, rem, yL, remL) < 1) {
                      n++;
                      subtract(rem, yL < remL ? yz : yc, remL, base);
                      remL = rem.length;
                    }
                  }
                } else if (cmp === 0) {
                  n++;
                  rem = [0];
                }
                qc[i++] = n;
                if (rem[0]) {
                  rem[remL++] = xc[xi] || 0;
                } else {
                  rem = [xc[xi]];
                  remL = 1;
                }
              } while ((xi++ < xL || rem[0] != null) && s--);
              more = rem[0] != null;
              if (!qc[0])
                qc.splice(0, 1);
            }
            if (base == BASE3) {
              for (i = 1, s = qc[0]; s >= 10; s /= 10, i++)
                ;
              round2(q, dp + (q.e = i + e * LOG_BASE3 - 1) + 1, rm, more);
            } else {
              q.e = e;
              q.r = +more;
            }
            return q;
          };
        }();
        function format(n, i, rm, id) {
          var c0, e, ne, len, str2;
          if (rm == null)
            rm = ROUNDING_MODE;
          else
            intCheck2(rm, 0, 8);
          if (!n.c)
            return n.toString();
          c0 = n.c[0];
          ne = n.e;
          if (i == null) {
            str2 = coeffToString2(n.c);
            str2 = id == 1 || id == 2 && (ne <= TO_EXP_NEG || ne >= TO_EXP_POS) ? toExponential2(str2, ne) : toFixedPoint2(str2, ne, "0");
          } else {
            n = round2(new BigNumber3(n), i, rm);
            e = n.e;
            str2 = coeffToString2(n.c);
            len = str2.length;
            if (id == 1 || id == 2 && (i <= e || e <= TO_EXP_NEG)) {
              for (; len < i; str2 += "0", len++)
                ;
              str2 = toExponential2(str2, e);
            } else {
              i -= ne + (id === 2 && e > ne);
              str2 = toFixedPoint2(str2, e, "0");
              if (e + 1 > len) {
                if (--i > 0)
                  for (str2 += "."; i--; str2 += "0")
                    ;
              } else {
                i += e - len;
                if (i > 0) {
                  if (e + 1 == len)
                    str2 += ".";
                  for (; i--; str2 += "0")
                    ;
                }
              }
            }
          }
          return n.s < 0 && c0 ? "-" + str2 : str2;
        }
        function maxOrMin2(args, n) {
          var k, y, i = 1, x = new BigNumber3(args[0]);
          for (; i < args.length; i++) {
            y = new BigNumber3(args[i]);
            if (!y.s || (k = compare2(x, y)) === n || k === 0 && x.s === n) {
              x = y;
            }
          }
          return x;
        }
        function normalise(n, c, e) {
          var i = 1, j = c.length;
          for (; !c[--j]; c.pop())
            ;
          for (j = c[0]; j >= 10; j /= 10, i++)
            ;
          if ((e = i + e * LOG_BASE3 - 1) > MAX_EXP) {
            n.c = n.e = null;
          } else if (e < MIN_EXP) {
            n.c = [n.e = 0];
          } else {
            n.e = e;
            n.c = c;
          }
          return n;
        }
        parseNumeric = /* @__PURE__ */ function() {
          var basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i, dotAfter = /^([^.]+)\.$/, dotBefore = /^\.([^.]+)$/, isInfinityOrNaN = /^-?(Infinity|NaN)$/, whitespaceOrPlus = /^\s*\+(?=[\w.])|^\s+|\s+$/g;
          return function(x, str2, isNum, b) {
            var base, s = isNum ? str2 : str2.replace(whitespaceOrPlus, "");
            if (isInfinityOrNaN.test(s)) {
              x.s = isNaN(s) ? null : s < 0 ? -1 : 1;
            } else {
              if (!isNum) {
                s = s.replace(basePrefix, function(m, p1, p2) {
                  base = (p2 = p2.toLowerCase()) == "x" ? 16 : p2 == "b" ? 2 : 8;
                  return !b || b == base ? p1 : m;
                });
                if (b) {
                  base = b;
                  s = s.replace(dotAfter, "$1").replace(dotBefore, "0.$1");
                }
                if (str2 != s)
                  return new BigNumber3(s, base);
              }
              if (BigNumber3.DEBUG) {
                throw Error(bignumberError2 + "Not a" + (b ? " base " + b : "") + " number: " + str2);
              }
              x.s = null;
            }
            x.c = x.e = null;
          };
        }();
        function round2(x, sd, rm, r) {
          var d, i, j, k, n, ni, rd, xc = x.c, pows10 = POWS_TEN2;
          if (xc) {
            out: {
              for (d = 1, k = xc[0]; k >= 10; k /= 10, d++)
                ;
              i = sd - d;
              if (i < 0) {
                i += LOG_BASE3;
                j = sd;
                n = xc[ni = 0];
                rd = mathfloor3(n / pows10[d - j - 1] % 10);
              } else {
                ni = mathceil2((i + 1) / LOG_BASE3);
                if (ni >= xc.length) {
                  if (r) {
                    for (; xc.length <= ni; xc.push(0))
                      ;
                    n = rd = 0;
                    d = 1;
                    i %= LOG_BASE3;
                    j = i - LOG_BASE3 + 1;
                  } else {
                    break out;
                  }
                } else {
                  n = k = xc[ni];
                  for (d = 1; k >= 10; k /= 10, d++)
                    ;
                  i %= LOG_BASE3;
                  j = i - LOG_BASE3 + d;
                  rd = j < 0 ? 0 : mathfloor3(n / pows10[d - j - 1] % 10);
                }
              }
              r = r || sd < 0 || // Are there any non-zero digits after the rounding digit?
              // The expression  n % pows10[d - j - 1]  returns all digits of n to the right
              // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.
              xc[ni + 1] != null || (j < 0 ? n : n % pows10[d - j - 1]);
              r = rm < 4 ? (rd || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : rd > 5 || rd == 5 && (rm == 4 || r || rm == 6 && // Check whether the digit to the left of the rounding digit is odd.
              (i > 0 ? j > 0 ? n / pows10[d - j] : 0 : xc[ni - 1]) % 10 & 1 || rm == (x.s < 0 ? 8 : 7));
              if (sd < 1 || !xc[0]) {
                xc.length = 0;
                if (r) {
                  sd -= x.e + 1;
                  xc[0] = pows10[(LOG_BASE3 - sd % LOG_BASE3) % LOG_BASE3];
                  x.e = -sd || 0;
                } else {
                  xc[0] = x.e = 0;
                }
                return x;
              }
              if (i == 0) {
                xc.length = ni;
                k = 1;
                ni--;
              } else {
                xc.length = ni + 1;
                k = pows10[LOG_BASE3 - i];
                xc[ni] = j > 0 ? mathfloor3(n / pows10[d - j] % pows10[j]) * k : 0;
              }
              if (r) {
                for (; ; ) {
                  if (ni == 0) {
                    for (i = 1, j = xc[0]; j >= 10; j /= 10, i++)
                      ;
                    j = xc[0] += k;
                    for (k = 1; j >= 10; j /= 10, k++)
                      ;
                    if (i != k) {
                      x.e++;
                      if (xc[0] == BASE3)
                        xc[0] = 1;
                    }
                    break;
                  } else {
                    xc[ni] += k;
                    if (xc[ni] != BASE3)
                      break;
                    xc[ni--] = 0;
                    k = 1;
                  }
                }
              }
              for (i = xc.length; xc[--i] === 0; xc.pop())
                ;
            }
            if (x.e > MAX_EXP) {
              x.c = x.e = null;
            } else if (x.e < MIN_EXP) {
              x.c = [x.e = 0];
            }
          }
          return x;
        }
        function valueOf(n) {
          var str2, e = n.e;
          if (e === null)
            return n.toString();
          str2 = coeffToString2(n.c);
          str2 = e <= TO_EXP_NEG || e >= TO_EXP_POS ? toExponential2(str2, e) : toFixedPoint2(str2, e, "0");
          return n.s < 0 ? "-" + str2 : str2;
        }
        P2.absoluteValue = P2.abs = function() {
          var x = new BigNumber3(this);
          if (x.s < 0)
            x.s = 1;
          return x;
        };
        P2.comparedTo = function(y, b) {
          return compare2(this, new BigNumber3(y, b));
        };
        P2.decimalPlaces = P2.dp = function(dp, rm) {
          var c, n, v, x = this;
          if (dp != null) {
            intCheck2(dp, 0, MAX2);
            if (rm == null)
              rm = ROUNDING_MODE;
            else
              intCheck2(rm, 0, 8);
            return round2(new BigNumber3(x), dp + x.e + 1, rm);
          }
          if (!(c = x.c))
            return null;
          n = ((v = c.length - 1) - bitFloor2(this.e / LOG_BASE3)) * LOG_BASE3;
          if (v = c[v])
            for (; v % 10 == 0; v /= 10, n--)
              ;
          if (n < 0)
            n = 0;
          return n;
        };
        P2.dividedBy = P2.div = function(y, b) {
          return div3(this, new BigNumber3(y, b), DECIMAL_PLACES, ROUNDING_MODE);
        };
        P2.dividedToIntegerBy = P2.idiv = function(y, b) {
          return div3(this, new BigNumber3(y, b), 0, 1);
        };
        P2.exponentiatedBy = P2.pow = function(n, m) {
          var half, isModExp, i, k, more, nIsBig, nIsNeg, nIsOdd, y, x = this;
          n = new BigNumber3(n);
          if (n.c && !n.isInteger()) {
            throw Error(bignumberError2 + "Exponent not an integer: " + valueOf(n));
          }
          if (m != null)
            m = new BigNumber3(m);
          nIsBig = n.e > 14;
          if (!x.c || !x.c[0] || x.c[0] == 1 && !x.e && x.c.length == 1 || !n.c || !n.c[0]) {
            y = new BigNumber3(Math.pow(+valueOf(x), nIsBig ? n.s * (2 - isOdd3(n)) : +valueOf(n)));
            return m ? y.mod(m) : y;
          }
          nIsNeg = n.s < 0;
          if (m) {
            if (m.c ? !m.c[0] : !m.s)
              return new BigNumber3(NaN);
            isModExp = !nIsNeg && x.isInteger() && m.isInteger();
            if (isModExp)
              x = x.mod(m);
          } else if (n.e > 9 && (x.e > 0 || x.e < -1 || (x.e == 0 ? x.c[0] > 1 || nIsBig && x.c[1] >= 24e7 : x.c[0] < 8e13 || nIsBig && x.c[0] <= 9999975e7))) {
            k = x.s < 0 && isOdd3(n) ? -0 : 0;
            if (x.e > -1)
              k = 1 / k;
            return new BigNumber3(nIsNeg ? 1 / k : k);
          } else if (POW_PRECISION) {
            k = mathceil2(POW_PRECISION / LOG_BASE3 + 2);
          }
          if (nIsBig) {
            half = new BigNumber3(0.5);
            if (nIsNeg)
              n.s = 1;
            nIsOdd = isOdd3(n);
          } else {
            i = Math.abs(+valueOf(n));
            nIsOdd = i % 2;
          }
          y = new BigNumber3(ONE2);
          for (; ; ) {
            if (nIsOdd) {
              y = y.times(x);
              if (!y.c)
                break;
              if (k) {
                if (y.c.length > k)
                  y.c.length = k;
              } else if (isModExp) {
                y = y.mod(m);
              }
            }
            if (i) {
              i = mathfloor3(i / 2);
              if (i === 0)
                break;
              nIsOdd = i % 2;
            } else {
              n = n.times(half);
              round2(n, n.e + 1, 1);
              if (n.e > 14) {
                nIsOdd = isOdd3(n);
              } else {
                i = +valueOf(n);
                if (i === 0)
                  break;
                nIsOdd = i % 2;
              }
            }
            x = x.times(x);
            if (k) {
              if (x.c && x.c.length > k)
                x.c.length = k;
            } else if (isModExp) {
              x = x.mod(m);
            }
          }
          if (isModExp)
            return y;
          if (nIsNeg)
            y = ONE2.div(y);
          return m ? y.mod(m) : k ? round2(y, POW_PRECISION, ROUNDING_MODE, more) : y;
        };
        P2.integerValue = function(rm) {
          var n = new BigNumber3(this);
          if (rm == null)
            rm = ROUNDING_MODE;
          else
            intCheck2(rm, 0, 8);
          return round2(n, n.e + 1, rm);
        };
        P2.isEqualTo = P2.eq = function(y, b) {
          return compare2(this, new BigNumber3(y, b)) === 0;
        };
        P2.isFinite = function() {
          return !!this.c;
        };
        P2.isGreaterThan = P2.gt = function(y, b) {
          return compare2(this, new BigNumber3(y, b)) > 0;
        };
        P2.isGreaterThanOrEqualTo = P2.gte = function(y, b) {
          return (b = compare2(this, new BigNumber3(y, b))) === 1 || b === 0;
        };
        P2.isInteger = function() {
          return !!this.c && bitFloor2(this.e / LOG_BASE3) > this.c.length - 2;
        };
        P2.isLessThan = P2.lt = function(y, b) {
          return compare2(this, new BigNumber3(y, b)) < 0;
        };
        P2.isLessThanOrEqualTo = P2.lte = function(y, b) {
          return (b = compare2(this, new BigNumber3(y, b))) === -1 || b === 0;
        };
        P2.isNaN = function() {
          return !this.s;
        };
        P2.isNegative = function() {
          return this.s < 0;
        };
        P2.isPositive = function() {
          return this.s > 0;
        };
        P2.isZero = function() {
          return !!this.c && this.c[0] == 0;
        };
        P2.minus = function(y, b) {
          var i, j, t, xLTy, x = this, a = x.s;
          y = new BigNumber3(y, b);
          b = y.s;
          if (!a || !b)
            return new BigNumber3(NaN);
          if (a != b) {
            y.s = -b;
            return x.plus(y);
          }
          var xe = x.e / LOG_BASE3, ye = y.e / LOG_BASE3, xc = x.c, yc = y.c;
          if (!xe || !ye) {
            if (!xc || !yc)
              return xc ? (y.s = -b, y) : new BigNumber3(yc ? x : NaN);
            if (!xc[0] || !yc[0]) {
              return yc[0] ? (y.s = -b, y) : new BigNumber3(xc[0] ? x : (
                // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity
                ROUNDING_MODE == 3 ? -0 : 0
              ));
            }
          }
          xe = bitFloor2(xe);
          ye = bitFloor2(ye);
          xc = xc.slice();
          if (a = xe - ye) {
            if (xLTy = a < 0) {
              a = -a;
              t = xc;
            } else {
              ye = xe;
              t = yc;
            }
            t.reverse();
            for (b = a; b--; t.push(0))
              ;
            t.reverse();
          } else {
            j = (xLTy = (a = xc.length) < (b = yc.length)) ? a : b;
            for (a = b = 0; b < j; b++) {
              if (xc[b] != yc[b]) {
                xLTy = xc[b] < yc[b];
                break;
              }
            }
          }
          if (xLTy) {
            t = xc;
            xc = yc;
            yc = t;
            y.s = -y.s;
          }
          b = (j = yc.length) - (i = xc.length);
          if (b > 0)
            for (; b--; xc[i++] = 0)
              ;
          b = BASE3 - 1;
          for (; j > a; ) {
            if (xc[--j] < yc[j]) {
              for (i = j; i && !xc[--i]; xc[i] = b)
                ;
              --xc[i];
              xc[j] += BASE3;
            }
            xc[j] -= yc[j];
          }
          for (; xc[0] == 0; xc.splice(0, 1), --ye)
            ;
          if (!xc[0]) {
            y.s = ROUNDING_MODE == 3 ? -1 : 1;
            y.c = [y.e = 0];
            return y;
          }
          return normalise(y, xc, ye);
        };
        P2.modulo = P2.mod = function(y, b) {
          var q, s, x = this;
          y = new BigNumber3(y, b);
          if (!x.c || !y.s || y.c && !y.c[0]) {
            return new BigNumber3(NaN);
          } else if (!y.c || x.c && !x.c[0]) {
            return new BigNumber3(x);
          }
          if (MODULO_MODE == 9) {
            s = y.s;
            y.s = 1;
            q = div3(x, y, 0, 3);
            y.s = s;
            q.s *= s;
          } else {
            q = div3(x, y, 0, MODULO_MODE);
          }
          y = x.minus(q.times(y));
          if (!y.c[0] && MODULO_MODE == 1)
            y.s = x.s;
          return y;
        };
        P2.multipliedBy = P2.times = function(y, b) {
          var c, e, i, j, k, m, xcL, xlo, xhi, ycL, ylo, yhi, zc, base, sqrtBase, x = this, xc = x.c, yc = (y = new BigNumber3(y, b)).c;
          if (!xc || !yc || !xc[0] || !yc[0]) {
            if (!x.s || !y.s || xc && !xc[0] && !yc || yc && !yc[0] && !xc) {
              y.c = y.e = y.s = null;
            } else {
              y.s *= x.s;
              if (!xc || !yc) {
                y.c = y.e = null;
              } else {
                y.c = [0];
                y.e = 0;
              }
            }
            return y;
          }
          e = bitFloor2(x.e / LOG_BASE3) + bitFloor2(y.e / LOG_BASE3);
          y.s *= x.s;
          xcL = xc.length;
          ycL = yc.length;
          if (xcL < ycL) {
            zc = xc;
            xc = yc;
            yc = zc;
            i = xcL;
            xcL = ycL;
            ycL = i;
          }
          for (i = xcL + ycL, zc = []; i--; zc.push(0))
            ;
          base = BASE3;
          sqrtBase = SQRT_BASE2;
          for (i = ycL; --i >= 0; ) {
            c = 0;
            ylo = yc[i] % sqrtBase;
            yhi = yc[i] / sqrtBase | 0;
            for (k = xcL, j = i + k; j > i; ) {
              xlo = xc[--k] % sqrtBase;
              xhi = xc[k] / sqrtBase | 0;
              m = yhi * xlo + xhi * ylo;
              xlo = ylo * xlo + m % sqrtBase * sqrtBase + zc[j] + c;
              c = (xlo / base | 0) + (m / sqrtBase | 0) + yhi * xhi;
              zc[j--] = xlo % base;
            }
            zc[j] = c;
          }
          if (c) {
            ++e;
          } else {
            zc.splice(0, 1);
          }
          return normalise(y, zc, e);
        };
        P2.negated = function() {
          var x = new BigNumber3(this);
          x.s = -x.s || null;
          return x;
        };
        P2.plus = function(y, b) {
          var t, x = this, a = x.s;
          y = new BigNumber3(y, b);
          b = y.s;
          if (!a || !b)
            return new BigNumber3(NaN);
          if (a != b) {
            y.s = -b;
            return x.minus(y);
          }
          var xe = x.e / LOG_BASE3, ye = y.e / LOG_BASE3, xc = x.c, yc = y.c;
          if (!xe || !ye) {
            if (!xc || !yc)
              return new BigNumber3(a / 0);
            if (!xc[0] || !yc[0])
              return yc[0] ? y : new BigNumber3(xc[0] ? x : a * 0);
          }
          xe = bitFloor2(xe);
          ye = bitFloor2(ye);
          xc = xc.slice();
          if (a = xe - ye) {
            if (a > 0) {
              ye = xe;
              t = yc;
            } else {
              a = -a;
              t = xc;
            }
            t.reverse();
            for (; a--; t.push(0))
              ;
            t.reverse();
          }
          a = xc.length;
          b = yc.length;
          if (a - b < 0) {
            t = yc;
            yc = xc;
            xc = t;
            b = a;
          }
          for (a = 0; b; ) {
            a = (xc[--b] = xc[b] + yc[b] + a) / BASE3 | 0;
            xc[b] = BASE3 === xc[b] ? 0 : xc[b] % BASE3;
          }
          if (a) {
            xc = [a].concat(xc);
            ++ye;
          }
          return normalise(y, xc, ye);
        };
        P2.precision = P2.sd = function(sd, rm) {
          var c, n, v, x = this;
          if (sd != null && sd !== !!sd) {
            intCheck2(sd, 1, MAX2);
            if (rm == null)
              rm = ROUNDING_MODE;
            else
              intCheck2(rm, 0, 8);
            return round2(new BigNumber3(x), sd, rm);
          }
          if (!(c = x.c))
            return null;
          v = c.length - 1;
          n = v * LOG_BASE3 + 1;
          if (v = c[v]) {
            for (; v % 10 == 0; v /= 10, n--)
              ;
            for (v = c[0]; v >= 10; v /= 10, n++)
              ;
          }
          if (sd && x.e + 1 > n)
            n = x.e + 1;
          return n;
        };
        P2.shiftedBy = function(k) {
          intCheck2(k, -MAX_SAFE_INTEGER3, MAX_SAFE_INTEGER3);
          return this.times("1e" + k);
        };
        P2.squareRoot = P2.sqrt = function() {
          var m, n, r, rep, t, x = this, c = x.c, s = x.s, e = x.e, dp = DECIMAL_PLACES + 4, half = new BigNumber3("0.5");
          if (s !== 1 || !c || !c[0]) {
            return new BigNumber3(!s || s < 0 && (!c || c[0]) ? NaN : c ? x : 1 / 0);
          }
          s = Math.sqrt(+valueOf(x));
          if (s == 0 || s == 1 / 0) {
            n = coeffToString2(c);
            if ((n.length + e) % 2 == 0)
              n += "0";
            s = Math.sqrt(+n);
            e = bitFloor2((e + 1) / 2) - (e < 0 || e % 2);
            if (s == 1 / 0) {
              n = "5e" + e;
            } else {
              n = s.toExponential();
              n = n.slice(0, n.indexOf("e") + 1) + e;
            }
            r = new BigNumber3(n);
          } else {
            r = new BigNumber3(s + "");
          }
          if (r.c[0]) {
            e = r.e;
            s = e + dp;
            if (s < 3)
              s = 0;
            for (; ; ) {
              t = r;
              r = half.times(t.plus(div3(x, t, dp, 1)));
              if (coeffToString2(t.c).slice(0, s) === (n = coeffToString2(r.c)).slice(0, s)) {
                if (r.e < e)
                  --s;
                n = n.slice(s - 3, s + 1);
                if (n == "9999" || !rep && n == "4999") {
                  if (!rep) {
                    round2(t, t.e + DECIMAL_PLACES + 2, 0);
                    if (t.times(t).eq(x)) {
                      r = t;
                      break;
                    }
                  }
                  dp += 4;
                  s += 4;
                  rep = 1;
                } else {
                  if (!+n || !+n.slice(1) && n.charAt(0) == "5") {
                    round2(r, r.e + DECIMAL_PLACES + 2, 1);
                    m = !r.times(r).eq(x);
                  }
                  break;
                }
              }
            }
          }
          return round2(r, r.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m);
        };
        P2.toExponential = function(dp, rm) {
          if (dp != null) {
            intCheck2(dp, 0, MAX2);
            dp++;
          }
          return format(this, dp, rm, 1);
        };
        P2.toFixed = function(dp, rm) {
          if (dp != null) {
            intCheck2(dp, 0, MAX2);
            dp = dp + this.e + 1;
          }
          return format(this, dp, rm);
        };
        P2.toFormat = function(dp, rm, format2) {
          var str2, x = this;
          if (format2 == null) {
            if (dp != null && rm && typeof rm == "object") {
              format2 = rm;
              rm = null;
            } else if (dp && typeof dp == "object") {
              format2 = dp;
              dp = rm = null;
            } else {
              format2 = FORMAT;
            }
          } else if (typeof format2 != "object") {
            throw Error(bignumberError2 + "Argument not an object: " + format2);
          }
          str2 = x.toFixed(dp, rm);
          if (x.c) {
            var i, arr = str2.split("."), g1 = +format2.groupSize, g2 = +format2.secondaryGroupSize, groupSeparator = format2.groupSeparator || "", intPart = arr[0], fractionPart = arr[1], isNeg = x.s < 0, intDigits = isNeg ? intPart.slice(1) : intPart, len = intDigits.length;
            if (g2) {
              i = g1;
              g1 = g2;
              g2 = i;
              len -= i;
            }
            if (g1 > 0 && len > 0) {
              i = len % g1 || g1;
              intPart = intDigits.substr(0, i);
              for (; i < len; i += g1)
                intPart += groupSeparator + intDigits.substr(i, g1);
              if (g2 > 0)
                intPart += groupSeparator + intDigits.slice(i);
              if (isNeg)
                intPart = "-" + intPart;
            }
            str2 = fractionPart ? intPart + (format2.decimalSeparator || "") + ((g2 = +format2.fractionGroupSize) ? fractionPart.replace(
              new RegExp("\\d{" + g2 + "}\\B", "g"),
              "$&" + (format2.fractionGroupSeparator || "")
            ) : fractionPart) : intPart;
          }
          return (format2.prefix || "") + str2 + (format2.suffix || "");
        };
        P2.toFraction = function(md) {
          var d, d0, d1, d2, e, exp2, n, n0, n1, q, r, s, x = this, xc = x.c;
          if (md != null) {
            n = new BigNumber3(md);
            if (!n.isInteger() && (n.c || n.s !== 1) || n.lt(ONE2)) {
              throw Error(bignumberError2 + "Argument " + (n.isInteger() ? "out of range: " : "not an integer: ") + valueOf(n));
            }
          }
          if (!xc)
            return new BigNumber3(x);
          d = new BigNumber3(ONE2);
          n1 = d0 = new BigNumber3(ONE2);
          d1 = n0 = new BigNumber3(ONE2);
          s = coeffToString2(xc);
          e = d.e = s.length - x.e - 1;
          d.c[0] = POWS_TEN2[(exp2 = e % LOG_BASE3) < 0 ? LOG_BASE3 + exp2 : exp2];
          md = !md || n.comparedTo(d) > 0 ? e > 0 ? d : n1 : n;
          exp2 = MAX_EXP;
          MAX_EXP = 1 / 0;
          n = new BigNumber3(s);
          n0.c[0] = 0;
          for (; ; ) {
            q = div3(n, d, 0, 1);
            d2 = d0.plus(q.times(d1));
            if (d2.comparedTo(md) == 1)
              break;
            d0 = d1;
            d1 = d2;
            n1 = n0.plus(q.times(d2 = n1));
            n0 = d2;
            d = n.minus(q.times(d2 = d));
            n = d2;
          }
          d2 = div3(md.minus(d0), d1, 0, 1);
          n0 = n0.plus(d2.times(n1));
          d0 = d0.plus(d2.times(d1));
          n0.s = n1.s = x.s;
          e = e * 2;
          r = div3(n1, d1, e, ROUNDING_MODE).minus(x).abs().comparedTo(
            div3(n0, d0, e, ROUNDING_MODE).minus(x).abs()
          ) < 1 ? [n1, d1] : [n0, d0];
          MAX_EXP = exp2;
          return r;
        };
        P2.toNumber = function() {
          return +valueOf(this);
        };
        P2.toPrecision = function(sd, rm) {
          if (sd != null)
            intCheck2(sd, 1, MAX2);
          return format(this, sd, rm, 2);
        };
        P2.toString = function(b) {
          var str2, n = this, s = n.s, e = n.e;
          if (e === null) {
            if (s) {
              str2 = "Infinity";
              if (s < 0)
                str2 = "-" + str2;
            } else {
              str2 = "NaN";
            }
          } else {
            if (b == null) {
              str2 = e <= TO_EXP_NEG || e >= TO_EXP_POS ? toExponential2(coeffToString2(n.c), e) : toFixedPoint2(coeffToString2(n.c), e, "0");
            } else if (b === 10 && alphabetHasNormalDecimalDigits) {
              n = round2(new BigNumber3(n), DECIMAL_PLACES + e + 1, ROUNDING_MODE);
              str2 = toFixedPoint2(coeffToString2(n.c), n.e, "0");
            } else {
              intCheck2(b, 2, ALPHABET.length, "Base");
              str2 = convertBase2(toFixedPoint2(coeffToString2(n.c), e, "0"), 10, b, s, true);
            }
            if (s < 0 && n.c[0])
              str2 = "-" + str2;
          }
          return str2;
        };
        P2.valueOf = P2.toJSON = function() {
          return valueOf(this);
        };
        P2._isBigNumber = true;
        if (configObject != null)
          BigNumber3.set(configObject);
        return BigNumber3;
      }
      function bitFloor2(n) {
        var i = n | 0;
        return n > 0 || n === i ? i : i - 1;
      }
      function coeffToString2(a) {
        var s, z, i = 1, j = a.length, r = a[0] + "";
        for (; i < j; ) {
          s = a[i++] + "";
          z = LOG_BASE3 - s.length;
          for (; z--; s = "0" + s)
            ;
          r += s;
        }
        for (j = r.length; r.charCodeAt(--j) === 48; )
          ;
        return r.slice(0, j + 1 || 1);
      }
      function compare2(x, y) {
        var a, b, xc = x.c, yc = y.c, i = x.s, j = y.s, k = x.e, l = y.e;
        if (!i || !j)
          return null;
        a = xc && !xc[0];
        b = yc && !yc[0];
        if (a || b)
          return a ? b ? 0 : -j : i;
        if (i != j)
          return i;
        a = i < 0;
        b = k == l;
        if (!xc || !yc)
          return b ? 0 : !xc ^ a ? 1 : -1;
        if (!b)
          return k > l ^ a ? 1 : -1;
        j = (k = xc.length) < (l = yc.length) ? k : l;
        for (i = 0; i < j; i++)
          if (xc[i] != yc[i])
            return xc[i] > yc[i] ^ a ? 1 : -1;
        return k == l ? 0 : k > l ^ a ? 1 : -1;
      }
      function intCheck2(n, min2, max2, name) {
        if (n < min2 || n > max2 || n !== mathfloor3(n)) {
          throw Error(bignumberError2 + (name || "Argument") + (typeof n == "number" ? n < min2 || n > max2 ? " out of range: " : " not an integer: " : " not a primitive number: ") + String(n));
        }
      }
      function isOdd3(n) {
        var k = n.c.length - 1;
        return bitFloor2(n.e / LOG_BASE3) == k && n.c[k] % 2 != 0;
      }
      function toExponential2(str2, e) {
        return (str2.length > 1 ? str2.charAt(0) + "." + str2.slice(1) : str2) + (e < 0 ? "e" : "e+") + e;
      }
      function toFixedPoint2(str2, e, z) {
        var len, zs;
        if (e < 0) {
          for (zs = z + "."; ++e; zs += z)
            ;
          str2 = zs + str2;
        } else {
          len = str2.length;
          if (++e > len) {
            for (zs = z, e -= len; --e; zs += z)
              ;
            str2 += zs;
          } else if (e < len) {
            str2 = str2.slice(0, e) + "." + str2.slice(e);
          }
        }
        return str2;
      }
      BigNumber2 = clone3();
      BigNumber2["default"] = BigNumber2.BigNumber = BigNumber2;
      if (typeof define == "function" && define.amd) {
        define(function() {
          return BigNumber2;
        });
      } else if (typeof module2 != "undefined" && module2.exports) {
        module2.exports = BigNumber2;
      } else {
        if (!globalObject) {
          globalObject = typeof self != "undefined" && self ? self : window;
        }
        globalObject.BigNumber = BigNumber2;
      }
    })(exports2);
  }
});

// node_modules/@solana/buffer-layout-utils/lib/cjs/decimal.js
var require_decimal = __commonJS({
  "node_modules/@solana/buffer-layout-utils/lib/cjs/decimal.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.decimal = exports2.WAD = void 0;
    var bignumber_js_1 = __importDefault(require_bignumber());
    var base_1 = require_base();
    var bigint_1 = require_bigint();
    exports2.WAD = new bignumber_js_1.default("1e+18");
    var decimal = (property) => {
      const layout = (0, bigint_1.u128)(property);
      const { encode, decode } = (0, base_1.encodeDecode)(layout);
      const decimalLayout = layout;
      decimalLayout.decode = (buffer, offset2) => {
        const src = decode(buffer, offset2).toString();
        return new bignumber_js_1.default(src).div(exports2.WAD);
      };
      decimalLayout.encode = (decimal2, buffer, offset2) => {
        const src = BigInt(decimal2.times(exports2.WAD).integerValue().toString());
        return encode(src, buffer, offset2);
      };
      return decimalLayout;
    };
    exports2.decimal = decimal;
  }
});

// node_modules/@solana/buffer-layout-utils/lib/cjs/native.js
var require_native = __commonJS({
  "node_modules/@solana/buffer-layout-utils/lib/cjs/native.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.bool = void 0;
    var buffer_layout_1 = require_Layout();
    var base_1 = require_base();
    var bool2 = (property) => {
      const layout = (0, buffer_layout_1.u8)(property);
      const { encode, decode } = (0, base_1.encodeDecode)(layout);
      const boolLayout = layout;
      boolLayout.decode = (buffer, offset2) => {
        const src = decode(buffer, offset2);
        return !!src;
      };
      boolLayout.encode = (bool3, buffer, offset2) => {
        const src = Number(bool3);
        return encode(src, buffer, offset2);
      };
      return boolLayout;
    };
    exports2.bool = bool2;
  }
});

// node_modules/@solana/buffer-layout-utils/lib/cjs/web3.js
var require_web3 = __commonJS({
  "node_modules/@solana/buffer-layout-utils/lib/cjs/web3.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.publicKey = void 0;
    var buffer_layout_1 = require_Layout();
    var web3_js_1 = require("@solana/web3.js");
    var base_1 = require_base();
    var publicKey3 = (property) => {
      const layout = (0, buffer_layout_1.blob)(32, property);
      const { encode, decode } = (0, base_1.encodeDecode)(layout);
      const publicKeyLayout = layout;
      publicKeyLayout.decode = (buffer, offset2) => {
        const src = decode(buffer, offset2);
        return new web3_js_1.PublicKey(src);
      };
      publicKeyLayout.encode = (publicKey4, buffer, offset2) => {
        const src = publicKey4.toBuffer();
        return encode(src, buffer, offset2);
      };
      return publicKeyLayout;
    };
    exports2.publicKey = publicKey3;
  }
});

// node_modules/@solana/buffer-layout-utils/lib/cjs/index.js
var require_cjs = __commonJS({
  "node_modules/@solana/buffer-layout-utils/lib/cjs/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_base(), exports2);
    __exportStar(require_bigint(), exports2);
    __exportStar(require_decimal(), exports2);
    __exportStar(require_native(), exports2);
    __exportStar(require_web3(), exports2);
  }
});

// node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/errors.js
var require_errors = __commonJS({
  "node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/errors.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TokenTransferHookPubkeyDataTooSmall = exports2.TokenTransferHookInvalidPubkeyData = exports2.TokenTransferHookAccountDataNotFound = exports2.TokenTransferHookInvalidSeed = exports2.TokenTransferHookAccountNotFound = exports2.TokenUnsupportedInstructionError = exports2.TokenInvalidInstructionTypeError = exports2.TokenInvalidInstructionDataError = exports2.TokenInvalidInstructionKeysError = exports2.TokenInvalidInstructionProgramError = exports2.TokenOwnerOffCurveError = exports2.TokenInvalidOwnerError = exports2.TokenInvalidMintError = exports2.TokenInvalidAccountSizeError = exports2.TokenInvalidAccountOwnerError = exports2.TokenInvalidAccountDataError = exports2.TokenInvalidAccountError = exports2.TokenAccountNotFoundError = exports2.TokenError = void 0;
    var TokenError = class extends Error {
      constructor(message) {
        super(message);
      }
    };
    exports2.TokenError = TokenError;
    var TokenAccountNotFoundError = class extends TokenError {
      constructor() {
        super(...arguments);
        this.name = "TokenAccountNotFoundError";
      }
    };
    exports2.TokenAccountNotFoundError = TokenAccountNotFoundError;
    var TokenInvalidAccountError = class extends TokenError {
      constructor() {
        super(...arguments);
        this.name = "TokenInvalidAccountError";
      }
    };
    exports2.TokenInvalidAccountError = TokenInvalidAccountError;
    var TokenInvalidAccountDataError = class extends TokenError {
      constructor() {
        super(...arguments);
        this.name = "TokenInvalidAccountDataError";
      }
    };
    exports2.TokenInvalidAccountDataError = TokenInvalidAccountDataError;
    var TokenInvalidAccountOwnerError = class extends TokenError {
      constructor() {
        super(...arguments);
        this.name = "TokenInvalidAccountOwnerError";
      }
    };
    exports2.TokenInvalidAccountOwnerError = TokenInvalidAccountOwnerError;
    var TokenInvalidAccountSizeError = class extends TokenError {
      constructor() {
        super(...arguments);
        this.name = "TokenInvalidAccountSizeError";
      }
    };
    exports2.TokenInvalidAccountSizeError = TokenInvalidAccountSizeError;
    var TokenInvalidMintError = class extends TokenError {
      constructor() {
        super(...arguments);
        this.name = "TokenInvalidMintError";
      }
    };
    exports2.TokenInvalidMintError = TokenInvalidMintError;
    var TokenInvalidOwnerError = class extends TokenError {
      constructor() {
        super(...arguments);
        this.name = "TokenInvalidOwnerError";
      }
    };
    exports2.TokenInvalidOwnerError = TokenInvalidOwnerError;
    var TokenOwnerOffCurveError = class extends TokenError {
      constructor() {
        super(...arguments);
        this.name = "TokenOwnerOffCurveError";
      }
    };
    exports2.TokenOwnerOffCurveError = TokenOwnerOffCurveError;
    var TokenInvalidInstructionProgramError = class extends TokenError {
      constructor() {
        super(...arguments);
        this.name = "TokenInvalidInstructionProgramError";
      }
    };
    exports2.TokenInvalidInstructionProgramError = TokenInvalidInstructionProgramError;
    var TokenInvalidInstructionKeysError = class extends TokenError {
      constructor() {
        super(...arguments);
        this.name = "TokenInvalidInstructionKeysError";
      }
    };
    exports2.TokenInvalidInstructionKeysError = TokenInvalidInstructionKeysError;
    var TokenInvalidInstructionDataError = class extends TokenError {
      constructor() {
        super(...arguments);
        this.name = "TokenInvalidInstructionDataError";
      }
    };
    exports2.TokenInvalidInstructionDataError = TokenInvalidInstructionDataError;
    var TokenInvalidInstructionTypeError = class extends TokenError {
      constructor() {
        super(...arguments);
        this.name = "TokenInvalidInstructionTypeError";
      }
    };
    exports2.TokenInvalidInstructionTypeError = TokenInvalidInstructionTypeError;
    var TokenUnsupportedInstructionError = class extends TokenError {
      constructor() {
        super(...arguments);
        this.name = "TokenUnsupportedInstructionError";
      }
    };
    exports2.TokenUnsupportedInstructionError = TokenUnsupportedInstructionError;
    var TokenTransferHookAccountNotFound = class extends TokenError {
      constructor() {
        super(...arguments);
        this.name = "TokenTransferHookAccountNotFound";
      }
    };
    exports2.TokenTransferHookAccountNotFound = TokenTransferHookAccountNotFound;
    var TokenTransferHookInvalidSeed = class extends TokenError {
      constructor() {
        super(...arguments);
        this.name = "TokenTransferHookInvalidSeed";
      }
    };
    exports2.TokenTransferHookInvalidSeed = TokenTransferHookInvalidSeed;
    var TokenTransferHookAccountDataNotFound = class extends TokenError {
      constructor() {
        super(...arguments);
        this.name = "TokenTransferHookAccountDataNotFound";
      }
    };
    exports2.TokenTransferHookAccountDataNotFound = TokenTransferHookAccountDataNotFound;
    var TokenTransferHookInvalidPubkeyData = class extends TokenError {
      constructor() {
        super(...arguments);
        this.name = "TokenTransferHookInvalidPubkeyData";
      }
    };
    exports2.TokenTransferHookInvalidPubkeyData = TokenTransferHookInvalidPubkeyData;
    var TokenTransferHookPubkeyDataTooSmall = class extends TokenError {
      constructor() {
        super(...arguments);
        this.name = "TokenTransferHookPubkeyDataTooSmall";
      }
    };
    exports2.TokenTransferHookPubkeyDataTooSmall = TokenTransferHookPubkeyDataTooSmall;
  }
});

// node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/instructions/types.js
var require_types = __commonJS({
  "node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/instructions/types.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TokenInstruction = void 0;
    var TokenInstruction;
    (function(TokenInstruction2) {
      TokenInstruction2[TokenInstruction2["InitializeMint"] = 0] = "InitializeMint";
      TokenInstruction2[TokenInstruction2["InitializeAccount"] = 1] = "InitializeAccount";
      TokenInstruction2[TokenInstruction2["InitializeMultisig"] = 2] = "InitializeMultisig";
      TokenInstruction2[TokenInstruction2["Transfer"] = 3] = "Transfer";
      TokenInstruction2[TokenInstruction2["Approve"] = 4] = "Approve";
      TokenInstruction2[TokenInstruction2["Revoke"] = 5] = "Revoke";
      TokenInstruction2[TokenInstruction2["SetAuthority"] = 6] = "SetAuthority";
      TokenInstruction2[TokenInstruction2["MintTo"] = 7] = "MintTo";
      TokenInstruction2[TokenInstruction2["Burn"] = 8] = "Burn";
      TokenInstruction2[TokenInstruction2["CloseAccount"] = 9] = "CloseAccount";
      TokenInstruction2[TokenInstruction2["FreezeAccount"] = 10] = "FreezeAccount";
      TokenInstruction2[TokenInstruction2["ThawAccount"] = 11] = "ThawAccount";
      TokenInstruction2[TokenInstruction2["TransferChecked"] = 12] = "TransferChecked";
      TokenInstruction2[TokenInstruction2["ApproveChecked"] = 13] = "ApproveChecked";
      TokenInstruction2[TokenInstruction2["MintToChecked"] = 14] = "MintToChecked";
      TokenInstruction2[TokenInstruction2["BurnChecked"] = 15] = "BurnChecked";
      TokenInstruction2[TokenInstruction2["InitializeAccount2"] = 16] = "InitializeAccount2";
      TokenInstruction2[TokenInstruction2["SyncNative"] = 17] = "SyncNative";
      TokenInstruction2[TokenInstruction2["InitializeAccount3"] = 18] = "InitializeAccount3";
      TokenInstruction2[TokenInstruction2["InitializeMultisig2"] = 19] = "InitializeMultisig2";
      TokenInstruction2[TokenInstruction2["InitializeMint2"] = 20] = "InitializeMint2";
      TokenInstruction2[TokenInstruction2["GetAccountDataSize"] = 21] = "GetAccountDataSize";
      TokenInstruction2[TokenInstruction2["InitializeImmutableOwner"] = 22] = "InitializeImmutableOwner";
      TokenInstruction2[TokenInstruction2["AmountToUiAmount"] = 23] = "AmountToUiAmount";
      TokenInstruction2[TokenInstruction2["UiAmountToAmount"] = 24] = "UiAmountToAmount";
      TokenInstruction2[TokenInstruction2["InitializeMintCloseAuthority"] = 25] = "InitializeMintCloseAuthority";
      TokenInstruction2[TokenInstruction2["TransferFeeExtension"] = 26] = "TransferFeeExtension";
      TokenInstruction2[TokenInstruction2["ConfidentialTransferExtension"] = 27] = "ConfidentialTransferExtension";
      TokenInstruction2[TokenInstruction2["DefaultAccountStateExtension"] = 28] = "DefaultAccountStateExtension";
      TokenInstruction2[TokenInstruction2["Reallocate"] = 29] = "Reallocate";
      TokenInstruction2[TokenInstruction2["MemoTransferExtension"] = 30] = "MemoTransferExtension";
      TokenInstruction2[TokenInstruction2["CreateNativeMint"] = 31] = "CreateNativeMint";
      TokenInstruction2[TokenInstruction2["InitializeNonTransferableMint"] = 32] = "InitializeNonTransferableMint";
      TokenInstruction2[TokenInstruction2["InterestBearingMintExtension"] = 33] = "InterestBearingMintExtension";
      TokenInstruction2[TokenInstruction2["CpiGuardExtension"] = 34] = "CpiGuardExtension";
      TokenInstruction2[TokenInstruction2["InitializePermanentDelegate"] = 35] = "InitializePermanentDelegate";
      TokenInstruction2[TokenInstruction2["TransferHookExtension"] = 36] = "TransferHookExtension";
      TokenInstruction2[TokenInstruction2["MetadataPointerExtension"] = 39] = "MetadataPointerExtension";
      TokenInstruction2[TokenInstruction2["GroupPointerExtension"] = 40] = "GroupPointerExtension";
      TokenInstruction2[TokenInstruction2["GroupMemberPointerExtension"] = 41] = "GroupMemberPointerExtension";
      TokenInstruction2[TokenInstruction2["ScaledUiAmountExtension"] = 43] = "ScaledUiAmountExtension";
      TokenInstruction2[TokenInstruction2["PausableExtension"] = 44] = "PausableExtension";
    })(TokenInstruction || (exports2.TokenInstruction = TokenInstruction = {}));
  }
});

// node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/instructions/amountToUiAmount.js
var require_amountToUiAmount = __commonJS({
  "node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/instructions/amountToUiAmount.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.amountToUiAmountInstructionData = void 0;
    exports2.createAmountToUiAmountInstruction = createAmountToUiAmountInstruction;
    exports2.decodeAmountToUiAmountInstruction = decodeAmountToUiAmountInstruction;
    exports2.decodeAmountToUiAmountInstructionUnchecked = decodeAmountToUiAmountInstructionUnchecked;
    var buffer_layout_1 = require_Layout();
    var buffer_layout_utils_1 = require_cjs();
    var web3_js_1 = require("@solana/web3.js");
    var constants_js_1 = require_constants();
    var errors_js_1 = require_errors();
    var types_js_1 = require_types();
    exports2.amountToUiAmountInstructionData = (0, buffer_layout_1.struct)([
      (0, buffer_layout_1.u8)("instruction"),
      (0, buffer_layout_utils_1.u64)("amount")
    ]);
    function createAmountToUiAmountInstruction(mint, amount, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      const keys = [{ pubkey: mint, isSigner: false, isWritable: false }];
      const data = Buffer.alloc(exports2.amountToUiAmountInstructionData.span);
      exports2.amountToUiAmountInstructionData.encode({
        instruction: types_js_1.TokenInstruction.AmountToUiAmount,
        amount: BigInt(amount)
      }, data);
      return new web3_js_1.TransactionInstruction({ keys, programId, data });
    }
    function decodeAmountToUiAmountInstruction(instruction, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      if (!instruction.programId.equals(programId))
        throw new errors_js_1.TokenInvalidInstructionProgramError();
      if (instruction.data.length !== exports2.amountToUiAmountInstructionData.span)
        throw new errors_js_1.TokenInvalidInstructionDataError();
      const { keys: { mint }, data } = decodeAmountToUiAmountInstructionUnchecked(instruction);
      if (data.instruction !== types_js_1.TokenInstruction.AmountToUiAmount)
        throw new errors_js_1.TokenInvalidInstructionTypeError();
      if (!mint)
        throw new errors_js_1.TokenInvalidInstructionKeysError();
      return {
        programId,
        keys: {
          mint
        },
        data
      };
    }
    function decodeAmountToUiAmountInstructionUnchecked({ programId, keys: [mint], data }) {
      return {
        programId,
        keys: {
          mint
        },
        data: exports2.amountToUiAmountInstructionData.decode(data)
      };
    }
  }
});

// node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/extensions/accountType.js
var require_accountType = __commonJS({
  "node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/extensions/accountType.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ACCOUNT_TYPE_SIZE = exports2.AccountType = void 0;
    var AccountType2;
    (function(AccountType3) {
      AccountType3[AccountType3["Uninitialized"] = 0] = "Uninitialized";
      AccountType3[AccountType3["Mint"] = 1] = "Mint";
      AccountType3[AccountType3["Account"] = 2] = "Account";
    })(AccountType2 || (exports2.AccountType = AccountType2 = {}));
    exports2.ACCOUNT_TYPE_SIZE = 1;
  }
});

// node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/state/multisig.js
var require_multisig = __commonJS({
  "node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/state/multisig.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MULTISIG_SIZE = exports2.MultisigLayout = void 0;
    exports2.getMultisig = getMultisig;
    exports2.unpackMultisig = unpackMultisig;
    exports2.getMinimumBalanceForRentExemptMultisig = getMinimumBalanceForRentExemptMultisig;
    var buffer_layout_1 = require_Layout();
    var buffer_layout_utils_1 = require_cjs();
    var constants_js_1 = require_constants();
    var errors_js_1 = require_errors();
    exports2.MultisigLayout = (0, buffer_layout_1.struct)([
      (0, buffer_layout_1.u8)("m"),
      (0, buffer_layout_1.u8)("n"),
      (0, buffer_layout_utils_1.bool)("isInitialized"),
      (0, buffer_layout_utils_1.publicKey)("signer1"),
      (0, buffer_layout_utils_1.publicKey)("signer2"),
      (0, buffer_layout_utils_1.publicKey)("signer3"),
      (0, buffer_layout_utils_1.publicKey)("signer4"),
      (0, buffer_layout_utils_1.publicKey)("signer5"),
      (0, buffer_layout_utils_1.publicKey)("signer6"),
      (0, buffer_layout_utils_1.publicKey)("signer7"),
      (0, buffer_layout_utils_1.publicKey)("signer8"),
      (0, buffer_layout_utils_1.publicKey)("signer9"),
      (0, buffer_layout_utils_1.publicKey)("signer10"),
      (0, buffer_layout_utils_1.publicKey)("signer11")
    ]);
    exports2.MULTISIG_SIZE = exports2.MultisigLayout.span;
    function getMultisig(connection_1, address_1, commitment_1) {
      return __awaiter(this, arguments, void 0, function* (connection, address, commitment, programId = constants_js_1.TOKEN_PROGRAM_ID) {
        const info = yield connection.getAccountInfo(address, commitment);
        return unpackMultisig(address, info, programId);
      });
    }
    function unpackMultisig(address, info, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      if (!info)
        throw new errors_js_1.TokenAccountNotFoundError();
      if (!info.owner.equals(programId))
        throw new errors_js_1.TokenInvalidAccountOwnerError();
      if (info.data.length != exports2.MULTISIG_SIZE)
        throw new errors_js_1.TokenInvalidAccountSizeError();
      const multisig = exports2.MultisigLayout.decode(info.data);
      return Object.assign({ address }, multisig);
    }
    function getMinimumBalanceForRentExemptMultisig(connection, commitment) {
      return __awaiter(this, void 0, void 0, function* () {
        return yield connection.getMinimumBalanceForRentExemption(exports2.MULTISIG_SIZE, commitment);
      });
    }
  }
});

// node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/state/account.js
var require_account = __commonJS({
  "node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/state/account.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ACCOUNT_SIZE = exports2.AccountLayout = exports2.AccountState = void 0;
    exports2.getAccount = getAccount;
    exports2.getMultipleAccounts = getMultipleAccounts;
    exports2.getMinimumBalanceForRentExemptAccount = getMinimumBalanceForRentExemptAccount;
    exports2.getMinimumBalanceForRentExemptAccountWithExtensions = getMinimumBalanceForRentExemptAccountWithExtensions;
    exports2.unpackAccount = unpackAccount;
    var buffer_layout_1 = require_Layout();
    var buffer_layout_utils_1 = require_cjs();
    var constants_js_1 = require_constants();
    var errors_js_1 = require_errors();
    var accountType_js_1 = require_accountType();
    var extensionType_js_1 = require_extensionType();
    var multisig_js_1 = require_multisig();
    var AccountState2;
    (function(AccountState3) {
      AccountState3[AccountState3["Uninitialized"] = 0] = "Uninitialized";
      AccountState3[AccountState3["Initialized"] = 1] = "Initialized";
      AccountState3[AccountState3["Frozen"] = 2] = "Frozen";
    })(AccountState2 || (exports2.AccountState = AccountState2 = {}));
    exports2.AccountLayout = (0, buffer_layout_1.struct)([
      (0, buffer_layout_utils_1.publicKey)("mint"),
      (0, buffer_layout_utils_1.publicKey)("owner"),
      (0, buffer_layout_utils_1.u64)("amount"),
      (0, buffer_layout_1.u32)("delegateOption"),
      (0, buffer_layout_utils_1.publicKey)("delegate"),
      (0, buffer_layout_1.u8)("state"),
      (0, buffer_layout_1.u32)("isNativeOption"),
      (0, buffer_layout_utils_1.u64)("isNative"),
      (0, buffer_layout_utils_1.u64)("delegatedAmount"),
      (0, buffer_layout_1.u32)("closeAuthorityOption"),
      (0, buffer_layout_utils_1.publicKey)("closeAuthority")
    ]);
    exports2.ACCOUNT_SIZE = exports2.AccountLayout.span;
    function getAccount(connection_1, address_1, commitment_1) {
      return __awaiter(this, arguments, void 0, function* (connection, address, commitment, programId = constants_js_1.TOKEN_PROGRAM_ID) {
        const info = yield connection.getAccountInfo(address, commitment);
        return unpackAccount(address, info, programId);
      });
    }
    function getMultipleAccounts(connection_1, addresses_1, commitment_1) {
      return __awaiter(this, arguments, void 0, function* (connection, addresses, commitment, programId = constants_js_1.TOKEN_PROGRAM_ID) {
        const infos = yield connection.getMultipleAccountsInfo(addresses, commitment);
        return addresses.map((address, i) => unpackAccount(address, infos[i], programId));
      });
    }
    function getMinimumBalanceForRentExemptAccount(connection, commitment) {
      return __awaiter(this, void 0, void 0, function* () {
        return yield getMinimumBalanceForRentExemptAccountWithExtensions(connection, [], commitment);
      });
    }
    function getMinimumBalanceForRentExemptAccountWithExtensions(connection, extensions, commitment) {
      return __awaiter(this, void 0, void 0, function* () {
        const accountLen = (0, extensionType_js_1.getAccountLen)(extensions);
        return yield connection.getMinimumBalanceForRentExemption(accountLen, commitment);
      });
    }
    function unpackAccount(address, info, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      if (!info)
        throw new errors_js_1.TokenAccountNotFoundError();
      if (!info.owner.equals(programId))
        throw new errors_js_1.TokenInvalidAccountOwnerError();
      if (info.data.length < exports2.ACCOUNT_SIZE)
        throw new errors_js_1.TokenInvalidAccountSizeError();
      const rawAccount = exports2.AccountLayout.decode(info.data.slice(0, exports2.ACCOUNT_SIZE));
      let tlvData = Buffer.alloc(0);
      if (info.data.length > exports2.ACCOUNT_SIZE) {
        if (info.data.length === multisig_js_1.MULTISIG_SIZE)
          throw new errors_js_1.TokenInvalidAccountSizeError();
        if (info.data[exports2.ACCOUNT_SIZE] != accountType_js_1.AccountType.Account)
          throw new errors_js_1.TokenInvalidAccountError();
        tlvData = info.data.slice(exports2.ACCOUNT_SIZE + accountType_js_1.ACCOUNT_TYPE_SIZE);
      }
      return {
        address,
        mint: rawAccount.mint,
        owner: rawAccount.owner,
        amount: rawAccount.amount,
        delegate: rawAccount.delegateOption ? rawAccount.delegate : null,
        delegatedAmount: rawAccount.delegatedAmount,
        isInitialized: rawAccount.state !== AccountState2.Uninitialized,
        isFrozen: rawAccount.state === AccountState2.Frozen,
        isNative: !!rawAccount.isNativeOption,
        rentExemptReserve: rawAccount.isNativeOption ? rawAccount.isNative : null,
        closeAuthority: rawAccount.closeAuthorityOption ? rawAccount.closeAuthority : null,
        tlvData
      };
    }
  }
});

// node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/actions/internal.js
var require_internal = __commonJS({
  "node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/actions/internal.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getSigners = getSigners;
    var web3_js_1 = require("@solana/web3.js");
    function getSigners(signerOrMultisig, multiSigners) {
      return signerOrMultisig instanceof web3_js_1.PublicKey ? [signerOrMultisig, multiSigners] : [signerOrMultisig.publicKey, [signerOrMultisig]];
    }
  }
});

// node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/instructions/internal.js
var require_internal2 = __commonJS({
  "node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/instructions/internal.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.addSigners = addSigners;
    var web3_js_1 = require("@solana/web3.js");
    function addSigners(keys, ownerOrAuthority, multiSigners) {
      if (multiSigners.length) {
        keys.push({ pubkey: ownerOrAuthority, isSigner: false, isWritable: false });
        for (const signer of multiSigners) {
          keys.push({
            pubkey: signer instanceof web3_js_1.PublicKey ? signer : signer.publicKey,
            isSigner: true,
            isWritable: false
          });
        }
      } else {
        keys.push({ pubkey: ownerOrAuthority, isSigner: true, isWritable: false });
      }
      return keys;
    }
  }
});

// node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/extensions/cpiGuard/instructions.js
var require_instructions = __commonJS({
  "node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/extensions/cpiGuard/instructions.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.cpiGuardInstructionData = exports2.CpiGuardInstruction = void 0;
    exports2.createEnableCpiGuardInstruction = createEnableCpiGuardInstruction;
    exports2.createDisableCpiGuardInstruction = createDisableCpiGuardInstruction;
    var buffer_layout_1 = require_Layout();
    var web3_js_1 = require("@solana/web3.js");
    var constants_js_1 = require_constants();
    var errors_js_1 = require_errors();
    var internal_js_1 = require_internal2();
    var types_js_1 = require_types();
    var CpiGuardInstruction;
    (function(CpiGuardInstruction2) {
      CpiGuardInstruction2[CpiGuardInstruction2["Enable"] = 0] = "Enable";
      CpiGuardInstruction2[CpiGuardInstruction2["Disable"] = 1] = "Disable";
    })(CpiGuardInstruction || (exports2.CpiGuardInstruction = CpiGuardInstruction = {}));
    exports2.cpiGuardInstructionData = (0, buffer_layout_1.struct)([(0, buffer_layout_1.u8)("instruction"), (0, buffer_layout_1.u8)("cpiGuardInstruction")]);
    function createEnableCpiGuardInstruction(account, authority, multiSigners = [], programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
      return createCpiGuardInstruction(CpiGuardInstruction.Enable, account, authority, multiSigners, programId);
    }
    function createDisableCpiGuardInstruction(account, authority, multiSigners = [], programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
      return createCpiGuardInstruction(CpiGuardInstruction.Disable, account, authority, multiSigners, programId);
    }
    function createCpiGuardInstruction(cpiGuardInstruction, account, authority, multiSigners, programId) {
      if (!(0, constants_js_1.programSupportsExtensions)(programId)) {
        throw new errors_js_1.TokenUnsupportedInstructionError();
      }
      const keys = (0, internal_js_1.addSigners)([{ pubkey: account, isSigner: false, isWritable: true }], authority, multiSigners);
      const data = Buffer.alloc(exports2.cpiGuardInstructionData.span);
      exports2.cpiGuardInstructionData.encode({
        instruction: types_js_1.TokenInstruction.CpiGuardExtension,
        cpiGuardInstruction
      }, data);
      return new web3_js_1.TransactionInstruction({ keys, programId, data });
    }
  }
});

// node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/extensions/cpiGuard/actions.js
var require_actions = __commonJS({
  "node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/extensions/cpiGuard/actions.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.enableCpiGuard = enableCpiGuard;
    exports2.disableCpiGuard = disableCpiGuard;
    var web3_js_1 = require("@solana/web3.js");
    var internal_js_1 = require_internal();
    var constants_js_1 = require_constants();
    var instructions_js_1 = require_instructions();
    function enableCpiGuard(connection_1, payer_1, account_1, owner_1) {
      return __awaiter(this, arguments, void 0, function* (connection, payer, account, owner, multiSigners = [], confirmOptions, programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
        const [ownerPublicKey, signers] = (0, internal_js_1.getSigners)(owner, multiSigners);
        const transaction = new web3_js_1.Transaction().add((0, instructions_js_1.createEnableCpiGuardInstruction)(account, ownerPublicKey, signers, programId));
        return yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer, ...signers], confirmOptions);
      });
    }
    function disableCpiGuard(connection_1, payer_1, account_1, owner_1) {
      return __awaiter(this, arguments, void 0, function* (connection, payer, account, owner, multiSigners = [], confirmOptions, programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
        const [ownerPublicKey, signers] = (0, internal_js_1.getSigners)(owner, multiSigners);
        const transaction = new web3_js_1.Transaction().add((0, instructions_js_1.createDisableCpiGuardInstruction)(account, ownerPublicKey, signers, programId));
        return yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer, ...signers], confirmOptions);
      });
    }
  }
});

// node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/extensions/cpiGuard/state.js
var require_state2 = __commonJS({
  "node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/extensions/cpiGuard/state.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CPI_GUARD_SIZE = exports2.CpiGuardLayout = void 0;
    exports2.getCpiGuard = getCpiGuard;
    var buffer_layout_1 = require_Layout();
    var buffer_layout_utils_1 = require_cjs();
    var extensionType_js_1 = require_extensionType();
    exports2.CpiGuardLayout = (0, buffer_layout_1.struct)([(0, buffer_layout_utils_1.bool)("lockCpi")]);
    exports2.CPI_GUARD_SIZE = exports2.CpiGuardLayout.span;
    function getCpiGuard(account) {
      const extensionData = (0, extensionType_js_1.getExtensionData)(extensionType_js_1.ExtensionType.CpiGuard, account.tlvData);
      if (extensionData !== null) {
        return exports2.CpiGuardLayout.decode(extensionData);
      } else {
        return null;
      }
    }
  }
});

// node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/extensions/cpiGuard/index.js
var require_cpiGuard = __commonJS({
  "node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/extensions/cpiGuard/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_actions(), exports2);
    __exportStar(require_instructions(), exports2);
    __exportStar(require_state2(), exports2);
  }
});

// node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/extensions/defaultAccountState/instructions.js
var require_instructions2 = __commonJS({
  "node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/extensions/defaultAccountState/instructions.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.defaultAccountStateInstructionData = exports2.DefaultAccountStateInstruction = void 0;
    exports2.createInitializeDefaultAccountStateInstruction = createInitializeDefaultAccountStateInstruction;
    exports2.createUpdateDefaultAccountStateInstruction = createUpdateDefaultAccountStateInstruction;
    var buffer_layout_1 = require_Layout();
    var web3_js_1 = require("@solana/web3.js");
    var constants_js_1 = require_constants();
    var errors_js_1 = require_errors();
    var internal_js_1 = require_internal2();
    var types_js_1 = require_types();
    var DefaultAccountStateInstruction;
    (function(DefaultAccountStateInstruction2) {
      DefaultAccountStateInstruction2[DefaultAccountStateInstruction2["Initialize"] = 0] = "Initialize";
      DefaultAccountStateInstruction2[DefaultAccountStateInstruction2["Update"] = 1] = "Update";
    })(DefaultAccountStateInstruction || (exports2.DefaultAccountStateInstruction = DefaultAccountStateInstruction = {}));
    exports2.defaultAccountStateInstructionData = (0, buffer_layout_1.struct)([
      (0, buffer_layout_1.u8)("instruction"),
      (0, buffer_layout_1.u8)("defaultAccountStateInstruction"),
      (0, buffer_layout_1.u8)("accountState")
    ]);
    function createInitializeDefaultAccountStateInstruction(mint, accountState, programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
      if (!(0, constants_js_1.programSupportsExtensions)(programId)) {
        throw new errors_js_1.TokenUnsupportedInstructionError();
      }
      const keys = [{ pubkey: mint, isSigner: false, isWritable: true }];
      const data = Buffer.alloc(exports2.defaultAccountStateInstructionData.span);
      exports2.defaultAccountStateInstructionData.encode({
        instruction: types_js_1.TokenInstruction.DefaultAccountStateExtension,
        defaultAccountStateInstruction: DefaultAccountStateInstruction.Initialize,
        accountState
      }, data);
      return new web3_js_1.TransactionInstruction({ keys, programId, data });
    }
    function createUpdateDefaultAccountStateInstruction(mint, accountState, freezeAuthority, multiSigners = [], programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
      if (!(0, constants_js_1.programSupportsExtensions)(programId)) {
        throw new errors_js_1.TokenUnsupportedInstructionError();
      }
      const keys = (0, internal_js_1.addSigners)([{ pubkey: mint, isSigner: false, isWritable: true }], freezeAuthority, multiSigners);
      const data = Buffer.alloc(exports2.defaultAccountStateInstructionData.span);
      exports2.defaultAccountStateInstructionData.encode({
        instruction: types_js_1.TokenInstruction.DefaultAccountStateExtension,
        defaultAccountStateInstruction: DefaultAccountStateInstruction.Update,
        accountState
      }, data);
      return new web3_js_1.TransactionInstruction({ keys, programId, data });
    }
  }
});

// node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/extensions/defaultAccountState/actions.js
var require_actions2 = __commonJS({
  "node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/extensions/defaultAccountState/actions.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.initializeDefaultAccountState = initializeDefaultAccountState;
    exports2.updateDefaultAccountState = updateDefaultAccountState;
    var web3_js_1 = require("@solana/web3.js");
    var internal_js_1 = require_internal();
    var constants_js_1 = require_constants();
    var instructions_js_1 = require_instructions2();
    function initializeDefaultAccountState(connection_1, payer_1, mint_1, state_1, confirmOptions_1) {
      return __awaiter(this, arguments, void 0, function* (connection, payer, mint, state, confirmOptions, programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
        const transaction = new web3_js_1.Transaction().add((0, instructions_js_1.createInitializeDefaultAccountStateInstruction)(mint, state, programId));
        return yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer], confirmOptions);
      });
    }
    function updateDefaultAccountState(connection_1, payer_1, mint_1, state_1, freezeAuthority_1) {
      return __awaiter(this, arguments, void 0, function* (connection, payer, mint, state, freezeAuthority, multiSigners = [], confirmOptions, programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
        const [freezeAuthorityPublicKey, signers] = (0, internal_js_1.getSigners)(freezeAuthority, multiSigners);
        const transaction = new web3_js_1.Transaction().add((0, instructions_js_1.createUpdateDefaultAccountStateInstruction)(mint, state, freezeAuthorityPublicKey, signers, programId));
        return yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer, ...signers], confirmOptions);
      });
    }
  }
});

// node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/extensions/defaultAccountState/state.js
var require_state3 = __commonJS({
  "node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/extensions/defaultAccountState/state.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DEFAULT_ACCOUNT_STATE_SIZE = exports2.DefaultAccountStateLayout = void 0;
    exports2.getDefaultAccountState = getDefaultAccountState;
    var buffer_layout_1 = require_Layout();
    var extensionType_js_1 = require_extensionType();
    exports2.DefaultAccountStateLayout = (0, buffer_layout_1.struct)([(0, buffer_layout_1.u8)("state")]);
    exports2.DEFAULT_ACCOUNT_STATE_SIZE = exports2.DefaultAccountStateLayout.span;
    function getDefaultAccountState(mint) {
      const extensionData = (0, extensionType_js_1.getExtensionData)(extensionType_js_1.ExtensionType.DefaultAccountState, mint.tlvData);
      if (extensionData !== null) {
        return exports2.DefaultAccountStateLayout.decode(extensionData);
      } else {
        return null;
      }
    }
  }
});

// node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/extensions/defaultAccountState/index.js
var require_defaultAccountState = __commonJS({
  "node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/extensions/defaultAccountState/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_actions2(), exports2);
    __exportStar(require_instructions2(), exports2);
    __exportStar(require_state3(), exports2);
  }
});

// node_modules/@solana/spl-token-group/lib/cjs/errors.js
var require_errors2 = __commonJS({
  "node_modules/@solana/spl-token-group/lib/cjs/errors.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MemberAccountIsGroupAccountError = exports2.IncorrectUpdateAuthorityError = exports2.IncorrectMintAuthorityError = exports2.ImmutableGroupError = exports2.SizeExceedsMaxSizeError = exports2.SizeExceedsNewMaxSizeError = exports2.TokenGroupError = void 0;
    var TokenGroupError = class extends Error {
      constructor(message) {
        super(message);
      }
    };
    exports2.TokenGroupError = TokenGroupError;
    var SizeExceedsNewMaxSizeError = class extends TokenGroupError {
      constructor() {
        super(...arguments);
        this.name = "SizeExceedsNewMaxSizeError";
      }
    };
    exports2.SizeExceedsNewMaxSizeError = SizeExceedsNewMaxSizeError;
    var SizeExceedsMaxSizeError = class extends TokenGroupError {
      constructor() {
        super(...arguments);
        this.name = "SizeExceedsMaxSizeError";
      }
    };
    exports2.SizeExceedsMaxSizeError = SizeExceedsMaxSizeError;
    var ImmutableGroupError = class extends TokenGroupError {
      constructor() {
        super(...arguments);
        this.name = "ImmutableGroupError";
      }
    };
    exports2.ImmutableGroupError = ImmutableGroupError;
    var IncorrectMintAuthorityError = class extends TokenGroupError {
      constructor() {
        super(...arguments);
        this.name = "IncorrectMintAuthorityError";
      }
    };
    exports2.IncorrectMintAuthorityError = IncorrectMintAuthorityError;
    var IncorrectUpdateAuthorityError = class extends TokenGroupError {
      constructor() {
        super(...arguments);
        this.name = "IncorrectUpdateAuthorityError";
      }
    };
    exports2.IncorrectUpdateAuthorityError = IncorrectUpdateAuthorityError;
    var MemberAccountIsGroupAccountError = class extends TokenGroupError {
      constructor() {
        super(...arguments);
        this.name = "MemberAccountIsGroupAccountError";
      }
    };
    exports2.MemberAccountIsGroupAccountError = MemberAccountIsGroupAccountError;
  }
});

// node_modules/@solana/errors/dist/index.node.cjs
var require_index_node = __commonJS({
  "node_modules/@solana/errors/dist/index.node.cjs"(exports2) {
    "use strict";
    var SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED = 1;
    var SOLANA_ERROR__INVALID_NONCE = 2;
    var SOLANA_ERROR__NONCE_ACCOUNT_NOT_FOUND = 3;
    var SOLANA_ERROR__BLOCKHASH_STRING_LENGTH_OUT_OF_RANGE = 4;
    var SOLANA_ERROR__INVALID_BLOCKHASH_BYTE_LENGTH = 5;
    var SOLANA_ERROR__LAMPORTS_OUT_OF_RANGE = 6;
    var SOLANA_ERROR__MALFORMED_BIGINT_STRING = 7;
    var SOLANA_ERROR__MALFORMED_NUMBER_STRING = 8;
    var SOLANA_ERROR__TIMESTAMP_OUT_OF_RANGE = 9;
    var SOLANA_ERROR__JSON_RPC__PARSE_ERROR = -32700;
    var SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR = -32603;
    var SOLANA_ERROR__JSON_RPC__INVALID_PARAMS = -32602;
    var SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND = -32601;
    var SOLANA_ERROR__JSON_RPC__INVALID_REQUEST = -32600;
    var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED = -32016;
    var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION = -32015;
    var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET = -32014;
    var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH = -32013;
    var SOLANA_ERROR__JSON_RPC__SCAN_ERROR = -32012;
    var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE = -32011;
    var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX = -32010;
    var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED = -32009;
    var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NO_SNAPSHOT = -32008;
    var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED = -32007;
    var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE = -32006;
    var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NODE_UNHEALTHY = -32005;
    var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE = -32004;
    var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE = -32003;
    var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE = -32002;
    var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP = -32001;
    var SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH = 28e5;
    var SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE = 2800001;
    var SOLANA_ERROR__ADDRESSES__INVALID_BASE58_ENCODED_ADDRESS = 2800002;
    var SOLANA_ERROR__ADDRESSES__INVALID_ED25519_PUBLIC_KEY = 2800003;
    var SOLANA_ERROR__ADDRESSES__MALFORMED_PDA = 2800004;
    var SOLANA_ERROR__ADDRESSES__PDA_BUMP_SEED_OUT_OF_RANGE = 2800005;
    var SOLANA_ERROR__ADDRESSES__MAX_NUMBER_OF_PDA_SEEDS_EXCEEDED = 2800006;
    var SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED = 2800007;
    var SOLANA_ERROR__ADDRESSES__INVALID_SEEDS_POINT_ON_CURVE = 2800008;
    var SOLANA_ERROR__ADDRESSES__FAILED_TO_FIND_VIABLE_PDA_BUMP_SEED = 2800009;
    var SOLANA_ERROR__ADDRESSES__PDA_ENDS_WITH_PDA_MARKER = 2800010;
    var SOLANA_ERROR__ACCOUNTS__ACCOUNT_NOT_FOUND = 323e4;
    var SOLANA_ERROR__ACCOUNTS__ONE_OR_MORE_ACCOUNTS_NOT_FOUND = 32300001;
    var SOLANA_ERROR__ACCOUNTS__FAILED_TO_DECODE_ACCOUNT = 3230002;
    var SOLANA_ERROR__ACCOUNTS__EXPECTED_DECODED_ACCOUNT = 3230003;
    var SOLANA_ERROR__ACCOUNTS__EXPECTED_ALL_ACCOUNTS_TO_BE_DECODED = 3230004;
    var SOLANA_ERROR__SUBTLE_CRYPTO__DISALLOWED_IN_INSECURE_CONTEXT = 361e4;
    var SOLANA_ERROR__SUBTLE_CRYPTO__DIGEST_UNIMPLEMENTED = 3610001;
    var SOLANA_ERROR__SUBTLE_CRYPTO__ED25519_ALGORITHM_UNIMPLEMENTED = 3610002;
    var SOLANA_ERROR__SUBTLE_CRYPTO__EXPORT_FUNCTION_UNIMPLEMENTED = 3610003;
    var SOLANA_ERROR__SUBTLE_CRYPTO__GENERATE_FUNCTION_UNIMPLEMENTED = 3610004;
    var SOLANA_ERROR__SUBTLE_CRYPTO__SIGN_FUNCTION_UNIMPLEMENTED = 3610005;
    var SOLANA_ERROR__SUBTLE_CRYPTO__VERIFY_FUNCTION_UNIMPLEMENTED = 3610006;
    var SOLANA_ERROR__SUBTLE_CRYPTO__CANNOT_EXPORT_NON_EXTRACTABLE_KEY = 3610007;
    var SOLANA_ERROR__CRYPTO__RANDOM_VALUES_FUNCTION_UNIMPLEMENTED = 3611e3;
    var SOLANA_ERROR__KEYS__INVALID_KEY_PAIR_BYTE_LENGTH = 3704e3;
    var SOLANA_ERROR__KEYS__INVALID_PRIVATE_KEY_BYTE_LENGTH = 3704001;
    var SOLANA_ERROR__KEYS__INVALID_SIGNATURE_BYTE_LENGTH = 3704002;
    var SOLANA_ERROR__KEYS__SIGNATURE_STRING_LENGTH_OUT_OF_RANGE = 3704003;
    var SOLANA_ERROR__KEYS__PUBLIC_KEY_MUST_MATCH_PRIVATE_KEY = 3704004;
    var SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_ACCOUNTS = 4128e3;
    var SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_DATA = 4128001;
    var SOLANA_ERROR__INSTRUCTION__PROGRAM_ID_MISMATCH = 4128002;
    var SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN = 4615e3;
    var SOLANA_ERROR__INSTRUCTION_ERROR__GENERIC_ERROR = 4615001;
    var SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ARGUMENT = 4615002;
    var SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_INSTRUCTION_DATA = 4615003;
    var SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_DATA = 4615004;
    var SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_TOO_SMALL = 4615005;
    var SOLANA_ERROR__INSTRUCTION_ERROR__INSUFFICIENT_FUNDS = 4615006;
    var SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_PROGRAM_ID = 4615007;
    var SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_REQUIRED_SIGNATURE = 4615008;
    var SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_ALREADY_INITIALIZED = 4615009;
    var SOLANA_ERROR__INSTRUCTION_ERROR__UNINITIALIZED_ACCOUNT = 4615010;
    var SOLANA_ERROR__INSTRUCTION_ERROR__UNBALANCED_INSTRUCTION = 4615011;
    var SOLANA_ERROR__INSTRUCTION_ERROR__MODIFIED_PROGRAM_ID = 4615012;
    var SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_LAMPORT_SPEND = 4615013;
    var SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_DATA_MODIFIED = 4615014;
    var SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_LAMPORT_CHANGE = 4615015;
    var SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_DATA_MODIFIED = 4615016;
    var SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_INDEX = 4615017;
    var SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_MODIFIED = 4615018;
    var SOLANA_ERROR__INSTRUCTION_ERROR__RENT_EPOCH_MODIFIED = 4615019;
    var SOLANA_ERROR__INSTRUCTION_ERROR__NOT_ENOUGH_ACCOUNT_KEYS = 4615020;
    var SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_SIZE_CHANGED = 4615021;
    var SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_EXECUTABLE = 4615022;
    var SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_FAILED = 4615023;
    var SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_OUTSTANDING = 4615024;
    var SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_OUT_OF_SYNC = 4615025;
    var SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM = 4615026;
    var SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ERROR = 4615027;
    var SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_DATA_MODIFIED = 4615028;
    var SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_LAMPORT_CHANGE = 4615029;
    var SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_ACCOUNT_NOT_RENT_EXEMPT = 4615030;
    var SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_PROGRAM_ID = 4615031;
    var SOLANA_ERROR__INSTRUCTION_ERROR__CALL_DEPTH = 4615032;
    var SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_ACCOUNT = 4615033;
    var SOLANA_ERROR__INSTRUCTION_ERROR__REENTRANCY_NOT_ALLOWED = 4615034;
    var SOLANA_ERROR__INSTRUCTION_ERROR__MAX_SEED_LENGTH_EXCEEDED = 4615035;
    var SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_SEEDS = 4615036;
    var SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_REALLOC = 4615037;
    var SOLANA_ERROR__INSTRUCTION_ERROR__COMPUTATIONAL_BUDGET_EXCEEDED = 4615038;
    var SOLANA_ERROR__INSTRUCTION_ERROR__PRIVILEGE_ESCALATION = 4615039;
    var SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_ENVIRONMENT_SETUP_FAILURE = 4615040;
    var SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPLETE = 4615041;
    var SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPILE = 4615042;
    var SOLANA_ERROR__INSTRUCTION_ERROR__IMMUTABLE = 4615043;
    var SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_AUTHORITY = 4615044;
    var SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR = 4615045;
    var SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_RENT_EXEMPT = 4615046;
    var SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_OWNER = 4615047;
    var SOLANA_ERROR__INSTRUCTION_ERROR__ARITHMETIC_OVERFLOW = 4615048;
    var SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_SYSVAR = 4615049;
    var SOLANA_ERROR__INSTRUCTION_ERROR__ILLEGAL_OWNER = 4615050;
    var SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_DATA_ALLOCATIONS_EXCEEDED = 4615051;
    var SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_EXCEEDED = 4615052;
    var SOLANA_ERROR__INSTRUCTION_ERROR__MAX_INSTRUCTION_TRACE_LENGTH_EXCEEDED = 4615053;
    var SOLANA_ERROR__INSTRUCTION_ERROR__BUILTIN_PROGRAMS_MUST_CONSUME_COMPUTE_UNITS = 4615054;
    var SOLANA_ERROR__SIGNER__ADDRESS_CANNOT_HAVE_MULTIPLE_SIGNERS = 5508e3;
    var SOLANA_ERROR__SIGNER__EXPECTED_KEY_PAIR_SIGNER = 5508001;
    var SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_SIGNER = 5508002;
    var SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_MODIFYING_SIGNER = 5508003;
    var SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_PARTIAL_SIGNER = 5508004;
    var SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SIGNER = 5508005;
    var SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_MODIFYING_SIGNER = 5508006;
    var SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_PARTIAL_SIGNER = 5508007;
    var SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SENDING_SIGNER = 5508008;
    var SOLANA_ERROR__SIGNER__TRANSACTION_CANNOT_HAVE_MULTIPLE_SENDING_SIGNERS = 5508009;
    var SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING = 5508010;
    var SOLANA_ERROR__SIGNER__WALLET_MULTISIGN_UNIMPLEMENTED = 5508011;
    var SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES = 5663e3;
    var SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE = 5663001;
    var SOLANA_ERROR__TRANSACTION__EXPECTED_BLOCKHASH_LIFETIME = 5663002;
    var SOLANA_ERROR__TRANSACTION__EXPECTED_NONCE_LIFETIME = 5663003;
    var SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE = 5663004;
    var SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING = 5663005;
    var SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE = 5663006;
    var SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND = 5663007;
    var SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_FEE_PAYER_MISSING = 5663008;
    var SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING = 5663009;
    var SOLANA_ERROR__TRANSACTION__ADDRESS_MISSING = 5663010;
    var SOLANA_ERROR__TRANSACTION__FEE_PAYER_MISSING = 5663011;
    var SOLANA_ERROR__TRANSACTION__FEE_PAYER_SIGNATURE_MISSING = 5663012;
    var SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_INSTRUCTIONS_MISSING = 5663013;
    var SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_FIRST_INSTRUCTION_MUST_BE_ADVANCE_NONCE = 5663014;
    var SOLANA_ERROR__TRANSACTION__ADDRESSES_CANNOT_SIGN_TRANSACTION = 5663015;
    var SOLANA_ERROR__TRANSACTION__CANNOT_ENCODE_WITH_EMPTY_SIGNATURES = 5663016;
    var SOLANA_ERROR__TRANSACTION__MESSAGE_SIGNATURES_MISMATCH = 5663017;
    var SOLANA_ERROR__TRANSACTION__FAILED_TO_ESTIMATE_COMPUTE_LIMIT = 5663018;
    var SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN = 705e4;
    var SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_IN_USE = 7050001;
    var SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_LOADED_TWICE = 7050002;
    var SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_NOT_FOUND = 7050003;
    var SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_ACCOUNT_NOT_FOUND = 7050004;
    var SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_FEE = 7050005;
    var SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_FOR_FEE = 7050006;
    var SOLANA_ERROR__TRANSACTION_ERROR__ALREADY_PROCESSED = 7050007;
    var SOLANA_ERROR__TRANSACTION_ERROR__BLOCKHASH_NOT_FOUND = 7050008;
    var SOLANA_ERROR__TRANSACTION_ERROR__CALL_CHAIN_TOO_DEEP = 7050009;
    var SOLANA_ERROR__TRANSACTION_ERROR__MISSING_SIGNATURE_FOR_FEE = 7050010;
    var SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_INDEX = 7050011;
    var SOLANA_ERROR__TRANSACTION_ERROR__SIGNATURE_FAILURE = 7050012;
    var SOLANA_ERROR__TRANSACTION_ERROR__INVALID_PROGRAM_FOR_EXECUTION = 7050013;
    var SOLANA_ERROR__TRANSACTION_ERROR__SANITIZE_FAILURE = 7050014;
    var SOLANA_ERROR__TRANSACTION_ERROR__CLUSTER_MAINTENANCE = 7050015;
    var SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_BORROW_OUTSTANDING = 7050016;
    var SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_BLOCK_COST_LIMIT = 7050017;
    var SOLANA_ERROR__TRANSACTION_ERROR__UNSUPPORTED_VERSION = 7050018;
    var SOLANA_ERROR__TRANSACTION_ERROR__INVALID_WRITABLE_ACCOUNT = 7050019;
    var SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_ACCOUNT_COST_LIMIT = 7050020;
    var SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_BLOCK_LIMIT = 7050021;
    var SOLANA_ERROR__TRANSACTION_ERROR__TOO_MANY_ACCOUNT_LOCKS = 7050022;
    var SOLANA_ERROR__TRANSACTION_ERROR__ADDRESS_LOOKUP_TABLE_NOT_FOUND = 7050023;
    var SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_OWNER = 7050024;
    var SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_DATA = 7050025;
    var SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_INDEX = 7050026;
    var SOLANA_ERROR__TRANSACTION_ERROR__INVALID_RENT_PAYING_ACCOUNT = 7050027;
    var SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_VOTE_COST_LIMIT = 7050028;
    var SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_TOTAL_LIMIT = 7050029;
    var SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION = 7050030;
    var SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT = 7050031;
    var SOLANA_ERROR__TRANSACTION_ERROR__MAX_LOADED_ACCOUNTS_DATA_SIZE_EXCEEDED = 7050032;
    var SOLANA_ERROR__TRANSACTION_ERROR__INVALID_LOADED_ACCOUNTS_DATA_SIZE_LIMIT = 7050033;
    var SOLANA_ERROR__TRANSACTION_ERROR__RESANITIZATION_NEEDED = 7050034;
    var SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED = 7050035;
    var SOLANA_ERROR__TRANSACTION_ERROR__UNBALANCED_TRANSACTION = 7050036;
    var SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY = 8078e3;
    var SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH = 8078001;
    var SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH = 8078002;
    var SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH = 8078003;
    var SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH = 8078004;
    var SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH = 8078005;
    var SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH = 8078006;
    var SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS = 8078007;
    var SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE = 8078008;
    var SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT = 8078009;
    var SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT = 8078010;
    var SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE = 8078011;
    var SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE = 8078012;
    var SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH = 8078013;
    var SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE = 8078014;
    var SOLANA_ERROR__CODECS__INVALID_LITERAL_UNION_VARIANT = 8078015;
    var SOLANA_ERROR__CODECS__LITERAL_UNION_DISCRIMINATOR_OUT_OF_RANGE = 8078016;
    var SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE = 8078017;
    var SOLANA_ERROR__CODECS__INVALID_CONSTANT = 8078018;
    var SOLANA_ERROR__CODECS__EXPECTED_ZERO_VALUE_TO_MATCH_ITEM_FIXED_SIZE = 8078019;
    var SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL = 8078020;
    var SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES = 8078021;
    var SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS = 8078022;
    var SOLANA_ERROR__RPC__INTEGER_OVERFLOW = 81e5;
    var SOLANA_ERROR__RPC__TRANSPORT_HTTP_HEADER_FORBIDDEN = 8100001;
    var SOLANA_ERROR__RPC__TRANSPORT_HTTP_ERROR = 8100002;
    var SOLANA_ERROR__RPC_SUBSCRIPTIONS__CANNOT_CREATE_SUBSCRIPTION_REQUEST = 819e4;
    var SOLANA_ERROR__RPC_SUBSCRIPTIONS__EXPECTED_SERVER_SUBSCRIPTION_ID = 8190001;
    var SOLANA_ERROR__RPC_SUBSCRIPTIONS__TRANSPORT_CLOSED_BEFORE_MESSAGE_BUFFERED = 8190002;
    var SOLANA_ERROR__RPC_SUBSCRIPTIONS__TRANSPORT_CONNECTION_CLOSED = 8190003;
    var SOLANA_ERROR__RPC_SUBSCRIPTIONS__TRANSPORT_FAILED_TO_CONNECT = 8190004;
    var SOLANA_ERROR__INVARIANT_VIOLATION__WEBSOCKET_MESSAGE_ITERATOR_STATE_MISSING = 99e5;
    var SOLANA_ERROR__INVARIANT_VIOLATION__WEBSOCKET_MESSAGE_ITERATOR_MUST_NOT_POLL_BEFORE_RESOLVING_EXISTING_MESSAGE_PROMISE = 9900001;
    var SOLANA_ERROR__INVARIANT_VIOLATION__CACHED_ABORTABLE_ITERABLE_CACHE_ENTRY_MISSING = 9900002;
    var SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE = 9900003;
    function encodeValue(value) {
      if (Array.isArray(value)) {
        const commaSeparatedValues = value.map(encodeValue).join(
          "%2C%20"
          /* ", " */
        );
        return "%5B" + commaSeparatedValues + /* "]" */
        "%5D";
      } else if (typeof value === "bigint") {
        return `${value}n`;
      } else {
        return encodeURIComponent(
          String(
            value != null && Object.getPrototypeOf(value) === null ? (
              // Plain objects with no prototype don't have a `toString` method.
              // Convert them before stringifying them.
              { ...value }
            ) : value
          )
        );
      }
    }
    function encodeObjectContextEntry([key, value]) {
      return `${key}=${encodeValue(value)}`;
    }
    function encodeContextObject(context) {
      const searchParamsString = Object.entries(context).map(encodeObjectContextEntry).join("&");
      return Buffer.from(searchParamsString, "utf8").toString("base64");
    }
    var SolanaErrorMessages = {
      [SOLANA_ERROR__ACCOUNTS__ACCOUNT_NOT_FOUND]: "Account not found at address: $address",
      [SOLANA_ERROR__ACCOUNTS__EXPECTED_ALL_ACCOUNTS_TO_BE_DECODED]: "Not all accounts were decoded. Encoded accounts found at addresses: $addresses.",
      [SOLANA_ERROR__ACCOUNTS__EXPECTED_DECODED_ACCOUNT]: "Expected decoded account at address: $address",
      [SOLANA_ERROR__ACCOUNTS__FAILED_TO_DECODE_ACCOUNT]: "Failed to decode account data at address: $address",
      [SOLANA_ERROR__ACCOUNTS__ONE_OR_MORE_ACCOUNTS_NOT_FOUND]: "Accounts not found at addresses: $addresses",
      [SOLANA_ERROR__ADDRESSES__FAILED_TO_FIND_VIABLE_PDA_BUMP_SEED]: "Unable to find a viable program address bump seed.",
      [SOLANA_ERROR__ADDRESSES__INVALID_BASE58_ENCODED_ADDRESS]: "$putativeAddress is not a base58-encoded address.",
      [SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH]: "Expected base58 encoded address to decode to a byte array of length 32. Actual length: $actualLength.",
      [SOLANA_ERROR__ADDRESSES__INVALID_ED25519_PUBLIC_KEY]: "The `CryptoKey` must be an `Ed25519` public key.",
      [SOLANA_ERROR__ADDRESSES__INVALID_SEEDS_POINT_ON_CURVE]: "Invalid seeds; point must fall off the Ed25519 curve.",
      [SOLANA_ERROR__ADDRESSES__MALFORMED_PDA]: "Expected given program derived address to have the following format: [Address, ProgramDerivedAddressBump].",
      [SOLANA_ERROR__ADDRESSES__MAX_NUMBER_OF_PDA_SEEDS_EXCEEDED]: "A maximum of $maxSeeds seeds, including the bump seed, may be supplied when creating an address. Received: $actual.",
      [SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED]: "The seed at index $index with length $actual exceeds the maximum length of $maxSeedLength bytes.",
      [SOLANA_ERROR__ADDRESSES__PDA_BUMP_SEED_OUT_OF_RANGE]: "Expected program derived address bump to be in the range [0, 255], got: $bump.",
      [SOLANA_ERROR__ADDRESSES__PDA_ENDS_WITH_PDA_MARKER]: "Program address cannot end with PDA marker.",
      [SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE]: "Expected base58-encoded address string of length in the range [32, 44]. Actual length: $actualLength.",
      [SOLANA_ERROR__BLOCKHASH_STRING_LENGTH_OUT_OF_RANGE]: "Expected base58-encoded blockash string of length in the range [32, 44]. Actual length: $actualLength.",
      [SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED]: "The network has progressed past the last block for which this transaction could have been committed.",
      [SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY]: "Codec [$codecDescription] cannot decode empty byte arrays.",
      [SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS]: "Enum codec cannot use lexical values [$stringValues] as discriminators. Either remove all lexical values or set `useValuesAsDiscriminators` to `false`.",
      [SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL]: "Sentinel [$hexSentinel] must not be present in encoded bytes [$hexEncodedBytes].",
      [SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH]: "Encoder and decoder must have the same fixed size, got [$encoderFixedSize] and [$decoderFixedSize].",
      [SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH]: "Encoder and decoder must have the same max size, got [$encoderMaxSize] and [$decoderMaxSize].",
      [SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH]: "Encoder and decoder must either both be fixed-size or variable-size.",
      [SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE]: "Enum discriminator out of range. Expected a number in [$formattedValidDiscriminators], got $discriminator.",
      [SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH]: "Expected a fixed-size codec, got a variable-size one.",
      [SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH]: "Codec [$codecDescription] expected a positive byte length, got $bytesLength.",
      [SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH]: "Expected a variable-size codec, got a fixed-size one.",
      [SOLANA_ERROR__CODECS__EXPECTED_ZERO_VALUE_TO_MATCH_ITEM_FIXED_SIZE]: "Codec [$codecDescription] expected zero-value [$hexZeroValue] to have the same size as the provided fixed-size item [$expectedSize bytes].",
      [SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH]: "Codec [$codecDescription] expected $expected bytes, got $bytesLength.",
      [SOLANA_ERROR__CODECS__INVALID_CONSTANT]: "Expected byte array constant [$hexConstant] to be present in data [$hexData] at offset [$offset].",
      [SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT]: "Invalid discriminated union variant. Expected one of [$variants], got $value.",
      [SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT]: "Invalid enum variant. Expected one of [$stringValues] or a number in [$formattedNumericalValues], got $variant.",
      [SOLANA_ERROR__CODECS__INVALID_LITERAL_UNION_VARIANT]: "Invalid literal union variant. Expected one of [$variants], got $value.",
      [SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS]: "Expected [$codecDescription] to have $expected items, got $actual.",
      [SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE]: "Invalid value $value for base $base with alphabet $alphabet.",
      [SOLANA_ERROR__CODECS__LITERAL_UNION_DISCRIMINATOR_OUT_OF_RANGE]: "Literal union discriminator out of range. Expected a number between $minRange and $maxRange, got $discriminator.",
      [SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE]: "Codec [$codecDescription] expected number to be in the range [$min, $max], got $value.",
      [SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE]: "Codec [$codecDescription] expected offset to be in the range [0, $bytesLength], got $offset.",
      [SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES]: "Expected sentinel [$hexSentinel] to be present in decoded bytes [$hexDecodedBytes].",
      [SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE]: "Union variant out of range. Expected an index between $minRange and $maxRange, got $variant.",
      [SOLANA_ERROR__CRYPTO__RANDOM_VALUES_FUNCTION_UNIMPLEMENTED]: "No random values implementation could be found.",
      [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_ALREADY_INITIALIZED]: "instruction requires an uninitialized account",
      [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_FAILED]: "instruction tries to borrow reference for an account which is already borrowed",
      [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_OUTSTANDING]: "instruction left account with an outstanding borrowed reference",
      [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_SIZE_CHANGED]: "program other than the account's owner changed the size of the account data",
      [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_TOO_SMALL]: "account data too small for instruction",
      [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_EXECUTABLE]: "instruction expected an executable account",
      [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_RENT_EXEMPT]: "An account does not have enough lamports to be rent-exempt",
      [SOLANA_ERROR__INSTRUCTION_ERROR__ARITHMETIC_OVERFLOW]: "Program arithmetic overflowed",
      [SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR]: "Failed to serialize or deserialize account data: $encodedData",
      [SOLANA_ERROR__INSTRUCTION_ERROR__BUILTIN_PROGRAMS_MUST_CONSUME_COMPUTE_UNITS]: "Builtin programs must consume compute units",
      [SOLANA_ERROR__INSTRUCTION_ERROR__CALL_DEPTH]: "Cross-program invocation call depth too deep",
      [SOLANA_ERROR__INSTRUCTION_ERROR__COMPUTATIONAL_BUDGET_EXCEEDED]: "Computational budget exceeded",
      [SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM]: "custom program error: #$code",
      [SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_INDEX]: "instruction contains duplicate accounts",
      [SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_OUT_OF_SYNC]: "instruction modifications of multiply-passed account differ",
      [SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_ACCOUNT_NOT_RENT_EXEMPT]: "executable accounts must be rent exempt",
      [SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_DATA_MODIFIED]: "instruction changed executable accounts data",
      [SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_LAMPORT_CHANGE]: "instruction changed the balance of an executable account",
      [SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_MODIFIED]: "instruction changed executable bit of an account",
      [SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_DATA_MODIFIED]: "instruction modified data of an account it does not own",
      [SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_LAMPORT_SPEND]: "instruction spent from the balance of an account it does not own",
      [SOLANA_ERROR__INSTRUCTION_ERROR__GENERIC_ERROR]: "generic instruction error",
      [SOLANA_ERROR__INSTRUCTION_ERROR__ILLEGAL_OWNER]: "Provided owner is not allowed",
      [SOLANA_ERROR__INSTRUCTION_ERROR__IMMUTABLE]: "Account is immutable",
      [SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_AUTHORITY]: "Incorrect authority provided",
      [SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_PROGRAM_ID]: "incorrect program id for instruction",
      [SOLANA_ERROR__INSTRUCTION_ERROR__INSUFFICIENT_FUNDS]: "insufficient funds for instruction",
      [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_DATA]: "invalid account data for instruction",
      [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_OWNER]: "Invalid account owner",
      [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ARGUMENT]: "invalid program argument",
      [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ERROR]: "program returned invalid error code",
      [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_INSTRUCTION_DATA]: "invalid instruction data",
      [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_REALLOC]: "Failed to reallocate account data",
      [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_SEEDS]: "Provided seeds do not result in a valid address",
      [SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_DATA_ALLOCATIONS_EXCEEDED]: "Accounts data allocations exceeded the maximum allowed per transaction",
      [SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_EXCEEDED]: "Max accounts exceeded",
      [SOLANA_ERROR__INSTRUCTION_ERROR__MAX_INSTRUCTION_TRACE_LENGTH_EXCEEDED]: "Max instruction trace length exceeded",
      [SOLANA_ERROR__INSTRUCTION_ERROR__MAX_SEED_LENGTH_EXCEEDED]: "Length of the seed is too long for address generation",
      [SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_ACCOUNT]: "An account required by the instruction is missing",
      [SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_REQUIRED_SIGNATURE]: "missing required signature for instruction",
      [SOLANA_ERROR__INSTRUCTION_ERROR__MODIFIED_PROGRAM_ID]: "instruction illegally modified the program id of an account",
      [SOLANA_ERROR__INSTRUCTION_ERROR__NOT_ENOUGH_ACCOUNT_KEYS]: "insufficient account keys for instruction",
      [SOLANA_ERROR__INSTRUCTION_ERROR__PRIVILEGE_ESCALATION]: "Cross-program invocation with unauthorized signer or writable account",
      [SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_ENVIRONMENT_SETUP_FAILURE]: "Failed to create program execution environment",
      [SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPILE]: "Program failed to compile",
      [SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPLETE]: "Program failed to complete",
      [SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_DATA_MODIFIED]: "instruction modified data of a read-only account",
      [SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_LAMPORT_CHANGE]: "instruction changed the balance of a read-only account",
      [SOLANA_ERROR__INSTRUCTION_ERROR__REENTRANCY_NOT_ALLOWED]: "Cross-program invocation reentrancy not allowed for this instruction",
      [SOLANA_ERROR__INSTRUCTION_ERROR__RENT_EPOCH_MODIFIED]: "instruction modified rent epoch of an account",
      [SOLANA_ERROR__INSTRUCTION_ERROR__UNBALANCED_INSTRUCTION]: "sum of account balances before and after instruction do not match",
      [SOLANA_ERROR__INSTRUCTION_ERROR__UNINITIALIZED_ACCOUNT]: "instruction requires an initialized account",
      [SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN]: "",
      [SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_PROGRAM_ID]: "Unsupported program id",
      [SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_SYSVAR]: "Unsupported sysvar",
      [SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_ACCOUNTS]: "The instruction does not have any accounts.",
      [SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_DATA]: "The instruction does not have any data.",
      [SOLANA_ERROR__INSTRUCTION__PROGRAM_ID_MISMATCH]: "Expected instruction to have progress address $expectedProgramAddress, got $actualProgramAddress.",
      [SOLANA_ERROR__INVALID_BLOCKHASH_BYTE_LENGTH]: "Expected base58 encoded blockhash to decode to a byte array of length 32. Actual length: $actualLength.",
      [SOLANA_ERROR__INVALID_NONCE]: "The nonce `$expectedNonceValue` is no longer valid. It has advanced to `$actualNonceValue`",
      [SOLANA_ERROR__INVARIANT_VIOLATION__CACHED_ABORTABLE_ITERABLE_CACHE_ENTRY_MISSING]: "Invariant violation: Found no abortable iterable cache entry for key `$cacheKey`. It should be impossible to hit this error; please file an issue at https://sola.na/web3invariant",
      [SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE]: "Invariant violation: Switch statement non-exhaustive. Received unexpected value `$unexpectedValue`. It should be impossible to hit this error; please file an issue at https://sola.na/web3invariant",
      [SOLANA_ERROR__INVARIANT_VIOLATION__WEBSOCKET_MESSAGE_ITERATOR_MUST_NOT_POLL_BEFORE_RESOLVING_EXISTING_MESSAGE_PROMISE]: "Invariant violation: WebSocket message iterator state is corrupt; iterated without first resolving existing message promise. It should be impossible to hit this error; please file an issue at https://sola.na/web3invariant",
      [SOLANA_ERROR__INVARIANT_VIOLATION__WEBSOCKET_MESSAGE_ITERATOR_STATE_MISSING]: "Invariant violation: WebSocket message iterator is missing state storage. It should be impossible to hit this error; please file an issue at https://sola.na/web3invariant",
      [SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR]: "JSON-RPC error: Internal JSON-RPC error ($__serverMessage)",
      [SOLANA_ERROR__JSON_RPC__INVALID_PARAMS]: "JSON-RPC error: Invalid method parameter(s) ($__serverMessage)",
      [SOLANA_ERROR__JSON_RPC__INVALID_REQUEST]: "JSON-RPC error: The JSON sent is not a valid `Request` object ($__serverMessage)",
      [SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND]: "JSON-RPC error: The method does not exist / is not available ($__serverMessage)",
      [SOLANA_ERROR__JSON_RPC__PARSE_ERROR]: "JSON-RPC error: An error occurred on the server while parsing the JSON text ($__serverMessage)",
      [SOLANA_ERROR__JSON_RPC__SCAN_ERROR]: "$__serverMessage",
      [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP]: "$__serverMessage",
      [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE]: "$__serverMessage",
      [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET]: "$__serverMessage",
      [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX]: "$__serverMessage",
      [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED]: "$__serverMessage",
      [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED]: "Minimum context slot has not been reached",
      [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NODE_UNHEALTHY]: "Node is unhealthy; behind by $numSlotsBehind slots",
      [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NO_SNAPSHOT]: "No snapshot",
      [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE]: "Transaction simulation failed",
      [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED]: "$__serverMessage",
      [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE]: "Transaction history is not available from this node",
      [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE]: "$__serverMessage",
      [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH]: "Transaction signature length mismatch",
      [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE]: "Transaction signature verification failure",
      [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION]: "$__serverMessage",
      [SOLANA_ERROR__KEYS__INVALID_KEY_PAIR_BYTE_LENGTH]: "Key pair bytes must be of length 64, got $byteLength.",
      [SOLANA_ERROR__KEYS__INVALID_PRIVATE_KEY_BYTE_LENGTH]: "Expected private key bytes with length 32. Actual length: $actualLength.",
      [SOLANA_ERROR__KEYS__INVALID_SIGNATURE_BYTE_LENGTH]: "Expected base58-encoded signature to decode to a byte array of length 64. Actual length: $actualLength.",
      [SOLANA_ERROR__KEYS__PUBLIC_KEY_MUST_MATCH_PRIVATE_KEY]: "The provided private key does not match the provided public key.",
      [SOLANA_ERROR__KEYS__SIGNATURE_STRING_LENGTH_OUT_OF_RANGE]: "Expected base58-encoded signature string of length in the range [64, 88]. Actual length: $actualLength.",
      [SOLANA_ERROR__LAMPORTS_OUT_OF_RANGE]: "Lamports value must be in the range [0, 2e64-1]",
      [SOLANA_ERROR__MALFORMED_BIGINT_STRING]: "`$value` cannot be parsed as a `BigInt`",
      [SOLANA_ERROR__MALFORMED_NUMBER_STRING]: "`$value` cannot be parsed as a `Number`",
      [SOLANA_ERROR__NONCE_ACCOUNT_NOT_FOUND]: "No nonce account could be found at address `$nonceAccountAddress`",
      [SOLANA_ERROR__RPC_SUBSCRIPTIONS__CANNOT_CREATE_SUBSCRIPTION_REQUEST]: "Either the notification name must end in 'Notifications' or the API must supply a subscription creator function for the notification '$notificationName' to map between the notification name and the subscribe/unsubscribe method names.",
      [SOLANA_ERROR__RPC_SUBSCRIPTIONS__EXPECTED_SERVER_SUBSCRIPTION_ID]: "Failed to obtain a subscription id from the server",
      [SOLANA_ERROR__RPC_SUBSCRIPTIONS__TRANSPORT_CLOSED_BEFORE_MESSAGE_BUFFERED]: "WebSocket was closed before payload could be added to the send buffer",
      [SOLANA_ERROR__RPC_SUBSCRIPTIONS__TRANSPORT_CONNECTION_CLOSED]: "WebSocket connection closed",
      [SOLANA_ERROR__RPC_SUBSCRIPTIONS__TRANSPORT_FAILED_TO_CONNECT]: "WebSocket failed to connect",
      [SOLANA_ERROR__RPC__INTEGER_OVERFLOW]: "The $argumentLabel argument to the `$methodName` RPC method$optionalPathLabel was `$value`. This number is unsafe for use with the Solana JSON-RPC because it exceeds `Number.MAX_SAFE_INTEGER`.",
      [SOLANA_ERROR__RPC__TRANSPORT_HTTP_ERROR]: "HTTP error ($statusCode): $message",
      [SOLANA_ERROR__RPC__TRANSPORT_HTTP_HEADER_FORBIDDEN]: "HTTP header(s) forbidden: $headers. Learn more at https://developer.mozilla.org/en-US/docs/Glossary/Forbidden_header_name.",
      [SOLANA_ERROR__SIGNER__ADDRESS_CANNOT_HAVE_MULTIPLE_SIGNERS]: "Multiple distinct signers were identified for address `$address`. Please ensure that you are using the same signer instance for each address.",
      [SOLANA_ERROR__SIGNER__EXPECTED_KEY_PAIR_SIGNER]: "The provided value does not implement the `KeyPairSigner` interface",
      [SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_MODIFYING_SIGNER]: "The provided value does not implement the `MessageModifyingSigner` interface",
      [SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_PARTIAL_SIGNER]: "The provided value does not implement the `MessagePartialSigner` interface",
      [SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_SIGNER]: "The provided value does not implement any of the `MessageSigner` interfaces",
      [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_MODIFYING_SIGNER]: "The provided value does not implement the `TransactionModifyingSigner` interface",
      [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_PARTIAL_SIGNER]: "The provided value does not implement the `TransactionPartialSigner` interface",
      [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SENDING_SIGNER]: "The provided value does not implement the `TransactionSendingSigner` interface",
      [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SIGNER]: "The provided value does not implement any of the `TransactionSigner` interfaces",
      [SOLANA_ERROR__SIGNER__TRANSACTION_CANNOT_HAVE_MULTIPLE_SENDING_SIGNERS]: "More than one `TransactionSendingSigner` was identified.",
      [SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING]: "No `TransactionSendingSigner` was identified. Please provide a valid `ITransactionWithSingleSendingSigner` transaction.",
      [SOLANA_ERROR__SIGNER__WALLET_MULTISIGN_UNIMPLEMENTED]: "Wallet account signers do not support signing multiple messages/transactions in a single operation",
      [SOLANA_ERROR__SUBTLE_CRYPTO__CANNOT_EXPORT_NON_EXTRACTABLE_KEY]: "Cannot export a non-extractable key.",
      [SOLANA_ERROR__SUBTLE_CRYPTO__DIGEST_UNIMPLEMENTED]: "No digest implementation could be found.",
      [SOLANA_ERROR__SUBTLE_CRYPTO__DISALLOWED_IN_INSECURE_CONTEXT]: "Cryptographic operations are only allowed in secure browser contexts. Read more here: https://developer.mozilla.org/en-US/docs/Web/Security/Secure_Contexts.",
      [SOLANA_ERROR__SUBTLE_CRYPTO__ED25519_ALGORITHM_UNIMPLEMENTED]: "This runtime does not support the generation of Ed25519 key pairs.\n\nInstall @solana/webcrypto-ed25519-polyfill and call its `install` function before generating keys in environments that do not support Ed25519.\n\nFor a list of runtimes that currently support Ed25519 operations, visit https://github.com/WICG/webcrypto-secure-curves/issues/20.",
      [SOLANA_ERROR__SUBTLE_CRYPTO__EXPORT_FUNCTION_UNIMPLEMENTED]: "No signature verification implementation could be found.",
      [SOLANA_ERROR__SUBTLE_CRYPTO__GENERATE_FUNCTION_UNIMPLEMENTED]: "No key generation implementation could be found.",
      [SOLANA_ERROR__SUBTLE_CRYPTO__SIGN_FUNCTION_UNIMPLEMENTED]: "No signing implementation could be found.",
      [SOLANA_ERROR__SUBTLE_CRYPTO__VERIFY_FUNCTION_UNIMPLEMENTED]: "No key export implementation could be found.",
      [SOLANA_ERROR__TIMESTAMP_OUT_OF_RANGE]: "Timestamp value must be in the range [-8.64e15, 8.64e15]. `$value` given",
      [SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_BORROW_OUTSTANDING]: "Transaction processing left an account with an outstanding borrowed reference",
      [SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_IN_USE]: "Account in use",
      [SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_LOADED_TWICE]: "Account loaded twice",
      [SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_NOT_FOUND]: "Attempt to debit an account but found no record of a prior credit.",
      [SOLANA_ERROR__TRANSACTION_ERROR__ADDRESS_LOOKUP_TABLE_NOT_FOUND]: "Transaction loads an address table account that doesn't exist",
      [SOLANA_ERROR__TRANSACTION_ERROR__ALREADY_PROCESSED]: "This transaction has already been processed",
      [SOLANA_ERROR__TRANSACTION_ERROR__BLOCKHASH_NOT_FOUND]: "Blockhash not found",
      [SOLANA_ERROR__TRANSACTION_ERROR__CALL_CHAIN_TOO_DEEP]: "Loader call chain is too deep",
      [SOLANA_ERROR__TRANSACTION_ERROR__CLUSTER_MAINTENANCE]: "Transactions are currently disabled due to cluster maintenance",
      [SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION]: "Transaction contains a duplicate instruction ($index) that is not allowed",
      [SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_FEE]: "Insufficient funds for fee",
      [SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT]: "Transaction results in an account ($accountIndex) with insufficient funds for rent",
      [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_FOR_FEE]: "This account may not be used to pay transaction fees",
      [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_INDEX]: "Transaction contains an invalid account reference",
      [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_DATA]: "Transaction loads an address table account with invalid data",
      [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_INDEX]: "Transaction address table lookup uses an invalid index",
      [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_OWNER]: "Transaction loads an address table account with an invalid owner",
      [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_LOADED_ACCOUNTS_DATA_SIZE_LIMIT]: "LoadedAccountsDataSizeLimit set for transaction must be greater than 0.",
      [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_PROGRAM_FOR_EXECUTION]: "This program may not be used for executing instructions",
      [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_RENT_PAYING_ACCOUNT]: "Transaction leaves an account with a lower balance than rent-exempt minimum",
      [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_WRITABLE_ACCOUNT]: "Transaction loads a writable account that cannot be written",
      [SOLANA_ERROR__TRANSACTION_ERROR__MAX_LOADED_ACCOUNTS_DATA_SIZE_EXCEEDED]: "Transaction exceeded max loaded accounts data size cap",
      [SOLANA_ERROR__TRANSACTION_ERROR__MISSING_SIGNATURE_FOR_FEE]: "Transaction requires a fee but has no signature present",
      [SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_ACCOUNT_NOT_FOUND]: "Attempt to load a program that does not exist",
      [SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED]: "Execution of the program referenced by account at index $accountIndex is temporarily restricted.",
      [SOLANA_ERROR__TRANSACTION_ERROR__RESANITIZATION_NEEDED]: "ResanitizationNeeded",
      [SOLANA_ERROR__TRANSACTION_ERROR__SANITIZE_FAILURE]: "Transaction failed to sanitize accounts offsets correctly",
      [SOLANA_ERROR__TRANSACTION_ERROR__SIGNATURE_FAILURE]: "Transaction did not pass signature verification",
      [SOLANA_ERROR__TRANSACTION_ERROR__TOO_MANY_ACCOUNT_LOCKS]: "Transaction locked too many accounts",
      [SOLANA_ERROR__TRANSACTION_ERROR__UNBALANCED_TRANSACTION]: "Sum of account balances before and after transaction do not match",
      [SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN]: "The transaction failed with the error `$errorName`",
      [SOLANA_ERROR__TRANSACTION_ERROR__UNSUPPORTED_VERSION]: "Transaction version is unsupported",
      [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_BLOCK_LIMIT]: "Transaction would exceed account data limit within the block",
      [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_TOTAL_LIMIT]: "Transaction would exceed total account data limit",
      [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_ACCOUNT_COST_LIMIT]: "Transaction would exceed max account limit within the block",
      [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_BLOCK_COST_LIMIT]: "Transaction would exceed max Block Cost Limit",
      [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_VOTE_COST_LIMIT]: "Transaction would exceed max Vote Cost Limit",
      [SOLANA_ERROR__TRANSACTION__ADDRESSES_CANNOT_SIGN_TRANSACTION]: "Attempted to sign a transaction with an address that is not a signer for it",
      [SOLANA_ERROR__TRANSACTION__ADDRESS_MISSING]: "Transaction is missing an address at index: $index.",
      [SOLANA_ERROR__TRANSACTION__CANNOT_ENCODE_WITH_EMPTY_SIGNATURES]: "Transaction has no expected signers therefore it cannot be encoded",
      [SOLANA_ERROR__TRANSACTION__EXPECTED_BLOCKHASH_LIFETIME]: "Transaction does not have a blockhash lifetime",
      [SOLANA_ERROR__TRANSACTION__EXPECTED_NONCE_LIFETIME]: "Transaction is not a durable nonce transaction",
      [SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING]: "Contents of these address lookup tables unknown: $lookupTableAddresses",
      [SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE]: "Lookup of address at index $highestRequestedIndex failed for lookup table `$lookupTableAddress`. Highest known index is $highestKnownIndex. The lookup table may have been extended since its contents were retrieved",
      [SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_FEE_PAYER_MISSING]: "No fee payer set in CompiledTransaction",
      [SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND]: "Could not find program address at index $index",
      [SOLANA_ERROR__TRANSACTION__FAILED_TO_ESTIMATE_COMPUTE_LIMIT]: "Failed to estimate the compute unit consumption for this transaction message. This is likely because simulating the transaction failed. Inspect the `cause` property of this error to learn more",
      [SOLANA_ERROR__TRANSACTION__FEE_PAYER_MISSING]: "Transaction is missing a fee payer.",
      [SOLANA_ERROR__TRANSACTION__FEE_PAYER_SIGNATURE_MISSING]: "Could not determine this transaction's signature. Make sure that the transaction has been signed by its fee payer.",
      [SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_FIRST_INSTRUCTION_MUST_BE_ADVANCE_NONCE]: "Transaction first instruction is not advance nonce account instruction.",
      [SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_INSTRUCTIONS_MISSING]: "Transaction with no instructions cannot be durable nonce transaction.",
      [SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES]: "This transaction includes an address (`$programAddress`) which is both invoked and set as the fee payer. Program addresses may not pay fees",
      [SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE]: "This transaction includes an address (`$programAddress`) which is both invoked and marked writable. Program addresses may not be writable",
      [SOLANA_ERROR__TRANSACTION__MESSAGE_SIGNATURES_MISMATCH]: "The transaction message expected the transaction to have $signerAddressesLength signatures, got $signaturesLength.",
      [SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING]: "Transaction is missing signatures for addresses: $addresses.",
      [SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE]: "Transaction version must be in the range [0, 127]. `$actualVersion` given"
    };
    var START_INDEX = "i";
    var TYPE = "t";
    function getHumanReadableErrorMessage(code, context = {}) {
      const messageFormatString = SolanaErrorMessages[code];
      if (messageFormatString.length === 0) {
        return "";
      }
      let state;
      function commitStateUpTo(endIndex) {
        if (state[TYPE] === 2) {
          const variableName = messageFormatString.slice(state[START_INDEX] + 1, endIndex);
          fragments.push(
            variableName in context ? `${context[variableName]}` : `$${variableName}`
          );
        } else if (state[TYPE] === 1) {
          fragments.push(messageFormatString.slice(state[START_INDEX], endIndex));
        }
      }
      const fragments = [];
      messageFormatString.split("").forEach((char, ii) => {
        if (ii === 0) {
          state = {
            [START_INDEX]: 0,
            [TYPE]: messageFormatString[0] === "\\" ? 0 : messageFormatString[0] === "$" ? 2 : 1
            /* Text */
          };
          return;
        }
        let nextState;
        switch (state[TYPE]) {
          case 0:
            nextState = {
              [START_INDEX]: ii,
              [TYPE]: 1
              /* Text */
            };
            break;
          case 1:
            if (char === "\\") {
              nextState = {
                [START_INDEX]: ii,
                [TYPE]: 0
                /* EscapeSequence */
              };
            } else if (char === "$") {
              nextState = {
                [START_INDEX]: ii,
                [TYPE]: 2
                /* Variable */
              };
            }
            break;
          case 2:
            if (char === "\\") {
              nextState = {
                [START_INDEX]: ii,
                [TYPE]: 0
                /* EscapeSequence */
              };
            } else if (char === "$") {
              nextState = {
                [START_INDEX]: ii,
                [TYPE]: 2
                /* Variable */
              };
            } else if (!char.match(/\w/)) {
              nextState = {
                [START_INDEX]: ii,
                [TYPE]: 1
                /* Text */
              };
            }
            break;
        }
        if (nextState) {
          if (state !== nextState) {
            commitStateUpTo(ii);
          }
          state = nextState;
        }
      });
      commitStateUpTo();
      return fragments.join("");
    }
    function getErrorMessage(code, context = {}) {
      if (process.env.NODE_ENV !== "production") {
        return getHumanReadableErrorMessage(code, context);
      } else {
        let decodingAdviceMessage = `Solana error #${code}; Decode this error by running \`npx @solana/errors decode -- ${code}`;
        if (Object.keys(context).length) {
          decodingAdviceMessage += ` '${encodeContextObject(context)}'`;
        }
        return `${decodingAdviceMessage}\``;
      }
    }
    function isSolanaError(e, code) {
      const isSolanaError2 = e instanceof Error && e.name === "SolanaError";
      if (isSolanaError2) {
        if (code !== void 0) {
          return e.context.__code === code;
        }
        return true;
      }
      return false;
    }
    var SolanaError = class extends Error {
      cause = this.cause;
      context;
      constructor(...[code, contextAndErrorOptions]) {
        let context;
        let errorOptions;
        if (contextAndErrorOptions) {
          const { cause, ...contextRest } = contextAndErrorOptions;
          if (cause) {
            errorOptions = { cause };
          }
          if (Object.keys(contextRest).length > 0) {
            context = contextRest;
          }
        }
        const message = getErrorMessage(code, context);
        super(message, errorOptions);
        this.context = {
          __code: code,
          ...context
        };
        this.name = "SolanaError";
      }
    };
    function safeCaptureStackTrace(...args) {
      if ("captureStackTrace" in Error && typeof Error.captureStackTrace === "function") {
        Error.captureStackTrace(...args);
      }
    }
    function getSolanaErrorFromRpcError({ errorCodeBaseOffset, getErrorContext, orderedErrorNames, rpcEnumError }, constructorOpt) {
      let rpcErrorName;
      let rpcErrorContext;
      if (typeof rpcEnumError === "string") {
        rpcErrorName = rpcEnumError;
      } else {
        rpcErrorName = Object.keys(rpcEnumError)[0];
        rpcErrorContext = rpcEnumError[rpcErrorName];
      }
      const codeOffset = orderedErrorNames.indexOf(rpcErrorName);
      const errorCode = errorCodeBaseOffset + codeOffset;
      const errorContext = getErrorContext(errorCode, rpcErrorName, rpcErrorContext);
      const err = new SolanaError(errorCode, errorContext);
      safeCaptureStackTrace(err, constructorOpt);
      return err;
    }
    var ORDERED_ERROR_NAMES = [
      // Keep synced with RPC source: https://github.com/anza-xyz/agave/blob/master/sdk/program/src/instruction.rs
      // If this list ever gets too large, consider implementing a compression strategy like this:
      // https://gist.github.com/steveluscher/aaa7cbbb5433b1197983908a40860c47
      "GenericError",
      "InvalidArgument",
      "InvalidInstructionData",
      "InvalidAccountData",
      "AccountDataTooSmall",
      "InsufficientFunds",
      "IncorrectProgramId",
      "MissingRequiredSignature",
      "AccountAlreadyInitialized",
      "UninitializedAccount",
      "UnbalancedInstruction",
      "ModifiedProgramId",
      "ExternalAccountLamportSpend",
      "ExternalAccountDataModified",
      "ReadonlyLamportChange",
      "ReadonlyDataModified",
      "DuplicateAccountIndex",
      "ExecutableModified",
      "RentEpochModified",
      "NotEnoughAccountKeys",
      "AccountDataSizeChanged",
      "AccountNotExecutable",
      "AccountBorrowFailed",
      "AccountBorrowOutstanding",
      "DuplicateAccountOutOfSync",
      "Custom",
      "InvalidError",
      "ExecutableDataModified",
      "ExecutableLamportChange",
      "ExecutableAccountNotRentExempt",
      "UnsupportedProgramId",
      "CallDepth",
      "MissingAccount",
      "ReentrancyNotAllowed",
      "MaxSeedLengthExceeded",
      "InvalidSeeds",
      "InvalidRealloc",
      "ComputationalBudgetExceeded",
      "PrivilegeEscalation",
      "ProgramEnvironmentSetupFailure",
      "ProgramFailedToComplete",
      "ProgramFailedToCompile",
      "Immutable",
      "IncorrectAuthority",
      "BorshIoError",
      "AccountNotRentExempt",
      "InvalidAccountOwner",
      "ArithmeticOverflow",
      "UnsupportedSysvar",
      "IllegalOwner",
      "MaxAccountsDataAllocationsExceeded",
      "MaxAccountsExceeded",
      "MaxInstructionTraceLengthExceeded",
      "BuiltinProgramsMustConsumeComputeUnits"
    ];
    function getSolanaErrorFromInstructionError(index, instructionError) {
      return getSolanaErrorFromRpcError(
        {
          errorCodeBaseOffset: 4615001,
          getErrorContext(errorCode, rpcErrorName, rpcErrorContext) {
            if (errorCode === SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN) {
              return {
                errorName: rpcErrorName,
                index,
                ...rpcErrorContext !== void 0 ? { instructionErrorContext: rpcErrorContext } : null
              };
            } else if (errorCode === SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM) {
              return {
                code: rpcErrorContext,
                index
              };
            } else if (errorCode === SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR) {
              return {
                encodedData: rpcErrorContext,
                index
              };
            }
            return { index };
          },
          orderedErrorNames: ORDERED_ERROR_NAMES,
          rpcEnumError: instructionError
        },
        getSolanaErrorFromInstructionError
      );
    }
    var ORDERED_ERROR_NAMES2 = [
      // Keep synced with RPC source: https://github.com/anza-xyz/agave/blob/master/sdk/src/transaction/error.rs
      // If this list ever gets too large, consider implementing a compression strategy like this:
      // https://gist.github.com/steveluscher/aaa7cbbb5433b1197983908a40860c47
      "AccountInUse",
      "AccountLoadedTwice",
      "AccountNotFound",
      "ProgramAccountNotFound",
      "InsufficientFundsForFee",
      "InvalidAccountForFee",
      "AlreadyProcessed",
      "BlockhashNotFound",
      // `InstructionError` intentionally omitted; delegated to `getSolanaErrorFromInstructionError`
      "CallChainTooDeep",
      "MissingSignatureForFee",
      "InvalidAccountIndex",
      "SignatureFailure",
      "InvalidProgramForExecution",
      "SanitizeFailure",
      "ClusterMaintenance",
      "AccountBorrowOutstanding",
      "WouldExceedMaxBlockCostLimit",
      "UnsupportedVersion",
      "InvalidWritableAccount",
      "WouldExceedMaxAccountCostLimit",
      "WouldExceedAccountDataBlockLimit",
      "TooManyAccountLocks",
      "AddressLookupTableNotFound",
      "InvalidAddressLookupTableOwner",
      "InvalidAddressLookupTableData",
      "InvalidAddressLookupTableIndex",
      "InvalidRentPayingAccount",
      "WouldExceedMaxVoteCostLimit",
      "WouldExceedAccountDataTotalLimit",
      "DuplicateInstruction",
      "InsufficientFundsForRent",
      "MaxLoadedAccountsDataSizeExceeded",
      "InvalidLoadedAccountsDataSizeLimit",
      "ResanitizationNeeded",
      "ProgramExecutionTemporarilyRestricted",
      "UnbalancedTransaction"
    ];
    function getSolanaErrorFromTransactionError(transactionError) {
      if (typeof transactionError === "object" && "InstructionError" in transactionError) {
        return getSolanaErrorFromInstructionError(
          ...transactionError.InstructionError
        );
      }
      return getSolanaErrorFromRpcError(
        {
          errorCodeBaseOffset: 7050001,
          getErrorContext(errorCode, rpcErrorName, rpcErrorContext) {
            if (errorCode === SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN) {
              return {
                errorName: rpcErrorName,
                ...rpcErrorContext !== void 0 ? { transactionErrorContext: rpcErrorContext } : null
              };
            } else if (errorCode === SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION) {
              return {
                index: rpcErrorContext
              };
            } else if (errorCode === SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT || errorCode === SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED) {
              return {
                accountIndex: rpcErrorContext.account_index
              };
            }
          },
          orderedErrorNames: ORDERED_ERROR_NAMES2,
          rpcEnumError: transactionError
        },
        getSolanaErrorFromTransactionError
      );
    }
    function getSolanaErrorFromJsonRpcError({ code, data, message }) {
      let out;
      if (code === SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE) {
        const { err, ...preflightErrorContext } = data;
        const causeObject = err ? { cause: getSolanaErrorFromTransactionError(err) } : null;
        out = new SolanaError(SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE, {
          ...preflightErrorContext,
          ...causeObject
        });
      } else {
        let errorContext;
        switch (code) {
          case SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR:
          case SOLANA_ERROR__JSON_RPC__INVALID_PARAMS:
          case SOLANA_ERROR__JSON_RPC__INVALID_REQUEST:
          case SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND:
          case SOLANA_ERROR__JSON_RPC__PARSE_ERROR:
          case SOLANA_ERROR__JSON_RPC__SCAN_ERROR:
          case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP:
          case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE:
          case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET:
          case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX:
          case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED:
          case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED:
          case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE:
          case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION:
            errorContext = { __serverMessage: message };
            break;
          default:
            if (typeof data === "object" && !Array.isArray(data)) {
              errorContext = data;
            }
        }
        out = new SolanaError(code, errorContext);
      }
      safeCaptureStackTrace(out, getSolanaErrorFromJsonRpcError);
      return out;
    }
    exports2.SOLANA_ERROR__ACCOUNTS__ACCOUNT_NOT_FOUND = SOLANA_ERROR__ACCOUNTS__ACCOUNT_NOT_FOUND;
    exports2.SOLANA_ERROR__ACCOUNTS__EXPECTED_ALL_ACCOUNTS_TO_BE_DECODED = SOLANA_ERROR__ACCOUNTS__EXPECTED_ALL_ACCOUNTS_TO_BE_DECODED;
    exports2.SOLANA_ERROR__ACCOUNTS__EXPECTED_DECODED_ACCOUNT = SOLANA_ERROR__ACCOUNTS__EXPECTED_DECODED_ACCOUNT;
    exports2.SOLANA_ERROR__ACCOUNTS__FAILED_TO_DECODE_ACCOUNT = SOLANA_ERROR__ACCOUNTS__FAILED_TO_DECODE_ACCOUNT;
    exports2.SOLANA_ERROR__ACCOUNTS__ONE_OR_MORE_ACCOUNTS_NOT_FOUND = SOLANA_ERROR__ACCOUNTS__ONE_OR_MORE_ACCOUNTS_NOT_FOUND;
    exports2.SOLANA_ERROR__ADDRESSES__FAILED_TO_FIND_VIABLE_PDA_BUMP_SEED = SOLANA_ERROR__ADDRESSES__FAILED_TO_FIND_VIABLE_PDA_BUMP_SEED;
    exports2.SOLANA_ERROR__ADDRESSES__INVALID_BASE58_ENCODED_ADDRESS = SOLANA_ERROR__ADDRESSES__INVALID_BASE58_ENCODED_ADDRESS;
    exports2.SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH = SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH;
    exports2.SOLANA_ERROR__ADDRESSES__INVALID_ED25519_PUBLIC_KEY = SOLANA_ERROR__ADDRESSES__INVALID_ED25519_PUBLIC_KEY;
    exports2.SOLANA_ERROR__ADDRESSES__INVALID_SEEDS_POINT_ON_CURVE = SOLANA_ERROR__ADDRESSES__INVALID_SEEDS_POINT_ON_CURVE;
    exports2.SOLANA_ERROR__ADDRESSES__MALFORMED_PDA = SOLANA_ERROR__ADDRESSES__MALFORMED_PDA;
    exports2.SOLANA_ERROR__ADDRESSES__MAX_NUMBER_OF_PDA_SEEDS_EXCEEDED = SOLANA_ERROR__ADDRESSES__MAX_NUMBER_OF_PDA_SEEDS_EXCEEDED;
    exports2.SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED = SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED;
    exports2.SOLANA_ERROR__ADDRESSES__PDA_BUMP_SEED_OUT_OF_RANGE = SOLANA_ERROR__ADDRESSES__PDA_BUMP_SEED_OUT_OF_RANGE;
    exports2.SOLANA_ERROR__ADDRESSES__PDA_ENDS_WITH_PDA_MARKER = SOLANA_ERROR__ADDRESSES__PDA_ENDS_WITH_PDA_MARKER;
    exports2.SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE = SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE;
    exports2.SOLANA_ERROR__BLOCKHASH_STRING_LENGTH_OUT_OF_RANGE = SOLANA_ERROR__BLOCKHASH_STRING_LENGTH_OUT_OF_RANGE;
    exports2.SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED = SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED;
    exports2.SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY = SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY;
    exports2.SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS = SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS;
    exports2.SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL = SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL;
    exports2.SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH = SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH;
    exports2.SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH = SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH;
    exports2.SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH = SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH;
    exports2.SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE = SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE;
    exports2.SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH = SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH;
    exports2.SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH = SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH;
    exports2.SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH = SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH;
    exports2.SOLANA_ERROR__CODECS__EXPECTED_ZERO_VALUE_TO_MATCH_ITEM_FIXED_SIZE = SOLANA_ERROR__CODECS__EXPECTED_ZERO_VALUE_TO_MATCH_ITEM_FIXED_SIZE;
    exports2.SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH = SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH;
    exports2.SOLANA_ERROR__CODECS__INVALID_CONSTANT = SOLANA_ERROR__CODECS__INVALID_CONSTANT;
    exports2.SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT = SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT;
    exports2.SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT = SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT;
    exports2.SOLANA_ERROR__CODECS__INVALID_LITERAL_UNION_VARIANT = SOLANA_ERROR__CODECS__INVALID_LITERAL_UNION_VARIANT;
    exports2.SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS = SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS;
    exports2.SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE = SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE;
    exports2.SOLANA_ERROR__CODECS__LITERAL_UNION_DISCRIMINATOR_OUT_OF_RANGE = SOLANA_ERROR__CODECS__LITERAL_UNION_DISCRIMINATOR_OUT_OF_RANGE;
    exports2.SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE = SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE;
    exports2.SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE = SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE;
    exports2.SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES = SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES;
    exports2.SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE = SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE;
    exports2.SOLANA_ERROR__CRYPTO__RANDOM_VALUES_FUNCTION_UNIMPLEMENTED = SOLANA_ERROR__CRYPTO__RANDOM_VALUES_FUNCTION_UNIMPLEMENTED;
    exports2.SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_ALREADY_INITIALIZED = SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_ALREADY_INITIALIZED;
    exports2.SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_FAILED = SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_FAILED;
    exports2.SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_OUTSTANDING = SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_OUTSTANDING;
    exports2.SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_SIZE_CHANGED = SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_SIZE_CHANGED;
    exports2.SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_TOO_SMALL = SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_TOO_SMALL;
    exports2.SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_EXECUTABLE = SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_EXECUTABLE;
    exports2.SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_RENT_EXEMPT = SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_RENT_EXEMPT;
    exports2.SOLANA_ERROR__INSTRUCTION_ERROR__ARITHMETIC_OVERFLOW = SOLANA_ERROR__INSTRUCTION_ERROR__ARITHMETIC_OVERFLOW;
    exports2.SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR = SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR;
    exports2.SOLANA_ERROR__INSTRUCTION_ERROR__BUILTIN_PROGRAMS_MUST_CONSUME_COMPUTE_UNITS = SOLANA_ERROR__INSTRUCTION_ERROR__BUILTIN_PROGRAMS_MUST_CONSUME_COMPUTE_UNITS;
    exports2.SOLANA_ERROR__INSTRUCTION_ERROR__CALL_DEPTH = SOLANA_ERROR__INSTRUCTION_ERROR__CALL_DEPTH;
    exports2.SOLANA_ERROR__INSTRUCTION_ERROR__COMPUTATIONAL_BUDGET_EXCEEDED = SOLANA_ERROR__INSTRUCTION_ERROR__COMPUTATIONAL_BUDGET_EXCEEDED;
    exports2.SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM = SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM;
    exports2.SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_INDEX = SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_INDEX;
    exports2.SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_OUT_OF_SYNC = SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_OUT_OF_SYNC;
    exports2.SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_ACCOUNT_NOT_RENT_EXEMPT = SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_ACCOUNT_NOT_RENT_EXEMPT;
    exports2.SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_DATA_MODIFIED = SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_DATA_MODIFIED;
    exports2.SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_LAMPORT_CHANGE = SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_LAMPORT_CHANGE;
    exports2.SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_MODIFIED = SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_MODIFIED;
    exports2.SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_DATA_MODIFIED = SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_DATA_MODIFIED;
    exports2.SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_LAMPORT_SPEND = SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_LAMPORT_SPEND;
    exports2.SOLANA_ERROR__INSTRUCTION_ERROR__GENERIC_ERROR = SOLANA_ERROR__INSTRUCTION_ERROR__GENERIC_ERROR;
    exports2.SOLANA_ERROR__INSTRUCTION_ERROR__ILLEGAL_OWNER = SOLANA_ERROR__INSTRUCTION_ERROR__ILLEGAL_OWNER;
    exports2.SOLANA_ERROR__INSTRUCTION_ERROR__IMMUTABLE = SOLANA_ERROR__INSTRUCTION_ERROR__IMMUTABLE;
    exports2.SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_AUTHORITY = SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_AUTHORITY;
    exports2.SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_PROGRAM_ID = SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_PROGRAM_ID;
    exports2.SOLANA_ERROR__INSTRUCTION_ERROR__INSUFFICIENT_FUNDS = SOLANA_ERROR__INSTRUCTION_ERROR__INSUFFICIENT_FUNDS;
    exports2.SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_DATA = SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_DATA;
    exports2.SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_OWNER = SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_OWNER;
    exports2.SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ARGUMENT = SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ARGUMENT;
    exports2.SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ERROR = SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ERROR;
    exports2.SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_INSTRUCTION_DATA = SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_INSTRUCTION_DATA;
    exports2.SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_REALLOC = SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_REALLOC;
    exports2.SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_SEEDS = SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_SEEDS;
    exports2.SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_DATA_ALLOCATIONS_EXCEEDED = SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_DATA_ALLOCATIONS_EXCEEDED;
    exports2.SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_EXCEEDED = SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_EXCEEDED;
    exports2.SOLANA_ERROR__INSTRUCTION_ERROR__MAX_INSTRUCTION_TRACE_LENGTH_EXCEEDED = SOLANA_ERROR__INSTRUCTION_ERROR__MAX_INSTRUCTION_TRACE_LENGTH_EXCEEDED;
    exports2.SOLANA_ERROR__INSTRUCTION_ERROR__MAX_SEED_LENGTH_EXCEEDED = SOLANA_ERROR__INSTRUCTION_ERROR__MAX_SEED_LENGTH_EXCEEDED;
    exports2.SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_ACCOUNT = SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_ACCOUNT;
    exports2.SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_REQUIRED_SIGNATURE = SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_REQUIRED_SIGNATURE;
    exports2.SOLANA_ERROR__INSTRUCTION_ERROR__MODIFIED_PROGRAM_ID = SOLANA_ERROR__INSTRUCTION_ERROR__MODIFIED_PROGRAM_ID;
    exports2.SOLANA_ERROR__INSTRUCTION_ERROR__NOT_ENOUGH_ACCOUNT_KEYS = SOLANA_ERROR__INSTRUCTION_ERROR__NOT_ENOUGH_ACCOUNT_KEYS;
    exports2.SOLANA_ERROR__INSTRUCTION_ERROR__PRIVILEGE_ESCALATION = SOLANA_ERROR__INSTRUCTION_ERROR__PRIVILEGE_ESCALATION;
    exports2.SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_ENVIRONMENT_SETUP_FAILURE = SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_ENVIRONMENT_SETUP_FAILURE;
    exports2.SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPILE = SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPILE;
    exports2.SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPLETE = SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPLETE;
    exports2.SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_DATA_MODIFIED = SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_DATA_MODIFIED;
    exports2.SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_LAMPORT_CHANGE = SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_LAMPORT_CHANGE;
    exports2.SOLANA_ERROR__INSTRUCTION_ERROR__REENTRANCY_NOT_ALLOWED = SOLANA_ERROR__INSTRUCTION_ERROR__REENTRANCY_NOT_ALLOWED;
    exports2.SOLANA_ERROR__INSTRUCTION_ERROR__RENT_EPOCH_MODIFIED = SOLANA_ERROR__INSTRUCTION_ERROR__RENT_EPOCH_MODIFIED;
    exports2.SOLANA_ERROR__INSTRUCTION_ERROR__UNBALANCED_INSTRUCTION = SOLANA_ERROR__INSTRUCTION_ERROR__UNBALANCED_INSTRUCTION;
    exports2.SOLANA_ERROR__INSTRUCTION_ERROR__UNINITIALIZED_ACCOUNT = SOLANA_ERROR__INSTRUCTION_ERROR__UNINITIALIZED_ACCOUNT;
    exports2.SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN = SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN;
    exports2.SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_PROGRAM_ID = SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_PROGRAM_ID;
    exports2.SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_SYSVAR = SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_SYSVAR;
    exports2.SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_ACCOUNTS = SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_ACCOUNTS;
    exports2.SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_DATA = SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_DATA;
    exports2.SOLANA_ERROR__INSTRUCTION__PROGRAM_ID_MISMATCH = SOLANA_ERROR__INSTRUCTION__PROGRAM_ID_MISMATCH;
    exports2.SOLANA_ERROR__INVALID_BLOCKHASH_BYTE_LENGTH = SOLANA_ERROR__INVALID_BLOCKHASH_BYTE_LENGTH;
    exports2.SOLANA_ERROR__INVALID_NONCE = SOLANA_ERROR__INVALID_NONCE;
    exports2.SOLANA_ERROR__INVARIANT_VIOLATION__CACHED_ABORTABLE_ITERABLE_CACHE_ENTRY_MISSING = SOLANA_ERROR__INVARIANT_VIOLATION__CACHED_ABORTABLE_ITERABLE_CACHE_ENTRY_MISSING;
    exports2.SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE = SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE;
    exports2.SOLANA_ERROR__INVARIANT_VIOLATION__WEBSOCKET_MESSAGE_ITERATOR_MUST_NOT_POLL_BEFORE_RESOLVING_EXISTING_MESSAGE_PROMISE = SOLANA_ERROR__INVARIANT_VIOLATION__WEBSOCKET_MESSAGE_ITERATOR_MUST_NOT_POLL_BEFORE_RESOLVING_EXISTING_MESSAGE_PROMISE;
    exports2.SOLANA_ERROR__INVARIANT_VIOLATION__WEBSOCKET_MESSAGE_ITERATOR_STATE_MISSING = SOLANA_ERROR__INVARIANT_VIOLATION__WEBSOCKET_MESSAGE_ITERATOR_STATE_MISSING;
    exports2.SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR = SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR;
    exports2.SOLANA_ERROR__JSON_RPC__INVALID_PARAMS = SOLANA_ERROR__JSON_RPC__INVALID_PARAMS;
    exports2.SOLANA_ERROR__JSON_RPC__INVALID_REQUEST = SOLANA_ERROR__JSON_RPC__INVALID_REQUEST;
    exports2.SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND = SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND;
    exports2.SOLANA_ERROR__JSON_RPC__PARSE_ERROR = SOLANA_ERROR__JSON_RPC__PARSE_ERROR;
    exports2.SOLANA_ERROR__JSON_RPC__SCAN_ERROR = SOLANA_ERROR__JSON_RPC__SCAN_ERROR;
    exports2.SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP = SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP;
    exports2.SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE = SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE;
    exports2.SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET = SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET;
    exports2.SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX = SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX;
    exports2.SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED = SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED;
    exports2.SOLANA_ERROR__JSON_RPC__SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED = SOLANA_ERROR__JSON_RPC__SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED;
    exports2.SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NODE_UNHEALTHY = SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NODE_UNHEALTHY;
    exports2.SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NO_SNAPSHOT = SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NO_SNAPSHOT;
    exports2.SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE = SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE;
    exports2.SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED = SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED;
    exports2.SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE = SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE;
    exports2.SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE = SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE;
    exports2.SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH = SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH;
    exports2.SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE = SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE;
    exports2.SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION = SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION;
    exports2.SOLANA_ERROR__KEYS__INVALID_KEY_PAIR_BYTE_LENGTH = SOLANA_ERROR__KEYS__INVALID_KEY_PAIR_BYTE_LENGTH;
    exports2.SOLANA_ERROR__KEYS__INVALID_PRIVATE_KEY_BYTE_LENGTH = SOLANA_ERROR__KEYS__INVALID_PRIVATE_KEY_BYTE_LENGTH;
    exports2.SOLANA_ERROR__KEYS__INVALID_SIGNATURE_BYTE_LENGTH = SOLANA_ERROR__KEYS__INVALID_SIGNATURE_BYTE_LENGTH;
    exports2.SOLANA_ERROR__KEYS__PUBLIC_KEY_MUST_MATCH_PRIVATE_KEY = SOLANA_ERROR__KEYS__PUBLIC_KEY_MUST_MATCH_PRIVATE_KEY;
    exports2.SOLANA_ERROR__KEYS__SIGNATURE_STRING_LENGTH_OUT_OF_RANGE = SOLANA_ERROR__KEYS__SIGNATURE_STRING_LENGTH_OUT_OF_RANGE;
    exports2.SOLANA_ERROR__LAMPORTS_OUT_OF_RANGE = SOLANA_ERROR__LAMPORTS_OUT_OF_RANGE;
    exports2.SOLANA_ERROR__MALFORMED_BIGINT_STRING = SOLANA_ERROR__MALFORMED_BIGINT_STRING;
    exports2.SOLANA_ERROR__MALFORMED_NUMBER_STRING = SOLANA_ERROR__MALFORMED_NUMBER_STRING;
    exports2.SOLANA_ERROR__NONCE_ACCOUNT_NOT_FOUND = SOLANA_ERROR__NONCE_ACCOUNT_NOT_FOUND;
    exports2.SOLANA_ERROR__RPC_SUBSCRIPTIONS__CANNOT_CREATE_SUBSCRIPTION_REQUEST = SOLANA_ERROR__RPC_SUBSCRIPTIONS__CANNOT_CREATE_SUBSCRIPTION_REQUEST;
    exports2.SOLANA_ERROR__RPC_SUBSCRIPTIONS__EXPECTED_SERVER_SUBSCRIPTION_ID = SOLANA_ERROR__RPC_SUBSCRIPTIONS__EXPECTED_SERVER_SUBSCRIPTION_ID;
    exports2.SOLANA_ERROR__RPC_SUBSCRIPTIONS__TRANSPORT_CLOSED_BEFORE_MESSAGE_BUFFERED = SOLANA_ERROR__RPC_SUBSCRIPTIONS__TRANSPORT_CLOSED_BEFORE_MESSAGE_BUFFERED;
    exports2.SOLANA_ERROR__RPC_SUBSCRIPTIONS__TRANSPORT_CONNECTION_CLOSED = SOLANA_ERROR__RPC_SUBSCRIPTIONS__TRANSPORT_CONNECTION_CLOSED;
    exports2.SOLANA_ERROR__RPC_SUBSCRIPTIONS__TRANSPORT_FAILED_TO_CONNECT = SOLANA_ERROR__RPC_SUBSCRIPTIONS__TRANSPORT_FAILED_TO_CONNECT;
    exports2.SOLANA_ERROR__RPC__INTEGER_OVERFLOW = SOLANA_ERROR__RPC__INTEGER_OVERFLOW;
    exports2.SOLANA_ERROR__RPC__TRANSPORT_HTTP_ERROR = SOLANA_ERROR__RPC__TRANSPORT_HTTP_ERROR;
    exports2.SOLANA_ERROR__RPC__TRANSPORT_HTTP_HEADER_FORBIDDEN = SOLANA_ERROR__RPC__TRANSPORT_HTTP_HEADER_FORBIDDEN;
    exports2.SOLANA_ERROR__SIGNER__ADDRESS_CANNOT_HAVE_MULTIPLE_SIGNERS = SOLANA_ERROR__SIGNER__ADDRESS_CANNOT_HAVE_MULTIPLE_SIGNERS;
    exports2.SOLANA_ERROR__SIGNER__EXPECTED_KEY_PAIR_SIGNER = SOLANA_ERROR__SIGNER__EXPECTED_KEY_PAIR_SIGNER;
    exports2.SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_MODIFYING_SIGNER = SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_MODIFYING_SIGNER;
    exports2.SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_PARTIAL_SIGNER = SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_PARTIAL_SIGNER;
    exports2.SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_SIGNER = SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_SIGNER;
    exports2.SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_MODIFYING_SIGNER = SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_MODIFYING_SIGNER;
    exports2.SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_PARTIAL_SIGNER = SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_PARTIAL_SIGNER;
    exports2.SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SENDING_SIGNER = SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SENDING_SIGNER;
    exports2.SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SIGNER = SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SIGNER;
    exports2.SOLANA_ERROR__SIGNER__TRANSACTION_CANNOT_HAVE_MULTIPLE_SENDING_SIGNERS = SOLANA_ERROR__SIGNER__TRANSACTION_CANNOT_HAVE_MULTIPLE_SENDING_SIGNERS;
    exports2.SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING = SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING;
    exports2.SOLANA_ERROR__SIGNER__WALLET_MULTISIGN_UNIMPLEMENTED = SOLANA_ERROR__SIGNER__WALLET_MULTISIGN_UNIMPLEMENTED;
    exports2.SOLANA_ERROR__SUBTLE_CRYPTO__CANNOT_EXPORT_NON_EXTRACTABLE_KEY = SOLANA_ERROR__SUBTLE_CRYPTO__CANNOT_EXPORT_NON_EXTRACTABLE_KEY;
    exports2.SOLANA_ERROR__SUBTLE_CRYPTO__DIGEST_UNIMPLEMENTED = SOLANA_ERROR__SUBTLE_CRYPTO__DIGEST_UNIMPLEMENTED;
    exports2.SOLANA_ERROR__SUBTLE_CRYPTO__DISALLOWED_IN_INSECURE_CONTEXT = SOLANA_ERROR__SUBTLE_CRYPTO__DISALLOWED_IN_INSECURE_CONTEXT;
    exports2.SOLANA_ERROR__SUBTLE_CRYPTO__ED25519_ALGORITHM_UNIMPLEMENTED = SOLANA_ERROR__SUBTLE_CRYPTO__ED25519_ALGORITHM_UNIMPLEMENTED;
    exports2.SOLANA_ERROR__SUBTLE_CRYPTO__EXPORT_FUNCTION_UNIMPLEMENTED = SOLANA_ERROR__SUBTLE_CRYPTO__EXPORT_FUNCTION_UNIMPLEMENTED;
    exports2.SOLANA_ERROR__SUBTLE_CRYPTO__GENERATE_FUNCTION_UNIMPLEMENTED = SOLANA_ERROR__SUBTLE_CRYPTO__GENERATE_FUNCTION_UNIMPLEMENTED;
    exports2.SOLANA_ERROR__SUBTLE_CRYPTO__SIGN_FUNCTION_UNIMPLEMENTED = SOLANA_ERROR__SUBTLE_CRYPTO__SIGN_FUNCTION_UNIMPLEMENTED;
    exports2.SOLANA_ERROR__SUBTLE_CRYPTO__VERIFY_FUNCTION_UNIMPLEMENTED = SOLANA_ERROR__SUBTLE_CRYPTO__VERIFY_FUNCTION_UNIMPLEMENTED;
    exports2.SOLANA_ERROR__TIMESTAMP_OUT_OF_RANGE = SOLANA_ERROR__TIMESTAMP_OUT_OF_RANGE;
    exports2.SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_BORROW_OUTSTANDING = SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_BORROW_OUTSTANDING;
    exports2.SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_IN_USE = SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_IN_USE;
    exports2.SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_LOADED_TWICE = SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_LOADED_TWICE;
    exports2.SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_NOT_FOUND = SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_NOT_FOUND;
    exports2.SOLANA_ERROR__TRANSACTION_ERROR__ADDRESS_LOOKUP_TABLE_NOT_FOUND = SOLANA_ERROR__TRANSACTION_ERROR__ADDRESS_LOOKUP_TABLE_NOT_FOUND;
    exports2.SOLANA_ERROR__TRANSACTION_ERROR__ALREADY_PROCESSED = SOLANA_ERROR__TRANSACTION_ERROR__ALREADY_PROCESSED;
    exports2.SOLANA_ERROR__TRANSACTION_ERROR__BLOCKHASH_NOT_FOUND = SOLANA_ERROR__TRANSACTION_ERROR__BLOCKHASH_NOT_FOUND;
    exports2.SOLANA_ERROR__TRANSACTION_ERROR__CALL_CHAIN_TOO_DEEP = SOLANA_ERROR__TRANSACTION_ERROR__CALL_CHAIN_TOO_DEEP;
    exports2.SOLANA_ERROR__TRANSACTION_ERROR__CLUSTER_MAINTENANCE = SOLANA_ERROR__TRANSACTION_ERROR__CLUSTER_MAINTENANCE;
    exports2.SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION = SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION;
    exports2.SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_FEE = SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_FEE;
    exports2.SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT = SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT;
    exports2.SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_FOR_FEE = SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_FOR_FEE;
    exports2.SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_INDEX = SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_INDEX;
    exports2.SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_DATA = SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_DATA;
    exports2.SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_INDEX = SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_INDEX;
    exports2.SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_OWNER = SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_OWNER;
    exports2.SOLANA_ERROR__TRANSACTION_ERROR__INVALID_LOADED_ACCOUNTS_DATA_SIZE_LIMIT = SOLANA_ERROR__TRANSACTION_ERROR__INVALID_LOADED_ACCOUNTS_DATA_SIZE_LIMIT;
    exports2.SOLANA_ERROR__TRANSACTION_ERROR__INVALID_PROGRAM_FOR_EXECUTION = SOLANA_ERROR__TRANSACTION_ERROR__INVALID_PROGRAM_FOR_EXECUTION;
    exports2.SOLANA_ERROR__TRANSACTION_ERROR__INVALID_RENT_PAYING_ACCOUNT = SOLANA_ERROR__TRANSACTION_ERROR__INVALID_RENT_PAYING_ACCOUNT;
    exports2.SOLANA_ERROR__TRANSACTION_ERROR__INVALID_WRITABLE_ACCOUNT = SOLANA_ERROR__TRANSACTION_ERROR__INVALID_WRITABLE_ACCOUNT;
    exports2.SOLANA_ERROR__TRANSACTION_ERROR__MAX_LOADED_ACCOUNTS_DATA_SIZE_EXCEEDED = SOLANA_ERROR__TRANSACTION_ERROR__MAX_LOADED_ACCOUNTS_DATA_SIZE_EXCEEDED;
    exports2.SOLANA_ERROR__TRANSACTION_ERROR__MISSING_SIGNATURE_FOR_FEE = SOLANA_ERROR__TRANSACTION_ERROR__MISSING_SIGNATURE_FOR_FEE;
    exports2.SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_ACCOUNT_NOT_FOUND = SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_ACCOUNT_NOT_FOUND;
    exports2.SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED = SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED;
    exports2.SOLANA_ERROR__TRANSACTION_ERROR__RESANITIZATION_NEEDED = SOLANA_ERROR__TRANSACTION_ERROR__RESANITIZATION_NEEDED;
    exports2.SOLANA_ERROR__TRANSACTION_ERROR__SANITIZE_FAILURE = SOLANA_ERROR__TRANSACTION_ERROR__SANITIZE_FAILURE;
    exports2.SOLANA_ERROR__TRANSACTION_ERROR__SIGNATURE_FAILURE = SOLANA_ERROR__TRANSACTION_ERROR__SIGNATURE_FAILURE;
    exports2.SOLANA_ERROR__TRANSACTION_ERROR__TOO_MANY_ACCOUNT_LOCKS = SOLANA_ERROR__TRANSACTION_ERROR__TOO_MANY_ACCOUNT_LOCKS;
    exports2.SOLANA_ERROR__TRANSACTION_ERROR__UNBALANCED_TRANSACTION = SOLANA_ERROR__TRANSACTION_ERROR__UNBALANCED_TRANSACTION;
    exports2.SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN = SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN;
    exports2.SOLANA_ERROR__TRANSACTION_ERROR__UNSUPPORTED_VERSION = SOLANA_ERROR__TRANSACTION_ERROR__UNSUPPORTED_VERSION;
    exports2.SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_BLOCK_LIMIT = SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_BLOCK_LIMIT;
    exports2.SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_TOTAL_LIMIT = SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_TOTAL_LIMIT;
    exports2.SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_ACCOUNT_COST_LIMIT = SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_ACCOUNT_COST_LIMIT;
    exports2.SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_BLOCK_COST_LIMIT = SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_BLOCK_COST_LIMIT;
    exports2.SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_VOTE_COST_LIMIT = SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_VOTE_COST_LIMIT;
    exports2.SOLANA_ERROR__TRANSACTION__ADDRESSES_CANNOT_SIGN_TRANSACTION = SOLANA_ERROR__TRANSACTION__ADDRESSES_CANNOT_SIGN_TRANSACTION;
    exports2.SOLANA_ERROR__TRANSACTION__ADDRESS_MISSING = SOLANA_ERROR__TRANSACTION__ADDRESS_MISSING;
    exports2.SOLANA_ERROR__TRANSACTION__CANNOT_ENCODE_WITH_EMPTY_SIGNATURES = SOLANA_ERROR__TRANSACTION__CANNOT_ENCODE_WITH_EMPTY_SIGNATURES;
    exports2.SOLANA_ERROR__TRANSACTION__EXPECTED_BLOCKHASH_LIFETIME = SOLANA_ERROR__TRANSACTION__EXPECTED_BLOCKHASH_LIFETIME;
    exports2.SOLANA_ERROR__TRANSACTION__EXPECTED_NONCE_LIFETIME = SOLANA_ERROR__TRANSACTION__EXPECTED_NONCE_LIFETIME;
    exports2.SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING = SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING;
    exports2.SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE = SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE;
    exports2.SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_FEE_PAYER_MISSING = SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_FEE_PAYER_MISSING;
    exports2.SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND = SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND;
    exports2.SOLANA_ERROR__TRANSACTION__FAILED_TO_ESTIMATE_COMPUTE_LIMIT = SOLANA_ERROR__TRANSACTION__FAILED_TO_ESTIMATE_COMPUTE_LIMIT;
    exports2.SOLANA_ERROR__TRANSACTION__FEE_PAYER_MISSING = SOLANA_ERROR__TRANSACTION__FEE_PAYER_MISSING;
    exports2.SOLANA_ERROR__TRANSACTION__FEE_PAYER_SIGNATURE_MISSING = SOLANA_ERROR__TRANSACTION__FEE_PAYER_SIGNATURE_MISSING;
    exports2.SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_FIRST_INSTRUCTION_MUST_BE_ADVANCE_NONCE = SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_FIRST_INSTRUCTION_MUST_BE_ADVANCE_NONCE;
    exports2.SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_INSTRUCTIONS_MISSING = SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_INSTRUCTIONS_MISSING;
    exports2.SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES = SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES;
    exports2.SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE = SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE;
    exports2.SOLANA_ERROR__TRANSACTION__MESSAGE_SIGNATURES_MISMATCH = SOLANA_ERROR__TRANSACTION__MESSAGE_SIGNATURES_MISMATCH;
    exports2.SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING = SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING;
    exports2.SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE = SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE;
    exports2.SolanaError = SolanaError;
    exports2.getSolanaErrorFromInstructionError = getSolanaErrorFromInstructionError;
    exports2.getSolanaErrorFromJsonRpcError = getSolanaErrorFromJsonRpcError;
    exports2.getSolanaErrorFromTransactionError = getSolanaErrorFromTransactionError;
    exports2.isSolanaError = isSolanaError;
    exports2.safeCaptureStackTrace = safeCaptureStackTrace;
  }
});

// node_modules/@solana/codecs-core/dist/index.node.cjs
var require_index_node2 = __commonJS({
  "node_modules/@solana/codecs-core/dist/index.node.cjs"(exports2) {
    "use strict";
    var errors = require_index_node();
    var mergeBytes = (byteArrays) => {
      const nonEmptyByteArrays = byteArrays.filter((arr) => arr.length);
      if (nonEmptyByteArrays.length === 0) {
        return byteArrays.length ? byteArrays[0] : new Uint8Array();
      }
      if (nonEmptyByteArrays.length === 1) {
        return nonEmptyByteArrays[0];
      }
      const totalLength = nonEmptyByteArrays.reduce((total, arr) => total + arr.length, 0);
      const result = new Uint8Array(totalLength);
      let offset2 = 0;
      nonEmptyByteArrays.forEach((arr) => {
        result.set(arr, offset2);
        offset2 += arr.length;
      });
      return result;
    };
    var padBytes = (bytes, length) => {
      if (bytes.length >= length)
        return bytes;
      const paddedBytes = new Uint8Array(length).fill(0);
      paddedBytes.set(bytes);
      return paddedBytes;
    };
    var fixBytes = (bytes, length) => padBytes(bytes.length <= length ? bytes : bytes.slice(0, length), length);
    function containsBytes(data, bytes, offset2) {
      const slice = offset2 === 0 && data.length === bytes.length ? data : data.slice(offset2, offset2 + bytes.length);
      if (slice.length !== bytes.length)
        return false;
      return bytes.every((b, i) => b === slice[i]);
    }
    function getEncodedSize(value, encoder) {
      return "fixedSize" in encoder ? encoder.fixedSize : encoder.getSizeFromValue(value);
    }
    function createEncoder(encoder) {
      return Object.freeze({
        ...encoder,
        encode: (value) => {
          const bytes = new Uint8Array(getEncodedSize(value, encoder));
          encoder.write(value, bytes, 0);
          return bytes;
        }
      });
    }
    function createDecoder(decoder) {
      return Object.freeze({
        ...decoder,
        decode: (bytes, offset2 = 0) => decoder.read(bytes, offset2)[0]
      });
    }
    function createCodec(codec) {
      return Object.freeze({
        ...codec,
        decode: (bytes, offset2 = 0) => codec.read(bytes, offset2)[0],
        encode: (value) => {
          const bytes = new Uint8Array(getEncodedSize(value, codec));
          codec.write(value, bytes, 0);
          return bytes;
        }
      });
    }
    function isFixedSize(codec) {
      return "fixedSize" in codec && typeof codec.fixedSize === "number";
    }
    function assertIsFixedSize(codec) {
      if (!isFixedSize(codec)) {
        throw new errors.SolanaError(errors.SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH);
      }
    }
    function isVariableSize(codec) {
      return !isFixedSize(codec);
    }
    function assertIsVariableSize(codec) {
      if (!isVariableSize(codec)) {
        throw new errors.SolanaError(errors.SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH);
      }
    }
    function combineCodec(encoder, decoder) {
      if (isFixedSize(encoder) !== isFixedSize(decoder)) {
        throw new errors.SolanaError(errors.SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH);
      }
      if (isFixedSize(encoder) && isFixedSize(decoder) && encoder.fixedSize !== decoder.fixedSize) {
        throw new errors.SolanaError(errors.SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH, {
          decoderFixedSize: decoder.fixedSize,
          encoderFixedSize: encoder.fixedSize
        });
      }
      if (!isFixedSize(encoder) && !isFixedSize(decoder) && encoder.maxSize !== decoder.maxSize) {
        throw new errors.SolanaError(errors.SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH, {
          decoderMaxSize: decoder.maxSize,
          encoderMaxSize: encoder.maxSize
        });
      }
      return {
        ...decoder,
        ...encoder,
        decode: decoder.decode,
        encode: encoder.encode,
        read: decoder.read,
        write: encoder.write
      };
    }
    function addEncoderSentinel(encoder, sentinel) {
      const write = (value, bytes, offset2) => {
        const encoderBytes = encoder.encode(value);
        if (findSentinelIndex(encoderBytes, sentinel) >= 0) {
          throw new errors.SolanaError(errors.SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL, {
            encodedBytes: encoderBytes,
            hexEncodedBytes: hexBytes(encoderBytes),
            hexSentinel: hexBytes(sentinel),
            sentinel
          });
        }
        bytes.set(encoderBytes, offset2);
        offset2 += encoderBytes.length;
        bytes.set(sentinel, offset2);
        offset2 += sentinel.length;
        return offset2;
      };
      if (isFixedSize(encoder)) {
        return createEncoder({ ...encoder, fixedSize: encoder.fixedSize + sentinel.length, write });
      }
      return createEncoder({
        ...encoder,
        ...encoder.maxSize != null ? { maxSize: encoder.maxSize + sentinel.length } : {},
        getSizeFromValue: (value) => encoder.getSizeFromValue(value) + sentinel.length,
        write
      });
    }
    function addDecoderSentinel(decoder, sentinel) {
      const read = (bytes, offset2) => {
        const candidateBytes = offset2 === 0 ? bytes : bytes.slice(offset2);
        const sentinelIndex = findSentinelIndex(candidateBytes, sentinel);
        if (sentinelIndex === -1) {
          throw new errors.SolanaError(errors.SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES, {
            decodedBytes: candidateBytes,
            hexDecodedBytes: hexBytes(candidateBytes),
            hexSentinel: hexBytes(sentinel),
            sentinel
          });
        }
        const preSentinelBytes = candidateBytes.slice(0, sentinelIndex);
        return [decoder.decode(preSentinelBytes), offset2 + preSentinelBytes.length + sentinel.length];
      };
      if (isFixedSize(decoder)) {
        return createDecoder({ ...decoder, fixedSize: decoder.fixedSize + sentinel.length, read });
      }
      return createDecoder({
        ...decoder,
        ...decoder.maxSize != null ? { maxSize: decoder.maxSize + sentinel.length } : {},
        read
      });
    }
    function addCodecSentinel(codec, sentinel) {
      return combineCodec(addEncoderSentinel(codec, sentinel), addDecoderSentinel(codec, sentinel));
    }
    function findSentinelIndex(bytes, sentinel) {
      return bytes.findIndex((byte, index, arr) => {
        if (sentinel.length === 1)
          return byte === sentinel[0];
        return containsBytes(arr, sentinel, index);
      });
    }
    function hexBytes(bytes) {
      return bytes.reduce((str2, byte) => str2 + byte.toString(16).padStart(2, "0"), "");
    }
    function assertByteArrayIsNotEmptyForCodec(codecDescription, bytes, offset2 = 0) {
      if (bytes.length - offset2 <= 0) {
        throw new errors.SolanaError(errors.SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY, {
          codecDescription
        });
      }
    }
    function assertByteArrayHasEnoughBytesForCodec(codecDescription, expected, bytes, offset2 = 0) {
      const bytesLength = bytes.length - offset2;
      if (bytesLength < expected) {
        throw new errors.SolanaError(errors.SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH, {
          bytesLength,
          codecDescription,
          expected
        });
      }
    }
    function assertByteArrayOffsetIsNotOutOfRange(codecDescription, offset2, bytesLength) {
      if (offset2 < 0 || offset2 > bytesLength) {
        throw new errors.SolanaError(errors.SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE, {
          bytesLength,
          codecDescription,
          offset: offset2
        });
      }
    }
    function addEncoderSizePrefix(encoder, prefix) {
      const write = (value, bytes, offset2) => {
        const encoderBytes = encoder.encode(value);
        offset2 = prefix.write(encoderBytes.length, bytes, offset2);
        bytes.set(encoderBytes, offset2);
        return offset2 + encoderBytes.length;
      };
      if (isFixedSize(prefix) && isFixedSize(encoder)) {
        return createEncoder({ ...encoder, fixedSize: prefix.fixedSize + encoder.fixedSize, write });
      }
      const prefixMaxSize = isFixedSize(prefix) ? prefix.fixedSize : prefix.maxSize ?? null;
      const encoderMaxSize = isFixedSize(encoder) ? encoder.fixedSize : encoder.maxSize ?? null;
      const maxSize = prefixMaxSize !== null && encoderMaxSize !== null ? prefixMaxSize + encoderMaxSize : null;
      return createEncoder({
        ...encoder,
        ...maxSize !== null ? { maxSize } : {},
        getSizeFromValue: (value) => {
          const encoderSize = getEncodedSize(value, encoder);
          return getEncodedSize(encoderSize, prefix) + encoderSize;
        },
        write
      });
    }
    function addDecoderSizePrefix(decoder, prefix) {
      const read = (bytes, offset2) => {
        const [bigintSize, decoderOffset] = prefix.read(bytes, offset2);
        const size = Number(bigintSize);
        offset2 = decoderOffset;
        if (offset2 > 0 || bytes.length > size) {
          bytes = bytes.slice(offset2, offset2 + size);
        }
        assertByteArrayHasEnoughBytesForCodec("addDecoderSizePrefix", size, bytes);
        return [decoder.decode(bytes), offset2 + size];
      };
      if (isFixedSize(prefix) && isFixedSize(decoder)) {
        return createDecoder({ ...decoder, fixedSize: prefix.fixedSize + decoder.fixedSize, read });
      }
      const prefixMaxSize = isFixedSize(prefix) ? prefix.fixedSize : prefix.maxSize ?? null;
      const decoderMaxSize = isFixedSize(decoder) ? decoder.fixedSize : decoder.maxSize ?? null;
      const maxSize = prefixMaxSize !== null && decoderMaxSize !== null ? prefixMaxSize + decoderMaxSize : null;
      return createDecoder({ ...decoder, ...maxSize !== null ? { maxSize } : {}, read });
    }
    function addCodecSizePrefix(codec, prefix) {
      return combineCodec(addEncoderSizePrefix(codec, prefix), addDecoderSizePrefix(codec, prefix));
    }
    function fixEncoderSize(encoder, fixedBytes) {
      return createEncoder({
        fixedSize: fixedBytes,
        write: (value, bytes, offset2) => {
          const variableByteArray = encoder.encode(value);
          const fixedByteArray = variableByteArray.length > fixedBytes ? variableByteArray.slice(0, fixedBytes) : variableByteArray;
          bytes.set(fixedByteArray, offset2);
          return offset2 + fixedBytes;
        }
      });
    }
    function fixDecoderSize(decoder, fixedBytes) {
      return createDecoder({
        fixedSize: fixedBytes,
        read: (bytes, offset2) => {
          assertByteArrayHasEnoughBytesForCodec("fixCodecSize", fixedBytes, bytes, offset2);
          if (offset2 > 0 || bytes.length > fixedBytes) {
            bytes = bytes.slice(offset2, offset2 + fixedBytes);
          }
          if (isFixedSize(decoder)) {
            bytes = fixBytes(bytes, decoder.fixedSize);
          }
          const [value] = decoder.read(bytes, 0);
          return [value, offset2 + fixedBytes];
        }
      });
    }
    function fixCodecSize(codec, fixedBytes) {
      return combineCodec(fixEncoderSize(codec, fixedBytes), fixDecoderSize(codec, fixedBytes));
    }
    function offsetEncoder(encoder, config2) {
      return createEncoder({
        ...encoder,
        write: (value, bytes, preOffset) => {
          const wrapBytes = (offset2) => modulo(offset2, bytes.length);
          const newPreOffset = config2.preOffset ? config2.preOffset({ bytes, preOffset, wrapBytes }) : preOffset;
          assertByteArrayOffsetIsNotOutOfRange("offsetEncoder", newPreOffset, bytes.length);
          const postOffset = encoder.write(value, bytes, newPreOffset);
          const newPostOffset = config2.postOffset ? config2.postOffset({ bytes, newPreOffset, postOffset, preOffset, wrapBytes }) : postOffset;
          assertByteArrayOffsetIsNotOutOfRange("offsetEncoder", newPostOffset, bytes.length);
          return newPostOffset;
        }
      });
    }
    function offsetDecoder(decoder, config2) {
      return createDecoder({
        ...decoder,
        read: (bytes, preOffset) => {
          const wrapBytes = (offset2) => modulo(offset2, bytes.length);
          const newPreOffset = config2.preOffset ? config2.preOffset({ bytes, preOffset, wrapBytes }) : preOffset;
          assertByteArrayOffsetIsNotOutOfRange("offsetDecoder", newPreOffset, bytes.length);
          const [value, postOffset] = decoder.read(bytes, newPreOffset);
          const newPostOffset = config2.postOffset ? config2.postOffset({ bytes, newPreOffset, postOffset, preOffset, wrapBytes }) : postOffset;
          assertByteArrayOffsetIsNotOutOfRange("offsetDecoder", newPostOffset, bytes.length);
          return [value, newPostOffset];
        }
      });
    }
    function offsetCodec(codec, config2) {
      return combineCodec(offsetEncoder(codec, config2), offsetDecoder(codec, config2));
    }
    function modulo(dividend, divisor) {
      if (divisor === 0)
        return 0;
      return (dividend % divisor + divisor) % divisor;
    }
    function resizeEncoder(encoder, resize) {
      if (isFixedSize(encoder)) {
        const fixedSize = resize(encoder.fixedSize);
        if (fixedSize < 0) {
          throw new errors.SolanaError(errors.SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH, {
            bytesLength: fixedSize,
            codecDescription: "resizeEncoder"
          });
        }
        return createEncoder({ ...encoder, fixedSize });
      }
      return createEncoder({
        ...encoder,
        getSizeFromValue: (value) => {
          const newSize = resize(encoder.getSizeFromValue(value));
          if (newSize < 0) {
            throw new errors.SolanaError(errors.SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH, {
              bytesLength: newSize,
              codecDescription: "resizeEncoder"
            });
          }
          return newSize;
        }
      });
    }
    function resizeDecoder(decoder, resize) {
      if (isFixedSize(decoder)) {
        const fixedSize = resize(decoder.fixedSize);
        if (fixedSize < 0) {
          throw new errors.SolanaError(errors.SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH, {
            bytesLength: fixedSize,
            codecDescription: "resizeDecoder"
          });
        }
        return createDecoder({ ...decoder, fixedSize });
      }
      return decoder;
    }
    function resizeCodec(codec, resize) {
      return combineCodec(resizeEncoder(codec, resize), resizeDecoder(codec, resize));
    }
    function padLeftEncoder(encoder, offset2) {
      return offsetEncoder(
        resizeEncoder(encoder, (size) => size + offset2),
        { preOffset: ({ preOffset }) => preOffset + offset2 }
      );
    }
    function padRightEncoder(encoder, offset2) {
      return offsetEncoder(
        resizeEncoder(encoder, (size) => size + offset2),
        { postOffset: ({ postOffset }) => postOffset + offset2 }
      );
    }
    function padLeftDecoder(decoder, offset2) {
      return offsetDecoder(
        resizeDecoder(decoder, (size) => size + offset2),
        { preOffset: ({ preOffset }) => preOffset + offset2 }
      );
    }
    function padRightDecoder(decoder, offset2) {
      return offsetDecoder(
        resizeDecoder(decoder, (size) => size + offset2),
        { postOffset: ({ postOffset }) => postOffset + offset2 }
      );
    }
    function padLeftCodec(codec, offset2) {
      return combineCodec(padLeftEncoder(codec, offset2), padLeftDecoder(codec, offset2));
    }
    function padRightCodec(codec, offset2) {
      return combineCodec(padRightEncoder(codec, offset2), padRightDecoder(codec, offset2));
    }
    function copySourceToTargetInReverse(source, target_WILL_MUTATE, sourceOffset, sourceLength, targetOffset = 0) {
      while (sourceOffset < --sourceLength) {
        const leftValue = source[sourceOffset];
        target_WILL_MUTATE[sourceOffset + targetOffset] = source[sourceLength];
        target_WILL_MUTATE[sourceLength + targetOffset] = leftValue;
        sourceOffset++;
      }
      if (sourceOffset === sourceLength) {
        target_WILL_MUTATE[sourceOffset + targetOffset] = source[sourceOffset];
      }
    }
    function reverseEncoder(encoder) {
      assertIsFixedSize(encoder);
      return createEncoder({
        ...encoder,
        write: (value, bytes, offset2) => {
          const newOffset = encoder.write(value, bytes, offset2);
          copySourceToTargetInReverse(
            bytes,
            bytes,
            offset2,
            offset2 + encoder.fixedSize
          );
          return newOffset;
        }
      });
    }
    function reverseDecoder(decoder) {
      assertIsFixedSize(decoder);
      return createDecoder({
        ...decoder,
        read: (bytes, offset2) => {
          const reversedBytes = bytes.slice();
          copySourceToTargetInReverse(
            bytes,
            reversedBytes,
            offset2,
            offset2 + decoder.fixedSize
          );
          return decoder.read(reversedBytes, offset2);
        }
      });
    }
    function reverseCodec(codec) {
      return combineCodec(reverseEncoder(codec), reverseDecoder(codec));
    }
    function transformEncoder(encoder, unmap) {
      return createEncoder({
        ...isVariableSize(encoder) ? { ...encoder, getSizeFromValue: (value) => encoder.getSizeFromValue(unmap(value)) } : encoder,
        write: (value, bytes, offset2) => encoder.write(unmap(value), bytes, offset2)
      });
    }
    function transformDecoder(decoder, map) {
      return createDecoder({
        ...decoder,
        read: (bytes, offset2) => {
          const [value, newOffset] = decoder.read(bytes, offset2);
          return [map(value, bytes, offset2), newOffset];
        }
      });
    }
    function transformCodec(codec, unmap, map) {
      return createCodec({
        ...transformEncoder(codec, unmap),
        read: map ? transformDecoder(codec, map).read : codec.read
      });
    }
    exports2.addCodecSentinel = addCodecSentinel;
    exports2.addCodecSizePrefix = addCodecSizePrefix;
    exports2.addDecoderSentinel = addDecoderSentinel;
    exports2.addDecoderSizePrefix = addDecoderSizePrefix;
    exports2.addEncoderSentinel = addEncoderSentinel;
    exports2.addEncoderSizePrefix = addEncoderSizePrefix;
    exports2.assertByteArrayHasEnoughBytesForCodec = assertByteArrayHasEnoughBytesForCodec;
    exports2.assertByteArrayIsNotEmptyForCodec = assertByteArrayIsNotEmptyForCodec;
    exports2.assertByteArrayOffsetIsNotOutOfRange = assertByteArrayOffsetIsNotOutOfRange;
    exports2.assertIsFixedSize = assertIsFixedSize;
    exports2.assertIsVariableSize = assertIsVariableSize;
    exports2.combineCodec = combineCodec;
    exports2.containsBytes = containsBytes;
    exports2.createCodec = createCodec;
    exports2.createDecoder = createDecoder;
    exports2.createEncoder = createEncoder;
    exports2.fixBytes = fixBytes;
    exports2.fixCodecSize = fixCodecSize;
    exports2.fixDecoderSize = fixDecoderSize;
    exports2.fixEncoderSize = fixEncoderSize;
    exports2.getEncodedSize = getEncodedSize;
    exports2.isFixedSize = isFixedSize;
    exports2.isVariableSize = isVariableSize;
    exports2.mergeBytes = mergeBytes;
    exports2.offsetCodec = offsetCodec;
    exports2.offsetDecoder = offsetDecoder;
    exports2.offsetEncoder = offsetEncoder;
    exports2.padBytes = padBytes;
    exports2.padLeftCodec = padLeftCodec;
    exports2.padLeftDecoder = padLeftDecoder;
    exports2.padLeftEncoder = padLeftEncoder;
    exports2.padRightCodec = padRightCodec;
    exports2.padRightDecoder = padRightDecoder;
    exports2.padRightEncoder = padRightEncoder;
    exports2.resizeCodec = resizeCodec;
    exports2.resizeDecoder = resizeDecoder;
    exports2.resizeEncoder = resizeEncoder;
    exports2.reverseCodec = reverseCodec;
    exports2.reverseDecoder = reverseDecoder;
    exports2.reverseEncoder = reverseEncoder;
    exports2.transformCodec = transformCodec;
    exports2.transformDecoder = transformDecoder;
    exports2.transformEncoder = transformEncoder;
  }
});

// node_modules/@solana/codecs-numbers/dist/index.node.cjs
var require_index_node3 = __commonJS({
  "node_modules/@solana/codecs-numbers/dist/index.node.cjs"(exports2) {
    "use strict";
    var errors = require_index_node();
    var codecsCore = require_index_node2();
    function assertNumberIsBetweenForCodec(codecDescription, min2, max2, value) {
      if (value < min2 || value > max2) {
        throw new errors.SolanaError(errors.SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE, {
          codecDescription,
          max: max2,
          min: min2,
          value
        });
      }
    }
    var Endian = /* @__PURE__ */ ((Endian2) => {
      Endian2[Endian2["Little"] = 0] = "Little";
      Endian2[Endian2["Big"] = 1] = "Big";
      return Endian2;
    })(Endian || {});
    function isLittleEndian(config2) {
      return config2?.endian === 1 ? false : true;
    }
    function numberEncoderFactory(input) {
      return codecsCore.createEncoder({
        fixedSize: input.size,
        write(value, bytes, offset2) {
          if (input.range) {
            assertNumberIsBetweenForCodec(input.name, input.range[0], input.range[1], value);
          }
          const arrayBuffer = new ArrayBuffer(input.size);
          input.set(new DataView(arrayBuffer), value, isLittleEndian(input.config));
          bytes.set(new Uint8Array(arrayBuffer), offset2);
          return offset2 + input.size;
        }
      });
    }
    function numberDecoderFactory(input) {
      return codecsCore.createDecoder({
        fixedSize: input.size,
        read(bytes, offset2 = 0) {
          codecsCore.assertByteArrayIsNotEmptyForCodec(input.name, bytes, offset2);
          codecsCore.assertByteArrayHasEnoughBytesForCodec(input.name, input.size, bytes, offset2);
          const view = new DataView(toArrayBuffer(bytes, offset2, input.size));
          return [input.get(view, isLittleEndian(input.config)), offset2 + input.size];
        }
      });
    }
    function toArrayBuffer(bytes, offset2, length) {
      const bytesOffset = bytes.byteOffset + (offset2 ?? 0);
      const bytesLength = length ?? bytes.byteLength;
      return bytes.buffer.slice(bytesOffset, bytesOffset + bytesLength);
    }
    var getF32Encoder = (config2 = {}) => numberEncoderFactory({
      config: config2,
      name: "f32",
      set: (view, value, le) => view.setFloat32(0, Number(value), le),
      size: 4
    });
    var getF32Decoder = (config2 = {}) => numberDecoderFactory({
      config: config2,
      get: (view, le) => view.getFloat32(0, le),
      name: "f32",
      size: 4
    });
    var getF32Codec = (config2 = {}) => codecsCore.combineCodec(getF32Encoder(config2), getF32Decoder(config2));
    var getF64Encoder = (config2 = {}) => numberEncoderFactory({
      config: config2,
      name: "f64",
      set: (view, value, le) => view.setFloat64(0, Number(value), le),
      size: 8
    });
    var getF64Decoder = (config2 = {}) => numberDecoderFactory({
      config: config2,
      get: (view, le) => view.getFloat64(0, le),
      name: "f64",
      size: 8
    });
    var getF64Codec = (config2 = {}) => codecsCore.combineCodec(getF64Encoder(config2), getF64Decoder(config2));
    var getI128Encoder = (config2 = {}) => numberEncoderFactory({
      config: config2,
      name: "i128",
      range: [-BigInt("0x7fffffffffffffffffffffffffffffff") - 1n, BigInt("0x7fffffffffffffffffffffffffffffff")],
      set: (view, value, le) => {
        const leftOffset = le ? 8 : 0;
        const rightOffset = le ? 0 : 8;
        const rightMask = 0xffffffffffffffffn;
        view.setBigInt64(leftOffset, BigInt(value) >> 64n, le);
        view.setBigUint64(rightOffset, BigInt(value) & rightMask, le);
      },
      size: 16
    });
    var getI128Decoder = (config2 = {}) => numberDecoderFactory({
      config: config2,
      get: (view, le) => {
        const leftOffset = le ? 8 : 0;
        const rightOffset = le ? 0 : 8;
        const left = view.getBigInt64(leftOffset, le);
        const right = view.getBigUint64(rightOffset, le);
        return (left << 64n) + right;
      },
      name: "i128",
      size: 16
    });
    var getI128Codec = (config2 = {}) => codecsCore.combineCodec(getI128Encoder(config2), getI128Decoder(config2));
    var getI16Encoder = (config2 = {}) => numberEncoderFactory({
      config: config2,
      name: "i16",
      range: [-Number("0x7fff") - 1, Number("0x7fff")],
      set: (view, value, le) => view.setInt16(0, Number(value), le),
      size: 2
    });
    var getI16Decoder = (config2 = {}) => numberDecoderFactory({
      config: config2,
      get: (view, le) => view.getInt16(0, le),
      name: "i16",
      size: 2
    });
    var getI16Codec = (config2 = {}) => codecsCore.combineCodec(getI16Encoder(config2), getI16Decoder(config2));
    var getI32Encoder = (config2 = {}) => numberEncoderFactory({
      config: config2,
      name: "i32",
      range: [-Number("0x7fffffff") - 1, Number("0x7fffffff")],
      set: (view, value, le) => view.setInt32(0, Number(value), le),
      size: 4
    });
    var getI32Decoder = (config2 = {}) => numberDecoderFactory({
      config: config2,
      get: (view, le) => view.getInt32(0, le),
      name: "i32",
      size: 4
    });
    var getI32Codec = (config2 = {}) => codecsCore.combineCodec(getI32Encoder(config2), getI32Decoder(config2));
    var getI64Encoder = (config2 = {}) => numberEncoderFactory({
      config: config2,
      name: "i64",
      range: [-BigInt("0x7fffffffffffffff") - 1n, BigInt("0x7fffffffffffffff")],
      set: (view, value, le) => view.setBigInt64(0, BigInt(value), le),
      size: 8
    });
    var getI64Decoder = (config2 = {}) => numberDecoderFactory({
      config: config2,
      get: (view, le) => view.getBigInt64(0, le),
      name: "i64",
      size: 8
    });
    var getI64Codec = (config2 = {}) => codecsCore.combineCodec(getI64Encoder(config2), getI64Decoder(config2));
    var getI8Encoder = () => numberEncoderFactory({
      name: "i8",
      range: [-Number("0x7f") - 1, Number("0x7f")],
      set: (view, value) => view.setInt8(0, Number(value)),
      size: 1
    });
    var getI8Decoder = () => numberDecoderFactory({
      get: (view) => view.getInt8(0),
      name: "i8",
      size: 1
    });
    var getI8Codec = () => codecsCore.combineCodec(getI8Encoder(), getI8Decoder());
    var getShortU16Encoder = () => codecsCore.createEncoder({
      getSizeFromValue: (value) => {
        if (value <= 127)
          return 1;
        if (value <= 16383)
          return 2;
        return 3;
      },
      maxSize: 3,
      write: (value, bytes, offset2) => {
        assertNumberIsBetweenForCodec("shortU16", 0, 65535, value);
        const shortU16Bytes = [0];
        for (let ii = 0; ; ii += 1) {
          const alignedValue = Number(value) >> ii * 7;
          if (alignedValue === 0) {
            break;
          }
          const nextSevenBits = 127 & alignedValue;
          shortU16Bytes[ii] = nextSevenBits;
          if (ii > 0) {
            shortU16Bytes[ii - 1] |= 128;
          }
        }
        bytes.set(shortU16Bytes, offset2);
        return offset2 + shortU16Bytes.length;
      }
    });
    var getShortU16Decoder = () => codecsCore.createDecoder({
      maxSize: 3,
      read: (bytes, offset2) => {
        let value = 0;
        let byteCount = 0;
        while (++byteCount) {
          const byteIndex = byteCount - 1;
          const currentByte = bytes[offset2 + byteIndex];
          const nextSevenBits = 127 & currentByte;
          value |= nextSevenBits << byteIndex * 7;
          if ((currentByte & 128) === 0) {
            break;
          }
        }
        return [value, offset2 + byteCount];
      }
    });
    var getShortU16Codec = () => codecsCore.combineCodec(getShortU16Encoder(), getShortU16Decoder());
    var getU128Encoder = (config2 = {}) => numberEncoderFactory({
      config: config2,
      name: "u128",
      range: [0n, BigInt("0xffffffffffffffffffffffffffffffff")],
      set: (view, value, le) => {
        const leftOffset = le ? 8 : 0;
        const rightOffset = le ? 0 : 8;
        const rightMask = 0xffffffffffffffffn;
        view.setBigUint64(leftOffset, BigInt(value) >> 64n, le);
        view.setBigUint64(rightOffset, BigInt(value) & rightMask, le);
      },
      size: 16
    });
    var getU128Decoder = (config2 = {}) => numberDecoderFactory({
      config: config2,
      get: (view, le) => {
        const leftOffset = le ? 8 : 0;
        const rightOffset = le ? 0 : 8;
        const left = view.getBigUint64(leftOffset, le);
        const right = view.getBigUint64(rightOffset, le);
        return (left << 64n) + right;
      },
      name: "u128",
      size: 16
    });
    var getU128Codec = (config2 = {}) => codecsCore.combineCodec(getU128Encoder(config2), getU128Decoder(config2));
    var getU16Encoder = (config2 = {}) => numberEncoderFactory({
      config: config2,
      name: "u16",
      range: [0, Number("0xffff")],
      set: (view, value, le) => view.setUint16(0, Number(value), le),
      size: 2
    });
    var getU16Decoder = (config2 = {}) => numberDecoderFactory({
      config: config2,
      get: (view, le) => view.getUint16(0, le),
      name: "u16",
      size: 2
    });
    var getU16Codec = (config2 = {}) => codecsCore.combineCodec(getU16Encoder(config2), getU16Decoder(config2));
    var getU32Encoder = (config2 = {}) => numberEncoderFactory({
      config: config2,
      name: "u32",
      range: [0, Number("0xffffffff")],
      set: (view, value, le) => view.setUint32(0, Number(value), le),
      size: 4
    });
    var getU32Decoder = (config2 = {}) => numberDecoderFactory({
      config: config2,
      get: (view, le) => view.getUint32(0, le),
      name: "u32",
      size: 4
    });
    var getU32Codec = (config2 = {}) => codecsCore.combineCodec(getU32Encoder(config2), getU32Decoder(config2));
    var getU64Encoder = (config2 = {}) => numberEncoderFactory({
      config: config2,
      name: "u64",
      range: [0n, BigInt("0xffffffffffffffff")],
      set: (view, value, le) => view.setBigUint64(0, BigInt(value), le),
      size: 8
    });
    var getU64Decoder = (config2 = {}) => numberDecoderFactory({
      config: config2,
      get: (view, le) => view.getBigUint64(0, le),
      name: "u64",
      size: 8
    });
    var getU64Codec = (config2 = {}) => codecsCore.combineCodec(getU64Encoder(config2), getU64Decoder(config2));
    var getU8Encoder = () => numberEncoderFactory({
      name: "u8",
      range: [0, Number("0xff")],
      set: (view, value) => view.setUint8(0, Number(value)),
      size: 1
    });
    var getU8Decoder = () => numberDecoderFactory({
      get: (view) => view.getUint8(0),
      name: "u8",
      size: 1
    });
    var getU8Codec = () => codecsCore.combineCodec(getU8Encoder(), getU8Decoder());
    exports2.Endian = Endian;
    exports2.assertNumberIsBetweenForCodec = assertNumberIsBetweenForCodec;
    exports2.getF32Codec = getF32Codec;
    exports2.getF32Decoder = getF32Decoder;
    exports2.getF32Encoder = getF32Encoder;
    exports2.getF64Codec = getF64Codec;
    exports2.getF64Decoder = getF64Decoder;
    exports2.getF64Encoder = getF64Encoder;
    exports2.getI128Codec = getI128Codec;
    exports2.getI128Decoder = getI128Decoder;
    exports2.getI128Encoder = getI128Encoder;
    exports2.getI16Codec = getI16Codec;
    exports2.getI16Decoder = getI16Decoder;
    exports2.getI16Encoder = getI16Encoder;
    exports2.getI32Codec = getI32Codec;
    exports2.getI32Decoder = getI32Decoder;
    exports2.getI32Encoder = getI32Encoder;
    exports2.getI64Codec = getI64Codec;
    exports2.getI64Decoder = getI64Decoder;
    exports2.getI64Encoder = getI64Encoder;
    exports2.getI8Codec = getI8Codec;
    exports2.getI8Decoder = getI8Decoder;
    exports2.getI8Encoder = getI8Encoder;
    exports2.getShortU16Codec = getShortU16Codec;
    exports2.getShortU16Decoder = getShortU16Decoder;
    exports2.getShortU16Encoder = getShortU16Encoder;
    exports2.getU128Codec = getU128Codec;
    exports2.getU128Decoder = getU128Decoder;
    exports2.getU128Encoder = getU128Encoder;
    exports2.getU16Codec = getU16Codec;
    exports2.getU16Decoder = getU16Decoder;
    exports2.getU16Encoder = getU16Encoder;
    exports2.getU32Codec = getU32Codec;
    exports2.getU32Decoder = getU32Decoder;
    exports2.getU32Encoder = getU32Encoder;
    exports2.getU64Codec = getU64Codec;
    exports2.getU64Decoder = getU64Decoder;
    exports2.getU64Encoder = getU64Encoder;
    exports2.getU8Codec = getU8Codec;
    exports2.getU8Decoder = getU8Decoder;
    exports2.getU8Encoder = getU8Encoder;
  }
});

// node_modules/@solana/codecs-data-structures/dist/index.node.cjs
var require_index_node4 = __commonJS({
  "node_modules/@solana/codecs-data-structures/dist/index.node.cjs"(exports2) {
    "use strict";
    var codecsCore = require_index_node2();
    var codecsNumbers = require_index_node3();
    var errors = require_index_node();
    function assertValidNumberOfItemsForCodec(codecDescription, expected, actual) {
      if (expected !== actual) {
        throw new errors.SolanaError(errors.SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS, {
          actual,
          codecDescription,
          expected
        });
      }
    }
    function maxCodecSizes(sizes) {
      return sizes.reduce(
        (all, size) => all === null || size === null ? null : Math.max(all, size),
        0
      );
    }
    function sumCodecSizes(sizes) {
      return sizes.reduce((all, size) => all === null || size === null ? null : all + size, 0);
    }
    function getFixedSize(codec) {
      return codecsCore.isFixedSize(codec) ? codec.fixedSize : null;
    }
    function getMaxSize(codec) {
      return codecsCore.isFixedSize(codec) ? codec.fixedSize : codec.maxSize ?? null;
    }
    function getArrayEncoder(item, config2 = {}) {
      const size = config2.size ?? codecsNumbers.getU32Encoder();
      const fixedSize = computeArrayLikeCodecSize(size, getFixedSize(item));
      const maxSize = computeArrayLikeCodecSize(size, getMaxSize(item)) ?? void 0;
      return codecsCore.createEncoder({
        ...fixedSize !== null ? { fixedSize } : {
          getSizeFromValue: (array2) => {
            const prefixSize = typeof size === "object" ? codecsCore.getEncodedSize(array2.length, size) : 0;
            return prefixSize + [...array2].reduce((all, value) => all + codecsCore.getEncodedSize(value, item), 0);
          },
          maxSize
        },
        write: (array2, bytes, offset2) => {
          if (typeof size === "number") {
            assertValidNumberOfItemsForCodec("array", size, array2.length);
          }
          if (typeof size === "object") {
            offset2 = size.write(array2.length, bytes, offset2);
          }
          array2.forEach((value) => {
            offset2 = item.write(value, bytes, offset2);
          });
          return offset2;
        }
      });
    }
    function getArrayDecoder(item, config2 = {}) {
      const size = config2.size ?? codecsNumbers.getU32Decoder();
      const itemSize = getFixedSize(item);
      const fixedSize = computeArrayLikeCodecSize(size, itemSize);
      const maxSize = computeArrayLikeCodecSize(size, getMaxSize(item)) ?? void 0;
      return codecsCore.createDecoder({
        ...fixedSize !== null ? { fixedSize } : { maxSize },
        read: (bytes, offset2) => {
          const array2 = [];
          if (typeof size === "object" && bytes.slice(offset2).length === 0) {
            return [array2, offset2];
          }
          if (size === "remainder") {
            while (offset2 < bytes.length) {
              const [value, newOffset2] = item.read(bytes, offset2);
              offset2 = newOffset2;
              array2.push(value);
            }
            return [array2, offset2];
          }
          const [resolvedSize, newOffset] = typeof size === "number" ? [size, offset2] : size.read(bytes, offset2);
          offset2 = newOffset;
          for (let i = 0; i < resolvedSize; i += 1) {
            const [value, newOffset2] = item.read(bytes, offset2);
            offset2 = newOffset2;
            array2.push(value);
          }
          return [array2, offset2];
        }
      });
    }
    function getArrayCodec(item, config2 = {}) {
      return codecsCore.combineCodec(getArrayEncoder(item, config2), getArrayDecoder(item, config2));
    }
    function computeArrayLikeCodecSize(size, itemSize) {
      if (typeof size !== "number")
        return null;
      if (size === 0)
        return 0;
      return itemSize === null ? null : itemSize * size;
    }
    function getBitArrayEncoder(size, config2 = {}) {
      const parsedConfig = typeof config2 === "boolean" ? { backward: config2 } : config2;
      const backward = parsedConfig.backward ?? false;
      return codecsCore.createEncoder({
        fixedSize: size,
        write(value, bytes, offset2) {
          const bytesToAdd = [];
          for (let i = 0; i < size; i += 1) {
            let byte = 0;
            for (let j = 0; j < 8; j += 1) {
              const feature = Number(value[i * 8 + j] ?? 0);
              byte |= feature << (backward ? j : 7 - j);
            }
            if (backward) {
              bytesToAdd.unshift(byte);
            } else {
              bytesToAdd.push(byte);
            }
          }
          bytes.set(bytesToAdd, offset2);
          return size;
        }
      });
    }
    function getBitArrayDecoder(size, config2 = {}) {
      const parsedConfig = typeof config2 === "boolean" ? { backward: config2 } : config2;
      const backward = parsedConfig.backward ?? false;
      return codecsCore.createDecoder({
        fixedSize: size,
        read(bytes, offset2) {
          codecsCore.assertByteArrayHasEnoughBytesForCodec("bitArray", size, bytes, offset2);
          const booleans = [];
          let slice = bytes.slice(offset2, offset2 + size);
          slice = backward ? slice.reverse() : slice;
          slice.forEach((byte) => {
            for (let i = 0; i < 8; i += 1) {
              if (backward) {
                booleans.push(Boolean(byte & 1));
                byte >>= 1;
              } else {
                booleans.push(Boolean(byte & 128));
                byte <<= 1;
              }
            }
          });
          return [booleans, offset2 + size];
        }
      });
    }
    function getBitArrayCodec(size, config2 = {}) {
      return codecsCore.combineCodec(getBitArrayEncoder(size, config2), getBitArrayDecoder(size, config2));
    }
    function getBooleanEncoder(config2 = {}) {
      return codecsCore.transformEncoder(config2.size ?? codecsNumbers.getU8Encoder(), (value) => value ? 1 : 0);
    }
    function getBooleanDecoder(config2 = {}) {
      return codecsCore.transformDecoder(config2.size ?? codecsNumbers.getU8Decoder(), (value) => Number(value) === 1);
    }
    function getBooleanCodec(config2 = {}) {
      return codecsCore.combineCodec(getBooleanEncoder(config2), getBooleanDecoder(config2));
    }
    function getBytesEncoder() {
      return codecsCore.createEncoder({
        getSizeFromValue: (value) => value.length,
        write: (value, bytes, offset2) => {
          bytes.set(value, offset2);
          return offset2 + value.length;
        }
      });
    }
    function getBytesDecoder() {
      return codecsCore.createDecoder({
        read: (bytes, offset2) => {
          const slice = bytes.slice(offset2);
          return [slice, offset2 + slice.length];
        }
      });
    }
    function getBytesCodec() {
      return codecsCore.combineCodec(getBytesEncoder(), getBytesDecoder());
    }
    var getBase16Decoder = () => codecsCore.createDecoder({
      read(bytes, offset2) {
        const value = bytes.slice(offset2).reduce((str2, byte) => str2 + byte.toString(16).padStart(2, "0"), "");
        return [value, bytes.length];
      }
    });
    function getConstantEncoder(constant) {
      return codecsCore.createEncoder({
        fixedSize: constant.length,
        write: (_, bytes, offset2) => {
          bytes.set(constant, offset2);
          return offset2 + constant.length;
        }
      });
    }
    function getConstantDecoder(constant) {
      return codecsCore.createDecoder({
        fixedSize: constant.length,
        read: (bytes, offset2) => {
          const base16 = getBase16Decoder();
          if (!codecsCore.containsBytes(bytes, constant, offset2)) {
            throw new errors.SolanaError(errors.SOLANA_ERROR__CODECS__INVALID_CONSTANT, {
              constant,
              data: bytes,
              hexConstant: base16.decode(constant),
              hexData: base16.decode(bytes),
              offset: offset2
            });
          }
          return [void 0, offset2 + constant.length];
        }
      });
    }
    function getConstantCodec(constant) {
      return codecsCore.combineCodec(getConstantEncoder(constant), getConstantDecoder(constant));
    }
    function getTupleEncoder(items) {
      const fixedSize = sumCodecSizes(items.map(getFixedSize));
      const maxSize = sumCodecSizes(items.map(getMaxSize)) ?? void 0;
      return codecsCore.createEncoder({
        ...fixedSize === null ? {
          getSizeFromValue: (value) => items.map((item, index) => codecsCore.getEncodedSize(value[index], item)).reduce((all, one) => all + one, 0),
          maxSize
        } : { fixedSize },
        write: (value, bytes, offset2) => {
          assertValidNumberOfItemsForCodec("tuple", items.length, value.length);
          items.forEach((item, index) => {
            offset2 = item.write(value[index], bytes, offset2);
          });
          return offset2;
        }
      });
    }
    function getTupleDecoder(items) {
      const fixedSize = sumCodecSizes(items.map(getFixedSize));
      const maxSize = sumCodecSizes(items.map(getMaxSize)) ?? void 0;
      return codecsCore.createDecoder({
        ...fixedSize === null ? { maxSize } : { fixedSize },
        read: (bytes, offset2) => {
          const values = [];
          items.forEach((item) => {
            const [newValue, newOffset] = item.read(bytes, offset2);
            values.push(newValue);
            offset2 = newOffset;
          });
          return [values, offset2];
        }
      });
    }
    function getTupleCodec(items) {
      return codecsCore.combineCodec(
        getTupleEncoder(items),
        getTupleDecoder(items)
      );
    }
    function getUnionEncoder(variants, getIndexFromValue) {
      const fixedSize = getUnionFixedSize(variants);
      const write = (variant, bytes, offset2) => {
        const index = getIndexFromValue(variant);
        assertValidVariantIndex(variants, index);
        return variants[index].write(variant, bytes, offset2);
      };
      if (fixedSize !== null) {
        return codecsCore.createEncoder({ fixedSize, write });
      }
      const maxSize = getUnionMaxSize(variants);
      return codecsCore.createEncoder({
        ...maxSize !== null ? { maxSize } : {},
        getSizeFromValue: (variant) => {
          const index = getIndexFromValue(variant);
          assertValidVariantIndex(variants, index);
          return codecsCore.getEncodedSize(variant, variants[index]);
        },
        write
      });
    }
    function getUnionDecoder(variants, getIndexFromBytes) {
      const fixedSize = getUnionFixedSize(variants);
      const read = (bytes, offset2) => {
        const index = getIndexFromBytes(bytes, offset2);
        assertValidVariantIndex(variants, index);
        return variants[index].read(bytes, offset2);
      };
      if (fixedSize !== null) {
        return codecsCore.createDecoder({ fixedSize, read });
      }
      const maxSize = getUnionMaxSize(variants);
      return codecsCore.createDecoder({ ...maxSize !== null ? { maxSize } : {}, read });
    }
    function getUnionCodec(variants, getIndexFromValue, getIndexFromBytes) {
      return codecsCore.combineCodec(
        getUnionEncoder(variants, getIndexFromValue),
        getUnionDecoder(variants, getIndexFromBytes)
      );
    }
    function assertValidVariantIndex(variants, index) {
      if (typeof variants[index] === "undefined") {
        throw new errors.SolanaError(errors.SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE, {
          maxRange: variants.length - 1,
          minRange: 0,
          variant: index
        });
      }
    }
    function getUnionFixedSize(variants) {
      if (variants.length === 0)
        return 0;
      if (!codecsCore.isFixedSize(variants[0]))
        return null;
      const variantSize = variants[0].fixedSize;
      const sameSizedVariants = variants.every((variant) => codecsCore.isFixedSize(variant) && variant.fixedSize === variantSize);
      return sameSizedVariants ? variantSize : null;
    }
    function getUnionMaxSize(variants) {
      return maxCodecSizes(variants.map((variant) => getMaxSize(variant)));
    }
    function getDiscriminatedUnionEncoder(variants, config2 = {}) {
      const discriminatorProperty = config2.discriminator ?? "__kind";
      const prefix = config2.size ?? codecsNumbers.getU8Encoder();
      return getUnionEncoder(
        variants.map(
          ([, variant], index) => codecsCore.transformEncoder(getTupleEncoder([prefix, variant]), (value) => [index, value])
        ),
        (value) => getVariantDiscriminator(variants, value[discriminatorProperty])
      );
    }
    function getDiscriminatedUnionDecoder(variants, config2 = {}) {
      const discriminatorProperty = config2.discriminator ?? "__kind";
      const prefix = config2.size ?? codecsNumbers.getU8Decoder();
      return getUnionDecoder(
        variants.map(
          ([discriminator, variant]) => codecsCore.transformDecoder(getTupleDecoder([prefix, variant]), ([, value]) => ({
            [discriminatorProperty]: discriminator,
            ...value
          }))
        ),
        (bytes, offset2) => Number(prefix.read(bytes, offset2)[0])
      );
    }
    function getDiscriminatedUnionCodec(variants, config2 = {}) {
      return codecsCore.combineCodec(
        getDiscriminatedUnionEncoder(variants, config2),
        getDiscriminatedUnionDecoder(variants, config2)
      );
    }
    function getVariantDiscriminator(variants, discriminatorValue) {
      const discriminator = variants.findIndex(([key]) => discriminatorValue === key);
      if (discriminator < 0) {
        throw new errors.SolanaError(errors.SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT, {
          value: discriminatorValue,
          variants: variants.map(([key]) => key)
        });
      }
      return discriminator;
    }
    var getDataEnumEncoder = getDiscriminatedUnionEncoder;
    var getDataEnumDecoder = getDiscriminatedUnionDecoder;
    var getDataEnumCodec = getDiscriminatedUnionCodec;
    function getEnumStats(constructor) {
      const numericalValues = [
        ...new Set(Object.values(constructor).filter((v) => typeof v === "number"))
      ].sort();
      const enumRecord = Object.fromEntries(Object.entries(constructor).slice(numericalValues.length));
      const enumKeys = Object.keys(enumRecord);
      const enumValues = Object.values(enumRecord);
      const stringValues = [
        .../* @__PURE__ */ new Set([...enumKeys, ...enumValues.filter((v) => typeof v === "string")])
      ];
      return { enumKeys, enumRecord, enumValues, numericalValues, stringValues };
    }
    function getEnumIndexFromVariant({
      enumKeys,
      enumValues,
      variant
    }) {
      const valueIndex = findLastIndex(enumValues, (value) => value === variant);
      if (valueIndex >= 0)
        return valueIndex;
      return enumKeys.findIndex((key) => key === variant);
    }
    function getEnumIndexFromDiscriminator({
      discriminator,
      enumKeys,
      enumValues,
      useValuesAsDiscriminators
    }) {
      if (!useValuesAsDiscriminators) {
        return discriminator >= 0 && discriminator < enumKeys.length ? discriminator : -1;
      }
      return findLastIndex(enumValues, (value) => value === discriminator);
    }
    function findLastIndex(array2, predicate) {
      let l = array2.length;
      while (l--) {
        if (predicate(array2[l], l, array2))
          return l;
      }
      return -1;
    }
    function formatNumericalValues(values) {
      if (values.length === 0)
        return "";
      let range = [values[0], values[0]];
      const ranges = [];
      for (let index = 1; index < values.length; index++) {
        const value = values[index];
        if (range[1] + 1 === value) {
          range[1] = value;
        } else {
          ranges.push(range[0] === range[1] ? `${range[0]}` : `${range[0]}-${range[1]}`);
          range = [value, value];
        }
      }
      ranges.push(range[0] === range[1] ? `${range[0]}` : `${range[0]}-${range[1]}`);
      return ranges.join(", ");
    }
    function getEnumEncoder(constructor, config2 = {}) {
      const prefix = config2.size ?? codecsNumbers.getU8Encoder();
      const useValuesAsDiscriminators = config2.useValuesAsDiscriminators ?? false;
      const { enumKeys, enumValues, numericalValues, stringValues } = getEnumStats(constructor);
      if (useValuesAsDiscriminators && enumValues.some((value) => typeof value === "string")) {
        throw new errors.SolanaError(errors.SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS, {
          stringValues: enumValues.filter((v) => typeof v === "string")
        });
      }
      return codecsCore.transformEncoder(prefix, (variant) => {
        const index = getEnumIndexFromVariant({ enumKeys, enumValues, variant });
        if (index < 0) {
          throw new errors.SolanaError(errors.SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT, {
            formattedNumericalValues: formatNumericalValues(numericalValues),
            numericalValues,
            stringValues,
            variant
          });
        }
        return useValuesAsDiscriminators ? enumValues[index] : index;
      });
    }
    function getEnumDecoder(constructor, config2 = {}) {
      const prefix = config2.size ?? codecsNumbers.getU8Decoder();
      const useValuesAsDiscriminators = config2.useValuesAsDiscriminators ?? false;
      const { enumKeys, enumValues, numericalValues } = getEnumStats(constructor);
      if (useValuesAsDiscriminators && enumValues.some((value) => typeof value === "string")) {
        throw new errors.SolanaError(errors.SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS, {
          stringValues: enumValues.filter((v) => typeof v === "string")
        });
      }
      return codecsCore.transformDecoder(prefix, (value) => {
        const discriminator = Number(value);
        const index = getEnumIndexFromDiscriminator({
          discriminator,
          enumKeys,
          enumValues,
          useValuesAsDiscriminators
        });
        if (index < 0) {
          const validDiscriminators = useValuesAsDiscriminators ? numericalValues : [...Array(enumKeys.length).keys()];
          throw new errors.SolanaError(errors.SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE, {
            discriminator,
            formattedValidDiscriminators: formatNumericalValues(validDiscriminators),
            validDiscriminators
          });
        }
        return enumValues[index];
      });
    }
    function getEnumCodec(constructor, config2 = {}) {
      return codecsCore.combineCodec(getEnumEncoder(constructor, config2), getEnumDecoder(constructor, config2));
    }
    var getScalarEnumEncoder = getEnumEncoder;
    var getScalarEnumDecoder = getEnumDecoder;
    var getScalarEnumCodec = getEnumCodec;
    function getHiddenPrefixEncoder(encoder, prefixedEncoders) {
      return codecsCore.transformEncoder(
        getTupleEncoder([...prefixedEncoders, encoder]),
        (value) => [...prefixedEncoders.map(() => void 0), value]
      );
    }
    function getHiddenPrefixDecoder(decoder, prefixedDecoders) {
      return codecsCore.transformDecoder(
        getTupleDecoder([...prefixedDecoders, decoder]),
        (tuple) => tuple[tuple.length - 1]
      );
    }
    function getHiddenPrefixCodec(codec, prefixedCodecs) {
      return codecsCore.combineCodec(getHiddenPrefixEncoder(codec, prefixedCodecs), getHiddenPrefixDecoder(codec, prefixedCodecs));
    }
    function getHiddenSuffixEncoder(encoder, suffixedEncoders) {
      return codecsCore.transformEncoder(
        getTupleEncoder([encoder, ...suffixedEncoders]),
        (value) => [value, ...suffixedEncoders.map(() => void 0)]
      );
    }
    function getHiddenSuffixDecoder(decoder, suffixedDecoders) {
      return codecsCore.transformDecoder(
        getTupleDecoder([decoder, ...suffixedDecoders]),
        (tuple) => tuple[0]
      );
    }
    function getHiddenSuffixCodec(codec, suffixedCodecs) {
      return codecsCore.combineCodec(getHiddenSuffixEncoder(codec, suffixedCodecs), getHiddenSuffixDecoder(codec, suffixedCodecs));
    }
    function getMapEncoder(key, value, config2 = {}) {
      return codecsCore.transformEncoder(
        getArrayEncoder(getTupleEncoder([key, value]), config2),
        (map) => [...map.entries()]
      );
    }
    function getMapDecoder(key, value, config2 = {}) {
      return codecsCore.transformDecoder(
        getArrayDecoder(getTupleDecoder([key, value]), config2),
        (entries) => new Map(entries)
      );
    }
    function getMapCodec(key, value, config2 = {}) {
      return codecsCore.combineCodec(getMapEncoder(key, value, config2), getMapDecoder(key, value, config2));
    }
    function getUnitEncoder() {
      return codecsCore.createEncoder({
        fixedSize: 0,
        write: (_value, _bytes, offset2) => offset2
      });
    }
    function getUnitDecoder() {
      return codecsCore.createDecoder({
        fixedSize: 0,
        read: (_bytes, offset2) => [void 0, offset2]
      });
    }
    function getUnitCodec() {
      return codecsCore.combineCodec(getUnitEncoder(), getUnitDecoder());
    }
    function getNullableEncoder(item, config2 = {}) {
      const prefix = (() => {
        if (config2.prefix === null) {
          return codecsCore.transformEncoder(getUnitEncoder(), (_boolean) => void 0);
        }
        return getBooleanEncoder({ size: config2.prefix ?? codecsNumbers.getU8Encoder() });
      })();
      const noneValue = (() => {
        if (config2.noneValue === "zeroes") {
          codecsCore.assertIsFixedSize(item);
          return codecsCore.fixEncoderSize(getUnitEncoder(), item.fixedSize);
        }
        if (!config2.noneValue) {
          return getUnitEncoder();
        }
        return getConstantEncoder(config2.noneValue);
      })();
      return getUnionEncoder(
        [
          codecsCore.transformEncoder(getTupleEncoder([prefix, noneValue]), (_value) => [
            false,
            void 0
          ]),
          codecsCore.transformEncoder(getTupleEncoder([prefix, item]), (value) => [true, value])
        ],
        (variant) => Number(variant !== null)
      );
    }
    function getNullableDecoder(item, config2 = {}) {
      const prefix = (() => {
        if (config2.prefix === null) {
          return codecsCore.transformDecoder(getUnitDecoder(), () => false);
        }
        return getBooleanDecoder({ size: config2.prefix ?? codecsNumbers.getU8Decoder() });
      })();
      const noneValue = (() => {
        if (config2.noneValue === "zeroes") {
          codecsCore.assertIsFixedSize(item);
          return codecsCore.fixDecoderSize(getUnitDecoder(), item.fixedSize);
        }
        if (!config2.noneValue) {
          return getUnitDecoder();
        }
        return getConstantDecoder(config2.noneValue);
      })();
      return getUnionDecoder(
        [
          codecsCore.transformDecoder(getTupleDecoder([prefix, noneValue]), () => null),
          codecsCore.transformDecoder(getTupleDecoder([prefix, item]), ([, value]) => value)
        ],
        (bytes, offset2) => {
          if (config2.prefix === null && !config2.noneValue) {
            return Number(offset2 < bytes.length);
          }
          if (config2.prefix === null && config2.noneValue != null) {
            const zeroValue = config2.noneValue === "zeroes" ? new Uint8Array(noneValue.fixedSize).fill(0) : config2.noneValue;
            return codecsCore.containsBytes(bytes, zeroValue, offset2) ? 0 : 1;
          }
          return Number(prefix.read(bytes, offset2)[0]);
        }
      );
    }
    function getNullableCodec(item, config2 = {}) {
      return codecsCore.combineCodec(
        getNullableEncoder(item, config2),
        getNullableDecoder(item, config2)
      );
    }
    function getSetEncoder(item, config2 = {}) {
      return codecsCore.transformEncoder(getArrayEncoder(item, config2), (set) => [...set]);
    }
    function getSetDecoder(item, config2 = {}) {
      return codecsCore.transformDecoder(getArrayDecoder(item, config2), (entries) => new Set(entries));
    }
    function getSetCodec(item, config2 = {}) {
      return codecsCore.combineCodec(getSetEncoder(item, config2), getSetDecoder(item, config2));
    }
    function getStructEncoder(fields) {
      const fieldCodecs = fields.map(([, codec]) => codec);
      const fixedSize = sumCodecSizes(fieldCodecs.map(getFixedSize));
      const maxSize = sumCodecSizes(fieldCodecs.map(getMaxSize)) ?? void 0;
      return codecsCore.createEncoder({
        ...fixedSize === null ? {
          getSizeFromValue: (value) => fields.map(([key, codec]) => codecsCore.getEncodedSize(value[key], codec)).reduce((all, one) => all + one, 0),
          maxSize
        } : { fixedSize },
        write: (struct3, bytes, offset2) => {
          fields.forEach(([key, codec]) => {
            offset2 = codec.write(struct3[key], bytes, offset2);
          });
          return offset2;
        }
      });
    }
    function getStructDecoder(fields) {
      const fieldCodecs = fields.map(([, codec]) => codec);
      const fixedSize = sumCodecSizes(fieldCodecs.map(getFixedSize));
      const maxSize = sumCodecSizes(fieldCodecs.map(getMaxSize)) ?? void 0;
      return codecsCore.createDecoder({
        ...fixedSize === null ? { maxSize } : { fixedSize },
        read: (bytes, offset2) => {
          const struct3 = {};
          fields.forEach(([key, codec]) => {
            const [value, newOffset] = codec.read(bytes, offset2);
            offset2 = newOffset;
            struct3[key] = value;
          });
          return [struct3, offset2];
        }
      });
    }
    function getStructCodec(fields) {
      return codecsCore.combineCodec(
        getStructEncoder(fields),
        getStructDecoder(fields)
      );
    }
    exports2.assertValidNumberOfItemsForCodec = assertValidNumberOfItemsForCodec;
    exports2.getArrayCodec = getArrayCodec;
    exports2.getArrayDecoder = getArrayDecoder;
    exports2.getArrayEncoder = getArrayEncoder;
    exports2.getBitArrayCodec = getBitArrayCodec;
    exports2.getBitArrayDecoder = getBitArrayDecoder;
    exports2.getBitArrayEncoder = getBitArrayEncoder;
    exports2.getBooleanCodec = getBooleanCodec;
    exports2.getBooleanDecoder = getBooleanDecoder;
    exports2.getBooleanEncoder = getBooleanEncoder;
    exports2.getBytesCodec = getBytesCodec;
    exports2.getBytesDecoder = getBytesDecoder;
    exports2.getBytesEncoder = getBytesEncoder;
    exports2.getConstantCodec = getConstantCodec;
    exports2.getConstantDecoder = getConstantDecoder;
    exports2.getConstantEncoder = getConstantEncoder;
    exports2.getDataEnumCodec = getDataEnumCodec;
    exports2.getDataEnumDecoder = getDataEnumDecoder;
    exports2.getDataEnumEncoder = getDataEnumEncoder;
    exports2.getDiscriminatedUnionCodec = getDiscriminatedUnionCodec;
    exports2.getDiscriminatedUnionDecoder = getDiscriminatedUnionDecoder;
    exports2.getDiscriminatedUnionEncoder = getDiscriminatedUnionEncoder;
    exports2.getEnumCodec = getEnumCodec;
    exports2.getEnumDecoder = getEnumDecoder;
    exports2.getEnumEncoder = getEnumEncoder;
    exports2.getHiddenPrefixCodec = getHiddenPrefixCodec;
    exports2.getHiddenPrefixDecoder = getHiddenPrefixDecoder;
    exports2.getHiddenPrefixEncoder = getHiddenPrefixEncoder;
    exports2.getHiddenSuffixCodec = getHiddenSuffixCodec;
    exports2.getHiddenSuffixDecoder = getHiddenSuffixDecoder;
    exports2.getHiddenSuffixEncoder = getHiddenSuffixEncoder;
    exports2.getMapCodec = getMapCodec;
    exports2.getMapDecoder = getMapDecoder;
    exports2.getMapEncoder = getMapEncoder;
    exports2.getNullableCodec = getNullableCodec;
    exports2.getNullableDecoder = getNullableDecoder;
    exports2.getNullableEncoder = getNullableEncoder;
    exports2.getScalarEnumCodec = getScalarEnumCodec;
    exports2.getScalarEnumDecoder = getScalarEnumDecoder;
    exports2.getScalarEnumEncoder = getScalarEnumEncoder;
    exports2.getSetCodec = getSetCodec;
    exports2.getSetDecoder = getSetDecoder;
    exports2.getSetEncoder = getSetEncoder;
    exports2.getStructCodec = getStructCodec;
    exports2.getStructDecoder = getStructDecoder;
    exports2.getStructEncoder = getStructEncoder;
    exports2.getTupleCodec = getTupleCodec;
    exports2.getTupleDecoder = getTupleDecoder;
    exports2.getTupleEncoder = getTupleEncoder;
    exports2.getUnionCodec = getUnionCodec;
    exports2.getUnionDecoder = getUnionDecoder;
    exports2.getUnionEncoder = getUnionEncoder;
    exports2.getUnitCodec = getUnitCodec;
    exports2.getUnitDecoder = getUnitDecoder;
    exports2.getUnitEncoder = getUnitEncoder;
  }
});

// node_modules/@solana/codecs-strings/dist/index.node.cjs
var require_index_node5 = __commonJS({
  "node_modules/@solana/codecs-strings/dist/index.node.cjs"(exports2) {
    "use strict";
    var errors = require_index_node();
    var codecsCore = require_index_node2();
    function assertValidBaseString(alphabet4, testValue, givenValue = testValue) {
      if (!testValue.match(new RegExp(`^[${alphabet4}]*$`))) {
        throw new errors.SolanaError(errors.SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {
          alphabet: alphabet4,
          base: alphabet4.length,
          value: givenValue
        });
      }
    }
    var getBaseXEncoder = (alphabet4) => {
      return codecsCore.createEncoder({
        getSizeFromValue: (value) => {
          const [leadingZeroes, tailChars] = partitionLeadingZeroes(value, alphabet4[0]);
          if (!tailChars)
            return value.length;
          const base10Number = getBigIntFromBaseX(tailChars, alphabet4);
          return leadingZeroes.length + Math.ceil(base10Number.toString(16).length / 2);
        },
        write(value, bytes, offset2) {
          assertValidBaseString(alphabet4, value);
          if (value === "")
            return offset2;
          const [leadingZeroes, tailChars] = partitionLeadingZeroes(value, alphabet4[0]);
          if (!tailChars) {
            bytes.set(new Uint8Array(leadingZeroes.length).fill(0), offset2);
            return offset2 + leadingZeroes.length;
          }
          let base10Number = getBigIntFromBaseX(tailChars, alphabet4);
          const tailBytes = [];
          while (base10Number > 0n) {
            tailBytes.unshift(Number(base10Number % 256n));
            base10Number /= 256n;
          }
          const bytesToAdd = [...Array(leadingZeroes.length).fill(0), ...tailBytes];
          bytes.set(bytesToAdd, offset2);
          return offset2 + bytesToAdd.length;
        }
      });
    };
    var getBaseXDecoder = (alphabet4) => {
      return codecsCore.createDecoder({
        read(rawBytes, offset2) {
          const bytes = offset2 === 0 ? rawBytes : rawBytes.slice(offset2);
          if (bytes.length === 0)
            return ["", 0];
          let trailIndex = bytes.findIndex((n) => n !== 0);
          trailIndex = trailIndex === -1 ? bytes.length : trailIndex;
          const leadingZeroes = alphabet4[0].repeat(trailIndex);
          if (trailIndex === bytes.length)
            return [leadingZeroes, rawBytes.length];
          const base10Number = bytes.slice(trailIndex).reduce((sum2, byte) => sum2 * 256n + BigInt(byte), 0n);
          const tailChars = getBaseXFromBigInt(base10Number, alphabet4);
          return [leadingZeroes + tailChars, rawBytes.length];
        }
      });
    };
    var getBaseXCodec = (alphabet4) => codecsCore.combineCodec(getBaseXEncoder(alphabet4), getBaseXDecoder(alphabet4));
    function partitionLeadingZeroes(value, zeroCharacter) {
      const [leadingZeros2, tailChars] = value.split(new RegExp(`((?!${zeroCharacter}).*)`));
      return [leadingZeros2, tailChars];
    }
    function getBigIntFromBaseX(value, alphabet4) {
      const base = BigInt(alphabet4.length);
      let sum2 = 0n;
      for (const char of value) {
        sum2 *= base;
        sum2 += BigInt(alphabet4.indexOf(char));
      }
      return sum2;
    }
    function getBaseXFromBigInt(value, alphabet4) {
      const base = BigInt(alphabet4.length);
      const tailChars = [];
      while (value > 0n) {
        tailChars.unshift(alphabet4[Number(value % base)]);
        value /= base;
      }
      return tailChars.join("");
    }
    var alphabet = "0123456789";
    var getBase10Encoder = () => getBaseXEncoder(alphabet);
    var getBase10Decoder = () => getBaseXDecoder(alphabet);
    var getBase10Codec = () => getBaseXCodec(alphabet);
    var INVALID_STRING_ERROR_BASE_CONFIG = {
      alphabet: "0123456789abcdef",
      base: 16
    };
    function charCodeToBase16(char) {
      if (char >= 48 && char <= 57)
        return char - 48;
      if (char >= 65 && char <= 70)
        return char - (65 - 10);
      if (char >= 97 && char <= 102)
        return char - (97 - 10);
    }
    var getBase16Encoder = () => codecsCore.createEncoder({
      getSizeFromValue: (value) => Math.ceil(value.length / 2),
      write(value, bytes, offset2) {
        const len = value.length;
        const al = len / 2;
        if (len === 1) {
          const c = value.charCodeAt(0);
          const n = charCodeToBase16(c);
          if (n === void 0) {
            throw new errors.SolanaError(errors.SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {
              ...INVALID_STRING_ERROR_BASE_CONFIG,
              value
            });
          }
          bytes.set([n], offset2);
          return 1 + offset2;
        }
        const hexBytes = new Uint8Array(al);
        for (let i = 0, j = 0; i < al; i++) {
          const c1 = value.charCodeAt(j++);
          const c2 = value.charCodeAt(j++);
          const n1 = charCodeToBase16(c1);
          const n2 = charCodeToBase16(c2);
          if (n1 === void 0 || n2 === void 0 && !Number.isNaN(c2)) {
            throw new errors.SolanaError(errors.SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {
              ...INVALID_STRING_ERROR_BASE_CONFIG,
              value
            });
          }
          hexBytes[i] = !Number.isNaN(c2) ? n1 << 4 | (n2 ?? 0) : n1;
        }
        bytes.set(hexBytes, offset2);
        return hexBytes.length + offset2;
      }
    });
    var getBase16Decoder = () => codecsCore.createDecoder({
      read(bytes, offset2) {
        const value = bytes.slice(offset2).reduce((str2, byte) => str2 + byte.toString(16).padStart(2, "0"), "");
        return [value, bytes.length];
      }
    });
    var getBase16Codec = () => codecsCore.combineCodec(getBase16Encoder(), getBase16Decoder());
    var alphabet2 = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
    var getBase58Encoder = () => getBaseXEncoder(alphabet2);
    var getBase58Decoder = () => getBaseXDecoder(alphabet2);
    var getBase58Codec = () => getBaseXCodec(alphabet2);
    var getBaseXResliceEncoder = (alphabet4, bits2) => codecsCore.createEncoder({
      getSizeFromValue: (value) => Math.floor(value.length * bits2 / 8),
      write(value, bytes, offset2) {
        assertValidBaseString(alphabet4, value);
        if (value === "")
          return offset2;
        const charIndices = [...value].map((c) => alphabet4.indexOf(c));
        const reslicedBytes = reslice(charIndices, bits2, 8, false);
        bytes.set(reslicedBytes, offset2);
        return reslicedBytes.length + offset2;
      }
    });
    var getBaseXResliceDecoder = (alphabet4, bits2) => codecsCore.createDecoder({
      read(rawBytes, offset2 = 0) {
        const bytes = offset2 === 0 ? rawBytes : rawBytes.slice(offset2);
        if (bytes.length === 0)
          return ["", rawBytes.length];
        const charIndices = reslice([...bytes], 8, bits2, true);
        return [charIndices.map((i) => alphabet4[i]).join(""), rawBytes.length];
      }
    });
    var getBaseXResliceCodec = (alphabet4, bits2) => codecsCore.combineCodec(getBaseXResliceEncoder(alphabet4, bits2), getBaseXResliceDecoder(alphabet4, bits2));
    function reslice(input, inputBits, outputBits, useRemainder) {
      const output = [];
      let accumulator = 0;
      let bitsInAccumulator = 0;
      const mask = (1 << outputBits) - 1;
      for (const value of input) {
        accumulator = accumulator << inputBits | value;
        bitsInAccumulator += inputBits;
        while (bitsInAccumulator >= outputBits) {
          bitsInAccumulator -= outputBits;
          output.push(accumulator >> bitsInAccumulator & mask);
        }
      }
      if (useRemainder && bitsInAccumulator > 0) {
        output.push(accumulator << outputBits - bitsInAccumulator & mask);
      }
      return output;
    }
    var alphabet3 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    var getBase64Encoder = () => {
      {
        return codecsCore.createEncoder({
          getSizeFromValue: (value) => Buffer.from(value, "base64").length,
          write(value, bytes, offset2) {
            assertValidBaseString(alphabet3, value.replace(/=/g, ""));
            const buffer = Buffer.from(value, "base64");
            bytes.set(buffer, offset2);
            return buffer.length + offset2;
          }
        });
      }
    };
    var getBase64Decoder = () => {
      {
        return codecsCore.createDecoder({
          read: (bytes, offset2 = 0) => [Buffer.from(bytes, offset2).toString("base64"), bytes.length]
        });
      }
    };
    var getBase64Codec = () => codecsCore.combineCodec(getBase64Encoder(), getBase64Decoder());
    var removeNullCharacters = (value) => (
      // eslint-disable-next-line no-control-regex
      value.replace(/\u0000/g, "")
    );
    var padNullCharacters = (value, chars) => value.padEnd(chars, "\0");
    var e = globalThis.TextDecoder;
    var o = globalThis.TextEncoder;
    var getUtf8Encoder = () => {
      let textEncoder;
      return codecsCore.createEncoder({
        getSizeFromValue: (value) => (textEncoder ||= new o()).encode(value).length,
        write: (value, bytes, offset2) => {
          const bytesToAdd = (textEncoder ||= new o()).encode(value);
          bytes.set(bytesToAdd, offset2);
          return offset2 + bytesToAdd.length;
        }
      });
    };
    var getUtf8Decoder = () => {
      let textDecoder;
      return codecsCore.createDecoder({
        read(bytes, offset2) {
          const value = (textDecoder ||= new e()).decode(bytes.slice(offset2));
          return [removeNullCharacters(value), bytes.length];
        }
      });
    };
    var getUtf8Codec = () => codecsCore.combineCodec(getUtf8Encoder(), getUtf8Decoder());
    exports2.assertValidBaseString = assertValidBaseString;
    exports2.getBase10Codec = getBase10Codec;
    exports2.getBase10Decoder = getBase10Decoder;
    exports2.getBase10Encoder = getBase10Encoder;
    exports2.getBase16Codec = getBase16Codec;
    exports2.getBase16Decoder = getBase16Decoder;
    exports2.getBase16Encoder = getBase16Encoder;
    exports2.getBase58Codec = getBase58Codec;
    exports2.getBase58Decoder = getBase58Decoder;
    exports2.getBase58Encoder = getBase58Encoder;
    exports2.getBase64Codec = getBase64Codec;
    exports2.getBase64Decoder = getBase64Decoder;
    exports2.getBase64Encoder = getBase64Encoder;
    exports2.getBaseXCodec = getBaseXCodec;
    exports2.getBaseXDecoder = getBaseXDecoder;
    exports2.getBaseXEncoder = getBaseXEncoder;
    exports2.getBaseXResliceCodec = getBaseXResliceCodec;
    exports2.getBaseXResliceDecoder = getBaseXResliceDecoder;
    exports2.getBaseXResliceEncoder = getBaseXResliceEncoder;
    exports2.getUtf8Codec = getUtf8Codec;
    exports2.getUtf8Decoder = getUtf8Decoder;
    exports2.getUtf8Encoder = getUtf8Encoder;
    exports2.padNullCharacters = padNullCharacters;
    exports2.removeNullCharacters = removeNullCharacters;
  }
});

// node_modules/@solana/options/dist/index.node.cjs
var require_index_node6 = __commonJS({
  "node_modules/@solana/options/dist/index.node.cjs"(exports2) {
    "use strict";
    var codecsCore = require_index_node2();
    var codecsDataStructures = require_index_node4();
    var codecsNumbers = require_index_node3();
    var some = (value) => ({ __option: "Some", value });
    var none = () => ({ __option: "None" });
    var isOption = (input) => !!(input && typeof input === "object" && "__option" in input && (input.__option === "Some" && "value" in input || input.__option === "None"));
    var isSome = (option2) => option2.__option === "Some";
    var isNone = (option2) => option2.__option === "None";
    function unwrapOption(option2, fallback) {
      if (isSome(option2))
        return option2.value;
      return fallback ? fallback() : null;
    }
    var wrapNullable = (nullable) => nullable !== null ? some(nullable) : none();
    function getOptionEncoder(item, config2 = {}) {
      const prefix = (() => {
        if (config2.prefix === null) {
          return codecsCore.transformEncoder(codecsDataStructures.getUnitEncoder(), (_boolean) => void 0);
        }
        return codecsDataStructures.getBooleanEncoder({ size: config2.prefix ?? codecsNumbers.getU8Encoder() });
      })();
      const noneValue = (() => {
        if (config2.noneValue === "zeroes") {
          codecsCore.assertIsFixedSize(item);
          return codecsCore.fixEncoderSize(codecsDataStructures.getUnitEncoder(), item.fixedSize);
        }
        if (!config2.noneValue) {
          return codecsDataStructures.getUnitEncoder();
        }
        return codecsDataStructures.getConstantEncoder(config2.noneValue);
      })();
      return codecsDataStructures.getUnionEncoder(
        [
          codecsCore.transformEncoder(codecsDataStructures.getTupleEncoder([prefix, noneValue]), (_value) => [
            false,
            void 0
          ]),
          codecsCore.transformEncoder(codecsDataStructures.getTupleEncoder([prefix, item]), (value) => [
            true,
            isOption(value) && isSome(value) ? value.value : value
          ])
        ],
        (variant) => {
          const option2 = isOption(variant) ? variant : wrapNullable(variant);
          return Number(isSome(option2));
        }
      );
    }
    function getOptionDecoder(item, config2 = {}) {
      const prefix = (() => {
        if (config2.prefix === null) {
          return codecsCore.transformDecoder(codecsDataStructures.getUnitDecoder(), () => false);
        }
        return codecsDataStructures.getBooleanDecoder({ size: config2.prefix ?? codecsNumbers.getU8Decoder() });
      })();
      const noneValue = (() => {
        if (config2.noneValue === "zeroes") {
          codecsCore.assertIsFixedSize(item);
          return codecsCore.fixDecoderSize(codecsDataStructures.getUnitDecoder(), item.fixedSize);
        }
        if (!config2.noneValue) {
          return codecsDataStructures.getUnitDecoder();
        }
        return codecsDataStructures.getConstantDecoder(config2.noneValue);
      })();
      return codecsDataStructures.getUnionDecoder(
        [
          codecsCore.transformDecoder(codecsDataStructures.getTupleDecoder([prefix, noneValue]), () => none()),
          codecsCore.transformDecoder(codecsDataStructures.getTupleDecoder([prefix, item]), ([, value]) => some(value))
        ],
        (bytes, offset2) => {
          if (config2.prefix === null && !config2.noneValue) {
            return Number(offset2 < bytes.length);
          }
          if (config2.prefix === null && config2.noneValue != null) {
            const zeroValue = config2.noneValue === "zeroes" ? new Uint8Array(noneValue.fixedSize).fill(0) : config2.noneValue;
            return codecsCore.containsBytes(bytes, zeroValue, offset2) ? 0 : 1;
          }
          return Number(prefix.read(bytes, offset2)[0]);
        }
      );
    }
    function getOptionCodec(item, config2 = {}) {
      return codecsCore.combineCodec(
        getOptionEncoder(item, config2),
        getOptionDecoder(item, config2)
      );
    }
    function unwrapOptionRecursively(input, fallback) {
      if (!input || ArrayBuffer.isView(input)) {
        return input;
      }
      const next = (x) => fallback ? unwrapOptionRecursively(x, fallback) : unwrapOptionRecursively(x);
      if (isOption(input)) {
        if (isSome(input))
          return next(input.value);
        return fallback ? fallback() : null;
      }
      if (Array.isArray(input)) {
        return input.map(next);
      }
      if (typeof input === "object") {
        return Object.fromEntries(Object.entries(input).map(([k, v]) => [k, next(v)]));
      }
      return input;
    }
    exports2.getOptionCodec = getOptionCodec;
    exports2.getOptionDecoder = getOptionDecoder;
    exports2.getOptionEncoder = getOptionEncoder;
    exports2.isNone = isNone;
    exports2.isOption = isOption;
    exports2.isSome = isSome;
    exports2.none = none;
    exports2.some = some;
    exports2.unwrapOption = unwrapOption;
    exports2.unwrapOptionRecursively = unwrapOptionRecursively;
    exports2.wrapNullable = wrapNullable;
  }
});

// node_modules/@solana/codecs/dist/index.node.cjs
var require_index_node7 = __commonJS({
  "node_modules/@solana/codecs/dist/index.node.cjs"(exports2) {
    "use strict";
    var codecsCore = require_index_node2();
    var codecsDataStructures = require_index_node4();
    var codecsNumbers = require_index_node3();
    var codecsStrings = require_index_node5();
    var options = require_index_node6();
    Object.keys(codecsCore).forEach(function(k) {
      if (k !== "default" && !Object.prototype.hasOwnProperty.call(exports2, k))
        Object.defineProperty(exports2, k, {
          enumerable: true,
          get: function() {
            return codecsCore[k];
          }
        });
    });
    Object.keys(codecsDataStructures).forEach(function(k) {
      if (k !== "default" && !Object.prototype.hasOwnProperty.call(exports2, k))
        Object.defineProperty(exports2, k, {
          enumerable: true,
          get: function() {
            return codecsDataStructures[k];
          }
        });
    });
    Object.keys(codecsNumbers).forEach(function(k) {
      if (k !== "default" && !Object.prototype.hasOwnProperty.call(exports2, k))
        Object.defineProperty(exports2, k, {
          enumerable: true,
          get: function() {
            return codecsNumbers[k];
          }
        });
    });
    Object.keys(codecsStrings).forEach(function(k) {
      if (k !== "default" && !Object.prototype.hasOwnProperty.call(exports2, k))
        Object.defineProperty(exports2, k, {
          enumerable: true,
          get: function() {
            return codecsStrings[k];
          }
        });
    });
    Object.keys(options).forEach(function(k) {
      if (k !== "default" && !Object.prototype.hasOwnProperty.call(exports2, k))
        Object.defineProperty(exports2, k, {
          enumerable: true,
          get: function() {
            return options[k];
          }
        });
    });
  }
});

// node_modules/@solana/spl-token-group/lib/cjs/instruction.js
var require_instruction = __commonJS({
  "node_modules/@solana/spl-token-group/lib/cjs/instruction.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createInitializeGroupInstruction = createInitializeGroupInstruction;
    exports2.createUpdateGroupMaxSizeInstruction = createUpdateGroupMaxSizeInstruction;
    exports2.createUpdateGroupAuthorityInstruction = createUpdateGroupAuthorityInstruction;
    exports2.createInitializeMemberInstruction = createInitializeMemberInstruction;
    var codecs_1 = require_index_node7();
    var web3_js_1 = require("@solana/web3.js");
    function getInstructionEncoder(discriminator, dataEncoder) {
      return (0, codecs_1.transformEncoder)((0, codecs_1.getTupleEncoder)([(0, codecs_1.getBytesEncoder)(), dataEncoder]), (data) => [
        discriminator,
        data
      ]);
    }
    function getPublicKeyEncoder() {
      return (0, codecs_1.transformEncoder)((0, codecs_1.fixEncoderSize)((0, codecs_1.getBytesEncoder)(), 32), (publicKey3) => publicKey3.toBytes());
    }
    function createInitializeGroupInstruction(args) {
      const { programId, group, mint, mintAuthority, updateAuthority, maxSize } = args;
      return new web3_js_1.TransactionInstruction({
        programId,
        keys: [
          { isSigner: false, isWritable: true, pubkey: group },
          { isSigner: false, isWritable: false, pubkey: mint },
          { isSigner: true, isWritable: false, pubkey: mintAuthority }
        ],
        data: Buffer.from(getInstructionEncoder(new Uint8Array([
          /* await splDiscriminate('spl_token_group_interface:initialize_token_group') */
          121,
          113,
          108,
          39,
          54,
          51,
          0,
          4
        ]), (0, codecs_1.getStructEncoder)([
          ["updateAuthority", getPublicKeyEncoder()],
          ["maxSize", (0, codecs_1.getU64Encoder)()]
        ])).encode({ updateAuthority: updateAuthority !== null && updateAuthority !== void 0 ? updateAuthority : web3_js_1.SystemProgram.programId, maxSize }))
      });
    }
    function createUpdateGroupMaxSizeInstruction(args) {
      const { programId, group, updateAuthority, maxSize } = args;
      return new web3_js_1.TransactionInstruction({
        programId,
        keys: [
          { isSigner: false, isWritable: true, pubkey: group },
          { isSigner: true, isWritable: false, pubkey: updateAuthority }
        ],
        data: Buffer.from(getInstructionEncoder(new Uint8Array([
          /* await splDiscriminate('spl_token_group_interface:update_group_max_size') */
          108,
          37,
          171,
          143,
          248,
          30,
          18,
          110
        ]), (0, codecs_1.getStructEncoder)([["maxSize", (0, codecs_1.getU64Encoder)()]])).encode({ maxSize }))
      });
    }
    function createUpdateGroupAuthorityInstruction(args) {
      const { programId, group, currentAuthority, newAuthority } = args;
      return new web3_js_1.TransactionInstruction({
        programId,
        keys: [
          { isSigner: false, isWritable: true, pubkey: group },
          { isSigner: true, isWritable: false, pubkey: currentAuthority }
        ],
        data: Buffer.from(getInstructionEncoder(new Uint8Array([
          /* await splDiscriminate('spl_token_group_interface:update_authority') */
          161,
          105,
          88,
          1,
          237,
          221,
          216,
          203
        ]), (0, codecs_1.getStructEncoder)([["newAuthority", getPublicKeyEncoder()]])).encode({ newAuthority: newAuthority !== null && newAuthority !== void 0 ? newAuthority : web3_js_1.SystemProgram.programId }))
      });
    }
    function createInitializeMemberInstruction(args) {
      const { programId, member, memberMint, memberMintAuthority, group, groupUpdateAuthority } = args;
      return new web3_js_1.TransactionInstruction({
        programId,
        keys: [
          { isSigner: false, isWritable: true, pubkey: member },
          { isSigner: false, isWritable: false, pubkey: memberMint },
          { isSigner: true, isWritable: false, pubkey: memberMintAuthority },
          { isSigner: false, isWritable: true, pubkey: group },
          { isSigner: true, isWritable: false, pubkey: groupUpdateAuthority }
        ],
        data: Buffer.from(getInstructionEncoder(new Uint8Array([
          /* await splDiscriminate('spl_token_group_interface:initialize_member') */
          152,
          32,
          222,
          176,
          223,
          237,
          116,
          134
        ]), (0, codecs_1.getStructEncoder)([])).encode({}))
      });
    }
  }
});

// node_modules/@solana/spl-token-group/lib/cjs/state/tokenGroup.js
var require_tokenGroup = __commonJS({
  "node_modules/@solana/spl-token-group/lib/cjs/state/tokenGroup.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TOKEN_GROUP_SIZE = void 0;
    exports2.packTokenGroup = packTokenGroup;
    exports2.unpackTokenGroup = unpackTokenGroup;
    var web3_js_1 = require("@solana/web3.js");
    var codecs_1 = require_index_node7();
    var tokenGroupCodec = (0, codecs_1.getStructCodec)([
      ["updateAuthority", (0, codecs_1.fixCodecSize)((0, codecs_1.getBytesCodec)(), 32)],
      ["mint", (0, codecs_1.fixCodecSize)((0, codecs_1.getBytesCodec)(), 32)],
      ["size", (0, codecs_1.getU64Codec)()],
      ["maxSize", (0, codecs_1.getU64Codec)()]
    ]);
    exports2.TOKEN_GROUP_SIZE = tokenGroupCodec.fixedSize;
    function isNonePubkey(buffer) {
      for (let i = 0; i < buffer.length; i++) {
        if (buffer[i] !== 0) {
          return false;
        }
      }
      return true;
    }
    function packTokenGroup(group) {
      var _a;
      const updateAuthority = (_a = group.updateAuthority) !== null && _a !== void 0 ? _a : web3_js_1.PublicKey.default;
      return tokenGroupCodec.encode({
        updateAuthority: updateAuthority.toBuffer(),
        mint: group.mint.toBuffer(),
        size: group.size,
        maxSize: group.maxSize
      });
    }
    function unpackTokenGroup(buffer) {
      const data = tokenGroupCodec.decode(buffer);
      return isNonePubkey(data.updateAuthority) ? {
        mint: new web3_js_1.PublicKey(data.mint),
        size: data.size,
        maxSize: data.maxSize
      } : {
        updateAuthority: new web3_js_1.PublicKey(data.updateAuthority),
        mint: new web3_js_1.PublicKey(data.mint),
        size: data.size,
        maxSize: data.maxSize
      };
    }
  }
});

// node_modules/@solana/spl-token-group/lib/cjs/state/tokenGroupMember.js
var require_tokenGroupMember = __commonJS({
  "node_modules/@solana/spl-token-group/lib/cjs/state/tokenGroupMember.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TOKEN_GROUP_MEMBER_SIZE = void 0;
    exports2.packTokenGroupMember = packTokenGroupMember;
    exports2.unpackTokenGroupMember = unpackTokenGroupMember;
    var web3_js_1 = require("@solana/web3.js");
    var codecs_1 = require_index_node7();
    var tokenGroupMemberCodec = (0, codecs_1.getStructCodec)([
      ["mint", (0, codecs_1.fixCodecSize)((0, codecs_1.getBytesCodec)(), 32)],
      ["group", (0, codecs_1.fixCodecSize)((0, codecs_1.getBytesCodec)(), 32)],
      ["memberNumber", (0, codecs_1.getU64Codec)()]
    ]);
    exports2.TOKEN_GROUP_MEMBER_SIZE = tokenGroupMemberCodec.fixedSize;
    function packTokenGroupMember(member) {
      return tokenGroupMemberCodec.encode({
        mint: member.mint.toBuffer(),
        group: member.group.toBuffer(),
        memberNumber: member.memberNumber
      });
    }
    function unpackTokenGroupMember(buffer) {
      const data = tokenGroupMemberCodec.decode(buffer);
      return {
        mint: new web3_js_1.PublicKey(data.mint),
        group: new web3_js_1.PublicKey(data.group),
        memberNumber: data.memberNumber
      };
    }
  }
});

// node_modules/@solana/spl-token-group/lib/cjs/state/index.js
var require_state4 = __commonJS({
  "node_modules/@solana/spl-token-group/lib/cjs/state/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_tokenGroup(), exports2);
    __exportStar(require_tokenGroupMember(), exports2);
  }
});

// node_modules/@solana/spl-token-group/lib/cjs/index.js
var require_cjs2 = __commonJS({
  "node_modules/@solana/spl-token-group/lib/cjs/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_errors2(), exports2);
    __exportStar(require_instruction(), exports2);
    __exportStar(require_state4(), exports2);
  }
});

// node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/extensions/tokenGroup/actions.js
var require_actions3 = __commonJS({
  "node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/extensions/tokenGroup/actions.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.tokenGroupInitializeGroup = tokenGroupInitializeGroup;
    exports2.tokenGroupInitializeGroupWithRentTransfer = tokenGroupInitializeGroupWithRentTransfer;
    exports2.tokenGroupUpdateGroupMaxSize = tokenGroupUpdateGroupMaxSize;
    exports2.tokenGroupUpdateGroupAuthority = tokenGroupUpdateGroupAuthority;
    exports2.tokenGroupMemberInitialize = tokenGroupMemberInitialize;
    exports2.tokenGroupMemberInitializeWithRentTransfer = tokenGroupMemberInitializeWithRentTransfer;
    var web3_js_1 = require("@solana/web3.js");
    var spl_token_group_1 = require_cjs2();
    var constants_js_1 = require_constants();
    var internal_js_1 = require_internal();
    function tokenGroupInitializeGroup(connection_1, payer_1, mint_1, mintAuthority_1, updateAuthority_1, maxSize_1) {
      return __awaiter(this, arguments, void 0, function* (connection, payer, mint, mintAuthority, updateAuthority, maxSize, multiSigners = [], confirmOptions, programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
        const [mintAuthorityPublicKey, signers] = (0, internal_js_1.getSigners)(mintAuthority, multiSigners);
        const transaction = new web3_js_1.Transaction().add((0, spl_token_group_1.createInitializeGroupInstruction)({
          programId,
          group: mint,
          mint,
          mintAuthority: mintAuthorityPublicKey,
          updateAuthority,
          maxSize
        }));
        return yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer, ...signers], confirmOptions);
      });
    }
    function tokenGroupInitializeGroupWithRentTransfer(connection_1, payer_1, mint_1, mintAuthority_1, updateAuthority_1, maxSize_1) {
      return __awaiter(this, arguments, void 0, function* (connection, payer, mint, mintAuthority, updateAuthority, maxSize, multiSigners = [], confirmOptions, programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
        const [mintAuthorityPublicKey, signers] = (0, internal_js_1.getSigners)(mintAuthority, multiSigners);
        const lamports = yield connection.getMinimumBalanceForRentExemption(spl_token_group_1.TOKEN_GROUP_SIZE);
        const transaction = new web3_js_1.Transaction().add(web3_js_1.SystemProgram.transfer({
          fromPubkey: payer.publicKey,
          toPubkey: mint,
          lamports
        }), (0, spl_token_group_1.createInitializeGroupInstruction)({
          programId,
          group: mint,
          mint,
          mintAuthority: mintAuthorityPublicKey,
          updateAuthority,
          maxSize
        }));
        return yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer, ...signers], confirmOptions);
      });
    }
    function tokenGroupUpdateGroupMaxSize(connection_1, payer_1, mint_1, updateAuthority_1, maxSize_1) {
      return __awaiter(this, arguments, void 0, function* (connection, payer, mint, updateAuthority, maxSize, multiSigners = [], confirmOptions, programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
        const [updateAuthorityPublicKey, signers] = (0, internal_js_1.getSigners)(updateAuthority, multiSigners);
        const transaction = new web3_js_1.Transaction().add((0, spl_token_group_1.createUpdateGroupMaxSizeInstruction)({
          programId,
          group: mint,
          updateAuthority: updateAuthorityPublicKey,
          maxSize
        }));
        return yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer, ...signers], confirmOptions);
      });
    }
    function tokenGroupUpdateGroupAuthority(connection_1, payer_1, mint_1, updateAuthority_1, newAuthority_1) {
      return __awaiter(this, arguments, void 0, function* (connection, payer, mint, updateAuthority, newAuthority, multiSigners = [], confirmOptions, programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
        const [updateAuthorityPublicKey, signers] = (0, internal_js_1.getSigners)(updateAuthority, multiSigners);
        const transaction = new web3_js_1.Transaction().add((0, spl_token_group_1.createUpdateGroupAuthorityInstruction)({
          programId,
          group: mint,
          currentAuthority: updateAuthorityPublicKey,
          newAuthority
        }));
        return yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer, ...signers], confirmOptions);
      });
    }
    function tokenGroupMemberInitialize(connection_1, payer_1, mint_1, mintAuthority_1, group_1, groupUpdateAuthority_1) {
      return __awaiter(this, arguments, void 0, function* (connection, payer, mint, mintAuthority, group, groupUpdateAuthority, multiSigners = [], confirmOptions, programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
        const [mintAuthorityPublicKey, signers] = (0, internal_js_1.getSigners)(mintAuthority, multiSigners);
        const transaction = new web3_js_1.Transaction().add((0, spl_token_group_1.createInitializeMemberInstruction)({
          programId,
          member: mint,
          memberMint: mint,
          memberMintAuthority: mintAuthorityPublicKey,
          group,
          groupUpdateAuthority
        }));
        return yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer, ...signers], confirmOptions);
      });
    }
    function tokenGroupMemberInitializeWithRentTransfer(connection_1, payer_1, mint_1, mintAuthority_1, group_1, groupUpdateAuthority_1) {
      return __awaiter(this, arguments, void 0, function* (connection, payer, mint, mintAuthority, group, groupUpdateAuthority, multiSigners = [], confirmOptions, programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
        const [mintAuthorityPublicKey, signers] = (0, internal_js_1.getSigners)(mintAuthority, multiSigners);
        const lamports = yield connection.getMinimumBalanceForRentExemption(spl_token_group_1.TOKEN_GROUP_MEMBER_SIZE);
        const transaction = new web3_js_1.Transaction().add(web3_js_1.SystemProgram.transfer({
          fromPubkey: payer.publicKey,
          toPubkey: mint,
          lamports
        }), (0, spl_token_group_1.createInitializeMemberInstruction)({
          programId,
          member: mint,
          memberMint: mint,
          memberMintAuthority: mintAuthorityPublicKey,
          group,
          groupUpdateAuthority
        }));
        return yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer, ...signers], confirmOptions);
      });
    }
  }
});

// node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/extensions/tokenGroup/state.js
var require_state5 = __commonJS({
  "node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/extensions/tokenGroup/state.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TOKEN_GROUP_MEMBER_SIZE = exports2.TOKEN_GROUP_SIZE = void 0;
    exports2.getTokenGroupState = getTokenGroupState;
    exports2.getTokenGroupMemberState = getTokenGroupMemberState;
    var web3_js_1 = require("@solana/web3.js");
    var spl_token_group_1 = require_cjs2();
    var extensionType_js_1 = require_extensionType();
    var spl_token_group_2 = require_cjs2();
    Object.defineProperty(exports2, "TOKEN_GROUP_SIZE", { enumerable: true, get: function() {
      return spl_token_group_2.TOKEN_GROUP_SIZE;
    } });
    Object.defineProperty(exports2, "TOKEN_GROUP_MEMBER_SIZE", { enumerable: true, get: function() {
      return spl_token_group_2.TOKEN_GROUP_MEMBER_SIZE;
    } });
    function getTokenGroupState(mint) {
      const extensionData = (0, extensionType_js_1.getExtensionData)(extensionType_js_1.ExtensionType.TokenGroup, mint.tlvData);
      if (extensionData !== null) {
        const { updateAuthority, mint: mint2, size, maxSize } = (0, spl_token_group_1.unpackTokenGroup)(extensionData);
        return {
          updateAuthority: (updateAuthority === null || updateAuthority === void 0 ? void 0 : updateAuthority.equals(web3_js_1.PublicKey.default)) ? void 0 : updateAuthority,
          mint: mint2,
          size,
          maxSize
        };
      } else {
        return null;
      }
    }
    function getTokenGroupMemberState(mint) {
      const extensionData = (0, extensionType_js_1.getExtensionData)(extensionType_js_1.ExtensionType.TokenGroupMember, mint.tlvData);
      if (extensionData !== null) {
        const { mint: mint2, group, memberNumber } = (0, spl_token_group_1.unpackTokenGroupMember)(extensionData);
        return {
          mint: mint2,
          group,
          memberNumber
        };
      } else {
        return null;
      }
    }
  }
});

// node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/extensions/tokenGroup/index.js
var require_tokenGroup2 = __commonJS({
  "node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/extensions/tokenGroup/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_actions3(), exports2);
    __exportStar(require_state5(), exports2);
  }
});

// node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/extensions/groupMemberPointer/state.js
var require_state6 = __commonJS({
  "node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/extensions/groupMemberPointer/state.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.GROUP_MEMBER_POINTER_SIZE = exports2.GroupMemberPointerLayout = void 0;
    exports2.getGroupMemberPointerState = getGroupMemberPointerState;
    var buffer_layout_1 = require_Layout();
    var buffer_layout_utils_1 = require_cjs();
    var web3_js_1 = require("@solana/web3.js");
    var extensionType_js_1 = require_extensionType();
    exports2.GroupMemberPointerLayout = (0, buffer_layout_1.struct)([
      (0, buffer_layout_utils_1.publicKey)("authority"),
      (0, buffer_layout_utils_1.publicKey)("memberAddress")
    ]);
    exports2.GROUP_MEMBER_POINTER_SIZE = exports2.GroupMemberPointerLayout.span;
    function getGroupMemberPointerState(mint) {
      const extensionData = (0, extensionType_js_1.getExtensionData)(extensionType_js_1.ExtensionType.GroupMemberPointer, mint.tlvData);
      if (extensionData !== null) {
        const { authority, memberAddress } = exports2.GroupMemberPointerLayout.decode(extensionData);
        return {
          authority: authority.equals(web3_js_1.PublicKey.default) ? null : authority,
          memberAddress: memberAddress.equals(web3_js_1.PublicKey.default) ? null : memberAddress
        };
      } else {
        return null;
      }
    }
  }
});

// node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/extensions/groupPointer/state.js
var require_state7 = __commonJS({
  "node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/extensions/groupPointer/state.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.GROUP_POINTER_SIZE = exports2.GroupPointerLayout = void 0;
    exports2.getGroupPointerState = getGroupPointerState;
    var buffer_layout_1 = require_Layout();
    var buffer_layout_utils_1 = require_cjs();
    var web3_js_1 = require("@solana/web3.js");
    var extensionType_js_1 = require_extensionType();
    exports2.GroupPointerLayout = (0, buffer_layout_1.struct)([
      (0, buffer_layout_utils_1.publicKey)("authority"),
      (0, buffer_layout_utils_1.publicKey)("groupAddress")
    ]);
    exports2.GROUP_POINTER_SIZE = exports2.GroupPointerLayout.span;
    function getGroupPointerState(mint) {
      const extensionData = (0, extensionType_js_1.getExtensionData)(extensionType_js_1.ExtensionType.GroupPointer, mint.tlvData);
      if (extensionData !== null) {
        const { authority, groupAddress } = exports2.GroupPointerLayout.decode(extensionData);
        return {
          authority: authority.equals(web3_js_1.PublicKey.default) ? null : authority,
          groupAddress: groupAddress.equals(web3_js_1.PublicKey.default) ? null : groupAddress
        };
      } else {
        return null;
      }
    }
  }
});

// node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/extensions/immutableOwner.js
var require_immutableOwner = __commonJS({
  "node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/extensions/immutableOwner.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IMMUTABLE_OWNER_SIZE = exports2.ImmutableOwnerLayout = void 0;
    exports2.getImmutableOwner = getImmutableOwner;
    var buffer_layout_1 = require_Layout();
    var extensionType_js_1 = require_extensionType();
    exports2.ImmutableOwnerLayout = (0, buffer_layout_1.struct)([]);
    exports2.IMMUTABLE_OWNER_SIZE = exports2.ImmutableOwnerLayout.span;
    function getImmutableOwner(account) {
      const extensionData = (0, extensionType_js_1.getExtensionData)(extensionType_js_1.ExtensionType.ImmutableOwner, account.tlvData);
      if (extensionData !== null) {
        return exports2.ImmutableOwnerLayout.decode(extensionData);
      } else {
        return null;
      }
    }
  }
});

// node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/extensions/interestBearingMint/state.js
var require_state8 = __commonJS({
  "node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/extensions/interestBearingMint/state.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.INTEREST_BEARING_MINT_CONFIG_STATE_SIZE = exports2.InterestBearingMintConfigStateLayout = void 0;
    exports2.getInterestBearingMintConfigState = getInterestBearingMintConfigState;
    var buffer_layout_1 = require_Layout();
    var buffer_layout_utils_1 = require_cjs();
    var extensionType_js_1 = require_extensionType();
    exports2.InterestBearingMintConfigStateLayout = (0, buffer_layout_1.struct)([
      (0, buffer_layout_utils_1.publicKey)("rateAuthority"),
      (0, buffer_layout_1.ns64)("initializationTimestamp"),
      (0, buffer_layout_1.s16)("preUpdateAverageRate"),
      (0, buffer_layout_1.ns64)("lastUpdateTimestamp"),
      (0, buffer_layout_1.s16)("currentRate")
    ]);
    exports2.INTEREST_BEARING_MINT_CONFIG_STATE_SIZE = exports2.InterestBearingMintConfigStateLayout.span;
    function getInterestBearingMintConfigState(mint) {
      const extensionData = (0, extensionType_js_1.getExtensionData)(extensionType_js_1.ExtensionType.InterestBearingConfig, mint.tlvData);
      if (extensionData !== null) {
        return exports2.InterestBearingMintConfigStateLayout.decode(extensionData);
      }
      return null;
    }
  }
});

// node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/extensions/memoTransfer/instructions.js
var require_instructions3 = __commonJS({
  "node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/extensions/memoTransfer/instructions.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.memoTransferInstructionData = exports2.MemoTransferInstruction = void 0;
    exports2.createEnableRequiredMemoTransfersInstruction = createEnableRequiredMemoTransfersInstruction;
    exports2.createDisableRequiredMemoTransfersInstruction = createDisableRequiredMemoTransfersInstruction;
    var buffer_layout_1 = require_Layout();
    var web3_js_1 = require("@solana/web3.js");
    var constants_js_1 = require_constants();
    var errors_js_1 = require_errors();
    var internal_js_1 = require_internal2();
    var types_js_1 = require_types();
    var MemoTransferInstruction;
    (function(MemoTransferInstruction2) {
      MemoTransferInstruction2[MemoTransferInstruction2["Enable"] = 0] = "Enable";
      MemoTransferInstruction2[MemoTransferInstruction2["Disable"] = 1] = "Disable";
    })(MemoTransferInstruction || (exports2.MemoTransferInstruction = MemoTransferInstruction = {}));
    exports2.memoTransferInstructionData = (0, buffer_layout_1.struct)([
      (0, buffer_layout_1.u8)("instruction"),
      (0, buffer_layout_1.u8)("memoTransferInstruction")
    ]);
    function createEnableRequiredMemoTransfersInstruction(account, authority, multiSigners = [], programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
      return createMemoTransferInstruction(MemoTransferInstruction.Enable, account, authority, multiSigners, programId);
    }
    function createDisableRequiredMemoTransfersInstruction(account, authority, multiSigners = [], programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
      return createMemoTransferInstruction(MemoTransferInstruction.Disable, account, authority, multiSigners, programId);
    }
    function createMemoTransferInstruction(memoTransferInstruction, account, authority, multiSigners, programId) {
      if (!(0, constants_js_1.programSupportsExtensions)(programId)) {
        throw new errors_js_1.TokenUnsupportedInstructionError();
      }
      const keys = (0, internal_js_1.addSigners)([{ pubkey: account, isSigner: false, isWritable: true }], authority, multiSigners);
      const data = Buffer.alloc(exports2.memoTransferInstructionData.span);
      exports2.memoTransferInstructionData.encode({
        instruction: types_js_1.TokenInstruction.MemoTransferExtension,
        memoTransferInstruction
      }, data);
      return new web3_js_1.TransactionInstruction({ keys, programId, data });
    }
  }
});

// node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/extensions/memoTransfer/actions.js
var require_actions4 = __commonJS({
  "node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/extensions/memoTransfer/actions.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.enableRequiredMemoTransfers = enableRequiredMemoTransfers;
    exports2.disableRequiredMemoTransfers = disableRequiredMemoTransfers;
    var web3_js_1 = require("@solana/web3.js");
    var internal_js_1 = require_internal();
    var constants_js_1 = require_constants();
    var instructions_js_1 = require_instructions3();
    function enableRequiredMemoTransfers(connection_1, payer_1, account_1, owner_1) {
      return __awaiter(this, arguments, void 0, function* (connection, payer, account, owner, multiSigners = [], confirmOptions, programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
        const [ownerPublicKey, signers] = (0, internal_js_1.getSigners)(owner, multiSigners);
        const transaction = new web3_js_1.Transaction().add((0, instructions_js_1.createEnableRequiredMemoTransfersInstruction)(account, ownerPublicKey, signers, programId));
        return yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer, ...signers], confirmOptions);
      });
    }
    function disableRequiredMemoTransfers(connection_1, payer_1, account_1, owner_1) {
      return __awaiter(this, arguments, void 0, function* (connection, payer, account, owner, multiSigners = [], confirmOptions, programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
        const [ownerPublicKey, signers] = (0, internal_js_1.getSigners)(owner, multiSigners);
        const transaction = new web3_js_1.Transaction().add((0, instructions_js_1.createDisableRequiredMemoTransfersInstruction)(account, ownerPublicKey, signers, programId));
        return yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer, ...signers], confirmOptions);
      });
    }
  }
});

// node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/extensions/memoTransfer/state.js
var require_state9 = __commonJS({
  "node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/extensions/memoTransfer/state.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MEMO_TRANSFER_SIZE = exports2.MemoTransferLayout = void 0;
    exports2.getMemoTransfer = getMemoTransfer;
    var buffer_layout_1 = require_Layout();
    var buffer_layout_utils_1 = require_cjs();
    var extensionType_js_1 = require_extensionType();
    exports2.MemoTransferLayout = (0, buffer_layout_1.struct)([(0, buffer_layout_utils_1.bool)("requireIncomingTransferMemos")]);
    exports2.MEMO_TRANSFER_SIZE = exports2.MemoTransferLayout.span;
    function getMemoTransfer(account) {
      const extensionData = (0, extensionType_js_1.getExtensionData)(extensionType_js_1.ExtensionType.MemoTransfer, account.tlvData);
      if (extensionData !== null) {
        return exports2.MemoTransferLayout.decode(extensionData);
      } else {
        return null;
      }
    }
  }
});

// node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/extensions/memoTransfer/index.js
var require_memoTransfer = __commonJS({
  "node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/extensions/memoTransfer/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_actions4(), exports2);
    __exportStar(require_instructions3(), exports2);
    __exportStar(require_state9(), exports2);
  }
});

// node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/extensions/metadataPointer/state.js
var require_state10 = __commonJS({
  "node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/extensions/metadataPointer/state.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.METADATA_POINTER_SIZE = exports2.MetadataPointerLayout = void 0;
    exports2.getMetadataPointerState = getMetadataPointerState;
    var buffer_layout_1 = require_Layout();
    var buffer_layout_utils_1 = require_cjs();
    var web3_js_1 = require("@solana/web3.js");
    var extensionType_js_1 = require_extensionType();
    exports2.MetadataPointerLayout = (0, buffer_layout_1.struct)([
      (0, buffer_layout_utils_1.publicKey)("authority"),
      (0, buffer_layout_utils_1.publicKey)("metadataAddress")
    ]);
    exports2.METADATA_POINTER_SIZE = exports2.MetadataPointerLayout.span;
    function getMetadataPointerState(mint) {
      const extensionData = (0, extensionType_js_1.getExtensionData)(extensionType_js_1.ExtensionType.MetadataPointer, mint.tlvData);
      if (extensionData !== null) {
        const { authority, metadataAddress } = exports2.MetadataPointerLayout.decode(extensionData);
        return {
          authority: authority.equals(web3_js_1.PublicKey.default) ? null : authority,
          metadataAddress: metadataAddress.equals(web3_js_1.PublicKey.default) ? null : metadataAddress
        };
      } else {
        return null;
      }
    }
  }
});

// node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/extensions/mintCloseAuthority.js
var require_mintCloseAuthority = __commonJS({
  "node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/extensions/mintCloseAuthority.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MINT_CLOSE_AUTHORITY_SIZE = exports2.MintCloseAuthorityLayout = void 0;
    exports2.getMintCloseAuthority = getMintCloseAuthority;
    var buffer_layout_1 = require_Layout();
    var buffer_layout_utils_1 = require_cjs();
    var extensionType_js_1 = require_extensionType();
    exports2.MintCloseAuthorityLayout = (0, buffer_layout_1.struct)([(0, buffer_layout_utils_1.publicKey)("closeAuthority")]);
    exports2.MINT_CLOSE_AUTHORITY_SIZE = exports2.MintCloseAuthorityLayout.span;
    function getMintCloseAuthority(mint) {
      const extensionData = (0, extensionType_js_1.getExtensionData)(extensionType_js_1.ExtensionType.MintCloseAuthority, mint.tlvData);
      if (extensionData !== null) {
        return exports2.MintCloseAuthorityLayout.decode(extensionData);
      } else {
        return null;
      }
    }
  }
});

// node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/extensions/nonTransferable.js
var require_nonTransferable = __commonJS({
  "node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/extensions/nonTransferable.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.NON_TRANSFERABLE_ACCOUNT_SIZE = exports2.NON_TRANSFERABLE_SIZE = exports2.NonTransferableLayout = void 0;
    exports2.getNonTransferable = getNonTransferable;
    exports2.getNonTransferableAccount = getNonTransferableAccount;
    var buffer_layout_1 = require_Layout();
    var extensionType_js_1 = require_extensionType();
    exports2.NonTransferableLayout = (0, buffer_layout_1.struct)([]);
    exports2.NON_TRANSFERABLE_SIZE = exports2.NonTransferableLayout.span;
    exports2.NON_TRANSFERABLE_ACCOUNT_SIZE = exports2.NonTransferableLayout.span;
    function getNonTransferable(mint) {
      const extensionData = (0, extensionType_js_1.getExtensionData)(extensionType_js_1.ExtensionType.NonTransferable, mint.tlvData);
      if (extensionData !== null) {
        return exports2.NonTransferableLayout.decode(extensionData);
      } else {
        return null;
      }
    }
    function getNonTransferableAccount(account) {
      const extensionData = (0, extensionType_js_1.getExtensionData)(extensionType_js_1.ExtensionType.NonTransferableAccount, account.tlvData);
      if (extensionData !== null) {
        return exports2.NonTransferableLayout.decode(extensionData);
      } else {
        return null;
      }
    }
  }
});

// node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/extensions/pausable/instructions.js
var require_instructions4 = __commonJS({
  "node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/extensions/pausable/instructions.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.resumeInstructionData = exports2.pauseInstructionData = exports2.initializePausableConfigInstructionData = exports2.PausableInstruction = void 0;
    exports2.createInitializePausableConfigInstruction = createInitializePausableConfigInstruction;
    exports2.createPauseInstruction = createPauseInstruction;
    exports2.createResumeInstruction = createResumeInstruction;
    var buffer_layout_1 = require_Layout();
    var buffer_layout_utils_1 = require_cjs();
    var web3_js_1 = require("@solana/web3.js");
    var constants_js_1 = require_constants();
    var errors_js_1 = require_errors();
    var types_js_1 = require_types();
    var internal_js_1 = require_internal2();
    var PausableInstruction;
    (function(PausableInstruction2) {
      PausableInstruction2[PausableInstruction2["Initialize"] = 0] = "Initialize";
      PausableInstruction2[PausableInstruction2["Pause"] = 1] = "Pause";
      PausableInstruction2[PausableInstruction2["Resume"] = 2] = "Resume";
    })(PausableInstruction || (exports2.PausableInstruction = PausableInstruction = {}));
    exports2.initializePausableConfigInstructionData = (0, buffer_layout_1.struct)([
      (0, buffer_layout_1.u8)("instruction"),
      (0, buffer_layout_1.u8)("pausableInstruction"),
      (0, buffer_layout_utils_1.publicKey)("authority")
    ]);
    function createInitializePausableConfigInstruction(mint, authority, programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
      if (!(0, constants_js_1.programSupportsExtensions)(programId)) {
        throw new errors_js_1.TokenUnsupportedInstructionError();
      }
      const keys = [{ pubkey: mint, isSigner: false, isWritable: true }];
      const data = Buffer.alloc(exports2.initializePausableConfigInstructionData.span);
      exports2.initializePausableConfigInstructionData.encode({
        instruction: types_js_1.TokenInstruction.PausableExtension,
        pausableInstruction: PausableInstruction.Initialize,
        authority: authority !== null && authority !== void 0 ? authority : web3_js_1.PublicKey.default
      }, data);
      return new web3_js_1.TransactionInstruction({ keys, programId, data });
    }
    exports2.pauseInstructionData = (0, buffer_layout_1.struct)([(0, buffer_layout_1.u8)("instruction"), (0, buffer_layout_1.u8)("pausableInstruction")]);
    function createPauseInstruction(mint, authority, multiSigners = [], programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
      if (!(0, constants_js_1.programSupportsExtensions)(programId)) {
        throw new errors_js_1.TokenUnsupportedInstructionError();
      }
      const keys = (0, internal_js_1.addSigners)([{ pubkey: mint, isSigner: false, isWritable: true }], authority, multiSigners);
      const data = Buffer.alloc(exports2.pauseInstructionData.span);
      exports2.pauseInstructionData.encode({
        instruction: types_js_1.TokenInstruction.PausableExtension,
        pausableInstruction: PausableInstruction.Pause
      }, data);
      return new web3_js_1.TransactionInstruction({ keys, programId, data });
    }
    exports2.resumeInstructionData = (0, buffer_layout_1.struct)([(0, buffer_layout_1.u8)("instruction"), (0, buffer_layout_1.u8)("pausableInstruction")]);
    function createResumeInstruction(mint, authority, multiSigners = [], programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
      if (!(0, constants_js_1.programSupportsExtensions)(programId)) {
        throw new errors_js_1.TokenUnsupportedInstructionError();
      }
      const keys = (0, internal_js_1.addSigners)([{ pubkey: mint, isSigner: false, isWritable: true }], authority, multiSigners);
      const data = Buffer.alloc(exports2.resumeInstructionData.span);
      exports2.resumeInstructionData.encode({
        instruction: types_js_1.TokenInstruction.PausableExtension,
        pausableInstruction: PausableInstruction.Resume
      }, data);
      return new web3_js_1.TransactionInstruction({ keys, programId, data });
    }
  }
});

// node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/extensions/pausable/actions.js
var require_actions5 = __commonJS({
  "node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/extensions/pausable/actions.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.pause = pause;
    exports2.resume = resume;
    var web3_js_1 = require("@solana/web3.js");
    var internal_js_1 = require_internal();
    var constants_js_1 = require_constants();
    var instructions_js_1 = require_instructions4();
    function pause(connection_1, payer_1, mint_1, owner_1) {
      return __awaiter(this, arguments, void 0, function* (connection, payer, mint, owner, multiSigners = [], confirmOptions, programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
        const [ownerPublicKey, signers] = (0, internal_js_1.getSigners)(owner, multiSigners);
        const transaction = new web3_js_1.Transaction().add((0, instructions_js_1.createPauseInstruction)(mint, ownerPublicKey, multiSigners, programId));
        return yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer, ...signers], confirmOptions);
      });
    }
    function resume(connection_1, payer_1, mint_1, owner_1) {
      return __awaiter(this, arguments, void 0, function* (connection, payer, mint, owner, multiSigners = [], confirmOptions, programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
        const [ownerPublicKey, signers] = (0, internal_js_1.getSigners)(owner, multiSigners);
        const transaction = new web3_js_1.Transaction().add((0, instructions_js_1.createResumeInstruction)(mint, ownerPublicKey, multiSigners, programId));
        return yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer, ...signers], confirmOptions);
      });
    }
  }
});

// node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/extensions/pausable/state.js
var require_state11 = __commonJS({
  "node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/extensions/pausable/state.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PAUSABLE_ACCOUNT_SIZE = exports2.PausableAccountLayout = exports2.PAUSABLE_CONFIG_SIZE = exports2.PausableConfigLayout = void 0;
    exports2.getPausableConfig = getPausableConfig;
    exports2.getPausableAccount = getPausableAccount;
    var buffer_layout_1 = require_Layout();
    var buffer_layout_utils_1 = require_cjs();
    var extensionType_js_1 = require_extensionType();
    exports2.PausableConfigLayout = (0, buffer_layout_1.struct)([(0, buffer_layout_utils_1.publicKey)("authority"), (0, buffer_layout_utils_1.bool)("paused")]);
    exports2.PAUSABLE_CONFIG_SIZE = exports2.PausableConfigLayout.span;
    function getPausableConfig(mint) {
      const extensionData = (0, extensionType_js_1.getExtensionData)(extensionType_js_1.ExtensionType.PausableConfig, mint.tlvData);
      if (extensionData !== null) {
        return exports2.PausableConfigLayout.decode(extensionData);
      } else {
        return null;
      }
    }
    exports2.PausableAccountLayout = (0, buffer_layout_1.struct)([]);
    exports2.PAUSABLE_ACCOUNT_SIZE = exports2.PausableAccountLayout.span;
    function getPausableAccount(account) {
      const extensionData = (0, extensionType_js_1.getExtensionData)(extensionType_js_1.ExtensionType.PausableAccount, account.tlvData);
      if (extensionData !== null) {
        return exports2.PausableAccountLayout.decode(extensionData);
      } else {
        return null;
      }
    }
  }
});

// node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/extensions/pausable/index.js
var require_pausable = __commonJS({
  "node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/extensions/pausable/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_actions5(), exports2);
    __exportStar(require_instructions4(), exports2);
    __exportStar(require_state11(), exports2);
  }
});

// node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/extensions/permanentDelegate.js
var require_permanentDelegate = __commonJS({
  "node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/extensions/permanentDelegate.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PERMANENT_DELEGATE_SIZE = exports2.PermanentDelegateLayout = void 0;
    exports2.getPermanentDelegate = getPermanentDelegate;
    var buffer_layout_1 = require_Layout();
    var buffer_layout_utils_1 = require_cjs();
    var extensionType_js_1 = require_extensionType();
    exports2.PermanentDelegateLayout = (0, buffer_layout_1.struct)([(0, buffer_layout_utils_1.publicKey)("delegate")]);
    exports2.PERMANENT_DELEGATE_SIZE = exports2.PermanentDelegateLayout.span;
    function getPermanentDelegate(mint) {
      const extensionData = (0, extensionType_js_1.getExtensionData)(extensionType_js_1.ExtensionType.PermanentDelegate, mint.tlvData);
      if (extensionData !== null) {
        return exports2.PermanentDelegateLayout.decode(extensionData);
      } else {
        return null;
      }
    }
  }
});

// node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/extensions/scaledUiAmount/instructions.js
var require_instructions5 = __commonJS({
  "node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/extensions/scaledUiAmount/instructions.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.updateMultiplierData = exports2.initializeScaledUiAmountConfigInstructionData = exports2.ScaledUiAmountInstruction = void 0;
    exports2.createInitializeScaledUiAmountConfigInstruction = createInitializeScaledUiAmountConfigInstruction;
    exports2.createUpdateMultiplierDataInstruction = createUpdateMultiplierDataInstruction;
    var buffer_layout_1 = require_Layout();
    var buffer_layout_utils_1 = require_cjs();
    var types_js_1 = require_types();
    var web3_js_1 = require("@solana/web3.js");
    var constants_js_1 = require_constants();
    var errors_js_1 = require_errors();
    var internal_js_1 = require_internal2();
    var ScaledUiAmountInstruction;
    (function(ScaledUiAmountInstruction2) {
      ScaledUiAmountInstruction2[ScaledUiAmountInstruction2["Initialize"] = 0] = "Initialize";
      ScaledUiAmountInstruction2[ScaledUiAmountInstruction2["UpdateMultiplier"] = 1] = "UpdateMultiplier";
    })(ScaledUiAmountInstruction || (exports2.ScaledUiAmountInstruction = ScaledUiAmountInstruction = {}));
    exports2.initializeScaledUiAmountConfigInstructionData = (0, buffer_layout_1.struct)([
      (0, buffer_layout_1.u8)("instruction"),
      (0, buffer_layout_1.u8)("scaledUiAmountInstruction"),
      (0, buffer_layout_utils_1.publicKey)("authority"),
      (0, buffer_layout_1.f64)("multiplier")
    ]);
    function createInitializeScaledUiAmountConfigInstruction(mint, authority, multiplier, programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
      if (!(0, constants_js_1.programSupportsExtensions)(programId)) {
        throw new errors_js_1.TokenUnsupportedInstructionError();
      }
      const keys = [{ pubkey: mint, isSigner: false, isWritable: true }];
      const data = Buffer.alloc(exports2.initializeScaledUiAmountConfigInstructionData.span);
      exports2.initializeScaledUiAmountConfigInstructionData.encode({
        instruction: types_js_1.TokenInstruction.ScaledUiAmountExtension,
        scaledUiAmountInstruction: ScaledUiAmountInstruction.Initialize,
        authority: authority !== null && authority !== void 0 ? authority : web3_js_1.PublicKey.default,
        multiplier
      }, data);
      return new web3_js_1.TransactionInstruction({ keys, programId, data });
    }
    exports2.updateMultiplierData = (0, buffer_layout_1.struct)([
      (0, buffer_layout_1.u8)("instruction"),
      (0, buffer_layout_1.u8)("scaledUiAmountInstruction"),
      (0, buffer_layout_1.f64)("multiplier"),
      (0, buffer_layout_utils_1.u64)("effectiveTimestamp")
    ]);
    function createUpdateMultiplierDataInstruction(mint, authority, multiplier, effectiveTimestamp, multiSigners = [], programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
      if (!(0, constants_js_1.programSupportsExtensions)(programId)) {
        throw new errors_js_1.TokenUnsupportedInstructionError();
      }
      const keys = (0, internal_js_1.addSigners)([{ pubkey: mint, isSigner: false, isWritable: true }], authority, multiSigners);
      const data = Buffer.alloc(exports2.updateMultiplierData.span);
      exports2.updateMultiplierData.encode({
        instruction: types_js_1.TokenInstruction.ScaledUiAmountExtension,
        scaledUiAmountInstruction: ScaledUiAmountInstruction.UpdateMultiplier,
        multiplier,
        effectiveTimestamp
      }, data);
      return new web3_js_1.TransactionInstruction({ keys, programId, data });
    }
  }
});

// node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/extensions/scaledUiAmount/actions.js
var require_actions6 = __commonJS({
  "node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/extensions/scaledUiAmount/actions.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.updateMultiplier = updateMultiplier;
    var web3_js_1 = require("@solana/web3.js");
    var internal_js_1 = require_internal();
    var constants_js_1 = require_constants();
    var instructions_js_1 = require_instructions5();
    function updateMultiplier(connection_1, payer_1, mint_1, owner_1, multiplier_1, effectiveTimestamp_1) {
      return __awaiter(this, arguments, void 0, function* (connection, payer, mint, owner, multiplier, effectiveTimestamp, multiSigners = [], confirmOptions, programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
        const [ownerPublicKey, signers] = (0, internal_js_1.getSigners)(owner, multiSigners);
        const transaction = new web3_js_1.Transaction().add((0, instructions_js_1.createUpdateMultiplierDataInstruction)(mint, ownerPublicKey, multiplier, effectiveTimestamp, multiSigners, programId));
        return yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer, ...signers], confirmOptions);
      });
    }
  }
});

// node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/extensions/scaledUiAmount/state.js
var require_state12 = __commonJS({
  "node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/extensions/scaledUiAmount/state.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SCALED_UI_AMOUNT_CONFIG_SIZE = exports2.ScaledUiAmountConfigLayout = void 0;
    exports2.getScaledUiAmountConfig = getScaledUiAmountConfig;
    var buffer_layout_1 = require_Layout();
    var buffer_layout_utils_1 = require_cjs();
    var extensionType_js_1 = require_extensionType();
    exports2.ScaledUiAmountConfigLayout = (0, buffer_layout_1.struct)([
      (0, buffer_layout_utils_1.publicKey)("authority"),
      (0, buffer_layout_1.f64)("multiplier"),
      (0, buffer_layout_utils_1.u64)("newMultiplierEffectiveTimestamp"),
      (0, buffer_layout_1.f64)("newMultiplier")
    ]);
    exports2.SCALED_UI_AMOUNT_CONFIG_SIZE = exports2.ScaledUiAmountConfigLayout.span;
    function getScaledUiAmountConfig(mint) {
      const extensionData = (0, extensionType_js_1.getExtensionData)(extensionType_js_1.ExtensionType.ScaledUiAmountConfig, mint.tlvData);
      if (extensionData !== null) {
        return exports2.ScaledUiAmountConfigLayout.decode(extensionData);
      }
      return null;
    }
  }
});

// node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/extensions/scaledUiAmount/index.js
var require_scaledUiAmount = __commonJS({
  "node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/extensions/scaledUiAmount/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_actions6(), exports2);
    __exportStar(require_instructions5(), exports2);
    __exportStar(require_state12(), exports2);
  }
});

// node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/serialization.js
var require_serialization = __commonJS({
  "node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/serialization.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.COptionPublicKeyLayout = void 0;
    var buffer_layout_1 = require_Layout();
    var buffer_layout_utils_1 = require_cjs();
    var COptionPublicKeyLayout = class extends buffer_layout_1.Layout {
      constructor(property) {
        super(-1, property);
        this.publicKeyLayout = (0, buffer_layout_utils_1.publicKey)();
      }
      decode(buffer, offset2 = 0) {
        const option2 = buffer[offset2];
        if (option2 === 0) {
          return null;
        }
        return this.publicKeyLayout.decode(buffer, offset2 + 1);
      }
      encode(src, buffer, offset2 = 0) {
        if (src === null) {
          buffer[offset2] = 0;
          return 1;
        } else {
          buffer[offset2] = 1;
          this.publicKeyLayout.encode(src, buffer, offset2 + 1);
          return 33;
        }
      }
      getSpan(buffer, offset2 = 0) {
        if (buffer) {
          const option2 = buffer[offset2];
          return option2 === 0 ? 1 : 1 + this.publicKeyLayout.span;
        }
        throw new RangeError("Buffer must be provided");
      }
    };
    exports2.COptionPublicKeyLayout = COptionPublicKeyLayout;
  }
});

// node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/extensions/transferFee/instructions.js
var require_instructions6 = __commonJS({
  "node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/extensions/transferFee/instructions.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.setTransferFeeInstructionData = exports2.harvestWithheldTokensToMintInstructionData = exports2.withdrawWithheldTokensFromAccountsInstructionData = exports2.withdrawWithheldTokensFromMintInstructionData = exports2.transferCheckedWithFeeInstructionData = exports2.initializeTransferFeeConfigInstructionData = exports2.TransferFeeInstruction = void 0;
    exports2.createInitializeTransferFeeConfigInstruction = createInitializeTransferFeeConfigInstruction;
    exports2.decodeInitializeTransferFeeConfigInstruction = decodeInitializeTransferFeeConfigInstruction;
    exports2.decodeInitializeTransferFeeConfigInstructionUnchecked = decodeInitializeTransferFeeConfigInstructionUnchecked;
    exports2.createTransferCheckedWithFeeInstruction = createTransferCheckedWithFeeInstruction;
    exports2.decodeTransferCheckedWithFeeInstruction = decodeTransferCheckedWithFeeInstruction;
    exports2.decodeTransferCheckedWithFeeInstructionUnchecked = decodeTransferCheckedWithFeeInstructionUnchecked;
    exports2.createWithdrawWithheldTokensFromMintInstruction = createWithdrawWithheldTokensFromMintInstruction;
    exports2.decodeWithdrawWithheldTokensFromMintInstruction = decodeWithdrawWithheldTokensFromMintInstruction;
    exports2.decodeWithdrawWithheldTokensFromMintInstructionUnchecked = decodeWithdrawWithheldTokensFromMintInstructionUnchecked;
    exports2.createWithdrawWithheldTokensFromAccountsInstruction = createWithdrawWithheldTokensFromAccountsInstruction;
    exports2.decodeWithdrawWithheldTokensFromAccountsInstruction = decodeWithdrawWithheldTokensFromAccountsInstruction;
    exports2.decodeWithdrawWithheldTokensFromAccountsInstructionUnchecked = decodeWithdrawWithheldTokensFromAccountsInstructionUnchecked;
    exports2.createHarvestWithheldTokensToMintInstruction = createHarvestWithheldTokensToMintInstruction;
    exports2.decodeHarvestWithheldTokensToMintInstruction = decodeHarvestWithheldTokensToMintInstruction;
    exports2.decodeHarvestWithheldTokensToMintInstructionUnchecked = decodeHarvestWithheldTokensToMintInstructionUnchecked;
    exports2.createSetTransferFeeInstruction = createSetTransferFeeInstruction;
    exports2.decodeSetTransferFeeInstruction = decodeSetTransferFeeInstruction;
    exports2.decodeSetTransferFeeInstructionUnchecked = decodeSetTransferFeeInstructionUnchecked;
    var buffer_layout_1 = require_Layout();
    var buffer_layout_utils_1 = require_cjs();
    var web3_js_1 = require("@solana/web3.js");
    var constants_js_1 = require_constants();
    var errors_js_1 = require_errors();
    var internal_js_1 = require_internal2();
    var types_js_1 = require_types();
    var serialization_js_1 = require_serialization();
    var TransferFeeInstruction;
    (function(TransferFeeInstruction2) {
      TransferFeeInstruction2[TransferFeeInstruction2["InitializeTransferFeeConfig"] = 0] = "InitializeTransferFeeConfig";
      TransferFeeInstruction2[TransferFeeInstruction2["TransferCheckedWithFee"] = 1] = "TransferCheckedWithFee";
      TransferFeeInstruction2[TransferFeeInstruction2["WithdrawWithheldTokensFromMint"] = 2] = "WithdrawWithheldTokensFromMint";
      TransferFeeInstruction2[TransferFeeInstruction2["WithdrawWithheldTokensFromAccounts"] = 3] = "WithdrawWithheldTokensFromAccounts";
      TransferFeeInstruction2[TransferFeeInstruction2["HarvestWithheldTokensToMint"] = 4] = "HarvestWithheldTokensToMint";
      TransferFeeInstruction2[TransferFeeInstruction2["SetTransferFee"] = 5] = "SetTransferFee";
    })(TransferFeeInstruction || (exports2.TransferFeeInstruction = TransferFeeInstruction = {}));
    exports2.initializeTransferFeeConfigInstructionData = (0, buffer_layout_1.struct)([
      (0, buffer_layout_1.u8)("instruction"),
      (0, buffer_layout_1.u8)("transferFeeInstruction"),
      new serialization_js_1.COptionPublicKeyLayout("transferFeeConfigAuthority"),
      new serialization_js_1.COptionPublicKeyLayout("withdrawWithheldAuthority"),
      (0, buffer_layout_1.u16)("transferFeeBasisPoints"),
      (0, buffer_layout_utils_1.u64)("maximumFee")
    ]);
    function createInitializeTransferFeeConfigInstruction(mint, transferFeeConfigAuthority, withdrawWithheldAuthority, transferFeeBasisPoints, maximumFee, programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
      if (!(0, constants_js_1.programSupportsExtensions)(programId)) {
        throw new errors_js_1.TokenUnsupportedInstructionError();
      }
      const keys = [{ pubkey: mint, isSigner: false, isWritable: true }];
      const data = Buffer.alloc(78);
      exports2.initializeTransferFeeConfigInstructionData.encode({
        instruction: types_js_1.TokenInstruction.TransferFeeExtension,
        transferFeeInstruction: TransferFeeInstruction.InitializeTransferFeeConfig,
        transferFeeConfigAuthority,
        withdrawWithheldAuthority,
        transferFeeBasisPoints,
        maximumFee
      }, data);
      return new web3_js_1.TransactionInstruction({
        keys,
        programId,
        data: data.subarray(0, exports2.initializeTransferFeeConfigInstructionData.getSpan(data))
      });
    }
    function decodeInitializeTransferFeeConfigInstruction(instruction, programId) {
      if (!instruction.programId.equals(programId))
        throw new errors_js_1.TokenInvalidInstructionProgramError();
      if (instruction.data.length !== exports2.initializeTransferFeeConfigInstructionData.getSpan(instruction.data))
        throw new errors_js_1.TokenInvalidInstructionDataError();
      const { keys: { mint }, data } = decodeInitializeTransferFeeConfigInstructionUnchecked(instruction);
      if (data.instruction !== types_js_1.TokenInstruction.TransferFeeExtension || data.transferFeeInstruction !== TransferFeeInstruction.InitializeTransferFeeConfig)
        throw new errors_js_1.TokenInvalidInstructionTypeError();
      if (!mint)
        throw new errors_js_1.TokenInvalidInstructionKeysError();
      return {
        programId,
        keys: {
          mint
        },
        data
      };
    }
    function decodeInitializeTransferFeeConfigInstructionUnchecked({ programId, keys: [mint], data }) {
      const { instruction, transferFeeInstruction, transferFeeConfigAuthority, withdrawWithheldAuthority, transferFeeBasisPoints, maximumFee } = exports2.initializeTransferFeeConfigInstructionData.decode(data);
      return {
        programId,
        keys: {
          mint
        },
        data: {
          instruction,
          transferFeeInstruction,
          transferFeeConfigAuthority,
          withdrawWithheldAuthority,
          transferFeeBasisPoints,
          maximumFee
        }
      };
    }
    exports2.transferCheckedWithFeeInstructionData = (0, buffer_layout_1.struct)([
      (0, buffer_layout_1.u8)("instruction"),
      (0, buffer_layout_1.u8)("transferFeeInstruction"),
      (0, buffer_layout_utils_1.u64)("amount"),
      (0, buffer_layout_1.u8)("decimals"),
      (0, buffer_layout_utils_1.u64)("fee")
    ]);
    function createTransferCheckedWithFeeInstruction(source, mint, destination, authority, amount, decimals, fee, multiSigners = [], programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
      if (!(0, constants_js_1.programSupportsExtensions)(programId)) {
        throw new errors_js_1.TokenUnsupportedInstructionError();
      }
      const data = Buffer.alloc(exports2.transferCheckedWithFeeInstructionData.span);
      exports2.transferCheckedWithFeeInstructionData.encode({
        instruction: types_js_1.TokenInstruction.TransferFeeExtension,
        transferFeeInstruction: TransferFeeInstruction.TransferCheckedWithFee,
        amount,
        decimals,
        fee
      }, data);
      const keys = (0, internal_js_1.addSigners)([
        { pubkey: source, isSigner: false, isWritable: true },
        { pubkey: mint, isSigner: false, isWritable: false },
        { pubkey: destination, isSigner: false, isWritable: true }
      ], authority, multiSigners);
      return new web3_js_1.TransactionInstruction({ keys, programId, data });
    }
    function decodeTransferCheckedWithFeeInstruction(instruction, programId) {
      if (!instruction.programId.equals(programId))
        throw new errors_js_1.TokenInvalidInstructionProgramError();
      if (instruction.data.length !== exports2.transferCheckedWithFeeInstructionData.span)
        throw new errors_js_1.TokenInvalidInstructionDataError();
      const { keys: { source, mint, destination, authority, signers }, data } = decodeTransferCheckedWithFeeInstructionUnchecked(instruction);
      if (data.instruction !== types_js_1.TokenInstruction.TransferFeeExtension || data.transferFeeInstruction !== TransferFeeInstruction.TransferCheckedWithFee)
        throw new errors_js_1.TokenInvalidInstructionTypeError();
      if (!mint)
        throw new errors_js_1.TokenInvalidInstructionKeysError();
      return {
        programId,
        keys: {
          source,
          mint,
          destination,
          authority,
          signers: signers ? signers : null
        },
        data
      };
    }
    function decodeTransferCheckedWithFeeInstructionUnchecked({ programId, keys: [source, mint, destination, authority, ...signers], data }) {
      const { instruction, transferFeeInstruction, amount, decimals, fee } = exports2.transferCheckedWithFeeInstructionData.decode(data);
      return {
        programId,
        keys: {
          source,
          mint,
          destination,
          authority,
          signers
        },
        data: {
          instruction,
          transferFeeInstruction,
          amount,
          decimals,
          fee
        }
      };
    }
    exports2.withdrawWithheldTokensFromMintInstructionData = (0, buffer_layout_1.struct)([
      (0, buffer_layout_1.u8)("instruction"),
      (0, buffer_layout_1.u8)("transferFeeInstruction")
    ]);
    function createWithdrawWithheldTokensFromMintInstruction(mint, destination, authority, signers = [], programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
      if (!(0, constants_js_1.programSupportsExtensions)(programId)) {
        throw new errors_js_1.TokenUnsupportedInstructionError();
      }
      const data = Buffer.alloc(exports2.withdrawWithheldTokensFromMintInstructionData.span);
      exports2.withdrawWithheldTokensFromMintInstructionData.encode({
        instruction: types_js_1.TokenInstruction.TransferFeeExtension,
        transferFeeInstruction: TransferFeeInstruction.WithdrawWithheldTokensFromMint
      }, data);
      const keys = (0, internal_js_1.addSigners)([
        { pubkey: mint, isSigner: false, isWritable: true },
        { pubkey: destination, isSigner: false, isWritable: true }
      ], authority, signers);
      return new web3_js_1.TransactionInstruction({ keys, programId, data });
    }
    function decodeWithdrawWithheldTokensFromMintInstruction(instruction, programId) {
      if (!instruction.programId.equals(programId))
        throw new errors_js_1.TokenInvalidInstructionProgramError();
      if (instruction.data.length !== exports2.withdrawWithheldTokensFromMintInstructionData.span)
        throw new errors_js_1.TokenInvalidInstructionDataError();
      const { keys: { mint, destination, authority, signers }, data } = decodeWithdrawWithheldTokensFromMintInstructionUnchecked(instruction);
      if (data.instruction !== types_js_1.TokenInstruction.TransferFeeExtension || data.transferFeeInstruction !== TransferFeeInstruction.WithdrawWithheldTokensFromMint)
        throw new errors_js_1.TokenInvalidInstructionTypeError();
      if (!mint)
        throw new errors_js_1.TokenInvalidInstructionKeysError();
      return {
        programId,
        keys: {
          mint,
          destination,
          authority,
          signers: signers ? signers : null
        },
        data
      };
    }
    function decodeWithdrawWithheldTokensFromMintInstructionUnchecked({ programId, keys: [mint, destination, authority, ...signers], data }) {
      const { instruction, transferFeeInstruction } = exports2.withdrawWithheldTokensFromMintInstructionData.decode(data);
      return {
        programId,
        keys: {
          mint,
          destination,
          authority,
          signers
        },
        data: {
          instruction,
          transferFeeInstruction
        }
      };
    }
    exports2.withdrawWithheldTokensFromAccountsInstructionData = (0, buffer_layout_1.struct)([
      (0, buffer_layout_1.u8)("instruction"),
      (0, buffer_layout_1.u8)("transferFeeInstruction"),
      (0, buffer_layout_1.u8)("numTokenAccounts")
    ]);
    function createWithdrawWithheldTokensFromAccountsInstruction(mint, destination, authority, signers, sources, programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
      if (!(0, constants_js_1.programSupportsExtensions)(programId)) {
        throw new errors_js_1.TokenUnsupportedInstructionError();
      }
      const data = Buffer.alloc(exports2.withdrawWithheldTokensFromAccountsInstructionData.span);
      exports2.withdrawWithheldTokensFromAccountsInstructionData.encode({
        instruction: types_js_1.TokenInstruction.TransferFeeExtension,
        transferFeeInstruction: TransferFeeInstruction.WithdrawWithheldTokensFromAccounts,
        numTokenAccounts: sources.length
      }, data);
      const keys = (0, internal_js_1.addSigners)([
        { pubkey: mint, isSigner: false, isWritable: true },
        { pubkey: destination, isSigner: false, isWritable: true }
      ], authority, signers);
      for (const source of sources) {
        keys.push({ pubkey: source, isSigner: false, isWritable: true });
      }
      return new web3_js_1.TransactionInstruction({ keys, programId, data });
    }
    function decodeWithdrawWithheldTokensFromAccountsInstruction(instruction, programId) {
      if (!instruction.programId.equals(programId))
        throw new errors_js_1.TokenInvalidInstructionProgramError();
      if (instruction.data.length !== exports2.withdrawWithheldTokensFromAccountsInstructionData.span)
        throw new errors_js_1.TokenInvalidInstructionDataError();
      const { keys: { mint, destination, authority, signers, sources }, data } = decodeWithdrawWithheldTokensFromAccountsInstructionUnchecked(instruction);
      if (data.instruction !== types_js_1.TokenInstruction.TransferFeeExtension || data.transferFeeInstruction !== TransferFeeInstruction.WithdrawWithheldTokensFromAccounts)
        throw new errors_js_1.TokenInvalidInstructionTypeError();
      if (!mint)
        throw new errors_js_1.TokenInvalidInstructionKeysError();
      return {
        programId,
        keys: {
          mint,
          destination,
          authority,
          signers: signers ? signers : null,
          sources: sources ? sources : null
        },
        data
      };
    }
    function decodeWithdrawWithheldTokensFromAccountsInstructionUnchecked({ programId, keys, data }) {
      const { instruction, transferFeeInstruction, numTokenAccounts } = exports2.withdrawWithheldTokensFromAccountsInstructionData.decode(data);
      const [mint, destination, authority, signers, sources] = [
        keys[0],
        keys[1],
        keys[2],
        keys.slice(3, 3 + numTokenAccounts),
        keys.slice(-1 * numTokenAccounts)
      ];
      return {
        programId,
        keys: {
          mint,
          destination,
          authority,
          signers,
          sources
        },
        data: {
          instruction,
          transferFeeInstruction,
          numTokenAccounts
        }
      };
    }
    exports2.harvestWithheldTokensToMintInstructionData = (0, buffer_layout_1.struct)([
      (0, buffer_layout_1.u8)("instruction"),
      (0, buffer_layout_1.u8)("transferFeeInstruction")
    ]);
    function createHarvestWithheldTokensToMintInstruction(mint, sources, programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
      if (!(0, constants_js_1.programSupportsExtensions)(programId)) {
        throw new errors_js_1.TokenUnsupportedInstructionError();
      }
      const data = Buffer.alloc(exports2.harvestWithheldTokensToMintInstructionData.span);
      exports2.harvestWithheldTokensToMintInstructionData.encode({
        instruction: types_js_1.TokenInstruction.TransferFeeExtension,
        transferFeeInstruction: TransferFeeInstruction.HarvestWithheldTokensToMint
      }, data);
      const keys = [];
      keys.push({ pubkey: mint, isSigner: false, isWritable: true });
      for (const source of sources) {
        keys.push({ pubkey: source, isSigner: false, isWritable: true });
      }
      return new web3_js_1.TransactionInstruction({ keys, programId, data });
    }
    function decodeHarvestWithheldTokensToMintInstruction(instruction, programId) {
      if (!instruction.programId.equals(programId))
        throw new errors_js_1.TokenInvalidInstructionProgramError();
      if (instruction.data.length !== exports2.harvestWithheldTokensToMintInstructionData.span)
        throw new errors_js_1.TokenInvalidInstructionDataError();
      const { keys: { mint, sources }, data } = decodeHarvestWithheldTokensToMintInstructionUnchecked(instruction);
      if (data.instruction !== types_js_1.TokenInstruction.TransferFeeExtension || data.transferFeeInstruction !== TransferFeeInstruction.HarvestWithheldTokensToMint)
        throw new errors_js_1.TokenInvalidInstructionTypeError();
      if (!mint)
        throw new errors_js_1.TokenInvalidInstructionKeysError();
      return {
        programId,
        keys: {
          mint,
          sources
        },
        data
      };
    }
    function decodeHarvestWithheldTokensToMintInstructionUnchecked({ programId, keys: [mint, ...sources], data }) {
      const { instruction, transferFeeInstruction } = exports2.harvestWithheldTokensToMintInstructionData.decode(data);
      return {
        programId,
        keys: {
          mint,
          sources
        },
        data: {
          instruction,
          transferFeeInstruction
        }
      };
    }
    exports2.setTransferFeeInstructionData = (0, buffer_layout_1.struct)([
      (0, buffer_layout_1.u8)("instruction"),
      (0, buffer_layout_1.u8)("transferFeeInstruction"),
      (0, buffer_layout_1.u16)("transferFeeBasisPoints"),
      (0, buffer_layout_utils_1.u64)("maximumFee")
    ]);
    function createSetTransferFeeInstruction(mint, authority, signers, transferFeeBasisPoints, maximumFee, programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
      if (!(0, constants_js_1.programSupportsExtensions)(programId)) {
        throw new errors_js_1.TokenUnsupportedInstructionError();
      }
      const data = Buffer.alloc(exports2.setTransferFeeInstructionData.span);
      exports2.setTransferFeeInstructionData.encode({
        instruction: types_js_1.TokenInstruction.TransferFeeExtension,
        transferFeeInstruction: TransferFeeInstruction.SetTransferFee,
        transferFeeBasisPoints,
        maximumFee
      }, data);
      const keys = (0, internal_js_1.addSigners)([{ pubkey: mint, isSigner: false, isWritable: true }], authority, signers);
      return new web3_js_1.TransactionInstruction({ keys, programId, data });
    }
    function decodeSetTransferFeeInstruction(instruction, programId) {
      if (!instruction.programId.equals(programId))
        throw new errors_js_1.TokenInvalidInstructionProgramError();
      if (instruction.data.length !== exports2.setTransferFeeInstructionData.span)
        throw new errors_js_1.TokenInvalidInstructionDataError();
      const { keys: { mint, authority, signers }, data } = decodeSetTransferFeeInstructionUnchecked(instruction);
      if (data.instruction !== types_js_1.TokenInstruction.TransferFeeExtension || data.transferFeeInstruction !== TransferFeeInstruction.SetTransferFee)
        throw new errors_js_1.TokenInvalidInstructionTypeError();
      if (!mint)
        throw new errors_js_1.TokenInvalidInstructionKeysError();
      return {
        programId,
        keys: {
          mint,
          authority,
          signers: signers ? signers : null
        },
        data
      };
    }
    function decodeSetTransferFeeInstructionUnchecked({ programId, keys: [mint, authority, ...signers], data }) {
      const { instruction, transferFeeInstruction, transferFeeBasisPoints, maximumFee } = exports2.setTransferFeeInstructionData.decode(data);
      return {
        programId,
        keys: {
          mint,
          authority,
          signers
        },
        data: {
          instruction,
          transferFeeInstruction,
          transferFeeBasisPoints,
          maximumFee
        }
      };
    }
  }
});

// node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/extensions/transferFee/actions.js
var require_actions7 = __commonJS({
  "node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/extensions/transferFee/actions.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.transferCheckedWithFee = transferCheckedWithFee;
    exports2.withdrawWithheldTokensFromMint = withdrawWithheldTokensFromMint;
    exports2.withdrawWithheldTokensFromAccounts = withdrawWithheldTokensFromAccounts;
    exports2.harvestWithheldTokensToMint = harvestWithheldTokensToMint;
    exports2.setTransferFee = setTransferFee;
    var web3_js_1 = require("@solana/web3.js");
    var internal_js_1 = require_internal();
    var constants_js_1 = require_constants();
    var instructions_js_1 = require_instructions6();
    function transferCheckedWithFee(connection_1, payer_1, source_1, mint_1, destination_1, owner_1, amount_1, decimals_1, fee_1) {
      return __awaiter(this, arguments, void 0, function* (connection, payer, source, mint, destination, owner, amount, decimals, fee, multiSigners = [], confirmOptions, programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
        const [ownerPublicKey, signers] = (0, internal_js_1.getSigners)(owner, multiSigners);
        const transaction = new web3_js_1.Transaction().add((0, instructions_js_1.createTransferCheckedWithFeeInstruction)(source, mint, destination, ownerPublicKey, amount, decimals, fee, multiSigners, programId));
        return yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer, ...signers], confirmOptions);
      });
    }
    function withdrawWithheldTokensFromMint(connection_1, payer_1, mint_1, destination_1, authority_1) {
      return __awaiter(this, arguments, void 0, function* (connection, payer, mint, destination, authority, multiSigners = [], confirmOptions, programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
        const [authorityPublicKey, signers] = (0, internal_js_1.getSigners)(authority, multiSigners);
        const transaction = new web3_js_1.Transaction().add((0, instructions_js_1.createWithdrawWithheldTokensFromMintInstruction)(mint, destination, authorityPublicKey, signers, programId));
        return yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer, ...signers], confirmOptions);
      });
    }
    function withdrawWithheldTokensFromAccounts(connection_1, payer_1, mint_1, destination_1, authority_1, multiSigners_1, sources_1, confirmOptions_1) {
      return __awaiter(this, arguments, void 0, function* (connection, payer, mint, destination, authority, multiSigners, sources, confirmOptions, programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
        const [authorityPublicKey, signers] = (0, internal_js_1.getSigners)(authority, multiSigners);
        const transaction = new web3_js_1.Transaction().add((0, instructions_js_1.createWithdrawWithheldTokensFromAccountsInstruction)(mint, destination, authorityPublicKey, signers, sources, programId));
        return yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer, ...signers], confirmOptions);
      });
    }
    function harvestWithheldTokensToMint(connection_1, payer_1, mint_1, sources_1, confirmOptions_1) {
      return __awaiter(this, arguments, void 0, function* (connection, payer, mint, sources, confirmOptions, programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
        const transaction = new web3_js_1.Transaction().add((0, instructions_js_1.createHarvestWithheldTokensToMintInstruction)(mint, sources, programId));
        return yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer], confirmOptions);
      });
    }
    function setTransferFee(connection_1, payer_1, mint_1, authority_1, multiSigners_1, transferFeeBasisPoints_1, maximumFee_1, confirmOptions_1) {
      return __awaiter(this, arguments, void 0, function* (connection, payer, mint, authority, multiSigners, transferFeeBasisPoints, maximumFee, confirmOptions, programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
        const [authorityPublicKey, signers] = (0, internal_js_1.getSigners)(authority, multiSigners);
        const transaction = new web3_js_1.Transaction().add((0, instructions_js_1.createSetTransferFeeInstruction)(mint, authorityPublicKey, signers, transferFeeBasisPoints, maximumFee, programId));
        return yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer, ...signers], confirmOptions);
      });
    }
  }
});

// node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/extensions/transferFee/state.js
var require_state13 = __commonJS({
  "node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/extensions/transferFee/state.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TRANSFER_FEE_AMOUNT_SIZE = exports2.TransferFeeAmountLayout = exports2.TRANSFER_FEE_CONFIG_SIZE = exports2.TransferFeeConfigLayout = exports2.ONE_IN_BASIS_POINTS = exports2.MAX_FEE_BASIS_POINTS = void 0;
    exports2.transferFeeLayout = transferFeeLayout;
    exports2.calculateFee = calculateFee;
    exports2.getEpochFee = getEpochFee;
    exports2.calculateEpochFee = calculateEpochFee;
    exports2.getTransferFeeConfig = getTransferFeeConfig;
    exports2.getTransferFeeAmount = getTransferFeeAmount;
    var buffer_layout_1 = require_Layout();
    var buffer_layout_utils_1 = require_cjs();
    var extensionType_js_1 = require_extensionType();
    exports2.MAX_FEE_BASIS_POINTS = 1e4;
    exports2.ONE_IN_BASIS_POINTS = BigInt(exports2.MAX_FEE_BASIS_POINTS);
    function transferFeeLayout(property) {
      return (0, buffer_layout_1.struct)([(0, buffer_layout_utils_1.u64)("epoch"), (0, buffer_layout_utils_1.u64)("maximumFee"), (0, buffer_layout_1.u16)("transferFeeBasisPoints")], property);
    }
    function calculateFee(transferFee, preFeeAmount) {
      const transferFeeBasisPoints = transferFee.transferFeeBasisPoints;
      if (transferFeeBasisPoints === 0 || preFeeAmount === BigInt(0)) {
        return BigInt(0);
      } else {
        const numerator = preFeeAmount * BigInt(transferFeeBasisPoints);
        const rawFee = (numerator + exports2.ONE_IN_BASIS_POINTS - BigInt(1)) / exports2.ONE_IN_BASIS_POINTS;
        const fee = rawFee > transferFee.maximumFee ? transferFee.maximumFee : rawFee;
        return BigInt(fee);
      }
    }
    exports2.TransferFeeConfigLayout = (0, buffer_layout_1.struct)([
      (0, buffer_layout_utils_1.publicKey)("transferFeeConfigAuthority"),
      (0, buffer_layout_utils_1.publicKey)("withdrawWithheldAuthority"),
      (0, buffer_layout_utils_1.u64)("withheldAmount"),
      transferFeeLayout("olderTransferFee"),
      transferFeeLayout("newerTransferFee")
    ]);
    exports2.TRANSFER_FEE_CONFIG_SIZE = exports2.TransferFeeConfigLayout.span;
    function getEpochFee(transferFeeConfig, epoch) {
      if (epoch >= transferFeeConfig.newerTransferFee.epoch) {
        return transferFeeConfig.newerTransferFee;
      } else {
        return transferFeeConfig.olderTransferFee;
      }
    }
    function calculateEpochFee(transferFeeConfig, epoch, preFeeAmount) {
      const transferFee = getEpochFee(transferFeeConfig, epoch);
      return calculateFee(transferFee, preFeeAmount);
    }
    exports2.TransferFeeAmountLayout = (0, buffer_layout_1.struct)([(0, buffer_layout_utils_1.u64)("withheldAmount")]);
    exports2.TRANSFER_FEE_AMOUNT_SIZE = exports2.TransferFeeAmountLayout.span;
    function getTransferFeeConfig(mint) {
      const extensionData = (0, extensionType_js_1.getExtensionData)(extensionType_js_1.ExtensionType.TransferFeeConfig, mint.tlvData);
      if (extensionData !== null) {
        return exports2.TransferFeeConfigLayout.decode(extensionData);
      } else {
        return null;
      }
    }
    function getTransferFeeAmount(account) {
      const extensionData = (0, extensionType_js_1.getExtensionData)(extensionType_js_1.ExtensionType.TransferFeeAmount, account.tlvData);
      if (extensionData !== null) {
        return exports2.TransferFeeAmountLayout.decode(extensionData);
      } else {
        return null;
      }
    }
  }
});

// node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/extensions/transferFee/index.js
var require_transferFee = __commonJS({
  "node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/extensions/transferFee/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_actions7(), exports2);
    __exportStar(require_instructions6(), exports2);
    __exportStar(require_state13(), exports2);
  }
});

// node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/instructions/transferChecked.js
var require_transferChecked = __commonJS({
  "node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/instructions/transferChecked.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.transferCheckedInstructionData = void 0;
    exports2.createTransferCheckedInstruction = createTransferCheckedInstruction;
    exports2.decodeTransferCheckedInstruction = decodeTransferCheckedInstruction;
    exports2.decodeTransferCheckedInstructionUnchecked = decodeTransferCheckedInstructionUnchecked;
    var buffer_layout_1 = require_Layout();
    var buffer_layout_utils_1 = require_cjs();
    var web3_js_1 = require("@solana/web3.js");
    var constants_js_1 = require_constants();
    var errors_js_1 = require_errors();
    var internal_js_1 = require_internal2();
    var types_js_1 = require_types();
    exports2.transferCheckedInstructionData = (0, buffer_layout_1.struct)([
      (0, buffer_layout_1.u8)("instruction"),
      (0, buffer_layout_utils_1.u64)("amount"),
      (0, buffer_layout_1.u8)("decimals")
    ]);
    function createTransferCheckedInstruction(source, mint, destination, owner, amount, decimals, multiSigners = [], programId = constants_js_1.TOKEN_PROGRAM_ID) {
      const keys = (0, internal_js_1.addSigners)([
        { pubkey: source, isSigner: false, isWritable: true },
        { pubkey: mint, isSigner: false, isWritable: false },
        { pubkey: destination, isSigner: false, isWritable: true }
      ], owner, multiSigners);
      const data = Buffer.alloc(exports2.transferCheckedInstructionData.span);
      exports2.transferCheckedInstructionData.encode({
        instruction: types_js_1.TokenInstruction.TransferChecked,
        amount: BigInt(amount),
        decimals
      }, data);
      return new web3_js_1.TransactionInstruction({ keys, programId, data });
    }
    function decodeTransferCheckedInstruction(instruction, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      if (!instruction.programId.equals(programId))
        throw new errors_js_1.TokenInvalidInstructionProgramError();
      if (instruction.data.length !== exports2.transferCheckedInstructionData.span)
        throw new errors_js_1.TokenInvalidInstructionDataError();
      const { keys: { source, mint, destination, owner, multiSigners }, data } = decodeTransferCheckedInstructionUnchecked(instruction);
      if (data.instruction !== types_js_1.TokenInstruction.TransferChecked)
        throw new errors_js_1.TokenInvalidInstructionTypeError();
      if (!source || !mint || !destination || !owner)
        throw new errors_js_1.TokenInvalidInstructionKeysError();
      return {
        programId,
        keys: {
          source,
          mint,
          destination,
          owner,
          multiSigners
        },
        data
      };
    }
    function decodeTransferCheckedInstructionUnchecked({ programId, keys: [source, mint, destination, owner, ...multiSigners], data }) {
      return {
        programId,
        keys: {
          source,
          mint,
          destination,
          owner,
          multiSigners
        },
        data: exports2.transferCheckedInstructionData.decode(data)
      };
    }
  }
});

// node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/extensions/transferHook/seeds.js
var require_seeds = __commonJS({
  "node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/extensions/transferHook/seeds.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.unpackSeeds = unpackSeeds;
    var errors_js_1 = require_errors();
    var DISCRIMINATOR_SPAN = 1;
    var LITERAL_LENGTH_SPAN = 1;
    var INSTRUCTION_ARG_OFFSET_SPAN = 1;
    var INSTRUCTION_ARG_LENGTH_SPAN = 1;
    var ACCOUNT_KEY_INDEX_SPAN = 1;
    var ACCOUNT_DATA_ACCOUNT_INDEX_SPAN = 1;
    var ACCOUNT_DATA_OFFSET_SPAN = 1;
    var ACCOUNT_DATA_LENGTH_SPAN = 1;
    function unpackSeedLiteral(seeds) {
      if (seeds.length < 1) {
        throw new errors_js_1.TokenTransferHookInvalidSeed();
      }
      const [length, ...rest] = seeds;
      if (rest.length < length) {
        throw new errors_js_1.TokenTransferHookInvalidSeed();
      }
      return {
        data: Buffer.from(rest.slice(0, length)),
        packedLength: DISCRIMINATOR_SPAN + LITERAL_LENGTH_SPAN + length
      };
    }
    function unpackSeedInstructionArg(seeds, instructionData) {
      if (seeds.length < 2) {
        throw new errors_js_1.TokenTransferHookInvalidSeed();
      }
      const [index, length] = seeds;
      if (instructionData.length < length + index) {
        throw new errors_js_1.TokenTransferHookInvalidSeed();
      }
      return {
        data: instructionData.subarray(index, index + length),
        packedLength: DISCRIMINATOR_SPAN + INSTRUCTION_ARG_OFFSET_SPAN + INSTRUCTION_ARG_LENGTH_SPAN
      };
    }
    function unpackSeedAccountKey(seeds, previousMetas) {
      if (seeds.length < 1) {
        throw new errors_js_1.TokenTransferHookInvalidSeed();
      }
      const [index] = seeds;
      if (previousMetas.length <= index) {
        throw new errors_js_1.TokenTransferHookInvalidSeed();
      }
      return {
        data: previousMetas[index].pubkey.toBuffer(),
        packedLength: DISCRIMINATOR_SPAN + ACCOUNT_KEY_INDEX_SPAN
      };
    }
    function unpackSeedAccountData(seeds, previousMetas, connection) {
      return __awaiter(this, void 0, void 0, function* () {
        if (seeds.length < 3) {
          throw new errors_js_1.TokenTransferHookInvalidSeed();
        }
        const [accountIndex, dataIndex, length] = seeds;
        if (previousMetas.length <= accountIndex) {
          throw new errors_js_1.TokenTransferHookInvalidSeed();
        }
        const accountInfo = yield connection.getAccountInfo(previousMetas[accountIndex].pubkey);
        if (accountInfo == null) {
          throw new errors_js_1.TokenTransferHookAccountDataNotFound();
        }
        if (accountInfo.data.length < dataIndex + length) {
          throw new errors_js_1.TokenTransferHookInvalidSeed();
        }
        return {
          data: accountInfo.data.subarray(dataIndex, dataIndex + length),
          packedLength: DISCRIMINATOR_SPAN + ACCOUNT_DATA_ACCOUNT_INDEX_SPAN + ACCOUNT_DATA_OFFSET_SPAN + ACCOUNT_DATA_LENGTH_SPAN
        };
      });
    }
    function unpackFirstSeed(seeds, previousMetas, instructionData, connection) {
      return __awaiter(this, void 0, void 0, function* () {
        const [discriminator, ...rest] = seeds;
        const remaining = new Uint8Array(rest);
        switch (discriminator) {
          case 0:
            return null;
          case 1:
            return unpackSeedLiteral(remaining);
          case 2:
            return unpackSeedInstructionArg(remaining, instructionData);
          case 3:
            return unpackSeedAccountKey(remaining, previousMetas);
          case 4:
            return unpackSeedAccountData(remaining, previousMetas, connection);
          default:
            throw new errors_js_1.TokenTransferHookInvalidSeed();
        }
      });
    }
    function unpackSeeds(seeds, previousMetas, instructionData, connection) {
      return __awaiter(this, void 0, void 0, function* () {
        const unpackedSeeds = [];
        let i = 0;
        while (i < 32) {
          const seed = yield unpackFirstSeed(seeds.slice(i), previousMetas, instructionData, connection);
          if (seed == null) {
            break;
          }
          unpackedSeeds.push(seed.data);
          i += seed.packedLength;
        }
        return unpackedSeeds;
      });
    }
  }
});

// node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/extensions/transferHook/pubkeyData.js
var require_pubkeyData = __commonJS({
  "node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/extensions/transferHook/pubkeyData.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.unpackPubkeyData = unpackPubkeyData;
    var web3_js_1 = require("@solana/web3.js");
    var errors_js_1 = require_errors();
    function unpackPubkeyData(keyDataConfig, previousMetas, instructionData, connection) {
      return __awaiter(this, void 0, void 0, function* () {
        const [discriminator, ...rest] = keyDataConfig;
        const remaining = new Uint8Array(rest);
        switch (discriminator) {
          case 1:
            return unpackPubkeyDataFromInstructionData(remaining, instructionData);
          case 2:
            return unpackPubkeyDataFromAccountData(remaining, previousMetas, connection);
          default:
            throw new errors_js_1.TokenTransferHookInvalidPubkeyData();
        }
      });
    }
    function unpackPubkeyDataFromInstructionData(remaining, instructionData) {
      if (remaining.length < 1) {
        throw new errors_js_1.TokenTransferHookInvalidPubkeyData();
      }
      const dataIndex = remaining[0];
      if (instructionData.length < dataIndex + web3_js_1.PUBLIC_KEY_LENGTH) {
        throw new errors_js_1.TokenTransferHookPubkeyDataTooSmall();
      }
      return new web3_js_1.PublicKey(instructionData.subarray(dataIndex, dataIndex + web3_js_1.PUBLIC_KEY_LENGTH));
    }
    function unpackPubkeyDataFromAccountData(remaining, previousMetas, connection) {
      return __awaiter(this, void 0, void 0, function* () {
        if (remaining.length < 2) {
          throw new errors_js_1.TokenTransferHookInvalidPubkeyData();
        }
        const [accountIndex, dataIndex] = remaining;
        if (previousMetas.length <= accountIndex) {
          throw new errors_js_1.TokenTransferHookAccountDataNotFound();
        }
        const accountInfo = yield connection.getAccountInfo(previousMetas[accountIndex].pubkey);
        if (accountInfo == null) {
          throw new errors_js_1.TokenTransferHookAccountNotFound();
        }
        if (accountInfo.data.length < dataIndex + web3_js_1.PUBLIC_KEY_LENGTH) {
          throw new errors_js_1.TokenTransferHookPubkeyDataTooSmall();
        }
        return new web3_js_1.PublicKey(accountInfo.data.subarray(dataIndex, dataIndex + web3_js_1.PUBLIC_KEY_LENGTH));
      });
    }
  }
});

// node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/extensions/transferHook/state.js
var require_state14 = __commonJS({
  "node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/extensions/transferHook/state.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ExtraAccountMetaAccountDataLayout = exports2.ExtraAccountMetaListLayout = exports2.ExtraAccountMetaLayout = exports2.TRANSFER_HOOK_ACCOUNT_SIZE = exports2.TransferHookAccountLayout = exports2.TRANSFER_HOOK_SIZE = exports2.TransferHookLayout = void 0;
    exports2.getTransferHook = getTransferHook;
    exports2.getTransferHookAccount = getTransferHookAccount;
    exports2.getExtraAccountMetaAddress = getExtraAccountMetaAddress;
    exports2.getExtraAccountMetas = getExtraAccountMetas;
    exports2.resolveExtraAccountMeta = resolveExtraAccountMeta;
    var buffer_layout_1 = require_Layout();
    var extensionType_js_1 = require_extensionType();
    var web3_js_1 = require("@solana/web3.js");
    var buffer_layout_utils_1 = require_cjs();
    var errors_js_1 = require_errors();
    var seeds_js_1 = require_seeds();
    var pubkeyData_js_1 = require_pubkeyData();
    exports2.TransferHookLayout = (0, buffer_layout_1.struct)([(0, buffer_layout_utils_1.publicKey)("authority"), (0, buffer_layout_utils_1.publicKey)("programId")]);
    exports2.TRANSFER_HOOK_SIZE = exports2.TransferHookLayout.span;
    function getTransferHook(mint) {
      const extensionData = (0, extensionType_js_1.getExtensionData)(extensionType_js_1.ExtensionType.TransferHook, mint.tlvData);
      if (extensionData !== null) {
        return exports2.TransferHookLayout.decode(extensionData);
      } else {
        return null;
      }
    }
    exports2.TransferHookAccountLayout = (0, buffer_layout_1.struct)([(0, buffer_layout_utils_1.bool)("transferring")]);
    exports2.TRANSFER_HOOK_ACCOUNT_SIZE = exports2.TransferHookAccountLayout.span;
    function getTransferHookAccount(account) {
      const extensionData = (0, extensionType_js_1.getExtensionData)(extensionType_js_1.ExtensionType.TransferHookAccount, account.tlvData);
      if (extensionData !== null) {
        return exports2.TransferHookAccountLayout.decode(extensionData);
      } else {
        return null;
      }
    }
    function getExtraAccountMetaAddress(mint, programId) {
      const seeds = [Buffer.from("extra-account-metas"), mint.toBuffer()];
      return web3_js_1.PublicKey.findProgramAddressSync(seeds, programId)[0];
    }
    exports2.ExtraAccountMetaLayout = (0, buffer_layout_1.struct)([
      (0, buffer_layout_1.u8)("discriminator"),
      (0, buffer_layout_1.blob)(32, "addressConfig"),
      (0, buffer_layout_utils_1.bool)("isSigner"),
      (0, buffer_layout_utils_1.bool)("isWritable")
    ]);
    exports2.ExtraAccountMetaListLayout = (0, buffer_layout_1.struct)([
      (0, buffer_layout_1.u32)("count"),
      (0, buffer_layout_1.seq)(exports2.ExtraAccountMetaLayout, (0, buffer_layout_1.greedy)(exports2.ExtraAccountMetaLayout.span), "extraAccounts")
    ]);
    exports2.ExtraAccountMetaAccountDataLayout = (0, buffer_layout_1.struct)([
      (0, buffer_layout_utils_1.u64)("instructionDiscriminator"),
      (0, buffer_layout_1.u32)("length"),
      exports2.ExtraAccountMetaListLayout.replicate("extraAccountsList")
    ]);
    function getExtraAccountMetas(account) {
      const extraAccountsList = exports2.ExtraAccountMetaAccountDataLayout.decode(account.data).extraAccountsList;
      return extraAccountsList.extraAccounts.slice(0, extraAccountsList.count);
    }
    function resolveExtraAccountMeta(connection, extraMeta, previousMetas, instructionData, transferHookProgramId) {
      return __awaiter(this, void 0, void 0, function* () {
        if (extraMeta.discriminator === 0) {
          return {
            pubkey: new web3_js_1.PublicKey(extraMeta.addressConfig),
            isSigner: extraMeta.isSigner,
            isWritable: extraMeta.isWritable
          };
        } else if (extraMeta.discriminator === 2) {
          const pubkey2 = yield (0, pubkeyData_js_1.unpackPubkeyData)(extraMeta.addressConfig, previousMetas, instructionData, connection);
          return {
            pubkey: pubkey2,
            isSigner: extraMeta.isSigner,
            isWritable: extraMeta.isWritable
          };
        }
        let programId = web3_js_1.PublicKey.default;
        if (extraMeta.discriminator === 1) {
          programId = transferHookProgramId;
        } else {
          const accountIndex = extraMeta.discriminator - (1 << 7);
          if (previousMetas.length <= accountIndex) {
            throw new errors_js_1.TokenTransferHookAccountNotFound();
          }
          programId = previousMetas[accountIndex].pubkey;
        }
        const seeds = yield (0, seeds_js_1.unpackSeeds)(extraMeta.addressConfig, previousMetas, instructionData, connection);
        const pubkey = web3_js_1.PublicKey.findProgramAddressSync(seeds, programId)[0];
        return { pubkey, isSigner: extraMeta.isSigner, isWritable: extraMeta.isWritable };
      });
    }
  }
});

// node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/extensions/transferHook/instructions.js
var require_instructions7 = __commonJS({
  "node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/extensions/transferHook/instructions.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.updateTransferHookInstructionData = exports2.initializeTransferHookInstructionData = exports2.TransferHookInstruction = void 0;
    exports2.createInitializeTransferHookInstruction = createInitializeTransferHookInstruction;
    exports2.createUpdateTransferHookInstruction = createUpdateTransferHookInstruction;
    exports2.createExecuteInstruction = createExecuteInstruction;
    exports2.addExtraAccountMetasForExecute = addExtraAccountMetasForExecute;
    exports2.createTransferCheckedWithTransferHookInstruction = createTransferCheckedWithTransferHookInstruction;
    exports2.createTransferCheckedWithFeeAndTransferHookInstruction = createTransferCheckedWithFeeAndTransferHookInstruction;
    var buffer_layout_1 = require_Layout();
    var web3_js_1 = require("@solana/web3.js");
    var constants_js_1 = require_constants();
    var errors_js_1 = require_errors();
    var internal_js_1 = require_internal2();
    var types_js_1 = require_types();
    var buffer_layout_utils_1 = require_cjs();
    var transferChecked_js_1 = require_transferChecked();
    var instructions_js_1 = require_instructions6();
    var mint_js_1 = require_mint();
    var state_js_1 = require_state14();
    var TransferHookInstruction;
    (function(TransferHookInstruction2) {
      TransferHookInstruction2[TransferHookInstruction2["Initialize"] = 0] = "Initialize";
      TransferHookInstruction2[TransferHookInstruction2["Update"] = 1] = "Update";
    })(TransferHookInstruction || (exports2.TransferHookInstruction = TransferHookInstruction = {}));
    exports2.initializeTransferHookInstructionData = (0, buffer_layout_1.struct)([
      (0, buffer_layout_1.u8)("instruction"),
      (0, buffer_layout_1.u8)("transferHookInstruction"),
      (0, buffer_layout_utils_1.publicKey)("authority"),
      (0, buffer_layout_utils_1.publicKey)("transferHookProgramId")
    ]);
    function createInitializeTransferHookInstruction(mint, authority, transferHookProgramId, programId) {
      if (!(0, constants_js_1.programSupportsExtensions)(programId)) {
        throw new errors_js_1.TokenUnsupportedInstructionError();
      }
      const keys = [{ pubkey: mint, isSigner: false, isWritable: true }];
      const data = Buffer.alloc(exports2.initializeTransferHookInstructionData.span);
      exports2.initializeTransferHookInstructionData.encode({
        instruction: types_js_1.TokenInstruction.TransferHookExtension,
        transferHookInstruction: TransferHookInstruction.Initialize,
        authority,
        transferHookProgramId
      }, data);
      return new web3_js_1.TransactionInstruction({ keys, programId, data });
    }
    exports2.updateTransferHookInstructionData = (0, buffer_layout_1.struct)([
      (0, buffer_layout_1.u8)("instruction"),
      (0, buffer_layout_1.u8)("transferHookInstruction"),
      (0, buffer_layout_utils_1.publicKey)("transferHookProgramId")
    ]);
    function createUpdateTransferHookInstruction(mint, authority, transferHookProgramId, multiSigners = [], programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
      if (!(0, constants_js_1.programSupportsExtensions)(programId)) {
        throw new errors_js_1.TokenUnsupportedInstructionError();
      }
      const keys = (0, internal_js_1.addSigners)([{ pubkey: mint, isSigner: false, isWritable: true }], authority, multiSigners);
      const data = Buffer.alloc(exports2.updateTransferHookInstructionData.span);
      exports2.updateTransferHookInstructionData.encode({
        instruction: types_js_1.TokenInstruction.TransferHookExtension,
        transferHookInstruction: TransferHookInstruction.Update,
        transferHookProgramId
      }, data);
      return new web3_js_1.TransactionInstruction({ keys, programId, data });
    }
    function deEscalateAccountMeta(accountMeta2, accountMetas) {
      const maybeHighestPrivileges = accountMetas.filter((x) => x.pubkey.equals(accountMeta2.pubkey)).reduce((acc, x) => {
        if (!acc)
          return { isSigner: x.isSigner, isWritable: x.isWritable };
        return { isSigner: acc.isSigner || x.isSigner, isWritable: acc.isWritable || x.isWritable };
      }, void 0);
      if (maybeHighestPrivileges) {
        const { isSigner, isWritable } = maybeHighestPrivileges;
        if (!isSigner && isSigner !== accountMeta2.isSigner) {
          accountMeta2.isSigner = false;
        }
        if (!isWritable && isWritable !== accountMeta2.isWritable) {
          accountMeta2.isWritable = false;
        }
      }
      return accountMeta2;
    }
    function createExecuteInstruction(programId, source, mint, destination, owner, validateStatePubkey, amount) {
      const keys = [source, mint, destination, owner, validateStatePubkey].map((pubkey) => ({
        pubkey,
        isSigner: false,
        isWritable: false
      }));
      const data = Buffer.alloc(16);
      data.set(Buffer.from([105, 37, 101, 197, 75, 251, 102, 26]), 0);
      data.writeBigUInt64LE(BigInt(amount), 8);
      return new web3_js_1.TransactionInstruction({ keys, programId, data });
    }
    function addExtraAccountMetasForExecute(connection, instruction, programId, source, mint, destination, owner, amount, commitment) {
      return __awaiter(this, void 0, void 0, function* () {
        const validateStatePubkey = (0, state_js_1.getExtraAccountMetaAddress)(mint, programId);
        const validateStateAccount = yield connection.getAccountInfo(validateStatePubkey, commitment);
        if (validateStateAccount == null) {
          return instruction;
        }
        const validateStateData = (0, state_js_1.getExtraAccountMetas)(validateStateAccount);
        if (![source, mint, destination, owner].every((key) => instruction.keys.some((meta) => meta.pubkey.equals(key)))) {
          throw new Error("Missing required account in instruction");
        }
        const executeInstruction = createExecuteInstruction(programId, source, mint, destination, owner, validateStatePubkey, BigInt(amount));
        for (const extraAccountMeta of validateStateData) {
          executeInstruction.keys.push(deEscalateAccountMeta(yield (0, state_js_1.resolveExtraAccountMeta)(connection, extraAccountMeta, executeInstruction.keys, executeInstruction.data, executeInstruction.programId), executeInstruction.keys));
        }
        instruction.keys.push(...executeInstruction.keys.slice(5));
        instruction.keys.push({ pubkey: programId, isSigner: false, isWritable: false });
        instruction.keys.push({ pubkey: validateStatePubkey, isSigner: false, isWritable: false });
      });
    }
    function createTransferCheckedWithTransferHookInstruction(connection_1, source_1, mint_1, destination_1, owner_1, amount_1, decimals_1) {
      return __awaiter(this, arguments, void 0, function* (connection, source, mint, destination, owner, amount, decimals, multiSigners = [], commitment, programId = constants_js_1.TOKEN_PROGRAM_ID) {
        const instruction = (0, transferChecked_js_1.createTransferCheckedInstruction)(source, mint, destination, owner, amount, decimals, multiSigners, programId);
        const mintInfo = yield (0, mint_js_1.getMint)(connection, mint, commitment, programId);
        const transferHook = (0, state_js_1.getTransferHook)(mintInfo);
        if (transferHook) {
          yield addExtraAccountMetasForExecute(connection, instruction, transferHook.programId, source, mint, destination, owner, amount, commitment);
        }
        return instruction;
      });
    }
    function createTransferCheckedWithFeeAndTransferHookInstruction(connection_1, source_1, mint_1, destination_1, owner_1, amount_1, decimals_1, fee_1) {
      return __awaiter(this, arguments, void 0, function* (connection, source, mint, destination, owner, amount, decimals, fee, multiSigners = [], commitment, programId = constants_js_1.TOKEN_PROGRAM_ID) {
        const instruction = (0, instructions_js_1.createTransferCheckedWithFeeInstruction)(source, mint, destination, owner, amount, decimals, fee, multiSigners, programId);
        const mintInfo = yield (0, mint_js_1.getMint)(connection, mint, commitment, programId);
        const transferHook = (0, state_js_1.getTransferHook)(mintInfo);
        if (transferHook) {
          yield addExtraAccountMetasForExecute(connection, instruction, transferHook.programId, source, mint, destination, owner, amount, commitment);
        }
        return instruction;
      });
    }
  }
});

// node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/extensions/transferHook/actions.js
var require_actions8 = __commonJS({
  "node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/extensions/transferHook/actions.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.initializeTransferHook = initializeTransferHook;
    exports2.updateTransferHook = updateTransferHook;
    exports2.transferCheckedWithTransferHook = transferCheckedWithTransferHook;
    exports2.transferCheckedWithFeeAndTransferHook = transferCheckedWithFeeAndTransferHook;
    var web3_js_1 = require("@solana/web3.js");
    var internal_js_1 = require_internal();
    var constants_js_1 = require_constants();
    var instructions_js_1 = require_instructions7();
    function initializeTransferHook(connection_1, payer_1, mint_1, authority_1, transferHookProgramId_1, confirmOptions_1) {
      return __awaiter(this, arguments, void 0, function* (connection, payer, mint, authority, transferHookProgramId, confirmOptions, programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
        const transaction = new web3_js_1.Transaction().add((0, instructions_js_1.createInitializeTransferHookInstruction)(mint, authority, transferHookProgramId, programId));
        return yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer], confirmOptions);
      });
    }
    function updateTransferHook(connection_1, payer_1, mint_1, transferHookProgramId_1, authority_1) {
      return __awaiter(this, arguments, void 0, function* (connection, payer, mint, transferHookProgramId, authority, multiSigners = [], confirmOptions, programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
        const [authorityPublicKey, signers] = (0, internal_js_1.getSigners)(authority, multiSigners);
        const transaction = new web3_js_1.Transaction().add((0, instructions_js_1.createUpdateTransferHookInstruction)(mint, authorityPublicKey, transferHookProgramId, signers, programId));
        return yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer, ...signers], confirmOptions);
      });
    }
    function transferCheckedWithTransferHook(connection_1, payer_1, source_1, mint_1, destination_1, authority_1, amount_1, decimals_1) {
      return __awaiter(this, arguments, void 0, function* (connection, payer, source, mint, destination, authority, amount, decimals, multiSigners = [], confirmOptions, programId = constants_js_1.TOKEN_PROGRAM_ID) {
        const [authorityPublicKey, signers] = (0, internal_js_1.getSigners)(authority, multiSigners);
        const transaction = new web3_js_1.Transaction().add(yield (0, instructions_js_1.createTransferCheckedWithTransferHookInstruction)(connection, source, mint, destination, authorityPublicKey, amount, decimals, signers, confirmOptions === null || confirmOptions === void 0 ? void 0 : confirmOptions.commitment, programId));
        return yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer, ...signers], confirmOptions);
      });
    }
    function transferCheckedWithFeeAndTransferHook(connection_1, payer_1, source_1, mint_1, destination_1, authority_1, amount_1, decimals_1, fee_1) {
      return __awaiter(this, arguments, void 0, function* (connection, payer, source, mint, destination, authority, amount, decimals, fee, multiSigners = [], confirmOptions, programId = constants_js_1.TOKEN_PROGRAM_ID) {
        const [authorityPublicKey, signers] = (0, internal_js_1.getSigners)(authority, multiSigners);
        const transaction = new web3_js_1.Transaction().add(yield (0, instructions_js_1.createTransferCheckedWithFeeAndTransferHookInstruction)(connection, source, mint, destination, authorityPublicKey, amount, decimals, fee, signers, confirmOptions === null || confirmOptions === void 0 ? void 0 : confirmOptions.commitment, programId));
        return yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer, ...signers], confirmOptions);
      });
    }
  }
});

// node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/extensions/transferHook/index.js
var require_transferHook = __commonJS({
  "node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/extensions/transferHook/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_actions8(), exports2);
    __exportStar(require_instructions7(), exports2);
    __exportStar(require_seeds(), exports2);
    __exportStar(require_state14(), exports2);
    __exportStar(require_pubkeyData(), exports2);
  }
});

// node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/extensions/extensionType.js
var require_extensionType = __commonJS({
  "node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/extensions/extensionType.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LENGTH_SIZE = exports2.TYPE_SIZE = exports2.ExtensionType = void 0;
    exports2.getTypeLen = getTypeLen;
    exports2.isMintExtension = isMintExtension;
    exports2.isAccountExtension = isAccountExtension;
    exports2.getAccountTypeOfMintType = getAccountTypeOfMintType;
    exports2.getMintLen = getMintLen;
    exports2.getAccountLen = getAccountLen;
    exports2.getExtensionData = getExtensionData;
    exports2.getExtensionTypes = getExtensionTypes;
    exports2.getAccountLenForMint = getAccountLenForMint;
    exports2.getNewAccountLenForExtensionLen = getNewAccountLenForExtensionLen;
    var account_js_1 = require_account();
    var mint_js_1 = require_mint();
    var multisig_js_1 = require_multisig();
    var accountType_js_1 = require_accountType();
    var index_js_1 = require_cpiGuard();
    var index_js_2 = require_defaultAccountState();
    var index_js_3 = require_tokenGroup2();
    var state_js_1 = require_state6();
    var state_js_2 = require_state7();
    var immutableOwner_js_1 = require_immutableOwner();
    var state_js_3 = require_state8();
    var index_js_4 = require_memoTransfer();
    var state_js_4 = require_state10();
    var mintCloseAuthority_js_1 = require_mintCloseAuthority();
    var nonTransferable_js_1 = require_nonTransferable();
    var index_js_5 = require_pausable();
    var permanentDelegate_js_1 = require_permanentDelegate();
    var index_js_6 = require_scaledUiAmount();
    var index_js_7 = require_transferFee();
    var index_js_8 = require_transferHook();
    var constants_js_1 = require_constants();
    var ExtensionType;
    (function(ExtensionType2) {
      ExtensionType2[ExtensionType2["Uninitialized"] = 0] = "Uninitialized";
      ExtensionType2[ExtensionType2["TransferFeeConfig"] = 1] = "TransferFeeConfig";
      ExtensionType2[ExtensionType2["TransferFeeAmount"] = 2] = "TransferFeeAmount";
      ExtensionType2[ExtensionType2["MintCloseAuthority"] = 3] = "MintCloseAuthority";
      ExtensionType2[ExtensionType2["ConfidentialTransferMint"] = 4] = "ConfidentialTransferMint";
      ExtensionType2[ExtensionType2["ConfidentialTransferAccount"] = 5] = "ConfidentialTransferAccount";
      ExtensionType2[ExtensionType2["DefaultAccountState"] = 6] = "DefaultAccountState";
      ExtensionType2[ExtensionType2["ImmutableOwner"] = 7] = "ImmutableOwner";
      ExtensionType2[ExtensionType2["MemoTransfer"] = 8] = "MemoTransfer";
      ExtensionType2[ExtensionType2["NonTransferable"] = 9] = "NonTransferable";
      ExtensionType2[ExtensionType2["InterestBearingConfig"] = 10] = "InterestBearingConfig";
      ExtensionType2[ExtensionType2["CpiGuard"] = 11] = "CpiGuard";
      ExtensionType2[ExtensionType2["PermanentDelegate"] = 12] = "PermanentDelegate";
      ExtensionType2[ExtensionType2["NonTransferableAccount"] = 13] = "NonTransferableAccount";
      ExtensionType2[ExtensionType2["TransferHook"] = 14] = "TransferHook";
      ExtensionType2[ExtensionType2["TransferHookAccount"] = 15] = "TransferHookAccount";
      ExtensionType2[ExtensionType2["MetadataPointer"] = 18] = "MetadataPointer";
      ExtensionType2[ExtensionType2["TokenMetadata"] = 19] = "TokenMetadata";
      ExtensionType2[ExtensionType2["GroupPointer"] = 20] = "GroupPointer";
      ExtensionType2[ExtensionType2["TokenGroup"] = 21] = "TokenGroup";
      ExtensionType2[ExtensionType2["GroupMemberPointer"] = 22] = "GroupMemberPointer";
      ExtensionType2[ExtensionType2["TokenGroupMember"] = 23] = "TokenGroupMember";
      ExtensionType2[ExtensionType2["ScaledUiAmountConfig"] = 25] = "ScaledUiAmountConfig";
      ExtensionType2[ExtensionType2["PausableConfig"] = 26] = "PausableConfig";
      ExtensionType2[ExtensionType2["PausableAccount"] = 27] = "PausableAccount";
    })(ExtensionType || (exports2.ExtensionType = ExtensionType = {}));
    exports2.TYPE_SIZE = 2;
    exports2.LENGTH_SIZE = 2;
    function addTypeAndLengthToLen(len) {
      return len + exports2.TYPE_SIZE + exports2.LENGTH_SIZE;
    }
    function isVariableLengthExtension(e) {
      switch (e) {
        case ExtensionType.TokenMetadata:
          return true;
        default:
          return false;
      }
    }
    function getTypeLen(e) {
      switch (e) {
        case ExtensionType.Uninitialized:
          return 0;
        case ExtensionType.TransferFeeConfig:
          return index_js_7.TRANSFER_FEE_CONFIG_SIZE;
        case ExtensionType.TransferFeeAmount:
          return index_js_7.TRANSFER_FEE_AMOUNT_SIZE;
        case ExtensionType.MintCloseAuthority:
          return mintCloseAuthority_js_1.MINT_CLOSE_AUTHORITY_SIZE;
        case ExtensionType.ConfidentialTransferMint:
          return 65;
        case ExtensionType.ConfidentialTransferAccount:
          return 295;
        case ExtensionType.CpiGuard:
          return index_js_1.CPI_GUARD_SIZE;
        case ExtensionType.DefaultAccountState:
          return index_js_2.DEFAULT_ACCOUNT_STATE_SIZE;
        case ExtensionType.ImmutableOwner:
          return immutableOwner_js_1.IMMUTABLE_OWNER_SIZE;
        case ExtensionType.MemoTransfer:
          return index_js_4.MEMO_TRANSFER_SIZE;
        case ExtensionType.MetadataPointer:
          return state_js_4.METADATA_POINTER_SIZE;
        case ExtensionType.NonTransferable:
          return nonTransferable_js_1.NON_TRANSFERABLE_SIZE;
        case ExtensionType.InterestBearingConfig:
          return state_js_3.INTEREST_BEARING_MINT_CONFIG_STATE_SIZE;
        case ExtensionType.PermanentDelegate:
          return permanentDelegate_js_1.PERMANENT_DELEGATE_SIZE;
        case ExtensionType.NonTransferableAccount:
          return nonTransferable_js_1.NON_TRANSFERABLE_ACCOUNT_SIZE;
        case ExtensionType.TransferHook:
          return index_js_8.TRANSFER_HOOK_SIZE;
        case ExtensionType.TransferHookAccount:
          return index_js_8.TRANSFER_HOOK_ACCOUNT_SIZE;
        case ExtensionType.GroupPointer:
          return state_js_2.GROUP_POINTER_SIZE;
        case ExtensionType.GroupMemberPointer:
          return state_js_1.GROUP_MEMBER_POINTER_SIZE;
        case ExtensionType.TokenGroup:
          return index_js_3.TOKEN_GROUP_SIZE;
        case ExtensionType.TokenGroupMember:
          return index_js_3.TOKEN_GROUP_MEMBER_SIZE;
        case ExtensionType.ScaledUiAmountConfig:
          return index_js_6.SCALED_UI_AMOUNT_CONFIG_SIZE;
        case ExtensionType.PausableConfig:
          return index_js_5.PAUSABLE_CONFIG_SIZE;
        case ExtensionType.PausableAccount:
          return index_js_5.PAUSABLE_ACCOUNT_SIZE;
        case ExtensionType.TokenMetadata:
          throw Error(`Cannot get type length for variable extension type: ${e}`);
        default:
          throw Error(`Unknown extension type: ${e}`);
      }
    }
    function isMintExtension(e) {
      switch (e) {
        case ExtensionType.TransferFeeConfig:
        case ExtensionType.MintCloseAuthority:
        case ExtensionType.ConfidentialTransferMint:
        case ExtensionType.DefaultAccountState:
        case ExtensionType.NonTransferable:
        case ExtensionType.InterestBearingConfig:
        case ExtensionType.PermanentDelegate:
        case ExtensionType.TransferHook:
        case ExtensionType.MetadataPointer:
        case ExtensionType.TokenMetadata:
        case ExtensionType.GroupPointer:
        case ExtensionType.GroupMemberPointer:
        case ExtensionType.TokenGroup:
        case ExtensionType.TokenGroupMember:
        case ExtensionType.ScaledUiAmountConfig:
        case ExtensionType.PausableConfig:
          return true;
        case ExtensionType.Uninitialized:
        case ExtensionType.TransferFeeAmount:
        case ExtensionType.ConfidentialTransferAccount:
        case ExtensionType.ImmutableOwner:
        case ExtensionType.MemoTransfer:
        case ExtensionType.CpiGuard:
        case ExtensionType.NonTransferableAccount:
        case ExtensionType.TransferHookAccount:
        case ExtensionType.PausableAccount:
          return false;
        default:
          throw Error(`Unknown extension type: ${e}`);
      }
    }
    function isAccountExtension(e) {
      switch (e) {
        case ExtensionType.TransferFeeAmount:
        case ExtensionType.ConfidentialTransferAccount:
        case ExtensionType.ImmutableOwner:
        case ExtensionType.MemoTransfer:
        case ExtensionType.CpiGuard:
        case ExtensionType.NonTransferableAccount:
        case ExtensionType.TransferHookAccount:
        case ExtensionType.PausableAccount:
          return true;
        case ExtensionType.Uninitialized:
        case ExtensionType.TransferFeeConfig:
        case ExtensionType.MintCloseAuthority:
        case ExtensionType.ConfidentialTransferMint:
        case ExtensionType.DefaultAccountState:
        case ExtensionType.NonTransferable:
        case ExtensionType.InterestBearingConfig:
        case ExtensionType.PermanentDelegate:
        case ExtensionType.TransferHook:
        case ExtensionType.MetadataPointer:
        case ExtensionType.TokenMetadata:
        case ExtensionType.GroupPointer:
        case ExtensionType.GroupMemberPointer:
        case ExtensionType.TokenGroup:
        case ExtensionType.TokenGroupMember:
        case ExtensionType.ScaledUiAmountConfig:
        case ExtensionType.PausableConfig:
          return false;
        default:
          throw Error(`Unknown extension type: ${e}`);
      }
    }
    function getAccountTypeOfMintType(e) {
      switch (e) {
        case ExtensionType.TransferFeeConfig:
          return ExtensionType.TransferFeeAmount;
        case ExtensionType.ConfidentialTransferMint:
          return ExtensionType.ConfidentialTransferAccount;
        case ExtensionType.NonTransferable:
          return ExtensionType.NonTransferableAccount;
        case ExtensionType.TransferHook:
          return ExtensionType.TransferHookAccount;
        case ExtensionType.PausableConfig:
          return ExtensionType.PausableAccount;
        case ExtensionType.TransferFeeAmount:
        case ExtensionType.ConfidentialTransferAccount:
        case ExtensionType.CpiGuard:
        case ExtensionType.DefaultAccountState:
        case ExtensionType.ImmutableOwner:
        case ExtensionType.MemoTransfer:
        case ExtensionType.MintCloseAuthority:
        case ExtensionType.MetadataPointer:
        case ExtensionType.TokenMetadata:
        case ExtensionType.Uninitialized:
        case ExtensionType.InterestBearingConfig:
        case ExtensionType.PermanentDelegate:
        case ExtensionType.NonTransferableAccount:
        case ExtensionType.TransferHookAccount:
        case ExtensionType.GroupPointer:
        case ExtensionType.GroupMemberPointer:
        case ExtensionType.TokenGroup:
        case ExtensionType.TokenGroupMember:
        case ExtensionType.ScaledUiAmountConfig:
        case ExtensionType.PausableAccount:
          return ExtensionType.Uninitialized;
      }
    }
    function getLen(extensionTypes, baseSize, variableLengthExtensions = {}) {
      if (extensionTypes.length === 0 && Object.keys(variableLengthExtensions).length === 0) {
        return baseSize;
      } else {
        const accountLength = account_js_1.ACCOUNT_SIZE + accountType_js_1.ACCOUNT_TYPE_SIZE + extensionTypes.filter((element, i) => i === extensionTypes.indexOf(element)).map((element) => addTypeAndLengthToLen(getTypeLen(element))).reduce((a, b) => a + b, 0) + Object.entries(variableLengthExtensions).map(([extension, len]) => {
          if (!isVariableLengthExtension(Number(extension))) {
            throw Error(`Extension ${extension} is not variable length`);
          }
          return addTypeAndLengthToLen(len);
        }).reduce((a, b) => a + b, 0);
        if (accountLength === multisig_js_1.MULTISIG_SIZE) {
          return accountLength + exports2.TYPE_SIZE;
        } else {
          return accountLength;
        }
      }
    }
    function getMintLen(extensionTypes, variableLengthExtensions = {}) {
      return getLen(extensionTypes, mint_js_1.MINT_SIZE, variableLengthExtensions);
    }
    function getAccountLen(extensionTypes) {
      return getLen(extensionTypes, account_js_1.ACCOUNT_SIZE);
    }
    function getExtensionData(extension, tlvData) {
      let extensionTypeIndex = 0;
      while (addTypeAndLengthToLen(extensionTypeIndex) <= tlvData.length) {
        const entryType = tlvData.readUInt16LE(extensionTypeIndex);
        const entryLength = tlvData.readUInt16LE(extensionTypeIndex + exports2.TYPE_SIZE);
        const typeIndex = addTypeAndLengthToLen(extensionTypeIndex);
        if (entryType == extension) {
          return tlvData.slice(typeIndex, typeIndex + entryLength);
        }
        extensionTypeIndex = typeIndex + entryLength;
      }
      return null;
    }
    function getExtensionTypes(tlvData) {
      const extensionTypes = [];
      let extensionTypeIndex = 0;
      while (extensionTypeIndex < tlvData.length) {
        const entryType = tlvData.readUInt16LE(extensionTypeIndex);
        extensionTypes.push(entryType);
        const entryLength = tlvData.readUInt16LE(extensionTypeIndex + exports2.TYPE_SIZE);
        extensionTypeIndex += addTypeAndLengthToLen(entryLength);
      }
      return extensionTypes;
    }
    function getAccountLenForMint(mint) {
      const extensionTypes = getExtensionTypes(mint.tlvData);
      const accountExtensions = extensionTypes.map(getAccountTypeOfMintType);
      return getAccountLen(accountExtensions);
    }
    function getNewAccountLenForExtensionLen(info, address, extensionType, extensionLen, programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
      const mint = (0, mint_js_1.unpackMint)(address, info, programId);
      const extensionData = getExtensionData(extensionType, mint.tlvData);
      const currentExtensionLen = extensionData ? addTypeAndLengthToLen(extensionData.length) : 0;
      const newExtensionLen = addTypeAndLengthToLen(extensionLen);
      return info.data.length + newExtensionLen - currentExtensionLen;
    }
  }
});

// node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/state/mint.js
var require_mint = __commonJS({
  "node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/state/mint.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MINT_SIZE = exports2.MintLayout = void 0;
    exports2.getMint = getMint;
    exports2.unpackMint = unpackMint;
    exports2.getMinimumBalanceForRentExemptMint = getMinimumBalanceForRentExemptMint;
    exports2.getMinimumBalanceForRentExemptMintWithExtensions = getMinimumBalanceForRentExemptMintWithExtensions;
    exports2.getAssociatedTokenAddress = getAssociatedTokenAddress;
    exports2.getAssociatedTokenAddressSync = getAssociatedTokenAddressSync;
    var buffer_layout_1 = require_Layout();
    var buffer_layout_utils_1 = require_cjs();
    var web3_js_1 = require("@solana/web3.js");
    var constants_js_1 = require_constants();
    var errors_js_1 = require_errors();
    var accountType_js_1 = require_accountType();
    var extensionType_js_1 = require_extensionType();
    var account_js_1 = require_account();
    var multisig_js_1 = require_multisig();
    exports2.MintLayout = (0, buffer_layout_1.struct)([
      (0, buffer_layout_1.u32)("mintAuthorityOption"),
      (0, buffer_layout_utils_1.publicKey)("mintAuthority"),
      (0, buffer_layout_utils_1.u64)("supply"),
      (0, buffer_layout_1.u8)("decimals"),
      (0, buffer_layout_utils_1.bool)("isInitialized"),
      (0, buffer_layout_1.u32)("freezeAuthorityOption"),
      (0, buffer_layout_utils_1.publicKey)("freezeAuthority")
    ]);
    exports2.MINT_SIZE = exports2.MintLayout.span;
    function getMint(connection_1, address_1, commitment_1) {
      return __awaiter(this, arguments, void 0, function* (connection, address, commitment, programId = constants_js_1.TOKEN_PROGRAM_ID) {
        const info = yield connection.getAccountInfo(address, commitment);
        return unpackMint(address, info, programId);
      });
    }
    function unpackMint(address, info, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      if (!info)
        throw new errors_js_1.TokenAccountNotFoundError();
      if (!info.owner.equals(programId))
        throw new errors_js_1.TokenInvalidAccountOwnerError();
      if (info.data.length < exports2.MINT_SIZE)
        throw new errors_js_1.TokenInvalidAccountSizeError();
      const rawMint = exports2.MintLayout.decode(info.data.slice(0, exports2.MINT_SIZE));
      let tlvData = Buffer.alloc(0);
      if (info.data.length > exports2.MINT_SIZE) {
        if (info.data.length <= account_js_1.ACCOUNT_SIZE)
          throw new errors_js_1.TokenInvalidAccountSizeError();
        if (info.data.length === multisig_js_1.MULTISIG_SIZE)
          throw new errors_js_1.TokenInvalidAccountSizeError();
        if (info.data[account_js_1.ACCOUNT_SIZE] != accountType_js_1.AccountType.Mint)
          throw new errors_js_1.TokenInvalidMintError();
        tlvData = info.data.slice(account_js_1.ACCOUNT_SIZE + accountType_js_1.ACCOUNT_TYPE_SIZE);
      }
      return {
        address,
        mintAuthority: rawMint.mintAuthorityOption ? rawMint.mintAuthority : null,
        supply: rawMint.supply,
        decimals: rawMint.decimals,
        isInitialized: rawMint.isInitialized,
        freezeAuthority: rawMint.freezeAuthorityOption ? rawMint.freezeAuthority : null,
        tlvData
      };
    }
    function getMinimumBalanceForRentExemptMint(connection, commitment) {
      return __awaiter(this, void 0, void 0, function* () {
        return yield getMinimumBalanceForRentExemptMintWithExtensions(connection, [], commitment);
      });
    }
    function getMinimumBalanceForRentExemptMintWithExtensions(connection, extensions, commitment) {
      return __awaiter(this, void 0, void 0, function* () {
        const mintLen = (0, extensionType_js_1.getMintLen)(extensions);
        return yield connection.getMinimumBalanceForRentExemption(mintLen, commitment);
      });
    }
    function getAssociatedTokenAddress(mint_1, owner_1) {
      return __awaiter(this, arguments, void 0, function* (mint, owner, allowOwnerOffCurve = false, programId = constants_js_1.TOKEN_PROGRAM_ID, associatedTokenProgramId = constants_js_1.ASSOCIATED_TOKEN_PROGRAM_ID) {
        if (!allowOwnerOffCurve && !web3_js_1.PublicKey.isOnCurve(owner.toBuffer()))
          throw new errors_js_1.TokenOwnerOffCurveError();
        const [address] = yield web3_js_1.PublicKey.findProgramAddress([owner.toBuffer(), programId.toBuffer(), mint.toBuffer()], associatedTokenProgramId);
        return address;
      });
    }
    function getAssociatedTokenAddressSync(mint, owner, allowOwnerOffCurve = false, programId = constants_js_1.TOKEN_PROGRAM_ID, associatedTokenProgramId = constants_js_1.ASSOCIATED_TOKEN_PROGRAM_ID) {
      if (!allowOwnerOffCurve && !web3_js_1.PublicKey.isOnCurve(owner.toBuffer()))
        throw new errors_js_1.TokenOwnerOffCurveError();
      const [address] = web3_js_1.PublicKey.findProgramAddressSync([owner.toBuffer(), programId.toBuffer(), mint.toBuffer()], associatedTokenProgramId);
      return address;
    }
  }
});

// node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/actions/amountToUiAmount.js
var require_amountToUiAmount2 = __commonJS({
  "node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/actions/amountToUiAmount.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.amountToUiAmount = amountToUiAmount;
    exports2.amountToUiAmountForInterestBearingMintWithoutSimulation = amountToUiAmountForInterestBearingMintWithoutSimulation;
    exports2.amountToUiAmountForScaledUiAmountMintWithoutSimulation = amountToUiAmountForScaledUiAmountMintWithoutSimulation;
    exports2.amountToUiAmountForMintWithoutSimulation = amountToUiAmountForMintWithoutSimulation;
    exports2.uiAmountToAmountForInterestBearingMintWithoutSimulation = uiAmountToAmountForInterestBearingMintWithoutSimulation;
    exports2.uiAmountToAmountForScaledUiAmountMintWithoutSimulation = uiAmountToAmountForScaledUiAmountMintWithoutSimulation;
    exports2.uiAmountToAmountForMintWithoutSimulation = uiAmountToAmountForMintWithoutSimulation;
    var web3_js_1 = require("@solana/web3.js");
    var constants_js_1 = require_constants();
    var amountToUiAmount_js_1 = require_amountToUiAmount();
    var mint_js_1 = require_mint();
    var state_js_1 = require_state8();
    var state_js_2 = require_state12();
    var ONE_IN_BASIS_POINTS = 1e4;
    var SECONDS_PER_YEAR = 60 * 60 * 24 * 365.24;
    var SYSVAR_CLOCK_PUBKEY2 = new web3_js_1.PublicKey("SysvarC1ock11111111111111111111111111111111");
    function amountToUiAmount(connection_1, payer_1, mint_1, amount_1) {
      return __awaiter(this, arguments, void 0, function* (connection, payer, mint, amount, programId = constants_js_1.TOKEN_PROGRAM_ID) {
        const transaction = new web3_js_1.Transaction().add((0, amountToUiAmount_js_1.createAmountToUiAmountInstruction)(mint, amount, programId));
        const { returnData, err } = (yield connection.simulateTransaction(transaction, [payer], false)).value;
        if (returnData === null || returnData === void 0 ? void 0 : returnData.data) {
          return Buffer.from(returnData.data[0], returnData.data[1]).toString("utf-8");
        }
        return err;
      });
    }
    function calculateExponentForTimesAndRate(t1, t2, r) {
      const timespan = t2 - t1;
      const numerator = r * timespan;
      const exponent = numerator / (SECONDS_PER_YEAR * ONE_IN_BASIS_POINTS);
      return Math.exp(exponent);
    }
    function getSysvarClockTimestamp(connection) {
      return __awaiter(this, void 0, void 0, function* () {
        const info = yield connection.getParsedAccountInfo(SYSVAR_CLOCK_PUBKEY2);
        if (!(info === null || info === void 0 ? void 0 : info.value)) {
          throw new Error("Failed to fetch sysvar clock");
        }
        if (typeof info.value === "object" && "data" in info.value && "parsed" in info.value.data) {
          return info.value.data.parsed.info.unixTimestamp;
        }
        throw new Error("Failed to parse sysvar clock");
      });
    }
    function getDecimalFactor(decimals) {
      return Math.pow(10, decimals);
    }
    function uiAmountToAtomicUiAmount(uiAmount, decimals) {
      const uiAmountNumber = parseFloat(uiAmount);
      const decimalFactor = getDecimalFactor(decimals);
      return uiAmountNumber * decimalFactor;
    }
    function amountToUiAmountForInterestBearingMintWithoutSimulation(amount, decimals, currentTimestamp, lastUpdateTimestamp, initializationTimestamp, preUpdateAverageRate, currentRate) {
      const preUpdateExp = calculateExponentForTimesAndRate(initializationTimestamp, lastUpdateTimestamp, preUpdateAverageRate);
      const postUpdateExp = calculateExponentForTimesAndRate(lastUpdateTimestamp, currentTimestamp, currentRate);
      const totalScale = preUpdateExp * postUpdateExp;
      const scaledAmount = Number(amount) * totalScale;
      const decimalFactor = getDecimalFactor(decimals);
      return (Math.trunc(scaledAmount) / decimalFactor).toString();
    }
    function amountToUiAmountForScaledUiAmountMintWithoutSimulation(amount, decimals, multiplier) {
      const scaledAmount = Number(amount) * multiplier;
      const decimalFactor = getDecimalFactor(decimals);
      return (Math.trunc(scaledAmount) / decimalFactor).toString();
    }
    function amountToUiAmountForMintWithoutSimulation(connection, mint, amount) {
      return __awaiter(this, void 0, void 0, function* () {
        const accountInfo = yield connection.getAccountInfo(mint);
        const programId = accountInfo === null || accountInfo === void 0 ? void 0 : accountInfo.owner;
        if (!(programId === null || programId === void 0 ? void 0 : programId.equals(constants_js_1.TOKEN_PROGRAM_ID)) && !(programId === null || programId === void 0 ? void 0 : programId.equals(constants_js_1.TOKEN_2022_PROGRAM_ID))) {
          throw new Error("Invalid program ID");
        }
        const mintInfo = (0, mint_js_1.unpackMint)(mint, accountInfo, programId);
        const interestBearingMintConfigState = (0, state_js_1.getInterestBearingMintConfigState)(mintInfo);
        const scaledUiAmountConfig = (0, state_js_2.getScaledUiAmountConfig)(mintInfo);
        if (!interestBearingMintConfigState && !scaledUiAmountConfig) {
          const decimalFactor = getDecimalFactor(mintInfo.decimals);
          return (Number(amount) / decimalFactor).toString();
        }
        const timestamp = yield getSysvarClockTimestamp(connection);
        if (interestBearingMintConfigState) {
          return amountToUiAmountForInterestBearingMintWithoutSimulation(amount, mintInfo.decimals, timestamp, Number(interestBearingMintConfigState.lastUpdateTimestamp), Number(interestBearingMintConfigState.initializationTimestamp), interestBearingMintConfigState.preUpdateAverageRate, interestBearingMintConfigState.currentRate);
        }
        let multiplier = scaledUiAmountConfig.multiplier;
        if (timestamp >= Number(scaledUiAmountConfig.newMultiplierEffectiveTimestamp)) {
          multiplier = scaledUiAmountConfig.newMultiplier;
        }
        return amountToUiAmountForScaledUiAmountMintWithoutSimulation(amount, mintInfo.decimals, multiplier);
      });
    }
    function uiAmountToAmountForInterestBearingMintWithoutSimulation(uiAmount, decimals, currentTimestamp, lastUpdateTimestamp, initializationTimestamp, preUpdateAverageRate, currentRate) {
      const uiAmountScaled = uiAmountToAtomicUiAmount(uiAmount, decimals);
      const preUpdateExp = calculateExponentForTimesAndRate(initializationTimestamp, lastUpdateTimestamp, preUpdateAverageRate);
      const postUpdateExp = calculateExponentForTimesAndRate(lastUpdateTimestamp, currentTimestamp, currentRate);
      const totalScale = preUpdateExp * postUpdateExp;
      const originalPrincipal = uiAmountScaled / totalScale;
      return BigInt(Math.trunc(originalPrincipal));
    }
    function uiAmountToAmountForScaledUiAmountMintWithoutSimulation(uiAmount, decimals, multiplier) {
      const uiAmountScaled = uiAmountToAtomicUiAmount(uiAmount, decimals);
      const rawAmount = uiAmountScaled / multiplier;
      return BigInt(Math.trunc(rawAmount));
    }
    function uiAmountToAmountForMintWithoutSimulation(connection, mint, uiAmount) {
      return __awaiter(this, void 0, void 0, function* () {
        const accountInfo = yield connection.getAccountInfo(mint);
        const programId = accountInfo === null || accountInfo === void 0 ? void 0 : accountInfo.owner;
        if (!(programId === null || programId === void 0 ? void 0 : programId.equals(constants_js_1.TOKEN_PROGRAM_ID)) && !(programId === null || programId === void 0 ? void 0 : programId.equals(constants_js_1.TOKEN_2022_PROGRAM_ID))) {
          throw new Error("Invalid program ID");
        }
        const mintInfo = (0, mint_js_1.unpackMint)(mint, accountInfo, programId);
        const interestBearingMintConfigState = (0, state_js_1.getInterestBearingMintConfigState)(mintInfo);
        const scaledUiAmountConfig = (0, state_js_2.getScaledUiAmountConfig)(mintInfo);
        if (!interestBearingMintConfigState && !scaledUiAmountConfig) {
          return BigInt(Math.trunc(uiAmountToAtomicUiAmount(uiAmount, mintInfo.decimals)));
        }
        const timestamp = yield getSysvarClockTimestamp(connection);
        if (interestBearingMintConfigState) {
          return uiAmountToAmountForInterestBearingMintWithoutSimulation(uiAmount, mintInfo.decimals, timestamp, Number(interestBearingMintConfigState.lastUpdateTimestamp), Number(interestBearingMintConfigState.initializationTimestamp), interestBearingMintConfigState.preUpdateAverageRate, interestBearingMintConfigState.currentRate);
        }
        let multiplier = scaledUiAmountConfig.multiplier;
        if (timestamp >= Number(scaledUiAmountConfig.newMultiplierEffectiveTimestamp)) {
          multiplier = scaledUiAmountConfig.newMultiplier;
        }
        return uiAmountToAmountForScaledUiAmountMintWithoutSimulation(uiAmount, mintInfo.decimals, multiplier);
      });
    }
  }
});

// node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/instructions/approve.js
var require_approve = __commonJS({
  "node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/instructions/approve.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.approveInstructionData = void 0;
    exports2.createApproveInstruction = createApproveInstruction;
    exports2.decodeApproveInstruction = decodeApproveInstruction;
    exports2.decodeApproveInstructionUnchecked = decodeApproveInstructionUnchecked;
    var buffer_layout_1 = require_Layout();
    var buffer_layout_utils_1 = require_cjs();
    var web3_js_1 = require("@solana/web3.js");
    var constants_js_1 = require_constants();
    var errors_js_1 = require_errors();
    var internal_js_1 = require_internal2();
    var types_js_1 = require_types();
    exports2.approveInstructionData = (0, buffer_layout_1.struct)([(0, buffer_layout_1.u8)("instruction"), (0, buffer_layout_utils_1.u64)("amount")]);
    function createApproveInstruction(account, delegate, owner, amount, multiSigners = [], programId = constants_js_1.TOKEN_PROGRAM_ID) {
      const keys = (0, internal_js_1.addSigners)([
        { pubkey: account, isSigner: false, isWritable: true },
        { pubkey: delegate, isSigner: false, isWritable: false }
      ], owner, multiSigners);
      const data = Buffer.alloc(exports2.approveInstructionData.span);
      exports2.approveInstructionData.encode({
        instruction: types_js_1.TokenInstruction.Approve,
        amount: BigInt(amount)
      }, data);
      return new web3_js_1.TransactionInstruction({ keys, programId, data });
    }
    function decodeApproveInstruction(instruction, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      if (!instruction.programId.equals(programId))
        throw new errors_js_1.TokenInvalidInstructionProgramError();
      if (instruction.data.length !== exports2.approveInstructionData.span)
        throw new errors_js_1.TokenInvalidInstructionDataError();
      const { keys: { account, delegate, owner, multiSigners }, data } = decodeApproveInstructionUnchecked(instruction);
      if (data.instruction !== types_js_1.TokenInstruction.Approve)
        throw new errors_js_1.TokenInvalidInstructionTypeError();
      if (!account || !delegate || !owner)
        throw new errors_js_1.TokenInvalidInstructionKeysError();
      return {
        programId,
        keys: {
          account,
          delegate,
          owner,
          multiSigners
        },
        data
      };
    }
    function decodeApproveInstructionUnchecked({ programId, keys: [account, delegate, owner, ...multiSigners], data }) {
      return {
        programId,
        keys: {
          account,
          delegate,
          owner,
          multiSigners
        },
        data: exports2.approveInstructionData.decode(data)
      };
    }
  }
});

// node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/actions/approve.js
var require_approve2 = __commonJS({
  "node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/actions/approve.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.approve = approve;
    var web3_js_1 = require("@solana/web3.js");
    var constants_js_1 = require_constants();
    var approve_js_1 = require_approve();
    var internal_js_1 = require_internal();
    function approve(connection_1, payer_1, account_1, delegate_1, owner_1, amount_1) {
      return __awaiter(this, arguments, void 0, function* (connection, payer, account, delegate, owner, amount, multiSigners = [], confirmOptions, programId = constants_js_1.TOKEN_PROGRAM_ID) {
        const [ownerPublicKey, signers] = (0, internal_js_1.getSigners)(owner, multiSigners);
        const transaction = new web3_js_1.Transaction().add((0, approve_js_1.createApproveInstruction)(account, delegate, ownerPublicKey, amount, multiSigners, programId));
        return yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer, ...signers], confirmOptions);
      });
    }
  }
});

// node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/instructions/approveChecked.js
var require_approveChecked = __commonJS({
  "node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/instructions/approveChecked.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.approveCheckedInstructionData = void 0;
    exports2.createApproveCheckedInstruction = createApproveCheckedInstruction;
    exports2.decodeApproveCheckedInstruction = decodeApproveCheckedInstruction;
    exports2.decodeApproveCheckedInstructionUnchecked = decodeApproveCheckedInstructionUnchecked;
    var buffer_layout_1 = require_Layout();
    var buffer_layout_utils_1 = require_cjs();
    var web3_js_1 = require("@solana/web3.js");
    var constants_js_1 = require_constants();
    var errors_js_1 = require_errors();
    var internal_js_1 = require_internal2();
    var types_js_1 = require_types();
    exports2.approveCheckedInstructionData = (0, buffer_layout_1.struct)([
      (0, buffer_layout_1.u8)("instruction"),
      (0, buffer_layout_utils_1.u64)("amount"),
      (0, buffer_layout_1.u8)("decimals")
    ]);
    function createApproveCheckedInstruction(account, mint, delegate, owner, amount, decimals, multiSigners = [], programId = constants_js_1.TOKEN_PROGRAM_ID) {
      const keys = (0, internal_js_1.addSigners)([
        { pubkey: account, isSigner: false, isWritable: true },
        { pubkey: mint, isSigner: false, isWritable: false },
        { pubkey: delegate, isSigner: false, isWritable: false }
      ], owner, multiSigners);
      const data = Buffer.alloc(exports2.approveCheckedInstructionData.span);
      exports2.approveCheckedInstructionData.encode({
        instruction: types_js_1.TokenInstruction.ApproveChecked,
        amount: BigInt(amount),
        decimals
      }, data);
      return new web3_js_1.TransactionInstruction({ keys, programId, data });
    }
    function decodeApproveCheckedInstruction(instruction, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      if (!instruction.programId.equals(programId))
        throw new errors_js_1.TokenInvalidInstructionProgramError();
      if (instruction.data.length !== exports2.approveCheckedInstructionData.span)
        throw new errors_js_1.TokenInvalidInstructionDataError();
      const { keys: { account, mint, delegate, owner, multiSigners }, data } = decodeApproveCheckedInstructionUnchecked(instruction);
      if (data.instruction !== types_js_1.TokenInstruction.ApproveChecked)
        throw new errors_js_1.TokenInvalidInstructionTypeError();
      if (!account || !mint || !delegate || !owner)
        throw new errors_js_1.TokenInvalidInstructionKeysError();
      return {
        programId,
        keys: {
          account,
          mint,
          delegate,
          owner,
          multiSigners
        },
        data
      };
    }
    function decodeApproveCheckedInstructionUnchecked({ programId, keys: [account, mint, delegate, owner, ...multiSigners], data }) {
      return {
        programId,
        keys: {
          account,
          mint,
          delegate,
          owner,
          multiSigners
        },
        data: exports2.approveCheckedInstructionData.decode(data)
      };
    }
  }
});

// node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/actions/approveChecked.js
var require_approveChecked2 = __commonJS({
  "node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/actions/approveChecked.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.approveChecked = approveChecked;
    var web3_js_1 = require("@solana/web3.js");
    var constants_js_1 = require_constants();
    var approveChecked_js_1 = require_approveChecked();
    var internal_js_1 = require_internal();
    function approveChecked(connection_1, payer_1, mint_1, account_1, delegate_1, owner_1, amount_1, decimals_1) {
      return __awaiter(this, arguments, void 0, function* (connection, payer, mint, account, delegate, owner, amount, decimals, multiSigners = [], confirmOptions, programId = constants_js_1.TOKEN_PROGRAM_ID) {
        const [ownerPublicKey, signers] = (0, internal_js_1.getSigners)(owner, multiSigners);
        const transaction = new web3_js_1.Transaction().add((0, approveChecked_js_1.createApproveCheckedInstruction)(account, mint, delegate, ownerPublicKey, amount, decimals, multiSigners, programId));
        return yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer, ...signers], confirmOptions);
      });
    }
  }
});

// node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/instructions/burn.js
var require_burn = __commonJS({
  "node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/instructions/burn.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.burnInstructionData = void 0;
    exports2.createBurnInstruction = createBurnInstruction;
    exports2.decodeBurnInstruction = decodeBurnInstruction;
    exports2.decodeBurnInstructionUnchecked = decodeBurnInstructionUnchecked;
    var buffer_layout_1 = require_Layout();
    var buffer_layout_utils_1 = require_cjs();
    var web3_js_1 = require("@solana/web3.js");
    var constants_js_1 = require_constants();
    var errors_js_1 = require_errors();
    var internal_js_1 = require_internal2();
    var types_js_1 = require_types();
    exports2.burnInstructionData = (0, buffer_layout_1.struct)([(0, buffer_layout_1.u8)("instruction"), (0, buffer_layout_utils_1.u64)("amount")]);
    function createBurnInstruction(account, mint, owner, amount, multiSigners = [], programId = constants_js_1.TOKEN_PROGRAM_ID) {
      const keys = (0, internal_js_1.addSigners)([
        { pubkey: account, isSigner: false, isWritable: true },
        { pubkey: mint, isSigner: false, isWritable: true }
      ], owner, multiSigners);
      const data = Buffer.alloc(exports2.burnInstructionData.span);
      exports2.burnInstructionData.encode({
        instruction: types_js_1.TokenInstruction.Burn,
        amount: BigInt(amount)
      }, data);
      return new web3_js_1.TransactionInstruction({ keys, programId, data });
    }
    function decodeBurnInstruction(instruction, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      if (!instruction.programId.equals(programId))
        throw new errors_js_1.TokenInvalidInstructionProgramError();
      if (instruction.data.length !== exports2.burnInstructionData.span)
        throw new errors_js_1.TokenInvalidInstructionDataError();
      const { keys: { account, mint, owner, multiSigners }, data } = decodeBurnInstructionUnchecked(instruction);
      if (data.instruction !== types_js_1.TokenInstruction.Burn)
        throw new errors_js_1.TokenInvalidInstructionTypeError();
      if (!account || !mint || !owner)
        throw new errors_js_1.TokenInvalidInstructionKeysError();
      return {
        programId,
        keys: {
          account,
          mint,
          owner,
          multiSigners
        },
        data
      };
    }
    function decodeBurnInstructionUnchecked({ programId, keys: [account, mint, owner, ...multiSigners], data }) {
      return {
        programId,
        keys: {
          account,
          mint,
          owner,
          multiSigners
        },
        data: exports2.burnInstructionData.decode(data)
      };
    }
  }
});

// node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/actions/burn.js
var require_burn2 = __commonJS({
  "node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/actions/burn.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.burn = burn;
    var web3_js_1 = require("@solana/web3.js");
    var constants_js_1 = require_constants();
    var burn_js_1 = require_burn();
    var internal_js_1 = require_internal();
    function burn(connection_1, payer_1, account_1, mint_1, owner_1, amount_1) {
      return __awaiter(this, arguments, void 0, function* (connection, payer, account, mint, owner, amount, multiSigners = [], confirmOptions, programId = constants_js_1.TOKEN_PROGRAM_ID) {
        const [ownerPublicKey, signers] = (0, internal_js_1.getSigners)(owner, multiSigners);
        const transaction = new web3_js_1.Transaction().add((0, burn_js_1.createBurnInstruction)(account, mint, ownerPublicKey, amount, multiSigners, programId));
        return yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer, ...signers], confirmOptions);
      });
    }
  }
});

// node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/instructions/burnChecked.js
var require_burnChecked = __commonJS({
  "node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/instructions/burnChecked.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.burnCheckedInstructionData = void 0;
    exports2.createBurnCheckedInstruction = createBurnCheckedInstruction;
    exports2.decodeBurnCheckedInstruction = decodeBurnCheckedInstruction;
    exports2.decodeBurnCheckedInstructionUnchecked = decodeBurnCheckedInstructionUnchecked;
    var buffer_layout_1 = require_Layout();
    var buffer_layout_utils_1 = require_cjs();
    var web3_js_1 = require("@solana/web3.js");
    var constants_js_1 = require_constants();
    var errors_js_1 = require_errors();
    var internal_js_1 = require_internal2();
    var types_js_1 = require_types();
    exports2.burnCheckedInstructionData = (0, buffer_layout_1.struct)([
      (0, buffer_layout_1.u8)("instruction"),
      (0, buffer_layout_utils_1.u64)("amount"),
      (0, buffer_layout_1.u8)("decimals")
    ]);
    function createBurnCheckedInstruction(account, mint, owner, amount, decimals, multiSigners = [], programId = constants_js_1.TOKEN_PROGRAM_ID) {
      const keys = (0, internal_js_1.addSigners)([
        { pubkey: account, isSigner: false, isWritable: true },
        { pubkey: mint, isSigner: false, isWritable: true }
      ], owner, multiSigners);
      const data = Buffer.alloc(exports2.burnCheckedInstructionData.span);
      exports2.burnCheckedInstructionData.encode({
        instruction: types_js_1.TokenInstruction.BurnChecked,
        amount: BigInt(amount),
        decimals
      }, data);
      return new web3_js_1.TransactionInstruction({ keys, programId, data });
    }
    function decodeBurnCheckedInstruction(instruction, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      if (!instruction.programId.equals(programId))
        throw new errors_js_1.TokenInvalidInstructionProgramError();
      if (instruction.data.length !== exports2.burnCheckedInstructionData.span)
        throw new errors_js_1.TokenInvalidInstructionDataError();
      const { keys: { account, mint, owner, multiSigners }, data } = decodeBurnCheckedInstructionUnchecked(instruction);
      if (data.instruction !== types_js_1.TokenInstruction.BurnChecked)
        throw new errors_js_1.TokenInvalidInstructionTypeError();
      if (!account || !mint || !owner)
        throw new errors_js_1.TokenInvalidInstructionKeysError();
      return {
        programId,
        keys: {
          account,
          mint,
          owner,
          multiSigners
        },
        data
      };
    }
    function decodeBurnCheckedInstructionUnchecked({ programId, keys: [account, mint, owner, ...multiSigners], data }) {
      return {
        programId,
        keys: {
          account,
          mint,
          owner,
          multiSigners
        },
        data: exports2.burnCheckedInstructionData.decode(data)
      };
    }
  }
});

// node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/actions/burnChecked.js
var require_burnChecked2 = __commonJS({
  "node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/actions/burnChecked.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.burnChecked = burnChecked;
    var web3_js_1 = require("@solana/web3.js");
    var constants_js_1 = require_constants();
    var burnChecked_js_1 = require_burnChecked();
    var internal_js_1 = require_internal();
    function burnChecked(connection_1, payer_1, account_1, mint_1, owner_1, amount_1, decimals_1) {
      return __awaiter(this, arguments, void 0, function* (connection, payer, account, mint, owner, amount, decimals, multiSigners = [], confirmOptions, programId = constants_js_1.TOKEN_PROGRAM_ID) {
        const [ownerPublicKey, signers] = (0, internal_js_1.getSigners)(owner, multiSigners);
        const transaction = new web3_js_1.Transaction().add((0, burnChecked_js_1.createBurnCheckedInstruction)(account, mint, ownerPublicKey, amount, decimals, multiSigners, programId));
        return yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer, ...signers], confirmOptions);
      });
    }
  }
});

// node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/instructions/closeAccount.js
var require_closeAccount = __commonJS({
  "node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/instructions/closeAccount.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.closeAccountInstructionData = void 0;
    exports2.createCloseAccountInstruction = createCloseAccountInstruction;
    exports2.decodeCloseAccountInstruction = decodeCloseAccountInstruction;
    exports2.decodeCloseAccountInstructionUnchecked = decodeCloseAccountInstructionUnchecked;
    var buffer_layout_1 = require_Layout();
    var web3_js_1 = require("@solana/web3.js");
    var constants_js_1 = require_constants();
    var errors_js_1 = require_errors();
    var internal_js_1 = require_internal2();
    var types_js_1 = require_types();
    exports2.closeAccountInstructionData = (0, buffer_layout_1.struct)([(0, buffer_layout_1.u8)("instruction")]);
    function createCloseAccountInstruction(account, destination, authority, multiSigners = [], programId = constants_js_1.TOKEN_PROGRAM_ID) {
      const keys = (0, internal_js_1.addSigners)([
        { pubkey: account, isSigner: false, isWritable: true },
        { pubkey: destination, isSigner: false, isWritable: true }
      ], authority, multiSigners);
      const data = Buffer.alloc(exports2.closeAccountInstructionData.span);
      exports2.closeAccountInstructionData.encode({ instruction: types_js_1.TokenInstruction.CloseAccount }, data);
      return new web3_js_1.TransactionInstruction({ keys, programId, data });
    }
    function decodeCloseAccountInstruction(instruction, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      if (!instruction.programId.equals(programId))
        throw new errors_js_1.TokenInvalidInstructionProgramError();
      if (instruction.data.length !== exports2.closeAccountInstructionData.span)
        throw new errors_js_1.TokenInvalidInstructionDataError();
      const { keys: { account, destination, authority, multiSigners }, data } = decodeCloseAccountInstructionUnchecked(instruction);
      if (data.instruction !== types_js_1.TokenInstruction.CloseAccount)
        throw new errors_js_1.TokenInvalidInstructionTypeError();
      if (!account || !destination || !authority)
        throw new errors_js_1.TokenInvalidInstructionKeysError();
      return {
        programId,
        keys: {
          account,
          destination,
          authority,
          multiSigners
        },
        data
      };
    }
    function decodeCloseAccountInstructionUnchecked({ programId, keys: [account, destination, authority, ...multiSigners], data }) {
      return {
        programId,
        keys: {
          account,
          destination,
          authority,
          multiSigners
        },
        data: exports2.closeAccountInstructionData.decode(data)
      };
    }
  }
});

// node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/actions/closeAccount.js
var require_closeAccount2 = __commonJS({
  "node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/actions/closeAccount.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.closeAccount = closeAccount;
    var web3_js_1 = require("@solana/web3.js");
    var constants_js_1 = require_constants();
    var closeAccount_js_1 = require_closeAccount();
    var internal_js_1 = require_internal();
    function closeAccount(connection_1, payer_1, account_1, destination_1, authority_1) {
      return __awaiter(this, arguments, void 0, function* (connection, payer, account, destination, authority, multiSigners = [], confirmOptions, programId = constants_js_1.TOKEN_PROGRAM_ID) {
        const [authorityPublicKey, signers] = (0, internal_js_1.getSigners)(authority, multiSigners);
        const transaction = new web3_js_1.Transaction().add((0, closeAccount_js_1.createCloseAccountInstruction)(account, destination, authorityPublicKey, multiSigners, programId));
        return yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer, ...signers], confirmOptions);
      });
    }
  }
});

// node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/instructions/initializeAccount.js
var require_initializeAccount = __commonJS({
  "node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/instructions/initializeAccount.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.initializeAccountInstructionData = void 0;
    exports2.createInitializeAccountInstruction = createInitializeAccountInstruction;
    exports2.decodeInitializeAccountInstruction = decodeInitializeAccountInstruction;
    exports2.decodeInitializeAccountInstructionUnchecked = decodeInitializeAccountInstructionUnchecked;
    var buffer_layout_1 = require_Layout();
    var web3_js_1 = require("@solana/web3.js");
    var constants_js_1 = require_constants();
    var errors_js_1 = require_errors();
    var types_js_1 = require_types();
    exports2.initializeAccountInstructionData = (0, buffer_layout_1.struct)([(0, buffer_layout_1.u8)("instruction")]);
    function createInitializeAccountInstruction(account, mint, owner, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      const keys = [
        { pubkey: account, isSigner: false, isWritable: true },
        { pubkey: mint, isSigner: false, isWritable: false },
        { pubkey: owner, isSigner: false, isWritable: false },
        { pubkey: web3_js_1.SYSVAR_RENT_PUBKEY, isSigner: false, isWritable: false }
      ];
      const data = Buffer.alloc(exports2.initializeAccountInstructionData.span);
      exports2.initializeAccountInstructionData.encode({ instruction: types_js_1.TokenInstruction.InitializeAccount }, data);
      return new web3_js_1.TransactionInstruction({ keys, programId, data });
    }
    function decodeInitializeAccountInstruction(instruction, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      if (!instruction.programId.equals(programId))
        throw new errors_js_1.TokenInvalidInstructionProgramError();
      if (instruction.data.length !== exports2.initializeAccountInstructionData.span)
        throw new errors_js_1.TokenInvalidInstructionDataError();
      const { keys: { account, mint, owner, rent }, data } = decodeInitializeAccountInstructionUnchecked(instruction);
      if (data.instruction !== types_js_1.TokenInstruction.InitializeAccount)
        throw new errors_js_1.TokenInvalidInstructionTypeError();
      if (!account || !mint || !owner || !rent)
        throw new errors_js_1.TokenInvalidInstructionKeysError();
      return {
        programId,
        keys: {
          account,
          mint,
          owner,
          rent
        },
        data
      };
    }
    function decodeInitializeAccountInstructionUnchecked({ programId, keys: [account, mint, owner, rent], data }) {
      return {
        programId,
        keys: {
          account,
          mint,
          owner,
          rent
        },
        data: exports2.initializeAccountInstructionData.decode(data)
      };
    }
  }
});

// node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/instructions/associatedTokenAccount.js
var require_associatedTokenAccount = __commonJS({
  "node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/instructions/associatedTokenAccount.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createAssociatedTokenAccountInstruction = createAssociatedTokenAccountInstruction;
    exports2.createAssociatedTokenAccountIdempotentInstruction = createAssociatedTokenAccountIdempotentInstruction;
    exports2.createAssociatedTokenAccountIdempotentInstructionWithDerivation = createAssociatedTokenAccountIdempotentInstructionWithDerivation;
    exports2.createRecoverNestedInstruction = createRecoverNestedInstruction;
    var web3_js_1 = require("@solana/web3.js");
    var constants_js_1 = require_constants();
    var mint_js_1 = require_mint();
    function createAssociatedTokenAccountInstruction(payer, associatedToken, owner, mint, programId = constants_js_1.TOKEN_PROGRAM_ID, associatedTokenProgramId = constants_js_1.ASSOCIATED_TOKEN_PROGRAM_ID) {
      return buildAssociatedTokenAccountInstruction(payer, associatedToken, owner, mint, Buffer.alloc(0), programId, associatedTokenProgramId);
    }
    function createAssociatedTokenAccountIdempotentInstruction(payer, associatedToken, owner, mint, programId = constants_js_1.TOKEN_PROGRAM_ID, associatedTokenProgramId = constants_js_1.ASSOCIATED_TOKEN_PROGRAM_ID) {
      return buildAssociatedTokenAccountInstruction(payer, associatedToken, owner, mint, Buffer.from([1]), programId, associatedTokenProgramId);
    }
    function createAssociatedTokenAccountIdempotentInstructionWithDerivation(payer, owner, mint, allowOwnerOffCurve = true, programId = constants_js_1.TOKEN_PROGRAM_ID, associatedTokenProgramId = constants_js_1.ASSOCIATED_TOKEN_PROGRAM_ID) {
      const associatedToken = (0, mint_js_1.getAssociatedTokenAddressSync)(mint, owner, allowOwnerOffCurve);
      return createAssociatedTokenAccountIdempotentInstruction(payer, associatedToken, owner, mint, programId, associatedTokenProgramId);
    }
    function buildAssociatedTokenAccountInstruction(payer, associatedToken, owner, mint, instructionData, programId = constants_js_1.TOKEN_PROGRAM_ID, associatedTokenProgramId = constants_js_1.ASSOCIATED_TOKEN_PROGRAM_ID) {
      const keys = [
        { pubkey: payer, isSigner: true, isWritable: true },
        { pubkey: associatedToken, isSigner: false, isWritable: true },
        { pubkey: owner, isSigner: false, isWritable: false },
        { pubkey: mint, isSigner: false, isWritable: false },
        { pubkey: web3_js_1.SystemProgram.programId, isSigner: false, isWritable: false },
        { pubkey: programId, isSigner: false, isWritable: false }
      ];
      return new web3_js_1.TransactionInstruction({
        keys,
        programId: associatedTokenProgramId,
        data: instructionData
      });
    }
    function createRecoverNestedInstruction(nestedAssociatedToken, nestedMint, destinationAssociatedToken, ownerAssociatedToken, ownerMint, owner, programId = constants_js_1.TOKEN_PROGRAM_ID, associatedTokenProgramId = constants_js_1.ASSOCIATED_TOKEN_PROGRAM_ID) {
      const keys = [
        { pubkey: nestedAssociatedToken, isSigner: false, isWritable: true },
        { pubkey: nestedMint, isSigner: false, isWritable: false },
        { pubkey: destinationAssociatedToken, isSigner: false, isWritable: true },
        { pubkey: ownerAssociatedToken, isSigner: false, isWritable: true },
        { pubkey: ownerMint, isSigner: false, isWritable: false },
        { pubkey: owner, isSigner: true, isWritable: true },
        { pubkey: programId, isSigner: false, isWritable: false }
      ];
      return new web3_js_1.TransactionInstruction({
        keys,
        programId: associatedTokenProgramId,
        data: Buffer.from([2])
      });
    }
  }
});

// node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/actions/createAssociatedTokenAccount.js
var require_createAssociatedTokenAccount = __commonJS({
  "node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/actions/createAssociatedTokenAccount.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createAssociatedTokenAccount = createAssociatedTokenAccount;
    var web3_js_1 = require("@solana/web3.js");
    var constants_js_1 = require_constants();
    var associatedTokenAccount_js_1 = require_associatedTokenAccount();
    var mint_js_1 = require_mint();
    function createAssociatedTokenAccount(connection_1, payer_1, mint_1, owner_1, confirmOptions_1) {
      return __awaiter(this, arguments, void 0, function* (connection, payer, mint, owner, confirmOptions, programId = constants_js_1.TOKEN_PROGRAM_ID, associatedTokenProgramId = constants_js_1.ASSOCIATED_TOKEN_PROGRAM_ID, allowOwnerOffCurve = false) {
        const associatedToken = (0, mint_js_1.getAssociatedTokenAddressSync)(mint, owner, allowOwnerOffCurve, programId, associatedTokenProgramId);
        const transaction = new web3_js_1.Transaction().add((0, associatedTokenAccount_js_1.createAssociatedTokenAccountInstruction)(payer.publicKey, associatedToken, owner, mint, programId, associatedTokenProgramId));
        yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer], confirmOptions);
        return associatedToken;
      });
    }
  }
});

// node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/actions/createAccount.js
var require_createAccount = __commonJS({
  "node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/actions/createAccount.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createAccount = createAccount;
    var web3_js_1 = require("@solana/web3.js");
    var constants_js_1 = require_constants();
    var extensionType_js_1 = require_extensionType();
    var initializeAccount_js_1 = require_initializeAccount();
    var mint_js_1 = require_mint();
    var createAssociatedTokenAccount_js_1 = require_createAssociatedTokenAccount();
    function createAccount(connection_1, payer_1, mint_1, owner_1, keypair_1, confirmOptions_1) {
      return __awaiter(this, arguments, void 0, function* (connection, payer, mint, owner, keypair, confirmOptions, programId = constants_js_1.TOKEN_PROGRAM_ID) {
        if (!keypair)
          return yield (0, createAssociatedTokenAccount_js_1.createAssociatedTokenAccount)(connection, payer, mint, owner, confirmOptions, programId);
        const mintState = yield (0, mint_js_1.getMint)(connection, mint, confirmOptions === null || confirmOptions === void 0 ? void 0 : confirmOptions.commitment, programId);
        const space = (0, extensionType_js_1.getAccountLenForMint)(mintState);
        const lamports = yield connection.getMinimumBalanceForRentExemption(space);
        const transaction = new web3_js_1.Transaction().add(web3_js_1.SystemProgram.createAccount({
          fromPubkey: payer.publicKey,
          newAccountPubkey: keypair.publicKey,
          space,
          lamports,
          programId
        }), (0, initializeAccount_js_1.createInitializeAccountInstruction)(keypair.publicKey, mint, owner, programId));
        yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer, keypair], confirmOptions);
        return keypair.publicKey;
      });
    }
  }
});

// node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/actions/createAssociatedTokenAccountIdempotent.js
var require_createAssociatedTokenAccountIdempotent = __commonJS({
  "node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/actions/createAssociatedTokenAccountIdempotent.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createAssociatedTokenAccountIdempotent = createAssociatedTokenAccountIdempotent;
    var web3_js_1 = require("@solana/web3.js");
    var constants_js_1 = require_constants();
    var associatedTokenAccount_js_1 = require_associatedTokenAccount();
    var mint_js_1 = require_mint();
    function createAssociatedTokenAccountIdempotent(connection_1, payer_1, mint_1, owner_1, confirmOptions_1) {
      return __awaiter(this, arguments, void 0, function* (connection, payer, mint, owner, confirmOptions, programId = constants_js_1.TOKEN_PROGRAM_ID, associatedTokenProgramId = constants_js_1.ASSOCIATED_TOKEN_PROGRAM_ID, allowOwnerOffCurve = false) {
        const associatedToken = (0, mint_js_1.getAssociatedTokenAddressSync)(mint, owner, allowOwnerOffCurve, programId, associatedTokenProgramId);
        const transaction = new web3_js_1.Transaction().add((0, associatedTokenAccount_js_1.createAssociatedTokenAccountIdempotentInstruction)(payer.publicKey, associatedToken, owner, mint, programId, associatedTokenProgramId));
        yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer], confirmOptions);
        return associatedToken;
      });
    }
  }
});

// node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/instructions/initializeMint2.js
var require_initializeMint2 = __commonJS({
  "node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/instructions/initializeMint2.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.initializeMint2InstructionData = void 0;
    exports2.createInitializeMint2Instruction = createInitializeMint2Instruction;
    exports2.decodeInitializeMint2Instruction = decodeInitializeMint2Instruction;
    exports2.decodeInitializeMint2InstructionUnchecked = decodeInitializeMint2InstructionUnchecked;
    var buffer_layout_1 = require_Layout();
    var buffer_layout_utils_1 = require_cjs();
    var web3_js_1 = require("@solana/web3.js");
    var constants_js_1 = require_constants();
    var errors_js_1 = require_errors();
    var types_js_1 = require_types();
    var serialization_js_1 = require_serialization();
    exports2.initializeMint2InstructionData = (0, buffer_layout_1.struct)([
      (0, buffer_layout_1.u8)("instruction"),
      (0, buffer_layout_1.u8)("decimals"),
      (0, buffer_layout_utils_1.publicKey)("mintAuthority"),
      new serialization_js_1.COptionPublicKeyLayout("freezeAuthority")
    ]);
    function createInitializeMint2Instruction(mint, decimals, mintAuthority, freezeAuthority, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      const keys = [{ pubkey: mint, isSigner: false, isWritable: true }];
      const data = Buffer.alloc(67);
      exports2.initializeMint2InstructionData.encode({
        instruction: types_js_1.TokenInstruction.InitializeMint2,
        decimals,
        mintAuthority,
        freezeAuthority
      }, data);
      return new web3_js_1.TransactionInstruction({
        keys,
        programId,
        data: data.subarray(0, exports2.initializeMint2InstructionData.getSpan(data))
      });
    }
    function decodeInitializeMint2Instruction(instruction, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      if (!instruction.programId.equals(programId))
        throw new errors_js_1.TokenInvalidInstructionProgramError();
      if (instruction.data.length !== exports2.initializeMint2InstructionData.getSpan(instruction.data))
        throw new errors_js_1.TokenInvalidInstructionDataError();
      const { keys: { mint }, data } = decodeInitializeMint2InstructionUnchecked(instruction);
      if (data.instruction !== types_js_1.TokenInstruction.InitializeMint2)
        throw new errors_js_1.TokenInvalidInstructionTypeError();
      if (!mint)
        throw new errors_js_1.TokenInvalidInstructionKeysError();
      return {
        programId,
        keys: {
          mint
        },
        data
      };
    }
    function decodeInitializeMint2InstructionUnchecked({ programId, keys: [mint], data }) {
      const { instruction, decimals, mintAuthority, freezeAuthority } = exports2.initializeMint2InstructionData.decode(data);
      return {
        programId,
        keys: {
          mint
        },
        data: {
          instruction,
          decimals,
          mintAuthority,
          freezeAuthority
        }
      };
    }
  }
});

// node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/actions/createMint.js
var require_createMint = __commonJS({
  "node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/actions/createMint.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createMint = createMint;
    var web3_js_1 = require("@solana/web3.js");
    var constants_js_1 = require_constants();
    var initializeMint2_js_1 = require_initializeMint2();
    var mint_js_1 = require_mint();
    function createMint(connection_1, payer_1, mintAuthority_1, freezeAuthority_1, decimals_1) {
      return __awaiter(this, arguments, void 0, function* (connection, payer, mintAuthority, freezeAuthority, decimals, keypair = web3_js_1.Keypair.generate(), confirmOptions, programId = constants_js_1.TOKEN_PROGRAM_ID) {
        const lamports = yield (0, mint_js_1.getMinimumBalanceForRentExemptMint)(connection);
        const transaction = new web3_js_1.Transaction().add(web3_js_1.SystemProgram.createAccount({
          fromPubkey: payer.publicKey,
          newAccountPubkey: keypair.publicKey,
          space: mint_js_1.MINT_SIZE,
          lamports,
          programId
        }), (0, initializeMint2_js_1.createInitializeMint2Instruction)(keypair.publicKey, decimals, mintAuthority, freezeAuthority, programId));
        yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer, keypair], confirmOptions);
        return keypair.publicKey;
      });
    }
  }
});

// node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/instructions/initializeMultisig.js
var require_initializeMultisig = __commonJS({
  "node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/instructions/initializeMultisig.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.initializeMultisigInstructionData = void 0;
    exports2.createInitializeMultisigInstruction = createInitializeMultisigInstruction;
    exports2.decodeInitializeMultisigInstruction = decodeInitializeMultisigInstruction;
    exports2.decodeInitializeMultisigInstructionUnchecked = decodeInitializeMultisigInstructionUnchecked;
    var buffer_layout_1 = require_Layout();
    var web3_js_1 = require("@solana/web3.js");
    var constants_js_1 = require_constants();
    var errors_js_1 = require_errors();
    var types_js_1 = require_types();
    exports2.initializeMultisigInstructionData = (0, buffer_layout_1.struct)([
      (0, buffer_layout_1.u8)("instruction"),
      (0, buffer_layout_1.u8)("m")
    ]);
    function createInitializeMultisigInstruction(account, signers, m, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      const keys = [
        { pubkey: account, isSigner: false, isWritable: true },
        { pubkey: web3_js_1.SYSVAR_RENT_PUBKEY, isSigner: false, isWritable: false }
      ];
      for (const signer of signers) {
        keys.push({
          pubkey: signer instanceof web3_js_1.PublicKey ? signer : signer.publicKey,
          isSigner: false,
          isWritable: false
        });
      }
      const data = Buffer.alloc(exports2.initializeMultisigInstructionData.span);
      exports2.initializeMultisigInstructionData.encode({
        instruction: types_js_1.TokenInstruction.InitializeMultisig,
        m
      }, data);
      return new web3_js_1.TransactionInstruction({ keys, programId, data });
    }
    function decodeInitializeMultisigInstruction(instruction, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      if (!instruction.programId.equals(programId))
        throw new errors_js_1.TokenInvalidInstructionProgramError();
      if (instruction.data.length !== exports2.initializeMultisigInstructionData.span)
        throw new errors_js_1.TokenInvalidInstructionDataError();
      const { keys: { account, rent, signers }, data } = decodeInitializeMultisigInstructionUnchecked(instruction);
      if (data.instruction !== types_js_1.TokenInstruction.InitializeMultisig)
        throw new errors_js_1.TokenInvalidInstructionTypeError();
      if (!account || !rent || !signers.length)
        throw new errors_js_1.TokenInvalidInstructionKeysError();
      return {
        programId,
        keys: {
          account,
          rent,
          signers
        },
        data
      };
    }
    function decodeInitializeMultisigInstructionUnchecked({ programId, keys: [account, rent, ...signers], data }) {
      return {
        programId,
        keys: {
          account,
          rent,
          signers
        },
        data: exports2.initializeMultisigInstructionData.decode(data)
      };
    }
  }
});

// node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/actions/createMultisig.js
var require_createMultisig = __commonJS({
  "node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/actions/createMultisig.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createMultisig = createMultisig;
    var web3_js_1 = require("@solana/web3.js");
    var constants_js_1 = require_constants();
    var initializeMultisig_js_1 = require_initializeMultisig();
    var multisig_js_1 = require_multisig();
    function createMultisig(connection_1, payer_1, signers_1, m_1) {
      return __awaiter(this, arguments, void 0, function* (connection, payer, signers, m, keypair = web3_js_1.Keypair.generate(), confirmOptions, programId = constants_js_1.TOKEN_PROGRAM_ID) {
        const lamports = yield (0, multisig_js_1.getMinimumBalanceForRentExemptMultisig)(connection);
        const transaction = new web3_js_1.Transaction().add(web3_js_1.SystemProgram.createAccount({
          fromPubkey: payer.publicKey,
          newAccountPubkey: keypair.publicKey,
          space: multisig_js_1.MULTISIG_SIZE,
          lamports,
          programId
        }), (0, initializeMultisig_js_1.createInitializeMultisigInstruction)(keypair.publicKey, signers, m, programId));
        yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer, keypair], confirmOptions);
        return keypair.publicKey;
      });
    }
  }
});

// node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/instructions/createNativeMint.js
var require_createNativeMint = __commonJS({
  "node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/instructions/createNativeMint.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createNativeMintInstructionData = void 0;
    exports2.createCreateNativeMintInstruction = createCreateNativeMintInstruction;
    var buffer_layout_1 = require_Layout();
    var web3_js_1 = require("@solana/web3.js");
    var constants_js_1 = require_constants();
    var errors_js_1 = require_errors();
    var types_js_1 = require_types();
    exports2.createNativeMintInstructionData = (0, buffer_layout_1.struct)([(0, buffer_layout_1.u8)("instruction")]);
    function createCreateNativeMintInstruction(payer, nativeMintId = constants_js_1.NATIVE_MINT_2022, programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
      if (!(0, constants_js_1.programSupportsExtensions)(programId)) {
        throw new errors_js_1.TokenUnsupportedInstructionError();
      }
      const keys = [
        { pubkey: payer, isSigner: true, isWritable: true },
        { pubkey: nativeMintId, isSigner: false, isWritable: true },
        { pubkey: web3_js_1.SystemProgram.programId, isSigner: false, isWritable: false }
      ];
      const data = Buffer.alloc(exports2.createNativeMintInstructionData.span);
      exports2.createNativeMintInstructionData.encode({ instruction: types_js_1.TokenInstruction.CreateNativeMint }, data);
      return new web3_js_1.TransactionInstruction({ keys, programId, data });
    }
  }
});

// node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/actions/createNativeMint.js
var require_createNativeMint2 = __commonJS({
  "node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/actions/createNativeMint.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createNativeMint = createNativeMint;
    var web3_js_1 = require("@solana/web3.js");
    var constants_js_1 = require_constants();
    var createNativeMint_js_1 = require_createNativeMint();
    function createNativeMint(connection_1, payer_1, confirmOptions_1) {
      return __awaiter(this, arguments, void 0, function* (connection, payer, confirmOptions, nativeMint = constants_js_1.NATIVE_MINT_2022, programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
        const transaction = new web3_js_1.Transaction().add((0, createNativeMint_js_1.createCreateNativeMintInstruction)(payer.publicKey, nativeMint, programId));
        yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer], confirmOptions);
      });
    }
  }
});

// node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/instructions/syncNative.js
var require_syncNative = __commonJS({
  "node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/instructions/syncNative.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.syncNativeInstructionData = void 0;
    exports2.createSyncNativeInstruction = createSyncNativeInstruction;
    exports2.decodeSyncNativeInstruction = decodeSyncNativeInstruction;
    exports2.decodeSyncNativeInstructionUnchecked = decodeSyncNativeInstructionUnchecked;
    var buffer_layout_1 = require_Layout();
    var web3_js_1 = require("@solana/web3.js");
    var constants_js_1 = require_constants();
    var errors_js_1 = require_errors();
    var types_js_1 = require_types();
    exports2.syncNativeInstructionData = (0, buffer_layout_1.struct)([(0, buffer_layout_1.u8)("instruction")]);
    function createSyncNativeInstruction(account, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      const keys = [{ pubkey: account, isSigner: false, isWritable: true }];
      const data = Buffer.alloc(exports2.syncNativeInstructionData.span);
      exports2.syncNativeInstructionData.encode({ instruction: types_js_1.TokenInstruction.SyncNative }, data);
      return new web3_js_1.TransactionInstruction({ keys, programId, data });
    }
    function decodeSyncNativeInstruction(instruction, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      if (!instruction.programId.equals(programId))
        throw new errors_js_1.TokenInvalidInstructionProgramError();
      if (instruction.data.length !== exports2.syncNativeInstructionData.span)
        throw new errors_js_1.TokenInvalidInstructionDataError();
      const { keys: { account }, data } = decodeSyncNativeInstructionUnchecked(instruction);
      if (data.instruction !== types_js_1.TokenInstruction.SyncNative)
        throw new errors_js_1.TokenInvalidInstructionTypeError();
      if (!account)
        throw new errors_js_1.TokenInvalidInstructionKeysError();
      return {
        programId,
        keys: {
          account
        },
        data
      };
    }
    function decodeSyncNativeInstructionUnchecked({ programId, keys: [account], data }) {
      return {
        programId,
        keys: {
          account
        },
        data: exports2.syncNativeInstructionData.decode(data)
      };
    }
  }
});

// node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/actions/createWrappedNativeAccount.js
var require_createWrappedNativeAccount = __commonJS({
  "node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/actions/createWrappedNativeAccount.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createWrappedNativeAccount = createWrappedNativeAccount;
    var web3_js_1 = require("@solana/web3.js");
    var constants_js_1 = require_constants();
    var associatedTokenAccount_js_1 = require_associatedTokenAccount();
    var initializeAccount_js_1 = require_initializeAccount();
    var syncNative_js_1 = require_syncNative();
    var account_js_1 = require_account();
    var mint_js_1 = require_mint();
    var createAccount_js_1 = require_createAccount();
    function createWrappedNativeAccount(connection_1, payer_1, owner_1, amount_1, keypair_1, confirmOptions_1) {
      return __awaiter(this, arguments, void 0, function* (connection, payer, owner, amount, keypair, confirmOptions, programId = constants_js_1.TOKEN_PROGRAM_ID, nativeMint = constants_js_1.NATIVE_MINT) {
        if (!amount)
          return yield (0, createAccount_js_1.createAccount)(connection, payer, nativeMint, owner, keypair, confirmOptions, programId);
        if (!keypair) {
          const associatedToken = (0, mint_js_1.getAssociatedTokenAddressSync)(nativeMint, owner, false, programId, constants_js_1.ASSOCIATED_TOKEN_PROGRAM_ID);
          const transaction2 = new web3_js_1.Transaction().add((0, associatedTokenAccount_js_1.createAssociatedTokenAccountInstruction)(payer.publicKey, associatedToken, owner, nativeMint, programId, constants_js_1.ASSOCIATED_TOKEN_PROGRAM_ID), web3_js_1.SystemProgram.transfer({
            fromPubkey: payer.publicKey,
            toPubkey: associatedToken,
            lamports: amount
          }), (0, syncNative_js_1.createSyncNativeInstruction)(associatedToken, programId));
          yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction2, [payer], confirmOptions);
          return associatedToken;
        }
        const lamports = yield (0, account_js_1.getMinimumBalanceForRentExemptAccount)(connection);
        const transaction = new web3_js_1.Transaction().add(web3_js_1.SystemProgram.createAccount({
          fromPubkey: payer.publicKey,
          newAccountPubkey: keypair.publicKey,
          space: account_js_1.ACCOUNT_SIZE,
          lamports,
          programId
        }), web3_js_1.SystemProgram.transfer({
          fromPubkey: payer.publicKey,
          toPubkey: keypair.publicKey,
          lamports: amount
        }), (0, initializeAccount_js_1.createInitializeAccountInstruction)(keypair.publicKey, nativeMint, owner, programId));
        yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer, keypair], confirmOptions);
        return keypair.publicKey;
      });
    }
  }
});

// node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/instructions/freezeAccount.js
var require_freezeAccount = __commonJS({
  "node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/instructions/freezeAccount.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.freezeAccountInstructionData = void 0;
    exports2.createFreezeAccountInstruction = createFreezeAccountInstruction;
    exports2.decodeFreezeAccountInstruction = decodeFreezeAccountInstruction;
    exports2.decodeFreezeAccountInstructionUnchecked = decodeFreezeAccountInstructionUnchecked;
    var buffer_layout_1 = require_Layout();
    var web3_js_1 = require("@solana/web3.js");
    var constants_js_1 = require_constants();
    var errors_js_1 = require_errors();
    var internal_js_1 = require_internal2();
    var types_js_1 = require_types();
    exports2.freezeAccountInstructionData = (0, buffer_layout_1.struct)([(0, buffer_layout_1.u8)("instruction")]);
    function createFreezeAccountInstruction(account, mint, authority, multiSigners = [], programId = constants_js_1.TOKEN_PROGRAM_ID) {
      const keys = (0, internal_js_1.addSigners)([
        { pubkey: account, isSigner: false, isWritable: true },
        { pubkey: mint, isSigner: false, isWritable: false }
      ], authority, multiSigners);
      const data = Buffer.alloc(exports2.freezeAccountInstructionData.span);
      exports2.freezeAccountInstructionData.encode({ instruction: types_js_1.TokenInstruction.FreezeAccount }, data);
      return new web3_js_1.TransactionInstruction({ keys, programId, data });
    }
    function decodeFreezeAccountInstruction(instruction, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      if (!instruction.programId.equals(programId))
        throw new errors_js_1.TokenInvalidInstructionProgramError();
      if (instruction.data.length !== exports2.freezeAccountInstructionData.span)
        throw new errors_js_1.TokenInvalidInstructionDataError();
      const { keys: { account, mint, authority, multiSigners }, data } = decodeFreezeAccountInstructionUnchecked(instruction);
      if (data.instruction !== types_js_1.TokenInstruction.FreezeAccount)
        throw new errors_js_1.TokenInvalidInstructionTypeError();
      if (!account || !mint || !authority)
        throw new errors_js_1.TokenInvalidInstructionKeysError();
      return {
        programId,
        keys: {
          account,
          mint,
          authority,
          multiSigners
        },
        data
      };
    }
    function decodeFreezeAccountInstructionUnchecked({ programId, keys: [account, mint, authority, ...multiSigners], data }) {
      return {
        programId,
        keys: {
          account,
          mint,
          authority,
          multiSigners
        },
        data: exports2.freezeAccountInstructionData.decode(data)
      };
    }
  }
});

// node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/actions/freezeAccount.js
var require_freezeAccount2 = __commonJS({
  "node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/actions/freezeAccount.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.freezeAccount = freezeAccount;
    var web3_js_1 = require("@solana/web3.js");
    var constants_js_1 = require_constants();
    var freezeAccount_js_1 = require_freezeAccount();
    var internal_js_1 = require_internal();
    function freezeAccount(connection_1, payer_1, account_1, mint_1, authority_1) {
      return __awaiter(this, arguments, void 0, function* (connection, payer, account, mint, authority, multiSigners = [], confirmOptions, programId = constants_js_1.TOKEN_PROGRAM_ID) {
        const [authorityPublicKey, signers] = (0, internal_js_1.getSigners)(authority, multiSigners);
        const transaction = new web3_js_1.Transaction().add((0, freezeAccount_js_1.createFreezeAccountInstruction)(account, mint, authorityPublicKey, multiSigners, programId));
        return yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer, ...signers], confirmOptions);
      });
    }
  }
});

// node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/actions/getOrCreateAssociatedTokenAccount.js
var require_getOrCreateAssociatedTokenAccount = __commonJS({
  "node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/actions/getOrCreateAssociatedTokenAccount.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getOrCreateAssociatedTokenAccount = getOrCreateAssociatedTokenAccount;
    var web3_js_1 = require("@solana/web3.js");
    var constants_js_1 = require_constants();
    var errors_js_1 = require_errors();
    var associatedTokenAccount_js_1 = require_associatedTokenAccount();
    var account_js_1 = require_account();
    var mint_js_1 = require_mint();
    function getOrCreateAssociatedTokenAccount(connection_1, payer_1, mint_1, owner_1) {
      return __awaiter(this, arguments, void 0, function* (connection, payer, mint, owner, allowOwnerOffCurve = false, commitment, confirmOptions, programId = constants_js_1.TOKEN_PROGRAM_ID, associatedTokenProgramId = constants_js_1.ASSOCIATED_TOKEN_PROGRAM_ID) {
        const associatedToken = (0, mint_js_1.getAssociatedTokenAddressSync)(mint, owner, allowOwnerOffCurve, programId, associatedTokenProgramId);
        let account;
        try {
          account = yield (0, account_js_1.getAccount)(connection, associatedToken, commitment, programId);
        } catch (error) {
          if (error instanceof errors_js_1.TokenAccountNotFoundError || error instanceof errors_js_1.TokenInvalidAccountOwnerError) {
            try {
              const transaction = new web3_js_1.Transaction().add((0, associatedTokenAccount_js_1.createAssociatedTokenAccountInstruction)(payer.publicKey, associatedToken, owner, mint, programId, associatedTokenProgramId));
              yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer], confirmOptions);
            } catch (error2) {
            }
            account = yield (0, account_js_1.getAccount)(connection, associatedToken, commitment, programId);
          } else {
            throw error;
          }
        }
        if (!account.mint.equals(mint))
          throw new errors_js_1.TokenInvalidMintError();
        if (!account.owner.equals(owner))
          throw new errors_js_1.TokenInvalidOwnerError();
        return account;
      });
    }
  }
});

// node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/instructions/mintTo.js
var require_mintTo = __commonJS({
  "node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/instructions/mintTo.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.mintToInstructionData = void 0;
    exports2.createMintToInstruction = createMintToInstruction;
    exports2.decodeMintToInstruction = decodeMintToInstruction;
    exports2.decodeMintToInstructionUnchecked = decodeMintToInstructionUnchecked;
    var buffer_layout_1 = require_Layout();
    var buffer_layout_utils_1 = require_cjs();
    var web3_js_1 = require("@solana/web3.js");
    var constants_js_1 = require_constants();
    var errors_js_1 = require_errors();
    var internal_js_1 = require_internal2();
    var types_js_1 = require_types();
    exports2.mintToInstructionData = (0, buffer_layout_1.struct)([(0, buffer_layout_1.u8)("instruction"), (0, buffer_layout_utils_1.u64)("amount")]);
    function createMintToInstruction(mint, destination, authority, amount, multiSigners = [], programId = constants_js_1.TOKEN_PROGRAM_ID) {
      const keys = (0, internal_js_1.addSigners)([
        { pubkey: mint, isSigner: false, isWritable: true },
        { pubkey: destination, isSigner: false, isWritable: true }
      ], authority, multiSigners);
      const data = Buffer.alloc(exports2.mintToInstructionData.span);
      exports2.mintToInstructionData.encode({
        instruction: types_js_1.TokenInstruction.MintTo,
        amount: BigInt(amount)
      }, data);
      return new web3_js_1.TransactionInstruction({ keys, programId, data });
    }
    function decodeMintToInstruction(instruction, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      if (!instruction.programId.equals(programId))
        throw new errors_js_1.TokenInvalidInstructionProgramError();
      if (instruction.data.length !== exports2.mintToInstructionData.span)
        throw new errors_js_1.TokenInvalidInstructionDataError();
      const { keys: { mint, destination, authority, multiSigners }, data } = decodeMintToInstructionUnchecked(instruction);
      if (data.instruction !== types_js_1.TokenInstruction.MintTo)
        throw new errors_js_1.TokenInvalidInstructionTypeError();
      if (!mint || !destination || !authority)
        throw new errors_js_1.TokenInvalidInstructionKeysError();
      return {
        programId,
        keys: {
          mint,
          destination,
          authority,
          multiSigners
        },
        data
      };
    }
    function decodeMintToInstructionUnchecked({ programId, keys: [mint, destination, authority, ...multiSigners], data }) {
      return {
        programId,
        keys: {
          mint,
          destination,
          authority,
          multiSigners
        },
        data: exports2.mintToInstructionData.decode(data)
      };
    }
  }
});

// node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/actions/mintTo.js
var require_mintTo2 = __commonJS({
  "node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/actions/mintTo.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.mintTo = mintTo;
    var web3_js_1 = require("@solana/web3.js");
    var constants_js_1 = require_constants();
    var mintTo_js_1 = require_mintTo();
    var internal_js_1 = require_internal();
    function mintTo(connection_1, payer_1, mint_1, destination_1, authority_1, amount_1) {
      return __awaiter(this, arguments, void 0, function* (connection, payer, mint, destination, authority, amount, multiSigners = [], confirmOptions, programId = constants_js_1.TOKEN_PROGRAM_ID) {
        const [authorityPublicKey, signers] = (0, internal_js_1.getSigners)(authority, multiSigners);
        const transaction = new web3_js_1.Transaction().add((0, mintTo_js_1.createMintToInstruction)(mint, destination, authorityPublicKey, amount, multiSigners, programId));
        return yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer, ...signers], confirmOptions);
      });
    }
  }
});

// node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/instructions/mintToChecked.js
var require_mintToChecked = __commonJS({
  "node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/instructions/mintToChecked.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.mintToCheckedInstructionData = void 0;
    exports2.createMintToCheckedInstruction = createMintToCheckedInstruction;
    exports2.decodeMintToCheckedInstruction = decodeMintToCheckedInstruction;
    exports2.decodeMintToCheckedInstructionUnchecked = decodeMintToCheckedInstructionUnchecked;
    var buffer_layout_1 = require_Layout();
    var buffer_layout_utils_1 = require_cjs();
    var web3_js_1 = require("@solana/web3.js");
    var constants_js_1 = require_constants();
    var errors_js_1 = require_errors();
    var internal_js_1 = require_internal2();
    var types_js_1 = require_types();
    exports2.mintToCheckedInstructionData = (0, buffer_layout_1.struct)([
      (0, buffer_layout_1.u8)("instruction"),
      (0, buffer_layout_utils_1.u64)("amount"),
      (0, buffer_layout_1.u8)("decimals")
    ]);
    function createMintToCheckedInstruction(mint, destination, authority, amount, decimals, multiSigners = [], programId = constants_js_1.TOKEN_PROGRAM_ID) {
      const keys = (0, internal_js_1.addSigners)([
        { pubkey: mint, isSigner: false, isWritable: true },
        { pubkey: destination, isSigner: false, isWritable: true }
      ], authority, multiSigners);
      const data = Buffer.alloc(exports2.mintToCheckedInstructionData.span);
      exports2.mintToCheckedInstructionData.encode({
        instruction: types_js_1.TokenInstruction.MintToChecked,
        amount: BigInt(amount),
        decimals
      }, data);
      return new web3_js_1.TransactionInstruction({ keys, programId, data });
    }
    function decodeMintToCheckedInstruction(instruction, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      if (!instruction.programId.equals(programId))
        throw new errors_js_1.TokenInvalidInstructionProgramError();
      if (instruction.data.length !== exports2.mintToCheckedInstructionData.span)
        throw new errors_js_1.TokenInvalidInstructionDataError();
      const { keys: { mint, destination, authority, multiSigners }, data } = decodeMintToCheckedInstructionUnchecked(instruction);
      if (data.instruction !== types_js_1.TokenInstruction.MintToChecked)
        throw new errors_js_1.TokenInvalidInstructionTypeError();
      if (!mint || !destination || !authority)
        throw new errors_js_1.TokenInvalidInstructionKeysError();
      return {
        programId,
        keys: {
          mint,
          destination,
          authority,
          multiSigners
        },
        data
      };
    }
    function decodeMintToCheckedInstructionUnchecked({ programId, keys: [mint, destination, authority, ...multiSigners], data }) {
      return {
        programId,
        keys: {
          mint,
          destination,
          authority,
          multiSigners
        },
        data: exports2.mintToCheckedInstructionData.decode(data)
      };
    }
  }
});

// node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/actions/mintToChecked.js
var require_mintToChecked2 = __commonJS({
  "node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/actions/mintToChecked.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.mintToChecked = mintToChecked;
    var web3_js_1 = require("@solana/web3.js");
    var constants_js_1 = require_constants();
    var mintToChecked_js_1 = require_mintToChecked();
    var internal_js_1 = require_internal();
    function mintToChecked(connection_1, payer_1, mint_1, destination_1, authority_1, amount_1, decimals_1) {
      return __awaiter(this, arguments, void 0, function* (connection, payer, mint, destination, authority, amount, decimals, multiSigners = [], confirmOptions, programId = constants_js_1.TOKEN_PROGRAM_ID) {
        const [authorityPublicKey, signers] = (0, internal_js_1.getSigners)(authority, multiSigners);
        const transaction = new web3_js_1.Transaction().add((0, mintToChecked_js_1.createMintToCheckedInstruction)(mint, destination, authorityPublicKey, amount, decimals, multiSigners, programId));
        return yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer, ...signers], confirmOptions);
      });
    }
  }
});

// node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/actions/recoverNested.js
var require_recoverNested = __commonJS({
  "node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/actions/recoverNested.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.recoverNested = recoverNested;
    var web3_js_1 = require("@solana/web3.js");
    var constants_js_1 = require_constants();
    var associatedTokenAccount_js_1 = require_associatedTokenAccount();
    var mint_js_1 = require_mint();
    function recoverNested(connection_1, payer_1, owner_1, mint_1, nestedMint_1, confirmOptions_1) {
      return __awaiter(this, arguments, void 0, function* (connection, payer, owner, mint, nestedMint, confirmOptions, programId = constants_js_1.TOKEN_PROGRAM_ID, associatedTokenProgramId = constants_js_1.ASSOCIATED_TOKEN_PROGRAM_ID) {
        const ownerAssociatedToken = (0, mint_js_1.getAssociatedTokenAddressSync)(mint, owner.publicKey, false, programId, associatedTokenProgramId);
        const destinationAssociatedToken = (0, mint_js_1.getAssociatedTokenAddressSync)(nestedMint, owner.publicKey, false, programId, associatedTokenProgramId);
        const nestedAssociatedToken = (0, mint_js_1.getAssociatedTokenAddressSync)(nestedMint, ownerAssociatedToken, true, programId, associatedTokenProgramId);
        const transaction = new web3_js_1.Transaction().add((0, associatedTokenAccount_js_1.createRecoverNestedInstruction)(nestedAssociatedToken, nestedMint, destinationAssociatedToken, ownerAssociatedToken, mint, owner.publicKey, programId, associatedTokenProgramId));
        return yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer, owner], confirmOptions);
      });
    }
  }
});

// node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/instructions/revoke.js
var require_revoke = __commonJS({
  "node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/instructions/revoke.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.revokeInstructionData = void 0;
    exports2.createRevokeInstruction = createRevokeInstruction;
    exports2.decodeRevokeInstruction = decodeRevokeInstruction;
    exports2.decodeRevokeInstructionUnchecked = decodeRevokeInstructionUnchecked;
    var buffer_layout_1 = require_Layout();
    var web3_js_1 = require("@solana/web3.js");
    var constants_js_1 = require_constants();
    var errors_js_1 = require_errors();
    var internal_js_1 = require_internal2();
    var types_js_1 = require_types();
    exports2.revokeInstructionData = (0, buffer_layout_1.struct)([(0, buffer_layout_1.u8)("instruction")]);
    function createRevokeInstruction(account, owner, multiSigners = [], programId = constants_js_1.TOKEN_PROGRAM_ID) {
      const keys = (0, internal_js_1.addSigners)([{ pubkey: account, isSigner: false, isWritable: true }], owner, multiSigners);
      const data = Buffer.alloc(exports2.revokeInstructionData.span);
      exports2.revokeInstructionData.encode({ instruction: types_js_1.TokenInstruction.Revoke }, data);
      return new web3_js_1.TransactionInstruction({ keys, programId, data });
    }
    function decodeRevokeInstruction(instruction, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      if (!instruction.programId.equals(programId))
        throw new errors_js_1.TokenInvalidInstructionProgramError();
      if (instruction.data.length !== exports2.revokeInstructionData.span)
        throw new errors_js_1.TokenInvalidInstructionDataError();
      const { keys: { account, owner, multiSigners }, data } = decodeRevokeInstructionUnchecked(instruction);
      if (data.instruction !== types_js_1.TokenInstruction.Revoke)
        throw new errors_js_1.TokenInvalidInstructionTypeError();
      if (!account || !owner)
        throw new errors_js_1.TokenInvalidInstructionKeysError();
      return {
        programId,
        keys: {
          account,
          owner,
          multiSigners
        },
        data
      };
    }
    function decodeRevokeInstructionUnchecked({ programId, keys: [account, owner, ...multiSigners], data }) {
      return {
        programId,
        keys: {
          account,
          owner,
          multiSigners
        },
        data: exports2.revokeInstructionData.decode(data)
      };
    }
  }
});

// node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/actions/revoke.js
var require_revoke2 = __commonJS({
  "node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/actions/revoke.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.revoke = revoke;
    var web3_js_1 = require("@solana/web3.js");
    var constants_js_1 = require_constants();
    var revoke_js_1 = require_revoke();
    var internal_js_1 = require_internal();
    function revoke(connection_1, payer_1, account_1, owner_1) {
      return __awaiter(this, arguments, void 0, function* (connection, payer, account, owner, multiSigners = [], confirmOptions, programId = constants_js_1.TOKEN_PROGRAM_ID) {
        const [ownerPublicKey, signers] = (0, internal_js_1.getSigners)(owner, multiSigners);
        const transaction = new web3_js_1.Transaction().add((0, revoke_js_1.createRevokeInstruction)(account, ownerPublicKey, multiSigners, programId));
        return yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer, ...signers], confirmOptions);
      });
    }
  }
});

// node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/instructions/setAuthority.js
var require_setAuthority = __commonJS({
  "node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/instructions/setAuthority.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.setAuthorityInstructionData = exports2.AuthorityType = void 0;
    exports2.createSetAuthorityInstruction = createSetAuthorityInstruction;
    exports2.decodeSetAuthorityInstruction = decodeSetAuthorityInstruction;
    exports2.decodeSetAuthorityInstructionUnchecked = decodeSetAuthorityInstructionUnchecked;
    var buffer_layout_1 = require_Layout();
    var web3_js_1 = require("@solana/web3.js");
    var constants_js_1 = require_constants();
    var errors_js_1 = require_errors();
    var internal_js_1 = require_internal2();
    var types_js_1 = require_types();
    var serialization_js_1 = require_serialization();
    var AuthorityType;
    (function(AuthorityType2) {
      AuthorityType2[AuthorityType2["MintTokens"] = 0] = "MintTokens";
      AuthorityType2[AuthorityType2["FreezeAccount"] = 1] = "FreezeAccount";
      AuthorityType2[AuthorityType2["AccountOwner"] = 2] = "AccountOwner";
      AuthorityType2[AuthorityType2["CloseAccount"] = 3] = "CloseAccount";
      AuthorityType2[AuthorityType2["TransferFeeConfig"] = 4] = "TransferFeeConfig";
      AuthorityType2[AuthorityType2["WithheldWithdraw"] = 5] = "WithheldWithdraw";
      AuthorityType2[AuthorityType2["CloseMint"] = 6] = "CloseMint";
      AuthorityType2[AuthorityType2["InterestRate"] = 7] = "InterestRate";
      AuthorityType2[AuthorityType2["PermanentDelegate"] = 8] = "PermanentDelegate";
      AuthorityType2[AuthorityType2["ConfidentialTransferMint"] = 9] = "ConfidentialTransferMint";
      AuthorityType2[AuthorityType2["TransferHookProgramId"] = 10] = "TransferHookProgramId";
      AuthorityType2[AuthorityType2["ConfidentialTransferFeeConfig"] = 11] = "ConfidentialTransferFeeConfig";
      AuthorityType2[AuthorityType2["MetadataPointer"] = 12] = "MetadataPointer";
      AuthorityType2[AuthorityType2["GroupPointer"] = 13] = "GroupPointer";
      AuthorityType2[AuthorityType2["GroupMemberPointer"] = 14] = "GroupMemberPointer";
      AuthorityType2[AuthorityType2["ScaledUiAmountConfig"] = 15] = "ScaledUiAmountConfig";
      AuthorityType2[AuthorityType2["PausableConfig"] = 16] = "PausableConfig";
    })(AuthorityType || (exports2.AuthorityType = AuthorityType = {}));
    exports2.setAuthorityInstructionData = (0, buffer_layout_1.struct)([
      (0, buffer_layout_1.u8)("instruction"),
      (0, buffer_layout_1.u8)("authorityType"),
      new serialization_js_1.COptionPublicKeyLayout("newAuthority")
    ]);
    function createSetAuthorityInstruction(account, currentAuthority, authorityType, newAuthority, multiSigners = [], programId = constants_js_1.TOKEN_PROGRAM_ID) {
      const keys = (0, internal_js_1.addSigners)([{ pubkey: account, isSigner: false, isWritable: true }], currentAuthority, multiSigners);
      const data = Buffer.alloc(35);
      exports2.setAuthorityInstructionData.encode({
        instruction: types_js_1.TokenInstruction.SetAuthority,
        authorityType,
        newAuthority
      }, data);
      return new web3_js_1.TransactionInstruction({
        keys,
        programId,
        data: data.subarray(0, exports2.setAuthorityInstructionData.getSpan(data))
      });
    }
    function decodeSetAuthorityInstruction(instruction, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      if (!instruction.programId.equals(programId))
        throw new errors_js_1.TokenInvalidInstructionProgramError();
      if (instruction.data.length !== exports2.setAuthorityInstructionData.getSpan(instruction.data))
        throw new errors_js_1.TokenInvalidInstructionDataError();
      const { keys: { account, currentAuthority, multiSigners }, data } = decodeSetAuthorityInstructionUnchecked(instruction);
      if (data.instruction !== types_js_1.TokenInstruction.SetAuthority)
        throw new errors_js_1.TokenInvalidInstructionTypeError();
      if (!account || !currentAuthority)
        throw new errors_js_1.TokenInvalidInstructionKeysError();
      return {
        programId,
        keys: {
          account,
          currentAuthority,
          multiSigners
        },
        data
      };
    }
    function decodeSetAuthorityInstructionUnchecked({ programId, keys: [account, currentAuthority, ...multiSigners], data }) {
      const { instruction, authorityType, newAuthority } = exports2.setAuthorityInstructionData.decode(data);
      return {
        programId,
        keys: {
          account,
          currentAuthority,
          multiSigners
        },
        data: {
          instruction,
          authorityType,
          newAuthority
        }
      };
    }
  }
});

// node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/actions/setAuthority.js
var require_setAuthority2 = __commonJS({
  "node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/actions/setAuthority.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.setAuthority = setAuthority;
    var web3_js_1 = require("@solana/web3.js");
    var constants_js_1 = require_constants();
    var setAuthority_js_1 = require_setAuthority();
    var internal_js_1 = require_internal();
    function setAuthority(connection_1, payer_1, account_1, currentAuthority_1, authorityType_1, newAuthority_1) {
      return __awaiter(this, arguments, void 0, function* (connection, payer, account, currentAuthority, authorityType, newAuthority, multiSigners = [], confirmOptions, programId = constants_js_1.TOKEN_PROGRAM_ID) {
        const [currentAuthorityPublicKey, signers] = (0, internal_js_1.getSigners)(currentAuthority, multiSigners);
        const transaction = new web3_js_1.Transaction().add((0, setAuthority_js_1.createSetAuthorityInstruction)(account, currentAuthorityPublicKey, authorityType, newAuthority, multiSigners, programId));
        return yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer, ...signers], confirmOptions);
      });
    }
  }
});

// node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/actions/syncNative.js
var require_syncNative2 = __commonJS({
  "node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/actions/syncNative.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.syncNative = syncNative;
    var web3_js_1 = require("@solana/web3.js");
    var constants_js_1 = require_constants();
    var syncNative_js_1 = require_syncNative();
    function syncNative(connection_1, payer_1, account_1, confirmOptions_1) {
      return __awaiter(this, arguments, void 0, function* (connection, payer, account, confirmOptions, programId = constants_js_1.TOKEN_PROGRAM_ID) {
        const transaction = new web3_js_1.Transaction().add((0, syncNative_js_1.createSyncNativeInstruction)(account, programId));
        return yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer], confirmOptions);
      });
    }
  }
});

// node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/instructions/thawAccount.js
var require_thawAccount = __commonJS({
  "node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/instructions/thawAccount.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.thawAccountInstructionData = void 0;
    exports2.createThawAccountInstruction = createThawAccountInstruction;
    exports2.decodeThawAccountInstruction = decodeThawAccountInstruction;
    exports2.decodeThawAccountInstructionUnchecked = decodeThawAccountInstructionUnchecked;
    var buffer_layout_1 = require_Layout();
    var web3_js_1 = require("@solana/web3.js");
    var constants_js_1 = require_constants();
    var errors_js_1 = require_errors();
    var internal_js_1 = require_internal2();
    var types_js_1 = require_types();
    exports2.thawAccountInstructionData = (0, buffer_layout_1.struct)([(0, buffer_layout_1.u8)("instruction")]);
    function createThawAccountInstruction(account, mint, authority, multiSigners = [], programId = constants_js_1.TOKEN_PROGRAM_ID) {
      const keys = (0, internal_js_1.addSigners)([
        { pubkey: account, isSigner: false, isWritable: true },
        { pubkey: mint, isSigner: false, isWritable: false }
      ], authority, multiSigners);
      const data = Buffer.alloc(exports2.thawAccountInstructionData.span);
      exports2.thawAccountInstructionData.encode({ instruction: types_js_1.TokenInstruction.ThawAccount }, data);
      return new web3_js_1.TransactionInstruction({ keys, programId, data });
    }
    function decodeThawAccountInstruction(instruction, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      if (!instruction.programId.equals(programId))
        throw new errors_js_1.TokenInvalidInstructionProgramError();
      if (instruction.data.length !== exports2.thawAccountInstructionData.span)
        throw new errors_js_1.TokenInvalidInstructionDataError();
      const { keys: { account, mint, authority, multiSigners }, data } = decodeThawAccountInstructionUnchecked(instruction);
      if (data.instruction !== types_js_1.TokenInstruction.ThawAccount)
        throw new errors_js_1.TokenInvalidInstructionTypeError();
      if (!account || !mint || !authority)
        throw new errors_js_1.TokenInvalidInstructionKeysError();
      return {
        programId,
        keys: {
          account,
          mint,
          authority,
          multiSigners
        },
        data
      };
    }
    function decodeThawAccountInstructionUnchecked({ programId, keys: [account, mint, authority, ...multiSigners], data }) {
      return {
        programId,
        keys: {
          account,
          mint,
          authority,
          multiSigners
        },
        data: exports2.thawAccountInstructionData.decode(data)
      };
    }
  }
});

// node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/actions/thawAccount.js
var require_thawAccount2 = __commonJS({
  "node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/actions/thawAccount.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.thawAccount = thawAccount;
    var web3_js_1 = require("@solana/web3.js");
    var constants_js_1 = require_constants();
    var thawAccount_js_1 = require_thawAccount();
    var internal_js_1 = require_internal();
    function thawAccount(connection_1, payer_1, account_1, mint_1, authority_1) {
      return __awaiter(this, arguments, void 0, function* (connection, payer, account, mint, authority, multiSigners = [], confirmOptions, programId = constants_js_1.TOKEN_PROGRAM_ID) {
        const [authorityPublicKey, signers] = (0, internal_js_1.getSigners)(authority, multiSigners);
        const transaction = new web3_js_1.Transaction().add((0, thawAccount_js_1.createThawAccountInstruction)(account, mint, authorityPublicKey, multiSigners, programId));
        return yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer, ...signers], confirmOptions);
      });
    }
  }
});

// node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/instructions/transfer.js
var require_transfer = __commonJS({
  "node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/instructions/transfer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.transferInstructionData = void 0;
    exports2.createTransferInstruction = createTransferInstruction;
    exports2.decodeTransferInstruction = decodeTransferInstruction;
    exports2.decodeTransferInstructionUnchecked = decodeTransferInstructionUnchecked;
    var buffer_layout_1 = require_Layout();
    var buffer_layout_utils_1 = require_cjs();
    var web3_js_1 = require("@solana/web3.js");
    var constants_js_1 = require_constants();
    var errors_js_1 = require_errors();
    var internal_js_1 = require_internal2();
    var types_js_1 = require_types();
    exports2.transferInstructionData = (0, buffer_layout_1.struct)([(0, buffer_layout_1.u8)("instruction"), (0, buffer_layout_utils_1.u64)("amount")]);
    function createTransferInstruction(source, destination, owner, amount, multiSigners = [], programId = constants_js_1.TOKEN_PROGRAM_ID) {
      const keys = (0, internal_js_1.addSigners)([
        { pubkey: source, isSigner: false, isWritable: true },
        { pubkey: destination, isSigner: false, isWritable: true }
      ], owner, multiSigners);
      const data = Buffer.alloc(exports2.transferInstructionData.span);
      exports2.transferInstructionData.encode({
        instruction: types_js_1.TokenInstruction.Transfer,
        amount: BigInt(amount)
      }, data);
      return new web3_js_1.TransactionInstruction({ keys, programId, data });
    }
    function decodeTransferInstruction(instruction, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      if (!instruction.programId.equals(programId))
        throw new errors_js_1.TokenInvalidInstructionProgramError();
      if (instruction.data.length !== exports2.transferInstructionData.span)
        throw new errors_js_1.TokenInvalidInstructionDataError();
      const { keys: { source, destination, owner, multiSigners }, data } = decodeTransferInstructionUnchecked(instruction);
      if (data.instruction !== types_js_1.TokenInstruction.Transfer)
        throw new errors_js_1.TokenInvalidInstructionTypeError();
      if (!source || !destination || !owner)
        throw new errors_js_1.TokenInvalidInstructionKeysError();
      return {
        programId,
        keys: {
          source,
          destination,
          owner,
          multiSigners
        },
        data
      };
    }
    function decodeTransferInstructionUnchecked({ programId, keys: [source, destination, owner, ...multiSigners], data }) {
      return {
        programId,
        keys: {
          source,
          destination,
          owner,
          multiSigners
        },
        data: exports2.transferInstructionData.decode(data)
      };
    }
  }
});

// node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/actions/transfer.js
var require_transfer2 = __commonJS({
  "node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/actions/transfer.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.transfer = transfer;
    var web3_js_1 = require("@solana/web3.js");
    var constants_js_1 = require_constants();
    var transfer_js_1 = require_transfer();
    var internal_js_1 = require_internal();
    function transfer(connection_1, payer_1, source_1, destination_1, owner_1, amount_1) {
      return __awaiter(this, arguments, void 0, function* (connection, payer, source, destination, owner, amount, multiSigners = [], confirmOptions, programId = constants_js_1.TOKEN_PROGRAM_ID) {
        const [ownerPublicKey, signers] = (0, internal_js_1.getSigners)(owner, multiSigners);
        const transaction = new web3_js_1.Transaction().add((0, transfer_js_1.createTransferInstruction)(source, destination, ownerPublicKey, amount, multiSigners, programId));
        return yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer, ...signers], confirmOptions);
      });
    }
  }
});

// node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/actions/transferChecked.js
var require_transferChecked2 = __commonJS({
  "node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/actions/transferChecked.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.transferChecked = transferChecked;
    var web3_js_1 = require("@solana/web3.js");
    var constants_js_1 = require_constants();
    var transferChecked_js_1 = require_transferChecked();
    var internal_js_1 = require_internal();
    function transferChecked(connection_1, payer_1, source_1, mint_1, destination_1, owner_1, amount_1, decimals_1) {
      return __awaiter(this, arguments, void 0, function* (connection, payer, source, mint, destination, owner, amount, decimals, multiSigners = [], confirmOptions, programId = constants_js_1.TOKEN_PROGRAM_ID) {
        const [ownerPublicKey, signers] = (0, internal_js_1.getSigners)(owner, multiSigners);
        const transaction = new web3_js_1.Transaction().add((0, transferChecked_js_1.createTransferCheckedInstruction)(source, mint, destination, ownerPublicKey, amount, decimals, multiSigners, programId));
        return yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer, ...signers], confirmOptions);
      });
    }
  }
});

// node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/instructions/uiAmountToAmount.js
var require_uiAmountToAmount = __commonJS({
  "node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/instructions/uiAmountToAmount.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createUiAmountToAmountInstruction = createUiAmountToAmountInstruction;
    exports2.decodeUiAmountToAmountInstruction = decodeUiAmountToAmountInstruction;
    exports2.decodeUiAmountToAmountInstructionUnchecked = decodeUiAmountToAmountInstructionUnchecked;
    var buffer_layout_1 = require_Layout();
    var web3_js_1 = require("@solana/web3.js");
    var constants_js_1 = require_constants();
    var errors_js_1 = require_errors();
    var types_js_1 = require_types();
    function createUiAmountToAmountInstruction(mint, amount, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      const keys = [{ pubkey: mint, isSigner: false, isWritable: false }];
      const buf = Buffer.from(amount, "utf8");
      const uiAmountToAmountInstructionData = (0, buffer_layout_1.struct)([
        (0, buffer_layout_1.u8)("instruction"),
        (0, buffer_layout_1.blob)(buf.length, "amount")
      ]);
      const data = Buffer.alloc(uiAmountToAmountInstructionData.span);
      uiAmountToAmountInstructionData.encode({
        instruction: types_js_1.TokenInstruction.UiAmountToAmount,
        amount: buf
      }, data);
      return new web3_js_1.TransactionInstruction({ keys, programId, data });
    }
    function decodeUiAmountToAmountInstruction(instruction, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      if (!instruction.programId.equals(programId))
        throw new errors_js_1.TokenInvalidInstructionProgramError();
      const uiAmountToAmountInstructionData = (0, buffer_layout_1.struct)([
        (0, buffer_layout_1.u8)("instruction"),
        (0, buffer_layout_1.blob)(instruction.data.length - 1, "amount")
      ]);
      if (instruction.data.length !== uiAmountToAmountInstructionData.span)
        throw new errors_js_1.TokenInvalidInstructionDataError();
      const { keys: { mint }, data } = decodeUiAmountToAmountInstructionUnchecked(instruction);
      if (data.instruction !== types_js_1.TokenInstruction.UiAmountToAmount)
        throw new errors_js_1.TokenInvalidInstructionTypeError();
      if (!mint)
        throw new errors_js_1.TokenInvalidInstructionKeysError();
      return {
        programId,
        keys: {
          mint
        },
        data
      };
    }
    function decodeUiAmountToAmountInstructionUnchecked({ programId, keys: [mint], data }) {
      const uiAmountToAmountInstructionData = (0, buffer_layout_1.struct)([
        (0, buffer_layout_1.u8)("instruction"),
        (0, buffer_layout_1.blob)(data.length - 1, "amount")
      ]);
      return {
        programId,
        keys: {
          mint
        },
        data: uiAmountToAmountInstructionData.decode(data)
      };
    }
  }
});

// node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/actions/uiAmountToAmount.js
var require_uiAmountToAmount2 = __commonJS({
  "node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/actions/uiAmountToAmount.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.uiAmountToAmount = uiAmountToAmount;
    var buffer_layout_utils_1 = require_cjs();
    var web3_js_1 = require("@solana/web3.js");
    var constants_js_1 = require_constants();
    var uiAmountToAmount_js_1 = require_uiAmountToAmount();
    function uiAmountToAmount(connection_1, payer_1, mint_1, amount_1) {
      return __awaiter(this, arguments, void 0, function* (connection, payer, mint, amount, programId = constants_js_1.TOKEN_PROGRAM_ID) {
        const transaction = new web3_js_1.Transaction().add((0, uiAmountToAmount_js_1.createUiAmountToAmountInstruction)(mint, amount, programId));
        const { returnData, err } = (yield connection.simulateTransaction(transaction, [payer], false)).value;
        if (returnData) {
          const data = Buffer.from(returnData.data[0], returnData.data[1]);
          return (0, buffer_layout_utils_1.u64)().decode(data);
        }
        return err;
      });
    }
  }
});

// node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/actions/index.js
var require_actions9 = __commonJS({
  "node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/actions/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_amountToUiAmount2(), exports2);
    __exportStar(require_approve2(), exports2);
    __exportStar(require_approveChecked2(), exports2);
    __exportStar(require_burn2(), exports2);
    __exportStar(require_burnChecked2(), exports2);
    __exportStar(require_closeAccount2(), exports2);
    __exportStar(require_createAccount(), exports2);
    __exportStar(require_createAssociatedTokenAccount(), exports2);
    __exportStar(require_createAssociatedTokenAccountIdempotent(), exports2);
    __exportStar(require_createMint(), exports2);
    __exportStar(require_createMultisig(), exports2);
    __exportStar(require_createNativeMint2(), exports2);
    __exportStar(require_createWrappedNativeAccount(), exports2);
    __exportStar(require_freezeAccount2(), exports2);
    __exportStar(require_getOrCreateAssociatedTokenAccount(), exports2);
    __exportStar(require_mintTo2(), exports2);
    __exportStar(require_mintToChecked2(), exports2);
    __exportStar(require_recoverNested(), exports2);
    __exportStar(require_revoke2(), exports2);
    __exportStar(require_setAuthority2(), exports2);
    __exportStar(require_syncNative2(), exports2);
    __exportStar(require_thawAccount2(), exports2);
    __exportStar(require_transfer2(), exports2);
    __exportStar(require_transferChecked2(), exports2);
    __exportStar(require_uiAmountToAmount2(), exports2);
  }
});

// node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/extensions/groupMemberPointer/instructions.js
var require_instructions8 = __commonJS({
  "node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/extensions/groupMemberPointer/instructions.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.updateGroupMemberPointerData = exports2.initializeGroupMemberPointerData = exports2.GroupMemberPointerInstruction = void 0;
    exports2.createInitializeGroupMemberPointerInstruction = createInitializeGroupMemberPointerInstruction;
    exports2.createUpdateGroupMemberPointerInstruction = createUpdateGroupMemberPointerInstruction;
    var buffer_layout_1 = require_Layout();
    var buffer_layout_utils_1 = require_cjs();
    var web3_js_1 = require("@solana/web3.js");
    var constants_js_1 = require_constants();
    var errors_js_1 = require_errors();
    var types_js_1 = require_types();
    var internal_js_1 = require_internal2();
    var GroupMemberPointerInstruction;
    (function(GroupMemberPointerInstruction2) {
      GroupMemberPointerInstruction2[GroupMemberPointerInstruction2["Initialize"] = 0] = "Initialize";
      GroupMemberPointerInstruction2[GroupMemberPointerInstruction2["Update"] = 1] = "Update";
    })(GroupMemberPointerInstruction || (exports2.GroupMemberPointerInstruction = GroupMemberPointerInstruction = {}));
    exports2.initializeGroupMemberPointerData = (0, buffer_layout_1.struct)([
      // prettier-ignore
      (0, buffer_layout_1.u8)("instruction"),
      (0, buffer_layout_1.u8)("groupMemberPointerInstruction"),
      (0, buffer_layout_utils_1.publicKey)("authority"),
      (0, buffer_layout_utils_1.publicKey)("memberAddress")
    ]);
    function createInitializeGroupMemberPointerInstruction(mint, authority, memberAddress, programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
      if (!(0, constants_js_1.programSupportsExtensions)(programId)) {
        throw new errors_js_1.TokenUnsupportedInstructionError();
      }
      const keys = [{ pubkey: mint, isSigner: false, isWritable: true }];
      const data = Buffer.alloc(exports2.initializeGroupMemberPointerData.span);
      exports2.initializeGroupMemberPointerData.encode({
        instruction: types_js_1.TokenInstruction.GroupMemberPointerExtension,
        groupMemberPointerInstruction: GroupMemberPointerInstruction.Initialize,
        authority: authority !== null && authority !== void 0 ? authority : web3_js_1.PublicKey.default,
        memberAddress: memberAddress !== null && memberAddress !== void 0 ? memberAddress : web3_js_1.PublicKey.default
      }, data);
      return new web3_js_1.TransactionInstruction({ keys, programId, data });
    }
    exports2.updateGroupMemberPointerData = (0, buffer_layout_1.struct)([
      // prettier-ignore
      (0, buffer_layout_1.u8)("instruction"),
      (0, buffer_layout_1.u8)("groupMemberPointerInstruction"),
      (0, buffer_layout_utils_1.publicKey)("memberAddress")
    ]);
    function createUpdateGroupMemberPointerInstruction(mint, authority, memberAddress, multiSigners = [], programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
      if (!(0, constants_js_1.programSupportsExtensions)(programId)) {
        throw new errors_js_1.TokenUnsupportedInstructionError();
      }
      const keys = (0, internal_js_1.addSigners)([{ pubkey: mint, isSigner: false, isWritable: true }], authority, multiSigners);
      const data = Buffer.alloc(exports2.updateGroupMemberPointerData.span);
      exports2.updateGroupMemberPointerData.encode({
        instruction: types_js_1.TokenInstruction.GroupMemberPointerExtension,
        groupMemberPointerInstruction: GroupMemberPointerInstruction.Update,
        memberAddress: memberAddress !== null && memberAddress !== void 0 ? memberAddress : web3_js_1.PublicKey.default
      }, data);
      return new web3_js_1.TransactionInstruction({ keys, programId, data });
    }
  }
});

// node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/extensions/groupMemberPointer/index.js
var require_groupMemberPointer = __commonJS({
  "node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/extensions/groupMemberPointer/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_instructions8(), exports2);
    __exportStar(require_state6(), exports2);
  }
});

// node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/extensions/groupPointer/instructions.js
var require_instructions9 = __commonJS({
  "node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/extensions/groupPointer/instructions.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.updateGroupPointerData = exports2.initializeGroupPointerData = exports2.GroupPointerInstruction = void 0;
    exports2.createInitializeGroupPointerInstruction = createInitializeGroupPointerInstruction;
    exports2.createUpdateGroupPointerInstruction = createUpdateGroupPointerInstruction;
    var buffer_layout_1 = require_Layout();
    var buffer_layout_utils_1 = require_cjs();
    var web3_js_1 = require("@solana/web3.js");
    var constants_js_1 = require_constants();
    var errors_js_1 = require_errors();
    var types_js_1 = require_types();
    var internal_js_1 = require_internal2();
    var GroupPointerInstruction;
    (function(GroupPointerInstruction2) {
      GroupPointerInstruction2[GroupPointerInstruction2["Initialize"] = 0] = "Initialize";
      GroupPointerInstruction2[GroupPointerInstruction2["Update"] = 1] = "Update";
    })(GroupPointerInstruction || (exports2.GroupPointerInstruction = GroupPointerInstruction = {}));
    exports2.initializeGroupPointerData = (0, buffer_layout_1.struct)([
      // prettier-ignore
      (0, buffer_layout_1.u8)("instruction"),
      (0, buffer_layout_1.u8)("groupPointerInstruction"),
      (0, buffer_layout_utils_1.publicKey)("authority"),
      (0, buffer_layout_utils_1.publicKey)("groupAddress")
    ]);
    function createInitializeGroupPointerInstruction(mint, authority, groupAddress, programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
      if (!(0, constants_js_1.programSupportsExtensions)(programId)) {
        throw new errors_js_1.TokenUnsupportedInstructionError();
      }
      const keys = [{ pubkey: mint, isSigner: false, isWritable: true }];
      const data = Buffer.alloc(exports2.initializeGroupPointerData.span);
      exports2.initializeGroupPointerData.encode({
        instruction: types_js_1.TokenInstruction.GroupPointerExtension,
        groupPointerInstruction: GroupPointerInstruction.Initialize,
        authority: authority !== null && authority !== void 0 ? authority : web3_js_1.PublicKey.default,
        groupAddress: groupAddress !== null && groupAddress !== void 0 ? groupAddress : web3_js_1.PublicKey.default
      }, data);
      return new web3_js_1.TransactionInstruction({ keys, programId, data });
    }
    exports2.updateGroupPointerData = (0, buffer_layout_1.struct)([
      // prettier-ignore
      (0, buffer_layout_1.u8)("instruction"),
      (0, buffer_layout_1.u8)("groupPointerInstruction"),
      (0, buffer_layout_utils_1.publicKey)("groupAddress")
    ]);
    function createUpdateGroupPointerInstruction(mint, authority, groupAddress, multiSigners = [], programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
      if (!(0, constants_js_1.programSupportsExtensions)(programId)) {
        throw new errors_js_1.TokenUnsupportedInstructionError();
      }
      const keys = (0, internal_js_1.addSigners)([{ pubkey: mint, isSigner: false, isWritable: true }], authority, multiSigners);
      const data = Buffer.alloc(exports2.updateGroupPointerData.span);
      exports2.updateGroupPointerData.encode({
        instruction: types_js_1.TokenInstruction.GroupPointerExtension,
        groupPointerInstruction: GroupPointerInstruction.Update,
        groupAddress: groupAddress !== null && groupAddress !== void 0 ? groupAddress : web3_js_1.PublicKey.default
      }, data);
      return new web3_js_1.TransactionInstruction({ keys, programId, data });
    }
  }
});

// node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/extensions/groupPointer/index.js
var require_groupPointer = __commonJS({
  "node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/extensions/groupPointer/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_instructions9(), exports2);
    __exportStar(require_state7(), exports2);
  }
});

// node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/instructions/initializeMint.js
var require_initializeMint = __commonJS({
  "node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/instructions/initializeMint.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.initializeMintInstructionData = void 0;
    exports2.createInitializeMintInstruction = createInitializeMintInstruction;
    exports2.decodeInitializeMintInstruction = decodeInitializeMintInstruction;
    exports2.decodeInitializeMintInstructionUnchecked = decodeInitializeMintInstructionUnchecked;
    var buffer_layout_1 = require_Layout();
    var buffer_layout_utils_1 = require_cjs();
    var web3_js_1 = require("@solana/web3.js");
    var constants_js_1 = require_constants();
    var errors_js_1 = require_errors();
    var types_js_1 = require_types();
    var serialization_js_1 = require_serialization();
    exports2.initializeMintInstructionData = (0, buffer_layout_1.struct)([
      (0, buffer_layout_1.u8)("instruction"),
      (0, buffer_layout_1.u8)("decimals"),
      (0, buffer_layout_utils_1.publicKey)("mintAuthority"),
      new serialization_js_1.COptionPublicKeyLayout("freezeAuthority")
    ]);
    function createInitializeMintInstruction(mint, decimals, mintAuthority, freezeAuthority, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      const keys = [
        { pubkey: mint, isSigner: false, isWritable: true },
        { pubkey: web3_js_1.SYSVAR_RENT_PUBKEY, isSigner: false, isWritable: false }
      ];
      const data = Buffer.alloc(67);
      exports2.initializeMintInstructionData.encode({
        instruction: types_js_1.TokenInstruction.InitializeMint,
        decimals,
        mintAuthority,
        freezeAuthority
      }, data);
      return new web3_js_1.TransactionInstruction({
        keys,
        programId,
        data: data.subarray(0, exports2.initializeMintInstructionData.getSpan(data))
      });
    }
    function decodeInitializeMintInstruction(instruction, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      if (!instruction.programId.equals(programId))
        throw new errors_js_1.TokenInvalidInstructionProgramError();
      if (instruction.data.length !== exports2.initializeMintInstructionData.getSpan(instruction.data))
        throw new errors_js_1.TokenInvalidInstructionDataError();
      const { keys: { mint, rent }, data } = decodeInitializeMintInstructionUnchecked(instruction);
      if (data.instruction !== types_js_1.TokenInstruction.InitializeMint)
        throw new errors_js_1.TokenInvalidInstructionTypeError();
      if (!mint || !rent)
        throw new errors_js_1.TokenInvalidInstructionKeysError();
      return {
        programId,
        keys: {
          mint,
          rent
        },
        data
      };
    }
    function decodeInitializeMintInstructionUnchecked({ programId, keys: [mint, rent], data }) {
      const { instruction, decimals, mintAuthority, freezeAuthority } = exports2.initializeMintInstructionData.decode(data);
      return {
        programId,
        keys: {
          mint,
          rent
        },
        data: {
          instruction,
          decimals,
          mintAuthority,
          freezeAuthority
        }
      };
    }
  }
});

// node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/extensions/interestBearingMint/instructions.js
var require_instructions10 = __commonJS({
  "node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/extensions/interestBearingMint/instructions.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.interestBearingMintUpdateRateInstructionData = exports2.interestBearingMintInitializeInstructionData = exports2.InterestBearingMintInstruction = void 0;
    exports2.createInitializeInterestBearingMintInstruction = createInitializeInterestBearingMintInstruction;
    exports2.createUpdateRateInterestBearingMintInstruction = createUpdateRateInterestBearingMintInstruction;
    var buffer_layout_1 = require_Layout();
    var buffer_layout_utils_1 = require_cjs();
    var web3_js_1 = require("@solana/web3.js");
    var constants_js_1 = require_constants();
    var internal_js_1 = require_internal2();
    var types_js_1 = require_types();
    var InterestBearingMintInstruction;
    (function(InterestBearingMintInstruction2) {
      InterestBearingMintInstruction2[InterestBearingMintInstruction2["Initialize"] = 0] = "Initialize";
      InterestBearingMintInstruction2[InterestBearingMintInstruction2["UpdateRate"] = 1] = "UpdateRate";
    })(InterestBearingMintInstruction || (exports2.InterestBearingMintInstruction = InterestBearingMintInstruction = {}));
    exports2.interestBearingMintInitializeInstructionData = (0, buffer_layout_1.struct)([
      (0, buffer_layout_1.u8)("instruction"),
      (0, buffer_layout_1.u8)("interestBearingMintInstruction"),
      // TODO: Make this an optional public key
      (0, buffer_layout_utils_1.publicKey)("rateAuthority"),
      (0, buffer_layout_1.s16)("rate")
    ]);
    exports2.interestBearingMintUpdateRateInstructionData = (0, buffer_layout_1.struct)([
      (0, buffer_layout_1.u8)("instruction"),
      (0, buffer_layout_1.u8)("interestBearingMintInstruction"),
      (0, buffer_layout_1.s16)("rate")
    ]);
    function createInitializeInterestBearingMintInstruction(mint, rateAuthority, rate, programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
      const keys = [{ pubkey: mint, isSigner: false, isWritable: true }];
      const data = Buffer.alloc(exports2.interestBearingMintInitializeInstructionData.span);
      exports2.interestBearingMintInitializeInstructionData.encode({
        instruction: types_js_1.TokenInstruction.InterestBearingMintExtension,
        interestBearingMintInstruction: InterestBearingMintInstruction.Initialize,
        rateAuthority,
        rate
      }, data);
      return new web3_js_1.TransactionInstruction({ keys, programId, data });
    }
    function createUpdateRateInterestBearingMintInstruction(mint, rateAuthority, rate, multiSigners = [], programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
      const keys = (0, internal_js_1.addSigners)([
        { pubkey: mint, isSigner: false, isWritable: true },
        { pubkey: rateAuthority, isSigner: !multiSigners.length, isWritable: false }
      ], rateAuthority, multiSigners);
      const data = Buffer.alloc(exports2.interestBearingMintUpdateRateInstructionData.span);
      exports2.interestBearingMintUpdateRateInstructionData.encode({
        instruction: types_js_1.TokenInstruction.InterestBearingMintExtension,
        interestBearingMintInstruction: InterestBearingMintInstruction.UpdateRate,
        rate
      }, data);
      return new web3_js_1.TransactionInstruction({ keys, programId, data });
    }
  }
});

// node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/extensions/interestBearingMint/actions.js
var require_actions10 = __commonJS({
  "node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/extensions/interestBearingMint/actions.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createInterestBearingMint = createInterestBearingMint;
    exports2.updateRateInterestBearingMint = updateRateInterestBearingMint;
    var web3_js_1 = require("@solana/web3.js");
    var internal_js_1 = require_internal();
    var constants_js_1 = require_constants();
    var initializeMint_js_1 = require_initializeMint();
    var extensionType_js_1 = require_extensionType();
    var instructions_js_1 = require_instructions10();
    function createInterestBearingMint(connection_1, payer_1, mintAuthority_1, freezeAuthority_1, rateAuthority_1, rate_1, decimals_1) {
      return __awaiter(this, arguments, void 0, function* (connection, payer, mintAuthority, freezeAuthority, rateAuthority, rate, decimals, keypair = web3_js_1.Keypair.generate(), confirmOptions, programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
        const mintLen = (0, extensionType_js_1.getMintLen)([extensionType_js_1.ExtensionType.InterestBearingConfig]);
        const lamports = yield connection.getMinimumBalanceForRentExemption(mintLen);
        const transaction = new web3_js_1.Transaction().add(web3_js_1.SystemProgram.createAccount({
          fromPubkey: payer.publicKey,
          newAccountPubkey: keypair.publicKey,
          space: mintLen,
          lamports,
          programId
        }), (0, instructions_js_1.createInitializeInterestBearingMintInstruction)(keypair.publicKey, rateAuthority, rate, programId), (0, initializeMint_js_1.createInitializeMintInstruction)(keypair.publicKey, decimals, mintAuthority, freezeAuthority, programId));
        yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer, keypair], confirmOptions);
        return keypair.publicKey;
      });
    }
    function updateRateInterestBearingMint(connection_1, payer_1, mint_1, rateAuthority_1, rate_1) {
      return __awaiter(this, arguments, void 0, function* (connection, payer, mint, rateAuthority, rate, multiSigners = [], confirmOptions, programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
        const [rateAuthorityPublicKey, signers] = (0, internal_js_1.getSigners)(rateAuthority, multiSigners);
        const transaction = new web3_js_1.Transaction().add((0, instructions_js_1.createUpdateRateInterestBearingMintInstruction)(mint, rateAuthorityPublicKey, rate, signers, programId));
        return yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer, rateAuthority, ...signers], confirmOptions);
      });
    }
  }
});

// node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/extensions/interestBearingMint/index.js
var require_interestBearingMint = __commonJS({
  "node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/extensions/interestBearingMint/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_actions10(), exports2);
    __exportStar(require_instructions10(), exports2);
    __exportStar(require_state8(), exports2);
  }
});

// node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/extensions/metadataPointer/instructions.js
var require_instructions11 = __commonJS({
  "node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/extensions/metadataPointer/instructions.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.updateMetadataPointerData = exports2.initializeMetadataPointerData = exports2.MetadataPointerInstruction = void 0;
    exports2.createInitializeMetadataPointerInstruction = createInitializeMetadataPointerInstruction;
    exports2.createUpdateMetadataPointerInstruction = createUpdateMetadataPointerInstruction;
    var buffer_layout_1 = require_Layout();
    var buffer_layout_utils_1 = require_cjs();
    var web3_js_1 = require("@solana/web3.js");
    var constants_js_1 = require_constants();
    var errors_js_1 = require_errors();
    var types_js_1 = require_types();
    var internal_js_1 = require_internal2();
    var MetadataPointerInstruction;
    (function(MetadataPointerInstruction2) {
      MetadataPointerInstruction2[MetadataPointerInstruction2["Initialize"] = 0] = "Initialize";
      MetadataPointerInstruction2[MetadataPointerInstruction2["Update"] = 1] = "Update";
    })(MetadataPointerInstruction || (exports2.MetadataPointerInstruction = MetadataPointerInstruction = {}));
    exports2.initializeMetadataPointerData = (0, buffer_layout_1.struct)([
      // prettier-ignore
      (0, buffer_layout_1.u8)("instruction"),
      (0, buffer_layout_1.u8)("metadataPointerInstruction"),
      (0, buffer_layout_utils_1.publicKey)("authority"),
      (0, buffer_layout_utils_1.publicKey)("metadataAddress")
    ]);
    function createInitializeMetadataPointerInstruction(mint, authority, metadataAddress, programId) {
      if (!(0, constants_js_1.programSupportsExtensions)(programId)) {
        throw new errors_js_1.TokenUnsupportedInstructionError();
      }
      const keys = [{ pubkey: mint, isSigner: false, isWritable: true }];
      const data = Buffer.alloc(exports2.initializeMetadataPointerData.span);
      exports2.initializeMetadataPointerData.encode({
        instruction: types_js_1.TokenInstruction.MetadataPointerExtension,
        metadataPointerInstruction: MetadataPointerInstruction.Initialize,
        authority: authority !== null && authority !== void 0 ? authority : web3_js_1.PublicKey.default,
        metadataAddress: metadataAddress !== null && metadataAddress !== void 0 ? metadataAddress : web3_js_1.PublicKey.default
      }, data);
      return new web3_js_1.TransactionInstruction({ keys, programId, data });
    }
    exports2.updateMetadataPointerData = (0, buffer_layout_1.struct)([
      // prettier-ignore
      (0, buffer_layout_1.u8)("instruction"),
      (0, buffer_layout_1.u8)("metadataPointerInstruction"),
      (0, buffer_layout_utils_1.publicKey)("metadataAddress")
    ]);
    function createUpdateMetadataPointerInstruction(mint, authority, metadataAddress, multiSigners = [], programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
      if (!(0, constants_js_1.programSupportsExtensions)(programId)) {
        throw new errors_js_1.TokenUnsupportedInstructionError();
      }
      const keys = (0, internal_js_1.addSigners)([{ pubkey: mint, isSigner: false, isWritable: true }], authority, multiSigners);
      const data = Buffer.alloc(exports2.updateMetadataPointerData.span);
      exports2.updateMetadataPointerData.encode({
        instruction: types_js_1.TokenInstruction.MetadataPointerExtension,
        metadataPointerInstruction: MetadataPointerInstruction.Update,
        metadataAddress: metadataAddress !== null && metadataAddress !== void 0 ? metadataAddress : web3_js_1.PublicKey.default
      }, data);
      return new web3_js_1.TransactionInstruction({ keys, programId, data });
    }
  }
});

// node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/extensions/metadataPointer/index.js
var require_metadataPointer = __commonJS({
  "node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/extensions/metadataPointer/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_instructions11(), exports2);
    __exportStar(require_state10(), exports2);
  }
});

// node_modules/@solana/spl-token-metadata/lib/cjs/errors.js
var require_errors3 = __commonJS({
  "node_modules/@solana/spl-token-metadata/lib/cjs/errors.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.KeyNotFoundError = exports2.ImmutableMetadataError = exports2.IncorrectUpdateAuthorityError = exports2.IncorrectMintAuthorityError = exports2.MintHasNoMintAuthorityError = exports2.IncorrectAccountError = exports2.TokenMetadataError = void 0;
    var TokenMetadataError = class extends Error {
      constructor(message) {
        super(message);
      }
    };
    exports2.TokenMetadataError = TokenMetadataError;
    var IncorrectAccountError = class extends TokenMetadataError {
      constructor() {
        super(...arguments);
        this.name = "IncorrectAccountError";
      }
    };
    exports2.IncorrectAccountError = IncorrectAccountError;
    var MintHasNoMintAuthorityError = class extends TokenMetadataError {
      constructor() {
        super(...arguments);
        this.name = "MintHasNoMintAuthorityError";
      }
    };
    exports2.MintHasNoMintAuthorityError = MintHasNoMintAuthorityError;
    var IncorrectMintAuthorityError = class extends TokenMetadataError {
      constructor() {
        super(...arguments);
        this.name = "IncorrectMintAuthorityError";
      }
    };
    exports2.IncorrectMintAuthorityError = IncorrectMintAuthorityError;
    var IncorrectUpdateAuthorityError = class extends TokenMetadataError {
      constructor() {
        super(...arguments);
        this.name = "IncorrectUpdateAuthorityError";
      }
    };
    exports2.IncorrectUpdateAuthorityError = IncorrectUpdateAuthorityError;
    var ImmutableMetadataError = class extends TokenMetadataError {
      constructor() {
        super(...arguments);
        this.name = "ImmutableMetadataError";
      }
    };
    exports2.ImmutableMetadataError = ImmutableMetadataError;
    var KeyNotFoundError = class extends TokenMetadataError {
      constructor() {
        super(...arguments);
        this.name = "KeyNotFoundError";
      }
    };
    exports2.KeyNotFoundError = KeyNotFoundError;
  }
});

// node_modules/@solana/spl-token-metadata/lib/cjs/field.js
var require_field = __commonJS({
  "node_modules/@solana/spl-token-metadata/lib/cjs/field.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getFieldCodec = exports2.Field = void 0;
    exports2.getFieldConfig = getFieldConfig;
    var codecs_1 = require_index_node7();
    var Field;
    (function(Field2) {
      Field2[Field2["Name"] = 0] = "Name";
      Field2[Field2["Symbol"] = 1] = "Symbol";
      Field2[Field2["Uri"] = 2] = "Uri";
    })(Field || (exports2.Field = Field = {}));
    var getFieldCodec = () => [
      ["Name", (0, codecs_1.getUnitCodec)()],
      ["Symbol", (0, codecs_1.getUnitCodec)()],
      ["Uri", (0, codecs_1.getUnitCodec)()],
      ["Key", (0, codecs_1.getStructCodec)([["value", (0, codecs_1.getTupleCodec)([(0, codecs_1.addCodecSizePrefix)((0, codecs_1.getUtf8Codec)(), (0, codecs_1.getU32Codec)())])]])]
    ];
    exports2.getFieldCodec = getFieldCodec;
    function getFieldConfig(field) {
      if (field === Field.Name || field === "Name" || field === "name") {
        return { __kind: "Name" };
      } else if (field === Field.Symbol || field === "Symbol" || field === "symbol") {
        return { __kind: "Symbol" };
      } else if (field === Field.Uri || field === "Uri" || field === "uri") {
        return { __kind: "Uri" };
      } else {
        return { __kind: "Key", value: [field] };
      }
    }
  }
});

// node_modules/@solana/spl-token-metadata/lib/cjs/instruction.js
var require_instruction2 = __commonJS({
  "node_modules/@solana/spl-token-metadata/lib/cjs/instruction.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createInitializeInstruction = createInitializeInstruction;
    exports2.createUpdateFieldInstruction = createUpdateFieldInstruction;
    exports2.createRemoveKeyInstruction = createRemoveKeyInstruction;
    exports2.createUpdateAuthorityInstruction = createUpdateAuthorityInstruction;
    exports2.createEmitInstruction = createEmitInstruction;
    var codecs_1 = require_index_node7();
    var web3_js_1 = require("@solana/web3.js");
    var field_js_1 = require_field();
    function getInstructionEncoder(discriminator, dataEncoder) {
      return (0, codecs_1.transformEncoder)((0, codecs_1.getTupleEncoder)([(0, codecs_1.getBytesEncoder)(), dataEncoder]), (data) => [
        discriminator,
        data
      ]);
    }
    function getPublicKeyEncoder() {
      return (0, codecs_1.transformEncoder)((0, codecs_1.fixEncoderSize)((0, codecs_1.getBytesEncoder)(), 32), (publicKey3) => publicKey3.toBytes());
    }
    function getStringEncoder() {
      return (0, codecs_1.addEncoderSizePrefix)((0, codecs_1.getUtf8Encoder)(), (0, codecs_1.getU32Encoder)());
    }
    function createInitializeInstruction(args) {
      const { programId, metadata, updateAuthority, mint, mintAuthority, name, symbol, uri } = args;
      return new web3_js_1.TransactionInstruction({
        programId,
        keys: [
          { isSigner: false, isWritable: true, pubkey: metadata },
          { isSigner: false, isWritable: false, pubkey: updateAuthority },
          { isSigner: false, isWritable: false, pubkey: mint },
          { isSigner: true, isWritable: false, pubkey: mintAuthority }
        ],
        data: Buffer.from(getInstructionEncoder(new Uint8Array([
          /* await splDiscriminate('spl_token_metadata_interface:initialize_account') */
          210,
          225,
          30,
          162,
          88,
          184,
          77,
          141
        ]), (0, codecs_1.getStructEncoder)([
          ["name", getStringEncoder()],
          ["symbol", getStringEncoder()],
          ["uri", getStringEncoder()]
        ])).encode({ name, symbol, uri }))
      });
    }
    function createUpdateFieldInstruction(args) {
      const { programId, metadata, updateAuthority, field, value } = args;
      return new web3_js_1.TransactionInstruction({
        programId,
        keys: [
          { isSigner: false, isWritable: true, pubkey: metadata },
          { isSigner: true, isWritable: false, pubkey: updateAuthority }
        ],
        data: Buffer.from(getInstructionEncoder(new Uint8Array([
          /* await splDiscriminate('spl_token_metadata_interface:updating_field') */
          221,
          233,
          49,
          45,
          181,
          202,
          220,
          200
        ]), (0, codecs_1.getStructEncoder)([
          ["field", (0, codecs_1.getDataEnumCodec)((0, field_js_1.getFieldCodec)())],
          ["value", getStringEncoder()]
        ])).encode({ field: (0, field_js_1.getFieldConfig)(field), value }))
      });
    }
    function createRemoveKeyInstruction(args) {
      const { programId, metadata, updateAuthority, key, idempotent } = args;
      return new web3_js_1.TransactionInstruction({
        programId,
        keys: [
          { isSigner: false, isWritable: true, pubkey: metadata },
          { isSigner: true, isWritable: false, pubkey: updateAuthority }
        ],
        data: Buffer.from(getInstructionEncoder(new Uint8Array([
          /* await splDiscriminate('spl_token_metadata_interface:remove_key_ix') */
          234,
          18,
          32,
          56,
          89,
          141,
          37,
          181
        ]), (0, codecs_1.getStructEncoder)([
          ["idempotent", (0, codecs_1.getBooleanEncoder)()],
          ["key", getStringEncoder()]
        ])).encode({ idempotent, key }))
      });
    }
    function createUpdateAuthorityInstruction(args) {
      const { programId, metadata, oldAuthority, newAuthority } = args;
      return new web3_js_1.TransactionInstruction({
        programId,
        keys: [
          { isSigner: false, isWritable: true, pubkey: metadata },
          { isSigner: true, isWritable: false, pubkey: oldAuthority }
        ],
        data: Buffer.from(getInstructionEncoder(new Uint8Array([
          /* await splDiscriminate('spl_token_metadata_interface:update_the_authority') */
          215,
          228,
          166,
          228,
          84,
          100,
          86,
          123
        ]), (0, codecs_1.getStructEncoder)([["newAuthority", getPublicKeyEncoder()]])).encode({ newAuthority: newAuthority !== null && newAuthority !== void 0 ? newAuthority : web3_js_1.SystemProgram.programId }))
      });
    }
    function createEmitInstruction(args) {
      const { programId, metadata, start, end } = args;
      return new web3_js_1.TransactionInstruction({
        programId,
        keys: [{ isSigner: false, isWritable: false, pubkey: metadata }],
        data: Buffer.from(getInstructionEncoder(new Uint8Array([
          /* await splDiscriminate('spl_token_metadata_interface:emitter') */
          250,
          166,
          180,
          250,
          13,
          12,
          184,
          70
        ]), (0, codecs_1.getStructEncoder)([
          ["start", (0, codecs_1.getOptionEncoder)((0, codecs_1.getU64Encoder)())],
          ["end", (0, codecs_1.getOptionEncoder)((0, codecs_1.getU64Encoder)())]
        ])).encode({ start: start !== null && start !== void 0 ? start : null, end: end !== null && end !== void 0 ? end : null }))
      });
    }
  }
});

// node_modules/@solana/spl-token-metadata/lib/cjs/state.js
var require_state15 = __commonJS({
  "node_modules/@solana/spl-token-metadata/lib/cjs/state.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TOKEN_METADATA_DISCRIMINATOR = void 0;
    exports2.pack = pack;
    exports2.unpack = unpack;
    var web3_js_1 = require("@solana/web3.js");
    var codecs_1 = require_index_node7();
    exports2.TOKEN_METADATA_DISCRIMINATOR = Buffer.from([112, 132, 90, 90, 11, 88, 157, 87]);
    function getStringCodec() {
      return (0, codecs_1.addCodecSizePrefix)((0, codecs_1.getUtf8Codec)(), (0, codecs_1.getU32Codec)());
    }
    var tokenMetadataCodec = (0, codecs_1.getStructCodec)([
      ["updateAuthority", (0, codecs_1.fixCodecSize)((0, codecs_1.getBytesCodec)(), 32)],
      ["mint", (0, codecs_1.fixCodecSize)((0, codecs_1.getBytesCodec)(), 32)],
      ["name", getStringCodec()],
      ["symbol", getStringCodec()],
      ["uri", getStringCodec()],
      ["additionalMetadata", (0, codecs_1.getArrayCodec)((0, codecs_1.getTupleCodec)([getStringCodec(), getStringCodec()]))]
    ]);
    function isNonePubkey(buffer) {
      for (let i = 0; i < buffer.length; i++) {
        if (buffer[i] !== 0) {
          return false;
        }
      }
      return true;
    }
    function pack(meta) {
      var _a;
      const updateAuthority = (_a = meta.updateAuthority) !== null && _a !== void 0 ? _a : web3_js_1.PublicKey.default;
      return tokenMetadataCodec.encode(Object.assign(Object.assign({}, meta), { updateAuthority: updateAuthority.toBuffer(), mint: meta.mint.toBuffer() }));
    }
    function unpack(buffer) {
      const data = tokenMetadataCodec.decode(buffer);
      return isNonePubkey(data.updateAuthority) ? {
        mint: new web3_js_1.PublicKey(data.mint),
        name: data.name,
        symbol: data.symbol,
        uri: data.uri,
        additionalMetadata: data.additionalMetadata
      } : {
        updateAuthority: new web3_js_1.PublicKey(data.updateAuthority),
        mint: new web3_js_1.PublicKey(data.mint),
        name: data.name,
        symbol: data.symbol,
        uri: data.uri,
        additionalMetadata: data.additionalMetadata
      };
    }
  }
});

// node_modules/@solana/spl-token-metadata/lib/cjs/index.js
var require_cjs3 = __commonJS({
  "node_modules/@solana/spl-token-metadata/lib/cjs/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_errors3(), exports2);
    __exportStar(require_field(), exports2);
    __exportStar(require_instruction2(), exports2);
    __exportStar(require_state15(), exports2);
  }
});

// node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/extensions/tokenMetadata/state.js
var require_state16 = __commonJS({
  "node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/extensions/tokenMetadata/state.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.updateTokenMetadata = updateTokenMetadata;
    exports2.getTokenMetadata = getTokenMetadata;
    var spl_token_metadata_1 = require_cjs3();
    var constants_js_1 = require_constants();
    var extensionType_js_1 = require_extensionType();
    var mint_js_1 = require_mint();
    var getNormalizedTokenMetadataField = (field) => {
      if (field === spl_token_metadata_1.Field.Name || field === "Name" || field === "name") {
        return "name";
      }
      if (field === spl_token_metadata_1.Field.Symbol || field === "Symbol" || field === "symbol") {
        return "symbol";
      }
      if (field === spl_token_metadata_1.Field.Uri || field === "Uri" || field === "uri") {
        return "uri";
      }
      return field;
    };
    function updateTokenMetadata(current, key, value) {
      const field = getNormalizedTokenMetadataField(key);
      if (field === "mint" || field === "updateAuthority") {
        throw new Error(`Cannot update ${field} via this instruction`);
      }
      if (["name", "symbol", "uri"].includes(field)) {
        return Object.assign(Object.assign({}, current), { [field]: value });
      }
      const additionalMetadata = [...current.additionalMetadata];
      const i = current.additionalMetadata.findIndex((x) => x[0] === field);
      if (i === -1) {
        additionalMetadata.push([field, value]);
      } else {
        additionalMetadata[i] = [field, value];
      }
      return Object.assign(Object.assign({}, current), { additionalMetadata });
    }
    function getTokenMetadata(connection_1, address_1, commitment_1) {
      return __awaiter(this, arguments, void 0, function* (connection, address, commitment, programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
        const mintInfo = yield (0, mint_js_1.getMint)(connection, address, commitment, programId);
        const data = (0, extensionType_js_1.getExtensionData)(extensionType_js_1.ExtensionType.TokenMetadata, mintInfo.tlvData);
        if (data === null) {
          return null;
        }
        return (0, spl_token_metadata_1.unpack)(data);
      });
    }
  }
});

// node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/state/index.js
var require_state17 = __commonJS({
  "node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/state/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_account(), exports2);
    __exportStar(require_mint(), exports2);
    __exportStar(require_multisig(), exports2);
  }
});

// node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/extensions/tokenMetadata/actions.js
var require_actions11 = __commonJS({
  "node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/extensions/tokenMetadata/actions.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.tokenMetadataInitialize = tokenMetadataInitialize;
    exports2.tokenMetadataInitializeWithRentTransfer = tokenMetadataInitializeWithRentTransfer;
    exports2.tokenMetadataUpdateField = tokenMetadataUpdateField;
    exports2.tokenMetadataUpdateFieldWithRentTransfer = tokenMetadataUpdateFieldWithRentTransfer;
    exports2.tokenMetadataRemoveKey = tokenMetadataRemoveKey;
    exports2.tokenMetadataUpdateAuthority = tokenMetadataUpdateAuthority;
    var web3_js_1 = require("@solana/web3.js");
    var spl_token_metadata_1 = require_cjs3();
    var constants_js_1 = require_constants();
    var internal_js_1 = require_internal();
    var extensionType_js_1 = require_extensionType();
    var state_js_1 = require_state16();
    var errors_js_1 = require_errors();
    var index_js_1 = require_state17();
    function getAdditionalRentForNewMetadata(connection_1, address_1, tokenMetadata_1) {
      return __awaiter(this, arguments, void 0, function* (connection, address, tokenMetadata, programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
        const info = yield connection.getAccountInfo(address);
        if (!info) {
          throw new errors_js_1.TokenAccountNotFoundError();
        }
        const extensionLen = (0, spl_token_metadata_1.pack)(tokenMetadata).length;
        const newAccountLen = (0, extensionType_js_1.getNewAccountLenForExtensionLen)(info, address, extensionType_js_1.ExtensionType.TokenMetadata, extensionLen, programId);
        if (newAccountLen <= info.data.length) {
          return 0;
        }
        const newRentExemptMinimum = yield connection.getMinimumBalanceForRentExemption(newAccountLen);
        return newRentExemptMinimum - info.lamports;
      });
    }
    function getAdditionalRentForUpdatedMetadata(connection_1, address_1, field_1, value_1) {
      return __awaiter(this, arguments, void 0, function* (connection, address, field, value, programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
        const info = yield connection.getAccountInfo(address);
        if (!info) {
          throw new errors_js_1.TokenAccountNotFoundError();
        }
        const mint = (0, index_js_1.unpackMint)(address, info, programId);
        const extensionData = (0, extensionType_js_1.getExtensionData)(extensionType_js_1.ExtensionType.TokenMetadata, mint.tlvData);
        if (extensionData === null) {
          throw new Error("TokenMetadata extension not initialized");
        }
        const updatedTokenMetadata = (0, state_js_1.updateTokenMetadata)((0, spl_token_metadata_1.unpack)(extensionData), field, value);
        const extensionLen = (0, spl_token_metadata_1.pack)(updatedTokenMetadata).length;
        const newAccountLen = (0, extensionType_js_1.getNewAccountLenForExtensionLen)(info, address, extensionType_js_1.ExtensionType.TokenMetadata, extensionLen, programId);
        if (newAccountLen <= info.data.length) {
          return 0;
        }
        const newRentExemptMinimum = yield connection.getMinimumBalanceForRentExemption(newAccountLen);
        return newRentExemptMinimum - info.lamports;
      });
    }
    function tokenMetadataInitialize(connection_1, payer_1, mint_1, updateAuthority_1, mintAuthority_1, name_1, symbol_1, uri_1) {
      return __awaiter(this, arguments, void 0, function* (connection, payer, mint, updateAuthority, mintAuthority, name, symbol, uri, multiSigners = [], confirmOptions, programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
        const [mintAuthorityPublicKey, signers] = (0, internal_js_1.getSigners)(mintAuthority, multiSigners);
        const transaction = new web3_js_1.Transaction().add((0, spl_token_metadata_1.createInitializeInstruction)({
          programId,
          metadata: mint,
          updateAuthority,
          mint,
          mintAuthority: mintAuthorityPublicKey,
          name,
          symbol,
          uri
        }));
        return yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer, ...signers], confirmOptions);
      });
    }
    function tokenMetadataInitializeWithRentTransfer(connection_1, payer_1, mint_1, updateAuthority_1, mintAuthority_1, name_1, symbol_1, uri_1) {
      return __awaiter(this, arguments, void 0, function* (connection, payer, mint, updateAuthority, mintAuthority, name, symbol, uri, multiSigners = [], confirmOptions, programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
        const [mintAuthorityPublicKey, signers] = (0, internal_js_1.getSigners)(mintAuthority, multiSigners);
        const transaction = new web3_js_1.Transaction();
        const lamports = yield getAdditionalRentForNewMetadata(connection, mint, {
          updateAuthority,
          mint,
          name,
          symbol,
          uri,
          additionalMetadata: []
        }, programId);
        if (lamports > 0) {
          transaction.add(web3_js_1.SystemProgram.transfer({ fromPubkey: payer.publicKey, toPubkey: mint, lamports }));
        }
        transaction.add((0, spl_token_metadata_1.createInitializeInstruction)({
          programId,
          metadata: mint,
          updateAuthority,
          mint,
          mintAuthority: mintAuthorityPublicKey,
          name,
          symbol,
          uri
        }));
        return yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer, ...signers], confirmOptions);
      });
    }
    function tokenMetadataUpdateField(connection_1, payer_1, mint_1, updateAuthority_1, field_1, value_1) {
      return __awaiter(this, arguments, void 0, function* (connection, payer, mint, updateAuthority, field, value, multiSigners = [], confirmOptions, programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
        const [updateAuthorityPublicKey, signers] = (0, internal_js_1.getSigners)(updateAuthority, multiSigners);
        const transaction = new web3_js_1.Transaction().add((0, spl_token_metadata_1.createUpdateFieldInstruction)({
          programId,
          metadata: mint,
          updateAuthority: updateAuthorityPublicKey,
          field,
          value
        }));
        return yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer, ...signers], confirmOptions);
      });
    }
    function tokenMetadataUpdateFieldWithRentTransfer(connection_1, payer_1, mint_1, updateAuthority_1, field_1, value_1) {
      return __awaiter(this, arguments, void 0, function* (connection, payer, mint, updateAuthority, field, value, multiSigners = [], confirmOptions, programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
        const [updateAuthorityPublicKey, signers] = (0, internal_js_1.getSigners)(updateAuthority, multiSigners);
        const transaction = new web3_js_1.Transaction();
        const lamports = yield getAdditionalRentForUpdatedMetadata(connection, mint, field, value, programId);
        if (lamports > 0) {
          transaction.add(web3_js_1.SystemProgram.transfer({ fromPubkey: payer.publicKey, toPubkey: mint, lamports }));
        }
        transaction.add((0, spl_token_metadata_1.createUpdateFieldInstruction)({
          programId,
          metadata: mint,
          updateAuthority: updateAuthorityPublicKey,
          field,
          value
        }));
        return yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer, ...signers], confirmOptions);
      });
    }
    function tokenMetadataRemoveKey(connection_1, payer_1, mint_1, updateAuthority_1, key_1, idempotent_1) {
      return __awaiter(this, arguments, void 0, function* (connection, payer, mint, updateAuthority, key, idempotent, multiSigners = [], confirmOptions, programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
        const [updateAuthorityPublicKey, signers] = (0, internal_js_1.getSigners)(updateAuthority, multiSigners);
        const transaction = new web3_js_1.Transaction().add((0, spl_token_metadata_1.createRemoveKeyInstruction)({
          programId,
          metadata: mint,
          updateAuthority: updateAuthorityPublicKey,
          key,
          idempotent
        }));
        return yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer, ...signers], confirmOptions);
      });
    }
    function tokenMetadataUpdateAuthority(connection_1, payer_1, mint_1, updateAuthority_1, newAuthority_1) {
      return __awaiter(this, arguments, void 0, function* (connection, payer, mint, updateAuthority, newAuthority, multiSigners = [], confirmOptions, programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
        const [updateAuthorityPublicKey, signers] = (0, internal_js_1.getSigners)(updateAuthority, multiSigners);
        const transaction = new web3_js_1.Transaction().add((0, spl_token_metadata_1.createUpdateAuthorityInstruction)({
          programId,
          metadata: mint,
          oldAuthority: updateAuthorityPublicKey,
          newAuthority
        }));
        return yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer, ...signers], confirmOptions);
      });
    }
  }
});

// node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/extensions/tokenMetadata/index.js
var require_tokenMetadata = __commonJS({
  "node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/extensions/tokenMetadata/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_actions11(), exports2);
    __exportStar(require_state16(), exports2);
  }
});

// node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/extensions/index.js
var require_extensions = __commonJS({
  "node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/extensions/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_accountType(), exports2);
    __exportStar(require_cpiGuard(), exports2);
    __exportStar(require_defaultAccountState(), exports2);
    __exportStar(require_extensionType(), exports2);
    __exportStar(require_groupMemberPointer(), exports2);
    __exportStar(require_groupPointer(), exports2);
    __exportStar(require_immutableOwner(), exports2);
    __exportStar(require_interestBearingMint(), exports2);
    __exportStar(require_memoTransfer(), exports2);
    __exportStar(require_metadataPointer(), exports2);
    __exportStar(require_scaledUiAmount(), exports2);
    __exportStar(require_tokenGroup2(), exports2);
    __exportStar(require_tokenMetadata(), exports2);
    __exportStar(require_mintCloseAuthority(), exports2);
    __exportStar(require_nonTransferable(), exports2);
    __exportStar(require_transferFee(), exports2);
    __exportStar(require_permanentDelegate(), exports2);
    __exportStar(require_transferHook(), exports2);
    __exportStar(require_pausable(), exports2);
  }
});

// node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/instructions/initializeAccount2.js
var require_initializeAccount2 = __commonJS({
  "node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/instructions/initializeAccount2.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.initializeAccount2InstructionData = void 0;
    exports2.createInitializeAccount2Instruction = createInitializeAccount2Instruction;
    exports2.decodeInitializeAccount2Instruction = decodeInitializeAccount2Instruction;
    exports2.decodeInitializeAccount2InstructionUnchecked = decodeInitializeAccount2InstructionUnchecked;
    var buffer_layout_1 = require_Layout();
    var buffer_layout_utils_1 = require_cjs();
    var web3_js_1 = require("@solana/web3.js");
    var constants_js_1 = require_constants();
    var errors_js_1 = require_errors();
    var types_js_1 = require_types();
    exports2.initializeAccount2InstructionData = (0, buffer_layout_1.struct)([
      (0, buffer_layout_1.u8)("instruction"),
      (0, buffer_layout_utils_1.publicKey)("owner")
    ]);
    function createInitializeAccount2Instruction(account, mint, owner, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      const keys = [
        { pubkey: account, isSigner: false, isWritable: true },
        { pubkey: mint, isSigner: false, isWritable: false },
        { pubkey: web3_js_1.SYSVAR_RENT_PUBKEY, isSigner: false, isWritable: false }
      ];
      const data = Buffer.alloc(exports2.initializeAccount2InstructionData.span);
      exports2.initializeAccount2InstructionData.encode({ instruction: types_js_1.TokenInstruction.InitializeAccount2, owner }, data);
      return new web3_js_1.TransactionInstruction({ keys, programId, data });
    }
    function decodeInitializeAccount2Instruction(instruction, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      if (!instruction.programId.equals(programId))
        throw new errors_js_1.TokenInvalidInstructionProgramError();
      if (instruction.data.length !== exports2.initializeAccount2InstructionData.span)
        throw new errors_js_1.TokenInvalidInstructionDataError();
      const { keys: { account, mint, rent }, data } = decodeInitializeAccount2InstructionUnchecked(instruction);
      if (data.instruction !== types_js_1.TokenInstruction.InitializeAccount2)
        throw new errors_js_1.TokenInvalidInstructionTypeError();
      if (!account || !mint || !rent)
        throw new errors_js_1.TokenInvalidInstructionKeysError();
      return {
        programId,
        keys: {
          account,
          mint,
          rent
        },
        data
      };
    }
    function decodeInitializeAccount2InstructionUnchecked({ programId, keys: [account, mint, rent], data }) {
      return {
        programId,
        keys: {
          account,
          mint,
          rent
        },
        data: exports2.initializeAccount2InstructionData.decode(data)
      };
    }
  }
});

// node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/instructions/initializeAccount3.js
var require_initializeAccount3 = __commonJS({
  "node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/instructions/initializeAccount3.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.initializeAccount3InstructionData = void 0;
    exports2.createInitializeAccount3Instruction = createInitializeAccount3Instruction;
    exports2.decodeInitializeAccount3Instruction = decodeInitializeAccount3Instruction;
    exports2.decodeInitializeAccount3InstructionUnchecked = decodeInitializeAccount3InstructionUnchecked;
    var buffer_layout_1 = require_Layout();
    var buffer_layout_utils_1 = require_cjs();
    var web3_js_1 = require("@solana/web3.js");
    var constants_js_1 = require_constants();
    var errors_js_1 = require_errors();
    var types_js_1 = require_types();
    exports2.initializeAccount3InstructionData = (0, buffer_layout_1.struct)([
      (0, buffer_layout_1.u8)("instruction"),
      (0, buffer_layout_utils_1.publicKey)("owner")
    ]);
    function createInitializeAccount3Instruction(account, mint, owner, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      const keys = [
        { pubkey: account, isSigner: false, isWritable: true },
        { pubkey: mint, isSigner: false, isWritable: false }
      ];
      const data = Buffer.alloc(exports2.initializeAccount3InstructionData.span);
      exports2.initializeAccount3InstructionData.encode({ instruction: types_js_1.TokenInstruction.InitializeAccount3, owner }, data);
      return new web3_js_1.TransactionInstruction({ keys, programId, data });
    }
    function decodeInitializeAccount3Instruction(instruction, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      if (!instruction.programId.equals(programId))
        throw new errors_js_1.TokenInvalidInstructionProgramError();
      if (instruction.data.length !== exports2.initializeAccount3InstructionData.span)
        throw new errors_js_1.TokenInvalidInstructionDataError();
      const { keys: { account, mint }, data } = decodeInitializeAccount3InstructionUnchecked(instruction);
      if (data.instruction !== types_js_1.TokenInstruction.InitializeAccount3)
        throw new errors_js_1.TokenInvalidInstructionTypeError();
      if (!account || !mint)
        throw new errors_js_1.TokenInvalidInstructionKeysError();
      return {
        programId,
        keys: {
          account,
          mint
        },
        data
      };
    }
    function decodeInitializeAccount3InstructionUnchecked({ programId, keys: [account, mint], data }) {
      return {
        programId,
        keys: {
          account,
          mint
        },
        data: exports2.initializeAccount3InstructionData.decode(data)
      };
    }
  }
});

// node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/instructions/decode.js
var require_decode = __commonJS({
  "node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/instructions/decode.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.decodeInstruction = decodeInstruction;
    exports2.isInitializeMintInstruction = isInitializeMintInstruction;
    exports2.isInitializeAccountInstruction = isInitializeAccountInstruction;
    exports2.isInitializeMultisigInstruction = isInitializeMultisigInstruction;
    exports2.isTransferInstruction = isTransferInstruction;
    exports2.isApproveInstruction = isApproveInstruction;
    exports2.isRevokeInstruction = isRevokeInstruction;
    exports2.isSetAuthorityInstruction = isSetAuthorityInstruction;
    exports2.isMintToInstruction = isMintToInstruction;
    exports2.isBurnInstruction = isBurnInstruction;
    exports2.isCloseAccountInstruction = isCloseAccountInstruction;
    exports2.isFreezeAccountInstruction = isFreezeAccountInstruction;
    exports2.isThawAccountInstruction = isThawAccountInstruction;
    exports2.isTransferCheckedInstruction = isTransferCheckedInstruction;
    exports2.isApproveCheckedInstruction = isApproveCheckedInstruction;
    exports2.isMintToCheckedInstruction = isMintToCheckedInstruction;
    exports2.isBurnCheckedInstruction = isBurnCheckedInstruction;
    exports2.isInitializeAccount2Instruction = isInitializeAccount2Instruction;
    exports2.isSyncNativeInstruction = isSyncNativeInstruction;
    exports2.isInitializeAccount3Instruction = isInitializeAccount3Instruction;
    exports2.isInitializeMint2Instruction = isInitializeMint2Instruction;
    exports2.isAmountToUiAmountInstruction = isAmountToUiAmountInstruction;
    exports2.isUiamountToAmountInstruction = isUiamountToAmountInstruction;
    var buffer_layout_1 = require_Layout();
    var constants_js_1 = require_constants();
    var errors_js_1 = require_errors();
    var amountToUiAmount_js_1 = require_amountToUiAmount();
    var approve_js_1 = require_approve();
    var approveChecked_js_1 = require_approveChecked();
    var burn_js_1 = require_burn();
    var burnChecked_js_1 = require_burnChecked();
    var closeAccount_js_1 = require_closeAccount();
    var freezeAccount_js_1 = require_freezeAccount();
    var initializeAccount_js_1 = require_initializeAccount();
    var initializeAccount2_js_1 = require_initializeAccount2();
    var initializeAccount3_js_1 = require_initializeAccount3();
    var initializeMint_js_1 = require_initializeMint();
    var initializeMint2_js_1 = require_initializeMint2();
    var initializeMultisig_js_1 = require_initializeMultisig();
    var mintTo_js_1 = require_mintTo();
    var mintToChecked_js_1 = require_mintToChecked();
    var revoke_js_1 = require_revoke();
    var setAuthority_js_1 = require_setAuthority();
    var syncNative_js_1 = require_syncNative();
    var thawAccount_js_1 = require_thawAccount();
    var transfer_js_1 = require_transfer();
    var transferChecked_js_1 = require_transferChecked();
    var types_js_1 = require_types();
    var uiAmountToAmount_js_1 = require_uiAmountToAmount();
    function decodeInstruction(instruction, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      if (!instruction.data.length)
        throw new errors_js_1.TokenInvalidInstructionDataError();
      const type = (0, buffer_layout_1.u8)().decode(instruction.data);
      if (type === types_js_1.TokenInstruction.InitializeMint)
        return (0, initializeMint_js_1.decodeInitializeMintInstruction)(instruction, programId);
      if (type === types_js_1.TokenInstruction.InitializeAccount)
        return (0, initializeAccount_js_1.decodeInitializeAccountInstruction)(instruction, programId);
      if (type === types_js_1.TokenInstruction.InitializeMultisig)
        return (0, initializeMultisig_js_1.decodeInitializeMultisigInstruction)(instruction, programId);
      if (type === types_js_1.TokenInstruction.Transfer)
        return (0, transfer_js_1.decodeTransferInstruction)(instruction, programId);
      if (type === types_js_1.TokenInstruction.Approve)
        return (0, approve_js_1.decodeApproveInstruction)(instruction, programId);
      if (type === types_js_1.TokenInstruction.Revoke)
        return (0, revoke_js_1.decodeRevokeInstruction)(instruction, programId);
      if (type === types_js_1.TokenInstruction.SetAuthority)
        return (0, setAuthority_js_1.decodeSetAuthorityInstruction)(instruction, programId);
      if (type === types_js_1.TokenInstruction.MintTo)
        return (0, mintTo_js_1.decodeMintToInstruction)(instruction, programId);
      if (type === types_js_1.TokenInstruction.Burn)
        return (0, burn_js_1.decodeBurnInstruction)(instruction, programId);
      if (type === types_js_1.TokenInstruction.CloseAccount)
        return (0, closeAccount_js_1.decodeCloseAccountInstruction)(instruction, programId);
      if (type === types_js_1.TokenInstruction.FreezeAccount)
        return (0, freezeAccount_js_1.decodeFreezeAccountInstruction)(instruction, programId);
      if (type === types_js_1.TokenInstruction.ThawAccount)
        return (0, thawAccount_js_1.decodeThawAccountInstruction)(instruction, programId);
      if (type === types_js_1.TokenInstruction.TransferChecked)
        return (0, transferChecked_js_1.decodeTransferCheckedInstruction)(instruction, programId);
      if (type === types_js_1.TokenInstruction.ApproveChecked)
        return (0, approveChecked_js_1.decodeApproveCheckedInstruction)(instruction, programId);
      if (type === types_js_1.TokenInstruction.MintToChecked)
        return (0, mintToChecked_js_1.decodeMintToCheckedInstruction)(instruction, programId);
      if (type === types_js_1.TokenInstruction.BurnChecked)
        return (0, burnChecked_js_1.decodeBurnCheckedInstruction)(instruction, programId);
      if (type === types_js_1.TokenInstruction.InitializeAccount2)
        return (0, initializeAccount2_js_1.decodeInitializeAccount2Instruction)(instruction, programId);
      if (type === types_js_1.TokenInstruction.SyncNative)
        return (0, syncNative_js_1.decodeSyncNativeInstruction)(instruction, programId);
      if (type === types_js_1.TokenInstruction.InitializeAccount3)
        return (0, initializeAccount3_js_1.decodeInitializeAccount3Instruction)(instruction, programId);
      if (type === types_js_1.TokenInstruction.InitializeMint2)
        return (0, initializeMint2_js_1.decodeInitializeMint2Instruction)(instruction, programId);
      if (type === types_js_1.TokenInstruction.AmountToUiAmount)
        return (0, amountToUiAmount_js_1.decodeAmountToUiAmountInstruction)(instruction, programId);
      if (type === types_js_1.TokenInstruction.UiAmountToAmount)
        return (0, uiAmountToAmount_js_1.decodeUiAmountToAmountInstruction)(instruction, programId);
      if (type === types_js_1.TokenInstruction.InitializeMultisig2)
        throw new errors_js_1.TokenInvalidInstructionTypeError();
      throw new errors_js_1.TokenInvalidInstructionTypeError();
    }
    function isInitializeMintInstruction(decoded) {
      return decoded.data.instruction === types_js_1.TokenInstruction.InitializeMint;
    }
    function isInitializeAccountInstruction(decoded) {
      return decoded.data.instruction === types_js_1.TokenInstruction.InitializeAccount;
    }
    function isInitializeMultisigInstruction(decoded) {
      return decoded.data.instruction === types_js_1.TokenInstruction.InitializeMultisig;
    }
    function isTransferInstruction(decoded) {
      return decoded.data.instruction === types_js_1.TokenInstruction.Transfer;
    }
    function isApproveInstruction(decoded) {
      return decoded.data.instruction === types_js_1.TokenInstruction.Approve;
    }
    function isRevokeInstruction(decoded) {
      return decoded.data.instruction === types_js_1.TokenInstruction.Revoke;
    }
    function isSetAuthorityInstruction(decoded) {
      return decoded.data.instruction === types_js_1.TokenInstruction.SetAuthority;
    }
    function isMintToInstruction(decoded) {
      return decoded.data.instruction === types_js_1.TokenInstruction.MintTo;
    }
    function isBurnInstruction(decoded) {
      return decoded.data.instruction === types_js_1.TokenInstruction.Burn;
    }
    function isCloseAccountInstruction(decoded) {
      return decoded.data.instruction === types_js_1.TokenInstruction.CloseAccount;
    }
    function isFreezeAccountInstruction(decoded) {
      return decoded.data.instruction === types_js_1.TokenInstruction.FreezeAccount;
    }
    function isThawAccountInstruction(decoded) {
      return decoded.data.instruction === types_js_1.TokenInstruction.ThawAccount;
    }
    function isTransferCheckedInstruction(decoded) {
      return decoded.data.instruction === types_js_1.TokenInstruction.TransferChecked;
    }
    function isApproveCheckedInstruction(decoded) {
      return decoded.data.instruction === types_js_1.TokenInstruction.ApproveChecked;
    }
    function isMintToCheckedInstruction(decoded) {
      return decoded.data.instruction === types_js_1.TokenInstruction.MintToChecked;
    }
    function isBurnCheckedInstruction(decoded) {
      return decoded.data.instruction === types_js_1.TokenInstruction.BurnChecked;
    }
    function isInitializeAccount2Instruction(decoded) {
      return decoded.data.instruction === types_js_1.TokenInstruction.InitializeAccount2;
    }
    function isSyncNativeInstruction(decoded) {
      return decoded.data.instruction === types_js_1.TokenInstruction.SyncNative;
    }
    function isInitializeAccount3Instruction(decoded) {
      return decoded.data.instruction === types_js_1.TokenInstruction.InitializeAccount3;
    }
    function isInitializeMint2Instruction(decoded) {
      return decoded.data.instruction === types_js_1.TokenInstruction.InitializeMint2;
    }
    function isAmountToUiAmountInstruction(decoded) {
      return decoded.data.instruction === types_js_1.TokenInstruction.AmountToUiAmount;
    }
    function isUiamountToAmountInstruction(decoded) {
      return decoded.data.instruction === types_js_1.TokenInstruction.UiAmountToAmount;
    }
  }
});

// node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/instructions/initializeMultisig2.js
var require_initializeMultisig2 = __commonJS({
  "node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/instructions/initializeMultisig2.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/instructions/initializeImmutableOwner.js
var require_initializeImmutableOwner = __commonJS({
  "node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/instructions/initializeImmutableOwner.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.initializeImmutableOwnerInstructionData = void 0;
    exports2.createInitializeImmutableOwnerInstruction = createInitializeImmutableOwnerInstruction;
    exports2.decodeInitializeImmutableOwnerInstruction = decodeInitializeImmutableOwnerInstruction;
    exports2.decodeInitializeImmutableOwnerInstructionUnchecked = decodeInitializeImmutableOwnerInstructionUnchecked;
    var buffer_layout_1 = require_Layout();
    var web3_js_1 = require("@solana/web3.js");
    var errors_js_1 = require_errors();
    var types_js_1 = require_types();
    exports2.initializeImmutableOwnerInstructionData = (0, buffer_layout_1.struct)([
      (0, buffer_layout_1.u8)("instruction")
    ]);
    function createInitializeImmutableOwnerInstruction(account, programId) {
      const keys = [{ pubkey: account, isSigner: false, isWritable: true }];
      const data = Buffer.alloc(exports2.initializeImmutableOwnerInstructionData.span);
      exports2.initializeImmutableOwnerInstructionData.encode({
        instruction: types_js_1.TokenInstruction.InitializeImmutableOwner
      }, data);
      return new web3_js_1.TransactionInstruction({ keys, programId, data });
    }
    function decodeInitializeImmutableOwnerInstruction(instruction, programId) {
      if (!instruction.programId.equals(programId))
        throw new errors_js_1.TokenInvalidInstructionProgramError();
      if (instruction.data.length !== exports2.initializeImmutableOwnerInstructionData.span)
        throw new errors_js_1.TokenInvalidInstructionDataError();
      const { keys: { account }, data } = decodeInitializeImmutableOwnerInstructionUnchecked(instruction);
      if (data.instruction !== types_js_1.TokenInstruction.InitializeImmutableOwner)
        throw new errors_js_1.TokenInvalidInstructionTypeError();
      if (!account)
        throw new errors_js_1.TokenInvalidInstructionKeysError();
      return {
        programId,
        keys: {
          account
        },
        data
      };
    }
    function decodeInitializeImmutableOwnerInstructionUnchecked({ programId, keys: [account], data }) {
      const { instruction } = exports2.initializeImmutableOwnerInstructionData.decode(data);
      return {
        programId,
        keys: {
          account
        },
        data: {
          instruction
        }
      };
    }
  }
});

// node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/instructions/initializeMintCloseAuthority.js
var require_initializeMintCloseAuthority = __commonJS({
  "node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/instructions/initializeMintCloseAuthority.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.initializeMintCloseAuthorityInstructionData = void 0;
    exports2.createInitializeMintCloseAuthorityInstruction = createInitializeMintCloseAuthorityInstruction;
    exports2.decodeInitializeMintCloseAuthorityInstruction = decodeInitializeMintCloseAuthorityInstruction;
    exports2.decodeInitializeMintCloseAuthorityInstructionUnchecked = decodeInitializeMintCloseAuthorityInstructionUnchecked;
    var buffer_layout_1 = require_Layout();
    var web3_js_1 = require("@solana/web3.js");
    var constants_js_1 = require_constants();
    var errors_js_1 = require_errors();
    var types_js_1 = require_types();
    var serialization_js_1 = require_serialization();
    exports2.initializeMintCloseAuthorityInstructionData = (0, buffer_layout_1.struct)([
      (0, buffer_layout_1.u8)("instruction"),
      new serialization_js_1.COptionPublicKeyLayout("closeAuthority")
    ]);
    function createInitializeMintCloseAuthorityInstruction(mint, closeAuthority, programId) {
      if (!(0, constants_js_1.programSupportsExtensions)(programId)) {
        throw new errors_js_1.TokenUnsupportedInstructionError();
      }
      const keys = [{ pubkey: mint, isSigner: false, isWritable: true }];
      const data = Buffer.alloc(34);
      exports2.initializeMintCloseAuthorityInstructionData.encode({
        instruction: types_js_1.TokenInstruction.InitializeMintCloseAuthority,
        closeAuthority
      }, data);
      return new web3_js_1.TransactionInstruction({
        keys,
        programId,
        data: data.subarray(0, exports2.initializeMintCloseAuthorityInstructionData.getSpan(data))
      });
    }
    function decodeInitializeMintCloseAuthorityInstruction(instruction, programId) {
      if (!instruction.programId.equals(programId))
        throw new errors_js_1.TokenInvalidInstructionProgramError();
      if (instruction.data.length !== exports2.initializeMintCloseAuthorityInstructionData.getSpan(instruction.data))
        throw new errors_js_1.TokenInvalidInstructionDataError();
      const { keys: { mint }, data } = decodeInitializeMintCloseAuthorityInstructionUnchecked(instruction);
      if (data.instruction !== types_js_1.TokenInstruction.InitializeMintCloseAuthority)
        throw new errors_js_1.TokenInvalidInstructionTypeError();
      if (!mint)
        throw new errors_js_1.TokenInvalidInstructionKeysError();
      return {
        programId,
        keys: {
          mint
        },
        data
      };
    }
    function decodeInitializeMintCloseAuthorityInstructionUnchecked({ programId, keys: [mint], data }) {
      const { instruction, closeAuthority } = exports2.initializeMintCloseAuthorityInstructionData.decode(data);
      return {
        programId,
        keys: {
          mint
        },
        data: {
          instruction,
          closeAuthority
        }
      };
    }
  }
});

// node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/instructions/reallocate.js
var require_reallocate = __commonJS({
  "node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/instructions/reallocate.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createReallocateInstruction = createReallocateInstruction;
    var buffer_layout_1 = require_Layout();
    var web3_js_1 = require("@solana/web3.js");
    var constants_js_1 = require_constants();
    var errors_js_1 = require_errors();
    var internal_js_1 = require_internal2();
    var types_js_1 = require_types();
    function createReallocateInstruction(account, payer, extensionTypes, owner, multiSigners = [], programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
      if (!(0, constants_js_1.programSupportsExtensions)(programId)) {
        throw new errors_js_1.TokenUnsupportedInstructionError();
      }
      const baseKeys = [
        { pubkey: account, isSigner: false, isWritable: true },
        { pubkey: payer, isSigner: true, isWritable: true },
        { pubkey: web3_js_1.SystemProgram.programId, isSigner: false, isWritable: false }
      ];
      const keys = (0, internal_js_1.addSigners)(baseKeys, owner, multiSigners);
      const reallocateInstructionData = (0, buffer_layout_1.struct)([
        (0, buffer_layout_1.u8)("instruction"),
        (0, buffer_layout_1.seq)((0, buffer_layout_1.u16)(), extensionTypes.length, "extensionTypes")
      ]);
      const data = Buffer.alloc(reallocateInstructionData.span);
      reallocateInstructionData.encode({ instruction: types_js_1.TokenInstruction.Reallocate, extensionTypes }, data);
      return new web3_js_1.TransactionInstruction({ keys, programId, data });
    }
  }
});

// node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/instructions/initializeNonTransferableMint.js
var require_initializeNonTransferableMint = __commonJS({
  "node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/instructions/initializeNonTransferableMint.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.initializeNonTransferableMintInstructionData = void 0;
    exports2.createInitializeNonTransferableMintInstruction = createInitializeNonTransferableMintInstruction;
    var buffer_layout_1 = require_Layout();
    var web3_js_1 = require("@solana/web3.js");
    var constants_js_1 = require_constants();
    var errors_js_1 = require_errors();
    var types_js_1 = require_types();
    exports2.initializeNonTransferableMintInstructionData = (0, buffer_layout_1.struct)([
      (0, buffer_layout_1.u8)("instruction")
    ]);
    function createInitializeNonTransferableMintInstruction(mint, programId) {
      if (!(0, constants_js_1.programSupportsExtensions)(programId)) {
        throw new errors_js_1.TokenUnsupportedInstructionError();
      }
      const keys = [{ pubkey: mint, isSigner: false, isWritable: true }];
      const data = Buffer.alloc(exports2.initializeNonTransferableMintInstructionData.span);
      exports2.initializeNonTransferableMintInstructionData.encode({
        instruction: types_js_1.TokenInstruction.InitializeNonTransferableMint
      }, data);
      return new web3_js_1.TransactionInstruction({ keys, programId, data });
    }
  }
});

// node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/instructions/initializePermanentDelegate.js
var require_initializePermanentDelegate = __commonJS({
  "node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/instructions/initializePermanentDelegate.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.initializePermanentDelegateInstructionData = void 0;
    exports2.createInitializePermanentDelegateInstruction = createInitializePermanentDelegateInstruction;
    exports2.decodeInitializePermanentDelegateInstruction = decodeInitializePermanentDelegateInstruction;
    exports2.decodeInitializePermanentDelegateInstructionUnchecked = decodeInitializePermanentDelegateInstructionUnchecked;
    var buffer_layout_1 = require_Layout();
    var buffer_layout_utils_1 = require_cjs();
    var web3_js_1 = require("@solana/web3.js");
    var web3_js_2 = require("@solana/web3.js");
    var constants_js_1 = require_constants();
    var errors_js_1 = require_errors();
    var types_js_1 = require_types();
    exports2.initializePermanentDelegateInstructionData = (0, buffer_layout_1.struct)([
      (0, buffer_layout_1.u8)("instruction"),
      (0, buffer_layout_utils_1.publicKey)("delegate")
    ]);
    function createInitializePermanentDelegateInstruction(mint, permanentDelegate, programId) {
      if (!(0, constants_js_1.programSupportsExtensions)(programId)) {
        throw new errors_js_1.TokenUnsupportedInstructionError();
      }
      const keys = [{ pubkey: mint, isSigner: false, isWritable: true }];
      const data = Buffer.alloc(exports2.initializePermanentDelegateInstructionData.span);
      exports2.initializePermanentDelegateInstructionData.encode({
        instruction: types_js_1.TokenInstruction.InitializePermanentDelegate,
        delegate: permanentDelegate || new web3_js_1.PublicKey(0)
      }, data);
      return new web3_js_2.TransactionInstruction({ keys, programId, data });
    }
    function decodeInitializePermanentDelegateInstruction(instruction, programId) {
      if (!instruction.programId.equals(programId))
        throw new errors_js_1.TokenInvalidInstructionProgramError();
      if (instruction.data.length !== exports2.initializePermanentDelegateInstructionData.span)
        throw new errors_js_1.TokenInvalidInstructionDataError();
      const { keys: { mint }, data } = decodeInitializePermanentDelegateInstructionUnchecked(instruction);
      if (data.instruction !== types_js_1.TokenInstruction.InitializePermanentDelegate)
        throw new errors_js_1.TokenInvalidInstructionTypeError();
      if (!mint)
        throw new errors_js_1.TokenInvalidInstructionKeysError();
      return {
        programId,
        keys: {
          mint
        },
        data
      };
    }
    function decodeInitializePermanentDelegateInstructionUnchecked({ programId, keys: [mint], data }) {
      const { instruction, delegate } = exports2.initializePermanentDelegateInstructionData.decode(data);
      return {
        programId,
        keys: {
          mint
        },
        data: {
          instruction,
          delegate
        }
      };
    }
  }
});

// node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/instructions/index.js
var require_instructions12 = __commonJS({
  "node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/instructions/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createInitializeMemberInstruction = exports2.createUpdateGroupAuthorityInstruction = exports2.createUpdateGroupMaxSizeInstruction = exports2.createInitializeGroupInstruction = exports2.createEmitInstruction = exports2.createUpdateAuthorityInstruction = exports2.createRemoveKeyInstruction = exports2.createUpdateFieldInstruction = exports2.createInitializeInstruction = void 0;
    var spl_token_metadata_1 = require_cjs3();
    Object.defineProperty(exports2, "createInitializeInstruction", { enumerable: true, get: function() {
      return spl_token_metadata_1.createInitializeInstruction;
    } });
    Object.defineProperty(exports2, "createUpdateFieldInstruction", { enumerable: true, get: function() {
      return spl_token_metadata_1.createUpdateFieldInstruction;
    } });
    Object.defineProperty(exports2, "createRemoveKeyInstruction", { enumerable: true, get: function() {
      return spl_token_metadata_1.createRemoveKeyInstruction;
    } });
    Object.defineProperty(exports2, "createUpdateAuthorityInstruction", { enumerable: true, get: function() {
      return spl_token_metadata_1.createUpdateAuthorityInstruction;
    } });
    Object.defineProperty(exports2, "createEmitInstruction", { enumerable: true, get: function() {
      return spl_token_metadata_1.createEmitInstruction;
    } });
    var spl_token_group_1 = require_cjs2();
    Object.defineProperty(exports2, "createInitializeGroupInstruction", { enumerable: true, get: function() {
      return spl_token_group_1.createInitializeGroupInstruction;
    } });
    Object.defineProperty(exports2, "createUpdateGroupMaxSizeInstruction", { enumerable: true, get: function() {
      return spl_token_group_1.createUpdateGroupMaxSizeInstruction;
    } });
    Object.defineProperty(exports2, "createUpdateGroupAuthorityInstruction", { enumerable: true, get: function() {
      return spl_token_group_1.createUpdateGroupAuthorityInstruction;
    } });
    Object.defineProperty(exports2, "createInitializeMemberInstruction", { enumerable: true, get: function() {
      return spl_token_group_1.createInitializeMemberInstruction;
    } });
    __exportStar(require_associatedTokenAccount(), exports2);
    __exportStar(require_decode(), exports2);
    __exportStar(require_types(), exports2);
    __exportStar(require_initializeMint(), exports2);
    __exportStar(require_initializeAccount(), exports2);
    __exportStar(require_initializeMultisig(), exports2);
    __exportStar(require_transfer(), exports2);
    __exportStar(require_approve(), exports2);
    __exportStar(require_revoke(), exports2);
    __exportStar(require_setAuthority(), exports2);
    __exportStar(require_mintTo(), exports2);
    __exportStar(require_burn(), exports2);
    __exportStar(require_closeAccount(), exports2);
    __exportStar(require_freezeAccount(), exports2);
    __exportStar(require_thawAccount(), exports2);
    __exportStar(require_transferChecked(), exports2);
    __exportStar(require_approveChecked(), exports2);
    __exportStar(require_mintToChecked(), exports2);
    __exportStar(require_burnChecked(), exports2);
    __exportStar(require_initializeAccount2(), exports2);
    __exportStar(require_syncNative(), exports2);
    __exportStar(require_initializeAccount3(), exports2);
    __exportStar(require_initializeMultisig2(), exports2);
    __exportStar(require_initializeMint2(), exports2);
    __exportStar(require_initializeImmutableOwner(), exports2);
    __exportStar(require_amountToUiAmount(), exports2);
    __exportStar(require_uiAmountToAmount(), exports2);
    __exportStar(require_initializeMintCloseAuthority(), exports2);
    __exportStar(require_reallocate(), exports2);
    __exportStar(require_createNativeMint(), exports2);
    __exportStar(require_initializeNonTransferableMint(), exports2);
    __exportStar(require_initializePermanentDelegate(), exports2);
  }
});

// node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/index.js
var require_cjs4 = __commonJS({
  "node_modules/@raydium-io/raydium-sdk-v2/node_modules/@solana/spl-token/lib/cjs/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_actions9(), exports2);
    __exportStar(require_constants(), exports2);
    __exportStar(require_errors(), exports2);
    __exportStar(require_extensions(), exports2);
    __exportStar(require_instructions12(), exports2);
    __exportStar(require_state17(), exports2);
  }
});

// node_modules/bn.js/lib/bn.js
var require_bn = __commonJS({
  "node_modules/bn.js/lib/bn.js"(exports2, module2) {
    (function(module3, exports3) {
      "use strict";
      function assert(val, msg) {
        if (!val)
          throw new Error(msg || "Assertion failed");
      }
      function inherits(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
      function BN2(number, base, endian) {
        if (BN2.isBN(number)) {
          return number;
        }
        this.negative = 0;
        this.words = null;
        this.length = 0;
        this.red = null;
        if (number !== null) {
          if (base === "le" || base === "be") {
            endian = base;
            base = 10;
          }
          this._init(number || 0, base || 10, endian || "be");
        }
      }
      if (typeof module3 === "object") {
        module3.exports = BN2;
      } else {
        exports3.BN = BN2;
      }
      BN2.BN = BN2;
      BN2.wordSize = 26;
      var Buffer2;
      try {
        if (typeof window !== "undefined" && typeof window.Buffer !== "undefined") {
          Buffer2 = window.Buffer;
        } else {
          Buffer2 = require("buffer").Buffer;
        }
      } catch (e) {
      }
      BN2.isBN = function isBN(num) {
        if (num instanceof BN2) {
          return true;
        }
        return num !== null && typeof num === "object" && num.constructor.wordSize === BN2.wordSize && Array.isArray(num.words);
      };
      BN2.max = function max2(left, right) {
        if (left.cmp(right) > 0)
          return left;
        return right;
      };
      BN2.min = function min2(left, right) {
        if (left.cmp(right) < 0)
          return left;
        return right;
      };
      BN2.prototype._init = function init(number, base, endian) {
        if (typeof number === "number") {
          return this._initNumber(number, base, endian);
        }
        if (typeof number === "object") {
          return this._initArray(number, base, endian);
        }
        if (base === "hex") {
          base = 16;
        }
        assert(base === (base | 0) && base >= 2 && base <= 36);
        number = number.toString().replace(/\s+/g, "");
        var start = 0;
        if (number[0] === "-") {
          start++;
          this.negative = 1;
        }
        if (start < number.length) {
          if (base === 16) {
            this._parseHex(number, start, endian);
          } else {
            this._parseBase(number, base, start);
            if (endian === "le") {
              this._initArray(this.toArray(), base, endian);
            }
          }
        }
      };
      BN2.prototype._initNumber = function _initNumber(number, base, endian) {
        if (number < 0) {
          this.negative = 1;
          number = -number;
        }
        if (number < 67108864) {
          this.words = [number & 67108863];
          this.length = 1;
        } else if (number < 4503599627370496) {
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863
          ];
          this.length = 2;
        } else {
          assert(number < 9007199254740992);
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863,
            1
          ];
          this.length = 3;
        }
        if (endian !== "le")
          return;
        this._initArray(this.toArray(), base, endian);
      };
      BN2.prototype._initArray = function _initArray(number, base, endian) {
        assert(typeof number.length === "number");
        if (number.length <= 0) {
          this.words = [0];
          this.length = 1;
          return this;
        }
        this.length = Math.ceil(number.length / 3);
        this.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) {
          this.words[i] = 0;
        }
        var j, w;
        var off = 0;
        if (endian === "be") {
          for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
            w = number[i] | number[i - 1] << 8 | number[i - 2] << 16;
            this.words[j] |= w << off & 67108863;
            this.words[j + 1] = w >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j++;
            }
          }
        } else if (endian === "le") {
          for (i = 0, j = 0; i < number.length; i += 3) {
            w = number[i] | number[i + 1] << 8 | number[i + 2] << 16;
            this.words[j] |= w << off & 67108863;
            this.words[j + 1] = w >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j++;
            }
          }
        }
        return this._strip();
      };
      function parseHex4Bits(string, index) {
        var c = string.charCodeAt(index);
        if (c >= 48 && c <= 57) {
          return c - 48;
        } else if (c >= 65 && c <= 70) {
          return c - 55;
        } else if (c >= 97 && c <= 102) {
          return c - 87;
        } else {
          assert(false, "Invalid character in " + string);
        }
      }
      function parseHexByte(string, lowerBound, index) {
        var r = parseHex4Bits(string, index);
        if (index - 1 >= lowerBound) {
          r |= parseHex4Bits(string, index - 1) << 4;
        }
        return r;
      }
      BN2.prototype._parseHex = function _parseHex(number, start, endian) {
        this.length = Math.ceil((number.length - start) / 6);
        this.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) {
          this.words[i] = 0;
        }
        var off = 0;
        var j = 0;
        var w;
        if (endian === "be") {
          for (i = number.length - 1; i >= start; i -= 2) {
            w = parseHexByte(number, start, i) << off;
            this.words[j] |= w & 67108863;
            if (off >= 18) {
              off -= 18;
              j += 1;
              this.words[j] |= w >>> 26;
            } else {
              off += 8;
            }
          }
        } else {
          var parseLength = number.length - start;
          for (i = parseLength % 2 === 0 ? start + 1 : start; i < number.length; i += 2) {
            w = parseHexByte(number, start, i) << off;
            this.words[j] |= w & 67108863;
            if (off >= 18) {
              off -= 18;
              j += 1;
              this.words[j] |= w >>> 26;
            } else {
              off += 8;
            }
          }
        }
        this._strip();
      };
      function parseBase(str2, start, end, mul3) {
        var r = 0;
        var b = 0;
        var len = Math.min(str2.length, end);
        for (var i = start; i < len; i++) {
          var c = str2.charCodeAt(i) - 48;
          r *= mul3;
          if (c >= 49) {
            b = c - 49 + 10;
          } else if (c >= 17) {
            b = c - 17 + 10;
          } else {
            b = c;
          }
          assert(c >= 0 && b < mul3, "Invalid character");
          r += b;
        }
        return r;
      }
      BN2.prototype._parseBase = function _parseBase(number, base, start) {
        this.words = [0];
        this.length = 1;
        for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base) {
          limbLen++;
        }
        limbLen--;
        limbPow = limbPow / base | 0;
        var total = number.length - start;
        var mod2 = total % limbLen;
        var end = Math.min(total, total - mod2) + start;
        var word = 0;
        for (var i = start; i < end; i += limbLen) {
          word = parseBase(number, i, i + limbLen, base);
          this.imuln(limbPow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        if (mod2 !== 0) {
          var pow2 = 1;
          word = parseBase(number, i, number.length, base);
          for (i = 0; i < mod2; i++) {
            pow2 *= base;
          }
          this.imuln(pow2);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        this._strip();
      };
      BN2.prototype.copy = function copy(dest) {
        dest.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) {
          dest.words[i] = this.words[i];
        }
        dest.length = this.length;
        dest.negative = this.negative;
        dest.red = this.red;
      };
      function move(dest, src) {
        dest.words = src.words;
        dest.length = src.length;
        dest.negative = src.negative;
        dest.red = src.red;
      }
      BN2.prototype._move = function _move(dest) {
        move(dest, this);
      };
      BN2.prototype.clone = function clone3() {
        var r = new BN2(null);
        this.copy(r);
        return r;
      };
      BN2.prototype._expand = function _expand(size) {
        while (this.length < size) {
          this.words[this.length++] = 0;
        }
        return this;
      };
      BN2.prototype._strip = function strip() {
        while (this.length > 1 && this.words[this.length - 1] === 0) {
          this.length--;
        }
        return this._normSign();
      };
      BN2.prototype._normSign = function _normSign() {
        if (this.length === 1 && this.words[0] === 0) {
          this.negative = 0;
        }
        return this;
      };
      if (typeof Symbol !== "undefined" && typeof Symbol.for === "function") {
        try {
          BN2.prototype[Symbol.for("nodejs.util.inspect.custom")] = inspect;
        } catch (e) {
          BN2.prototype.inspect = inspect;
        }
      } else {
        BN2.prototype.inspect = inspect;
      }
      function inspect() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      }
      var zeros2 = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
      ];
      var groupSizes = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
      ];
      var groupBases = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        1e7,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64e6,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        243e5,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
      ];
      BN2.prototype.toString = function toString(base, padding) {
        base = base || 10;
        padding = padding | 0 || 1;
        var out;
        if (base === 16 || base === "hex") {
          out = "";
          var off = 0;
          var carry = 0;
          for (var i = 0; i < this.length; i++) {
            var w = this.words[i];
            var word = ((w << off | carry) & 16777215).toString(16);
            carry = w >>> 24 - off & 16777215;
            off += 2;
            if (off >= 26) {
              off -= 26;
              i--;
            }
            if (carry !== 0 || i !== this.length - 1) {
              out = zeros2[6 - word.length] + word + out;
            } else {
              out = word + out;
            }
          }
          if (carry !== 0) {
            out = carry.toString(16) + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        if (base === (base | 0) && base >= 2 && base <= 36) {
          var groupSize = groupSizes[base];
          var groupBase = groupBases[base];
          out = "";
          var c = this.clone();
          c.negative = 0;
          while (!c.isZero()) {
            var r = c.modrn(groupBase).toString(base);
            c = c.idivn(groupBase);
            if (!c.isZero()) {
              out = zeros2[groupSize - r.length] + r + out;
            } else {
              out = r + out;
            }
          }
          if (this.isZero()) {
            out = "0" + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        assert(false, "Base should be between 2 and 36");
      };
      BN2.prototype.toNumber = function toNumber() {
        var ret = this.words[0];
        if (this.length === 2) {
          ret += this.words[1] * 67108864;
        } else if (this.length === 3 && this.words[2] === 1) {
          ret += 4503599627370496 + this.words[1] * 67108864;
        } else if (this.length > 2) {
          assert(false, "Number can only safely store up to 53 bits");
        }
        return this.negative !== 0 ? -ret : ret;
      };
      BN2.prototype.toJSON = function toJSON() {
        return this.toString(16, 2);
      };
      if (Buffer2) {
        BN2.prototype.toBuffer = function toBuffer2(endian, length) {
          return this.toArrayLike(Buffer2, endian, length);
        };
      }
      BN2.prototype.toArray = function toArray(endian, length) {
        return this.toArrayLike(Array, endian, length);
      };
      var allocate = function allocate2(ArrayType, size) {
        if (ArrayType.allocUnsafe) {
          return ArrayType.allocUnsafe(size);
        }
        return new ArrayType(size);
      };
      BN2.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
        this._strip();
        var byteLength = this.byteLength();
        var reqLength = length || Math.max(1, byteLength);
        assert(byteLength <= reqLength, "byte array longer than desired length");
        assert(reqLength > 0, "Requested array length <= 0");
        var res = allocate(ArrayType, reqLength);
        var postfix = endian === "le" ? "LE" : "BE";
        this["_toArrayLike" + postfix](res, byteLength);
        return res;
      };
      BN2.prototype._toArrayLikeLE = function _toArrayLikeLE(res, byteLength) {
        var position = 0;
        var carry = 0;
        for (var i = 0, shift = 0; i < this.length; i++) {
          var word = this.words[i] << shift | carry;
          res[position++] = word & 255;
          if (position < res.length) {
            res[position++] = word >> 8 & 255;
          }
          if (position < res.length) {
            res[position++] = word >> 16 & 255;
          }
          if (shift === 6) {
            if (position < res.length) {
              res[position++] = word >> 24 & 255;
            }
            carry = 0;
            shift = 0;
          } else {
            carry = word >>> 24;
            shift += 2;
          }
        }
        if (position < res.length) {
          res[position++] = carry;
          while (position < res.length) {
            res[position++] = 0;
          }
        }
      };
      BN2.prototype._toArrayLikeBE = function _toArrayLikeBE(res, byteLength) {
        var position = res.length - 1;
        var carry = 0;
        for (var i = 0, shift = 0; i < this.length; i++) {
          var word = this.words[i] << shift | carry;
          res[position--] = word & 255;
          if (position >= 0) {
            res[position--] = word >> 8 & 255;
          }
          if (position >= 0) {
            res[position--] = word >> 16 & 255;
          }
          if (shift === 6) {
            if (position >= 0) {
              res[position--] = word >> 24 & 255;
            }
            carry = 0;
            shift = 0;
          } else {
            carry = word >>> 24;
            shift += 2;
          }
        }
        if (position >= 0) {
          res[position--] = carry;
          while (position >= 0) {
            res[position--] = 0;
          }
        }
      };
      if (Math.clz32) {
        BN2.prototype._countBits = function _countBits(w) {
          return 32 - Math.clz32(w);
        };
      } else {
        BN2.prototype._countBits = function _countBits(w) {
          var t = w;
          var r = 0;
          if (t >= 4096) {
            r += 13;
            t >>>= 13;
          }
          if (t >= 64) {
            r += 7;
            t >>>= 7;
          }
          if (t >= 8) {
            r += 4;
            t >>>= 4;
          }
          if (t >= 2) {
            r += 2;
            t >>>= 2;
          }
          return r + t;
        };
      }
      BN2.prototype._zeroBits = function _zeroBits(w) {
        if (w === 0)
          return 26;
        var t = w;
        var r = 0;
        if ((t & 8191) === 0) {
          r += 13;
          t >>>= 13;
        }
        if ((t & 127) === 0) {
          r += 7;
          t >>>= 7;
        }
        if ((t & 15) === 0) {
          r += 4;
          t >>>= 4;
        }
        if ((t & 3) === 0) {
          r += 2;
          t >>>= 2;
        }
        if ((t & 1) === 0) {
          r++;
        }
        return r;
      };
      BN2.prototype.bitLength = function bitLength() {
        var w = this.words[this.length - 1];
        var hi = this._countBits(w);
        return (this.length - 1) * 26 + hi;
      };
      function toBitArray(num) {
        var w = new Array(num.bitLength());
        for (var bit = 0; bit < w.length; bit++) {
          var off = bit / 26 | 0;
          var wbit = bit % 26;
          w[bit] = num.words[off] >>> wbit & 1;
        }
        return w;
      }
      BN2.prototype.zeroBits = function zeroBits() {
        if (this.isZero())
          return 0;
        var r = 0;
        for (var i = 0; i < this.length; i++) {
          var b = this._zeroBits(this.words[i]);
          r += b;
          if (b !== 26)
            break;
        }
        return r;
      };
      BN2.prototype.byteLength = function byteLength() {
        return Math.ceil(this.bitLength() / 8);
      };
      BN2.prototype.toTwos = function toTwos(width) {
        if (this.negative !== 0) {
          return this.abs().inotn(width).iaddn(1);
        }
        return this.clone();
      };
      BN2.prototype.fromTwos = function fromTwos(width) {
        if (this.testn(width - 1)) {
          return this.notn(width).iaddn(1).ineg();
        }
        return this.clone();
      };
      BN2.prototype.isNeg = function isNeg() {
        return this.negative !== 0;
      };
      BN2.prototype.neg = function neg() {
        return this.clone().ineg();
      };
      BN2.prototype.ineg = function ineg() {
        if (!this.isZero()) {
          this.negative ^= 1;
        }
        return this;
      };
      BN2.prototype.iuor = function iuor(num) {
        while (this.length < num.length) {
          this.words[this.length++] = 0;
        }
        for (var i = 0; i < num.length; i++) {
          this.words[i] = this.words[i] | num.words[i];
        }
        return this._strip();
      };
      BN2.prototype.ior = function ior(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuor(num);
      };
      BN2.prototype.or = function or(num) {
        if (this.length > num.length)
          return this.clone().ior(num);
        return num.clone().ior(this);
      };
      BN2.prototype.uor = function uor(num) {
        if (this.length > num.length)
          return this.clone().iuor(num);
        return num.clone().iuor(this);
      };
      BN2.prototype.iuand = function iuand(num) {
        var b;
        if (this.length > num.length) {
          b = num;
        } else {
          b = this;
        }
        for (var i = 0; i < b.length; i++) {
          this.words[i] = this.words[i] & num.words[i];
        }
        this.length = b.length;
        return this._strip();
      };
      BN2.prototype.iand = function iand(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuand(num);
      };
      BN2.prototype.and = function and(num) {
        if (this.length > num.length)
          return this.clone().iand(num);
        return num.clone().iand(this);
      };
      BN2.prototype.uand = function uand(num) {
        if (this.length > num.length)
          return this.clone().iuand(num);
        return num.clone().iuand(this);
      };
      BN2.prototype.iuxor = function iuxor(num) {
        var a;
        var b;
        if (this.length > num.length) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }
        for (var i = 0; i < b.length; i++) {
          this.words[i] = a.words[i] ^ b.words[i];
        }
        if (this !== a) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }
        this.length = a.length;
        return this._strip();
      };
      BN2.prototype.ixor = function ixor(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuxor(num);
      };
      BN2.prototype.xor = function xor2(num) {
        if (this.length > num.length)
          return this.clone().ixor(num);
        return num.clone().ixor(this);
      };
      BN2.prototype.uxor = function uxor(num) {
        if (this.length > num.length)
          return this.clone().iuxor(num);
        return num.clone().iuxor(this);
      };
      BN2.prototype.inotn = function inotn(width) {
        assert(typeof width === "number" && width >= 0);
        var bytesNeeded = Math.ceil(width / 26) | 0;
        var bitsLeft = width % 26;
        this._expand(bytesNeeded);
        if (bitsLeft > 0) {
          bytesNeeded--;
        }
        for (var i = 0; i < bytesNeeded; i++) {
          this.words[i] = ~this.words[i] & 67108863;
        }
        if (bitsLeft > 0) {
          this.words[i] = ~this.words[i] & 67108863 >> 26 - bitsLeft;
        }
        return this._strip();
      };
      BN2.prototype.notn = function notn(width) {
        return this.clone().inotn(width);
      };
      BN2.prototype.setn = function setn(bit, val) {
        assert(typeof bit === "number" && bit >= 0);
        var off = bit / 26 | 0;
        var wbit = bit % 26;
        this._expand(off + 1);
        if (val) {
          this.words[off] = this.words[off] | 1 << wbit;
        } else {
          this.words[off] = this.words[off] & ~(1 << wbit);
        }
        return this._strip();
      };
      BN2.prototype.iadd = function iadd(num) {
        var r;
        if (this.negative !== 0 && num.negative === 0) {
          this.negative = 0;
          r = this.isub(num);
          this.negative ^= 1;
          return this._normSign();
        } else if (this.negative === 0 && num.negative !== 0) {
          num.negative = 0;
          r = this.isub(num);
          num.negative = 1;
          return r._normSign();
        }
        var a, b;
        if (this.length > num.length) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }
        var carry = 0;
        for (var i = 0; i < b.length; i++) {
          r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
          this.words[i] = r & 67108863;
          carry = r >>> 26;
        }
        for (; carry !== 0 && i < a.length; i++) {
          r = (a.words[i] | 0) + carry;
          this.words[i] = r & 67108863;
          carry = r >>> 26;
        }
        this.length = a.length;
        if (carry !== 0) {
          this.words[this.length] = carry;
          this.length++;
        } else if (a !== this) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }
        return this;
      };
      BN2.prototype.add = function add3(num) {
        var res;
        if (num.negative !== 0 && this.negative === 0) {
          num.negative = 0;
          res = this.sub(num);
          num.negative ^= 1;
          return res;
        } else if (num.negative === 0 && this.negative !== 0) {
          this.negative = 0;
          res = num.sub(this);
          this.negative = 1;
          return res;
        }
        if (this.length > num.length)
          return this.clone().iadd(num);
        return num.clone().iadd(this);
      };
      BN2.prototype.isub = function isub(num) {
        if (num.negative !== 0) {
          num.negative = 0;
          var r = this.iadd(num);
          num.negative = 1;
          return r._normSign();
        } else if (this.negative !== 0) {
          this.negative = 0;
          this.iadd(num);
          this.negative = 1;
          return this._normSign();
        }
        var cmp = this.cmp(num);
        if (cmp === 0) {
          this.negative = 0;
          this.length = 1;
          this.words[0] = 0;
          return this;
        }
        var a, b;
        if (cmp > 0) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }
        var carry = 0;
        for (var i = 0; i < b.length; i++) {
          r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
          carry = r >> 26;
          this.words[i] = r & 67108863;
        }
        for (; carry !== 0 && i < a.length; i++) {
          r = (a.words[i] | 0) + carry;
          carry = r >> 26;
          this.words[i] = r & 67108863;
        }
        if (carry === 0 && i < a.length && a !== this) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }
        this.length = Math.max(this.length, i);
        if (a !== this) {
          this.negative = 1;
        }
        return this._strip();
      };
      BN2.prototype.sub = function sub3(num) {
        return this.clone().isub(num);
      };
      function smallMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        var len = self2.length + num.length | 0;
        out.length = len;
        len = len - 1 | 0;
        var a = self2.words[0] | 0;
        var b = num.words[0] | 0;
        var r = a * b;
        var lo = r & 67108863;
        var carry = r / 67108864 | 0;
        out.words[0] = lo;
        for (var k = 1; k < len; k++) {
          var ncarry = carry >>> 26;
          var rword = carry & 67108863;
          var maxJ = Math.min(k, num.length - 1);
          for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
            var i = k - j | 0;
            a = self2.words[i] | 0;
            b = num.words[j] | 0;
            r = a * b + rword;
            ncarry += r / 67108864 | 0;
            rword = r & 67108863;
          }
          out.words[k] = rword | 0;
          carry = ncarry | 0;
        }
        if (carry !== 0) {
          out.words[k] = carry | 0;
        } else {
          out.length--;
        }
        return out._strip();
      }
      var comb10MulTo = function comb10MulTo2(self2, num, out) {
        var a = self2.words;
        var b = num.words;
        var o = out.words;
        var c = 0;
        var lo;
        var mid;
        var hi;
        var a0 = a[0] | 0;
        var al0 = a0 & 8191;
        var ah0 = a0 >>> 13;
        var a1 = a[1] | 0;
        var al1 = a1 & 8191;
        var ah1 = a1 >>> 13;
        var a2 = a[2] | 0;
        var al2 = a2 & 8191;
        var ah2 = a2 >>> 13;
        var a3 = a[3] | 0;
        var al3 = a3 & 8191;
        var ah3 = a3 >>> 13;
        var a4 = a[4] | 0;
        var al4 = a4 & 8191;
        var ah4 = a4 >>> 13;
        var a5 = a[5] | 0;
        var al5 = a5 & 8191;
        var ah5 = a5 >>> 13;
        var a6 = a[6] | 0;
        var al6 = a6 & 8191;
        var ah6 = a6 >>> 13;
        var a7 = a[7] | 0;
        var al7 = a7 & 8191;
        var ah7 = a7 >>> 13;
        var a8 = a[8] | 0;
        var al8 = a8 & 8191;
        var ah8 = a8 >>> 13;
        var a9 = a[9] | 0;
        var al9 = a9 & 8191;
        var ah9 = a9 >>> 13;
        var b0 = b[0] | 0;
        var bl0 = b0 & 8191;
        var bh0 = b0 >>> 13;
        var b1 = b[1] | 0;
        var bl1 = b1 & 8191;
        var bh1 = b1 >>> 13;
        var b2 = b[2] | 0;
        var bl2 = b2 & 8191;
        var bh2 = b2 >>> 13;
        var b3 = b[3] | 0;
        var bl3 = b3 & 8191;
        var bh3 = b3 >>> 13;
        var b4 = b[4] | 0;
        var bl4 = b4 & 8191;
        var bh4 = b4 >>> 13;
        var b5 = b[5] | 0;
        var bl5 = b5 & 8191;
        var bh5 = b5 >>> 13;
        var b6 = b[6] | 0;
        var bl6 = b6 & 8191;
        var bh6 = b6 >>> 13;
        var b7 = b[7] | 0;
        var bl7 = b7 & 8191;
        var bh7 = b7 >>> 13;
        var b8 = b[8] | 0;
        var bl8 = b8 & 8191;
        var bh8 = b8 >>> 13;
        var b9 = b[9] | 0;
        var bl9 = b9 & 8191;
        var bh9 = b9 >>> 13;
        out.negative = self2.negative ^ num.negative;
        out.length = 19;
        lo = Math.imul(al0, bl0);
        mid = Math.imul(al0, bh0);
        mid = mid + Math.imul(ah0, bl0) | 0;
        hi = Math.imul(ah0, bh0);
        var w0 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
        w0 &= 67108863;
        lo = Math.imul(al1, bl0);
        mid = Math.imul(al1, bh0);
        mid = mid + Math.imul(ah1, bl0) | 0;
        hi = Math.imul(ah1, bh0);
        lo = lo + Math.imul(al0, bl1) | 0;
        mid = mid + Math.imul(al0, bh1) | 0;
        mid = mid + Math.imul(ah0, bl1) | 0;
        hi = hi + Math.imul(ah0, bh1) | 0;
        var w1 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
        w1 &= 67108863;
        lo = Math.imul(al2, bl0);
        mid = Math.imul(al2, bh0);
        mid = mid + Math.imul(ah2, bl0) | 0;
        hi = Math.imul(ah2, bh0);
        lo = lo + Math.imul(al1, bl1) | 0;
        mid = mid + Math.imul(al1, bh1) | 0;
        mid = mid + Math.imul(ah1, bl1) | 0;
        hi = hi + Math.imul(ah1, bh1) | 0;
        lo = lo + Math.imul(al0, bl2) | 0;
        mid = mid + Math.imul(al0, bh2) | 0;
        mid = mid + Math.imul(ah0, bl2) | 0;
        hi = hi + Math.imul(ah0, bh2) | 0;
        var w2 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
        w2 &= 67108863;
        lo = Math.imul(al3, bl0);
        mid = Math.imul(al3, bh0);
        mid = mid + Math.imul(ah3, bl0) | 0;
        hi = Math.imul(ah3, bh0);
        lo = lo + Math.imul(al2, bl1) | 0;
        mid = mid + Math.imul(al2, bh1) | 0;
        mid = mid + Math.imul(ah2, bl1) | 0;
        hi = hi + Math.imul(ah2, bh1) | 0;
        lo = lo + Math.imul(al1, bl2) | 0;
        mid = mid + Math.imul(al1, bh2) | 0;
        mid = mid + Math.imul(ah1, bl2) | 0;
        hi = hi + Math.imul(ah1, bh2) | 0;
        lo = lo + Math.imul(al0, bl3) | 0;
        mid = mid + Math.imul(al0, bh3) | 0;
        mid = mid + Math.imul(ah0, bl3) | 0;
        hi = hi + Math.imul(ah0, bh3) | 0;
        var w3 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
        w3 &= 67108863;
        lo = Math.imul(al4, bl0);
        mid = Math.imul(al4, bh0);
        mid = mid + Math.imul(ah4, bl0) | 0;
        hi = Math.imul(ah4, bh0);
        lo = lo + Math.imul(al3, bl1) | 0;
        mid = mid + Math.imul(al3, bh1) | 0;
        mid = mid + Math.imul(ah3, bl1) | 0;
        hi = hi + Math.imul(ah3, bh1) | 0;
        lo = lo + Math.imul(al2, bl2) | 0;
        mid = mid + Math.imul(al2, bh2) | 0;
        mid = mid + Math.imul(ah2, bl2) | 0;
        hi = hi + Math.imul(ah2, bh2) | 0;
        lo = lo + Math.imul(al1, bl3) | 0;
        mid = mid + Math.imul(al1, bh3) | 0;
        mid = mid + Math.imul(ah1, bl3) | 0;
        hi = hi + Math.imul(ah1, bh3) | 0;
        lo = lo + Math.imul(al0, bl4) | 0;
        mid = mid + Math.imul(al0, bh4) | 0;
        mid = mid + Math.imul(ah0, bl4) | 0;
        hi = hi + Math.imul(ah0, bh4) | 0;
        var w4 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
        w4 &= 67108863;
        lo = Math.imul(al5, bl0);
        mid = Math.imul(al5, bh0);
        mid = mid + Math.imul(ah5, bl0) | 0;
        hi = Math.imul(ah5, bh0);
        lo = lo + Math.imul(al4, bl1) | 0;
        mid = mid + Math.imul(al4, bh1) | 0;
        mid = mid + Math.imul(ah4, bl1) | 0;
        hi = hi + Math.imul(ah4, bh1) | 0;
        lo = lo + Math.imul(al3, bl2) | 0;
        mid = mid + Math.imul(al3, bh2) | 0;
        mid = mid + Math.imul(ah3, bl2) | 0;
        hi = hi + Math.imul(ah3, bh2) | 0;
        lo = lo + Math.imul(al2, bl3) | 0;
        mid = mid + Math.imul(al2, bh3) | 0;
        mid = mid + Math.imul(ah2, bl3) | 0;
        hi = hi + Math.imul(ah2, bh3) | 0;
        lo = lo + Math.imul(al1, bl4) | 0;
        mid = mid + Math.imul(al1, bh4) | 0;
        mid = mid + Math.imul(ah1, bl4) | 0;
        hi = hi + Math.imul(ah1, bh4) | 0;
        lo = lo + Math.imul(al0, bl5) | 0;
        mid = mid + Math.imul(al0, bh5) | 0;
        mid = mid + Math.imul(ah0, bl5) | 0;
        hi = hi + Math.imul(ah0, bh5) | 0;
        var w5 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
        w5 &= 67108863;
        lo = Math.imul(al6, bl0);
        mid = Math.imul(al6, bh0);
        mid = mid + Math.imul(ah6, bl0) | 0;
        hi = Math.imul(ah6, bh0);
        lo = lo + Math.imul(al5, bl1) | 0;
        mid = mid + Math.imul(al5, bh1) | 0;
        mid = mid + Math.imul(ah5, bl1) | 0;
        hi = hi + Math.imul(ah5, bh1) | 0;
        lo = lo + Math.imul(al4, bl2) | 0;
        mid = mid + Math.imul(al4, bh2) | 0;
        mid = mid + Math.imul(ah4, bl2) | 0;
        hi = hi + Math.imul(ah4, bh2) | 0;
        lo = lo + Math.imul(al3, bl3) | 0;
        mid = mid + Math.imul(al3, bh3) | 0;
        mid = mid + Math.imul(ah3, bl3) | 0;
        hi = hi + Math.imul(ah3, bh3) | 0;
        lo = lo + Math.imul(al2, bl4) | 0;
        mid = mid + Math.imul(al2, bh4) | 0;
        mid = mid + Math.imul(ah2, bl4) | 0;
        hi = hi + Math.imul(ah2, bh4) | 0;
        lo = lo + Math.imul(al1, bl5) | 0;
        mid = mid + Math.imul(al1, bh5) | 0;
        mid = mid + Math.imul(ah1, bl5) | 0;
        hi = hi + Math.imul(ah1, bh5) | 0;
        lo = lo + Math.imul(al0, bl6) | 0;
        mid = mid + Math.imul(al0, bh6) | 0;
        mid = mid + Math.imul(ah0, bl6) | 0;
        hi = hi + Math.imul(ah0, bh6) | 0;
        var w6 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
        w6 &= 67108863;
        lo = Math.imul(al7, bl0);
        mid = Math.imul(al7, bh0);
        mid = mid + Math.imul(ah7, bl0) | 0;
        hi = Math.imul(ah7, bh0);
        lo = lo + Math.imul(al6, bl1) | 0;
        mid = mid + Math.imul(al6, bh1) | 0;
        mid = mid + Math.imul(ah6, bl1) | 0;
        hi = hi + Math.imul(ah6, bh1) | 0;
        lo = lo + Math.imul(al5, bl2) | 0;
        mid = mid + Math.imul(al5, bh2) | 0;
        mid = mid + Math.imul(ah5, bl2) | 0;
        hi = hi + Math.imul(ah5, bh2) | 0;
        lo = lo + Math.imul(al4, bl3) | 0;
        mid = mid + Math.imul(al4, bh3) | 0;
        mid = mid + Math.imul(ah4, bl3) | 0;
        hi = hi + Math.imul(ah4, bh3) | 0;
        lo = lo + Math.imul(al3, bl4) | 0;
        mid = mid + Math.imul(al3, bh4) | 0;
        mid = mid + Math.imul(ah3, bl4) | 0;
        hi = hi + Math.imul(ah3, bh4) | 0;
        lo = lo + Math.imul(al2, bl5) | 0;
        mid = mid + Math.imul(al2, bh5) | 0;
        mid = mid + Math.imul(ah2, bl5) | 0;
        hi = hi + Math.imul(ah2, bh5) | 0;
        lo = lo + Math.imul(al1, bl6) | 0;
        mid = mid + Math.imul(al1, bh6) | 0;
        mid = mid + Math.imul(ah1, bl6) | 0;
        hi = hi + Math.imul(ah1, bh6) | 0;
        lo = lo + Math.imul(al0, bl7) | 0;
        mid = mid + Math.imul(al0, bh7) | 0;
        mid = mid + Math.imul(ah0, bl7) | 0;
        hi = hi + Math.imul(ah0, bh7) | 0;
        var w7 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
        w7 &= 67108863;
        lo = Math.imul(al8, bl0);
        mid = Math.imul(al8, bh0);
        mid = mid + Math.imul(ah8, bl0) | 0;
        hi = Math.imul(ah8, bh0);
        lo = lo + Math.imul(al7, bl1) | 0;
        mid = mid + Math.imul(al7, bh1) | 0;
        mid = mid + Math.imul(ah7, bl1) | 0;
        hi = hi + Math.imul(ah7, bh1) | 0;
        lo = lo + Math.imul(al6, bl2) | 0;
        mid = mid + Math.imul(al6, bh2) | 0;
        mid = mid + Math.imul(ah6, bl2) | 0;
        hi = hi + Math.imul(ah6, bh2) | 0;
        lo = lo + Math.imul(al5, bl3) | 0;
        mid = mid + Math.imul(al5, bh3) | 0;
        mid = mid + Math.imul(ah5, bl3) | 0;
        hi = hi + Math.imul(ah5, bh3) | 0;
        lo = lo + Math.imul(al4, bl4) | 0;
        mid = mid + Math.imul(al4, bh4) | 0;
        mid = mid + Math.imul(ah4, bl4) | 0;
        hi = hi + Math.imul(ah4, bh4) | 0;
        lo = lo + Math.imul(al3, bl5) | 0;
        mid = mid + Math.imul(al3, bh5) | 0;
        mid = mid + Math.imul(ah3, bl5) | 0;
        hi = hi + Math.imul(ah3, bh5) | 0;
        lo = lo + Math.imul(al2, bl6) | 0;
        mid = mid + Math.imul(al2, bh6) | 0;
        mid = mid + Math.imul(ah2, bl6) | 0;
        hi = hi + Math.imul(ah2, bh6) | 0;
        lo = lo + Math.imul(al1, bl7) | 0;
        mid = mid + Math.imul(al1, bh7) | 0;
        mid = mid + Math.imul(ah1, bl7) | 0;
        hi = hi + Math.imul(ah1, bh7) | 0;
        lo = lo + Math.imul(al0, bl8) | 0;
        mid = mid + Math.imul(al0, bh8) | 0;
        mid = mid + Math.imul(ah0, bl8) | 0;
        hi = hi + Math.imul(ah0, bh8) | 0;
        var w8 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
        w8 &= 67108863;
        lo = Math.imul(al9, bl0);
        mid = Math.imul(al9, bh0);
        mid = mid + Math.imul(ah9, bl0) | 0;
        hi = Math.imul(ah9, bh0);
        lo = lo + Math.imul(al8, bl1) | 0;
        mid = mid + Math.imul(al8, bh1) | 0;
        mid = mid + Math.imul(ah8, bl1) | 0;
        hi = hi + Math.imul(ah8, bh1) | 0;
        lo = lo + Math.imul(al7, bl2) | 0;
        mid = mid + Math.imul(al7, bh2) | 0;
        mid = mid + Math.imul(ah7, bl2) | 0;
        hi = hi + Math.imul(ah7, bh2) | 0;
        lo = lo + Math.imul(al6, bl3) | 0;
        mid = mid + Math.imul(al6, bh3) | 0;
        mid = mid + Math.imul(ah6, bl3) | 0;
        hi = hi + Math.imul(ah6, bh3) | 0;
        lo = lo + Math.imul(al5, bl4) | 0;
        mid = mid + Math.imul(al5, bh4) | 0;
        mid = mid + Math.imul(ah5, bl4) | 0;
        hi = hi + Math.imul(ah5, bh4) | 0;
        lo = lo + Math.imul(al4, bl5) | 0;
        mid = mid + Math.imul(al4, bh5) | 0;
        mid = mid + Math.imul(ah4, bl5) | 0;
        hi = hi + Math.imul(ah4, bh5) | 0;
        lo = lo + Math.imul(al3, bl6) | 0;
        mid = mid + Math.imul(al3, bh6) | 0;
        mid = mid + Math.imul(ah3, bl6) | 0;
        hi = hi + Math.imul(ah3, bh6) | 0;
        lo = lo + Math.imul(al2, bl7) | 0;
        mid = mid + Math.imul(al2, bh7) | 0;
        mid = mid + Math.imul(ah2, bl7) | 0;
        hi = hi + Math.imul(ah2, bh7) | 0;
        lo = lo + Math.imul(al1, bl8) | 0;
        mid = mid + Math.imul(al1, bh8) | 0;
        mid = mid + Math.imul(ah1, bl8) | 0;
        hi = hi + Math.imul(ah1, bh8) | 0;
        lo = lo + Math.imul(al0, bl9) | 0;
        mid = mid + Math.imul(al0, bh9) | 0;
        mid = mid + Math.imul(ah0, bl9) | 0;
        hi = hi + Math.imul(ah0, bh9) | 0;
        var w9 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
        w9 &= 67108863;
        lo = Math.imul(al9, bl1);
        mid = Math.imul(al9, bh1);
        mid = mid + Math.imul(ah9, bl1) | 0;
        hi = Math.imul(ah9, bh1);
        lo = lo + Math.imul(al8, bl2) | 0;
        mid = mid + Math.imul(al8, bh2) | 0;
        mid = mid + Math.imul(ah8, bl2) | 0;
        hi = hi + Math.imul(ah8, bh2) | 0;
        lo = lo + Math.imul(al7, bl3) | 0;
        mid = mid + Math.imul(al7, bh3) | 0;
        mid = mid + Math.imul(ah7, bl3) | 0;
        hi = hi + Math.imul(ah7, bh3) | 0;
        lo = lo + Math.imul(al6, bl4) | 0;
        mid = mid + Math.imul(al6, bh4) | 0;
        mid = mid + Math.imul(ah6, bl4) | 0;
        hi = hi + Math.imul(ah6, bh4) | 0;
        lo = lo + Math.imul(al5, bl5) | 0;
        mid = mid + Math.imul(al5, bh5) | 0;
        mid = mid + Math.imul(ah5, bl5) | 0;
        hi = hi + Math.imul(ah5, bh5) | 0;
        lo = lo + Math.imul(al4, bl6) | 0;
        mid = mid + Math.imul(al4, bh6) | 0;
        mid = mid + Math.imul(ah4, bl6) | 0;
        hi = hi + Math.imul(ah4, bh6) | 0;
        lo = lo + Math.imul(al3, bl7) | 0;
        mid = mid + Math.imul(al3, bh7) | 0;
        mid = mid + Math.imul(ah3, bl7) | 0;
        hi = hi + Math.imul(ah3, bh7) | 0;
        lo = lo + Math.imul(al2, bl8) | 0;
        mid = mid + Math.imul(al2, bh8) | 0;
        mid = mid + Math.imul(ah2, bl8) | 0;
        hi = hi + Math.imul(ah2, bh8) | 0;
        lo = lo + Math.imul(al1, bl9) | 0;
        mid = mid + Math.imul(al1, bh9) | 0;
        mid = mid + Math.imul(ah1, bl9) | 0;
        hi = hi + Math.imul(ah1, bh9) | 0;
        var w10 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
        w10 &= 67108863;
        lo = Math.imul(al9, bl2);
        mid = Math.imul(al9, bh2);
        mid = mid + Math.imul(ah9, bl2) | 0;
        hi = Math.imul(ah9, bh2);
        lo = lo + Math.imul(al8, bl3) | 0;
        mid = mid + Math.imul(al8, bh3) | 0;
        mid = mid + Math.imul(ah8, bl3) | 0;
        hi = hi + Math.imul(ah8, bh3) | 0;
        lo = lo + Math.imul(al7, bl4) | 0;
        mid = mid + Math.imul(al7, bh4) | 0;
        mid = mid + Math.imul(ah7, bl4) | 0;
        hi = hi + Math.imul(ah7, bh4) | 0;
        lo = lo + Math.imul(al6, bl5) | 0;
        mid = mid + Math.imul(al6, bh5) | 0;
        mid = mid + Math.imul(ah6, bl5) | 0;
        hi = hi + Math.imul(ah6, bh5) | 0;
        lo = lo + Math.imul(al5, bl6) | 0;
        mid = mid + Math.imul(al5, bh6) | 0;
        mid = mid + Math.imul(ah5, bl6) | 0;
        hi = hi + Math.imul(ah5, bh6) | 0;
        lo = lo + Math.imul(al4, bl7) | 0;
        mid = mid + Math.imul(al4, bh7) | 0;
        mid = mid + Math.imul(ah4, bl7) | 0;
        hi = hi + Math.imul(ah4, bh7) | 0;
        lo = lo + Math.imul(al3, bl8) | 0;
        mid = mid + Math.imul(al3, bh8) | 0;
        mid = mid + Math.imul(ah3, bl8) | 0;
        hi = hi + Math.imul(ah3, bh8) | 0;
        lo = lo + Math.imul(al2, bl9) | 0;
        mid = mid + Math.imul(al2, bh9) | 0;
        mid = mid + Math.imul(ah2, bl9) | 0;
        hi = hi + Math.imul(ah2, bh9) | 0;
        var w11 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
        w11 &= 67108863;
        lo = Math.imul(al9, bl3);
        mid = Math.imul(al9, bh3);
        mid = mid + Math.imul(ah9, bl3) | 0;
        hi = Math.imul(ah9, bh3);
        lo = lo + Math.imul(al8, bl4) | 0;
        mid = mid + Math.imul(al8, bh4) | 0;
        mid = mid + Math.imul(ah8, bl4) | 0;
        hi = hi + Math.imul(ah8, bh4) | 0;
        lo = lo + Math.imul(al7, bl5) | 0;
        mid = mid + Math.imul(al7, bh5) | 0;
        mid = mid + Math.imul(ah7, bl5) | 0;
        hi = hi + Math.imul(ah7, bh5) | 0;
        lo = lo + Math.imul(al6, bl6) | 0;
        mid = mid + Math.imul(al6, bh6) | 0;
        mid = mid + Math.imul(ah6, bl6) | 0;
        hi = hi + Math.imul(ah6, bh6) | 0;
        lo = lo + Math.imul(al5, bl7) | 0;
        mid = mid + Math.imul(al5, bh7) | 0;
        mid = mid + Math.imul(ah5, bl7) | 0;
        hi = hi + Math.imul(ah5, bh7) | 0;
        lo = lo + Math.imul(al4, bl8) | 0;
        mid = mid + Math.imul(al4, bh8) | 0;
        mid = mid + Math.imul(ah4, bl8) | 0;
        hi = hi + Math.imul(ah4, bh8) | 0;
        lo = lo + Math.imul(al3, bl9) | 0;
        mid = mid + Math.imul(al3, bh9) | 0;
        mid = mid + Math.imul(ah3, bl9) | 0;
        hi = hi + Math.imul(ah3, bh9) | 0;
        var w12 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
        w12 &= 67108863;
        lo = Math.imul(al9, bl4);
        mid = Math.imul(al9, bh4);
        mid = mid + Math.imul(ah9, bl4) | 0;
        hi = Math.imul(ah9, bh4);
        lo = lo + Math.imul(al8, bl5) | 0;
        mid = mid + Math.imul(al8, bh5) | 0;
        mid = mid + Math.imul(ah8, bl5) | 0;
        hi = hi + Math.imul(ah8, bh5) | 0;
        lo = lo + Math.imul(al7, bl6) | 0;
        mid = mid + Math.imul(al7, bh6) | 0;
        mid = mid + Math.imul(ah7, bl6) | 0;
        hi = hi + Math.imul(ah7, bh6) | 0;
        lo = lo + Math.imul(al6, bl7) | 0;
        mid = mid + Math.imul(al6, bh7) | 0;
        mid = mid + Math.imul(ah6, bl7) | 0;
        hi = hi + Math.imul(ah6, bh7) | 0;
        lo = lo + Math.imul(al5, bl8) | 0;
        mid = mid + Math.imul(al5, bh8) | 0;
        mid = mid + Math.imul(ah5, bl8) | 0;
        hi = hi + Math.imul(ah5, bh8) | 0;
        lo = lo + Math.imul(al4, bl9) | 0;
        mid = mid + Math.imul(al4, bh9) | 0;
        mid = mid + Math.imul(ah4, bl9) | 0;
        hi = hi + Math.imul(ah4, bh9) | 0;
        var w13 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
        w13 &= 67108863;
        lo = Math.imul(al9, bl5);
        mid = Math.imul(al9, bh5);
        mid = mid + Math.imul(ah9, bl5) | 0;
        hi = Math.imul(ah9, bh5);
        lo = lo + Math.imul(al8, bl6) | 0;
        mid = mid + Math.imul(al8, bh6) | 0;
        mid = mid + Math.imul(ah8, bl6) | 0;
        hi = hi + Math.imul(ah8, bh6) | 0;
        lo = lo + Math.imul(al7, bl7) | 0;
        mid = mid + Math.imul(al7, bh7) | 0;
        mid = mid + Math.imul(ah7, bl7) | 0;
        hi = hi + Math.imul(ah7, bh7) | 0;
        lo = lo + Math.imul(al6, bl8) | 0;
        mid = mid + Math.imul(al6, bh8) | 0;
        mid = mid + Math.imul(ah6, bl8) | 0;
        hi = hi + Math.imul(ah6, bh8) | 0;
        lo = lo + Math.imul(al5, bl9) | 0;
        mid = mid + Math.imul(al5, bh9) | 0;
        mid = mid + Math.imul(ah5, bl9) | 0;
        hi = hi + Math.imul(ah5, bh9) | 0;
        var w14 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
        w14 &= 67108863;
        lo = Math.imul(al9, bl6);
        mid = Math.imul(al9, bh6);
        mid = mid + Math.imul(ah9, bl6) | 0;
        hi = Math.imul(ah9, bh6);
        lo = lo + Math.imul(al8, bl7) | 0;
        mid = mid + Math.imul(al8, bh7) | 0;
        mid = mid + Math.imul(ah8, bl7) | 0;
        hi = hi + Math.imul(ah8, bh7) | 0;
        lo = lo + Math.imul(al7, bl8) | 0;
        mid = mid + Math.imul(al7, bh8) | 0;
        mid = mid + Math.imul(ah7, bl8) | 0;
        hi = hi + Math.imul(ah7, bh8) | 0;
        lo = lo + Math.imul(al6, bl9) | 0;
        mid = mid + Math.imul(al6, bh9) | 0;
        mid = mid + Math.imul(ah6, bl9) | 0;
        hi = hi + Math.imul(ah6, bh9) | 0;
        var w15 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
        w15 &= 67108863;
        lo = Math.imul(al9, bl7);
        mid = Math.imul(al9, bh7);
        mid = mid + Math.imul(ah9, bl7) | 0;
        hi = Math.imul(ah9, bh7);
        lo = lo + Math.imul(al8, bl8) | 0;
        mid = mid + Math.imul(al8, bh8) | 0;
        mid = mid + Math.imul(ah8, bl8) | 0;
        hi = hi + Math.imul(ah8, bh8) | 0;
        lo = lo + Math.imul(al7, bl9) | 0;
        mid = mid + Math.imul(al7, bh9) | 0;
        mid = mid + Math.imul(ah7, bl9) | 0;
        hi = hi + Math.imul(ah7, bh9) | 0;
        var w16 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
        w16 &= 67108863;
        lo = Math.imul(al9, bl8);
        mid = Math.imul(al9, bh8);
        mid = mid + Math.imul(ah9, bl8) | 0;
        hi = Math.imul(ah9, bh8);
        lo = lo + Math.imul(al8, bl9) | 0;
        mid = mid + Math.imul(al8, bh9) | 0;
        mid = mid + Math.imul(ah8, bl9) | 0;
        hi = hi + Math.imul(ah8, bh9) | 0;
        var w17 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
        w17 &= 67108863;
        lo = Math.imul(al9, bl9);
        mid = Math.imul(al9, bh9);
        mid = mid + Math.imul(ah9, bl9) | 0;
        hi = Math.imul(ah9, bh9);
        var w18 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
        w18 &= 67108863;
        o[0] = w0;
        o[1] = w1;
        o[2] = w2;
        o[3] = w3;
        o[4] = w4;
        o[5] = w5;
        o[6] = w6;
        o[7] = w7;
        o[8] = w8;
        o[9] = w9;
        o[10] = w10;
        o[11] = w11;
        o[12] = w12;
        o[13] = w13;
        o[14] = w14;
        o[15] = w15;
        o[16] = w16;
        o[17] = w17;
        o[18] = w18;
        if (c !== 0) {
          o[19] = c;
          out.length++;
        }
        return out;
      };
      if (!Math.imul) {
        comb10MulTo = smallMulTo;
      }
      function bigMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        out.length = self2.length + num.length;
        var carry = 0;
        var hncarry = 0;
        for (var k = 0; k < out.length - 1; k++) {
          var ncarry = hncarry;
          hncarry = 0;
          var rword = carry & 67108863;
          var maxJ = Math.min(k, num.length - 1);
          for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
            var i = k - j;
            var a = self2.words[i] | 0;
            var b = num.words[j] | 0;
            var r = a * b;
            var lo = r & 67108863;
            ncarry = ncarry + (r / 67108864 | 0) | 0;
            lo = lo + rword | 0;
            rword = lo & 67108863;
            ncarry = ncarry + (lo >>> 26) | 0;
            hncarry += ncarry >>> 26;
            ncarry &= 67108863;
          }
          out.words[k] = rword;
          carry = ncarry;
          ncarry = hncarry;
        }
        if (carry !== 0) {
          out.words[k] = carry;
        } else {
          out.length--;
        }
        return out._strip();
      }
      function jumboMulTo(self2, num, out) {
        return bigMulTo(self2, num, out);
      }
      BN2.prototype.mulTo = function mulTo(num, out) {
        var res;
        var len = this.length + num.length;
        if (this.length === 10 && num.length === 10) {
          res = comb10MulTo(this, num, out);
        } else if (len < 63) {
          res = smallMulTo(this, num, out);
        } else if (len < 1024) {
          res = bigMulTo(this, num, out);
        } else {
          res = jumboMulTo(this, num, out);
        }
        return res;
      };
      function FFTM(x, y) {
        this.x = x;
        this.y = y;
      }
      FFTM.prototype.makeRBT = function makeRBT(N) {
        var t = new Array(N);
        var l = BN2.prototype._countBits(N) - 1;
        for (var i = 0; i < N; i++) {
          t[i] = this.revBin(i, l, N);
        }
        return t;
      };
      FFTM.prototype.revBin = function revBin(x, l, N) {
        if (x === 0 || x === N - 1)
          return x;
        var rb = 0;
        for (var i = 0; i < l; i++) {
          rb |= (x & 1) << l - i - 1;
          x >>= 1;
        }
        return rb;
      };
      FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N) {
        for (var i = 0; i < N; i++) {
          rtws[i] = rws[rbt[i]];
          itws[i] = iws[rbt[i]];
        }
      };
      FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N, rbt) {
        this.permute(rbt, rws, iws, rtws, itws, N);
        for (var s = 1; s < N; s <<= 1) {
          var l = s << 1;
          var rtwdf = Math.cos(2 * Math.PI / l);
          var itwdf = Math.sin(2 * Math.PI / l);
          for (var p = 0; p < N; p += l) {
            var rtwdf_ = rtwdf;
            var itwdf_ = itwdf;
            for (var j = 0; j < s; j++) {
              var re = rtws[p + j];
              var ie = itws[p + j];
              var ro = rtws[p + j + s];
              var io = itws[p + j + s];
              var rx = rtwdf_ * ro - itwdf_ * io;
              io = rtwdf_ * io + itwdf_ * ro;
              ro = rx;
              rtws[p + j] = re + ro;
              itws[p + j] = ie + io;
              rtws[p + j + s] = re - ro;
              itws[p + j + s] = ie - io;
              if (j !== l) {
                rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                rtwdf_ = rx;
              }
            }
          }
        }
      };
      FFTM.prototype.guessLen13b = function guessLen13b(n, m) {
        var N = Math.max(m, n) | 1;
        var odd = N & 1;
        var i = 0;
        for (N = N / 2 | 0; N; N = N >>> 1) {
          i++;
        }
        return 1 << i + 1 + odd;
      };
      FFTM.prototype.conjugate = function conjugate(rws, iws, N) {
        if (N <= 1)
          return;
        for (var i = 0; i < N / 2; i++) {
          var t = rws[i];
          rws[i] = rws[N - i - 1];
          rws[N - i - 1] = t;
          t = iws[i];
          iws[i] = -iws[N - i - 1];
          iws[N - i - 1] = -t;
        }
      };
      FFTM.prototype.normalize13b = function normalize13b(ws, N) {
        var carry = 0;
        for (var i = 0; i < N / 2; i++) {
          var w = Math.round(ws[2 * i + 1] / N) * 8192 + Math.round(ws[2 * i] / N) + carry;
          ws[i] = w & 67108863;
          if (w < 67108864) {
            carry = 0;
          } else {
            carry = w / 67108864 | 0;
          }
        }
        return ws;
      };
      FFTM.prototype.convert13b = function convert13b(ws, len, rws, N) {
        var carry = 0;
        for (var i = 0; i < len; i++) {
          carry = carry + (ws[i] | 0);
          rws[2 * i] = carry & 8191;
          carry = carry >>> 13;
          rws[2 * i + 1] = carry & 8191;
          carry = carry >>> 13;
        }
        for (i = 2 * len; i < N; ++i) {
          rws[i] = 0;
        }
        assert(carry === 0);
        assert((carry & ~8191) === 0);
      };
      FFTM.prototype.stub = function stub(N) {
        var ph = new Array(N);
        for (var i = 0; i < N; i++) {
          ph[i] = 0;
        }
        return ph;
      };
      FFTM.prototype.mulp = function mulp(x, y, out) {
        var N = 2 * this.guessLen13b(x.length, y.length);
        var rbt = this.makeRBT(N);
        var _ = this.stub(N);
        var rws = new Array(N);
        var rwst = new Array(N);
        var iwst = new Array(N);
        var nrws = new Array(N);
        var nrwst = new Array(N);
        var niwst = new Array(N);
        var rmws = out.words;
        rmws.length = N;
        this.convert13b(x.words, x.length, rws, N);
        this.convert13b(y.words, y.length, nrws, N);
        this.transform(rws, _, rwst, iwst, N, rbt);
        this.transform(nrws, _, nrwst, niwst, N, rbt);
        for (var i = 0; i < N; i++) {
          var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
          iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
          rwst[i] = rx;
        }
        this.conjugate(rwst, iwst, N);
        this.transform(rwst, iwst, rmws, _, N, rbt);
        this.conjugate(rmws, _, N);
        this.normalize13b(rmws, N);
        out.negative = x.negative ^ y.negative;
        out.length = x.length + y.length;
        return out._strip();
      };
      BN2.prototype.mul = function mul3(num) {
        var out = new BN2(null);
        out.words = new Array(this.length + num.length);
        return this.mulTo(num, out);
      };
      BN2.prototype.mulf = function mulf(num) {
        var out = new BN2(null);
        out.words = new Array(this.length + num.length);
        return jumboMulTo(this, num, out);
      };
      BN2.prototype.imul = function imul(num) {
        return this.clone().mulTo(num, this);
      };
      BN2.prototype.imuln = function imuln(num) {
        var isNegNum = num < 0;
        if (isNegNum)
          num = -num;
        assert(typeof num === "number");
        assert(num < 67108864);
        var carry = 0;
        for (var i = 0; i < this.length; i++) {
          var w = (this.words[i] | 0) * num;
          var lo = (w & 67108863) + (carry & 67108863);
          carry >>= 26;
          carry += w / 67108864 | 0;
          carry += lo >>> 26;
          this.words[i] = lo & 67108863;
        }
        if (carry !== 0) {
          this.words[i] = carry;
          this.length++;
        }
        this.length = num === 0 ? 1 : this.length;
        return isNegNum ? this.ineg() : this;
      };
      BN2.prototype.muln = function muln(num) {
        return this.clone().imuln(num);
      };
      BN2.prototype.sqr = function sqr() {
        return this.mul(this);
      };
      BN2.prototype.isqr = function isqr() {
        return this.imul(this.clone());
      };
      BN2.prototype.pow = function pow2(num) {
        var w = toBitArray(num);
        if (w.length === 0)
          return new BN2(1);
        var res = this;
        for (var i = 0; i < w.length; i++, res = res.sqr()) {
          if (w[i] !== 0)
            break;
        }
        if (++i < w.length) {
          for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
            if (w[i] === 0)
              continue;
            res = res.mul(q);
          }
        }
        return res;
      };
      BN2.prototype.iushln = function iushln(bits2) {
        assert(typeof bits2 === "number" && bits2 >= 0);
        var r = bits2 % 26;
        var s = (bits2 - r) / 26;
        var carryMask = 67108863 >>> 26 - r << 26 - r;
        var i;
        if (r !== 0) {
          var carry = 0;
          for (i = 0; i < this.length; i++) {
            var newCarry = this.words[i] & carryMask;
            var c = (this.words[i] | 0) - newCarry << r;
            this.words[i] = c | carry;
            carry = newCarry >>> 26 - r;
          }
          if (carry) {
            this.words[i] = carry;
            this.length++;
          }
        }
        if (s !== 0) {
          for (i = this.length - 1; i >= 0; i--) {
            this.words[i + s] = this.words[i];
          }
          for (i = 0; i < s; i++) {
            this.words[i] = 0;
          }
          this.length += s;
        }
        return this._strip();
      };
      BN2.prototype.ishln = function ishln(bits2) {
        assert(this.negative === 0);
        return this.iushln(bits2);
      };
      BN2.prototype.iushrn = function iushrn(bits2, hint, extended) {
        assert(typeof bits2 === "number" && bits2 >= 0);
        var h;
        if (hint) {
          h = (hint - hint % 26) / 26;
        } else {
          h = 0;
        }
        var r = bits2 % 26;
        var s = Math.min((bits2 - r) / 26, this.length);
        var mask = 67108863 ^ 67108863 >>> r << r;
        var maskedWords = extended;
        h -= s;
        h = Math.max(0, h);
        if (maskedWords) {
          for (var i = 0; i < s; i++) {
            maskedWords.words[i] = this.words[i];
          }
          maskedWords.length = s;
        }
        if (s === 0) {
        } else if (this.length > s) {
          this.length -= s;
          for (i = 0; i < this.length; i++) {
            this.words[i] = this.words[i + s];
          }
        } else {
          this.words[0] = 0;
          this.length = 1;
        }
        var carry = 0;
        for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
          var word = this.words[i] | 0;
          this.words[i] = carry << 26 - r | word >>> r;
          carry = word & mask;
        }
        if (maskedWords && carry !== 0) {
          maskedWords.words[maskedWords.length++] = carry;
        }
        if (this.length === 0) {
          this.words[0] = 0;
          this.length = 1;
        }
        return this._strip();
      };
      BN2.prototype.ishrn = function ishrn(bits2, hint, extended) {
        assert(this.negative === 0);
        return this.iushrn(bits2, hint, extended);
      };
      BN2.prototype.shln = function shln(bits2) {
        return this.clone().ishln(bits2);
      };
      BN2.prototype.ushln = function ushln(bits2) {
        return this.clone().iushln(bits2);
      };
      BN2.prototype.shrn = function shrn(bits2) {
        return this.clone().ishrn(bits2);
      };
      BN2.prototype.ushrn = function ushrn(bits2) {
        return this.clone().iushrn(bits2);
      };
      BN2.prototype.testn = function testn(bit) {
        assert(typeof bit === "number" && bit >= 0);
        var r = bit % 26;
        var s = (bit - r) / 26;
        var q = 1 << r;
        if (this.length <= s)
          return false;
        var w = this.words[s];
        return !!(w & q);
      };
      BN2.prototype.imaskn = function imaskn(bits2) {
        assert(typeof bits2 === "number" && bits2 >= 0);
        var r = bits2 % 26;
        var s = (bits2 - r) / 26;
        assert(this.negative === 0, "imaskn works only with positive numbers");
        if (this.length <= s) {
          return this;
        }
        if (r !== 0) {
          s++;
        }
        this.length = Math.min(s, this.length);
        if (r !== 0) {
          var mask = 67108863 ^ 67108863 >>> r << r;
          this.words[this.length - 1] &= mask;
        }
        return this._strip();
      };
      BN2.prototype.maskn = function maskn(bits2) {
        return this.clone().imaskn(bits2);
      };
      BN2.prototype.iaddn = function iaddn(num) {
        assert(typeof num === "number");
        assert(num < 67108864);
        if (num < 0)
          return this.isubn(-num);
        if (this.negative !== 0) {
          if (this.length === 1 && (this.words[0] | 0) <= num) {
            this.words[0] = num - (this.words[0] | 0);
            this.negative = 0;
            return this;
          }
          this.negative = 0;
          this.isubn(num);
          this.negative = 1;
          return this;
        }
        return this._iaddn(num);
      };
      BN2.prototype._iaddn = function _iaddn(num) {
        this.words[0] += num;
        for (var i = 0; i < this.length && this.words[i] >= 67108864; i++) {
          this.words[i] -= 67108864;
          if (i === this.length - 1) {
            this.words[i + 1] = 1;
          } else {
            this.words[i + 1]++;
          }
        }
        this.length = Math.max(this.length, i + 1);
        return this;
      };
      BN2.prototype.isubn = function isubn(num) {
        assert(typeof num === "number");
        assert(num < 67108864);
        if (num < 0)
          return this.iaddn(-num);
        if (this.negative !== 0) {
          this.negative = 0;
          this.iaddn(num);
          this.negative = 1;
          return this;
        }
        this.words[0] -= num;
        if (this.length === 1 && this.words[0] < 0) {
          this.words[0] = -this.words[0];
          this.negative = 1;
        } else {
          for (var i = 0; i < this.length && this.words[i] < 0; i++) {
            this.words[i] += 67108864;
            this.words[i + 1] -= 1;
          }
        }
        return this._strip();
      };
      BN2.prototype.addn = function addn(num) {
        return this.clone().iaddn(num);
      };
      BN2.prototype.subn = function subn(num) {
        return this.clone().isubn(num);
      };
      BN2.prototype.iabs = function iabs() {
        this.negative = 0;
        return this;
      };
      BN2.prototype.abs = function abs2() {
        return this.clone().iabs();
      };
      BN2.prototype._ishlnsubmul = function _ishlnsubmul(num, mul3, shift) {
        var len = num.length + shift;
        var i;
        this._expand(len);
        var w;
        var carry = 0;
        for (i = 0; i < num.length; i++) {
          w = (this.words[i + shift] | 0) + carry;
          var right = (num.words[i] | 0) * mul3;
          w -= right & 67108863;
          carry = (w >> 26) - (right / 67108864 | 0);
          this.words[i + shift] = w & 67108863;
        }
        for (; i < this.length - shift; i++) {
          w = (this.words[i + shift] | 0) + carry;
          carry = w >> 26;
          this.words[i + shift] = w & 67108863;
        }
        if (carry === 0)
          return this._strip();
        assert(carry === -1);
        carry = 0;
        for (i = 0; i < this.length; i++) {
          w = -(this.words[i] | 0) + carry;
          carry = w >> 26;
          this.words[i] = w & 67108863;
        }
        this.negative = 1;
        return this._strip();
      };
      BN2.prototype._wordDiv = function _wordDiv(num, mode) {
        var shift = this.length - num.length;
        var a = this.clone();
        var b = num;
        var bhi = b.words[b.length - 1] | 0;
        var bhiBits = this._countBits(bhi);
        shift = 26 - bhiBits;
        if (shift !== 0) {
          b = b.ushln(shift);
          a.iushln(shift);
          bhi = b.words[b.length - 1] | 0;
        }
        var m = a.length - b.length;
        var q;
        if (mode !== "mod") {
          q = new BN2(null);
          q.length = m + 1;
          q.words = new Array(q.length);
          for (var i = 0; i < q.length; i++) {
            q.words[i] = 0;
          }
        }
        var diff = a.clone()._ishlnsubmul(b, 1, m);
        if (diff.negative === 0) {
          a = diff;
          if (q) {
            q.words[m] = 1;
          }
        }
        for (var j = m - 1; j >= 0; j--) {
          var qj = (a.words[b.length + j] | 0) * 67108864 + (a.words[b.length + j - 1] | 0);
          qj = Math.min(qj / bhi | 0, 67108863);
          a._ishlnsubmul(b, qj, j);
          while (a.negative !== 0) {
            qj--;
            a.negative = 0;
            a._ishlnsubmul(b, 1, j);
            if (!a.isZero()) {
              a.negative ^= 1;
            }
          }
          if (q) {
            q.words[j] = qj;
          }
        }
        if (q) {
          q._strip();
        }
        a._strip();
        if (mode !== "div" && shift !== 0) {
          a.iushrn(shift);
        }
        return {
          div: q || null,
          mod: a
        };
      };
      BN2.prototype.divmod = function divmod(num, mode, positive) {
        assert(!num.isZero());
        if (this.isZero()) {
          return {
            div: new BN2(0),
            mod: new BN2(0)
          };
        }
        var div3, mod2, res;
        if (this.negative !== 0 && num.negative === 0) {
          res = this.neg().divmod(num, mode);
          if (mode !== "mod") {
            div3 = res.div.neg();
          }
          if (mode !== "div") {
            mod2 = res.mod.neg();
            if (positive && mod2.negative !== 0) {
              mod2.iadd(num);
            }
          }
          return {
            div: div3,
            mod: mod2
          };
        }
        if (this.negative === 0 && num.negative !== 0) {
          res = this.divmod(num.neg(), mode);
          if (mode !== "mod") {
            div3 = res.div.neg();
          }
          return {
            div: div3,
            mod: res.mod
          };
        }
        if ((this.negative & num.negative) !== 0) {
          res = this.neg().divmod(num.neg(), mode);
          if (mode !== "div") {
            mod2 = res.mod.neg();
            if (positive && mod2.negative !== 0) {
              mod2.isub(num);
            }
          }
          return {
            div: res.div,
            mod: mod2
          };
        }
        if (num.length > this.length || this.cmp(num) < 0) {
          return {
            div: new BN2(0),
            mod: this
          };
        }
        if (num.length === 1) {
          if (mode === "div") {
            return {
              div: this.divn(num.words[0]),
              mod: null
            };
          }
          if (mode === "mod") {
            return {
              div: null,
              mod: new BN2(this.modrn(num.words[0]))
            };
          }
          return {
            div: this.divn(num.words[0]),
            mod: new BN2(this.modrn(num.words[0]))
          };
        }
        return this._wordDiv(num, mode);
      };
      BN2.prototype.div = function div3(num) {
        return this.divmod(num, "div", false).div;
      };
      BN2.prototype.mod = function mod2(num) {
        return this.divmod(num, "mod", false).mod;
      };
      BN2.prototype.umod = function umod(num) {
        return this.divmod(num, "mod", true).mod;
      };
      BN2.prototype.divRound = function divRound(num) {
        var dm = this.divmod(num);
        if (dm.mod.isZero())
          return dm.div;
        var mod2 = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
        var half = num.ushrn(1);
        var r2 = num.andln(1);
        var cmp = mod2.cmp(half);
        if (cmp < 0 || r2 === 1 && cmp === 0)
          return dm.div;
        return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
      };
      BN2.prototype.modrn = function modrn(num) {
        var isNegNum = num < 0;
        if (isNegNum)
          num = -num;
        assert(num <= 67108863);
        var p = (1 << 26) % num;
        var acc = 0;
        for (var i = this.length - 1; i >= 0; i--) {
          acc = (p * acc + (this.words[i] | 0)) % num;
        }
        return isNegNum ? -acc : acc;
      };
      BN2.prototype.modn = function modn(num) {
        return this.modrn(num);
      };
      BN2.prototype.idivn = function idivn(num) {
        var isNegNum = num < 0;
        if (isNegNum)
          num = -num;
        assert(num <= 67108863);
        var carry = 0;
        for (var i = this.length - 1; i >= 0; i--) {
          var w = (this.words[i] | 0) + carry * 67108864;
          this.words[i] = w / num | 0;
          carry = w % num;
        }
        this._strip();
        return isNegNum ? this.ineg() : this;
      };
      BN2.prototype.divn = function divn(num) {
        return this.clone().idivn(num);
      };
      BN2.prototype.egcd = function egcd(p) {
        assert(p.negative === 0);
        assert(!p.isZero());
        var x = this;
        var y = p.clone();
        if (x.negative !== 0) {
          x = x.umod(p);
        } else {
          x = x.clone();
        }
        var A = new BN2(1);
        var B = new BN2(0);
        var C = new BN2(0);
        var D = new BN2(1);
        var g = 0;
        while (x.isEven() && y.isEven()) {
          x.iushrn(1);
          y.iushrn(1);
          ++g;
        }
        var yp = y.clone();
        var xp = x.clone();
        while (!x.isZero()) {
          for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1)
            ;
          if (i > 0) {
            x.iushrn(i);
            while (i-- > 0) {
              if (A.isOdd() || B.isOdd()) {
                A.iadd(yp);
                B.isub(xp);
              }
              A.iushrn(1);
              B.iushrn(1);
            }
          }
          for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
            ;
          if (j > 0) {
            y.iushrn(j);
            while (j-- > 0) {
              if (C.isOdd() || D.isOdd()) {
                C.iadd(yp);
                D.isub(xp);
              }
              C.iushrn(1);
              D.iushrn(1);
            }
          }
          if (x.cmp(y) >= 0) {
            x.isub(y);
            A.isub(C);
            B.isub(D);
          } else {
            y.isub(x);
            C.isub(A);
            D.isub(B);
          }
        }
        return {
          a: C,
          b: D,
          gcd: y.iushln(g)
        };
      };
      BN2.prototype._invmp = function _invmp(p) {
        assert(p.negative === 0);
        assert(!p.isZero());
        var a = this;
        var b = p.clone();
        if (a.negative !== 0) {
          a = a.umod(p);
        } else {
          a = a.clone();
        }
        var x1 = new BN2(1);
        var x2 = new BN2(0);
        var delta = b.clone();
        while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
          for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1)
            ;
          if (i > 0) {
            a.iushrn(i);
            while (i-- > 0) {
              if (x1.isOdd()) {
                x1.iadd(delta);
              }
              x1.iushrn(1);
            }
          }
          for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
            ;
          if (j > 0) {
            b.iushrn(j);
            while (j-- > 0) {
              if (x2.isOdd()) {
                x2.iadd(delta);
              }
              x2.iushrn(1);
            }
          }
          if (a.cmp(b) >= 0) {
            a.isub(b);
            x1.isub(x2);
          } else {
            b.isub(a);
            x2.isub(x1);
          }
        }
        var res;
        if (a.cmpn(1) === 0) {
          res = x1;
        } else {
          res = x2;
        }
        if (res.cmpn(0) < 0) {
          res.iadd(p);
        }
        return res;
      };
      BN2.prototype.gcd = function gcd(num) {
        if (this.isZero())
          return num.abs();
        if (num.isZero())
          return this.abs();
        var a = this.clone();
        var b = num.clone();
        a.negative = 0;
        b.negative = 0;
        for (var shift = 0; a.isEven() && b.isEven(); shift++) {
          a.iushrn(1);
          b.iushrn(1);
        }
        do {
          while (a.isEven()) {
            a.iushrn(1);
          }
          while (b.isEven()) {
            b.iushrn(1);
          }
          var r = a.cmp(b);
          if (r < 0) {
            var t = a;
            a = b;
            b = t;
          } else if (r === 0 || b.cmpn(1) === 0) {
            break;
          }
          a.isub(b);
        } while (true);
        return b.iushln(shift);
      };
      BN2.prototype.invm = function invm(num) {
        return this.egcd(num).a.umod(num);
      };
      BN2.prototype.isEven = function isEven() {
        return (this.words[0] & 1) === 0;
      };
      BN2.prototype.isOdd = function isOdd3() {
        return (this.words[0] & 1) === 1;
      };
      BN2.prototype.andln = function andln(num) {
        return this.words[0] & num;
      };
      BN2.prototype.bincn = function bincn(bit) {
        assert(typeof bit === "number");
        var r = bit % 26;
        var s = (bit - r) / 26;
        var q = 1 << r;
        if (this.length <= s) {
          this._expand(s + 1);
          this.words[s] |= q;
          return this;
        }
        var carry = q;
        for (var i = s; carry !== 0 && i < this.length; i++) {
          var w = this.words[i] | 0;
          w += carry;
          carry = w >>> 26;
          w &= 67108863;
          this.words[i] = w;
        }
        if (carry !== 0) {
          this.words[i] = carry;
          this.length++;
        }
        return this;
      };
      BN2.prototype.isZero = function isZero2() {
        return this.length === 1 && this.words[0] === 0;
      };
      BN2.prototype.cmpn = function cmpn(num) {
        var negative = num < 0;
        if (this.negative !== 0 && !negative)
          return -1;
        if (this.negative === 0 && negative)
          return 1;
        this._strip();
        var res;
        if (this.length > 1) {
          res = 1;
        } else {
          if (negative) {
            num = -num;
          }
          assert(num <= 67108863, "Number is too big");
          var w = this.words[0] | 0;
          res = w === num ? 0 : w < num ? -1 : 1;
        }
        if (this.negative !== 0)
          return -res | 0;
        return res;
      };
      BN2.prototype.cmp = function cmp(num) {
        if (this.negative !== 0 && num.negative === 0)
          return -1;
        if (this.negative === 0 && num.negative !== 0)
          return 1;
        var res = this.ucmp(num);
        if (this.negative !== 0)
          return -res | 0;
        return res;
      };
      BN2.prototype.ucmp = function ucmp(num) {
        if (this.length > num.length)
          return 1;
        if (this.length < num.length)
          return -1;
        var res = 0;
        for (var i = this.length - 1; i >= 0; i--) {
          var a = this.words[i] | 0;
          var b = num.words[i] | 0;
          if (a === b)
            continue;
          if (a < b) {
            res = -1;
          } else if (a > b) {
            res = 1;
          }
          break;
        }
        return res;
      };
      BN2.prototype.gtn = function gtn(num) {
        return this.cmpn(num) === 1;
      };
      BN2.prototype.gt = function gt(num) {
        return this.cmp(num) === 1;
      };
      BN2.prototype.gten = function gten(num) {
        return this.cmpn(num) >= 0;
      };
      BN2.prototype.gte = function gte2(num) {
        return this.cmp(num) >= 0;
      };
      BN2.prototype.ltn = function ltn(num) {
        return this.cmpn(num) === -1;
      };
      BN2.prototype.lt = function lt(num) {
        return this.cmp(num) === -1;
      };
      BN2.prototype.lten = function lten(num) {
        return this.cmpn(num) <= 0;
      };
      BN2.prototype.lte = function lte2(num) {
        return this.cmp(num) <= 0;
      };
      BN2.prototype.eqn = function eqn(num) {
        return this.cmpn(num) === 0;
      };
      BN2.prototype.eq = function eq2(num) {
        return this.cmp(num) === 0;
      };
      BN2.red = function red(num) {
        return new Red(num);
      };
      BN2.prototype.toRed = function toRed(ctx) {
        assert(!this.red, "Already a number in reduction context");
        assert(this.negative === 0, "red works only with positives");
        return ctx.convertTo(this)._forceRed(ctx);
      };
      BN2.prototype.fromRed = function fromRed() {
        assert(this.red, "fromRed works only with numbers in reduction context");
        return this.red.convertFrom(this);
      };
      BN2.prototype._forceRed = function _forceRed(ctx) {
        this.red = ctx;
        return this;
      };
      BN2.prototype.forceRed = function forceRed(ctx) {
        assert(!this.red, "Already a number in reduction context");
        return this._forceRed(ctx);
      };
      BN2.prototype.redAdd = function redAdd(num) {
        assert(this.red, "redAdd works only with red numbers");
        return this.red.add(this, num);
      };
      BN2.prototype.redIAdd = function redIAdd(num) {
        assert(this.red, "redIAdd works only with red numbers");
        return this.red.iadd(this, num);
      };
      BN2.prototype.redSub = function redSub(num) {
        assert(this.red, "redSub works only with red numbers");
        return this.red.sub(this, num);
      };
      BN2.prototype.redISub = function redISub(num) {
        assert(this.red, "redISub works only with red numbers");
        return this.red.isub(this, num);
      };
      BN2.prototype.redShl = function redShl(num) {
        assert(this.red, "redShl works only with red numbers");
        return this.red.shl(this, num);
      };
      BN2.prototype.redMul = function redMul(num) {
        assert(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.mul(this, num);
      };
      BN2.prototype.redIMul = function redIMul(num) {
        assert(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.imul(this, num);
      };
      BN2.prototype.redSqr = function redSqr() {
        assert(this.red, "redSqr works only with red numbers");
        this.red._verify1(this);
        return this.red.sqr(this);
      };
      BN2.prototype.redISqr = function redISqr() {
        assert(this.red, "redISqr works only with red numbers");
        this.red._verify1(this);
        return this.red.isqr(this);
      };
      BN2.prototype.redSqrt = function redSqrt() {
        assert(this.red, "redSqrt works only with red numbers");
        this.red._verify1(this);
        return this.red.sqrt(this);
      };
      BN2.prototype.redInvm = function redInvm() {
        assert(this.red, "redInvm works only with red numbers");
        this.red._verify1(this);
        return this.red.invm(this);
      };
      BN2.prototype.redNeg = function redNeg() {
        assert(this.red, "redNeg works only with red numbers");
        this.red._verify1(this);
        return this.red.neg(this);
      };
      BN2.prototype.redPow = function redPow(num) {
        assert(this.red && !num.red, "redPow(normalNum)");
        this.red._verify1(this);
        return this.red.pow(this, num);
      };
      var primes = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };
      function MPrime(name, p) {
        this.name = name;
        this.p = new BN2(p, 16);
        this.n = this.p.bitLength();
        this.k = new BN2(1).iushln(this.n).isub(this.p);
        this.tmp = this._tmp();
      }
      MPrime.prototype._tmp = function _tmp() {
        var tmp = new BN2(null);
        tmp.words = new Array(Math.ceil(this.n / 13));
        return tmp;
      };
      MPrime.prototype.ireduce = function ireduce(num) {
        var r = num;
        var rlen;
        do {
          this.split(r, this.tmp);
          r = this.imulK(r);
          r = r.iadd(this.tmp);
          rlen = r.bitLength();
        } while (rlen > this.n);
        var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
        if (cmp === 0) {
          r.words[0] = 0;
          r.length = 1;
        } else if (cmp > 0) {
          r.isub(this.p);
        } else {
          if (r.strip !== void 0) {
            r.strip();
          } else {
            r._strip();
          }
        }
        return r;
      };
      MPrime.prototype.split = function split(input, out) {
        input.iushrn(this.n, 0, out);
      };
      MPrime.prototype.imulK = function imulK(num) {
        return num.imul(this.k);
      };
      function K256() {
        MPrime.call(
          this,
          "k256",
          "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
        );
      }
      inherits(K256, MPrime);
      K256.prototype.split = function split(input, output) {
        var mask = 4194303;
        var outLen = Math.min(input.length, 9);
        for (var i = 0; i < outLen; i++) {
          output.words[i] = input.words[i];
        }
        output.length = outLen;
        if (input.length <= 9) {
          input.words[0] = 0;
          input.length = 1;
          return;
        }
        var prev = input.words[9];
        output.words[output.length++] = prev & mask;
        for (i = 10; i < input.length; i++) {
          var next = input.words[i] | 0;
          input.words[i - 10] = (next & mask) << 4 | prev >>> 22;
          prev = next;
        }
        prev >>>= 22;
        input.words[i - 10] = prev;
        if (prev === 0 && input.length > 10) {
          input.length -= 10;
        } else {
          input.length -= 9;
        }
      };
      K256.prototype.imulK = function imulK(num) {
        num.words[num.length] = 0;
        num.words[num.length + 1] = 0;
        num.length += 2;
        var lo = 0;
        for (var i = 0; i < num.length; i++) {
          var w = num.words[i] | 0;
          lo += w * 977;
          num.words[i] = lo & 67108863;
          lo = w * 64 + (lo / 67108864 | 0);
        }
        if (num.words[num.length - 1] === 0) {
          num.length--;
          if (num.words[num.length - 1] === 0) {
            num.length--;
          }
        }
        return num;
      };
      function P224() {
        MPrime.call(
          this,
          "p224",
          "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
        );
      }
      inherits(P224, MPrime);
      function P192() {
        MPrime.call(
          this,
          "p192",
          "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
        );
      }
      inherits(P192, MPrime);
      function P25519() {
        MPrime.call(
          this,
          "25519",
          "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
        );
      }
      inherits(P25519, MPrime);
      P25519.prototype.imulK = function imulK(num) {
        var carry = 0;
        for (var i = 0; i < num.length; i++) {
          var hi = (num.words[i] | 0) * 19 + carry;
          var lo = hi & 67108863;
          hi >>>= 26;
          num.words[i] = lo;
          carry = hi;
        }
        if (carry !== 0) {
          num.words[num.length++] = carry;
        }
        return num;
      };
      BN2._prime = function prime(name) {
        if (primes[name])
          return primes[name];
        var prime2;
        if (name === "k256") {
          prime2 = new K256();
        } else if (name === "p224") {
          prime2 = new P224();
        } else if (name === "p192") {
          prime2 = new P192();
        } else if (name === "p25519") {
          prime2 = new P25519();
        } else {
          throw new Error("Unknown prime " + name);
        }
        primes[name] = prime2;
        return prime2;
      };
      function Red(m) {
        if (typeof m === "string") {
          var prime = BN2._prime(m);
          this.m = prime.p;
          this.prime = prime;
        } else {
          assert(m.gtn(1), "modulus must be greater than 1");
          this.m = m;
          this.prime = null;
        }
      }
      Red.prototype._verify1 = function _verify1(a) {
        assert(a.negative === 0, "red works only with positives");
        assert(a.red, "red works only with red numbers");
      };
      Red.prototype._verify2 = function _verify2(a, b) {
        assert((a.negative | b.negative) === 0, "red works only with positives");
        assert(
          a.red && a.red === b.red,
          "red works only with red numbers"
        );
      };
      Red.prototype.imod = function imod(a) {
        if (this.prime)
          return this.prime.ireduce(a)._forceRed(this);
        move(a, a.umod(this.m)._forceRed(this));
        return a;
      };
      Red.prototype.neg = function neg(a) {
        if (a.isZero()) {
          return a.clone();
        }
        return this.m.sub(a)._forceRed(this);
      };
      Red.prototype.add = function add3(a, b) {
        this._verify2(a, b);
        var res = a.add(b);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.iadd = function iadd(a, b) {
        this._verify2(a, b);
        var res = a.iadd(b);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res;
      };
      Red.prototype.sub = function sub3(a, b) {
        this._verify2(a, b);
        var res = a.sub(b);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.isub = function isub(a, b) {
        this._verify2(a, b);
        var res = a.isub(b);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res;
      };
      Red.prototype.shl = function shl(a, num) {
        this._verify1(a);
        return this.imod(a.ushln(num));
      };
      Red.prototype.imul = function imul(a, b) {
        this._verify2(a, b);
        return this.imod(a.imul(b));
      };
      Red.prototype.mul = function mul3(a, b) {
        this._verify2(a, b);
        return this.imod(a.mul(b));
      };
      Red.prototype.isqr = function isqr(a) {
        return this.imul(a, a.clone());
      };
      Red.prototype.sqr = function sqr(a) {
        return this.mul(a, a);
      };
      Red.prototype.sqrt = function sqrt2(a) {
        if (a.isZero())
          return a.clone();
        var mod3 = this.m.andln(3);
        assert(mod3 % 2 === 1);
        if (mod3 === 3) {
          var pow2 = this.m.add(new BN2(1)).iushrn(2);
          return this.pow(a, pow2);
        }
        var q = this.m.subn(1);
        var s = 0;
        while (!q.isZero() && q.andln(1) === 0) {
          s++;
          q.iushrn(1);
        }
        assert(!q.isZero());
        var one = new BN2(1).toRed(this);
        var nOne = one.redNeg();
        var lpow = this.m.subn(1).iushrn(1);
        var z = this.m.bitLength();
        z = new BN2(2 * z * z).toRed(this);
        while (this.pow(z, lpow).cmp(nOne) !== 0) {
          z.redIAdd(nOne);
        }
        var c = this.pow(z, q);
        var r = this.pow(a, q.addn(1).iushrn(1));
        var t = this.pow(a, q);
        var m = s;
        while (t.cmp(one) !== 0) {
          var tmp = t;
          for (var i = 0; tmp.cmp(one) !== 0; i++) {
            tmp = tmp.redSqr();
          }
          assert(i < m);
          var b = this.pow(c, new BN2(1).iushln(m - i - 1));
          r = r.redMul(b);
          c = b.redSqr();
          t = t.redMul(c);
          m = i;
        }
        return r;
      };
      Red.prototype.invm = function invm(a) {
        var inv = a._invmp(this.m);
        if (inv.negative !== 0) {
          inv.negative = 0;
          return this.imod(inv).redNeg();
        } else {
          return this.imod(inv);
        }
      };
      Red.prototype.pow = function pow2(a, num) {
        if (num.isZero())
          return new BN2(1).toRed(this);
        if (num.cmpn(1) === 0)
          return a.clone();
        var windowSize = 4;
        var wnd = new Array(1 << windowSize);
        wnd[0] = new BN2(1).toRed(this);
        wnd[1] = a;
        for (var i = 2; i < wnd.length; i++) {
          wnd[i] = this.mul(wnd[i - 1], a);
        }
        var res = wnd[0];
        var current = 0;
        var currentLen = 0;
        var start = num.bitLength() % 26;
        if (start === 0) {
          start = 26;
        }
        for (i = num.length - 1; i >= 0; i--) {
          var word = num.words[i];
          for (var j = start - 1; j >= 0; j--) {
            var bit = word >> j & 1;
            if (res !== wnd[0]) {
              res = this.sqr(res);
            }
            if (bit === 0 && current === 0) {
              currentLen = 0;
              continue;
            }
            current <<= 1;
            current |= bit;
            currentLen++;
            if (currentLen !== windowSize && (i !== 0 || j !== 0))
              continue;
            res = this.mul(res, wnd[current]);
            currentLen = 0;
            current = 0;
          }
          start = 26;
        }
        return res;
      };
      Red.prototype.convertTo = function convertTo(num) {
        var r = num.umod(this.m);
        return r === num ? r.clone() : r;
      };
      Red.prototype.convertFrom = function convertFrom(num) {
        var res = num.clone();
        res.red = null;
        return res;
      };
      BN2.mont = function mont(num) {
        return new Mont(num);
      };
      function Mont(m) {
        Red.call(this, m);
        this.shift = this.m.bitLength();
        if (this.shift % 26 !== 0) {
          this.shift += 26 - this.shift % 26;
        }
        this.r = new BN2(1).iushln(this.shift);
        this.r2 = this.imod(this.r.sqr());
        this.rinv = this.r._invmp(this.m);
        this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
        this.minv = this.minv.umod(this.r);
        this.minv = this.r.sub(this.minv);
      }
      inherits(Mont, Red);
      Mont.prototype.convertTo = function convertTo(num) {
        return this.imod(num.ushln(this.shift));
      };
      Mont.prototype.convertFrom = function convertFrom(num) {
        var r = this.imod(num.mul(this.rinv));
        r.red = null;
        return r;
      };
      Mont.prototype.imul = function imul(a, b) {
        if (a.isZero() || b.isZero()) {
          a.words[0] = 0;
          a.length = 1;
          return a;
        }
        var t = a.imul(b);
        var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u = t.isub(c).iushrn(this.shift);
        var res = u;
        if (u.cmp(this.m) >= 0) {
          res = u.isub(this.m);
        } else if (u.cmpn(0) < 0) {
          res = u.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.mul = function mul3(a, b) {
        if (a.isZero() || b.isZero())
          return new BN2(0)._forceRed(this);
        var t = a.mul(b);
        var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u = t.isub(c).iushrn(this.shift);
        var res = u;
        if (u.cmp(this.m) >= 0) {
          res = u.isub(this.m);
        } else if (u.cmpn(0) < 0) {
          res = u.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.invm = function invm(a) {
        var res = this.imod(a._invmp(this.m).mul(this.r2));
        return res._forceRed(this);
      };
    })(typeof module2 === "undefined" || module2, exports2);
  }
});

// node_modules/big.js/big.js
var require_big = __commonJS({
  "node_modules/big.js/big.js"(exports2, module2) {
    (function(GLOBAL) {
      "use strict";
      var Big, DP = 20, RM = 1, MAX_DP = 1e6, MAX_POWER = 1e6, NE = -7, PE = 21, STRICT = false, NAME = "[big.js] ", INVALID = NAME + "Invalid ", INVALID_DP = INVALID + "decimal places", INVALID_RM = INVALID + "rounding mode", DIV_BY_ZERO = NAME + "Division by zero", P2 = {}, UNDEFINED = void 0, NUMERIC = /^-?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i;
      function _Big_() {
        function Big2(n) {
          var x = this;
          if (!(x instanceof Big2))
            return n === UNDEFINED ? _Big_() : new Big2(n);
          if (n instanceof Big2) {
            x.s = n.s;
            x.e = n.e;
            x.c = n.c.slice();
          } else {
            if (typeof n !== "string") {
              if (Big2.strict === true && typeof n !== "bigint") {
                throw TypeError(INVALID + "value");
              }
              n = n === 0 && 1 / n < 0 ? "-0" : String(n);
            }
            parse(x, n);
          }
          x.constructor = Big2;
        }
        Big2.prototype = P2;
        Big2.DP = DP;
        Big2.RM = RM;
        Big2.NE = NE;
        Big2.PE = PE;
        Big2.strict = STRICT;
        Big2.roundDown = 0;
        Big2.roundHalfUp = 1;
        Big2.roundHalfEven = 2;
        Big2.roundUp = 3;
        return Big2;
      }
      function parse(x, n) {
        var e, i, nl;
        if (!NUMERIC.test(n)) {
          throw Error(INVALID + "number");
        }
        x.s = n.charAt(0) == "-" ? (n = n.slice(1), -1) : 1;
        if ((e = n.indexOf(".")) > -1)
          n = n.replace(".", "");
        if ((i = n.search(/e/i)) > 0) {
          if (e < 0)
            e = i;
          e += +n.slice(i + 1);
          n = n.substring(0, i);
        } else if (e < 0) {
          e = n.length;
        }
        nl = n.length;
        for (i = 0; i < nl && n.charAt(i) == "0"; )
          ++i;
        if (i == nl) {
          x.c = [x.e = 0];
        } else {
          for (; nl > 0 && n.charAt(--nl) == "0"; )
            ;
          x.e = e - i - 1;
          x.c = [];
          for (e = 0; i <= nl; )
            x.c[e++] = +n.charAt(i++);
        }
        return x;
      }
      function round2(x, sd, rm, more) {
        var xc = x.c;
        if (rm === UNDEFINED)
          rm = x.constructor.RM;
        if (rm !== 0 && rm !== 1 && rm !== 2 && rm !== 3) {
          throw Error(INVALID_RM);
        }
        if (sd < 1) {
          more = rm === 3 && (more || !!xc[0]) || sd === 0 && (rm === 1 && xc[0] >= 5 || rm === 2 && (xc[0] > 5 || xc[0] === 5 && (more || xc[1] !== UNDEFINED)));
          xc.length = 1;
          if (more) {
            x.e = x.e - sd + 1;
            xc[0] = 1;
          } else {
            xc[0] = x.e = 0;
          }
        } else if (sd < xc.length) {
          more = rm === 1 && xc[sd] >= 5 || rm === 2 && (xc[sd] > 5 || xc[sd] === 5 && (more || xc[sd + 1] !== UNDEFINED || xc[sd - 1] & 1)) || rm === 3 && (more || !!xc[0]);
          xc.length = sd;
          if (more) {
            for (; ++xc[--sd] > 9; ) {
              xc[sd] = 0;
              if (sd === 0) {
                ++x.e;
                xc.unshift(1);
                break;
              }
            }
          }
          for (sd = xc.length; !xc[--sd]; )
            xc.pop();
        }
        return x;
      }
      function stringify(x, doExponential, isNonzero) {
        var e = x.e, s = x.c.join(""), n = s.length;
        if (doExponential) {
          s = s.charAt(0) + (n > 1 ? "." + s.slice(1) : "") + (e < 0 ? "e" : "e+") + e;
        } else if (e < 0) {
          for (; ++e; )
            s = "0" + s;
          s = "0." + s;
        } else if (e > 0) {
          if (++e > n) {
            for (e -= n; e--; )
              s += "0";
          } else if (e < n) {
            s = s.slice(0, e) + "." + s.slice(e);
          }
        } else if (n > 1) {
          s = s.charAt(0) + "." + s.slice(1);
        }
        return x.s < 0 && isNonzero ? "-" + s : s;
      }
      P2.abs = function() {
        var x = new this.constructor(this);
        x.s = 1;
        return x;
      };
      P2.cmp = function(y) {
        var isneg, x = this, xc = x.c, yc = (y = new x.constructor(y)).c, i = x.s, j = y.s, k = x.e, l = y.e;
        if (!xc[0] || !yc[0])
          return !xc[0] ? !yc[0] ? 0 : -j : i;
        if (i != j)
          return i;
        isneg = i < 0;
        if (k != l)
          return k > l ^ isneg ? 1 : -1;
        j = (k = xc.length) < (l = yc.length) ? k : l;
        for (i = -1; ++i < j; ) {
          if (xc[i] != yc[i])
            return xc[i] > yc[i] ^ isneg ? 1 : -1;
        }
        return k == l ? 0 : k > l ^ isneg ? 1 : -1;
      };
      P2.div = function(y) {
        var x = this, Big2 = x.constructor, a = x.c, b = (y = new Big2(y)).c, k = x.s == y.s ? 1 : -1, dp = Big2.DP;
        if (dp !== ~~dp || dp < 0 || dp > MAX_DP) {
          throw Error(INVALID_DP);
        }
        if (!b[0]) {
          throw Error(DIV_BY_ZERO);
        }
        if (!a[0]) {
          y.s = k;
          y.c = [y.e = 0];
          return y;
        }
        var bl, bt, n, cmp, ri, bz = b.slice(), ai = bl = b.length, al = a.length, r = a.slice(0, bl), rl = r.length, q = y, qc = q.c = [], qi = 0, p = dp + (q.e = x.e - y.e) + 1;
        q.s = k;
        k = p < 0 ? 0 : p;
        bz.unshift(0);
        for (; rl++ < bl; )
          r.push(0);
        do {
          for (n = 0; n < 10; n++) {
            if (bl != (rl = r.length)) {
              cmp = bl > rl ? 1 : -1;
            } else {
              for (ri = -1, cmp = 0; ++ri < bl; ) {
                if (b[ri] != r[ri]) {
                  cmp = b[ri] > r[ri] ? 1 : -1;
                  break;
                }
              }
            }
            if (cmp < 0) {
              for (bt = rl == bl ? b : bz; rl; ) {
                if (r[--rl] < bt[rl]) {
                  ri = rl;
                  for (; ri && !r[--ri]; )
                    r[ri] = 9;
                  --r[ri];
                  r[rl] += 10;
                }
                r[rl] -= bt[rl];
              }
              for (; !r[0]; )
                r.shift();
            } else {
              break;
            }
          }
          qc[qi++] = cmp ? n : ++n;
          if (r[0] && cmp)
            r[rl] = a[ai] || 0;
          else
            r = [a[ai]];
        } while ((ai++ < al || r[0] !== UNDEFINED) && k--);
        if (!qc[0] && qi != 1) {
          qc.shift();
          q.e--;
          p--;
        }
        if (qi > p)
          round2(q, p, Big2.RM, r[0] !== UNDEFINED);
        return q;
      };
      P2.eq = function(y) {
        return this.cmp(y) === 0;
      };
      P2.gt = function(y) {
        return this.cmp(y) > 0;
      };
      P2.gte = function(y) {
        return this.cmp(y) > -1;
      };
      P2.lt = function(y) {
        return this.cmp(y) < 0;
      };
      P2.lte = function(y) {
        return this.cmp(y) < 1;
      };
      P2.minus = P2.sub = function(y) {
        var i, j, t, xlty, x = this, Big2 = x.constructor, a = x.s, b = (y = new Big2(y)).s;
        if (a != b) {
          y.s = -b;
          return x.plus(y);
        }
        var xc = x.c.slice(), xe = x.e, yc = y.c, ye = y.e;
        if (!xc[0] || !yc[0]) {
          if (yc[0]) {
            y.s = -b;
          } else if (xc[0]) {
            y = new Big2(x);
          } else {
            y.s = 1;
          }
          return y;
        }
        if (a = xe - ye) {
          if (xlty = a < 0) {
            a = -a;
            t = xc;
          } else {
            ye = xe;
            t = yc;
          }
          t.reverse();
          for (b = a; b--; )
            t.push(0);
          t.reverse();
        } else {
          j = ((xlty = xc.length < yc.length) ? xc : yc).length;
          for (a = b = 0; b < j; b++) {
            if (xc[b] != yc[b]) {
              xlty = xc[b] < yc[b];
              break;
            }
          }
        }
        if (xlty) {
          t = xc;
          xc = yc;
          yc = t;
          y.s = -y.s;
        }
        if ((b = (j = yc.length) - (i = xc.length)) > 0)
          for (; b--; )
            xc[i++] = 0;
        for (b = i; j > a; ) {
          if (xc[--j] < yc[j]) {
            for (i = j; i && !xc[--i]; )
              xc[i] = 9;
            --xc[i];
            xc[j] += 10;
          }
          xc[j] -= yc[j];
        }
        for (; xc[--b] === 0; )
          xc.pop();
        for (; xc[0] === 0; ) {
          xc.shift();
          --ye;
        }
        if (!xc[0]) {
          y.s = 1;
          xc = [ye = 0];
        }
        y.c = xc;
        y.e = ye;
        return y;
      };
      P2.mod = function(y) {
        var ygtx, x = this, Big2 = x.constructor, a = x.s, b = (y = new Big2(y)).s;
        if (!y.c[0]) {
          throw Error(DIV_BY_ZERO);
        }
        x.s = y.s = 1;
        ygtx = y.cmp(x) == 1;
        x.s = a;
        y.s = b;
        if (ygtx)
          return new Big2(x);
        a = Big2.DP;
        b = Big2.RM;
        Big2.DP = Big2.RM = 0;
        x = x.div(y);
        Big2.DP = a;
        Big2.RM = b;
        return this.minus(x.times(y));
      };
      P2.neg = function() {
        var x = new this.constructor(this);
        x.s = -x.s;
        return x;
      };
      P2.plus = P2.add = function(y) {
        var e, k, t, x = this, Big2 = x.constructor;
        y = new Big2(y);
        if (x.s != y.s) {
          y.s = -y.s;
          return x.minus(y);
        }
        var xe = x.e, xc = x.c, ye = y.e, yc = y.c;
        if (!xc[0] || !yc[0]) {
          if (!yc[0]) {
            if (xc[0]) {
              y = new Big2(x);
            } else {
              y.s = x.s;
            }
          }
          return y;
        }
        xc = xc.slice();
        if (e = xe - ye) {
          if (e > 0) {
            ye = xe;
            t = yc;
          } else {
            e = -e;
            t = xc;
          }
          t.reverse();
          for (; e--; )
            t.push(0);
          t.reverse();
        }
        if (xc.length - yc.length < 0) {
          t = yc;
          yc = xc;
          xc = t;
        }
        e = yc.length;
        for (k = 0; e; xc[e] %= 10)
          k = (xc[--e] = xc[e] + yc[e] + k) / 10 | 0;
        if (k) {
          xc.unshift(k);
          ++ye;
        }
        for (e = xc.length; xc[--e] === 0; )
          xc.pop();
        y.c = xc;
        y.e = ye;
        return y;
      };
      P2.pow = function(n) {
        var x = this, one = new x.constructor("1"), y = one, isneg = n < 0;
        if (n !== ~~n || n < -MAX_POWER || n > MAX_POWER) {
          throw Error(INVALID + "exponent");
        }
        if (isneg)
          n = -n;
        for (; ; ) {
          if (n & 1)
            y = y.times(x);
          n >>= 1;
          if (!n)
            break;
          x = x.times(x);
        }
        return isneg ? one.div(y) : y;
      };
      P2.prec = function(sd, rm) {
        if (sd !== ~~sd || sd < 1 || sd > MAX_DP) {
          throw Error(INVALID + "precision");
        }
        return round2(new this.constructor(this), sd, rm);
      };
      P2.round = function(dp, rm) {
        if (dp === UNDEFINED)
          dp = 0;
        else if (dp !== ~~dp || dp < -MAX_DP || dp > MAX_DP) {
          throw Error(INVALID_DP);
        }
        return round2(new this.constructor(this), dp + this.e + 1, rm);
      };
      P2.sqrt = function() {
        var r, c, t, x = this, Big2 = x.constructor, s = x.s, e = x.e, half = new Big2("0.5");
        if (!x.c[0])
          return new Big2(x);
        if (s < 0) {
          throw Error(NAME + "No square root");
        }
        s = Math.sqrt(+stringify(x, true, true));
        if (s === 0 || s === 1 / 0) {
          c = x.c.join("");
          if (!(c.length + e & 1))
            c += "0";
          s = Math.sqrt(c);
          e = ((e + 1) / 2 | 0) - (e < 0 || e & 1);
          r = new Big2((s == 1 / 0 ? "5e" : (s = s.toExponential()).slice(0, s.indexOf("e") + 1)) + e);
        } else {
          r = new Big2(s + "");
        }
        e = r.e + (Big2.DP += 4);
        do {
          t = r;
          r = half.times(t.plus(x.div(t)));
        } while (t.c.slice(0, e).join("") !== r.c.slice(0, e).join(""));
        return round2(r, (Big2.DP -= 4) + r.e + 1, Big2.RM);
      };
      P2.times = P2.mul = function(y) {
        var c, x = this, Big2 = x.constructor, xc = x.c, yc = (y = new Big2(y)).c, a = xc.length, b = yc.length, i = x.e, j = y.e;
        y.s = x.s == y.s ? 1 : -1;
        if (!xc[0] || !yc[0]) {
          y.c = [y.e = 0];
          return y;
        }
        y.e = i + j;
        if (a < b) {
          c = xc;
          xc = yc;
          yc = c;
          j = a;
          a = b;
          b = j;
        }
        for (c = new Array(j = a + b); j--; )
          c[j] = 0;
        for (i = b; i--; ) {
          b = 0;
          for (j = a + i; j > i; ) {
            b = c[j] + yc[i] * xc[j - i - 1] + b;
            c[j--] = b % 10;
            b = b / 10 | 0;
          }
          c[j] = b;
        }
        if (b)
          ++y.e;
        else
          c.shift();
        for (i = c.length; !c[--i]; )
          c.pop();
        y.c = c;
        return y;
      };
      P2.toExponential = function(dp, rm) {
        var x = this, n = x.c[0];
        if (dp !== UNDEFINED) {
          if (dp !== ~~dp || dp < 0 || dp > MAX_DP) {
            throw Error(INVALID_DP);
          }
          x = round2(new x.constructor(x), ++dp, rm);
          for (; x.c.length < dp; )
            x.c.push(0);
        }
        return stringify(x, true, !!n);
      };
      P2.toFixed = function(dp, rm) {
        var x = this, n = x.c[0];
        if (dp !== UNDEFINED) {
          if (dp !== ~~dp || dp < 0 || dp > MAX_DP) {
            throw Error(INVALID_DP);
          }
          x = round2(new x.constructor(x), dp + x.e + 1, rm);
          for (dp = dp + x.e + 1; x.c.length < dp; )
            x.c.push(0);
        }
        return stringify(x, false, !!n);
      };
      P2.toJSON = P2.toString = function() {
        var x = this, Big2 = x.constructor;
        return stringify(x, x.e <= Big2.NE || x.e >= Big2.PE, !!x.c[0]);
      };
      P2.toNumber = function() {
        var n = +stringify(this, true, true);
        if (this.constructor.strict === true && !this.eq(n.toString())) {
          throw Error(NAME + "Imprecise conversion");
        }
        return n;
      };
      P2.toPrecision = function(sd, rm) {
        var x = this, Big2 = x.constructor, n = x.c[0];
        if (sd !== UNDEFINED) {
          if (sd !== ~~sd || sd < 1 || sd > MAX_DP) {
            throw Error(INVALID + "precision");
          }
          x = round2(new Big2(x), sd, rm);
          for (; x.c.length < sd; )
            x.c.push(0);
        }
        return stringify(x, sd <= x.e || x.e <= Big2.NE || x.e >= Big2.PE, !!n);
      };
      P2.valueOf = function() {
        var x = this, Big2 = x.constructor;
        if (Big2.strict === true) {
          throw Error(NAME + "valueOf disallowed");
        }
        return stringify(x, x.e <= Big2.NE || x.e >= Big2.PE, true);
      };
      Big = _Big_();
      Big["default"] = Big.Big = Big;
      if (typeof define === "function" && define.amd) {
        define(function() {
          return Big;
        });
      } else if (typeof module2 !== "undefined" && module2.exports) {
        module2.exports = Big;
      } else {
        GLOBAL.Big = Big;
      }
    })(exports2);
  }
});

// node_modules/toformat/toFormat.js
var require_toFormat = __commonJS({
  "node_modules/toformat/toFormat.js"(exports2, module2) {
    function toFormat(Ctor) {
      "use strict";
      Ctor.prototype.toFormat = function toFormat2(dp, rm, fmt) {
        if (!this.e && this.e !== 0)
          return this.toString();
        var arr, g1, g2, i, u, nd, intd, intp, fracp, dsep, gsep, gsize, sgsize, fgsep, fgsize, tfmt = this.format || {}, cfmt = this.constructor.format || {};
        if (dp != u) {
          if (typeof dp == "object") {
            fmt = dp;
            dp = u;
          } else if (rm != u) {
            if (typeof rm == "object") {
              fmt = rm;
              rm = u;
            } else if (typeof fmt != "object") {
              fmt = {};
            }
          } else {
            fmt = {};
          }
        } else {
          fmt = {};
        }
        arr = this.toFixed(dp, rm).split(".");
        intp = arr[0];
        fracp = arr[1];
        intd = this.s < 0 ? intp.slice(1) : intp;
        nd = intd.length;
        dsep = fmt.decimalSeparator;
        if (dsep == u) {
          dsep = tfmt.decimalSeparator;
          if (dsep == u) {
            dsep = cfmt.decimalSeparator;
            if (dsep == u)
              dsep = ".";
          }
        }
        gsep = fmt.groupSeparator;
        if (gsep == u) {
          gsep = tfmt.groupSeparator;
          if (gsep == u)
            gsep = cfmt.groupSeparator;
        }
        if (gsep) {
          gsize = fmt.groupSize;
          if (gsize == u) {
            gsize = tfmt.groupSize;
            if (gsize == u) {
              gsize = cfmt.groupSize;
              if (gsize == u)
                gsize = 0;
            }
          }
          sgsize = fmt.secondaryGroupSize;
          if (sgsize == u) {
            sgsize = tfmt.secondaryGroupSize;
            if (sgsize == u) {
              sgsize = cfmt.secondaryGroupSize;
              if (sgsize == u)
                sgsize = 0;
            }
          }
          if (sgsize) {
            g1 = +sgsize;
            g2 = +gsize;
            nd -= g2;
          } else {
            g1 = +gsize;
            g2 = +sgsize;
          }
          if (g1 > 0 && nd > 0) {
            i = nd % g1 || g1;
            intp = intd.substr(0, i);
            for (; i < nd; i += g1)
              intp += gsep + intd.substr(i, g1);
            if (g2 > 0)
              intp += gsep + intd.slice(i);
            if (this.s < 0)
              intp = "-" + intp;
          }
        }
        if (fracp) {
          fgsep = fmt.fractionGroupSeparator;
          if (fgsep == u) {
            fgsep = tfmt.fractionGroupSeparator;
            if (fgsep == u)
              fgsep = cfmt.fractionGroupSeparator;
          }
          if (fgsep) {
            fgsize = fmt.fractionGroupSize;
            if (fgsize == u) {
              fgsize = tfmt.fractionGroupSize;
              if (fgsize == u) {
                fgsize = cfmt.fractionGroupSize;
                if (fgsize == u)
                  fgsize = 0;
              }
            }
            fgsize = +fgsize;
            if (fgsize) {
              fracp = fracp.replace(new RegExp("\\d{" + fgsize + "}\\B", "g"), "$&" + fgsep);
            }
          }
          return intp + dsep + fracp;
        } else {
          return intp;
        }
      };
      Ctor.format = {
        decimalSeparator: ".",
        groupSeparator: ",",
        groupSize: 3,
        secondaryGroupSize: 0,
        fractionGroupSeparator: "",
        fractionGroupSize: 0
      };
      return Ctor;
    }
    if (typeof module2 !== "undefined" && module2.exports)
      module2.exports = toFormat;
  }
});

// node_modules/decimal.js-light/decimal.js
var require_decimal2 = __commonJS({
  "node_modules/decimal.js-light/decimal.js"(exports2, module2) {
    (function(globalScope) {
      "use strict";
      var MAX_DIGITS2 = 1e9, Decimal2 = {
        // These values must be integers within the stated ranges (inclusive).
        // Most of these values can be changed during run-time using `Decimal.config`.
        // The maximum number of significant digits of the result of a calculation or base conversion.
        // E.g. `Decimal.config({ precision: 20 });`
        precision: 20,
        // 1 to MAX_DIGITS
        // The rounding mode used by default by `toInteger`, `toDecimalPlaces`, `toExponential`,
        // `toFixed`, `toPrecision` and `toSignificantDigits`.
        //
        // ROUND_UP         0 Away from zero.
        // ROUND_DOWN       1 Towards zero.
        // ROUND_CEIL       2 Towards +Infinity.
        // ROUND_FLOOR      3 Towards -Infinity.
        // ROUND_HALF_UP    4 Towards nearest neighbour. If equidistant, up.
        // ROUND_HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.
        // ROUND_HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.
        // ROUND_HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.
        // ROUND_HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.
        //
        // E.g.
        // `Decimal.rounding = 4;`
        // `Decimal.rounding = Decimal.ROUND_HALF_UP;`
        rounding: 4,
        // 0 to 8
        // The exponent value at and beneath which `toString` returns exponential notation.
        // JavaScript numbers: -7
        toExpNeg: -7,
        // 0 to -MAX_E
        // The exponent value at and above which `toString` returns exponential notation.
        // JavaScript numbers: 21
        toExpPos: 21,
        // 0 to MAX_E
        // The natural logarithm of 10.
        // 115 digits
        LN10: "2.302585092994045684017991454684364207601101488628772976033327900967572609677352480235997205089598298341967784042286"
      }, external2 = true, decimalError2 = "[DecimalError] ", invalidArgument2 = decimalError2 + "Invalid argument: ", exponentOutOfRange = decimalError2 + "Exponent out of range: ", mathfloor3 = Math.floor, mathpow2 = Math.pow, isDecimal3 = /^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i, ONE2, BASE3 = 1e7, LOG_BASE3 = 7, MAX_SAFE_INTEGER3 = 9007199254740991, MAX_E = mathfloor3(MAX_SAFE_INTEGER3 / LOG_BASE3), P2 = {};
      P2.absoluteValue = P2.abs = function() {
        var x = new this.constructor(this);
        if (x.s)
          x.s = 1;
        return x;
      };
      P2.comparedTo = P2.cmp = function(y) {
        var i, j, xdL, ydL, x = this;
        y = new x.constructor(y);
        if (x.s !== y.s)
          return x.s || -y.s;
        if (x.e !== y.e)
          return x.e > y.e ^ x.s < 0 ? 1 : -1;
        xdL = x.d.length;
        ydL = y.d.length;
        for (i = 0, j = xdL < ydL ? xdL : ydL; i < j; ++i) {
          if (x.d[i] !== y.d[i])
            return x.d[i] > y.d[i] ^ x.s < 0 ? 1 : -1;
        }
        return xdL === ydL ? 0 : xdL > ydL ^ x.s < 0 ? 1 : -1;
      };
      P2.decimalPlaces = P2.dp = function() {
        var x = this, w = x.d.length - 1, dp = (w - x.e) * LOG_BASE3;
        w = x.d[w];
        if (w)
          for (; w % 10 == 0; w /= 10)
            dp--;
        return dp < 0 ? 0 : dp;
      };
      P2.dividedBy = P2.div = function(y) {
        return divide2(this, new this.constructor(y));
      };
      P2.dividedToIntegerBy = P2.idiv = function(y) {
        var x = this, Ctor = x.constructor;
        return round2(divide2(x, new Ctor(y), 0, 1), Ctor.precision);
      };
      P2.equals = P2.eq = function(y) {
        return !this.cmp(y);
      };
      P2.exponent = function() {
        return getBase10Exponent2(this);
      };
      P2.greaterThan = P2.gt = function(y) {
        return this.cmp(y) > 0;
      };
      P2.greaterThanOrEqualTo = P2.gte = function(y) {
        return this.cmp(y) >= 0;
      };
      P2.isInteger = P2.isint = function() {
        return this.e > this.d.length - 2;
      };
      P2.isNegative = P2.isneg = function() {
        return this.s < 0;
      };
      P2.isPositive = P2.ispos = function() {
        return this.s > 0;
      };
      P2.isZero = function() {
        return this.s === 0;
      };
      P2.lessThan = P2.lt = function(y) {
        return this.cmp(y) < 0;
      };
      P2.lessThanOrEqualTo = P2.lte = function(y) {
        return this.cmp(y) < 1;
      };
      P2.logarithm = P2.log = function(base) {
        var r, x = this, Ctor = x.constructor, pr = Ctor.precision, wpr = pr + 5;
        if (base === void 0) {
          base = new Ctor(10);
        } else {
          base = new Ctor(base);
          if (base.s < 1 || base.eq(ONE2))
            throw Error(decimalError2 + "NaN");
        }
        if (x.s < 1)
          throw Error(decimalError2 + (x.s ? "NaN" : "-Infinity"));
        if (x.eq(ONE2))
          return new Ctor(0);
        external2 = false;
        r = divide2(ln2(x, wpr), ln2(base, wpr), wpr);
        external2 = true;
        return round2(r, pr);
      };
      P2.minus = P2.sub = function(y) {
        var x = this;
        y = new x.constructor(y);
        return x.s == y.s ? subtract(x, y) : add3(x, (y.s = -y.s, y));
      };
      P2.modulo = P2.mod = function(y) {
        var q, x = this, Ctor = x.constructor, pr = Ctor.precision;
        y = new Ctor(y);
        if (!y.s)
          throw Error(decimalError2 + "NaN");
        if (!x.s)
          return round2(new Ctor(x), pr);
        external2 = false;
        q = divide2(x, y, 0, 1).times(y);
        external2 = true;
        return x.minus(q);
      };
      P2.naturalExponential = P2.exp = function() {
        return exp2(this);
      };
      P2.naturalLogarithm = P2.ln = function() {
        return ln2(this);
      };
      P2.negated = P2.neg = function() {
        var x = new this.constructor(this);
        x.s = -x.s || 0;
        return x;
      };
      P2.plus = P2.add = function(y) {
        var x = this;
        y = new x.constructor(y);
        return x.s == y.s ? add3(x, y) : subtract(x, (y.s = -y.s, y));
      };
      P2.precision = P2.sd = function(z) {
        var e, sd, w, x = this;
        if (z !== void 0 && z !== !!z && z !== 1 && z !== 0)
          throw Error(invalidArgument2 + z);
        e = getBase10Exponent2(x) + 1;
        w = x.d.length - 1;
        sd = w * LOG_BASE3 + 1;
        w = x.d[w];
        if (w) {
          for (; w % 10 == 0; w /= 10)
            sd--;
          for (w = x.d[0]; w >= 10; w /= 10)
            sd++;
        }
        return z && e > sd ? e : sd;
      };
      P2.squareRoot = P2.sqrt = function() {
        var e, n, pr, r, s, t, wpr, x = this, Ctor = x.constructor;
        if (x.s < 1) {
          if (!x.s)
            return new Ctor(0);
          throw Error(decimalError2 + "NaN");
        }
        e = getBase10Exponent2(x);
        external2 = false;
        s = Math.sqrt(+x);
        if (s == 0 || s == 1 / 0) {
          n = digitsToString2(x.d);
          if ((n.length + e) % 2 == 0)
            n += "0";
          s = Math.sqrt(n);
          e = mathfloor3((e + 1) / 2) - (e < 0 || e % 2);
          if (s == 1 / 0) {
            n = "5e" + e;
          } else {
            n = s.toExponential();
            n = n.slice(0, n.indexOf("e") + 1) + e;
          }
          r = new Ctor(n);
        } else {
          r = new Ctor(s.toString());
        }
        pr = Ctor.precision;
        s = wpr = pr + 3;
        for (; ; ) {
          t = r;
          r = t.plus(divide2(x, t, wpr + 2)).times(0.5);
          if (digitsToString2(t.d).slice(0, wpr) === (n = digitsToString2(r.d)).slice(0, wpr)) {
            n = n.slice(wpr - 3, wpr + 1);
            if (s == wpr && n == "4999") {
              round2(t, pr + 1, 0);
              if (t.times(t).eq(x)) {
                r = t;
                break;
              }
            } else if (n != "9999") {
              break;
            }
            wpr += 4;
          }
        }
        external2 = true;
        return round2(r, pr);
      };
      P2.times = P2.mul = function(y) {
        var carry, e, i, k, r, rL, t, xdL, ydL, x = this, Ctor = x.constructor, xd = x.d, yd = (y = new Ctor(y)).d;
        if (!x.s || !y.s)
          return new Ctor(0);
        y.s *= x.s;
        e = x.e + y.e;
        xdL = xd.length;
        ydL = yd.length;
        if (xdL < ydL) {
          r = xd;
          xd = yd;
          yd = r;
          rL = xdL;
          xdL = ydL;
          ydL = rL;
        }
        r = [];
        rL = xdL + ydL;
        for (i = rL; i--; )
          r.push(0);
        for (i = ydL; --i >= 0; ) {
          carry = 0;
          for (k = xdL + i; k > i; ) {
            t = r[k] + yd[i] * xd[k - i - 1] + carry;
            r[k--] = t % BASE3 | 0;
            carry = t / BASE3 | 0;
          }
          r[k] = (r[k] + carry) % BASE3 | 0;
        }
        for (; !r[--rL]; )
          r.pop();
        if (carry)
          ++e;
        else
          r.shift();
        y.d = r;
        y.e = e;
        return external2 ? round2(y, Ctor.precision) : y;
      };
      P2.toDecimalPlaces = P2.todp = function(dp, rm) {
        var x = this, Ctor = x.constructor;
        x = new Ctor(x);
        if (dp === void 0)
          return x;
        checkInt322(dp, 0, MAX_DIGITS2);
        if (rm === void 0)
          rm = Ctor.rounding;
        else
          checkInt322(rm, 0, 8);
        return round2(x, dp + getBase10Exponent2(x) + 1, rm);
      };
      P2.toExponential = function(dp, rm) {
        var str2, x = this, Ctor = x.constructor;
        if (dp === void 0) {
          str2 = toString(x, true);
        } else {
          checkInt322(dp, 0, MAX_DIGITS2);
          if (rm === void 0)
            rm = Ctor.rounding;
          else
            checkInt322(rm, 0, 8);
          x = round2(new Ctor(x), dp + 1, rm);
          str2 = toString(x, true, dp + 1);
        }
        return str2;
      };
      P2.toFixed = function(dp, rm) {
        var str2, y, x = this, Ctor = x.constructor;
        if (dp === void 0)
          return toString(x);
        checkInt322(dp, 0, MAX_DIGITS2);
        if (rm === void 0)
          rm = Ctor.rounding;
        else
          checkInt322(rm, 0, 8);
        y = round2(new Ctor(x), dp + getBase10Exponent2(x) + 1, rm);
        str2 = toString(y.abs(), false, dp + getBase10Exponent2(y) + 1);
        return x.isneg() && !x.isZero() ? "-" + str2 : str2;
      };
      P2.toInteger = P2.toint = function() {
        var x = this, Ctor = x.constructor;
        return round2(new Ctor(x), getBase10Exponent2(x) + 1, Ctor.rounding);
      };
      P2.toNumber = function() {
        return +this;
      };
      P2.toPower = P2.pow = function(y) {
        var e, k, pr, r, sign2, yIsInt, x = this, Ctor = x.constructor, guard = 12, yn = +(y = new Ctor(y));
        if (!y.s)
          return new Ctor(ONE2);
        x = new Ctor(x);
        if (!x.s) {
          if (y.s < 1)
            throw Error(decimalError2 + "Infinity");
          return x;
        }
        if (x.eq(ONE2))
          return x;
        pr = Ctor.precision;
        if (y.eq(ONE2))
          return round2(x, pr);
        e = y.e;
        k = y.d.length - 1;
        yIsInt = e >= k;
        sign2 = x.s;
        if (!yIsInt) {
          if (sign2 < 0)
            throw Error(decimalError2 + "NaN");
        } else if ((k = yn < 0 ? -yn : yn) <= MAX_SAFE_INTEGER3) {
          r = new Ctor(ONE2);
          e = Math.ceil(pr / LOG_BASE3 + 4);
          external2 = false;
          for (; ; ) {
            if (k % 2) {
              r = r.times(x);
              truncate2(r.d, e);
            }
            k = mathfloor3(k / 2);
            if (k === 0)
              break;
            x = x.times(x);
            truncate2(x.d, e);
          }
          external2 = true;
          return y.s < 0 ? new Ctor(ONE2).div(r) : round2(r, pr);
        }
        sign2 = sign2 < 0 && y.d[Math.max(e, k)] & 1 ? -1 : 1;
        x.s = 1;
        external2 = false;
        r = y.times(ln2(x, pr + guard));
        external2 = true;
        r = exp2(r);
        r.s = sign2;
        return r;
      };
      P2.toPrecision = function(sd, rm) {
        var e, str2, x = this, Ctor = x.constructor;
        if (sd === void 0) {
          e = getBase10Exponent2(x);
          str2 = toString(x, e <= Ctor.toExpNeg || e >= Ctor.toExpPos);
        } else {
          checkInt322(sd, 1, MAX_DIGITS2);
          if (rm === void 0)
            rm = Ctor.rounding;
          else
            checkInt322(rm, 0, 8);
          x = round2(new Ctor(x), sd, rm);
          e = getBase10Exponent2(x);
          str2 = toString(x, sd <= e || e <= Ctor.toExpNeg, sd);
        }
        return str2;
      };
      P2.toSignificantDigits = P2.tosd = function(sd, rm) {
        var x = this, Ctor = x.constructor;
        if (sd === void 0) {
          sd = Ctor.precision;
          rm = Ctor.rounding;
        } else {
          checkInt322(sd, 1, MAX_DIGITS2);
          if (rm === void 0)
            rm = Ctor.rounding;
          else
            checkInt322(rm, 0, 8);
        }
        return round2(new Ctor(x), sd, rm);
      };
      P2.toString = P2.valueOf = P2.val = P2.toJSON = function() {
        var x = this, e = getBase10Exponent2(x), Ctor = x.constructor;
        return toString(x, e <= Ctor.toExpNeg || e >= Ctor.toExpPos);
      };
      function add3(x, y) {
        var carry, d, e, i, k, len, xd, yd, Ctor = x.constructor, pr = Ctor.precision;
        if (!x.s || !y.s) {
          if (!y.s)
            y = new Ctor(x);
          return external2 ? round2(y, pr) : y;
        }
        xd = x.d;
        yd = y.d;
        k = x.e;
        e = y.e;
        xd = xd.slice();
        i = k - e;
        if (i) {
          if (i < 0) {
            d = xd;
            i = -i;
            len = yd.length;
          } else {
            d = yd;
            e = k;
            len = xd.length;
          }
          k = Math.ceil(pr / LOG_BASE3);
          len = k > len ? k + 1 : len + 1;
          if (i > len) {
            i = len;
            d.length = 1;
          }
          d.reverse();
          for (; i--; )
            d.push(0);
          d.reverse();
        }
        len = xd.length;
        i = yd.length;
        if (len - i < 0) {
          i = len;
          d = yd;
          yd = xd;
          xd = d;
        }
        for (carry = 0; i; ) {
          carry = (xd[--i] = xd[i] + yd[i] + carry) / BASE3 | 0;
          xd[i] %= BASE3;
        }
        if (carry) {
          xd.unshift(carry);
          ++e;
        }
        for (len = xd.length; xd[--len] == 0; )
          xd.pop();
        y.d = xd;
        y.e = e;
        return external2 ? round2(y, pr) : y;
      }
      function checkInt322(i, min2, max2) {
        if (i !== ~~i || i < min2 || i > max2) {
          throw Error(invalidArgument2 + i);
        }
      }
      function digitsToString2(d) {
        var i, k, ws, indexOfLastWord = d.length - 1, str2 = "", w = d[0];
        if (indexOfLastWord > 0) {
          str2 += w;
          for (i = 1; i < indexOfLastWord; i++) {
            ws = d[i] + "";
            k = LOG_BASE3 - ws.length;
            if (k)
              str2 += getZeroString2(k);
            str2 += ws;
          }
          w = d[i];
          ws = w + "";
          k = LOG_BASE3 - ws.length;
          if (k)
            str2 += getZeroString2(k);
        } else if (w === 0) {
          return "0";
        }
        for (; w % 10 === 0; )
          w /= 10;
        return str2 + w;
      }
      var divide2 = /* @__PURE__ */ function() {
        function multiplyInteger(x, k) {
          var temp, carry = 0, i = x.length;
          for (x = x.slice(); i--; ) {
            temp = x[i] * k + carry;
            x[i] = temp % BASE3 | 0;
            carry = temp / BASE3 | 0;
          }
          if (carry)
            x.unshift(carry);
          return x;
        }
        function compare2(a, b, aL, bL) {
          var i, r;
          if (aL != bL) {
            r = aL > bL ? 1 : -1;
          } else {
            for (i = r = 0; i < aL; i++) {
              if (a[i] != b[i]) {
                r = a[i] > b[i] ? 1 : -1;
                break;
              }
            }
          }
          return r;
        }
        function subtract2(a, b, aL) {
          var i = 0;
          for (; aL--; ) {
            a[aL] -= i;
            i = a[aL] < b[aL] ? 1 : 0;
            a[aL] = i * BASE3 + a[aL] - b[aL];
          }
          for (; !a[0] && a.length > 1; )
            a.shift();
        }
        return function(x, y, pr, dp) {
          var cmp, e, i, k, prod, prodL, q, qd, rem, remL, rem0, sd, t, xi, xL, yd0, yL, yz, Ctor = x.constructor, sign2 = x.s == y.s ? 1 : -1, xd = x.d, yd = y.d;
          if (!x.s)
            return new Ctor(x);
          if (!y.s)
            throw Error(decimalError2 + "Division by zero");
          e = x.e - y.e;
          yL = yd.length;
          xL = xd.length;
          q = new Ctor(sign2);
          qd = q.d = [];
          for (i = 0; yd[i] == (xd[i] || 0); )
            ++i;
          if (yd[i] > (xd[i] || 0))
            --e;
          if (pr == null) {
            sd = pr = Ctor.precision;
          } else if (dp) {
            sd = pr + (getBase10Exponent2(x) - getBase10Exponent2(y)) + 1;
          } else {
            sd = pr;
          }
          if (sd < 0)
            return new Ctor(0);
          sd = sd / LOG_BASE3 + 2 | 0;
          i = 0;
          if (yL == 1) {
            k = 0;
            yd = yd[0];
            sd++;
            for (; (i < xL || k) && sd--; i++) {
              t = k * BASE3 + (xd[i] || 0);
              qd[i] = t / yd | 0;
              k = t % yd | 0;
            }
          } else {
            k = BASE3 / (yd[0] + 1) | 0;
            if (k > 1) {
              yd = multiplyInteger(yd, k);
              xd = multiplyInteger(xd, k);
              yL = yd.length;
              xL = xd.length;
            }
            xi = yL;
            rem = xd.slice(0, yL);
            remL = rem.length;
            for (; remL < yL; )
              rem[remL++] = 0;
            yz = yd.slice();
            yz.unshift(0);
            yd0 = yd[0];
            if (yd[1] >= BASE3 / 2)
              ++yd0;
            do {
              k = 0;
              cmp = compare2(yd, rem, yL, remL);
              if (cmp < 0) {
                rem0 = rem[0];
                if (yL != remL)
                  rem0 = rem0 * BASE3 + (rem[1] || 0);
                k = rem0 / yd0 | 0;
                if (k > 1) {
                  if (k >= BASE3)
                    k = BASE3 - 1;
                  prod = multiplyInteger(yd, k);
                  prodL = prod.length;
                  remL = rem.length;
                  cmp = compare2(prod, rem, prodL, remL);
                  if (cmp == 1) {
                    k--;
                    subtract2(prod, yL < prodL ? yz : yd, prodL);
                  }
                } else {
                  if (k == 0)
                    cmp = k = 1;
                  prod = yd.slice();
                }
                prodL = prod.length;
                if (prodL < remL)
                  prod.unshift(0);
                subtract2(rem, prod, remL);
                if (cmp == -1) {
                  remL = rem.length;
                  cmp = compare2(yd, rem, yL, remL);
                  if (cmp < 1) {
                    k++;
                    subtract2(rem, yL < remL ? yz : yd, remL);
                  }
                }
                remL = rem.length;
              } else if (cmp === 0) {
                k++;
                rem = [0];
              }
              qd[i++] = k;
              if (cmp && rem[0]) {
                rem[remL++] = xd[xi] || 0;
              } else {
                rem = [xd[xi]];
                remL = 1;
              }
            } while ((xi++ < xL || rem[0] !== void 0) && sd--);
          }
          if (!qd[0])
            qd.shift();
          q.e = e;
          return round2(q, dp ? pr + getBase10Exponent2(q) + 1 : pr);
        };
      }();
      function exp2(x, sd) {
        var denominator, guard, pow2, sum2, t, wpr, i = 0, k = 0, Ctor = x.constructor, pr = Ctor.precision;
        if (getBase10Exponent2(x) > 16)
          throw Error(exponentOutOfRange + getBase10Exponent2(x));
        if (!x.s)
          return new Ctor(ONE2);
        if (sd == null) {
          external2 = false;
          wpr = pr;
        } else {
          wpr = sd;
        }
        t = new Ctor(0.03125);
        while (x.abs().gte(0.1)) {
          x = x.times(t);
          k += 5;
        }
        guard = Math.log(mathpow2(2, k)) / Math.LN10 * 2 + 5 | 0;
        wpr += guard;
        denominator = pow2 = sum2 = new Ctor(ONE2);
        Ctor.precision = wpr;
        for (; ; ) {
          pow2 = round2(pow2.times(x), wpr);
          denominator = denominator.times(++i);
          t = sum2.plus(divide2(pow2, denominator, wpr));
          if (digitsToString2(t.d).slice(0, wpr) === digitsToString2(sum2.d).slice(0, wpr)) {
            while (k--)
              sum2 = round2(sum2.times(sum2), wpr);
            Ctor.precision = pr;
            return sd == null ? (external2 = true, round2(sum2, pr)) : sum2;
          }
          sum2 = t;
        }
      }
      function getBase10Exponent2(x) {
        var e = x.e * LOG_BASE3, w = x.d[0];
        for (; w >= 10; w /= 10)
          e++;
        return e;
      }
      function getLn102(Ctor, sd, pr) {
        if (sd > Ctor.LN10.sd()) {
          external2 = true;
          if (pr)
            Ctor.precision = pr;
          throw Error(decimalError2 + "LN10 precision limit exceeded");
        }
        return round2(new Ctor(Ctor.LN10), sd);
      }
      function getZeroString2(k) {
        var zs = "";
        for (; k--; )
          zs += "0";
        return zs;
      }
      function ln2(y, sd) {
        var c, c0, denominator, e, numerator, sum2, t, wpr, x2, n = 1, guard = 10, x = y, xd = x.d, Ctor = x.constructor, pr = Ctor.precision;
        if (x.s < 1)
          throw Error(decimalError2 + (x.s ? "NaN" : "-Infinity"));
        if (x.eq(ONE2))
          return new Ctor(0);
        if (sd == null) {
          external2 = false;
          wpr = pr;
        } else {
          wpr = sd;
        }
        if (x.eq(10)) {
          if (sd == null)
            external2 = true;
          return getLn102(Ctor, wpr);
        }
        wpr += guard;
        Ctor.precision = wpr;
        c = digitsToString2(xd);
        c0 = c.charAt(0);
        e = getBase10Exponent2(x);
        if (Math.abs(e) < 15e14) {
          while (c0 < 7 && c0 != 1 || c0 == 1 && c.charAt(1) > 3) {
            x = x.times(y);
            c = digitsToString2(x.d);
            c0 = c.charAt(0);
            n++;
          }
          e = getBase10Exponent2(x);
          if (c0 > 1) {
            x = new Ctor("0." + c);
            e++;
          } else {
            x = new Ctor(c0 + "." + c.slice(1));
          }
        } else {
          t = getLn102(Ctor, wpr + 2, pr).times(e + "");
          x = ln2(new Ctor(c0 + "." + c.slice(1)), wpr - guard).plus(t);
          Ctor.precision = pr;
          return sd == null ? (external2 = true, round2(x, pr)) : x;
        }
        sum2 = numerator = x = divide2(x.minus(ONE2), x.plus(ONE2), wpr);
        x2 = round2(x.times(x), wpr);
        denominator = 3;
        for (; ; ) {
          numerator = round2(numerator.times(x2), wpr);
          t = sum2.plus(divide2(numerator, new Ctor(denominator), wpr));
          if (digitsToString2(t.d).slice(0, wpr) === digitsToString2(sum2.d).slice(0, wpr)) {
            sum2 = sum2.times(2);
            if (e !== 0)
              sum2 = sum2.plus(getLn102(Ctor, wpr + 2, pr).times(e + ""));
            sum2 = divide2(sum2, new Ctor(n), wpr);
            Ctor.precision = pr;
            return sd == null ? (external2 = true, round2(sum2, pr)) : sum2;
          }
          sum2 = t;
          denominator += 2;
        }
      }
      function parseDecimal2(x, str2) {
        var e, i, len;
        if ((e = str2.indexOf(".")) > -1)
          str2 = str2.replace(".", "");
        if ((i = str2.search(/e/i)) > 0) {
          if (e < 0)
            e = i;
          e += +str2.slice(i + 1);
          str2 = str2.substring(0, i);
        } else if (e < 0) {
          e = str2.length;
        }
        for (i = 0; str2.charCodeAt(i) === 48; )
          ++i;
        for (len = str2.length; str2.charCodeAt(len - 1) === 48; )
          --len;
        str2 = str2.slice(i, len);
        if (str2) {
          len -= i;
          e = e - i - 1;
          x.e = mathfloor3(e / LOG_BASE3);
          x.d = [];
          i = (e + 1) % LOG_BASE3;
          if (e < 0)
            i += LOG_BASE3;
          if (i < len) {
            if (i)
              x.d.push(+str2.slice(0, i));
            for (len -= LOG_BASE3; i < len; )
              x.d.push(+str2.slice(i, i += LOG_BASE3));
            str2 = str2.slice(i);
            i = LOG_BASE3 - str2.length;
          } else {
            i -= len;
          }
          for (; i--; )
            str2 += "0";
          x.d.push(+str2);
          if (external2 && (x.e > MAX_E || x.e < -MAX_E))
            throw Error(exponentOutOfRange + e);
        } else {
          x.s = 0;
          x.e = 0;
          x.d = [0];
        }
        return x;
      }
      function round2(x, sd, rm) {
        var i, j, k, n, rd, doRound, w, xdi, xd = x.d;
        for (n = 1, k = xd[0]; k >= 10; k /= 10)
          n++;
        i = sd - n;
        if (i < 0) {
          i += LOG_BASE3;
          j = sd;
          w = xd[xdi = 0];
        } else {
          xdi = Math.ceil((i + 1) / LOG_BASE3);
          k = xd.length;
          if (xdi >= k)
            return x;
          w = k = xd[xdi];
          for (n = 1; k >= 10; k /= 10)
            n++;
          i %= LOG_BASE3;
          j = i - LOG_BASE3 + n;
        }
        if (rm !== void 0) {
          k = mathpow2(10, n - j - 1);
          rd = w / k % 10 | 0;
          doRound = sd < 0 || xd[xdi + 1] !== void 0 || w % k;
          doRound = rm < 4 ? (rd || doRound) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : rd > 5 || rd == 5 && (rm == 4 || doRound || rm == 6 && // Check whether the digit to the left of the rounding digit is odd.
          (i > 0 ? j > 0 ? w / mathpow2(10, n - j) : 0 : xd[xdi - 1]) % 10 & 1 || rm == (x.s < 0 ? 8 : 7));
        }
        if (sd < 1 || !xd[0]) {
          if (doRound) {
            k = getBase10Exponent2(x);
            xd.length = 1;
            sd = sd - k - 1;
            xd[0] = mathpow2(10, (LOG_BASE3 - sd % LOG_BASE3) % LOG_BASE3);
            x.e = mathfloor3(-sd / LOG_BASE3) || 0;
          } else {
            xd.length = 1;
            xd[0] = x.e = x.s = 0;
          }
          return x;
        }
        if (i == 0) {
          xd.length = xdi;
          k = 1;
          xdi--;
        } else {
          xd.length = xdi + 1;
          k = mathpow2(10, LOG_BASE3 - i);
          xd[xdi] = j > 0 ? (w / mathpow2(10, n - j) % mathpow2(10, j) | 0) * k : 0;
        }
        if (doRound) {
          for (; ; ) {
            if (xdi == 0) {
              if ((xd[0] += k) == BASE3) {
                xd[0] = 1;
                ++x.e;
              }
              break;
            } else {
              xd[xdi] += k;
              if (xd[xdi] != BASE3)
                break;
              xd[xdi--] = 0;
              k = 1;
            }
          }
        }
        for (i = xd.length; xd[--i] === 0; )
          xd.pop();
        if (external2 && (x.e > MAX_E || x.e < -MAX_E)) {
          throw Error(exponentOutOfRange + getBase10Exponent2(x));
        }
        return x;
      }
      function subtract(x, y) {
        var d, e, i, j, k, len, xd, xe, xLTy, yd, Ctor = x.constructor, pr = Ctor.precision;
        if (!x.s || !y.s) {
          if (y.s)
            y.s = -y.s;
          else
            y = new Ctor(x);
          return external2 ? round2(y, pr) : y;
        }
        xd = x.d;
        yd = y.d;
        e = y.e;
        xe = x.e;
        xd = xd.slice();
        k = xe - e;
        if (k) {
          xLTy = k < 0;
          if (xLTy) {
            d = xd;
            k = -k;
            len = yd.length;
          } else {
            d = yd;
            e = xe;
            len = xd.length;
          }
          i = Math.max(Math.ceil(pr / LOG_BASE3), len) + 2;
          if (k > i) {
            k = i;
            d.length = 1;
          }
          d.reverse();
          for (i = k; i--; )
            d.push(0);
          d.reverse();
        } else {
          i = xd.length;
          len = yd.length;
          xLTy = i < len;
          if (xLTy)
            len = i;
          for (i = 0; i < len; i++) {
            if (xd[i] != yd[i]) {
              xLTy = xd[i] < yd[i];
              break;
            }
          }
          k = 0;
        }
        if (xLTy) {
          d = xd;
          xd = yd;
          yd = d;
          y.s = -y.s;
        }
        len = xd.length;
        for (i = yd.length - len; i > 0; --i)
          xd[len++] = 0;
        for (i = yd.length; i > k; ) {
          if (xd[--i] < yd[i]) {
            for (j = i; j && xd[--j] === 0; )
              xd[j] = BASE3 - 1;
            --xd[j];
            xd[i] += BASE3;
          }
          xd[i] -= yd[i];
        }
        for (; xd[--len] === 0; )
          xd.pop();
        for (; xd[0] === 0; xd.shift())
          --e;
        if (!xd[0])
          return new Ctor(0);
        y.d = xd;
        y.e = e;
        return external2 ? round2(y, pr) : y;
      }
      function toString(x, isExp, sd) {
        var k, e = getBase10Exponent2(x), str2 = digitsToString2(x.d), len = str2.length;
        if (isExp) {
          if (sd && (k = sd - len) > 0) {
            str2 = str2.charAt(0) + "." + str2.slice(1) + getZeroString2(k);
          } else if (len > 1) {
            str2 = str2.charAt(0) + "." + str2.slice(1);
          }
          str2 = str2 + (e < 0 ? "e" : "e+") + e;
        } else if (e < 0) {
          str2 = "0." + getZeroString2(-e - 1) + str2;
          if (sd && (k = sd - len) > 0)
            str2 += getZeroString2(k);
        } else if (e >= len) {
          str2 += getZeroString2(e + 1 - len);
          if (sd && (k = sd - e - 1) > 0)
            str2 = str2 + "." + getZeroString2(k);
        } else {
          if ((k = e + 1) < len)
            str2 = str2.slice(0, k) + "." + str2.slice(k);
          if (sd && (k = sd - len) > 0) {
            if (e + 1 === len)
              str2 += ".";
            str2 += getZeroString2(k);
          }
        }
        return x.s < 0 ? "-" + str2 : str2;
      }
      function truncate2(arr, len) {
        if (arr.length > len) {
          arr.length = len;
          return true;
        }
      }
      function clone3(obj) {
        var i, p, ps;
        function Decimal3(value) {
          var x = this;
          if (!(x instanceof Decimal3))
            return new Decimal3(value);
          x.constructor = Decimal3;
          if (value instanceof Decimal3) {
            x.s = value.s;
            x.e = value.e;
            x.d = (value = value.d) ? value.slice() : value;
            return;
          }
          if (typeof value === "number") {
            if (value * 0 !== 0) {
              throw Error(invalidArgument2 + value);
            }
            if (value > 0) {
              x.s = 1;
            } else if (value < 0) {
              value = -value;
              x.s = -1;
            } else {
              x.s = 0;
              x.e = 0;
              x.d = [0];
              return;
            }
            if (value === ~~value && value < 1e7) {
              x.e = 0;
              x.d = [value];
              return;
            }
            return parseDecimal2(x, value.toString());
          } else if (typeof value !== "string") {
            throw Error(invalidArgument2 + value);
          }
          if (value.charCodeAt(0) === 45) {
            value = value.slice(1);
            x.s = -1;
          } else {
            x.s = 1;
          }
          if (isDecimal3.test(value))
            parseDecimal2(x, value);
          else
            throw Error(invalidArgument2 + value);
        }
        Decimal3.prototype = P2;
        Decimal3.ROUND_UP = 0;
        Decimal3.ROUND_DOWN = 1;
        Decimal3.ROUND_CEIL = 2;
        Decimal3.ROUND_FLOOR = 3;
        Decimal3.ROUND_HALF_UP = 4;
        Decimal3.ROUND_HALF_DOWN = 5;
        Decimal3.ROUND_HALF_EVEN = 6;
        Decimal3.ROUND_HALF_CEIL = 7;
        Decimal3.ROUND_HALF_FLOOR = 8;
        Decimal3.clone = clone3;
        Decimal3.config = Decimal3.set = config2;
        if (obj === void 0)
          obj = {};
        if (obj) {
          ps = ["precision", "rounding", "toExpNeg", "toExpPos", "LN10"];
          for (i = 0; i < ps.length; )
            if (!obj.hasOwnProperty(p = ps[i++]))
              obj[p] = this[p];
        }
        Decimal3.config(obj);
        return Decimal3;
      }
      function config2(obj) {
        if (!obj || typeof obj !== "object") {
          throw Error(decimalError2 + "Object expected");
        }
        var i, p, v, ps = [
          "precision",
          1,
          MAX_DIGITS2,
          "rounding",
          0,
          8,
          "toExpNeg",
          -1 / 0,
          0,
          "toExpPos",
          0,
          1 / 0
        ];
        for (i = 0; i < ps.length; i += 3) {
          if ((v = obj[p = ps[i]]) !== void 0) {
            if (mathfloor3(v) === v && v >= ps[i + 1] && v <= ps[i + 2])
              this[p] = v;
            else
              throw Error(invalidArgument2 + p + ": " + v);
          }
        }
        if ((v = obj[p = "LN10"]) !== void 0) {
          if (v == Math.LN10)
            this[p] = new this(v);
          else
            throw Error(invalidArgument2 + p + ": " + v);
        }
        return this;
      }
      Decimal2 = clone3(Decimal2);
      Decimal2["default"] = Decimal2.Decimal = Decimal2;
      ONE2 = new Decimal2(1);
      if (typeof define == "function" && define.amd) {
        define(function() {
          return Decimal2;
        });
      } else if (typeof module2 != "undefined" && module2.exports) {
        module2.exports = Decimal2;
      } else {
        if (!globalScope) {
          globalScope = typeof self != "undefined" && self && self.self == self ? self : Function("return this")();
        }
        globalScope.Decimal = Decimal2;
      }
    })(exports2);
  }
});

// node_modules/@raydium-io/raydium-sdk-v2/lib/index.js
var require_lib = __commonJS({
  "node_modules/@raydium-io/raydium-sdk-v2/lib/index.js"(exports2, module2) {
    var Pp = Object.create;
    var Xi = Object.defineProperty;
    var Ap = Object.defineProperties;
    var wp = Object.getOwnPropertyDescriptor;
    var kp = Object.getOwnPropertyDescriptors;
    var hp = Object.getOwnPropertyNames;
    var os = Object.getOwnPropertySymbols;
    var Tp = Object.getPrototypeOf;
    var nu = Object.prototype.hasOwnProperty;
    var _l = Object.prototype.propertyIsEnumerable;
    var Vl = (i, e, t) => e in i ? Xi(i, e, { enumerable: true, configurable: true, writable: true, value: t }) : i[e] = t;
    var E = (i, e) => {
      for (var t in e || (e = {}))
        nu.call(e, t) && Vl(i, t, e[t]);
      if (os)
        for (var t of os(e))
          _l.call(e, t) && Vl(i, t, e[t]);
      return i;
    };
    var U = (i, e) => Ap(i, kp(e));
    var tt = (i, e) => {
      var t = {};
      for (var n in i)
        nu.call(i, n) && e.indexOf(n) < 0 && (t[n] = i[n]);
      if (i != null && os)
        for (var n of os(i))
          e.indexOf(n) < 0 && _l.call(i, n) && (t[n] = i[n]);
      return t;
    };
    var Ip = (i, e) => {
      for (var t in e)
        Xi(i, t, { get: e[t], enumerable: true });
    };
    var El = (i, e, t, n) => {
      if (e && typeof e == "object" || typeof e == "function")
        for (let o of hp(e))
          !nu.call(i, o) && o !== t && Xi(i, o, { get: () => e[o], enumerable: !(n = wp(e, o)) || n.enumerable });
      return i;
    };
    var Ae = (i, e, t) => (t = i != null ? Pp(Tp(i)) : {}, El(e || !i || !i.__esModule ? Xi(t, "default", { value: i, enumerable: true }) : t, i));
    var Bp = (i) => El(Xi({}, "__esModule", { value: true }), i);
    var bg = {};
    Ip(bg, { ACCOUNT_TYPE_SIZE: () => Sp, ALL_PROGRAM_ID: () => Et, AMM_CONFIG_SEED: () => Pd, AMM_STABLE: () => hm, AMM_V4: () => si, ANAMint: () => vf, API_URLS: () => It, AUTH_SEED: () => sp, AccountType: () => ql, Api: () => cr, BIT_PRECISION: () => bc, BNDivCeil: () => An, BNLayout: () => ho, BN_100: () => Zf, BN_1000: () => $f, BN_10000: () => Jf, BN_FIVE: () => jf, BN_ONE: () => Au, BN_TEN: () => bo, BN_THREE: () => Qf, BN_TWO: () => Hf, BN_ZERO: () => ut, BitStructure: () => wy, Blob: () => qu, BondingCurveParam: () => Da, CLMM_LOCK_AUTH_ID: () => ai, CLMM_LOCK_PROGRAM_ID: () => Fo, CLMM_PROGRAM_ID: () => $n, CLOCK_PROGRAM_ID: () => As, CONFIG_SEED: () => ap, CREATE_CPMM_POOL_AUTH: () => Cs, CREATE_CPMM_POOL_FEE_ACC: () => Km, CREATE_CPMM_POOL_PROGRAM: () => eo, CREATOR_FEE_VAULT_AUTH_SEED: () => mp, Clmm: () => vi, ClmmConfigLayout: () => Oc, ClmmInstrument: () => Oe, ConstantProductCurve: () => Fi, CpmmConfigInfoLayout: () => sl, CpmmCreatorFeeOn: () => hl, CpmmFee: () => Jt, CpmmPermission: () => eg, CpmmPoolInfoLayout: () => Vr, Currency: () => ni, CurrencyAmount: () => yo, Curve: () => Yt, CurveBase: () => ao, CurveCalculator: () => Vi, DEVNET_PROGRAM_ID: () => En, DEV_API_URLS: () => Nu, DEV_FARM_LOCK_MINT: () => sb, DEV_FARM_LOCK_VAULT: () => ab, DEV_LAUNCHPAD_AUTH: () => dy, DEV_LAUNCHPAD_PROGRAM: () => my, DEV_LOOKUP_TABLE_CACHE: () => _o, DataElement: () => Dd, ETHMint: () => Ff, EXTENSION_TICKARRAY_BITMAP_SIZE: () => ka, FARM_LOCK_MINT: () => nc, FARM_LOCK_VAULT: () => oc, FARM_PROGRAM_ID_V3: () => Is, FARM_PROGRAM_ID_V4: () => Bs, FARM_PROGRAM_ID_V5: () => xs, FARM_PROGRAM_ID_V6: () => vo, FARM_PROGRAM_TO_VERSION: () => mn, FARM_VERSION_TO_LEDGER_LAYOUT: () => rc, FARM_VERSION_TO_STATE_LAYOUT: () => ic, FEE_DESTINATION_ID: () => Ks, FEE_RATE_DENOMINATOR: () => kr, FEE_RATE_DENOMINATOR_VALUE: () => jt, FETCH_TICKARRAY_COUNT: () => Bd, Fee: () => gd, FeeOn: () => al, FixedPriceCurve: () => Xr, Fraction: () => ke, IDO_ALL_PROGRAM: () => li, IDO_PROGRAM_ID_V1: () => Im, IDO_PROGRAM_ID_V2: () => Bm, IDO_PROGRAM_ID_V3: () => xm, IDO_PROGRAM_ID_V4: () => Sm, INSTRUCTION_PROGRAM_ID: () => $i, InstructionType: () => X, JupTokenType: () => Ru, LAUNCHPAD_AUTH: () => Cm, LAUNCHPAD_CONFIG: () => Lm, LAUNCHPAD_PLATFORM: () => Rm, LAUNCHPAD_PROGRAM: () => pt, LIQUIDITY_FEES_DENOMINATOR: () => xr, LIQUIDITY_FEES_NUMERATOR: () => Ta, LIQUIDITY_POOL_PROGRAM_ID_V5_MODEL: () => sr, LIQUIDITY_VERSION_TO_SERUM_VERSION: () => vd, LIQUIDITY_VERSION_TO_STATE_LAYOUT: () => Cb, LOCK_CPMM_AUTH: () => ci, LOCK_CPMM_PROGRAM: () => ui, LOCK_LIQUIDITY_SEED: () => tp, LOG_B_2_X32: () => gc, LOG_B_P_ERR_MARGIN_LOWER_X64: () => Pc, LOG_B_P_ERR_MARGIN_UPPER_X64: () => Ac, LOOKUP_TABLE_CACHE: () => Vo, LaunchConstantProductCurve: () => Ur, LaunchpadConfig: () => ro, LaunchpadPool: () => In, LaunchpadPoolInitParam: () => Yr, LaunchpadVesting: () => sg, Layout: () => di, LinearPriceCurve: () => zr, LiquidityMath: () => Re, LockClPositionLayoutV2: () => Fc, LockPositionLayout: () => Tb, LogLevel: () => Wl, Logger: () => is, MARKET_STATE_LAYOUT_V2: () => Ma, MARKET_STATE_LAYOUT_V3: () => Ea, MARKET_VERSION_TO_STATE_LAYOUT: () => ll, MAX_BASE64_SIZE: () => Bu, MAX_SQRT_PRICE_X64: () => Ut, MAX_SQRT_PRICE_X64_SUB_ONE: () => wr, MAX_TICK: () => Dt, MEMO_PROGRAM_ID: () => Zi, MEMO_PROGRAM_ID2: () => Cn, METADATA_PROGRAM_ID: () => cn, MIN_SQRT_PRICE_X64: () => qt, MIN_SQRT_PRICE_X64_ADD_ONE: () => Ar, MIN_TICK: () => Mt, MODEL_DATA_PUBKEY: () => Jn, Market: () => Er, MathLaunch: () => Wi, MathUtil: () => Pe, MaxU64: () => ki, MaxUint128: () => yc, NEGATIVE_ONE: () => qn, NRVMint: () => Mf, OBSERVATION_SEED: () => Td, ONE: () => rn, OPEN_BOOK_PROGRAM: () => Ss, OPERATION_SEED: () => kd, ObservationInfoLayout: () => Mc, ObservationLayout: () => Sd, OperationLayout: () => vc, OptionLayout: () => Xs, Owner: () => Pn, PAIMint: () => Sf, PLATFORM_FEE_VAULT_AUTH_SEED: () => lp, PLATFORM_SEED: () => cp, POOL_LOCK_ID_SEED: () => Sc, POOL_REWARD_VAULT_SEED: () => Ad, POOL_SEED: () => ba, POOL_TICK_ARRAY_BITMAP_SEED: () => hd, POOL_VAULT_SEED: () => ga, POOL_VESTING_SEED: () => up, POSITION_SEED: () => Tc, Percent: () => ot, PlatformConfig: () => Xn, PlatformCurveParam: () => rp, PoolFetchType: () => Lu, PoolInfoLayout: () => Bo, PoolUtils: () => Xe, PositionInfoLayout: () => Uo, PositionRewardInfoLayout: () => Cd, PositionUtils: () => Bi, Price: () => Tt, ProtocolPositionLayout: () => hb, Q128: () => Pr, Q64: () => Pt, RAYMint: () => xf, RENT_PROGRAM_ID: () => at, Raydium: () => Jr, RewardInfo: () => Kd, RoundDirection: () => jc, Rounding: () => ps, Router: () => Tm, SERUM_PROGRAMID_TO_VERSION: () => ul, SERUM_PROGRAM_ID_V3: () => rr, SERUM_VERSION_TO_PROGRAMID: () => cl, SESSION_KEY: () => Ou, SOLMint: () => ht, SOL_INFO: () => Kn, SPL_MINT_LAYOUT: () => Vc, SRMMint: () => Kf, STORAGE_KEY: () => Fs, SUPPORT_MINT_SEED: () => Id, SYSTEM_PROGRAM_ID: () => Ji, SqrtPriceMath: () => fe, StableLayout: () => Xo, Structure: () => zs, SwapMath: () => Io, TICK_ARRAY_BITMAP_SIZE: () => To, TICK_ARRAY_SEED: () => wd, TICK_ARRAY_SIZE: () => At, TICK_SPACINGS: () => fb, TOKEN_WSOL: () => kt, TickArrayBitmap: () => Gn, TickArrayBitmapExtensionLayout: () => Lc, TickArrayBitmapExtensionUtils: () => Si, TickArrayLayout: () => xi, TickLayout: () => Rd, TickMath: () => xo, TickQuery: () => Ne, TickUtils: () => ne, Token: () => De, TokenAmount: () => ve, TradeDirection: () => $d, TradeDirectionOpposite: () => Jd, TxBuilder: () => ar, TxVersion: () => Vn, U64Resolution: () => hi, U64_IGNORE_RANGE: () => bb, UInt: () => Ds, USDCMint: () => Cf, USDHMint: () => Of, USDTMint: () => Rf, UTIL1216: () => km, Union: () => Ys, VestingSchedule: () => ip, Voter: () => tc, VoterDepositEntry: () => ad, VoterLockup: () => sd, VoterRegistrar: () => ec, VoterVotingMintConfig: () => rd, WSOLMint: () => ee, WideBits: () => mr, WrappedLayout: () => Wn, ZERO: () => Ke, _100_PERCENT: () => gu, accountMeta: () => w, add: () => Yf, addComputeBudget: () => nr, addLiquidityLayout: () => Sa, anchorDataBuf: () => Rt, array: () => Jy, associatedLedgerAccountLayout: () => js, bits: () => Us, blob: () => Fe, bool: () => Ze, buyExactInInstruction: () => Wr, buyExactOutInstruction: () => gl, calFarmRewardAmount: () => la, ceilDiv: () => oi, ceilDivBN: () => Ao, checkLegacyTxSize: () => ii, checkPoolToAmm: () => mg, checkV0TxSize: () => ri, chunkArray: () => rs, claimCreatorFee: () => ja, claimLayout: () => Di, claimPlatformFee: () => Ha, claimPlatformFeeFromVault: () => Qa, claimVestedToken: () => za, clmmComputeInfoToApiInfo: () => Rc, closeAccountInstruction: () => Dn, collectCpFeeInstruction: () => Va, commonSystemAccountMeta: () => bs, confirmTransaction: () => or, cpmmLockPositionInstruction: () => np, createAssociatedLedgerAccountInstruction: () => gi, createLogger: () => xe, createPlatformConfig: () => Al, createPlatformVestingAccountIns: () => kl, createPoolFeeLayout: () => Ec, createPoolV4InstructionV2: () => La, createPoolV4Layout: () => Kb, createVestingAccount: () => Ya, createWSolAccountInstructions: () => to, cstr: () => Hy, currencyEquals: () => Vf, decimalToFraction: () => oy, decodeBool: () => Qm, div: () => Uf, divCeil: () => er, dwLayout: () => Wt, encodeBool: () => jm, endlessRetry: () => yy, eq: () => dm, f32: () => Uy, f32be: () => Gy, f64: () => Xy, f64be: () => zy, farmAddRewardLayout: () => ea, farmLedgerLayoutV3_1: () => ib, farmLedgerLayoutV3_2: () => yi, farmLedgerLayoutV5_1: () => rb, farmLedgerLayoutV5_2: () => $u, farmLedgerLayoutV6_1: () => Ju, farmRewardInfoToConfig: () => ac, farmRewardLayout: () => $s, farmRewardRestartLayout: () => Js, farmRewardTimeInfoLayout: () => id, farmStateV3Layout: () => ju, farmStateV5Layout: () => Zu, farmStateV6Layout: () => fi, fetchMultipleFarmInfoAndUpdate: () => ub, fetchMultipleInfo: () => Db, fetchMultipleMintInfos: () => Oo, findProgramAddress: () => se, fixedSwapInLayout: () => Ia, fixedSwapOutLayout: () => Ba, floorDiv: () => tr, forecastTransactionSize: () => ir, formatLayout: () => Xd, generatePubKey: () => rt, getATAAddress: () => te, getAssociatedAuthority: () => sc, getAssociatedConfigId: () => Rr, getAssociatedLedgerAccount: () => Ot, getAssociatedLedgerPoolAccount: () => bi, getAssociatedOpenOrders: () => Qd, getAssociatedPoolKeys: () => Oa, getCpLockPda: () => Ei, getCpmmPdaAmmConfigId: () => Zb, getCpmmPdaPoolId: () => va, getCreatePoolKeys: () => Fa, getDate: () => hu, getDepositEntryIndex: () => ma, getDevLookupTableCache: () => Ms, getDxByDyBaseIn: () => Gc, getDyByDxBaseIn: () => Uc, getEpochInfo: () => cy, getFarmLedgerLayout: () => Do, getFarmStateLayout: () => cd, getLiquidityAssociatedAuthority: () => Na, getLiquidityAssociatedId: () => Ko, getLiquidityFromAmounts: () => wb, getMainLookupTableCache: () => Os, getMax: () => zf, getMultipleAccountsInfo: () => gn, getMultipleAccountsInfoWithCustomFlags: () => ze, getMultipleLookupTableInfo: () => Ns, getPdaAmmConfigId: () => Ab, getPdaCpiEvent: () => so, getPdaCreatorFeeVaultAuth: () => Xa, getPdaCreatorVault: () => vn, getPdaExBitmapAccount: () => st, getPdaLaunchpadAuth: () => an, getPdaLaunchpadConfigId: () => ag, getPdaLaunchpadPoolId: () => Ho, getPdaLaunchpadVaultId: () => qa, getPdaLockClPositionIdV2: () => qo, getPdaLockPositionId: () => Aa, getPdaLpMint: () => ep, getPdaMetadataKey: () => Un, getPdaMintExAccount: () => wa, getPdaObservationAccount: () => xc, getPdaObservationId: () => _i, getPdaOperationAccount: () => Ii, getPdaPermissionId: () => Jc, getPdaPersonalPositionAddress: () => Gt, getPdaPlatformFeeVaultAuth: () => Ga, getPdaPlatformId: () => Ua, getPdaPlatformVault: () => Mn, getPdaPoolAuthority: () => Yo, getPdaPoolId: () => Ic, getPdaPoolRewardVaulId: () => Bc, getPdaPoolVaultId: () => Pa, getPdaProtocolPositionAddress: () => hn, getPdaTickArrayAddress: () => Ce, getPdaVault: () => $c, getPdaVestId: () => Qo, getRecentBlockHash: () => Mo, getRegistrarAddress: () => ia, getSessionKey: () => Vm, getStablePrice: () => Xc, getTime: () => ym, getTimestamp: () => fy, getTokenOwnerRecordAddress: () => ca, getTransferAmountFee: () => py, getTransferAmountFeeFromPost: () => Ls, getTransferAmountFeeFromPre: () => Rs, getTransferAmountFeeV2: () => _e, getVoterAddress: () => aa, getVoterWeightRecordAddress: () => ua, getVotingMintAuthority: () => sa, getVotingTokenMint: () => ra, governanceCreateTokenOwnerRecord: () => fd, greedy: () => ky, gt: () => mm, gte: () => qf, i128: () => zu, i16ToBytes: () => gb, i32ToBytes: () => Tr, i64: () => Eo, i8: () => Xu, initPoolLayout: () => xa, initTokenAccountInstruction: () => Qs, initialize: () => ug, initializeMarket: () => jd, initializeV2: () => yl, initializeWithPermission: () => rl, initializeWithToken2022: () => bl, intersection: () => sy, isDateAfter: () => Iu, isDateBefore: () => Tu, isDecimal: () => iy, isMeaningfulNumber: () => Xf, isNumber: () => ku, isValidFarmVersion: () => na, isZero: () => Ti, jsonInfo2PoolKeys: () => Qe, judgeFarmType: () => cb, leadingZeros: () => fa, leastSignificantBit: () => hc, liquidityStateV4Layout: () => So, liquidityStateV5Layout: () => Fd, lt: () => Wf, lte: () => Df, mSOLMint: () => Lf, makeAMMSwapInstruction: () => Cr, makeAMMSwapV2Instruction: () => Kr, makeAddLiquidityInstruction: () => Wc, makeAddNewRewardInstruction: () => pa, makeClaimInstruction: () => Zr, makeClaimInstructionV4: () => Ja, makeCollectCreatorFeeInstruction: () => _a, makeCpmmLockInstruction: () => il, makeCreateCpmmPoolInInstruction: () => el, makeCreateFarmInstruction: () => uc, makeCreateMarketInstruction: () => Nr, makeCreatorWithdrawFarmRewardInstruction: () => cc, makeDepositCpmmInInstruction: () => tl, makeDepositInstructionV3: () => mc, makeDepositInstructionV5: () => dc, makeDepositInstructionV6: () => pc, makeDepositTokenInstruction: () => mb, makeDepositWithdrawInstruction: () => pb, makeInitPoolInstructionV4: () => Lb, makePurchaseInstruction: () => pg, makeRestartRewardInstruction: () => da, makeSimulatePoolInfoInstruction: () => Dc, makeSwapCpmmBaseInInstruction: () => Fr, makeSwapCpmmBaseOutInstruction: () => ol, makeSwapFixedInInstruction: () => Vd, makeSwapFixedOutInstruction: () => _d, makeSwapInstruction: () => pl, makeTransferInstruction: () => Qu, makeWithdrawCpmmInInstruction: () => nl, makeWithdrawInstructionV3: () => wi, makeWithdrawInstructionV4: () => lc, makeWithdrawInstructionV5: () => Ai, makeWithdrawInstructionV6: () => Pi, makeWithdrawTokenInstruction: () => db, minExpirationTime: () => wn, mockCreatePoolInfo: () => yb, mockV3CreatePoolInfo: () => wc, modelDataInfoLayout: () => qd, mostSignificantBit: () => kc, mul: () => hs, notInnerObject: () => vm, ns64: () => Fy, ns64be: () => qy, nu64: () => Uu, nu64be: () => Ry, offset: () => Gs, offsetDateTime: () => ry, option: () => jy, parseBigNumberish: () => oe, parseNumberInfo: () => go, parseSimulateLogToJson: () => Su, parseSimulateValue: () => _n, parseTokenAccountResp: () => Hu, parseTokenInfo: () => Ib, poolTypeV6: () => no, printSimulate: () => Po, publicKey: () => F, purchaseLayout: () => Za, realFarmStateV3Layout: () => td, realFarmStateV5Layout: () => nd, realFarmV6Layout: () => od, removeLiquidityInstruction: () => Ra, removeLiquidityLayout: () => Ka, removePlatformCurveParamInstruction: () => lg, route1Instruction: () => ng, route2Instruction: () => og, routeInstruction: () => op, rustEnum: () => $y, s16: () => Ny, s16be: () => Vy, s24: () => Oy, s24be: () => _y, s32: () => je, s32be: () => Ey, s40: () => My, s40be: () => Wy, s48: () => vy, s48be: () => Dy, s8: () => Ly, sellExactInInstruction: () => Dr, sellExactOut: () => Pl, seq: () => Z, setLoggerLevel: () => xp, shakeFractionDecimal: () => pm, simulateMultipleInstruction: () => xu, simulatePoolInfoInstruction: () => Rb, simulateTransaction: () => gm, sleep: () => Cu, solToWSol: () => Lt, solToWSolToken: () => xb, splAccountLayout: () => kn, splitNumber: () => pu, stSOLMint: () => Nf, str: () => Kt, struct: () => V, sub: () => Gf, swapBaseInAutoAccount: () => ig, swapBaseInV2Instruction: () => Ed, swapBaseOutAutoAccount: () => rg, swapBaseOutV2Instruction: () => Wd, tagged: () => Zy, tenExponential: () => ks, toAmmComputePoolInfo: () => Lr, toApiV3Token: () => vt, toBN: () => fm, toBuffer: () => Ku, toFeeConfig: () => oo, toFraction: () => wu, toFractionWithDecimals: () => Ef, toPercent: () => ey, toToken: () => Br, toTokenAmount: () => Ki, toTokenInfo: () => Bb, toTokenPrice: () => ty, toTotalPrice: () => ny, toUsdCurrency: () => Pu, trailingZeros: () => ya, transformTxToBase64: () => ly, tryParsePublicKey: () => Ps, txToBase64: () => Pm, u128: () => ae, u16: () => on, u16ToBytes: () => hr, u16be: () => By, u24: () => hy, u24be: () => xy, u32: () => St, u32ToBytes: () => Pb, u32be: () => Sy, u40: () => Ty, u40be: () => Ky, u48: () => Iy, u48be: () => Cy, u64: () => P2, u8: () => W, u8ToBytes: () => dp, union: () => eb, unionArr: () => yg, unionLayoutDiscriminator: () => Yy, uniq: () => uy, updateFarmPoolInfo: () => ld, updatePlatformConfig: () => wl, updatePlatformCurveParamInstruction: () => cg, updateReqHistory: () => ur, usdMintBSet: () => dg, utf8: () => Qy, validateAndParsePublicKey: () => gs, validateFarmRewards: () => oa, vec: () => Yu, vecU8: () => Zm, voterStakeRegistryCreateDepositEntry: () => bd, voterStakeRegistryCreateVoter: () => yd, voterStakeRegistryDeposit: () => md, voterStakeRegistryUpdateVoterWeightRecord: () => dd, voterStakeRegistryWithdraw: () => pd, wSolToSolToken: () => Sb, withdrawRewardLayout: () => Zs, xor: () => ay, zeros: () => tb });
    module2.exports = Bp(bg);
    var Fu = Ae(require_axios());
    var ru = require("@solana/web3.js");
    var No = require_lodash();
    var Wl = ((o) => (o[o.Error = 0] = "Error", o[o.Warning = 1] = "Warning", o[o.Info = 2] = "Info", o[o.Debug = 3] = "Debug", o))(Wl || {});
    var is = class {
      constructor(e) {
        this.logLevel = e.logLevel !== void 0 ? e.logLevel : 0, this.name = e.name;
      }
      set level(e) {
        this.logLevel = e;
      }
      get time() {
        return Date.now().toString();
      }
      get moduleName() {
        return this.name;
      }
      isLogLevel(e) {
        return e <= this.logLevel;
      }
      error(...e) {
        return this.isLogLevel(0) ? (console.error(this.time, this.name, "sdk logger error", ...e), this) : this;
      }
      logWithError(...e) {
        let t = e.map((n) => typeof n == "object" ? JSON.stringify(n) : n).join(", ");
        throw new Error(t);
      }
      warning(...e) {
        return this.isLogLevel(1) ? (console.warn(this.time, this.name, "sdk logger warning", ...e), this) : this;
      }
      info(...e) {
        return this.isLogLevel(2) ? (console.info(this.time, this.name, "sdk logger info", ...e), this) : this;
      }
      debug(...e) {
        return this.isLogLevel(3) ? (console.debug(this.time, this.name, "sdk logger debug", ...e), this) : this;
      }
    };
    var ou = {};
    var Dl = {};
    function xe(i) {
      let e = (0, No.get)(ou, i);
      if (!e) {
        let t = (0, No.get)(Dl, i);
        e = new is({ name: i, logLevel: t }), (0, No.set)(ou, i, e);
      }
      return e;
    }
    function xp(i, e) {
      (0, No.set)(Dl, i, e);
      let t = (0, No.get)(ou, i);
      t && (t.level = e);
    }
    var co = require_cjs4();
    var iu = xe("Raydium_accountInfo_util");
    async function gn(i, e, t) {
      let { batchRequest: n, commitment: o = "confirmed", chunkCount: r = 100 } = E({ batchRequest: false }, t), s = rs(e, r), a = new Array(s.length).fill([]);
      if (n) {
        let c = s.map((m) => {
          let d = i._buildArgs([m.map((p) => p.toBase58())], o, "base64");
          return { methodName: "getMultipleAccounts", args: d };
        }), u = rs(c, 10);
        a = (await (await Promise.all(u.map(async (m) => await i._rpcBatchRequest(m)))).flat()).map((m) => (m.error && iu.logWithError(`failed to get info for multiple accounts, RPC_ERROR, ${m.error.message}`), m.result.value.map((d) => {
          if (d) {
            let { data: p, executable: f, lamports: y, owner: b, rentEpoch: g } = d;
            return p.length !== 2 && p[1] !== "base64" && iu.logWithError("info must be base64 encoded, RPC_ERROR"), { data: Buffer.from(p[0], "base64"), executable: f, lamports: y, owner: new ru.PublicKey(b), rentEpoch: g };
          }
          return null;
        })));
      } else
        try {
          a = await Promise.all(s.map((c) => i.getMultipleAccountsInfo(c, o)));
        } catch (c) {
          c instanceof Error && iu.logWithError(`failed to get info for multiple accounts, RPC_ERROR, ${c.message}`);
        }
      return a.flat();
    }
    async function ze(i, e, t) {
      let n = await gn(i, e.map((o) => o.pubkey), t);
      return e.map((o, r) => U(E({}, o), { accountInfo: n[r] }));
    }
    var ql = ((n) => (n[n.Uninitialized = 0] = "Uninitialized", n[n.Mint = 1] = "Mint", n[n.Account = 2] = "Account", n))(ql || {});
    var Sp = 1;
    async function Oo({ connection: i, mints: e, config: t }) {
      var r, s, a;
      if (e.length === 0)
        return {};
      let n = await ze(i, e.map((c) => ({ pubkey: Lt(c) })), t), o = {};
      for (let c of n) {
        if (!c.accountInfo || c.accountInfo.data.length < co.MINT_SIZE) {
          console.log("invalid mint account", c.pubkey.toBase58());
          continue;
        }
        let u = (0, co.unpackMint)(c.pubkey, c.accountInfo, (r = c.accountInfo) == null ? void 0 : r.owner);
        o[c.pubkey.toString()] = U(E({}, u), { programId: ((s = c.accountInfo) == null ? void 0 : s.owner) || co.TOKEN_PROGRAM_ID, feeConfig: (a = (0, co.getTransferFeeConfig)(u)) != null ? a : void 0 });
      }
      return o[ru.PublicKey.default.toBase58()] = o[ee.toBase58()], o;
    }
    var it = Ae(require_bn());
    var Jo = 9e15;
    var fo = 1e9;
    var su = "0123456789abcdef";
    var as = "2.3025850929940456840179914546843642076011014886287729760333279009675726096773524802359972050895982983419677840422862486334095254650828067566662873690987816894829072083255546808437998948262331985283935053089653777326288461633662222876982198867465436674744042432743651550489343149393914796194044002221051017141748003688084012647080685567743216228355220114804663715659121373450747856947683463616792101806445070648000277502684916746550586856935673420670581136429224554405758925724208241314695689016758940256776311356919292033376587141660230105703089634572075440370847469940168269282808481184289314848524948644871927809676271275775397027668605952496716674183485704422507197965004714951050492214776567636938662976979522110718264549734772662425709429322582798502585509785265383207606726317164309505995087807523710333101197857547331541421808427543863591778117054309827482385045648019095610299291824318237525357709750539565187697510374970888692180205189339507238539205144634197265287286965110862571492198849978748873771345686209167058";
    var us = "3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632789";
    var au = { precision: 20, rounding: 4, modulo: 1, toExpNeg: -7, toExpPos: 21, minE: -Jo, maxE: Jo, crypto: false };
    var zl;
    var Qn;
    var we = true;
    var ls = "[DecimalError] ";
    var po = ls + "Invalid argument: ";
    var Yl = ls + "Precision limit exceeded";
    var Hl = ls + "crypto unavailable";
    var Ql = "[object Decimal]";
    var _t = Math.floor;
    var wt = Math.pow;
    var Kp = /^0b([01]+(\.[01]*)?|\.[01]+)(p[+-]?\d+)?$/i;
    var Cp = /^0x([0-9a-f]+(\.[0-9a-f]*)?|\.[0-9a-f]+)(p[+-]?\d+)?$/i;
    var Rp = /^0o([0-7]+(\.[0-7]*)?|\.[0-7]+)(p[+-]?\d+)?$/i;
    var jl = /^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i;
    var Sn = 1e7;
    var ge = 7;
    var Lp = 9007199254740991;
    var Np = as.length - 1;
    var uu = us.length - 1;
    var z = { toStringTag: Ql };
    z.absoluteValue = z.abs = function() {
      var i = new this.constructor(this);
      return i.s < 0 && (i.s = 1), de(i);
    };
    z.ceil = function() {
      return de(new this.constructor(this), this.e + 1, 2);
    };
    z.clampedTo = z.clamp = function(i, e) {
      var t, n = this, o = n.constructor;
      if (i = new o(i), e = new o(e), !i.s || !e.s)
        return new o(NaN);
      if (i.gt(e))
        throw Error(po + e);
      return t = n.cmp(i), t < 0 ? i : n.cmp(e) > 0 ? e : new o(n);
    };
    z.comparedTo = z.cmp = function(i) {
      var e, t, n, o, r = this, s = r.d, a = (i = new r.constructor(i)).d, c = r.s, u = i.s;
      if (!s || !a)
        return !c || !u ? NaN : c !== u ? c : s === a ? 0 : !s ^ c < 0 ? 1 : -1;
      if (!s[0] || !a[0])
        return s[0] ? c : a[0] ? -u : 0;
      if (c !== u)
        return c;
      if (r.e !== i.e)
        return r.e > i.e ^ c < 0 ? 1 : -1;
      for (n = s.length, o = a.length, e = 0, t = n < o ? n : o; e < t; ++e)
        if (s[e] !== a[e])
          return s[e] > a[e] ^ c < 0 ? 1 : -1;
      return n === o ? 0 : n > o ^ c < 0 ? 1 : -1;
    };
    z.cosine = z.cos = function() {
      var i, e, t = this, n = t.constructor;
      return t.d ? t.d[0] ? (i = n.precision, e = n.rounding, n.precision = i + Math.max(t.e, t.sd()) + ge, n.rounding = 1, t = Op(n, tm(n, t)), n.precision = i, n.rounding = e, de(Qn == 2 || Qn == 3 ? t.neg() : t, i, e, true)) : new n(1) : new n(NaN);
    };
    z.cubeRoot = z.cbrt = function() {
      var i, e, t, n, o, r, s, a, c, u, l = this, m = l.constructor;
      if (!l.isFinite() || l.isZero())
        return new m(l);
      for (we = false, r = l.s * wt(l.s * l, 1 / 3), !r || Math.abs(r) == 1 / 0 ? (t = Nt(l.d), i = l.e, (r = (i - t.length + 1) % 3) && (t += r == 1 || r == -2 ? "0" : "00"), r = wt(t, 1 / 3), i = _t((i + 1) / 3) - (i % 3 == (i < 0 ? -1 : 2)), r == 1 / 0 ? t = "5e" + i : (t = r.toExponential(), t = t.slice(0, t.indexOf("e") + 1) + i), n = new m(t), n.s = l.s) : n = new m(r.toString()), s = (i = m.precision) + 3; ; )
        if (a = n, c = a.times(a).times(a), u = c.plus(l), n = Ye(u.plus(l).times(a), u.plus(c), s + 2, 1), Nt(a.d).slice(0, s) === (t = Nt(n.d)).slice(0, s))
          if (t = t.slice(s - 3, s + 1), t == "9999" || !o && t == "4999") {
            if (!o && (de(a, i + 1, 0), a.times(a).times(a).eq(l))) {
              n = a;
              break;
            }
            s += 4, o = 1;
          } else {
            (!+t || !+t.slice(1) && t.charAt(0) == "5") && (de(n, i + 1, 1), e = !n.times(n).times(n).eq(l));
            break;
          }
      return we = true, de(n, i, m.rounding, e);
    };
    z.decimalPlaces = z.dp = function() {
      var i, e = this.d, t = NaN;
      if (e) {
        if (i = e.length - 1, t = (i - _t(this.e / ge)) * ge, i = e[i], i)
          for (; i % 10 == 0; i /= 10)
            t--;
        t < 0 && (t = 0);
      }
      return t;
    };
    z.dividedBy = z.div = function(i) {
      return Ye(this, new this.constructor(i));
    };
    z.dividedToIntegerBy = z.divToInt = function(i) {
      var e = this, t = e.constructor;
      return de(Ye(e, new t(i), 0, 1, 1), t.precision, t.rounding);
    };
    z.equals = z.eq = function(i) {
      return this.cmp(i) === 0;
    };
    z.floor = function() {
      return de(new this.constructor(this), this.e + 1, 3);
    };
    z.greaterThan = z.gt = function(i) {
      return this.cmp(i) > 0;
    };
    z.greaterThanOrEqualTo = z.gte = function(i) {
      var e = this.cmp(i);
      return e == 1 || e === 0;
    };
    z.hyperbolicCosine = z.cosh = function() {
      var i, e, t, n, o, r = this, s = r.constructor, a = new s(1);
      if (!r.isFinite())
        return new s(r.s ? 1 / 0 : NaN);
      if (r.isZero())
        return a;
      t = s.precision, n = s.rounding, s.precision = t + Math.max(r.e, r.sd()) + 4, s.rounding = 1, o = r.d.length, o < 32 ? (i = Math.ceil(o / 3), e = (1 / ds(4, i)).toString()) : (i = 16, e = "2.3283064365386962890625e-10"), r = ei(s, 1, r.times(e), new s(1), true);
      for (var c, u = i, l = new s(8); u--; )
        c = r.times(r), r = a.minus(c.times(l.minus(c.times(l))));
      return de(r, s.precision = t, s.rounding = n, true);
    };
    z.hyperbolicSine = z.sinh = function() {
      var i, e, t, n, o = this, r = o.constructor;
      if (!o.isFinite() || o.isZero())
        return new r(o);
      if (e = r.precision, t = r.rounding, r.precision = e + Math.max(o.e, o.sd()) + 4, r.rounding = 1, n = o.d.length, n < 3)
        o = ei(r, 2, o, o, true);
      else {
        i = 1.4 * Math.sqrt(n), i = i > 16 ? 16 : i | 0, o = o.times(1 / ds(5, i)), o = ei(r, 2, o, o, true);
        for (var s, a = new r(5), c = new r(16), u = new r(20); i--; )
          s = o.times(o), o = o.times(a.plus(s.times(c.times(s).plus(u))));
      }
      return r.precision = e, r.rounding = t, de(o, e, t, true);
    };
    z.hyperbolicTangent = z.tanh = function() {
      var i, e, t = this, n = t.constructor;
      return t.isFinite() ? t.isZero() ? new n(t) : (i = n.precision, e = n.rounding, n.precision = i + 7, n.rounding = 1, Ye(t.sinh(), t.cosh(), n.precision = i, n.rounding = e)) : new n(t.s);
    };
    z.inverseCosine = z.acos = function() {
      var i, e = this, t = e.constructor, n = e.abs().cmp(1), o = t.precision, r = t.rounding;
      return n !== -1 ? n === 0 ? e.isNeg() ? xn(t, o, r) : new t(0) : new t(NaN) : e.isZero() ? xn(t, o + 4, r).times(0.5) : (t.precision = o + 6, t.rounding = 1, e = e.asin(), i = xn(t, o + 4, r).times(0.5), t.precision = o, t.rounding = r, i.minus(e));
    };
    z.inverseHyperbolicCosine = z.acosh = function() {
      var i, e, t = this, n = t.constructor;
      return t.lte(1) ? new n(t.eq(1) ? 0 : NaN) : t.isFinite() ? (i = n.precision, e = n.rounding, n.precision = i + Math.max(Math.abs(t.e), t.sd()) + 4, n.rounding = 1, we = false, t = t.times(t).minus(1).sqrt().plus(t), we = true, n.precision = i, n.rounding = e, t.ln()) : new n(t);
    };
    z.inverseHyperbolicSine = z.asinh = function() {
      var i, e, t = this, n = t.constructor;
      return !t.isFinite() || t.isZero() ? new n(t) : (i = n.precision, e = n.rounding, n.precision = i + 2 * Math.max(Math.abs(t.e), t.sd()) + 6, n.rounding = 1, we = false, t = t.times(t).plus(1).sqrt().plus(t), we = true, n.precision = i, n.rounding = e, t.ln());
    };
    z.inverseHyperbolicTangent = z.atanh = function() {
      var i, e, t, n, o = this, r = o.constructor;
      return o.isFinite() ? o.e >= 0 ? new r(o.abs().eq(1) ? o.s / 0 : o.isZero() ? o : NaN) : (i = r.precision, e = r.rounding, n = o.sd(), Math.max(n, i) < 2 * -o.e - 1 ? de(new r(o), i, e, true) : (r.precision = t = n - o.e, o = Ye(o.plus(1), new r(1).minus(o), t + i, 1), r.precision = i + 4, r.rounding = 1, o = o.ln(), r.precision = i, r.rounding = e, o.times(0.5))) : new r(NaN);
    };
    z.inverseSine = z.asin = function() {
      var i, e, t, n, o = this, r = o.constructor;
      return o.isZero() ? new r(o) : (e = o.abs().cmp(1), t = r.precision, n = r.rounding, e !== -1 ? e === 0 ? (i = xn(r, t + 4, n).times(0.5), i.s = o.s, i) : new r(NaN) : (r.precision = t + 6, r.rounding = 1, o = o.div(new r(1).minus(o.times(o)).sqrt().plus(1)).atan(), r.precision = t, r.rounding = n, o.times(2)));
    };
    z.inverseTangent = z.atan = function() {
      var i, e, t, n, o, r, s, a, c, u = this, l = u.constructor, m = l.precision, d = l.rounding;
      if (u.isFinite()) {
        if (u.isZero())
          return new l(u);
        if (u.abs().eq(1) && m + 4 <= uu)
          return s = xn(l, m + 4, d).times(0.25), s.s = u.s, s;
      } else {
        if (!u.s)
          return new l(NaN);
        if (m + 4 <= uu)
          return s = xn(l, m + 4, d).times(0.5), s.s = u.s, s;
      }
      for (l.precision = a = m + 10, l.rounding = 1, t = Math.min(28, a / ge + 2 | 0), i = t; i; --i)
        u = u.div(u.times(u).plus(1).sqrt().plus(1));
      for (we = false, e = Math.ceil(a / ge), n = 1, c = u.times(u), s = new l(u), o = u; i !== -1; )
        if (o = o.times(c), r = s.minus(o.div(n += 2)), o = o.times(c), s = r.plus(o.div(n += 2)), s.d[e] !== void 0)
          for (i = e; s.d[i] === r.d[i] && i--; )
            ;
      return t && (s = s.times(2 << t - 1)), we = true, de(s, l.precision = m, l.rounding = d, true);
    };
    z.isFinite = function() {
      return !!this.d;
    };
    z.isInteger = z.isInt = function() {
      return !!this.d && _t(this.e / ge) > this.d.length - 2;
    };
    z.isNaN = function() {
      return !this.s;
    };
    z.isNegative = z.isNeg = function() {
      return this.s < 0;
    };
    z.isPositive = z.isPos = function() {
      return this.s > 0;
    };
    z.isZero = function() {
      return !!this.d && this.d[0] === 0;
    };
    z.lessThan = z.lt = function(i) {
      return this.cmp(i) < 0;
    };
    z.lessThanOrEqualTo = z.lte = function(i) {
      return this.cmp(i) < 1;
    };
    z.logarithm = z.log = function(i) {
      var e, t, n, o, r, s, a, c, u = this, l = u.constructor, m = l.precision, d = l.rounding, p = 5;
      if (i == null)
        i = new l(10), e = true;
      else {
        if (i = new l(i), t = i.d, i.s < 0 || !t || !t[0] || i.eq(1))
          return new l(NaN);
        e = i.eq(10);
      }
      if (t = u.d, u.s < 0 || !t || !t[0] || u.eq(1))
        return new l(t && !t[0] ? -1 / 0 : u.s != 1 ? NaN : t ? 0 : 1 / 0);
      if (e)
        if (t.length > 1)
          r = true;
        else {
          for (o = t[0]; o % 10 === 0; )
            o /= 10;
          r = o !== 1;
        }
      if (we = false, a = m + p, s = mo(u, a), n = e ? cs(l, a + 10) : mo(i, a), c = Ye(s, n, a, 1), zi(c.d, o = m, d))
        do
          if (a += 10, s = mo(u, a), n = e ? cs(l, a + 10) : mo(i, a), c = Ye(s, n, a, 1), !r) {
            +Nt(c.d).slice(o + 1, o + 15) + 1 == 1e14 && (c = de(c, m + 1, 0));
            break;
          }
        while (zi(c.d, o += 10, d));
      return we = true, de(c, m, d);
    };
    z.minus = z.sub = function(i) {
      var e, t, n, o, r, s, a, c, u, l, m, d, p = this, f = p.constructor;
      if (i = new f(i), !p.d || !i.d)
        return !p.s || !i.s ? i = new f(NaN) : p.d ? i.s = -i.s : i = new f(i.d || p.s !== i.s ? p : NaN), i;
      if (p.s != i.s)
        return i.s = -i.s, p.plus(i);
      if (u = p.d, d = i.d, a = f.precision, c = f.rounding, !u[0] || !d[0]) {
        if (d[0])
          i.s = -i.s;
        else if (u[0])
          i = new f(p);
        else
          return new f(c === 3 ? -0 : 0);
        return we ? de(i, a, c) : i;
      }
      if (t = _t(i.e / ge), l = _t(p.e / ge), u = u.slice(), r = l - t, r) {
        for (m = r < 0, m ? (e = u, r = -r, s = d.length) : (e = d, t = l, s = u.length), n = Math.max(Math.ceil(a / ge), s) + 2, r > n && (r = n, e.length = 1), e.reverse(), n = r; n--; )
          e.push(0);
        e.reverse();
      } else {
        for (n = u.length, s = d.length, m = n < s, m && (s = n), n = 0; n < s; n++)
          if (u[n] != d[n]) {
            m = u[n] < d[n];
            break;
          }
        r = 0;
      }
      for (m && (e = u, u = d, d = e, i.s = -i.s), s = u.length, n = d.length - s; n > 0; --n)
        u[s++] = 0;
      for (n = d.length; n > r; ) {
        if (u[--n] < d[n]) {
          for (o = n; o && u[--o] === 0; )
            u[o] = Sn - 1;
          --u[o], u[n] += Sn;
        }
        u[n] -= d[n];
      }
      for (; u[--s] === 0; )
        u.pop();
      for (; u[0] === 0; u.shift())
        --t;
      return u[0] ? (i.d = u, i.e = ms(u, t), we ? de(i, a, c) : i) : new f(c === 3 ? -0 : 0);
    };
    z.modulo = z.mod = function(i) {
      var e, t = this, n = t.constructor;
      return i = new n(i), !t.d || !i.s || i.d && !i.d[0] ? new n(NaN) : !i.d || t.d && !t.d[0] ? de(new n(t), n.precision, n.rounding) : (we = false, n.modulo == 9 ? (e = Ye(t, i.abs(), 0, 3, 1), e.s *= i.s) : e = Ye(t, i, 0, n.modulo, 1), e = e.times(i), we = true, t.minus(e));
    };
    z.naturalExponential = z.exp = function() {
      return cu(this);
    };
    z.naturalLogarithm = z.ln = function() {
      return mo(this);
    };
    z.negated = z.neg = function() {
      var i = new this.constructor(this);
      return i.s = -i.s, de(i);
    };
    z.plus = z.add = function(i) {
      var e, t, n, o, r, s, a, c, u, l, m = this, d = m.constructor;
      if (i = new d(i), !m.d || !i.d)
        return !m.s || !i.s ? i = new d(NaN) : m.d || (i = new d(i.d || m.s === i.s ? m : NaN)), i;
      if (m.s != i.s)
        return i.s = -i.s, m.minus(i);
      if (u = m.d, l = i.d, a = d.precision, c = d.rounding, !u[0] || !l[0])
        return l[0] || (i = new d(m)), we ? de(i, a, c) : i;
      if (r = _t(m.e / ge), n = _t(i.e / ge), u = u.slice(), o = r - n, o) {
        for (o < 0 ? (t = u, o = -o, s = l.length) : (t = l, n = r, s = u.length), r = Math.ceil(a / ge), s = r > s ? r + 1 : s + 1, o > s && (o = s, t.length = 1), t.reverse(); o--; )
          t.push(0);
        t.reverse();
      }
      for (s = u.length, o = l.length, s - o < 0 && (o = s, t = l, l = u, u = t), e = 0; o; )
        e = (u[--o] = u[o] + l[o] + e) / Sn | 0, u[o] %= Sn;
      for (e && (u.unshift(e), ++n), s = u.length; u[--s] == 0; )
        u.pop();
      return i.d = u, i.e = ms(u, n), we ? de(i, a, c) : i;
    };
    z.precision = z.sd = function(i) {
      var e, t = this;
      if (i !== void 0 && i !== !!i && i !== 1 && i !== 0)
        throw Error(po + i);
      return t.d ? (e = Zl(t.d), i && t.e + 1 > e && (e = t.e + 1)) : e = NaN, e;
    };
    z.round = function() {
      var i = this, e = i.constructor;
      return de(new e(i), i.e + 1, e.rounding);
    };
    z.sine = z.sin = function() {
      var i, e, t = this, n = t.constructor;
      return t.isFinite() ? t.isZero() ? new n(t) : (i = n.precision, e = n.rounding, n.precision = i + Math.max(t.e, t.sd()) + ge, n.rounding = 1, t = vp(n, tm(n, t)), n.precision = i, n.rounding = e, de(Qn > 2 ? t.neg() : t, i, e, true)) : new n(NaN);
    };
    z.squareRoot = z.sqrt = function() {
      var i, e, t, n, o, r, s = this, a = s.d, c = s.e, u = s.s, l = s.constructor;
      if (u !== 1 || !a || !a[0])
        return new l(!u || u < 0 && (!a || a[0]) ? NaN : a ? s : 1 / 0);
      for (we = false, u = Math.sqrt(+s), u == 0 || u == 1 / 0 ? (e = Nt(a), (e.length + c) % 2 == 0 && (e += "0"), u = Math.sqrt(e), c = _t((c + 1) / 2) - (c < 0 || c % 2), u == 1 / 0 ? e = "5e" + c : (e = u.toExponential(), e = e.slice(0, e.indexOf("e") + 1) + c), n = new l(e)) : n = new l(u.toString()), t = (c = l.precision) + 3; ; )
        if (r = n, n = r.plus(Ye(s, r, t + 2, 1)).times(0.5), Nt(r.d).slice(0, t) === (e = Nt(n.d)).slice(0, t))
          if (e = e.slice(t - 3, t + 1), e == "9999" || !o && e == "4999") {
            if (!o && (de(r, c + 1, 0), r.times(r).eq(s))) {
              n = r;
              break;
            }
            t += 4, o = 1;
          } else {
            (!+e || !+e.slice(1) && e.charAt(0) == "5") && (de(n, c + 1, 1), i = !n.times(n).eq(s));
            break;
          }
      return we = true, de(n, c, l.rounding, i);
    };
    z.tangent = z.tan = function() {
      var i, e, t = this, n = t.constructor;
      return t.isFinite() ? t.isZero() ? new n(t) : (i = n.precision, e = n.rounding, n.precision = i + 10, n.rounding = 1, t = t.sin(), t.s = 1, t = Ye(t, new n(1).minus(t.times(t)).sqrt(), i + 10, 0), n.precision = i, n.rounding = e, de(Qn == 2 || Qn == 4 ? t.neg() : t, i, e, true)) : new n(NaN);
    };
    z.times = z.mul = function(i) {
      var e, t, n, o, r, s, a, c, u, l = this, m = l.constructor, d = l.d, p = (i = new m(i)).d;
      if (i.s *= l.s, !d || !d[0] || !p || !p[0])
        return new m(!i.s || d && !d[0] && !p || p && !p[0] && !d ? NaN : !d || !p ? i.s / 0 : i.s * 0);
      for (t = _t(l.e / ge) + _t(i.e / ge), c = d.length, u = p.length, c < u && (r = d, d = p, p = r, s = c, c = u, u = s), r = [], s = c + u, n = s; n--; )
        r.push(0);
      for (n = u; --n >= 0; ) {
        for (e = 0, o = c + n; o > n; )
          a = r[o] + p[n] * d[o - n - 1] + e, r[o--] = a % Sn | 0, e = a / Sn | 0;
        r[o] = (r[o] + e) % Sn | 0;
      }
      for (; !r[--s]; )
        r.pop();
      return e ? ++t : r.shift(), i.d = r, i.e = ms(r, t), we ? de(i, m.precision, m.rounding) : i;
    };
    z.toBinary = function(i, e) {
      return mu(this, 2, i, e);
    };
    z.toDecimalPlaces = z.toDP = function(i, e) {
      var t = this, n = t.constructor;
      return t = new n(t), i === void 0 ? t : (nn(i, 0, fo), e === void 0 ? e = n.rounding : nn(e, 0, 8), de(t, i + t.e + 1, e));
    };
    z.toExponential = function(i, e) {
      var t, n = this, o = n.constructor;
      return i === void 0 ? t = Fn(n, true) : (nn(i, 0, fo), e === void 0 ? e = o.rounding : nn(e, 0, 8), n = de(new o(n), i + 1, e), t = Fn(n, true, i + 1)), n.isNeg() && !n.isZero() ? "-" + t : t;
    };
    z.toFixed = function(i, e) {
      var t, n, o = this, r = o.constructor;
      return i === void 0 ? t = Fn(o) : (nn(i, 0, fo), e === void 0 ? e = r.rounding : nn(e, 0, 8), n = de(new r(o), i + o.e + 1, e), t = Fn(n, false, i + n.e + 1)), o.isNeg() && !o.isZero() ? "-" + t : t;
    };
    z.toFraction = function(i) {
      var e, t, n, o, r, s, a, c, u, l, m, d, p = this, f = p.d, y = p.constructor;
      if (!f)
        return new y(p);
      if (u = t = new y(1), n = c = new y(0), e = new y(n), r = e.e = Zl(f) - p.e - 1, s = r % ge, e.d[0] = wt(10, s < 0 ? ge + s : s), i == null)
        i = r > 0 ? e : u;
      else {
        if (a = new y(i), !a.isInt() || a.lt(u))
          throw Error(po + a);
        i = a.gt(e) ? r > 0 ? e : u : a;
      }
      for (we = false, a = new y(Nt(f)), l = y.precision, y.precision = r = f.length * ge * 2; m = Ye(a, e, 0, 1, 1), o = t.plus(m.times(n)), o.cmp(i) != 1; )
        t = n, n = o, o = u, u = c.plus(m.times(o)), c = o, o = e, e = a.minus(m.times(o)), a = o;
      return o = Ye(i.minus(t), n, 0, 1, 1), c = c.plus(o.times(u)), t = t.plus(o.times(n)), c.s = u.s = p.s, d = Ye(u, n, r, 1).minus(p).abs().cmp(Ye(c, t, r, 1).minus(p).abs()) < 1 ? [u, n] : [c, t], y.precision = l, we = true, d;
    };
    z.toHexadecimal = z.toHex = function(i, e) {
      return mu(this, 16, i, e);
    };
    z.toNearest = function(i, e) {
      var t = this, n = t.constructor;
      if (t = new n(t), i == null) {
        if (!t.d)
          return t;
        i = new n(1), e = n.rounding;
      } else {
        if (i = new n(i), e === void 0 ? e = n.rounding : nn(e, 0, 8), !t.d)
          return i.s ? t : i;
        if (!i.d)
          return i.s && (i.s = t.s), i;
      }
      return i.d[0] ? (we = false, t = Ye(t, i, 0, e, 1).times(i), we = true, de(t)) : (i.s = t.s, t = i), t;
    };
    z.toNumber = function() {
      return +this;
    };
    z.toOctal = function(i, e) {
      return mu(this, 8, i, e);
    };
    z.toPower = z.pow = function(i) {
      var e, t, n, o, r, s, a = this, c = a.constructor, u = +(i = new c(i));
      if (!a.d || !i.d || !a.d[0] || !i.d[0])
        return new c(wt(+a, u));
      if (a = new c(a), a.eq(1))
        return a;
      if (n = c.precision, r = c.rounding, i.eq(1))
        return de(a, n, r);
      if (e = _t(i.e / ge), e >= i.d.length - 1 && (t = u < 0 ? -u : u) <= Lp)
        return o = $l(c, a, t, n), i.s < 0 ? new c(1).div(o) : de(o, n, r);
      if (s = a.s, s < 0) {
        if (e < i.d.length - 1)
          return new c(NaN);
        if ((i.d[e] & 1) == 0 && (s = 1), a.e == 0 && a.d[0] == 1 && a.d.length == 1)
          return a.s = s, a;
      }
      return t = wt(+a, u), e = t == 0 || !isFinite(t) ? _t(u * (Math.log("0." + Nt(a.d)) / Math.LN10 + a.e + 1)) : new c(t + "").e, e > c.maxE + 1 || e < c.minE - 1 ? new c(e > 0 ? s / 0 : 0) : (we = false, c.rounding = a.s = 1, t = Math.min(12, (e + "").length), o = cu(i.times(mo(a, n + t)), n), o.d && (o = de(o, n + 5, 1), zi(o.d, n, r) && (e = n + 10, o = de(cu(i.times(mo(a, e + t)), e), e + 5, 1), +Nt(o.d).slice(n + 1, n + 15) + 1 == 1e14 && (o = de(o, n + 1, 0)))), o.s = s, we = true, c.rounding = r, de(o, n, r));
    };
    z.toPrecision = function(i, e) {
      var t, n = this, o = n.constructor;
      return i === void 0 ? t = Fn(n, n.e <= o.toExpNeg || n.e >= o.toExpPos) : (nn(i, 1, fo), e === void 0 ? e = o.rounding : nn(e, 0, 8), n = de(new o(n), i, e), t = Fn(n, i <= n.e || n.e <= o.toExpNeg, i)), n.isNeg() && !n.isZero() ? "-" + t : t;
    };
    z.toSignificantDigits = z.toSD = function(i, e) {
      var t = this, n = t.constructor;
      return i === void 0 ? (i = n.precision, e = n.rounding) : (nn(i, 1, fo), e === void 0 ? e = n.rounding : nn(e, 0, 8)), de(new n(t), i, e);
    };
    z.toString = function() {
      var i = this, e = i.constructor, t = Fn(i, i.e <= e.toExpNeg || i.e >= e.toExpPos);
      return i.isNeg() && !i.isZero() ? "-" + t : t;
    };
    z.truncated = z.trunc = function() {
      return de(new this.constructor(this), this.e + 1, 1);
    };
    z.valueOf = z.toJSON = function() {
      var i = this, e = i.constructor, t = Fn(i, i.e <= e.toExpNeg || i.e >= e.toExpPos);
      return i.isNeg() ? "-" + t : t;
    };
    function Nt(i) {
      var e, t, n, o = i.length - 1, r = "", s = i[0];
      if (o > 0) {
        for (r += s, e = 1; e < o; e++)
          n = i[e] + "", t = ge - n.length, t && (r += lo(t)), r += n;
        s = i[e], n = s + "", t = ge - n.length, t && (r += lo(t));
      } else if (s === 0)
        return "0";
      for (; s % 10 === 0; )
        s /= 10;
      return r + s;
    }
    function nn(i, e, t) {
      if (i !== ~~i || i < e || i > t)
        throw Error(po + i);
    }
    function zi(i, e, t, n) {
      var o, r, s, a;
      for (r = i[0]; r >= 10; r /= 10)
        --e;
      return --e < 0 ? (e += ge, o = 0) : (o = Math.ceil((e + 1) / ge), e %= ge), r = wt(10, ge - e), a = i[o] % r | 0, n == null ? e < 3 ? (e == 0 ? a = a / 100 | 0 : e == 1 && (a = a / 10 | 0), s = t < 4 && a == 99999 || t > 3 && a == 49999 || a == 5e4 || a == 0) : s = (t < 4 && a + 1 == r || t > 3 && a + 1 == r / 2) && (i[o + 1] / r / 100 | 0) == wt(10, e - 2) - 1 || (a == r / 2 || a == 0) && (i[o + 1] / r / 100 | 0) == 0 : e < 4 ? (e == 0 ? a = a / 1e3 | 0 : e == 1 ? a = a / 100 | 0 : e == 2 && (a = a / 10 | 0), s = (n || t < 4) && a == 9999 || !n && t > 3 && a == 4999) : s = ((n || t < 4) && a + 1 == r || !n && t > 3 && a + 1 == r / 2) && (i[o + 1] / r / 1e3 | 0) == wt(10, e - 3) - 1, s;
    }
    function ss(i, e, t) {
      for (var n, o = [0], r, s = 0, a = i.length; s < a; ) {
        for (r = o.length; r--; )
          o[r] *= e;
        for (o[0] += su.indexOf(i.charAt(s++)), n = 0; n < o.length; n++)
          o[n] > t - 1 && (o[n + 1] === void 0 && (o[n + 1] = 0), o[n + 1] += o[n] / t | 0, o[n] %= t);
      }
      return o.reverse();
    }
    function Op(i, e) {
      var t, n, o;
      if (e.isZero())
        return e;
      n = e.d.length, n < 32 ? (t = Math.ceil(n / 3), o = (1 / ds(4, t)).toString()) : (t = 16, o = "2.3283064365386962890625e-10"), i.precision += t, e = ei(i, 1, e.times(o), new i(1));
      for (var r = t; r--; ) {
        var s = e.times(e);
        e = s.times(s).minus(s).times(8).plus(1);
      }
      return i.precision -= t, e;
    }
    var Ye = /* @__PURE__ */ function() {
      function i(n, o, r) {
        var s, a = 0, c = n.length;
        for (n = n.slice(); c--; )
          s = n[c] * o + a, n[c] = s % r | 0, a = s / r | 0;
        return a && n.unshift(a), n;
      }
      function e(n, o, r, s) {
        var a, c;
        if (r != s)
          c = r > s ? 1 : -1;
        else
          for (a = c = 0; a < r; a++)
            if (n[a] != o[a]) {
              c = n[a] > o[a] ? 1 : -1;
              break;
            }
        return c;
      }
      function t(n, o, r, s) {
        for (var a = 0; r--; )
          n[r] -= a, a = n[r] < o[r] ? 1 : 0, n[r] = a * s + n[r] - o[r];
        for (; !n[0] && n.length > 1; )
          n.shift();
      }
      return function(n, o, r, s, a, c) {
        var u, l, m, d, p, f, y, b, g, A, k, I, T, h, S, x, K, B, C, R, N = n.constructor, v = n.s == o.s ? 1 : -1, L = n.d, M = o.d;
        if (!L || !L[0] || !M || !M[0])
          return new N(!n.s || !o.s || (L ? M && L[0] == M[0] : !M) ? NaN : L && L[0] == 0 || !M ? v * 0 : v / 0);
        for (c ? (p = 1, l = n.e - o.e) : (c = Sn, p = ge, l = _t(n.e / p) - _t(o.e / p)), C = M.length, K = L.length, g = new N(v), A = g.d = [], m = 0; M[m] == (L[m] || 0); m++)
          ;
        if (M[m] > (L[m] || 0) && l--, r == null ? (h = r = N.precision, s = N.rounding) : a ? h = r + (n.e - o.e) + 1 : h = r, h < 0)
          A.push(1), f = true;
        else {
          if (h = h / p + 2 | 0, m = 0, C == 1) {
            for (d = 0, M = M[0], h++; (m < K || d) && h--; m++)
              S = d * c + (L[m] || 0), A[m] = S / M | 0, d = S % M | 0;
            f = d || m < K;
          } else {
            for (d = c / (M[0] + 1) | 0, d > 1 && (M = i(M, d, c), L = i(L, d, c), C = M.length, K = L.length), x = C, k = L.slice(0, C), I = k.length; I < C; )
              k[I++] = 0;
            R = M.slice(), R.unshift(0), B = M[0], M[1] >= c / 2 && ++B;
            do
              d = 0, u = e(M, k, C, I), u < 0 ? (T = k[0], C != I && (T = T * c + (k[1] || 0)), d = T / B | 0, d > 1 ? (d >= c && (d = c - 1), y = i(M, d, c), b = y.length, I = k.length, u = e(y, k, b, I), u == 1 && (d--, t(y, C < b ? R : M, b, c))) : (d == 0 && (u = d = 1), y = M.slice()), b = y.length, b < I && y.unshift(0), t(k, y, I, c), u == -1 && (I = k.length, u = e(M, k, C, I), u < 1 && (d++, t(k, C < I ? R : M, I, c))), I = k.length) : u === 0 && (d++, k = [0]), A[m++] = d, u && k[0] ? k[I++] = L[x] || 0 : (k = [L[x]], I = 1);
            while ((x++ < K || k[0] !== void 0) && h--);
            f = k[0] !== void 0;
          }
          A[0] || A.shift();
        }
        if (p == 1)
          g.e = l, zl = f;
        else {
          for (m = 1, d = A[0]; d >= 10; d /= 10)
            m++;
          g.e = m + l * p - 1, de(g, a ? r + g.e + 1 : r, s, f);
        }
        return g;
      };
    }();
    function de(i, e, t, n) {
      var o, r, s, a, c, u, l, m, d, p = i.constructor;
      e:
        if (e != null) {
          if (m = i.d, !m)
            return i;
          for (o = 1, a = m[0]; a >= 10; a /= 10)
            o++;
          if (r = e - o, r < 0)
            r += ge, s = e, l = m[d = 0], c = l / wt(10, o - s - 1) % 10 | 0;
          else if (d = Math.ceil((r + 1) / ge), a = m.length, d >= a)
            if (n) {
              for (; a++ <= d; )
                m.push(0);
              l = c = 0, o = 1, r %= ge, s = r - ge + 1;
            } else
              break e;
          else {
            for (l = a = m[d], o = 1; a >= 10; a /= 10)
              o++;
            r %= ge, s = r - ge + o, c = s < 0 ? 0 : l / wt(10, o - s - 1) % 10 | 0;
          }
          if (n = n || e < 0 || m[d + 1] !== void 0 || (s < 0 ? l : l % wt(10, o - s - 1)), u = t < 4 ? (c || n) && (t == 0 || t == (i.s < 0 ? 3 : 2)) : c > 5 || c == 5 && (t == 4 || n || t == 6 && (r > 0 ? s > 0 ? l / wt(10, o - s) : 0 : m[d - 1]) % 10 & 1 || t == (i.s < 0 ? 8 : 7)), e < 1 || !m[0])
            return m.length = 0, u ? (e -= i.e + 1, m[0] = wt(10, (ge - e % ge) % ge), i.e = -e || 0) : m[0] = i.e = 0, i;
          if (r == 0 ? (m.length = d, a = 1, d--) : (m.length = d + 1, a = wt(10, ge - r), m[d] = s > 0 ? (l / wt(10, o - s) % wt(10, s) | 0) * a : 0), u)
            for (; ; )
              if (d == 0) {
                for (r = 1, s = m[0]; s >= 10; s /= 10)
                  r++;
                for (s = m[0] += a, a = 1; s >= 10; s /= 10)
                  a++;
                r != a && (i.e++, m[0] == Sn && (m[0] = 1));
                break;
              } else {
                if (m[d] += a, m[d] != Sn)
                  break;
                m[d--] = 0, a = 1;
              }
          for (r = m.length; m[--r] === 0; )
            m.pop();
        }
      return we && (i.e > p.maxE ? (i.d = null, i.e = NaN) : i.e < p.minE && (i.e = 0, i.d = [0])), i;
    }
    function Fn(i, e, t) {
      if (!i.isFinite())
        return em(i);
      var n, o = i.e, r = Nt(i.d), s = r.length;
      return e ? (t && (n = t - s) > 0 ? r = r.charAt(0) + "." + r.slice(1) + lo(n) : s > 1 && (r = r.charAt(0) + "." + r.slice(1)), r = r + (i.e < 0 ? "e" : "e+") + i.e) : o < 0 ? (r = "0." + lo(-o - 1) + r, t && (n = t - s) > 0 && (r += lo(n))) : o >= s ? (r += lo(o + 1 - s), t && (n = t - o - 1) > 0 && (r = r + "." + lo(n))) : ((n = o + 1) < s && (r = r.slice(0, n) + "." + r.slice(n)), t && (n = t - s) > 0 && (o + 1 === s && (r += "."), r += lo(n))), r;
    }
    function ms(i, e) {
      var t = i[0];
      for (e *= ge; t >= 10; t /= 10)
        e++;
      return e;
    }
    function cs(i, e, t) {
      if (e > Np)
        throw we = true, t && (i.precision = t), Error(Yl);
      return de(new i(as), e, 1, true);
    }
    function xn(i, e, t) {
      if (e > uu)
        throw Error(Yl);
      return de(new i(us), e, t, true);
    }
    function Zl(i) {
      var e = i.length - 1, t = e * ge + 1;
      if (e = i[e], e) {
        for (; e % 10 == 0; e /= 10)
          t--;
        for (e = i[0]; e >= 10; e /= 10)
          t++;
      }
      return t;
    }
    function lo(i) {
      for (var e = ""; i--; )
        e += "0";
      return e;
    }
    function $l(i, e, t, n) {
      var o, r = new i(1), s = Math.ceil(n / ge + 4);
      for (we = false; ; ) {
        if (t % 2 && (r = r.times(e), Gl(r.d, s) && (o = true)), t = _t(t / 2), t === 0) {
          t = r.d.length - 1, o && r.d[t] === 0 && ++r.d[t];
          break;
        }
        e = e.times(e), Gl(e.d, s);
      }
      return we = true, r;
    }
    function Ul(i) {
      return i.d[i.d.length - 1] & 1;
    }
    function Jl(i, e, t) {
      for (var n, o = new i(e[0]), r = 0; ++r < e.length; )
        if (n = new i(e[r]), n.s)
          o[t](n) && (o = n);
        else {
          o = n;
          break;
        }
      return o;
    }
    function cu(i, e) {
      var t, n, o, r, s, a, c, u = 0, l = 0, m = 0, d = i.constructor, p = d.rounding, f = d.precision;
      if (!i.d || !i.d[0] || i.e > 17)
        return new d(i.d ? i.d[0] ? i.s < 0 ? 0 : 1 / 0 : 1 : i.s ? i.s < 0 ? 0 : i : 0 / 0);
      for (e == null ? (we = false, c = f) : c = e, a = new d(0.03125); i.e > -2; )
        i = i.times(a), m += 5;
      for (n = Math.log(wt(2, m)) / Math.LN10 * 2 + 5 | 0, c += n, t = r = s = new d(1), d.precision = c; ; ) {
        if (r = de(r.times(i), c, 1), t = t.times(++l), a = s.plus(Ye(r, t, c, 1)), Nt(a.d).slice(0, c) === Nt(s.d).slice(0, c)) {
          for (o = m; o--; )
            s = de(s.times(s), c, 1);
          if (e == null)
            if (u < 3 && zi(s.d, c - n, p, u))
              d.precision = c += 10, t = r = a = new d(1), l = 0, u++;
            else
              return de(s, d.precision = f, p, we = true);
          else
            return d.precision = f, s;
        }
        s = a;
      }
    }
    function mo(i, e) {
      var t, n, o, r, s, a, c, u, l, m, d, p = 1, f = 10, y = i, b = y.d, g = y.constructor, A = g.rounding, k = g.precision;
      if (y.s < 0 || !b || !b[0] || !y.e && b[0] == 1 && b.length == 1)
        return new g(b && !b[0] ? -1 / 0 : y.s != 1 ? NaN : b ? 0 : y);
      if (e == null ? (we = false, l = k) : l = e, g.precision = l += f, t = Nt(b), n = t.charAt(0), Math.abs(r = y.e) < 15e14) {
        for (; n < 7 && n != 1 || n == 1 && t.charAt(1) > 3; )
          y = y.times(i), t = Nt(y.d), n = t.charAt(0), p++;
        r = y.e, n > 1 ? (y = new g("0." + t), r++) : y = new g(n + "." + t.slice(1));
      } else
        return u = cs(g, l + 2, k).times(r + ""), y = mo(new g(n + "." + t.slice(1)), l - f).plus(u), g.precision = k, e == null ? de(y, k, A, we = true) : y;
      for (m = y, c = s = y = Ye(y.minus(1), y.plus(1), l, 1), d = de(y.times(y), l, 1), o = 3; ; ) {
        if (s = de(s.times(d), l, 1), u = c.plus(Ye(s, new g(o), l, 1)), Nt(u.d).slice(0, l) === Nt(c.d).slice(0, l))
          if (c = c.times(2), r !== 0 && (c = c.plus(cs(g, l + 2, k).times(r + ""))), c = Ye(c, new g(p), l, 1), e == null)
            if (zi(c.d, l - f, A, a))
              g.precision = l += f, u = s = y = Ye(m.minus(1), m.plus(1), l, 1), d = de(y.times(y), l, 1), o = a = 1;
            else
              return de(c, g.precision = k, A, we = true);
          else
            return g.precision = k, c;
        c = u, o += 2;
      }
    }
    function em(i) {
      return String(i.s * i.s / 0);
    }
    function lu(i, e) {
      var t, n, o;
      for ((t = e.indexOf(".")) > -1 && (e = e.replace(".", "")), (n = e.search(/e/i)) > 0 ? (t < 0 && (t = n), t += +e.slice(n + 1), e = e.substring(0, n)) : t < 0 && (t = e.length), n = 0; e.charCodeAt(n) === 48; n++)
        ;
      for (o = e.length; e.charCodeAt(o - 1) === 48; --o)
        ;
      if (e = e.slice(n, o), e) {
        if (o -= n, i.e = t = t - n - 1, i.d = [], n = (t + 1) % ge, t < 0 && (n += ge), n < o) {
          for (n && i.d.push(+e.slice(0, n)), o -= ge; n < o; )
            i.d.push(+e.slice(n, n += ge));
          e = e.slice(n), n = ge - e.length;
        } else
          n -= o;
        for (; n--; )
          e += "0";
        i.d.push(+e), we && (i.e > i.constructor.maxE ? (i.d = null, i.e = NaN) : i.e < i.constructor.minE && (i.e = 0, i.d = [0]));
      } else
        i.e = 0, i.d = [0];
      return i;
    }
    function Mp(i, e) {
      var t, n, o, r, s, a, c, u, l;
      if (e.indexOf("_") > -1) {
        if (e = e.replace(/(\d)_(?=\d)/g, "$1"), jl.test(e))
          return lu(i, e);
      } else if (e === "Infinity" || e === "NaN")
        return +e || (i.s = NaN), i.e = NaN, i.d = null, i;
      if (Cp.test(e))
        t = 16, e = e.toLowerCase();
      else if (Kp.test(e))
        t = 2;
      else if (Rp.test(e))
        t = 8;
      else
        throw Error(po + e);
      for (r = e.search(/p/i), r > 0 ? (c = +e.slice(r + 1), e = e.substring(2, r)) : e = e.slice(2), r = e.indexOf("."), s = r >= 0, n = i.constructor, s && (e = e.replace(".", ""), a = e.length, r = a - r, o = $l(n, new n(t), r, r * 2)), u = ss(e, t, Sn), l = u.length - 1, r = l; u[r] === 0; --r)
        u.pop();
      return r < 0 ? new n(i.s * 0) : (i.e = ms(u, l), i.d = u, we = false, s && (i = Ye(i, o, a * 4)), c && (i = i.times(Math.abs(c) < 54 ? wt(2, c) : Yi.pow(2, c))), we = true, i);
    }
    function vp(i, e) {
      var t, n = e.d.length;
      if (n < 3)
        return e.isZero() ? e : ei(i, 2, e, e);
      t = 1.4 * Math.sqrt(n), t = t > 16 ? 16 : t | 0, e = e.times(1 / ds(5, t)), e = ei(i, 2, e, e);
      for (var o, r = new i(5), s = new i(16), a = new i(20); t--; )
        o = e.times(e), e = e.times(r.plus(o.times(s.times(o).minus(a))));
      return e;
    }
    function ei(i, e, t, n, o) {
      var r, s, a, c, u = 1, l = i.precision, m = Math.ceil(l / ge);
      for (we = false, c = t.times(t), a = new i(n); ; ) {
        if (s = Ye(a.times(c), new i(e++ * e++), l, 1), a = o ? n.plus(s) : n.minus(s), n = Ye(s.times(c), new i(e++ * e++), l, 1), s = a.plus(n), s.d[m] !== void 0) {
          for (r = m; s.d[r] === a.d[r] && r--; )
            ;
          if (r == -1)
            break;
        }
        r = a, a = n, n = s, s = r, u++;
      }
      return we = true, s.d.length = m + 1, s;
    }
    function ds(i, e) {
      for (var t = i; --e; )
        t *= i;
      return t;
    }
    function tm(i, e) {
      var t, n = e.s < 0, o = xn(i, i.precision, 1), r = o.times(0.5);
      if (e = e.abs(), e.lte(r))
        return Qn = n ? 4 : 1, e;
      if (t = e.divToInt(o), t.isZero())
        Qn = n ? 3 : 2;
      else {
        if (e = e.minus(t.times(o)), e.lte(r))
          return Qn = Ul(t) ? n ? 2 : 3 : n ? 4 : 1, e;
        Qn = Ul(t) ? n ? 1 : 4 : n ? 3 : 2;
      }
      return e.minus(o).abs();
    }
    function mu(i, e, t, n) {
      var o, r, s, a, c, u, l, m, d, p = i.constructor, f = t !== void 0;
      if (f ? (nn(t, 1, fo), n === void 0 ? n = p.rounding : nn(n, 0, 8)) : (t = p.precision, n = p.rounding), !i.isFinite())
        l = em(i);
      else {
        for (l = Fn(i), s = l.indexOf("."), f ? (o = 2, e == 16 ? t = t * 4 - 3 : e == 8 && (t = t * 3 - 2)) : o = e, s >= 0 && (l = l.replace(".", ""), d = new p(1), d.e = l.length - s, d.d = ss(Fn(d), 10, o), d.e = d.d.length), m = ss(l, 10, o), r = c = m.length; m[--c] == 0; )
          m.pop();
        if (!m[0])
          l = f ? "0p+0" : "0";
        else {
          if (s < 0 ? r-- : (i = new p(i), i.d = m, i.e = r, i = Ye(i, d, t, n, 0, o), m = i.d, r = i.e, u = zl), s = m[t], a = o / 2, u = u || m[t + 1] !== void 0, u = n < 4 ? (s !== void 0 || u) && (n === 0 || n === (i.s < 0 ? 3 : 2)) : s > a || s === a && (n === 4 || u || n === 6 && m[t - 1] & 1 || n === (i.s < 0 ? 8 : 7)), m.length = t, u)
            for (; ++m[--t] > o - 1; )
              m[t] = 0, t || (++r, m.unshift(1));
          for (c = m.length; !m[c - 1]; --c)
            ;
          for (s = 0, l = ""; s < c; s++)
            l += su.charAt(m[s]);
          if (f) {
            if (c > 1)
              if (e == 16 || e == 8) {
                for (s = e == 16 ? 4 : 3, --c; c % s; c++)
                  l += "0";
                for (m = ss(l, o, e), c = m.length; !m[c - 1]; --c)
                  ;
                for (s = 1, l = "1."; s < c; s++)
                  l += su.charAt(m[s]);
              } else
                l = l.charAt(0) + "." + l.slice(1);
            l = l + (r < 0 ? "p" : "p+") + r;
          } else if (r < 0) {
            for (; ++r; )
              l = "0" + l;
            l = "0." + l;
          } else if (++r > c)
            for (r -= c; r--; )
              l += "0";
          else
            r < c && (l = l.slice(0, r) + "." + l.slice(r));
        }
        l = (e == 16 ? "0x" : e == 2 ? "0b" : e == 8 ? "0o" : "") + l;
      }
      return i.s < 0 ? "-" + l : l;
    }
    function Gl(i, e) {
      if (i.length > e)
        return i.length = e, true;
    }
    function Fp(i) {
      return new this(i).abs();
    }
    function Vp(i) {
      return new this(i).acos();
    }
    function _p(i) {
      return new this(i).acosh();
    }
    function Ep(i, e) {
      return new this(i).plus(e);
    }
    function Wp(i) {
      return new this(i).asin();
    }
    function Dp(i) {
      return new this(i).asinh();
    }
    function qp(i) {
      return new this(i).atan();
    }
    function Up(i) {
      return new this(i).atanh();
    }
    function Gp(i, e) {
      i = new this(i), e = new this(e);
      var t, n = this.precision, o = this.rounding, r = n + 4;
      return !i.s || !e.s ? t = new this(NaN) : !i.d && !e.d ? (t = xn(this, r, 1).times(e.s > 0 ? 0.25 : 0.75), t.s = i.s) : !e.d || i.isZero() ? (t = e.s < 0 ? xn(this, n, o) : new this(0), t.s = i.s) : !i.d || e.isZero() ? (t = xn(this, r, 1).times(0.5), t.s = i.s) : e.s < 0 ? (this.precision = r, this.rounding = 1, t = this.atan(Ye(i, e, r, 1)), e = xn(this, r, 1), this.precision = n, this.rounding = o, t = i.s < 0 ? t.minus(e) : t.plus(e)) : t = this.atan(Ye(i, e, r, 1)), t;
    }
    function Xp(i) {
      return new this(i).cbrt();
    }
    function zp(i) {
      return de(i = new this(i), i.e + 1, 2);
    }
    function Yp(i, e, t) {
      return new this(i).clamp(e, t);
    }
    function Hp(i) {
      if (!i || typeof i != "object")
        throw Error(ls + "Object expected");
      var e, t, n, o = i.defaults === true, r = ["precision", 1, fo, "rounding", 0, 8, "toExpNeg", -Jo, 0, "toExpPos", 0, Jo, "maxE", 0, Jo, "minE", -Jo, 0, "modulo", 0, 9];
      for (e = 0; e < r.length; e += 3)
        if (t = r[e], o && (this[t] = au[t]), (n = i[t]) !== void 0)
          if (_t(n) === n && n >= r[e + 1] && n <= r[e + 2])
            this[t] = n;
          else
            throw Error(po + t + ": " + n);
      if (t = "crypto", o && (this[t] = au[t]), (n = i[t]) !== void 0)
        if (n === true || n === false || n === 0 || n === 1)
          if (n)
            if (typeof crypto < "u" && crypto && (crypto.getRandomValues || crypto.randomBytes))
              this[t] = true;
            else
              throw Error(Hl);
          else
            this[t] = false;
        else
          throw Error(po + t + ": " + n);
      return this;
    }
    function Qp(i) {
      return new this(i).cos();
    }
    function jp(i) {
      return new this(i).cosh();
    }
    function nm(i) {
      var e, t, n;
      function o(r) {
        var s, a, c, u = this;
        if (!(u instanceof o))
          return new o(r);
        if (u.constructor = o, Xl(r)) {
          u.s = r.s, we ? !r.d || r.e > o.maxE ? (u.e = NaN, u.d = null) : r.e < o.minE ? (u.e = 0, u.d = [0]) : (u.e = r.e, u.d = r.d.slice()) : (u.e = r.e, u.d = r.d ? r.d.slice() : r.d);
          return;
        }
        if (c = typeof r, c === "number") {
          if (r === 0) {
            u.s = 1 / r < 0 ? -1 : 1, u.e = 0, u.d = [0];
            return;
          }
          if (r < 0 ? (r = -r, u.s = -1) : u.s = 1, r === ~~r && r < 1e7) {
            for (s = 0, a = r; a >= 10; a /= 10)
              s++;
            we ? s > o.maxE ? (u.e = NaN, u.d = null) : s < o.minE ? (u.e = 0, u.d = [0]) : (u.e = s, u.d = [r]) : (u.e = s, u.d = [r]);
            return;
          } else if (r * 0 !== 0) {
            r || (u.s = NaN), u.e = NaN, u.d = null;
            return;
          }
          return lu(u, r.toString());
        } else if (c !== "string")
          throw Error(po + r);
        return (a = r.charCodeAt(0)) === 45 ? (r = r.slice(1), u.s = -1) : (a === 43 && (r = r.slice(1)), u.s = 1), jl.test(r) ? lu(u, r) : Mp(u, r);
      }
      if (o.prototype = z, o.ROUND_UP = 0, o.ROUND_DOWN = 1, o.ROUND_CEIL = 2, o.ROUND_FLOOR = 3, o.ROUND_HALF_UP = 4, o.ROUND_HALF_DOWN = 5, o.ROUND_HALF_EVEN = 6, o.ROUND_HALF_CEIL = 7, o.ROUND_HALF_FLOOR = 8, o.EUCLID = 9, o.config = o.set = Hp, o.clone = nm, o.isDecimal = Xl, o.abs = Fp, o.acos = Vp, o.acosh = _p, o.add = Ep, o.asin = Wp, o.asinh = Dp, o.atan = qp, o.atanh = Up, o.atan2 = Gp, o.cbrt = Xp, o.ceil = zp, o.clamp = Yp, o.cos = Qp, o.cosh = jp, o.div = Zp, o.exp = $p, o.floor = Jp, o.hypot = ef, o.ln = tf, o.log = nf, o.log10 = rf, o.log2 = of, o.max = sf, o.min = af, o.mod = uf, o.mul = cf, o.pow = lf, o.random = mf, o.round = df, o.sign = pf, o.sin = ff, o.sinh = yf, o.sqrt = bf, o.sub = gf, o.sum = Pf, o.tan = Af, o.tanh = wf, o.trunc = kf, i === void 0 && (i = {}), i && i.defaults !== true)
        for (n = ["precision", "rounding", "toExpNeg", "toExpPos", "maxE", "minE", "modulo", "crypto"], e = 0; e < n.length; )
          i.hasOwnProperty(t = n[e++]) || (i[t] = this[t]);
      return o.config(i), o;
    }
    function Zp(i, e) {
      return new this(i).div(e);
    }
    function $p(i) {
      return new this(i).exp();
    }
    function Jp(i) {
      return de(i = new this(i), i.e + 1, 3);
    }
    function ef() {
      var i, e, t = new this(0);
      for (we = false, i = 0; i < arguments.length; )
        if (e = new this(arguments[i++]), e.d)
          t.d && (t = t.plus(e.times(e)));
        else {
          if (e.s)
            return we = true, new this(1 / 0);
          t = e;
        }
      return we = true, t.sqrt();
    }
    function Xl(i) {
      return i instanceof Yi || i && i.toStringTag === Ql || false;
    }
    function tf(i) {
      return new this(i).ln();
    }
    function nf(i, e) {
      return new this(i).log(e);
    }
    function of(i) {
      return new this(i).log(2);
    }
    function rf(i) {
      return new this(i).log(10);
    }
    function sf() {
      return Jl(this, arguments, "lt");
    }
    function af() {
      return Jl(this, arguments, "gt");
    }
    function uf(i, e) {
      return new this(i).mod(e);
    }
    function cf(i, e) {
      return new this(i).mul(e);
    }
    function lf(i, e) {
      return new this(i).pow(e);
    }
    function mf(i) {
      var e, t, n, o, r = 0, s = new this(1), a = [];
      if (i === void 0 ? i = this.precision : nn(i, 1, fo), n = Math.ceil(i / ge), this.crypto)
        if (crypto.getRandomValues)
          for (e = crypto.getRandomValues(new Uint32Array(n)); r < n; )
            o = e[r], o >= 429e7 ? e[r] = crypto.getRandomValues(new Uint32Array(1))[0] : a[r++] = o % 1e7;
        else if (crypto.randomBytes) {
          for (e = crypto.randomBytes(n *= 4); r < n; )
            o = e[r] + (e[r + 1] << 8) + (e[r + 2] << 16) + ((e[r + 3] & 127) << 24), o >= 214e7 ? crypto.randomBytes(4).copy(e, r) : (a.push(o % 1e7), r += 4);
          r = n / 4;
        } else
          throw Error(Hl);
      else
        for (; r < n; )
          a[r++] = Math.random() * 1e7 | 0;
      for (n = a[--r], i %= ge, n && i && (o = wt(10, ge - i), a[r] = (n / o | 0) * o); a[r] === 0; r--)
        a.pop();
      if (r < 0)
        t = 0, a = [0];
      else {
        for (t = -1; a[0] === 0; t -= ge)
          a.shift();
        for (n = 1, o = a[0]; o >= 10; o /= 10)
          n++;
        n < ge && (t -= ge - n);
      }
      return s.e = t, s.d = a, s;
    }
    function df(i) {
      return de(i = new this(i), i.e + 1, this.rounding);
    }
    function pf(i) {
      return i = new this(i), i.d ? i.d[0] ? i.s : 0 * i.s : i.s || NaN;
    }
    function ff(i) {
      return new this(i).sin();
    }
    function yf(i) {
      return new this(i).sinh();
    }
    function bf(i) {
      return new this(i).sqrt();
    }
    function gf(i, e) {
      return new this(i).sub(e);
    }
    function Pf() {
      var i = 0, e = arguments, t = new this(e[i]);
      for (we = false; t.s && ++i < e.length; )
        t = t.plus(e[i]);
      return we = true, de(t, this.precision, this.rounding);
    }
    function Af(i) {
      return new this(i).tan();
    }
    function wf(i) {
      return new this(i).tanh();
    }
    function kf(i) {
      return de(i = new this(i), i.e + 1, 1);
    }
    z[Symbol.for("nodejs.util.inspect.custom")] = z.toString;
    z[Symbol.toStringTag] = "Decimal";
    var Yi = z.constructor = nm(au);
    as = new Yi(as);
    us = new Yi(us);
    var O = Yi;
    var am = Ae(require_big());
    var jn = Ae(require_bn());
    var om = Ae(require_toFormat());
    var hf = om.default;
    var Hi = hf;
    var Qi = Ae(require_big());
    var rm = Ae(require_bn());
    var sm = Ae(require_decimal2());
    var ti = Ae(require_bn());
    var ps = ((n) => (n[n.ROUND_DOWN = 0] = "ROUND_DOWN", n[n.ROUND_HALF_UP = 1] = "ROUND_HALF_UP", n[n.ROUND_UP = 2] = "ROUND_UP", n))(ps || {});
    var im = 9007199254740991;
    function oe(i) {
      let e = xe("Raydium_parseBigNumberish");
      if (i instanceof ti.default)
        return i;
      if (typeof i == "string") {
        if (i.match(/^-?[0-9]+$/))
          return new ti.default(i);
        e.logWithError(`invalid BigNumberish string: ${i}`);
      }
      return typeof i == "number" ? (i % 1 && e.logWithError(`BigNumberish number underflow: ${i}`), (i >= im || i <= -im) && e.logWithError(`BigNumberish number overflow: ${i}`), new ti.default(String(i))) : typeof i == "bigint" ? new ti.default(i.toString()) : (e.error(`invalid BigNumberish value: ${i}`), new ti.default(0));
    }
    var fs = xe("module/fraction");
    var du = Hi(Qi.default);
    var ji = Hi(sm.default);
    var Tf = { [0]: ji.ROUND_DOWN, [1]: ji.ROUND_HALF_UP, [2]: ji.ROUND_UP };
    var If = { [0]: Qi.default.roundDown, [1]: Qi.default.roundHalfUp, [2]: Qi.default.roundUp };
    var ke = class {
      constructor(e, t = new rm.default(1)) {
        this.numerator = oe(e), this.denominator = oe(t);
      }
      get quotient() {
        return this.numerator.div(this.denominator);
      }
      invert() {
        return new ke(this.denominator, this.numerator);
      }
      add(e) {
        let t = e instanceof ke ? e : new ke(oe(e));
        return this.denominator.eq(t.denominator) ? new ke(this.numerator.add(t.numerator), this.denominator) : new ke(this.numerator.mul(t.denominator).add(t.numerator.mul(this.denominator)), this.denominator.mul(t.denominator));
      }
      sub(e) {
        let t = e instanceof ke ? e : new ke(oe(e));
        return this.denominator.eq(t.denominator) ? new ke(this.numerator.sub(t.numerator), this.denominator) : new ke(this.numerator.mul(t.denominator).sub(t.numerator.mul(this.denominator)), this.denominator.mul(t.denominator));
      }
      mul(e) {
        let t = e instanceof ke ? e : new ke(oe(e));
        return new ke(this.numerator.mul(t.numerator), this.denominator.mul(t.denominator));
      }
      div(e) {
        let t = e instanceof ke ? e : new ke(oe(e));
        return new ke(this.numerator.mul(t.denominator), this.denominator.mul(t.numerator));
      }
      toSignificant(e, t = { groupSeparator: "" }, n = 1) {
        Number.isInteger(e) || fs.logWithError(`${e} is not an integer.`), e <= 0 && fs.logWithError(`${e} is not positive.`), ji.set({ precision: e + 1, rounding: Tf[n] });
        let o = new ji(this.numerator.toString()).div(this.denominator.toString()).toSignificantDigits(e);
        return o.toFormat(o.decimalPlaces(), t);
      }
      toFixed(e, t = { groupSeparator: "" }, n = 1) {
        return Number.isInteger(e) || fs.logWithError(`${e} is not an integer.`), e < 0 && fs.logWithError(`${e} is negative.`), du.DP = e, du.RM = If[n] || 1, new du(this.numerator.toString()).div(this.denominator.toString()).toFormat(e, t);
      }
      isZero() {
        return this.numerator.isZero();
      }
    };
    var Bf = xe("Raydium_amount");
    var ys = Hi(am.default);
    function pu(i, e) {
      let t = "0", n = "0";
      if (i.includes(".")) {
        let o = i.split(".");
        o.length === 2 ? ([t, n] = o, n = n.padEnd(e, "0")) : Bf.logWithError(`invalid number string, num: ${i}`);
      } else
        t = i;
      return [t, n.slice(0, e) || n];
    }
    var ve = class extends ke {
      constructor(t, n, o = true, r) {
        let s = new jn.default(0), a = bo.pow(new jn.default(t.decimals));
        if (o)
          s = oe(n);
        else {
          let c = new jn.default(0), u = new jn.default(0);
          if (typeof n == "string" || typeof n == "number" || typeof n == "bigint") {
            let [l, m] = pu(n.toString(), t.decimals);
            c = oe(l), u = oe(m);
          }
          c = c.mul(a), s = c.add(u);
        }
        super(s, a);
        this.logger = xe(r || "TokenAmount"), this.token = t;
      }
      get raw() {
        return this.numerator;
      }
      isZero() {
        return this.raw.isZero();
      }
      gt(t) {
        return this.token.equals(t.token) || this.logger.logWithError("gt token not equals"), this.raw.gt(t.raw);
      }
      lt(t) {
        return this.token.equals(t.token) || this.logger.logWithError("lt token not equals"), this.raw.lt(t.raw);
      }
      add(t) {
        return this.token.equals(t.token) || this.logger.logWithError("add token not equals"), new ve(this.token, this.raw.add(t.raw));
      }
      subtract(t) {
        return this.token.equals(t.token) || this.logger.logWithError("sub token not equals"), new ve(this.token, this.raw.sub(t.raw));
      }
      toSignificant(t = this.token.decimals, n, o = 0) {
        return super.toSignificant(t, n, o);
      }
      toFixed(t = this.token.decimals, n, o = 0) {
        return t > this.token.decimals && this.logger.logWithError("decimals overflow"), super.toFixed(t, n, o);
      }
      toExact(t = { groupSeparator: "" }) {
        return ys.DP = this.token.decimals, new ys(this.numerator.toString()).div(this.denominator.toString()).toFormat(t);
      }
    };
    var yo = class extends ke {
      constructor(t, n, o = true, r) {
        let s = new jn.default(0), a = bo.pow(new jn.default(t.decimals));
        if (o)
          s = oe(n);
        else {
          let c = new jn.default(0), u = new jn.default(0);
          if (typeof n == "string" || typeof n == "number" || typeof n == "bigint") {
            let [l, m] = pu(n.toString(), t.decimals);
            c = oe(l), u = oe(m);
          }
          c = c.mul(a), s = c.add(u);
        }
        super(s, a);
        this.logger = xe(r || "TokenAmount"), this.currency = t;
      }
      get raw() {
        return this.numerator;
      }
      isZero() {
        return this.raw.isZero();
      }
      gt(t) {
        return this.currency.equals(t.currency) || this.logger.logWithError("gt currency not equals"), this.raw.gt(t.raw);
      }
      lt(t) {
        return this.currency.equals(t.currency) || this.logger.logWithError("lt currency not equals"), this.raw.lt(t.raw);
      }
      add(t) {
        return this.currency.equals(t.currency) || this.logger.logWithError("add currency not equals"), new yo(this.currency, this.raw.add(t.raw));
      }
      sub(t) {
        return this.currency.equals(t.currency) || this.logger.logWithError("sub currency not equals"), new yo(this.currency, this.raw.sub(t.raw));
      }
      toSignificant(t = this.currency.decimals, n, o = 0) {
        return super.toSignificant(t, n, o);
      }
      toFixed(t = this.currency.decimals, n, o = 0) {
        return t > this.currency.decimals && this.logger.logWithError("decimals overflow"), super.toFixed(t, n, o);
      }
      toExact(t = { groupSeparator: "" }) {
        return ys.DP = this.currency.decimals, new ys(this.numerator.toString()).div(this.denominator.toString()).toFormat(t);
      }
    };
    var um = require("@solana/web3.js");
    var fu = require_cjs4();
    var Kn = { chainId: 101, address: um.PublicKey.default.toBase58(), programId: fu.TOKEN_PROGRAM_ID.toBase58(), decimals: 9, symbol: "SOL", name: "solana", logoURI: "https://img-v1.raydium.io/icon/So11111111111111111111111111111111111111112.png", tags: [], priority: 2, type: "raydium", extensions: { coingeckoId: "solana" } };
    var kt = { chainId: 101, address: "So11111111111111111111111111111111111111112", programId: fu.TOKEN_PROGRAM_ID.toBase58(), decimals: 9, symbol: "WSOL", name: "Wrapped SOL", logoURI: "https://img-v1.raydium.io/icon/So11111111111111111111111111111111111111112.png", tags: [], priority: 2, type: "raydium", extensions: { coingeckoId: "solana" } };
    var ws = require("@solana/web3.js");
    var Ge = require("@solana/web3.js");
    var cm = require_cjs4();
    function w({ pubkey: i, isSigner: e = false, isWritable: t = true }) {
      return { pubkey: i, isWritable: t, isSigner: e };
    }
    var bs = [w({ pubkey: cm.TOKEN_PROGRAM_ID, isWritable: false }), w({ pubkey: Ge.SystemProgram.programId, isWritable: false }), w({ pubkey: Ge.SYSVAR_RENT_PUBKEY, isWritable: false })];
    function gs({ publicKey: i, transformSol: e }) {
      let t = Ps(i.toString());
      if (t instanceof Ge.PublicKey)
        return e && t.equals(ht) ? ee : t;
      if (e && t.toString() === ht.toBase58())
        return ee;
      if (typeof t == "string") {
        if (t === Ge.PublicKey.default.toBase58())
          return Ge.PublicKey.default;
        try {
          return new Ge.PublicKey(t);
        } catch {
          throw new Error("invalid public key");
        }
      }
      throw new Error("invalid public key");
    }
    function Ps(i) {
      try {
        return new Ge.PublicKey(i);
      } catch {
        return i;
      }
    }
    var Zi = new Ge.PublicKey("MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr");
    var Cn = new Ge.PublicKey("MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr");
    var at = new Ge.PublicKey("SysvarRent111111111111111111111111111111111");
    var As = new Ge.PublicKey("SysvarC1ock11111111111111111111111111111111");
    var cn = new Ge.PublicKey("metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s");
    var $i = new Ge.PublicKey("Sysvar1nstructions1111111111111111111111111");
    var Ji = Ge.SystemProgram.programId;
    var xf = new Ge.PublicKey("4k3Dyjzvzp8eMZWUXbBCjEvwSkkk59S5iCNLY3QrkX6R");
    var Sf = new Ge.PublicKey("Ea5SjE2Y6yvCeW5dYTn7PYMuW5ikXkvbGdcmSnXeaLjS");
    var Kf = new Ge.PublicKey("SRMuApVNdxXokk5GT7XD5cUUgXMBCoAz2LHeuAoKWRt");
    var Cf = new Ge.PublicKey("EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v");
    var Rf = new Ge.PublicKey("Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB");
    var Lf = new Ge.PublicKey("mSoLzYCxHdYgdzU16g5QSh3i5K3z3KZK7ytfqcJm7So");
    var Nf = new Ge.PublicKey("7dHbWXmci3dT8UFYWYZweBLXgycu7Y3iL6trKn1Y7ARj");
    var Of = new Ge.PublicKey("USDH1SM1ojwWUga67PGrgFWUHibbjqMvuMaDkRJTgkX");
    var Mf = new Ge.PublicKey("NRVwhjBQiUPYtfDT5zRBVJajzFQHaBUNtC7SNVvqRFa");
    var vf = new Ge.PublicKey("ANAxByE6G2WjFp7A4NqtWYXb3mgruyzZYg3spfxe6Lbo");
    var Ff = new Ge.PublicKey("7vfCXTUXx5WJV5JADk17DUJ4ksgau7utNKj4b963voxs");
    var ee = new Ge.PublicKey("So11111111111111111111111111111111111111112");
    var ht = Ge.PublicKey.default;
    function Lt(i) {
      return gs({ publicKey: i, transformSol: true });
    }
    var yu = class {
      constructor({ mint: e, decimals: t, symbol: n, name: o, skipMint: r = false, isToken2022: s = false }) {
        if (e === ht.toBase58() || e instanceof ws.PublicKey && ht.equals(e)) {
          this.decimals = kt.decimals, this.symbol = kt.symbol, this.name = kt.name, this.mint = new ws.PublicKey(kt.address), this.isToken2022 = false;
          return;
        }
        this.decimals = t, this.symbol = n || e.toString().substring(0, 6), this.name = o || e.toString().substring(0, 6), this.mint = r ? ws.PublicKey.default : gs({ publicKey: e }), this.isToken2022 = s;
      }
      equals(e) {
        return this === e ? true : this.mint.equals(e.mint);
      }
    };
    var De = yu;
    De.WSOL = new yu(U(E({}, kt), { mint: kt.address }));
    var bu = class {
      constructor({ decimals: e, symbol: t = "UNKNOWN", name: n = "UNKNOWN" }) {
        this.decimals = e, this.symbol = t, this.name = n;
      }
      equals(e) {
        return this === e;
      }
    };
    var ni = bu;
    ni.SOL = new bu(Kn);
    function Vf(i, e) {
      return i instanceof De && e instanceof De ? i.equals(e) : i instanceof De || e instanceof De ? false : i === e;
    }
    var lm = Ae(require_bn());
    var gu = new ke(new lm.default(100));
    var ot = class extends ke {
      toSignificant(e = 5, t, n) {
        return this.mul(gu).toSignificant(e, t, n);
      }
      toFixed(e = 2, t, n) {
        return this.mul(gu).toFixed(e, t, n);
      }
    };
    var _f = xe("Raydium_price");
    var Tt = class extends ke {
      constructor(t) {
        let { baseToken: n, quoteToken: o, numerator: r, denominator: s } = t;
        super(r, s);
        this.baseToken = n, this.quoteToken = o, this.scalar = new ke(ks(n.decimals), ks(o.decimals));
      }
      get raw() {
        return new ke(this.numerator, this.denominator);
      }
      get adjusted() {
        return super.mul(this.scalar);
      }
      invert() {
        return new Tt({ baseToken: this.quoteToken, quoteToken: this.baseToken, denominator: this.numerator, numerator: this.denominator });
      }
      mul(t) {
        this.quoteToken !== t.baseToken && _f.logWithError("mul token not equals");
        let n = super.mul(t);
        return new Tt({ baseToken: this.baseToken, quoteToken: t.quoteToken, denominator: n.denominator, numerator: n.numerator });
      }
      toSignificant(t = this.quoteToken.decimals, n, o) {
        return this.adjusted.toSignificant(t, n, o);
      }
      toFixed(t = this.quoteToken.decimals, n, o) {
        return this.adjusted.toFixed(t, n, o);
      }
    };
    function dt(i) {
      if (i instanceof ot)
        return new ke(i.numerator, i.denominator);
      if (i instanceof Tt)
        return i.adjusted;
      if (i instanceof ve)
        try {
          return dt(i.toExact());
        } catch {
          return new ke(ut);
        }
      if (i instanceof ke)
        return i;
      let e = String(i), t = go(e);
      return new ke(t.numerator, t.denominator);
    }
    function Ef(i) {
      var n;
      if (i instanceof ot)
        return { fr: new ke(i.numerator, i.denominator) };
      if (i instanceof Tt)
        return { fr: i.adjusted };
      if (i instanceof ve)
        return { fr: dt(i.toExact()), decimals: i.token.decimals };
      if (i instanceof ke)
        return { fr: i };
      let e = String(i), t = go(e);
      return { fr: new ke(t.numerator, t.denominator), decimals: (n = t.dec) == null ? void 0 : n.length };
    }
    function Wf(i, e) {
      if (i == null || e == null)
        return false;
      let t = dt(i), n = dt(e);
      return t.sub(n).numerator, t.sub(n).numerator.lt(ut);
    }
    function mm(i, e) {
      if (i == null || e == null)
        return false;
      let t = dt(i), n = dt(e);
      return t.sub(n).numerator.gt(ut);
    }
    function Df(i, e) {
      if (i == null || e == null)
        return false;
      let t = dt(i), n = dt(e);
      return t.sub(n).numerator.lte(ut);
    }
    function qf(i, e) {
      if (i == null || e == null)
        return false;
      let t = dt(i), n = dt(e);
      return t.sub(n).numerator.gte(ut);
    }
    function dm(i, e) {
      if (i == null || e == null)
        return false;
      let t = dt(i), n = dt(e);
      return t.sub(n).numerator.eq(ut);
    }
    function Uf(i, e) {
      if (i == null || e == null)
        return;
      let t = dt(i), n = dt(e);
      try {
        return t.div(n);
      } catch {
        return t;
      }
    }
    function Gf(i, e) {
      if (i == null || e == null)
        return;
      let t = dt(i), n = dt(e);
      return t.sub(n);
    }
    function Xf(i) {
      return i == null ? false : !dm(i, 0);
    }
    function zf(i, e) {
      return mm(e, i) ? e : i;
    }
    function hs(i, e) {
      if (i == null || e == null)
        return;
      let t = dt(i), n = dt(e);
      return t.mul(n);
    }
    function Yf(i, e) {
      if (i == null || e == null)
        return;
      let t = dt(i), n = dt(e);
      return t.add(n);
    }
    var ut = new it.default(0);
    var Au = new it.default(1);
    var Hf = new it.default(2);
    var Qf = new it.default(3);
    var jf = new it.default(5);
    var bo = new it.default(10);
    var Zf = new it.default(100);
    var $f = new it.default(1e3);
    var Jf = new it.default(1e4);
    function ks(i) {
      return bo.pow(oe(i));
    }
    function go(i) {
      var a;
      if (i === void 0)
        return { denominator: "1", numerator: "0" };
      if (i instanceof it.default)
        return { numerator: i.toString(), denominator: "1" };
      if (i instanceof ke)
        return { denominator: i.denominator.toString(), numerator: i.numerator.toString() };
      let e = String(i), [, t = "", n = "", o = ""] = (a = e.replace(",", "").match(/(-?)(\d*)\.?(\d*)/)) != null ? a : [], r = "1" + "0".repeat(o.length), s = t + (n === "0" ? "" : n) + o || "0";
      return { denominator: r, numerator: s, sign: t, int: n, dec: o };
    }
    function er(i, e) {
      let t = i.divmod(e);
      return t.mod.isZero() ? t.div : t.div.isNeg() ? t.div.isubn(1) : t.div.iaddn(1);
    }
    function pm(i) {
      var n;
      let [, e = "", t = ""] = (n = i.toFixed(2).match(/(-?)(\d*)\.?(\d*)/)) != null ? n : [];
      return `${e}${t}`;
    }
    function fm(i, e = 0) {
      return i instanceof it.default ? i : new it.default(pm(wu(i).mul(bo.pow(new it.default(String(e))))));
    }
    function wu(i) {
      if (i instanceof ot)
        return new ke(i.numerator, i.denominator);
      if (i instanceof Tt)
        return i.adjusted;
      if (i instanceof ve)
        try {
          return wu(i.toExact());
        } catch {
          return new ke(ut);
        }
      if (i instanceof ke)
        return i;
      let e = String(i), t = go(e);
      return new ke(t.numerator, t.denominator);
    }
    function oi(i, e, t) {
      return i.mul(e).add(t).sub(new it.default(1)).div(t);
    }
    function tr(i, e, t) {
      return i.mul(e).div(t);
    }
    function ey(i, e) {
      let { numerator: t, denominator: n } = go(i);
      return new ot(new it.default(t), new it.default(n).mul(e != null && e.alreadyDecimaled ? new it.default(100) : new it.default(1)));
    }
    function ty(i) {
      let { token: e, numberPrice: t, decimalDone: n } = i, o = new De({ mint: "", decimals: 6, symbol: "usd", name: "usd", skipMint: true }), { numerator: r, denominator: s } = go(t), a = n ? new it.default(r).mul(bo.pow(new it.default(e.decimals))) : r, c = new it.default(s).mul(bo.pow(new it.default(o.decimals)));
      return new Tt({ baseToken: o, denominator: c.toString(), quoteToken: new De(U(E({}, e), { skipMint: true, mint: "" })), numerator: a.toString() });
    }
    function Pu(i) {
      let e = new ni({ decimals: 6, symbol: "usd", name: "usd" }), t = fm(hs(i, 10 ** e.decimals));
      return new yo(e, t);
    }
    function ny(i, e) {
      return Pu(!e || !i ? 0 : hs(i, e));
    }
    function oy(i) {
      if (i == null)
        return;
      let { numerator: e, denominator: t } = go(i.toString());
      return new ke(e, t);
    }
    function iy(i) {
      return i instanceof O;
    }
    var ku = (i) => typeof i == "number";
    var hu = (i) => i ? new Date(i) : /* @__PURE__ */ new Date();
    var ym = (i) => hu(i).getTime();
    function Tu(i, e, t) {
      let n = ku(e) ? e * ((t == null ? void 0 : t.unit) === "s" ? 1e3 : 1) : e;
      return new Date(i).getTime() <= n;
    }
    function Iu(i, e, t) {
      let n = ku(e) ? e * ((t == null ? void 0 : t.unit) === "s" ? 1e3 : 1) : e;
      return new Date(i).getTime() > n;
    }
    function ry(i, e) {
      let n = ym(i) + (e.days ? e.days * 24 * 60 * 60 * 1e3 : 0) + (e.hours ? e.hours * 60 * 60 * 1e3 : 0) + (e.minutes ? e.minutes * 60 * 1e3 : 0) + (e.seconds ? e.seconds * 1e3 : 0) + (e.milliseconds ? e.milliseconds : 0);
      return hu(n);
    }
    function rs(i, e = 1, t = []) {
      let n = [...i];
      if (e <= 0)
        return t;
      for (; n.length; )
        t.push(n.splice(0, e));
      return t;
    }
    function sy(i, ...e) {
      return i.filter((t) => e.every((n) => n.includes(t)));
    }
    function ay(i, ...e) {
      return i.filter((t) => e.every((n) => !n.includes(t)));
    }
    function uy(i) {
      return [...new Set(i)];
    }
    var Pn = class {
      constructor(e) {
        this._owner = e;
      }
      get publicKey() {
        return Pn.isKeyPair(this._owner) ? this._owner.publicKey : this._owner;
      }
      get signer() {
        return Pn.isKeyPair(this._owner) ? this._owner : void 0;
      }
      get isKeyPair() {
        return Pn.isKeyPair(this._owner);
      }
      get isPublicKey() {
        return Pn.isPublicKey(this._owner);
      }
      static isKeyPair(e) {
        return e.secretKey !== void 0;
      }
      static isPublicKey(e) {
        return !Pn.isKeyPair(e);
      }
    };
    var Am = require("@solana/web3.js");
    var wm = require_cjs4();
    var gt = require("@solana/web3.js");
    var Vn = ((t) => (t[t.V0 = 0] = "V0", t[t.LEGACY = 1] = "LEGACY", t))(Vn || {});
    var X = { CreateAccount: "CreateAccount", InitAccount: "InitAccount", CreateATA: "CreateATA", CloseAccount: "CloseAccount", TransferAmount: "TransferAmount", InitMint: "InitMint", MintTo: "MintTo", InitMarket: "InitMarket", Util1216OwnerClaim: "Util1216OwnerClaim", SetComputeUnitPrice: "SetComputeUnitPrice", SetComputeUnitLimit: "SetComputeUnitLimit", ClmmCreatePool: "ClmmCreatePool", ClmmOpenPosition: "ClmmOpenPosition", ClmmIncreasePosition: "ClmmIncreasePosition", ClmmDecreasePosition: "ClmmDecreasePosition", ClmmClosePosition: "ClmmClosePosition", ClmmSwapBaseIn: "ClmmSwapBaseIn", ClmmSwapBaseOut: "ClmmSwapBaseOut", ClmmInitReward: "ClmmInitReward", ClmmSetReward: "ClmmSetReward", ClmmCollectReward: "ClmmCollectReward", ClmmLockPosition: "ClmmLockPosition", ClmmHarvestLockPosition: "ClmmHarvestLockPosition", AmmV4Swap: "AmmV4Swap", AmmV4AddLiquidity: "AmmV4AddLiquidity", AmmV4RemoveLiquidity: "AmmV4RemoveLiquidity", AmmV4SimulatePoolInfo: "AmmV4SimulatePoolInfo", AmmV4SwapBaseIn: "AmmV4SwapBaseIn", AmmV4SwapBaseOut: "AmmV4SwapBaseOut", AmmV4CreatePool: "AmmV4CreatePool", AmmV4InitPool: "AmmV4InitPool", AmmV5AddLiquidity: "AmmV5AddLiquidity", AmmV5RemoveLiquidity: "AmmV5RemoveLiquidity", AmmV5SimulatePoolInfo: "AmmV5SimulatePoolInfo", AmmV5SwapBaseIn: "AmmV5SwapBaseIn", AmmV5SwapBaseOut: "AmmV5SwapBaseOut", RouteSwap: "RouteSwap", RouteSwap1: "RouteSwap1", RouteSwap2: "RouteSwap2", FarmV3Deposit: "FarmV3Deposit", FarmV3Withdraw: "FarmV3Withdraw", FarmV3CreateLedger: "FarmV3CreateLedger", FarmV4Withdraw: "FarmV4Withdraw", FarmV5Deposit: "FarmV5Deposit", FarmV5Withdraw: "FarmV5Withdraw", FarmV5CreateLedger: "FarmV5CreateLedger", FarmV6Deposit: "FarmV6Deposit", FarmV6Withdraw: "FarmV6Withdraw", FarmV6Create: "FarmV6Create", FarmV6Restart: "FarmV6Restart", FarmV6CreatorAddReward: "FarmV6CreatorAddReward", FarmV6CreatorWithdraw: "FarmV6CreatorWithdraw", CpmmCreatePool: "CpmmCreatePool", CpmmAddLiquidity: "CpmmAddLiquidity", CpmmWithdrawLiquidity: "CpmmWithdrawLiquidity", CpmmSwapBaseIn: "CpmmSwapBaseIn", CpmmSwapBaseOut: "CpmmSwapBaseOut", CpmmLockLp: "CpmmLockLp", CpmmCollectLockFee: "CpmmCollectLockFee", TransferTip: "TransferTip" };
    var bm = require_cjs4();
    var Zn = xe("Raydium_txUtil");
    var Bu = 1644;
    function nr(i) {
      let e = [], t = [];
      return i.microLamports && (e.push(gt.ComputeBudgetProgram.setComputeUnitPrice({ microLamports: i.microLamports })), t.push(X.SetComputeUnitPrice)), i.units && (e.push(gt.ComputeBudgetProgram.setComputeUnitLimit({ units: i.units })), t.push(X.SetComputeUnitLimit)), { instructions: e, instructionTypes: t };
    }
    async function Mo(i, e) {
      var n, o;
      let t = e != null ? e : "confirmed";
      return (o = await ((n = i.getLatestBlockhash) == null ? void 0 : n.call(i, { commitment: t }))) == null ? void 0 : o.blockhash;
    }
    async function or(i, e) {
      return i.getSignatureStatuses([e]), new Promise((t, n) => {
        let o = setTimeout(n, 6e4);
        i.onSignature(e, (r) => {
          if (clearTimeout(o), !r.err) {
            t("");
            return;
          }
          n(Object.assign(r.err, { txId: e }));
        }, "confirmed");
      });
    }
    function ir(i, e) {
      i.length < 1 && Zn.logWithError(`no instructions provided: ${i.toString()}`), e.length < 1 && Zn.logWithError(`no signers provided:, ${e.toString()}`);
      let t = new gt.Transaction();
      t.recentBlockhash = "11111111111111111111111111111111", t.feePayer = e[0], t.add(...i);
      try {
        return Buffer.from(t.serialize({ verifySignatures: false })).toString("base64").length < Bu;
      } catch {
        return false;
      }
    }
    async function xu(i, e, t, n = true) {
      let o = new gt.PublicKey("RaydiumSimuLateTransaction11111111111111111"), r = [], s = new gt.Transaction();
      s.feePayer = o;
      for (let u of e)
        ir([...s.instructions, u], [o]) || (r.push(s), s = new gt.Transaction(), s.feePayer = o), s.add(u);
      s.instructions.length > 0 && r.push(s);
      let a = [];
      try {
        if (a = await gm(i, r, n), a.find((u) => u.err !== null))
          throw Error("rpc simulateTransaction error");
      } catch (u) {
        u instanceof Error && Zn.logWithError("failed to simulate for instructions", "RPC_ERROR", { message: u.message });
      }
      let c = [];
      for (let u of a)
        if (Zn.debug("simulate result:", u), u.logs) {
          let l = u.logs.filter((m) => m && m.includes(t));
          Zn.debug("filteredLog:", c), l.length || Zn.logWithError("simulate log not match keyword", "keyword", t), c.push(...l);
        }
      return c;
    }
    function Su(i, e) {
      let t = i.match(/{["\w:,]+}/g);
      return !t || t.length !== 1 ? Zn.logWithError(`simulate log fail to match json, keyword: ${e}`) : t[0];
    }
    function _n(i, e) {
      let n = new RegExp(`"${e}":(\\d+)`, "g").exec(i);
      return !n || n.length !== 2 ? Zn.logWithError(`simulate log fail to match key", key: ${e}`) : n[1];
    }
    function se(i, e) {
      let [t, n] = gt.PublicKey.findProgramAddressSync(i, e);
      return { publicKey: t, nonce: n };
    }
    async function gm(i, e, t) {
      let n = [];
      if (t) {
        let o = await i.getLatestBlockhash(), r = [];
        for (let u of e) {
          u.recentBlockhash = o.blockhash, u.lastValidBlockHeight = o.lastValidBlockHeight;
          let m = u._compile().serialize(), p = u._serialize(m).toString("base64");
          r.push(p);
        }
        let s = r.map((u) => {
          let l = i._buildArgs([u], void 0, "base64");
          return { methodName: "simulateTransaction", args: l };
        }), a = [], c = 20;
        for (let u = 0; u < Math.ceil(s.length / c); u++)
          a.push(s.slice(u * c, (u + 1) * c));
        n = await (await Promise.all(a.map(async (u) => (await i._rpcBatchRequest(u)).map((l) => l.result.value)))).flat();
      } else
        try {
          n = await Promise.all(e.map(async (o) => await (await i.simulateTransaction(o)).value));
        } catch (o) {
          o instanceof Error && Zn.logWithError("failed to get info for multiple accounts", "RPC_ERROR", { message: o.message });
        }
      return n;
    }
    function ii({ instructions: i, payer: e, signers: t }) {
      return ir(i, [e, ...t]);
    }
    function ri({ instructions: i, payer: e, lookupTableAddressAccount: t, recentBlockhash: n = gt.Keypair.generate().publicKey.toString() }) {
      let r = new gt.TransactionMessage({ payerKey: e, recentBlockhash: n, instructions: i }).compileToV0Message(Object.values(t != null ? t : {}));
      try {
        return Buffer.from(new gt.VersionedTransaction(r).serialize()).toString("base64").length < Bu;
      } catch {
        return false;
      }
    }
    var Ts = { time: 0, data: void 0 };
    async function cy(i) {
      if (!Ts.data || (Date.now() - Ts.time) / 1e3 > 30) {
        let e = await i.getEpochInfo();
        return Ts = { time: Date.now(), data: e }, e;
      } else
        return Ts.data;
    }
    var Ku = (i) => Buffer.isBuffer(i) ? i : i instanceof Uint8Array ? Buffer.from(i.buffer, i.byteOffset, i.byteLength) : Buffer.from(i);
    var Pm = (i) => {
      let e = i.serialize({ requireAllSignatures: false, verifySignatures: false });
      i instanceof gt.VersionedTransaction && (e = Ku(e));
      try {
        return e instanceof Buffer ? e.toString("base64") : Buffer.from(e).toString("base64");
      } catch {
        return e.toString("base64");
      }
    };
    function Po(i) {
      let e = [];
      return i.forEach((t) => {
        t instanceof gt.Transaction && (t.recentBlockhash || (t.recentBlockhash = bm.TOKEN_PROGRAM_ID.toBase58()), t.feePayer || (t.feePayer = gt.Keypair.generate().publicKey)), e.push(Pm(t));
      }), console.log("simulate tx string:", e), e;
    }
    function ly(i) {
      let e = i.serialize({ requireAllSignatures: false, verifySignatures: false });
      return i instanceof gt.VersionedTransaction && (e = Ku(e)), e.toString("base64");
    }
    function te(i, e, t) {
      return se([i.toBuffer(), (t != null ? t : wm.TOKEN_PROGRAM_ID).toBuffer(), e.toBuffer()], new Am.PublicKey("ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL"));
    }
    var pe = require("@solana/web3.js");
    var Is = new pe.PublicKey("EhhTKczWMGQt46ynNeRX1WfeagwwJd7ufHvCDjRxjo5Q");
    var Bs = new pe.PublicKey("CBuCnLe26faBpcBP2fktp4rp8abpcAnTWft6ZrP5Q4T");
    var xs = new pe.PublicKey("9KEPoZmtHUrBbhWN1v1KWLMkkvwY6WLtAVUCPRtRjP4z");
    var vo = new pe.PublicKey("FarmqiPv5eAj3j1GMdMCMUGXqPUvmquZtMy86QH6rzhG");
    var km = new pe.PublicKey("CLaimxFqjHzgTJtAGHU47NPhg6qrc5sCnpC4tBLyABQS");
    var Ss = new pe.PublicKey("srmqPvymJeFKQ4zGQed1GFppgkRHL9kaELCbyksJtPX");
    var rr = new pe.PublicKey("9xQeWvG816bUx9EPjHmaT23yvVM2ZWbrrpZb9PusVFin");
    var si = new pe.PublicKey("675kPX9MHTjS2zt1qfr1NYHuzeLXfQM9H24wFSUt1Mp8");
    var hm = new pe.PublicKey("5quBtoiQqxF9Jv6KYKctB59NT3gtJD2Y65kdnB1Uev3h");
    var sr = new pe.PublicKey("CDSr3ssLcRB6XYPJwAfFt18MZvEZp4LjHcvzBVZ45duo");
    var $n = new pe.PublicKey("CAMMCzo5YL8w4VFF8KVHrK22GGUsp5VTaW7grrKgrWqK");
    var Fo = new pe.PublicKey("LockrWmn6K5twhz3y9w1dQERbmgSaRkfnTeTKbpofwE");
    var ai = new pe.PublicKey("kN1kEznaF5Xbd8LYuqtEFcxzWSBk5Fv6ygX6SqEGJVy");
    var Jn = new pe.PublicKey("CDSr3ssLcRB6XYPJwAfFt18MZvEZp4LjHcvzBVZ45duo");
    var Tm = new pe.PublicKey("routeUGWgWzqBWFcrCfv8tritsqukccJPu3q5GPP3xS");
    var Ks = new pe.PublicKey("7YttLkHDoNj9wyDur5pM1ejNaAvT9X4eqaYcHQqtj2G5");
    var Im = new pe.PublicKey("6FJon3QE27qgPVggARueB22hLvoh22VzJpXv4rBEoSLF");
    var Bm = new pe.PublicKey("CC12se5To1CdEuw7fDS27B7Geo5jJyL7t5UK2B44NgiH");
    var xm = new pe.PublicKey("9HzJyW1qZsEiSfMUf6L2jo3CcTKAyBmSyKdwQeYisHrC");
    var Sm = new pe.PublicKey("DropEU8AvevN3UrXWXTMuz3rqnMczQVNjq3kcSdW2SQi");
    var eo = new pe.PublicKey("CPMMoo8L3F4NbTegBCKVNunggL7H1ZpdTHKxQB5qKP1C");
    var Cs = new pe.PublicKey("GpMZbSM2GgvTKHJirzeGfMFoaZ8UR2X7F4v8vHTvxFbL");
    var Km = new pe.PublicKey("DNXgeM9EiiaAbaWvwjHj9fQQLAX5ZsfHyvmYUNRAdNC8");
    var ui = new pe.PublicKey("LockrWmn6K5twhz3y9w1dQERbmgSaRkfnTeTKbpofwE");
    var ci = new pe.PublicKey("3f7GcQFG397GAaEnv51zR6tsTVihYRydnydDD1cXekxH");
    var pt = new pe.PublicKey("LanMV9sAd7wArD4vJFi2qDdfnVhFxYSUg6eADduJ3uj");
    var Cm = new pe.PublicKey("WLHv2UAZm6z4KyaaELi5pjdbJh6RESMva1Rnn8pJVVh");
    var my = new pe.PublicKey("DRay6fNdQ5J82H7xV6uq2aV3mNrUZ1J4PgSKsWgptcm6");
    var dy = new pe.PublicKey("5xqNaZXX5eUi4p5HU4oz9i5QnwRNT2y6oN7yyn4qENeq");
    var Rm = new pe.PublicKey("4Bu96XjU84XjPDSpveTVf6LYGCkfW5FK7SNkREWcEfV4");
    var Lm = new pe.PublicKey("6s1xP3hpbAfFoNtUNF8mfHsjr2Bd97JxFJRWLbL6aHuX");
    var li = { IDO_PROGRAM_ID_V1: Im, IDO_PROGRAM_ID_V2: Bm, IDO_PROGRAM_ID_V3: xm, IDO_PROGRAM_ID_V4: Sm };
    var Et = { AMM_V4: si, AMM_STABLE: hm, CLMM_PROGRAM_ID: $n, CLMM_LOCK_PROGRAM_ID: Fo, CLMM_LOCK_AUTH_ID: ai, FARM_PROGRAM_ID_V3: Is, FARM_PROGRAM_ID_V4: Bs, FARM_PROGRAM_ID_V5: xs, FARM_PROGRAM_ID_V6: vo, OPEN_BOOK_PROGRAM: Ss, SERUM_PROGRAM_ID_V3: rr, UTIL1216: km, Router: Tm, CREATE_CPMM_POOL_PROGRAM: eo, CREATE_CPMM_POOL_AUTH: Cs, CREATE_CPMM_POOL_FEE_ACC: Km, LOCK_CPMM_PROGRAM: ui, LOCK_CPMM_AUTH: ci, LAUNCHPAD_PROGRAM: pt, LAUNCHPAD_AUTH: Cm, LAUNCHPAD_PLATFORM: Rm, LAUNCHPAD_CONFIG: Lm, FEE_DESTINATION_ID: Ks, MODEL_DATA_PUBKEY: Jn };
    var En = { OPEN_BOOK_PROGRAM: new pe.PublicKey("EoTcMgcDRTJVZDMZWBoU6rhYHZfkNTVEAfz3uUJRcYGj"), SERUM_PROGRAM_ID_V3: new pe.PublicKey("Ray1111111111111111111111111111111111111111"), AMM_V4: new pe.PublicKey("DRaya7Kj3aMWQSy19kSjvmuwq9docCHofyP9kanQGaav"), AMM_STABLE: new pe.PublicKey("DRayDdXc1NZQ9C3hRWmoSf8zK4iapgMnjdNZWrfwsP8m"), CLMM_PROGRAM_ID: new pe.PublicKey("DRayAUgENGQBKVaX8owNhgzkEDyoHTGVEGHVJT1E9pfH"), CLMM_LOCK_PROGRAM_ID: new pe.PublicKey("DRay25Usp3YJAi7beckgpGUC7mGJ2cR1AVPxhYfwVCUX"), CLMM_LOCK_AUTH_ID: new pe.PublicKey("6Aoh8h2Lw2m5UGxYR8AdAL87jTWYeKoxM52mJRzfYwN"), CREATE_CPMM_POOL_PROGRAM: new pe.PublicKey("DRaycpLY18LhpbydsBWbVJtxpNv9oXPgjRSfpF2bWpYb"), CREATE_CPMM_POOL_AUTH: new pe.PublicKey("CXniRufdq5xL8t8jZAPxsPZDpuudwuJSPWnbcD5Y5Nxq"), CREATE_CPMM_POOL_FEE_ACC: new pe.PublicKey("3oE58BKVt8KuYkGxx8zBojugnymWmBiyafWgMrnb6eYy"), LOCK_CPMM_PROGRAM: new pe.PublicKey("DRay25Usp3YJAi7beckgpGUC7mGJ2cR1AVPxhYfwVCUX"), LOCK_CPMM_AUTH: new pe.PublicKey("7qWVV8UY2bRJfDLP4s37YzBPKUkVB46DStYJBpYbQzu3"), UTIL1216: pe.PublicKey.default, Router: new pe.PublicKey("DRaybByLpbUL57LJARs3j8BitTxVfzBg351EaMr5UTCd"), FARM_PROGRAM_ID_V3: new pe.PublicKey("DRayWyrLmEW5KEeqs8kdTMMaBabapqagaBC7KWpGtJeZ"), FARM_PROGRAM_ID_V4: new pe.PublicKey("Ray1111111111111111111111111111111111111111"), FARM_PROGRAM_ID_V5: new pe.PublicKey("DRayiCGSZgku1GTK6rXD6mVDdingXy6APAH1R6R5L2LC"), FARM_PROGRAM_ID_V6: new pe.PublicKey("DRayzbYakXs45ELHkzH6vC3fuhQqTAnv5A68gdFuvZyZ"), LAUNCHPAD_PROGRAM: new pe.PublicKey("DRay6fNdQ5J82H7xV6uq2aV3mNrUZ1J4PgSKsWgptcm6"), LAUNCHPAD_AUTH: new pe.PublicKey("5xqNaZXX5eUi4p5HU4oz9i5QnwRNT2y6oN7yyn4qENeq"), LAUNCHPAD_PLATFORM: new pe.PublicKey("2Jx4KTDrVSdWNazuGpcA8n3ZLTRGGBDxAWhuKe2Xcj2a"), LAUNCHPAD_CONFIG: new pe.PublicKey("7ZR4zD7PYfY2XxoG1Gxcy2EgEeGYrpxrwzPuwdUBssEt"), FEE_DESTINATION_ID: new pe.PublicKey("9y8ENuuZ3b19quffx9hQvRVygG5ky6snHfRvGpuSfeJy"), MODEL_DATA_PUBKEY: new pe.PublicKey("Ray1111111111111111111111111111111111111111") };
    var Le = Ae(require_bn());
    var Qt = 1e4;
    function py(i, e, t, n) {
      if (e === void 0)
        return { amount: i, fee: void 0, expirationTime: void 0 };
      let o = t.epoch < e.newerTransferFee.epoch ? e.olderTransferFee : e.newerTransferFee, r = new Le.default(o.maximumFee.toString()), s = t.epoch < e.newerTransferFee.epoch ? (Number(e.newerTransferFee.epoch) * t.slotsInEpoch - t.absoluteSlot) * 400 / 1e3 : void 0;
      if (n)
        if (o.transferFeeBasisPoints === Qt) {
          let a = new Le.default(o.maximumFee.toString());
          return { amount: i.add(a), fee: a, expirationTime: s };
        } else {
          let a = An(i.mul(new Le.default(Qt)), new Le.default(Qt - o.transferFeeBasisPoints)), c = new Le.default(o.maximumFee.toString()), u = a.sub(i).gt(c) ? i.add(c) : a, l = An(u.mul(new Le.default(o.transferFeeBasisPoints)), new Le.default(Qt)), m = l.gt(r) ? r : l;
          return { amount: u, fee: m, expirationTime: s };
        }
      else {
        let a = An(i.mul(new Le.default(o.transferFeeBasisPoints)), new Le.default(Qt)), c = a.gt(r) ? r : a;
        return { amount: i, fee: c, expirationTime: s };
      }
    }
    function _e(i, e, t, n) {
      if (e === void 0)
        return { amount: i, fee: void 0, expirationTime: void 0 };
      let o = U(E({}, e), { olderTransferFee: { epoch: BigInt(e.olderTransferFee.epoch), maximumFee: BigInt(e.olderTransferFee.maximumFee), transferFeeBasisPoints: e.olderTransferFee.transferFeeBasisPoints }, newerTransferFee: { epoch: BigInt(e.newerTransferFee.epoch), maximumFee: BigInt(e.newerTransferFee.maximumFee), transferFeeBasisPoints: e.newerTransferFee.transferFeeBasisPoints } }), r = t.epoch < o.newerTransferFee.epoch ? o.olderTransferFee : o.newerTransferFee, s = new Le.default(r.maximumFee.toString()), a = t.epoch < o.newerTransferFee.epoch ? (Number(o.newerTransferFee.epoch) * t.slotsInEpoch - t.absoluteSlot) * 400 / 1e3 : void 0;
      if (n)
        if (r.transferFeeBasisPoints === Qt) {
          let c = new Le.default(r.maximumFee.toString());
          return { amount: i.add(c), fee: c, expirationTime: a };
        } else {
          let c = An(i.mul(new Le.default(Qt)), new Le.default(Qt - r.transferFeeBasisPoints)), u = new Le.default(r.maximumFee.toString()), l = c.sub(i).gt(u) ? i.add(u) : c, m = An(l.mul(new Le.default(r.transferFeeBasisPoints)), new Le.default(Qt)), d = m.gt(s) ? s : m;
          return { amount: l, fee: d, expirationTime: a };
        }
      else {
        let c = An(i.mul(new Le.default(r.transferFeeBasisPoints)), new Le.default(Qt)), u = c.gt(s) ? s : c;
        return { amount: i, fee: u, expirationTime: a };
      }
    }
    function wn(i, e) {
      return i === void 0 ? e : e === void 0 ? i : Math.min(i, e);
    }
    function An(i, e) {
      let { div: t, mod: n } = i.divmod(e);
      return n.gt(new Le.default(0)) ? t.add(new Le.default(1)) : t;
    }
    function Ao(i, e) {
      if (i.isZero())
        return new Le.default(0);
      let t = i.div(e);
      return t.isZero() ? new Le.default(1) : i.mod(e).gt(new Le.default(0)) ? t.add(new Le.default(1)) : t;
    }
    function Rs(i, e, t) {
      if (e === void 0)
        return { amount: i, fee: void 0, expirationTime: void 0 };
      let n = Math.floor(t / 432e3), o = n < e.newerTransferFee.epoch ? e.olderTransferFee : e.newerTransferFee, r = new Le.default(o.maximumFee.toString()), s = n < e.newerTransferFee.epoch ? (Number(e.newerTransferFee.epoch) * 432e3 - t) * 400 / 1e3 : void 0, a = An(i.mul(new Le.default(o.transferFeeBasisPoints)), new Le.default(Qt)), c = a.gt(r) ? r : a;
      return { amount: i, fee: c, expirationTime: s };
    }
    function Ls(i, e, t) {
      if (e === void 0)
        return { amount: i, fee: void 0, expirationTime: void 0 };
      let n = Math.floor(t / 432e3), o = n < e.newerTransferFee.epoch ? e.olderTransferFee : e.newerTransferFee, r = new Le.default(o.maximumFee.toString()), s = n < e.newerTransferFee.epoch ? (Number(e.newerTransferFee.epoch) * 432e3 - t) * 400 / 1e3 : void 0;
      if (o.transferFeeBasisPoints === Qt) {
        let a = new Le.default(o.maximumFee.toString());
        return { amount: i.add(a), fee: a, expirationTime: s };
      } else {
        let a = An(i.mul(new Le.default(Qt)), new Le.default(Qt - o.transferFeeBasisPoints)), c = new Le.default(o.maximumFee.toString()), u = a.sub(i).gt(c) ? i.add(c) : a, l = An(u.mul(new Le.default(o.transferFeeBasisPoints)), new Le.default(Qt)), m = l.gt(r) ? r : l;
        return { amount: u, fee: m, expirationTime: s };
      }
    }
    var Rn = require("@solana/web3.js");
    async function Ns({ connection: i, address: e, cluster: t = "mainnet" }) {
      let n = await gn(i, [...new Set(e.map((r) => r.toString()))].map((r) => new Rn.PublicKey(r))), o = {};
      for (let r = 0; r < e.length; r++) {
        let s = n[r], a = e[r];
        if (!s)
          continue;
        let c = new Rn.AddressLookupTableAccount({ key: a, state: Rn.AddressLookupTableAccount.deserialize(s.data) });
        o[a.toString()] = c, t === "devnet" ? _o[a.toString()] = c : Vo[a.toString()] = c;
      }
      return o;
    }
    var Vo = {};
    var Os = async (i) => {
      let e = "AcL1Vo8oy1ULiavEcjSUcwfBSForXMudcZvDZy5nzJkU";
      if (Vo[e])
        return Vo;
      let t = new Rn.PublicKey(e), n = await i.getAccountInfo(t);
      return n && (Vo[e] = new Rn.AddressLookupTableAccount({ key: t, state: Rn.AddressLookupTableAccount.deserialize(n.data) })), Vo;
    };
    var _o = {};
    var Ms = async (i) => {
      let e = "EFhMuDw1PKEuckuFRW9PavNfTH4LKP5uKHgyXDmWpFCq";
      if (_o[e])
        return _o;
      let t = new Rn.PublicKey(e), n = await i.getAccountInfo(t);
      return n && (_o[e] = new Rn.AddressLookupTableAccount({ key: t, state: Rn.AddressLookupTableAccount.deserialize(n.data) })), _o;
    };
    var qe = require("@solana/web3.js");
    var Nm = Ae(require_axios());
    var vs = 2e3;
    var ar = class {
      constructor(e) {
        this.instructions = [];
        this.endInstructions = [];
        this.lookupTableAddress = [];
        this.signers = [];
        this.instructionTypes = [];
        this.endInstructionTypes = [];
        this.connection = e.connection, this.feePayer = e.feePayer, this.signAllTransactions = e.signAllTransactions, this.owner = e.owner, this.cluster = e.cluster, this.blockhashCommitment = e.blockhashCommitment, this.loopMultiTxStatus = !!e.loopMultiTxStatus;
      }
      get AllTxData() {
        return { instructions: this.instructions, endInstructions: this.endInstructions, signers: this.signers, instructionTypes: this.instructionTypes, endInstructionTypes: this.endInstructionTypes, lookupTableAddress: this.lookupTableAddress };
      }
      get allInstructions() {
        return [...this.instructions, ...this.endInstructions];
      }
      async getComputeBudgetConfig() {
        var n;
        let e = (await Nm.default.get(`https://solanacompass.com/api/fees?cacheFreshTime=${3e5}`)).data, { avg: t } = (n = e == null ? void 0 : e[15]) != null ? n : {};
        if (!!t)
          return { units: 6e5, microLamports: Math.min(Math.ceil(t * 1e6 / 6e5), 25e3) };
      }
      addCustomComputeBudget(e) {
        if (e) {
          let { instructions: t, instructionTypes: n } = nr(e);
          return this.instructions.unshift(...t), this.instructionTypes.unshift(...n), true;
        }
        return false;
      }
      addTipInstruction(e) {
        var t;
        return e ? (this.endInstructions.push(qe.SystemProgram.transfer({ fromPubkey: (t = e.feePayer) != null ? t : this.feePayer, toPubkey: new qe.PublicKey(e.address), lamports: BigInt(e.amount.toString()) })), this.endInstructionTypes.push(X.TransferTip), true) : false;
      }
      async calComputeBudget({ config: e, defaultIns: t }) {
        try {
          let n = e || await this.getComputeBudgetConfig();
          if (this.addCustomComputeBudget(n))
            return;
          t && this.instructions.unshift(...t);
        } catch {
          t && this.instructions.unshift(...t);
        }
      }
      addInstruction({ instructions: e = [], endInstructions: t = [], signers: n = [], instructionTypes: o = [], endInstructionTypes: r = [], lookupTableAddress: s = [] }) {
        return this.instructions.push(...e), this.endInstructions.push(...t), this.signers.push(...n), this.instructionTypes.push(...o), this.endInstructionTypes.push(...r), this.lookupTableAddress.push(...s.filter((a) => a !== qe.PublicKey.default.toString())), this;
      }
      async versionBuild({ txVersion: e, extInfo: t }) {
        return e === 0 ? await this.buildV0(E({}, t || {})) : this.build(t);
      }
      build(e) {
        var n;
        let t = new qe.Transaction();
        return this.allInstructions.length && t.add(...this.allInstructions), t.feePayer = this.feePayer, ((n = this.owner) == null ? void 0 : n.signer) && !this.signers.some((o) => o.publicKey.equals(this.owner.publicKey)) && this.signers.push(this.owner.signer), { builder: this, transaction: t, signers: this.signers, instructionTypes: [...this.instructionTypes, ...this.endInstructionTypes], execute: async (o) => {
          var l;
          let { recentBlockHash: r, skipPreflight: s = true, sendAndConfirm: a, notSendToRpc: c } = o || {}, u = r != null ? r : await Mo(this.connection, this.blockhashCommitment);
          if (t.recentBlockhash = u, this.signers.length && t.sign(...this.signers), Po([t]), (l = this.owner) != null && l.isKeyPair)
            return { txId: a ? await (0, qe.sendAndConfirmTransaction)(this.connection, t, this.signers.find((d) => d.publicKey.equals(this.owner.publicKey)) ? this.signers : [...this.signers, this.owner.signer], { skipPreflight: s }) : await this.connection.sendRawTransaction(t.serialize(), { skipPreflight: s }), signedTx: t };
          if (this.signAllTransactions) {
            let m = await this.signAllTransactions([t]);
            if (this.signers.length)
              for (let d of m)
                try {
                  d.sign(...this.signers);
                } catch {
                }
            return { txId: c ? "" : await this.connection.sendRawTransaction(m[0].serialize(), { skipPreflight: s }), signedTx: m[0] };
          }
          throw new Error("please provide owner in keypair format or signAllTransactions function");
        }, extInfo: e || {} };
      }
      buildMultiTx(e) {
        var u;
        let { extraPreBuildData: t = [], extInfo: n } = e, { transaction: o } = this.build(n), r = t.filter((l) => l.transaction.instructions.length > 0), s = [o, ...r.map((l) => l.transaction)], a = [this.signers, ...r.map((l) => l.signers)], c = [...this.instructionTypes, ...r.map((l) => l.instructionTypes).flat()];
        return (u = this.owner) != null && u.signer && a.forEach((l) => {
          l.some((m) => m.publicKey.equals(this.owner.publicKey)) || this.signers.push(this.owner.signer);
        }), { builder: this, transactions: s, signers: a, instructionTypes: c, execute: async (l) => {
          var g;
          let { sequentially: m, onTxUpdate: d, skipTxCount: p = 0, recentBlockHash: f, skipPreflight: y = true } = l || {}, b = f != null ? f : await Mo(this.connection, this.blockhashCommitment);
          if ((g = this.owner) != null && g.isKeyPair) {
            if (m) {
              let A = [], k = 0;
              for (let I of s) {
                if (++k, k <= p)
                  continue;
                let T = await (0, qe.sendAndConfirmTransaction)(this.connection, I, this.signers.find((h) => h.publicKey.equals(this.owner.publicKey)) ? this.signers : [...this.signers, this.owner.signer], { skipPreflight: y });
                A.push(T);
              }
              return { txIds: A, signedTxs: s };
            }
            return { txIds: await await Promise.all(s.map(async (A) => (A.recentBlockhash = b, await this.connection.sendRawTransaction(A.serialize(), { skipPreflight: y })))), signedTxs: s };
          }
          if (this.signAllTransactions) {
            let A = s.map((I, T) => (I.recentBlockhash = b, a[T].length && I.sign(...a[T]), I));
            Po(A);
            let k = await this.signAllTransactions(A);
            if (m) {
              let I = 0, T = [], h = async () => {
                if (!k[I])
                  return;
                let S = await this.connection.sendRawTransaction(k[I].serialize(), { skipPreflight: y });
                T.push({ txId: S, status: "sent", signedTx: k[I] }), d == null || d([...T]), I++;
                let x = false, K = null, B = null, C = (R) => {
                  K !== null && clearInterval(K), B !== null && this.connection.removeSignatureListener(B);
                  let N = T.findIndex((v) => v.txId === S);
                  if (N > -1) {
                    if (T[N].status === "error" || T[N].status === "success")
                      return;
                    T[N].status = R.err ? "error" : "success";
                  }
                  d == null || d([...T]), R.err || h();
                };
                this.loopMultiTxStatus && (K = setInterval(async () => {
                  var R;
                  if (x) {
                    clearInterval(K);
                    return;
                  }
                  try {
                    let N = await this.connection.getTransaction(S, { commitment: "confirmed", maxSupportedTransactionVersion: 0 });
                    N && (x = true, clearInterval(K), C({ err: ((R = N.meta) == null ? void 0 : R.err) || null }), console.log("tx status from getTransaction:", S));
                  } catch (N) {
                    x = true, clearInterval(K), console.error("getTransaction timeout:", N, S);
                  }
                }, vs)), B = this.connection.onSignature(S, (R) => {
                  if (x) {
                    this.connection.removeSignatureListener(B);
                    return;
                  }
                  x = true, C(R);
                }, "confirmed"), this.connection.getSignatureStatus(S);
              };
              return await h(), { txIds: T.map((S) => S.txId), signedTxs: k };
            } else {
              let I = [];
              for (let T = 0; T < k.length; T += 1) {
                let h = await this.connection.sendRawTransaction(k[T].serialize(), { skipPreflight: y });
                I.push(h);
              }
              return { txIds: I, signedTxs: k };
            }
          }
          throw new Error("please provide owner in keypair format or signAllTransactions function");
        }, extInfo: n || {} };
      }
      async versionMultiBuild({ extraPreBuildData: e, txVersion: t, extInfo: n }) {
        return t === 0 ? await this.buildV0MultiTx({ extraPreBuildData: e, buildProps: n || {} }) : this.buildMultiTx({ extraPreBuildData: e, extInfo: n });
      }
      async buildV0(e) {
        var y;
        let f = e || {}, { lookupTableCache: t = {}, lookupTableAddress: n = [], forerunCreate: o, recentBlockhash: r } = f, s = tt(f, ["lookupTableCache", "lookupTableAddress", "forerunCreate", "recentBlockhash"]), a = E(E({}, this.cluster === "devnet" ? await Ms(this.connection) : await Os(this.connection)), t), c = Array.from(/* @__PURE__ */ new Set([...n, ...this.lookupTableAddress])), u = [];
        for (let b of c)
          a[b] === void 0 && u.push(new qe.PublicKey(b));
        let l = await Ns({ connection: this.connection, address: u });
        for (let [b, g] of Object.entries(l))
          a[b] = g;
        let m = o ? qe.PublicKey.default.toBase58() : r != null ? r : await Mo(this.connection, this.blockhashCommitment), d = new qe.TransactionMessage({ payerKey: this.feePayer, recentBlockhash: m, instructions: [...this.allInstructions] }).compileToV0Message(Object.values(a));
        ((y = this.owner) == null ? void 0 : y.signer) && !this.signers.some((b) => b.publicKey.equals(this.owner.publicKey)) && this.signers.push(this.owner.signer);
        let p = new qe.VersionedTransaction(d);
        return p.sign(this.signers), { builder: this, transaction: p, signers: this.signers, instructionTypes: [...this.instructionTypes, ...this.endInstructionTypes], execute: async (b) => {
          var I;
          let { skipPreflight: g = true, sendAndConfirm: A, notSendToRpc: k } = b || {};
          if (Po([p]), (I = this.owner) != null && I.isKeyPair) {
            let T = await this.connection.sendTransaction(p, { skipPreflight: g });
            return A && await or(this.connection, T), { txId: T, signedTx: p };
          }
          if (this.signAllTransactions) {
            let T = await this.signAllTransactions([p]);
            if (this.signers.length)
              for (let h of T)
                try {
                  h.sign(this.signers);
                } catch {
                }
            return { txId: k ? "" : await this.connection.sendTransaction(T[0], { skipPreflight: g }), signedTx: T[0] };
          }
          throw new Error("please provide owner in keypair format or signAllTransactions function");
        }, extInfo: s || {} };
      }
      async buildV0MultiTx(e) {
        var u;
        let { extraPreBuildData: t = [], buildProps: n } = e, { transaction: o } = await this.buildV0(n), r = t.filter((l) => l.builder.instructions.length > 0), s = [o, ...r.map((l) => l.transaction)], a = [this.signers, ...r.map((l) => l.signers)], c = [...this.instructionTypes, ...r.map((l) => l.instructionTypes).flat()];
        return (u = this.owner) != null && u.signer && a.forEach((l) => {
          l.some((m) => m.publicKey.equals(this.owner.publicKey)) || this.signers.push(this.owner.signer);
        }), s.forEach(async (l, m) => {
          l.sign(a[m]);
        }), { builder: this, transactions: s, signers: a, instructionTypes: c, buildProps: n, execute: async (l) => {
          var y;
          let { sequentially: m, onTxUpdate: d, recentBlockHash: p, skipPreflight: f = true } = l || {};
          if (p && s.forEach((b) => b.message.recentBlockhash = p), Po(s), (y = this.owner) != null && y.isKeyPair) {
            if (m) {
              let b = [];
              for (let g of s) {
                let A = await this.connection.sendTransaction(g, { skipPreflight: f });
                await or(this.connection, A), b.push(A);
              }
              return { txIds: b, signedTxs: s };
            }
            return { txIds: await Promise.all(s.map(async (b) => await this.connection.sendTransaction(b, { skipPreflight: f }))), signedTxs: s };
          }
          if (this.signAllTransactions) {
            let b = await this.signAllTransactions(s);
            if (m) {
              let g = 0, A = [], k = async () => {
                if (!b[g])
                  return;
                let I = await this.connection.sendTransaction(b[g], { skipPreflight: f });
                A.push({ txId: I, status: "sent", signedTx: b[g] }), d == null || d([...A]), g++;
                let T = false, h = null, S = null, x = (K) => {
                  h !== null && clearInterval(h), S !== null && this.connection.removeSignatureListener(S);
                  let B = A.findIndex((C) => C.txId === I);
                  if (B > -1) {
                    if (A[B].status === "error" || A[B].status === "success")
                      return;
                    A[B].status = K.err ? "error" : "success";
                  }
                  d == null || d([...A]), K.err || k();
                };
                this.loopMultiTxStatus && (h = setInterval(async () => {
                  var K;
                  if (T) {
                    clearInterval(h);
                    return;
                  }
                  try {
                    let B = await this.connection.getTransaction(I, { commitment: "confirmed", maxSupportedTransactionVersion: 0 });
                    B && (T = true, clearInterval(h), x({ err: ((K = B.meta) == null ? void 0 : K.err) || null }), console.log("tx status from getTransaction:", I));
                  } catch (B) {
                    T = true, clearInterval(h), console.error("getTransaction timeout:", B, I);
                  }
                }, vs)), S = this.connection.onSignature(I, (K) => {
                  if (T) {
                    this.connection.removeSignatureListener(S);
                    return;
                  }
                  T = true, x(K);
                }, "confirmed"), this.connection.getSignatureStatus(I);
              };
              return k(), { txIds: [], signedTxs: b };
            } else {
              let g = [];
              for (let A = 0; A < b.length; A += 1) {
                let k = await this.connection.sendTransaction(b[A], { skipPreflight: f });
                g.push(k);
              }
              return { txIds: g, signedTxs: b };
            }
          }
          throw new Error("please provide owner in keypair format or signAllTransactions function");
        }, extInfo: n || {} };
      }
      async sizeCheckBuild(e) {
        var d;
        let m = e || {}, { splitIns: t = [], computeBudgetConfig: n } = m, o = tt(m, ["splitIns", "computeBudgetConfig"]), r = n ? nr(n) : { instructions: [], instructionTypes: [] }, s = this.signers.reduce((p, f) => U(E({}, p), { [f.publicKey.toBase58()]: f }), {}), a = [], c = [], u = [], l = 0;
        if (this.allInstructions.forEach((p) => {
          let f = [...u, p], y = n ? [...r.instructions, ...f] : f, g = [...new Set(f.map((A) => A.keys.filter((k) => k.isSigner).map((k) => k.pubkey.toString())).flat()).values()].map((A) => new qe.PublicKey(A));
          if (p !== t[l] && u.length < 12 && (ii({ instructions: y, payer: this.feePayer, signers: g }) || ii({ instructions: f, payer: this.feePayer, signers: g })))
            u.push(p);
          else {
            if (u.length === 0)
              throw Error("item ins too big");
            l += p === t[l] ? 1 : 0, ii({ instructions: n ? [...r.instructions, ...u] : [...u], payer: this.feePayer, signers: g }) ? a.push(new qe.Transaction().add(...r.instructions, ...u)) : a.push(new qe.Transaction().add(...u)), c.push(Array.from(new Set(u.map((A) => A.keys.filter((k) => k.isSigner).map((k) => k.pubkey.toString())).flat())).map((A) => s[A]).filter((A) => A !== void 0)), u = [p];
          }
        }), u.length > 0) {
          let f = [...new Set(u.map((y) => y.keys.filter((b) => b.isSigner).map((b) => b.pubkey.toString())).flat()).values()].map((y) => s[y]).filter((y) => y !== void 0);
          ii({ instructions: n ? [...r.instructions, ...u] : [...u], payer: this.feePayer, signers: f.map((y) => y.publicKey) }) ? a.push(new qe.Transaction().add(...r.instructions, ...u)) : a.push(new qe.Transaction().add(...u)), c.push(f);
        }
        return a.forEach((p) => p.feePayer = this.feePayer), (d = this.owner) != null && d.signer && c.forEach((p) => {
          p.some((f) => f.publicKey.equals(this.owner.publicKey)) || p.push(this.owner.signer);
        }), { builder: this, transactions: a, signers: c, instructionTypes: this.instructionTypes, execute: async (p) => {
          var I;
          let { sequentially: f, onTxUpdate: y, skipTxCount: b = 0, recentBlockHash: g, skipPreflight: A = true } = p || {}, k = g != null ? g : await Mo(this.connection, this.blockhashCommitment);
          if (a.forEach(async (T, h) => {
            T.recentBlockhash = k, c[h].length && T.sign(...c[h]);
          }), Po(a), (I = this.owner) != null && I.isKeyPair) {
            if (f) {
              let T = 0, h = [];
              for (let S of a) {
                if (++T, T <= b) {
                  h.push("tx skipped");
                  continue;
                }
                let x = await (0, qe.sendAndConfirmTransaction)(this.connection, S, this.signers.find((K) => K.publicKey.equals(this.owner.publicKey)) ? this.signers : [...this.signers, this.owner.signer], { skipPreflight: A });
                h.push(x);
              }
              return { txIds: h, signedTxs: a };
            }
            return { txIds: await Promise.all(a.map(async (T) => await this.connection.sendRawTransaction(T.serialize(), { skipPreflight: A }))), signedTxs: a };
          }
          if (this.signAllTransactions) {
            let T = await this.signAllTransactions(a.slice(b, a.length)), h = [...a.slice(0, b), ...T];
            if (f) {
              let S = 0, x = [], K = async () => {
                if (!h[S])
                  return;
                S < b && (x.push({ txId: "", status: "success", signedTx: h[S] }), y == null || y([...x]), S++, K());
                let B = await this.connection.sendRawTransaction(h[S].serialize(), { skipPreflight: A });
                x.push({ txId: B, status: "sent", signedTx: h[S] }), y == null || y([...x]), S++;
                let C = false, R = null, N = null, v = (L) => {
                  R !== null && clearInterval(R), N !== null && this.connection.removeSignatureListener(N);
                  let M = x.findIndex((Y) => Y.txId === B);
                  if (M > -1) {
                    if (x[M].status === "error" || x[M].status === "success")
                      return;
                    x[M].status = L.err ? "error" : "success";
                  }
                  y == null || y([...x]), L.err || K();
                };
                this.loopMultiTxStatus && (R = setInterval(async () => {
                  var L;
                  if (C) {
                    clearInterval(R);
                    return;
                  }
                  try {
                    let M = await this.connection.getTransaction(B, { commitment: "confirmed", maxSupportedTransactionVersion: 0 });
                    M && (C = true, clearInterval(R), v({ err: ((L = M.meta) == null ? void 0 : L.err) || null }), console.log("tx status from getTransaction:", B));
                  } catch (M) {
                    C = true, clearInterval(R), console.error("getTransaction timeout:", M, B);
                  }
                }, vs)), N = this.connection.onSignature(B, (L) => {
                  if (C) {
                    this.connection.removeSignatureListener(N);
                    return;
                  }
                  C = true, v(L);
                }, "confirmed"), this.connection.getSignatureStatus(B);
              };
              return await K(), { txIds: x.map((B) => B.txId), signedTxs: h };
            } else {
              let S = [];
              for (let x = 0; x < h.length; x += 1) {
                let K = await this.connection.sendRawTransaction(h[x].serialize(), { skipPreflight: A });
                S.push(K);
              }
              return { txIds: S, signedTxs: h };
            }
          }
          throw new Error("please provide owner in keypair format or signAllTransactions function");
        }, extInfo: o || {} };
      }
      async sizeCheckBuildV0(e) {
        var k;
        let A = e || {}, { computeBudgetConfig: t, splitIns: n = [], lookupTableCache: o = {}, lookupTableAddress: r = [] } = A, s = tt(A, ["computeBudgetConfig", "splitIns", "lookupTableCache", "lookupTableAddress"]), a = E(E({}, this.cluster === "devnet" ? await Ms(this.connection) : await Os(this.connection)), o), c = Array.from(/* @__PURE__ */ new Set([...this.lookupTableAddress, ...r])), u = [];
        for (let I of c)
          a[I] === void 0 && u.push(new qe.PublicKey(I));
        let l = await Ns({ connection: this.connection, address: u });
        for (let [I, T] of Object.entries(l))
          a[I] = T;
        let m = t ? nr(t) : { instructions: [], instructionTypes: [] }, d = await Mo(this.connection, this.blockhashCommitment), p = this.signers.reduce((I, T) => U(E({}, I), { [T.publicKey.toBase58()]: T }), {}), f = [], y = [], b = [], g = 0;
        if (this.allInstructions.forEach((I) => {
          let T = [...b, I], h = t ? [...m.instructions, ...T] : T;
          if (I !== n[g] && b.length < 12 && (ri({ instructions: h, payer: this.feePayer, lookupTableAddressAccount: a }) || ri({ instructions: T, payer: this.feePayer, lookupTableAddressAccount: a })))
            b.push(I);
          else {
            if (b.length === 0)
              throw Error("item ins too big");
            g += I === n[g] ? 1 : 0;
            let S = {};
            for (let x of [...new Set(c)])
              a[x] !== void 0 && (S[x] = a[x]);
            if (t && ri({ instructions: [...m.instructions, ...b], payer: this.feePayer, lookupTableAddressAccount: a, recentBlockhash: d })) {
              let x = new qe.TransactionMessage({ payerKey: this.feePayer, recentBlockhash: d, instructions: [...m.instructions, ...b] }).compileToV0Message(Object.values(a));
              f.push(new qe.VersionedTransaction(x));
            } else {
              let x = new qe.TransactionMessage({ payerKey: this.feePayer, recentBlockhash: d, instructions: [...b] }).compileToV0Message(Object.values(a));
              f.push(new qe.VersionedTransaction(x));
            }
            y.push(Array.from(new Set(b.map((x) => x.keys.filter((K) => K.isSigner).map((K) => K.pubkey.toString())).flat())).map((x) => p[x]).filter((x) => x !== void 0)), b = [I];
          }
        }), b.length > 0) {
          let T = [...new Set(b.map((h) => h.keys.filter((S) => S.isSigner).map((S) => S.pubkey.toString())).flat()).values()].map((h) => p[h]).filter((h) => h !== void 0);
          if (t && ri({ instructions: [...m.instructions, ...b], payer: this.feePayer, lookupTableAddressAccount: a, recentBlockhash: d })) {
            let h = new qe.TransactionMessage({ payerKey: this.feePayer, recentBlockhash: d, instructions: [...m.instructions, ...b] }).compileToV0Message(Object.values(a));
            f.push(new qe.VersionedTransaction(h));
          } else {
            let h = new qe.TransactionMessage({ payerKey: this.feePayer, recentBlockhash: d, instructions: [...b] }).compileToV0Message(Object.values(a));
            f.push(new qe.VersionedTransaction(h));
          }
          y.push(T);
        }
        return (k = this.owner) != null && k.signer && y.forEach((I) => {
          I.some((T) => T.publicKey.equals(this.owner.publicKey)) || I.push(this.owner.signer);
        }), f.forEach((I, T) => {
          I.sign(y[T]);
        }), { builder: this, transactions: f, buildProps: e, signers: y, instructionTypes: this.instructionTypes, execute: async (I) => {
          var B;
          let { sequentially: T, onTxUpdate: h, skipTxCount: S = 0, recentBlockHash: x, skipPreflight: K = true } = I || {};
          if (f.map(async (C, R) => {
            y[R].length && C.sign(y[R]), x && (C.message.recentBlockhash = x);
          }), Po(f), (B = this.owner) != null && B.isKeyPair) {
            if (T) {
              let C = 0, R = [];
              for (let N of f) {
                if (++C, C <= S) {
                  console.log("skip tx: ", C), R.push("tx skipped");
                  continue;
                }
                let v = await this.connection.sendTransaction(N, { skipPreflight: K });
                await or(this.connection, v), R.push(v);
              }
              return { txIds: R, signedTxs: f };
            }
            return { txIds: await Promise.all(f.map(async (C) => await this.connection.sendTransaction(C, { skipPreflight: K }))), signedTxs: f };
          }
          if (this.signAllTransactions) {
            let C = await this.signAllTransactions(f.slice(S, f.length)), R = [...f.slice(0, S), ...C];
            if (T) {
              let N = 0, v = [], L = async () => {
                if (!R[N])
                  return;
                if (N < S) {
                  v.push({ txId: "", status: "success", signedTx: R[N] }), h == null || h([...v]), N++, L();
                  return;
                }
                let M = await this.connection.sendTransaction(R[N], { skipPreflight: K });
                v.push({ txId: M, status: "sent", signedTx: R[N] }), h == null || h([...v]), N++;
                let Y = false, j = null, le = null, be = (me) => {
                  j !== null && clearInterval(j), le !== null && this.connection.removeSignatureListener(le);
                  let Ie = v.findIndex((he) => he.txId === M);
                  if (Ie > -1) {
                    if (v[Ie].status === "error" || v[Ie].status === "success")
                      return;
                    v[Ie].status = me.err ? "error" : "success";
                  }
                  h == null || h([...v]), me.err || L();
                };
                this.loopMultiTxStatus && (j = setInterval(async () => {
                  var me;
                  if (Y) {
                    clearInterval(j);
                    return;
                  }
                  try {
                    let Ie = await this.connection.getTransaction(M, { commitment: "confirmed", maxSupportedTransactionVersion: 0 });
                    Ie && (Y = true, clearInterval(j), be({ err: ((me = Ie.meta) == null ? void 0 : me.err) || null }), console.log("tx status from getTransaction:", M));
                  } catch (Ie) {
                    Y = true, clearInterval(j), console.error("getTransaction timeout:", Ie, M);
                  }
                }, vs)), le = this.connection.onSignature(M, (me) => {
                  if (Y) {
                    this.connection.removeSignatureListener(le);
                    return;
                  }
                  Y = true, be(me);
                }, "confirmed"), this.connection.getSignatureStatus(M);
              };
              return L(), { txIds: [], signedTxs: R };
            } else {
              let N = [];
              for (let v = 0; v < R.length; v += 1) {
                let L = await this.connection.sendTransaction(R[v], { skipPreflight: K });
                N.push(L);
              }
              return { txIds: N, signedTxs: R };
            }
          }
          throw new Error("please provide owner in keypair format or signAllTransactions function");
        }, extInfo: s || {} };
      }
    };
    var Om = require("@solana/web3.js");
    var Mm = Ae(require_bn());
    async function Cu(i) {
      new Promise((e) => setTimeout(e, i));
    }
    function fy() {
      return (/* @__PURE__ */ new Date()).getTime();
    }
    function vm(i) {
      return typeof i == "object" && i !== null && ![De, ve, Om.PublicKey, ke, Mm.default, Tt, ot].some((e) => typeof e == "object" && i instanceof e);
    }
    function Qe(i) {
      return typeof i == "string" ? Ps(i) : Array.isArray(i) ? i.map((e) => Qe(e)) : vm(i) ? Object.fromEntries(Object.entries(i).map(([e, t]) => [e, Qe(t)])) : i;
    }
    var Fm = Ae(require_bn());
    var jt = new Fm.default(1e6);
    var Ru = ((t) => (t.ALL = "all", t.Strict = "strict", t))(Ru || {});
    var Lu = ((s) => (s.All = "all", s.Standard = "standard", s.Concentrated = "concentrated", s.AllFarm = "allFarm", s.StandardFarm = "standardFarm", s.ConcentratedFarm = "concentratedFarm", s))(Lu || {});
    var It = { BASE_HOST: "https://api-v3.raydium.io", OWNER_BASE_HOST: "https://owner-v1.raydium.io", SERVICE_BASE_HOST: "https://service.raydium.io", MONITOR_BASE_HOST: "https://monitor.raydium.io", SERVICE_1_BASE_HOST: "https://service-v1.raydium.io", SEND_TRANSACTION: "/send-transaction", FARM_ARP: "/main/farm/info", FARM_ARP_LINE: "/main/farm-apr-tv", CLMM_CONFIG: "/main/clmm-config", CPMM_CONFIG: "/main/cpmm-config", VERSION: "/main/version", CHECK_AVAILABILITY: "/v3/main/AvailabilityCheckAPI", RPCS: "/main/rpcs", INFO: "/main/info", STAKE_POOLS: "/main/stake-pools", CHAIN_TIME: "/main/chain-time", TOKEN_LIST: "/mint/list", MINT_INFO_ID: "/mint/ids", JUP_TOKEN_LIST: "https://lite-api.jup.ag/tokens/v2/tag?query=verified", POOL_LIST: "/pools/info/list", POOL_SEARCH_BY_ID: "/pools/info/ids", POOL_SEARCH_MINT: "/pools/info/mint", POOL_SEARCH_LP: "/pools/info/lps", POOL_KEY_BY_ID: "/pools/key/ids", POOL_LIQUIDITY_LINE: "/pools/line/liquidity", POOL_POSITION_LINE: "/pools/line/position", FARM_INFO: "/farms/info/ids", FARM_LP_INFO: "/farms/info/lp", FARM_KEYS: "/farms/key/ids", OWNER_CREATED_FARM: "/create-pool/{owner}", OWNER_IDO: "/main/ido/{owner}", OWNER_STAKE_FARMS: "/position/stake/{owner}", OWNER_LOCK_POSITION: "/position/clmm-lock/{owner}", IDO_KEYS: "/ido/key/ids", SWAP_HOST: "https://transaction-v1.raydium.io", SWAP_COMPUTE: "/compute/", SWAP_TX: "/transaction/", MINT_PRICE: "/mint/price", MIGRATE_CONFIG: "/main/migrate-lp", PRIORITY_FEE: "/main/auto-fee", CPMM_LOCK: "https://dynamic-ipfs.raydium.io/lock/cpmm/position", LAUNCH_AUTH_HOST: "https://launch-auth-v1.raydium.io", LAUNCH_COMMENT_HOST: "hhttps://launch-forum-v1.raydium.io", LAUNCH_HISTORY_HOST: "https://launch-history-v1.raydium.io", LAUNCH_MINT_HOST: "https://launch-mint-v1.raydium.io" };
    var Nu = U(E({}, It), { BASE_HOST: "https://api-v3-devnet.raydium.io", OWNER_BASE_HOST: "https://owner-v1-devnet.raydium.io", SWAP_HOST: "https://transaction-v1-devnet.raydium.io", CPMM_LOCK: "https://dynamic-ipfs-devnet.raydium.io/lock/cpmm/position", LAUNCH_AUTH_HOST: "https://launch-auth-v1-devnet.raydium.io", LAUNCH_COMMENT_HOST: "https://launch-forum-v1-devnet.raydium.io", LAUNCH_HISTORY_HOST: "https://launch-history-v1-devnet.raydium.io", LAUNCH_MINT_HOST: "https://launch-mint-v1-devnet.raydium.io" });
    var Ou = "ray_tab_hash";
    var Fs = "ray_req_hash";
    var Vm = () => {
      if (typeof window === void 0)
        return "";
      let i = sessionStorage.getItem(Ou);
      return i || (i = `ray-${Date.now()}`, sessionStorage.setItem(Ou, i)), i;
    };
    var ur = async (n) => {
      var o = n, { logCount: i = 1e3, removeLastLog: e } = o, t = tt(o, ["logCount", "removeLastLog"]);
      if (typeof window === void 0)
        return new Promise((s) => s());
      let r = JSON.parse(localStorage.getItem(Fs) || "[]").slice(0, i - 1);
      e && r.pop(), new Blob([JSON.stringify(t.data)]).size > 1024 && (t.data = JSON.stringify(t.data).substring(0, 200) + "..."), r.unshift(U(E({}, t), { time: Date.now(), session: Vm() }));
      try {
        localStorage.setItem(Fs, JSON.stringify(r));
      } catch {
        if (e) {
          let s = false, a = JSON.stringify(t.data).substring(0, 100);
          for (r[0].data = a + (a.length > 100 ? "..." : ""); !s; ) {
            r.pop();
            let c = JSON.stringify(t.data).substring(0, 100);
            r[0].data = c + (c.length > 100 ? "..." : "");
            try {
              localStorage.setItem(Fs, JSON.stringify(r)), s = true;
            } catch {
              s = false;
            }
          }
          return new Promise((c) => c());
        }
        return ur(U(E({}, t), { logCount: i, removeLastLog: true }));
      }
    };
    var mi = xe("Raydium_Api");
    var Mu = /* @__PURE__ */ new Map();
    var vu = /* @__PURE__ */ new Map();
    async function yy(i, e, t = 1e3) {
      let n;
      for (; n == null; )
        try {
          mi.debug(`Request ${i} through endlessRetry`), n = await e();
        } catch (o) {
          mi.error(`Request ${i} failed, retry after ${t} ms`, o), await Cu(t);
        }
      return n;
    }
    var cr = class {
      constructor({ cluster: e, timeout: t, logRequests: n, logCount: o, urlConfigs: r }) {
        this.cluster = e, this.urlConfigs = r || {}, this.logCount = o || 1e3, this.api = Fu.default.create({ baseURL: this.urlConfigs.BASE_HOST || (this.cluster === "devnet" ? Nu.BASE_HOST : It.BASE_HOST), timeout: t }), this.api.interceptors.request.use((s) => {
          let { method: a, baseURL: c, url: u } = s;
          return mi.debug(`${a == null ? void 0 : a.toUpperCase()} ${c}${u}`), s;
        }, (s) => (mi.error("Request failed"), Promise.reject(s))), this.api.interceptors.response.use((s) => {
          let { config: a, data: c, status: u } = s, { method: l, baseURL: m, url: d } = a;
          return n && ur({ status: u, url: `${m}${d}`, params: a.params, data: c, logCount: this.logCount }), mi.debug(`${l == null ? void 0 : l.toUpperCase()} ${m}${d}  ${u}`), c;
        }, (s) => {
          let { config: a, response: c = {} } = s, { status: u } = c, { method: l, baseURL: m, url: d } = a;
          return n && ur({ status: u, url: `${m}${d}`, params: a.params, data: s.message, logCount: this.logCount }), mi.error(`${l.toUpperCase()} ${m}${d} ${u || s.message}`), Promise.reject(s);
        });
      }
      async getClmmConfigs() {
        return (await this.api.get(this.urlConfigs.CLMM_CONFIG || It.CLMM_CONFIG)).data;
      }
      async getCpmmConfigs() {
        return (await this.api.get(this.urlConfigs.CPMM_CONFIG || It.CPMM_CONFIG)).data;
      }
      async getClmmPoolLines(e) {
        return (await this.api.get(`${this.urlConfigs.POOL_LIQUIDITY_LINE || It.POOL_LIQUIDITY_LINE}?id=${e}`)).data;
      }
      async getBlockSlotCountForSecond(e) {
        if (!e)
          return 2;
        let n = (await Fu.default.post(e, { id: "getRecentPerformanceSamples", jsonrpc: "2.0", method: "getRecentPerformanceSamples", params: [4] })).result.map((o) => o.numSlots);
        return n.reduce((o, r) => o + r, 0) / n.length / 60;
      }
      async getChainTimeOffset() {
        return (await this.api.get(this.urlConfigs.CHAIN_TIME || It.CHAIN_TIME)).data;
      }
      async getRpcs() {
        return this.api.get(this.urlConfigs.RPCS || It.RPCS);
      }
      async getTokenList() {
        return (await this.api.get(this.urlConfigs.TOKEN_LIST || It.TOKEN_LIST)).data;
      }
      async getJupTokenList() {
        return (await this.api.get("", { baseURL: this.urlConfigs.JUP_TOKEN_LIST || It.JUP_TOKEN_LIST })).map((t) => U(E({}, t), { chainId: 101, programId: t.tokenProgram, address: t.id, logoURI: t.icon, extensions: {}, freeze_authority: null, permanent_delegate: null, mint_authority: t.mintAuthority || null, minted_at: Date.now().toString() }));
      }
      async getTokenInfo(e) {
        return (await this.api.get((this.urlConfigs.MINT_INFO_ID || It.MINT_INFO_ID) + `?mints=${e.map((n) => n.toString()).join(",")}`)).data;
      }
      async getPoolList(e = {}) {
        let { type: t = "all", sort: n = "liquidity", order: o = "desc", page: r = 0, pageSize: s = 100 } = e;
        return (await this.api.get((this.urlConfigs.POOL_LIST || It.POOL_LIST) + `?poolType=${t}&poolSortField=${n}&sortType=${o}&page=${r}&pageSize=${s}`)).data;
      }
      async fetchPoolById(e) {
        let { ids: t } = e;
        return (await this.api.get((this.urlConfigs.POOL_SEARCH_BY_ID || It.POOL_SEARCH_BY_ID) + `?ids=${t}`)).data;
      }
      async fetchPoolKeysById(e) {
        let { idList: t } = e, n = [], o = t.filter((s) => Mu.has(s) ? (n.push(Mu.get(s)), false) : true), r = [];
        return o.length && (r = (await this.api.get((this.urlConfigs.POOL_KEY_BY_ID || It.POOL_KEY_BY_ID) + `?ids=${o.join(",")}`)).data.filter(Boolean), r.forEach((a) => {
          Mu.set(a.id, a);
        })), n.concat(r);
      }
      async fetchPoolByMints(e) {
        let { mint1: t, mint2: n, type: o = "all", sort: r = "default", order: s = "desc", page: a = 1 } = e, [c, u] = [t && Lt(t).toBase58(), n && n !== "undefined" ? Lt(n).toBase58() : ""], [l, m] = u && c > u ? [u, c] : [c, u];
        return (await this.api.get((this.urlConfigs.POOL_SEARCH_MINT || It.POOL_SEARCH_MINT) + `?mint1=${l}&mint2=${m}&poolType=${o}&poolSortField=${r}&sortType=${s}&pageSize=100&page=${a}`)).data;
      }
      async fetchFarmInfoById(e) {
        let { ids: t } = e;
        return (await this.api.get((this.urlConfigs.FARM_INFO || It.FARM_INFO) + `?ids=${t}`)).data;
      }
      async fetchFarmKeysById(e) {
        let { ids: t } = e;
        return (await this.api.get((this.urlConfigs.FARM_KEYS || It.FARM_KEYS) + `?ids=${t}`)).data;
      }
      async fetchAvailabilityStatus() {
        return (await this.api.get(this.urlConfigs.CHECK_AVAILABILITY || It.CHECK_AVAILABILITY)).data;
      }
      async fetchLaunchConfigs() {
        var t;
        if ((t = vu.get(this.cluster)) != null && t.length)
          return vu.get(this.cluster);
        let e = await this.api.get(this.cluster === "devnet" ? "https://launch-mint-v1-devnet.raydium.io/main/configs" : "https://launch-mint-v1.raydium.io/main/configs");
        return vu.set(this.cluster, e.data.data), e.data.data;
      }
    };
    var bp = require_lodash();
    var Vs = "please provide owner in load() initialization or you can set by calling raydium.setOwner(owner)";
    var _m = "please provide connection in load() initialization or set it by raydium.setConnection(connection)";
    var Wo = require("@solana/web3.js");
    var ct = require_cjs4();
    var Vu = (...i) => i.map((e) => {
      try {
        return typeof e == "object" ? JSON.stringify(e) : e;
      } catch {
        return e;
      }
    }).join(", ");
    var Je = class {
      constructor({ scope: e, moduleName: t }) {
        this.disabled = false;
        this.scope = e, this.logger = xe(t);
      }
      createTxBuilder(e) {
        return this.scope.checkOwner(), new ar({ connection: this.scope.connection, feePayer: e || this.scope.ownerPubKey, cluster: this.scope.cluster, owner: this.scope.owner, blockhashCommitment: this.scope.blockhashCommitment, loopMultiTxStatus: this.scope.loopMultiTxStatus, api: this.scope.api, signAllTransactions: this.scope.signAllTransactions });
      }
      logDebug(...e) {
        this.logger.debug(Vu(e));
      }
      logInfo(...e) {
        this.logger.info(Vu(e));
      }
      logAndCreateError(...e) {
        let t = Vu(e);
        throw new Error(t);
      }
      checkDisabled() {
        (this.disabled || !this.scope) && this.logAndCreateError("module not working");
      }
    };
    var Hs = require("@solana/web3.js");
    var ed = Ae(require_bn());
    var ln2 = require_cjs4();
    var dr = require("@solana/web3.js");
    var $m = Ae(require_bn());
    var Jm = require_cjs4();
    function by(i) {
      return i instanceof Uint8Array || i != null && typeof i == "object" && i.constructor.name === "Uint8Array";
    }
    function _u(i, ...e) {
      if (!by(i))
        throw new Error("Uint8Array expected");
      if (e.length > 0 && !e.includes(i.length))
        throw new Error(`Uint8Array expected of length ${e}, not of length=${i.length}`);
    }
    function Eu(i, e = true) {
      if (i.destroyed)
        throw new Error("Hash instance has been destroyed");
      if (e && i.finished)
        throw new Error("Hash#digest() has already been called");
    }
    function Em(i, e) {
      _u(i);
      let t = e.outputLen;
      if (i.length < t)
        throw new Error(`digestInto() expects output buffer of length at least ${t}`);
    }
    var Es = (i) => new DataView(i.buffer, i.byteOffset, i.byteLength);
    var Ln = (i, e) => i << 32 - e | i >>> e;
    var aw = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
    function gy(i) {
      if (typeof i != "string")
        throw new Error(`utf8ToBytes expected string, got ${typeof i}`);
      return new Uint8Array(new TextEncoder().encode(i));
    }
    function Wu(i) {
      return typeof i == "string" && (i = gy(i)), _u(i), i;
    }
    var _s = class {
      clone() {
        return this._cloneInto();
      }
    };
    var uw = {}.toString;
    function Wm(i) {
      let e = (n) => i().update(Wu(n)).digest(), t = i();
      return e.outputLen = t.outputLen, e.blockLen = t.blockLen, e.create = () => i(), e;
    }
    function Py(i, e, t, n) {
      if (typeof i.setBigUint64 == "function")
        return i.setBigUint64(e, t, n);
      let o = BigInt(32), r = BigInt(4294967295), s = Number(t >> o & r), a = Number(t & r), c = n ? 4 : 0, u = n ? 0 : 4;
      i.setUint32(e + c, s, n), i.setUint32(e + u, a, n);
    }
    var Dm = (i, e, t) => i & e ^ ~i & t;
    var qm = (i, e, t) => i & e ^ i & t ^ e & t;
    var Ws = class extends _s {
      constructor(e, t, n, o) {
        super(), this.blockLen = e, this.outputLen = t, this.padOffset = n, this.isLE = o, this.finished = false, this.length = 0, this.pos = 0, this.destroyed = false, this.buffer = new Uint8Array(e), this.view = Es(this.buffer);
      }
      update(e) {
        Eu(this);
        let { view: t, buffer: n, blockLen: o } = this;
        e = Wu(e);
        let r = e.length;
        for (let s = 0; s < r; ) {
          let a = Math.min(o - this.pos, r - s);
          if (a === o) {
            let c = Es(e);
            for (; o <= r - s; s += o)
              this.process(c, s);
            continue;
          }
          n.set(e.subarray(s, s + a), this.pos), this.pos += a, s += a, this.pos === o && (this.process(t, 0), this.pos = 0);
        }
        return this.length += e.length, this.roundClean(), this;
      }
      digestInto(e) {
        Eu(this), Em(e, this), this.finished = true;
        let { buffer: t, view: n, blockLen: o, isLE: r } = this, { pos: s } = this;
        t[s++] = 128, this.buffer.subarray(s).fill(0), this.padOffset > o - s && (this.process(n, 0), s = 0);
        for (let m = s; m < o; m++)
          t[m] = 0;
        Py(n, o - 8, BigInt(this.length * 8), r), this.process(n, 0);
        let a = Es(e), c = this.outputLen;
        if (c % 4)
          throw new Error("_sha2: outputLen should be aligned to 32bit");
        let u = c / 4, l = this.get();
        if (u > l.length)
          throw new Error("_sha2: outputLen bigger than state");
        for (let m = 0; m < u; m++)
          a.setUint32(4 * m, l[m], r);
      }
      digest() {
        let { buffer: e, outputLen: t } = this;
        this.digestInto(e);
        let n = e.slice(0, t);
        return this.destroy(), n;
      }
      _cloneInto(e) {
        e || (e = new this.constructor()), e.set(...this.get());
        let { blockLen: t, buffer: n, length: o, finished: r, destroyed: s, pos: a } = this;
        return e.length = o, e.pos = a, e.finished = r, e.destroyed = s, o % t && e.buffer.set(n), e;
      }
    };
    var Ay = new Uint32Array([1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298]);
    var wo = new Uint32Array([1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225]);
    var ko = new Uint32Array(64);
    var Du = class extends Ws {
      constructor() {
        super(64, 32, 8, false), this.A = wo[0] | 0, this.B = wo[1] | 0, this.C = wo[2] | 0, this.D = wo[3] | 0, this.E = wo[4] | 0, this.F = wo[5] | 0, this.G = wo[6] | 0, this.H = wo[7] | 0;
      }
      get() {
        let { A: e, B: t, C: n, D: o, E: r, F: s, G: a, H: c } = this;
        return [e, t, n, o, r, s, a, c];
      }
      set(e, t, n, o, r, s, a, c) {
        this.A = e | 0, this.B = t | 0, this.C = n | 0, this.D = o | 0, this.E = r | 0, this.F = s | 0, this.G = a | 0, this.H = c | 0;
      }
      process(e, t) {
        for (let m = 0; m < 16; m++, t += 4)
          ko[m] = e.getUint32(t, false);
        for (let m = 16; m < 64; m++) {
          let d = ko[m - 15], p = ko[m - 2], f = Ln(d, 7) ^ Ln(d, 18) ^ d >>> 3, y = Ln(p, 17) ^ Ln(p, 19) ^ p >>> 10;
          ko[m] = y + ko[m - 7] + f + ko[m - 16] | 0;
        }
        let { A: n, B: o, C: r, D: s, E: a, F: c, G: u, H: l } = this;
        for (let m = 0; m < 64; m++) {
          let d = Ln(a, 6) ^ Ln(a, 11) ^ Ln(a, 25), p = l + d + Dm(a, c, u) + Ay[m] + ko[m] | 0, y = (Ln(n, 2) ^ Ln(n, 13) ^ Ln(n, 22)) + qm(n, o, r) | 0;
          l = u, u = c, c = a, a = s + p | 0, s = r, r = o, o = n, n = p + y | 0;
        }
        n = n + this.A | 0, o = o + this.B | 0, r = r + this.C | 0, s = s + this.D | 0, a = a + this.E | 0, c = c + this.F | 0, u = u + this.G | 0, l = l + this.H | 0, this.set(n, o, r, s, a, c, u, l);
      }
      roundClean() {
        ko.fill(0);
      }
      destroy() {
        this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
      }
    };
    var Um = Wm(() => new Du());
    var Hm = require("@solana/web3.js");
    var pi = Ae(require_bn());
    var H = require_Layout();
    var di = H.Layout;
    var Gm = H.Structure;
    var Xm = H.Union;
    var wy = H.BitStructure;
    var Ds = H.UInt;
    var qu = H.Blob;
    var ky = H.greedy;
    var qs = H.u8;
    var on = H.u16;
    var hy = H.u24;
    var lr = H.u32;
    var Ty = H.u40;
    var Iy = H.u48;
    var Uu = H.nu64;
    var By = H.u16be;
    var xy = H.u24be;
    var Sy = H.u32be;
    var Ky = H.u40be;
    var Cy = H.u48be;
    var Ry = H.nu64be;
    var Ly = H.s8;
    var Ny = H.s16;
    var Oy = H.s24;
    var je = H.s32;
    var My = H.s40;
    var vy = H.s48;
    var Fy = H.ns64;
    var Vy = H.s16be;
    var _y = H.s24be;
    var Ey = H.s32be;
    var Wy = H.s40be;
    var Dy = H.s48be;
    var qy = H.ns64be;
    var Uy = H.f32;
    var Gy = H.f32be;
    var Xy = H.f64;
    var zy = H.f64be;
    var zm = H.seq;
    var Ym = H.union;
    var Yy = H.unionLayoutDiscriminator;
    var Fe = H.blob;
    var Hy = H.cstr;
    var Qy = H.utf8;
    var Us = H.bits;
    var Gs = H.offset;
    var ho = class extends di {
      constructor(t, n, o) {
        super(t, o);
        this.blob = Fe(t), this.signed = n;
      }
      decode(t, n = 0) {
        let o = new pi.default(this.blob.decode(t, n), 10, "le");
        return this.signed ? o.fromTwos(this.span * 8).clone() : o;
      }
      encode(t, n, o = 0) {
        return typeof t == "number" && (t = new pi.default(t)), this.signed && (t = t.toTwos(this.span * 8)), this.blob.encode(t.toArrayLike(Buffer, "le", this.span), n, o);
      }
    };
    var mr = class extends di {
      constructor(t) {
        super(8, t);
        this._lower = Us(lr(), false), this._upper = Us(lr(), false);
      }
      addBoolean(t) {
        this._lower.fields.length < 32 ? this._lower.addBoolean(t) : this._upper.addBoolean(t);
      }
      decode(t, n = 0) {
        let o = this._lower.decode(t, n), r = this._upper.decode(t, n + this._lower.span);
        return E(E({}, o), r);
      }
      encode(t, n, o = 0) {
        return this._lower.encode(t, n, o) + this._upper.encode(t, n, o + this._lower.span);
      }
    };
    function W(i) {
      return new Ds(1, i);
    }
    function St(i) {
      return new Ds(4, i);
    }
    function P2(i) {
      return new ho(8, false, i);
    }
    function ae(i) {
      return new ho(16, false, i);
    }
    function Xu(i) {
      return new ho(1, true, i);
    }
    function Eo(i) {
      return new ho(8, true, i);
    }
    function zu(i) {
      return new ho(16, true, i);
    }
    var Wn = class extends di {
      constructor(t, n, o, r) {
        super(t.span, r);
        this.layout = t, this.decoder = n, this.encoder = o;
      }
      decode(t, n) {
        return this.decoder(this.layout.decode(t, n));
      }
      encode(t, n, o) {
        return this.layout.encode(this.encoder(t), n, o);
      }
      getSpan(t, n) {
        return this.layout.getSpan(t, n);
      }
    };
    function F(i) {
      return new Wn(Fe(32), (e) => new Hm.PublicKey(e), (e) => e.toBuffer(), i);
    }
    var Xs = class extends di {
      constructor(t, n) {
        super(-1, n);
        this.layout = t, this.discriminator = qs();
      }
      encode(t, n, o = 0) {
        return t == null ? this.discriminator.encode(0, n, o) : (this.discriminator.encode(1, n, o), this.layout.encode(t, n, o + 1) + 1);
      }
      decode(t, n = 0) {
        let o = this.discriminator.decode(t, n);
        if (o === 0)
          return null;
        if (o === 1)
          return this.layout.decode(t, n + 1);
        throw new Error("Invalid option " + this.property);
      }
      getSpan(t, n = 0) {
        let o = this.discriminator.decode(t, n);
        if (o === 0)
          return 1;
        if (o === 1)
          return this.layout.getSpan(t, n + 1) + 1;
        throw new Error("Invalid option " + this.property);
      }
    };
    function jy(i, e) {
      return new Xs(i, e);
    }
    function Ze(i) {
      return new Wn(qs(), Qm, jm, i);
    }
    function Qm(i) {
      if (i === 0)
        return false;
      if (i === 1)
        return true;
      throw new Error("Invalid bool: " + i);
    }
    function jm(i) {
      return i ? 1 : 0;
    }
    function Yu(i, e) {
      let t = lr("length"), n = V([t, Z(i, Gs(t, -t.span), "values")]);
      return new Wn(n, ({ values: o }) => o, (o) => ({ values: o }), e);
    }
    function Zy(i, e, t) {
      let n = V([P2("tag"), e.replicate("data")]);
      function o({ tag: r, data: s }) {
        if (!r.eq(i))
          throw new Error("Invalid tag, expected: " + i.toString("hex") + ", got: " + r.toString("hex"));
        return s;
      }
      return new Wn(n, o, (r) => ({ tag: i, data: r }), t);
    }
    function Zm(i) {
      let e = lr("length"), t = V([e, Fe(Gs(e, -e.span), "data")]);
      return new Wn(t, ({ data: n }) => n, (n) => ({ data: n }), i);
    }
    function Kt(i) {
      return new Wn(Zm(), (e) => e.toString("utf-8"), (e) => Buffer.from(e, "utf-8"), i);
    }
    function $y(i, e) {
      let t = Ym(qs(), e);
      return i.forEach((n, o) => t.addVariant(o, n, n.property)), t;
    }
    function Jy(i, e, t) {
      let n = V([Z(i, e, "values")]);
      return new Wn(n, ({ values: o }) => o, (o) => ({ values: o }), t);
    }
    var zs = class extends Gm {
      decode(e, t) {
        return super.decode(e, t);
      }
    };
    function V(i, e, t) {
      return new zs(i, e, t);
    }
    var Ys = class extends Xm {
      encodeInstruction(e) {
        let t = Math.max(...Object.values(this.registry).map((o) => o.span)), n = Buffer.alloc(t);
        return n.slice(0, this.encode(e, n));
      }
      decodeInstruction(e) {
        return this.decode(e);
      }
    };
    function eb(i, e, t) {
      return new Ys(i, e, t);
    }
    var Gu = class extends qu {
      decode(e, t) {
        let n = super.decode(e, t);
        if (!n.every((o) => o === 0))
          throw new Error("nonzero padding bytes");
        return n;
      }
    };
    function tb(i) {
      return new Gu(i);
    }
    function Z(i, e, t) {
      let n, o = typeof e == "number" ? e : (0, pi.isBN)(e) ? e.toNumber() : new Proxy(e, { get(r, s) {
        if (!n) {
          let a = Reflect.get(r, "count");
          n = (0, pi.isBN)(a) ? a.toNumber() : a, Reflect.set(r, "count", n);
        }
        return Reflect.get(r, s);
      }, set(r, s, a) {
        return s === "count" && (n = a), Reflect.set(r, s, a);
      } });
      return zm(i, o, t);
    }
    var kn = V([F("mint"), F("owner"), P2("amount"), St("delegateOption"), F("delegate"), W("state"), St("isNativeOption"), P2("isNative"), P2("delegatedAmount"), St("closeAuthorityOption"), F("closeAuthority")]);
    var Kw = xe("Raydium_Util");
    function Hu({ owner: i, solAccountResp: e, tokenAccountResp: t }) {
      let n = [], o = [];
      for (let { pubkey: r, account: s } of t.value) {
        let a = kn.decode(s.data), { mint: c, amount: u } = a;
        n.push({ publicKey: r, mint: c, amount: u, isAssociated: te(i, c, s.owner).publicKey.equals(r), isNative: false, programId: s.owner }), o.push({ pubkey: r, accountInfo: a, programId: s.owner });
      }
      return e && n.push({ mint: dr.PublicKey.default, amount: new $m.default(String(e.lamports)), isNative: true, programId: e.owner }), { tokenAccounts: n, tokenAccountRawInfos: o };
    }
    function rt({ fromPublicKey: i, programId: e = Jm.TOKEN_PROGRAM_ID, assignSeed: t }) {
      let n = t ? btoa(t).slice(0, 32) : dr.Keypair.generate().publicKey.toBase58().slice(0, 32);
      return { publicKey: nb(i, n, e), seed: n };
    }
    function nb(i, e, t) {
      let n = Buffer.concat([i.toBuffer(), Buffer.from(e), t.toBuffer()]), o = Um(n);
      return new dr.PublicKey(o);
    }
    function Qs(i) {
      let { mint: e, tokenAccount: t, owner: n, programId: o = ln2.TOKEN_PROGRAM_ID } = i;
      return (0, ln2.createInitializeAccountInstruction)(t, e, n, o);
    }
    function Dn(i) {
      let { tokenAccount: e, payer: t, multiSigners: n = [], owner: o, programId: r = ln2.TOKEN_PROGRAM_ID } = i;
      return (0, ln2.createCloseAccountInstruction)(e, t, o, n, r);
    }
    async function to(i) {
      let { connection: e, amount: t, commitment: n, payer: o, owner: r, skipCloseAccount: s } = i, a = await e.getMinimumBalanceForRentExemption(kn.span, n), c = oe(t).add(new ed.default(a)), u = rt({ fromPublicKey: o, programId: ln2.TOKEN_PROGRAM_ID });
      return { addresses: { newAccount: u.publicKey }, signers: [], instructions: [Hs.SystemProgram.createAccountWithSeed({ fromPubkey: o, basePubkey: o, seed: u.seed, newAccountPubkey: u.publicKey, lamports: c.toNumber(), space: kn.span, programId: ln2.TOKEN_PROGRAM_ID }), Qs({ mint: new Hs.PublicKey(kt.address), tokenAccount: u.publicKey, owner: r, programId: ln2.TOKEN_PROGRAM_ID })], instructionTypes: [X.CreateAccount, X.InitAccount], endInstructionTypes: s ? [] : [X.CloseAccount], endInstructions: s ? [] : [Dn({ tokenAccount: u.publicKey, payer: o, owner: r })] };
    }
    function Qu({ source: i, destination: e, owner: t, amount: n, multiSigners: o = [], tokenProgram: r = ln2.TOKEN_PROGRAM_ID }) {
      return (0, ln2.createTransferInstruction)(i, e, t, BigInt(String(n)), o, r);
    }
    var pr = class extends Je {
      constructor(t) {
        super(t);
        this._tokenAccounts = [];
        this._tokenAccountRawInfos = [];
        this._accountListener = [];
        this._clientOwnedToken = false;
        this._notSubscribeAccountChange = false;
        this._accountFetchTime = 0;
        let { tokenAccounts: n, tokenAccountRawInfos: o, notSubscribeAccountChange: r } = t;
        this._tokenAccounts = n || [], this._tokenAccountRawInfos = o || [], this._notSubscribeAccountChange = r != null ? r : true, this._clientOwnedToken = !!(n || o);
      }
      get tokenAccounts() {
        return this._tokenAccounts;
      }
      get tokenAccountRawInfos() {
        return this._tokenAccountRawInfos;
      }
      set notSubscribeAccountChange(t) {
        this._notSubscribeAccountChange = t;
      }
      updateTokenAccount({ tokenAccounts: t, tokenAccountRawInfos: n }) {
        return t && (this._tokenAccounts = t), n && (this._tokenAccountRawInfos = n), this._accountChangeListenerId && this.scope.connection.removeAccountChangeListener(this._accountChangeListenerId), this._accountChangeListenerId = void 0, this._clientOwnedToken = true, this;
      }
      addAccountChangeListener(t) {
        return this._accountListener.push(t), this;
      }
      removeAccountChangeListener(t) {
        return this._accountListener = this._accountListener.filter((n) => n !== t), this;
      }
      getAssociatedTokenAccount(t, n) {
        return te(this.scope.ownerPubKey, t, n).publicKey;
      }
      resetTokenAccounts() {
        this._clientOwnedToken || (this._tokenAccounts = [], this._tokenAccountRawInfos = []);
      }
      async fetchWalletTokenAccounts(t) {
        if (this._clientOwnedToken || !(t != null && t.forceUpdate) && this._tokenAccounts.length && Date.now() - this._accountFetchTime < (this._notSubscribeAccountChange ? 1e3 * 5 : 1e3 * 60 * 3))
          return { tokenAccounts: this._tokenAccounts, tokenAccountRawInfos: this._tokenAccountRawInfos };
        this.scope.checkOwner();
        let o = E(E({}, {}), t), [r, s, a] = await Promise.all([this.scope.connection.getAccountInfo(this.scope.ownerPubKey, o.commitment), this.scope.connection.getTokenAccountsByOwner(this.scope.ownerPubKey, { programId: ct.TOKEN_PROGRAM_ID }, o.commitment), this.scope.connection.getTokenAccountsByOwner(this.scope.ownerPubKey, { programId: ct.TOKEN_2022_PROGRAM_ID }, o.commitment)]), { tokenAccounts: c, tokenAccountRawInfos: u } = Hu({ owner: this.scope.ownerPubKey, solAccountResp: r, tokenAccountResp: { context: s.context, value: [...s.value, ...a.value] } });
        return this._tokenAccounts = c, this._tokenAccountRawInfos = u, this._accountFetchTime = Date.now(), this._notSubscribeAccountChange || (this._accountChangeListenerId && this.scope.connection.removeAccountChangeListener(this._accountChangeListenerId), this._accountChangeListenerId = this.scope.connection.onAccountChange(this.scope.ownerPubKey, () => {
          this.fetchWalletTokenAccounts({ forceUpdate: true }), this._accountListener.forEach((l) => l({ tokenAccounts: this._tokenAccounts, tokenAccountRawInfos: this._tokenAccountRawInfos }));
        }, { commitment: t == null ? void 0 : t.commitment })), { tokenAccounts: c, tokenAccountRawInfos: u };
      }
      clearAccountChangeCkb() {
        this._accountChangeListenerId !== void 0 && this.scope.connection.removeAccountChangeListener(this._accountChangeListenerId);
      }
      async getCreatedTokenAccount({ mint: t, programId: n = ct.TOKEN_PROGRAM_ID, associatedOnly: o = true }) {
        await this.fetchWalletTokenAccounts();
        let r = this._tokenAccounts.filter(({ mint: a }) => a == null ? void 0 : a.equals(t)).sort((a, c) => a.amount.lt(c.amount) ? 1 : -1), s = this.getAssociatedTokenAccount(t, n);
        for (let a of r) {
          let { publicKey: c } = a;
          if (c && (!o || o && s.equals(c)))
            return c;
        }
      }
      async getOrCreateTokenAccount(t) {
        var y, b, g, A;
        await this.fetchWalletTokenAccounts();
        let { mint: n, createInfo: o, associatedOnly: r, owner: s, notUseTokenAccount: a = false, skipCloseAccount: c = false, checkCreateATAOwner: u = false, assignSeed: l } = t, m = new Wo.PublicKey(t.tokenProgram || ct.TOKEN_PROGRAM_ID), d = this.getAssociatedTokenAccount(n, new Wo.PublicKey(m)), p = (a ? [] : this.tokenAccountRawInfos).filter((k) => k.accountInfo.mint.equals(n) && (!r || k.pubkey.equals(d))).sort((k, I) => k.accountInfo.amount.lt(I.accountInfo.amount) ? 1 : -1);
        if (o === void 0 || p.length > 0)
          return p.length > 0 ? { account: p[0].pubkey } : {};
        let f = { instructions: [], endInstructions: [], signers: [], instructionTypes: [], endInstructionTypes: [] };
        if (r) {
          let k = (0, ct.createAssociatedTokenAccountIdempotentInstruction)(s, d, s, n, m), I = this.tokenAccountRawInfos.find((T) => T.pubkey.equals(d));
          if (u) {
            let T = await this.scope.connection.getAccountInfo(d);
            if (T === null)
              (y = f.instructions) == null || y.push(k), f.instructionTypes.push(X.CreateATA);
            else if (!(T.owner.equals(m) && ct.AccountLayout.decode(T.data).mint.equals(n) && ct.AccountLayout.decode(T.data).owner.equals(s)))
              throw Error(`create ata check error -> mint: ${n.toString()}, ata: ${d.toString()}`);
          } else
            I === void 0 && (f.instructions.push(k), f.instructionTypes.push(X.CreateATA));
          if (n.equals(ee) && o.amount) {
            let T = await to({ connection: this.scope.connection, owner: this.scope.ownerPubKey, payer: o.payer || this.scope.ownerPubKey, amount: (b = o.amount) != null ? b : 0, skipCloseAccount: c });
            f.instructions.push(...T.instructions || []), f.endInstructions.push(...T.endInstructions || []), f.instructionTypes.push(...T.instructionTypes || []), f.endInstructionTypes.push(...T.endInstructionTypes || []), o.amount && (f.instructions.push(Qu({ source: T.addresses.newAccount, destination: d, owner: this.scope.ownerPubKey, amount: o.amount, tokenProgram: ct.TOKEN_PROGRAM_ID })), f.instructionTypes.push(X.TransferAmount));
          }
          return !c && I === void 0 && (f.endInstructions.push(Dn({ owner: s, payer: o.payer || s, tokenAccount: d, programId: m })), f.endInstructionTypes.push(X.CloseAccount)), { account: d, instructionParams: f };
        } else {
          let k = rt({ fromPublicKey: s, programId: m, assignSeed: l }), I = await this.scope.connection.getMinimumBalanceForRentExemption(ct.AccountLayout.span), T = Wo.SystemProgram.createAccountWithSeed({ fromPubkey: s, basePubkey: s, seed: k.seed, newAccountPubkey: k.publicKey, lamports: I + Number((A = (g = o.amount) == null ? void 0 : g.toString()) != null ? A : 0), space: ct.AccountLayout.span, programId: m });
          return f.instructions.push(T, Qs({ mint: n, tokenAccount: k.publicKey, owner: this.scope.ownerPubKey, programId: m })), f.instructionTypes.push(X.CreateAccount), f.instructionTypes.push(X.InitAccount), c || (f.endInstructions.push(Dn({ owner: s, payer: o.payer || s, tokenAccount: k.publicKey, programId: m })), f.endInstructionTypes.push(X.CloseAccount)), { account: k.publicKey, instructionParams: f };
        }
      }
      async checkOrCreateAta({ mint: t, programId: n = ct.TOKEN_PROGRAM_ID, autoUnwrapWSOLToSOL: o }) {
        var c;
        await this.fetchWalletTokenAccounts();
        let r = (c = this.scope.account.tokenAccounts.find(({ mint: u }) => (u == null ? void 0 : u.toBase58()) === t.toBase58())) == null ? void 0 : c.publicKey, s = this.scope.ownerPubKey, a = {};
        if (!r) {
          let u = this.getAssociatedTokenAccount(t, n), l = await (0, ct.createAssociatedTokenAccountIdempotentInstruction)(s, u, s, t, n);
          a.instructions = [l], a.instructionTypes = [X.CreateATA], r = u;
        }
        return o && ee.toBase58() === t.toBase58() && (a.endInstructions = [Dn({ owner: s, payer: s, tokenAccount: r, programId: n })], a.endInstructionTypes = [X.CloseAccount]), { pubKey: r, newInstructions: a };
      }
      async handleTokenAccount(t) {
        let { side: n, amount: o, mint: r, programId: s = ct.TOKEN_PROGRAM_ID, tokenAccount: a, payer: c = this.scope.ownerPubKey, bypassAssociatedCheck: u, skipCloseAccount: l, checkCreateATAOwner: m } = t, d = this.getAssociatedTokenAccount(r, s);
        if (new Wo.PublicKey(ee).equals(r)) {
          let p = await to({ connection: this.scope.connection, owner: this.scope.ownerPubKey, payer: c, amount: o, skipCloseAccount: l });
          return E({ tokenAccount: p.addresses.newAccount }, p);
        } else if (!a || n === "out" && !d.equals(a) && !u) {
          let p = [], f = (0, ct.createAssociatedTokenAccountIdempotentInstruction)(this.scope.ownerPubKey, d, this.scope.ownerPubKey, r, s);
          if (m) {
            let y = await this.scope.connection.getAccountInfo(d);
            if (y === null)
              p.push(f);
            else if (!(y.owner.equals(ct.TOKEN_PROGRAM_ID) && ct.AccountLayout.decode(y.data).mint.equals(r) && ct.AccountLayout.decode(y.data).owner.equals(this.scope.ownerPubKey)))
              throw Error(`create ata check error -> mint: ${r.toString()}, ata: ${d.toString()}`);
          } else
            p.push(f);
          return { tokenAccount: d, instructions: p, instructionTypes: [X.CreateATA] };
        }
        return { tokenAccount: a };
      }
      async processTokenAccount(t) {
        let { mint: n, programId: o = ct.TOKEN_PROGRAM_ID, amount: r, useSOLBalance: s, handleTokenAccount: a, feePayer: c } = t, u, l = this.createTxBuilder(c);
        if (n.equals(new Wo.PublicKey(ee)) && s) {
          let m = await this.handleTokenAccount({ side: "in", amount: r || 0, mint: n, bypassAssociatedCheck: true, programId: o }), { tokenAccount: p } = m, f = tt(m, ["tokenAccount"]);
          u = p, l.addInstruction(f);
        } else if (u = await this.getCreatedTokenAccount({ mint: n, associatedOnly: false, programId: o }), !u && a) {
          let d = await this.scope.account.handleTokenAccount({ side: "in", amount: 0, mint: n, bypassAssociatedCheck: true, programId: o }), { tokenAccount: p } = d, f = tt(d, ["tokenAccount"]);
          u = p, l.addInstruction(f);
        }
        return E({ tokenAccount: u }, l.AllTxData);
      }
    };
    var Ve = require("@solana/web3.js");
    var fc = require_cjs4();
    var ta = require("@solana/web3.js");
    var js = V([W("instruction")]);
    var Zs = V([W("instruction")]);
    var ob = V([P2("rewardState"), P2("rewardOpenTime"), P2("rewardEndTime"), P2("rewardLastUpdateTime"), P2("totalReward"), P2("totalRewardEmissioned"), P2("rewardClaimed"), P2("rewardPerSecond"), ae("accRewardPerShare"), F("rewardVault"), F("rewardMint"), F("rewardSender"), P2("rewardType"), Z(P2(), 15, "padding")]);
    var td = V([P2("state"), P2("nonce"), F("lpVault"), F("rewardVault"), F(), F(), P2(), P2(), P2("totalReward"), ae("perShareReward"), P2("lastSlot"), P2("perSlotReward")]);
    var nd = V([P2("state"), P2("nonce"), F("lpVault"), F("rewardVaultA"), P2("totalRewardA"), ae("perShareRewardA"), P2("perSlotRewardA"), W("option"), F("rewardVaultB"), Fe(7), P2("totalRewardB"), ae("perShareRewardB"), P2("perSlotRewardB"), P2("lastSlot"), F()]);
    var od = V([P2(), P2("state"), P2("nonce"), P2("validRewardTokenNum"), ae("rewardMultiplier"), P2("rewardPeriodMax"), P2("rewardPeriodMin"), P2("rewardPeriodExtend"), F("lpMint"), F("lpVault"), Z(ob, 5, "rewardInfos"), F("creator"), F(), Z(P2(), 32, "padding")]);
    var ju = new Proxy(td, { get(i, e, t) {
      return e === "decode" ? (...n) => {
        let o = i.decode(...n);
        return U(E({}, o), { version: 3, rewardInfos: [{ rewardVault: o.rewardVault, totalReward: o.totalReward, perSlotReward: o.perSlotReward, perShareReward: o.perShareReward }] });
      } : Reflect.get(i, e, t);
    } });
    var Zu = new Proxy(nd, { get(i, e, t) {
      return e === "decode" ? (...n) => {
        let o = i.decode(...n);
        return U(E({}, o), { version: 5, rewardInfos: [{ rewardVault: o.rewardVaultA, totalReward: o.totalRewardA, perSlotReward: o.perSlotRewardA, perShareReward: o.perShareRewardA }, { rewardVault: o.rewardVaultB, totalReward: o.totalRewardB, perSlotReward: o.perSlotRewardB, perShareReward: o.perShareRewardB }] });
      } : Reflect.get(i, e, t);
    } });
    var fi = new Proxy(od, { get(i, e, t) {
      return e === "decode" ? (...n) => {
        let o = i.decode(...n);
        return U(E({}, o), { version: 6, rewardInfos: o.rewardInfos.map((r) => {
          var s;
          return U(E({}, r), { rewardType: ((s = Object.entries(no).find((a) => String(a[1]) === r.rewardType.toString())) != null ? s : ["Standard SPL"])[0] });
        }) });
      } : Reflect.get(i, e, t);
    } });
    var id = V([P2("isSet"), P2("rewardPerSecond"), P2("rewardOpenTime"), P2("rewardEndTime"), P2("rewardType")]);
    var $s = V([W("instruction"), P2("nonce"), Z(id, 5, "rewardTimeInfo")]);
    var Js = V([W("instruction"), P2("rewardReopenTime"), P2("rewardEndTime"), P2("rewardPerSecond")]);
    var ea = V([W("instruction"), P2("isSet"), P2("rewardPerSecond"), P2("rewardOpenTime"), P2("rewardEndTime"), P2("rewardType")]);
    var ib = V([P2("state"), F("id"), F("owner"), P2("deposited"), Z(P2(), 1, "rewardDebts")]);
    var yi = V([P2("state"), F("id"), F("owner"), P2("deposited"), Z(ae(), 1, "rewardDebts"), P2(""), P2("voteLockedBalance"), Z(P2(), 15)]);
    var rb = V([P2("state"), F("id"), F("owner"), P2("deposited"), Z(P2(), 2, "rewardDebts")]);
    var $u = V([P2("state"), F("id"), F("owner"), P2("deposited"), Z(ae(), 2, "rewardDebts"), Z(P2(), 17)]);
    var Ju = V([P2(), P2("state"), F("id"), F("owner"), P2("deposited"), Z(ae(), 5, "rewardDebts"), Z(P2(), 16)]);
    var Wt = V([W("instruction"), P2("amount")]);
    var rd = V([F("mint"), F("grantAuthority"), P2("baselineVoteWeightScaledFactor"), P2("maxExtraLockupVoteWeightScaledFactor"), P2("lockupSaturationSecs"), Xu("digitShift"), Z(W(), 7, "reserved1"), Z(P2(), 7, "reserved2")]);
    var ec = V([Fe(8), F("governanceProgramId"), F("realm"), F("realmGoverningTokenMint"), F("realmAuthority"), Z(W(), 32, "reserved1"), Z(rd, 4, "votingMints"), Eo("timeOffset"), W("bump"), Z(W(), 7, "reserved2"), Z(P2(), 11, "reserved3")]);
    var sd = V([Eo("startTime"), Eo("endTime"), W("kind"), Z(W(), 15, "reserved")]);
    var ad = V([Z(sd, 1, "lockup"), P2("amountDeposited_native"), P2("amountInitiallyLockedNative"), Ze("isUsed"), Ze("allowClawback"), W("votingMintConfigIdx"), Z(W(), 29, "reserved")]);
    var tc = V([Fe(8), F("voterAuthority"), F("registrar"), Z(ad, 32, "deposits"), W("voterBump"), W("voterWweightRecordBump"), Z(W(), 94, "reserved")]);
    var ud = require_cjs4();
    var ak = xe("Raydium_farm_config");
    var nc = new ta.PublicKey("4k3Dyjzvzp8eMZWUXbBCjEvwSkkk59S5iCNLY3QrkX6R");
    var oc = new ta.PublicKey("FrspKwj8i3pNmKwXreTveC4fu7KL5ZbGeXdZBe2XViu1");
    var sb = ud.NATIVE_MINT;
    var ab = new ta.PublicKey("3TRTX4dXUpp2eqxi3tvQDFYUV7SdDJjcPE3Y4mbtftaX");
    var ic = { 3: ju, 5: Zu, 6: fi };
    var rc = { 3: yi, 5: $u, 6: Ju };
    var na = (i) => [3, 4, 5, 6].indexOf(i) !== -1;
    var oa = (i) => {
      var s;
      let { version: e, rewardInfos: t, rewardTokenAccountsPublicKeys: n } = i, o = `rewardInfo:${JSON.stringify(t)}, rewardAccount:${JSON.stringify(n)}`, r = { 3: () => {
        if (t.length !== 1 || n.length !== 1)
          return `rewardInfos or rewardTokenAccounts lengths not equal 1: ${o}`;
      }, 5: () => {
        if (t.length !== n.length)
          return `rewardInfos and rewardTokenAccounts lengths not equal: ${o}`;
      }, 6: () => {
        if (!n.length || t.length !== n.length)
          return `no rewardTokenAccounts or rewardInfos and rewardTokenAccounts lengths not equal: ${o}`;
      } };
      return (s = r[e]) == null ? void 0 : s.call(r);
    };
    var no = { "Standard SPL": 0, "Option tokens": 1 };
    var mn = { [Is.toString()]: 3, [Bs.toString()]: 4, [xs.toString()]: 5, [vo.toString()]: 6, [En.FARM_PROGRAM_ID_V3.toString()]: 3, [En.FARM_PROGRAM_ID_V4.toString()]: 4, [En.FARM_PROGRAM_ID_V5.toString()]: 5, [En.FARM_PROGRAM_ID_V6.toString()]: 6 };
    var Q = require("@solana/web3.js");
    var yr = Ae(require_bn());
    var Bt = require_cjs4();
    function ia(i, e, t) {
      return se([e.toBuffer(), Buffer.from("registrar", "utf8"), t.toBuffer()], i);
    }
    function ra(i, e) {
      return se([e.toBuffer(), Buffer.from("voting_mint_seed", "utf8")], i);
    }
    function sa(i, e) {
      return se([e.toBuffer()], i);
    }
    function aa(i, e, t) {
      return se([e.toBuffer(), Buffer.from("voter", "utf8"), t.toBuffer()], i);
    }
    function ua(i, e, t) {
      return se([e.toBuffer(), Buffer.from("voter-weight-record", "utf8"), t.toBuffer()], i);
    }
    function ca(i, e, t, n) {
      return se([Buffer.from("governance", "utf8"), e.toBuffer(), t.toBuffer(), n.toBuffer()], i);
    }
    var Zt = Ae(require_bn());
    var fr = xe("Raydium.farm.util");
    function bi({ programId: i, poolId: e, mint: t, type: n }) {
      let { publicKey: o } = se([e.toBuffer(), t.toBuffer(), Buffer.from(n === "lpVault" ? "lp_vault_associated_seed" : n === "rewardVault" ? "reward_vault_associated_seed" : "", "utf-8")], i);
      return o;
    }
    function Ot({ programId: i, poolId: e, owner: t, version: n }) {
      let { publicKey: o } = se([e.toBuffer(), t.toBuffer(), Buffer.from(n === 6 ? "farmer_info_associated_seed" : "staker_info_v2_associated_seed", "utf-8")], i);
      return o;
    }
    var sc = ({ programId: i, poolId: e }) => se([e.toBuffer()], i);
    function ac(i) {
      return { isSet: new Zt.default(1), rewardPerSecond: oe(i.perSecond), rewardOpenTime: oe(i.openTime), rewardEndTime: oe(i.endTime), rewardType: oe(no[i.rewardType]) };
    }
    function la(i) {
      return oe(i.endTime).sub(oe(i.openTime)).mul(oe(i.perSecond));
    }
    function Do(i) {
      let e = rc[i];
      return e || fr.logWithError("invalid version", i), e;
    }
    function cd(i) {
      let e = ic[i];
      return e || fr.logWithError("invalid version", i), e;
    }
    function ld(i, e, t, n) {
      if (i.version === 3 || i.version === 5) {
        if (i.lastSlot.gte(new Zt.default(t)))
          return i;
        let o = new Zt.default(t).sub(i.lastSlot);
        i.lastSlot = new Zt.default(t);
        for (let r of i.rewardInfos) {
          if (e.amount.eq(new Zt.default(0)))
            continue;
          let s = r.perSlotReward.mul(o);
          r.perShareReward = r.perShareReward.add(s.mul(new Zt.default(10).pow(new Zt.default(i.version === 3 ? 9 : 15))).div(e.amount)), r.totalReward = r.totalReward.add(s);
        }
      } else if (i.version === 6)
        for (let o of i.rewardInfos) {
          if (o.rewardState.eq(new Zt.default(0)))
            continue;
          let r = Zt.default.min(new Zt.default(n), o.rewardEndTime);
          if (o.rewardOpenTime.gte(r))
            continue;
          let a = r.sub(o.rewardLastUpdateTime).mul(o.rewardPerSecond), c = o.totalReward.sub(o.totalRewardEmissioned);
          c.lt(a) ? (a = c, o.rewardLastUpdateTime = o.rewardLastUpdateTime.add(c.div(o.rewardPerSecond))) : o.rewardLastUpdateTime = r, !e.amount.eq(new Zt.default(0)) && (o.accRewardPerShare = o.accRewardPerShare.add(a.mul(i.rewardMultiplier).div(e.amount)), o.totalRewardEmissioned = o.totalRewardEmissioned.add(a));
        }
      return i;
    }
    async function ub({ connection: i, farmPools: e, owner: t, config: n, chainTime: o }) {
      let r = false, s = false, a = new Zt.default(10), c = [];
      for (let d of e) {
        let p = Qe(d);
        p.version === 6 ? s = true : r = true, c.push({ pubkey: p.id, version: p.version, key: "state", poolId: p.id }, { pubkey: p.lpVault, version: p.version, key: "lpVault", poolId: p.id }), t && c.push({ pubkey: Ot({ programId: p.programId, poolId: p.id, owner: t, version: d.version }), version: p.version, key: "ledger", poolId: p.id });
      }
      let u = {}, l = await ze(i, c, n);
      for (let { pubkey: d, version: p, key: f, poolId: y, accountInfo: b } of l) {
        let g = y.toBase58();
        if (u[g] = E({}, u[g]), f === "state") {
          let A = cd(p);
          (!b || !b.data || b.data.length !== A.span) && fr.logWithError(`invalid farm state account info, pools.id, ${d}`), u[g].state = A.decode(b.data);
        } else if (f === "lpVault")
          (!b || !b.data || b.data.length !== kn.span) && fr.logWithError(`invalid farm lp vault account info, pools.lpVault, ${d}`), u[g].lpVault = kn.decode(b.data);
        else if (f === "ledger") {
          let A = Do(p);
          b && b.data && (b.data.length !== A.span && fr.logWithError(`invalid farm ledger account info, ledger, ${d}`), u[g].ledger = A.decode(b.data));
        }
      }
      let m = s || r ? await i.getSlot() : 0;
      for (let d of Object.keys(u))
        u[d] !== void 0 && (u[d].state = ld(u[d].state, u[d].lpVault, m, o));
      for (let [d, { state: p, ledger: f }] of Object.entries(u))
        if (f) {
          let y = p.version === 6 ? p.rewardMultiplier : p.rewardInfos.length === 1 ? a.pow(new Zt.default(9)) : a.pow(new Zt.default(15)), b = p.rewardInfos.map((g, A) => {
            let k = f.rewardDebts[A];
            return f.deposited.mul(p.version === 6 ? g.accRewardPerShare : g.perShareReward).div(y).sub(k);
          });
          u[d].wrapped = U(E({}, u[d].wrapped), { pendingRewards: b });
        }
      return u;
    }
    function cb(i, e = Date.now()) {
      if (i.version === 6) {
        let t = i.state.rewardInfos;
        if (t.every(({ rewardOpenTime: n }) => Tu(e, n.toNumber(), { unit: "s" })))
          return "upcoming pool";
        if (t.every(({ rewardEndTime: n }) => Iu(e, n.toNumber(), { unit: "s" })))
          return "closed pool";
      } else {
        let t = i.state.rewardInfos.map(({ perSlotReward: n }) => n);
        if (t.length === 2) {
          if (String(t[0]) === "0" && String(t[1]) !== "0")
            return "normal fusion pool";
          if (String(t[0]) !== "0" && String(t[1]) !== "0")
            return "dual fusion pool";
          if (String(t[0]) === "0" && String(t[1]) === "0")
            return "closed pool";
        } else if (t.length === 1 && String(t[0]) === "0")
          return "closed pool";
      }
    }
    async function ma(i, e, t, n) {
      let o = await i.getAccountInfo(e);
      if (o === null)
        throw Error("registrar info check error");
      let s = ec.decode(o.data).votingMints.findIndex((l) => l.mint.equals(n));
      if (s === -1)
        throw Error("find voter mint error");
      let a = await i.getAccountInfo(t);
      if (a === null)
        return { index: s, isInit: false };
      let u = tc.decode(a.data).deposits.findIndex((l) => l.isUsed && l.votingMintConfigIdx === s);
      return u === -1 ? { index: s, isInit: false } : { index: u, isInit: true };
    }
    var lb = xe("Raydium_farm_instruction");
    var br = { voterStakeRegistryCreateVoter: Buffer.from([6, 24, 245, 52, 243, 255, 148, 25]), voterStakeRegistryCreateDepositEntry: Buffer.from([185, 131, 167, 186, 159, 125, 19, 67]), voterStakeRegistryDeposit: Buffer.from([242, 35, 198, 137, 82, 225, 242, 182]), voterStakeRegistryWithdraw: Buffer.from([183, 18, 70, 156, 148, 109, 161, 34]), voterStakeRegistryUpdateVoterWeightRecord: Buffer.from([45, 185, 3, 36, 109, 190, 115, 169]) };
    function gi(i) {
      let { version: e, id: t, ledger: n, programId: o, owner: r } = i, s = { 3: 9, 5: 10 }[e];
      s || lb.logWithError(`invalid farm pool version: ${e}`);
      let a = Buffer.alloc(js.span);
      js.encode({ instruction: s }, a);
      let c = [w({ pubkey: t }), w({ pubkey: n }), w({ pubkey: r, isWritable: false }), w({ pubkey: Q.SystemProgram.programId, isWritable: false }), w({ pubkey: Q.SYSVAR_RENT_PUBKEY, isWritable: false })];
      return { instruction: new Q.TransactionInstruction({ programId: o, keys: c, data: a }), instructionType: X.FarmV3CreateLedger };
    }
    function uc(i) {
      var n;
      let e = Buffer.alloc($s.span);
      $s.encode({ instruction: 0, nonce: new yr.default(i.nonce), rewardTimeInfo: i.rewardInfoConfig }, e);
      let t = [...bs, w({ pubkey: i.farmId }), w({ pubkey: i.farmAuthority, isWritable: false }), w({ pubkey: i.lpVault }), w({ pubkey: i.lpMint, isWritable: false }), w({ pubkey: i.lockVault }), w({ pubkey: i.lockMint, isWritable: false }), w({ pubkey: (n = i.lockUserAccount) != null ? n : ht }), w({ pubkey: i.owner, isWritable: false, isSigner: true })];
      for (let o of i.rewardInfo)
        t.push(w({ pubkey: o.rewardMint, isWritable: false }), w({ pubkey: o.rewardVault }), w({ pubkey: o.userRewardToken }));
      return { instruction: new Q.TransactionInstruction({ programId: i.programId, keys: t, data: e }), instructionType: X.FarmV6Create };
    }
    function cc(i) {
      let e = Buffer.alloc(Zs.span);
      Zs.encode({ instruction: 5 }, e);
      let t = [w({ pubkey: Bt.TOKEN_PROGRAM_ID, isWritable: false }), w({ pubkey: i.id }), w({ pubkey: i.authority, isWritable: false }), w({ pubkey: i.lpVault, isWritable: false }), w({ pubkey: i.rewardVault }), w({ pubkey: i.userRewardToken }), w({ pubkey: i.owner, isWritable: false, isSigner: true })];
      return { instruction: new Q.TransactionInstruction({ programId: i.programId, keys: t, data: e }), instructionType: X.FarmV6CreatorWithdraw };
    }
    function md(i, e, t, n, o, r, s, a, c, u, l, m, d) {
      let p = V([W("depositEntryIndex"), P2("amount")]), f = [{ pubkey: e, isSigner: false, isWritable: false }, { pubkey: t, isSigner: false, isWritable: true }, { pubkey: n, isSigner: false, isWritable: true }, { pubkey: o, isSigner: false, isWritable: true }, { pubkey: r, isSigner: false, isWritable: false }, { pubkey: Bt.TOKEN_PROGRAM_ID, isSigner: false, isWritable: false }, { pubkey: s, isSigner: false, isWritable: true }, { pubkey: a, isSigner: false, isWritable: false }, { pubkey: c, isSigner: false, isWritable: true }, { pubkey: u, isSigner: false, isWritable: false }, { pubkey: l, isSigner: false, isWritable: false }, { pubkey: $i, isSigner: false, isWritable: false }], y = Buffer.alloc(p.span);
      p.encode({ depositEntryIndex: m, amount: d }, y);
      let b = Buffer.from([...br.voterStakeRegistryDeposit, ...y]);
      return new Q.TransactionInstruction({ keys: f, programId: i, data: b });
    }
    function dd(i, e, t, n) {
      let o = V([]), r = [{ pubkey: e, isSigner: false, isWritable: false }, { pubkey: t, isSigner: false, isWritable: false }, { pubkey: n, isSigner: false, isWritable: true }, { pubkey: Q.SystemProgram.programId, isSigner: false, isWritable: false }], s = Buffer.alloc(o.span);
      o.encode({}, s);
      let a = Buffer.from([...br.voterStakeRegistryUpdateVoterWeightRecord, ...s]);
      return new Q.TransactionInstruction({ keys: r, programId: i, data: a });
    }
    function pd(i, e, t, n, o, r, s, a, c, u, l, m, d, p, f) {
      let y = V([W("depositEntryIndex"), P2("amount")]), b = [{ pubkey: e, isSigner: false, isWritable: false }, { pubkey: t, isSigner: false, isWritable: true }, { pubkey: n, isSigner: true, isWritable: false }, { pubkey: o, isSigner: false, isWritable: false }, { pubkey: r, isSigner: false, isWritable: true }, { pubkey: s, isSigner: false, isWritable: true }, { pubkey: a, isSigner: false, isWritable: true }, { pubkey: Bt.TOKEN_PROGRAM_ID, isSigner: false, isWritable: false }, { pubkey: c, isSigner: false, isWritable: true }, { pubkey: u, isSigner: false, isWritable: false }, { pubkey: l, isSigner: false, isWritable: true }, { pubkey: m, isSigner: false, isWritable: false }, { pubkey: d, isSigner: false, isWritable: false }, { pubkey: $i, isSigner: false, isWritable: false }], g = Buffer.alloc(y.span);
      y.encode({ depositEntryIndex: p, amount: f }, g);
      let A = Buffer.from([...br.voterStakeRegistryWithdraw, ...g]);
      return new Q.TransactionInstruction({ keys: b, programId: i, data: A });
    }
    function fd(i, e, t, n, o, r) {
      let s = V([W("ins")]), a = [{ pubkey: e, isSigner: false, isWritable: false }, { pubkey: t, isSigner: false, isWritable: false }, { pubkey: r, isSigner: false, isWritable: true }, { pubkey: n, isSigner: false, isWritable: false }, { pubkey: o, isSigner: true, isWritable: true }, { pubkey: Q.SystemProgram.programId, isSigner: false, isWritable: false }], c = Buffer.alloc(s.span);
      return s.encode({ ins: 23 }, c), new Q.TransactionInstruction({ keys: a, programId: i, data: c });
    }
    function yd(i, e, t, n, o, r, s, a) {
      let c = V([W("voterBump"), W("voterWeightRecordBump")]), u = [{ pubkey: e, isSigner: false, isWritable: false }, { pubkey: t, isSigner: false, isWritable: true }, { pubkey: o, isSigner: true, isWritable: false }, { pubkey: n, isSigner: false, isWritable: true }, { pubkey: r, isSigner: true, isWritable: true }, { pubkey: Q.SystemProgram.programId, isSigner: false, isWritable: false }, { pubkey: at, isSigner: false, isWritable: false }, { pubkey: $i, isSigner: false, isWritable: false }], l = Buffer.alloc(c.span);
      c.encode({ voterBump: s, voterWeightRecordBump: a }, l);
      let m = Buffer.from([...br.voterStakeRegistryCreateVoter, ...l]);
      return new Q.TransactionInstruction({ keys: u, programId: i, data: m });
    }
    function bd(i, e, t, n, o, r, s, a, c, u, l, m) {
      let d = V([W("depositEntryIndex"), W("kind"), W("option"), P2("startTs"), St("periods"), Ze("allowClawback")]), p = [{ pubkey: e, isSigner: false, isWritable: false }, { pubkey: t, isSigner: false, isWritable: true }, { pubkey: n, isSigner: false, isWritable: true }, { pubkey: o, isSigner: true, isWritable: false }, { pubkey: r, isSigner: true, isWritable: true }, { pubkey: s, isSigner: false, isWritable: false }, { pubkey: Q.SystemProgram.programId, isSigner: false, isWritable: false }, { pubkey: Bt.TOKEN_PROGRAM_ID, isSigner: false, isWritable: false }, { pubkey: Bt.ASSOCIATED_TOKEN_PROGRAM_ID, isSigner: false, isWritable: false }, { pubkey: at, isSigner: false, isWritable: false }], f = Buffer.alloc(d.span);
      d.encode({ depositEntryIndex: a, kind: c, option: u === void 0 ? 0 : 1, startTs: u, periods: l, allowClawback: m }, f);
      let y = Buffer.from([...br.voterStakeRegistryCreateDepositEntry, ...f]);
      return new Q.TransactionInstruction({ keys: p, programId: i, data: y });
    }
    async function mb({ connection: i, programId: e, governanceProgramId: t, voteWeightAddinProgramId: n, realm: o, communityTokenMint: r, owner: s, poolId: a, tokenProgram: c }) {
      let u = ia(n, o, r).publicKey, l = Ot({ programId: e, poolId: a, owner: s, version: 3 }), m = await i.getAccountInfo(l);
      if (m === null)
        throw Error("user is not staker");
      let d = yi.decode(m.data), p = d.deposited.sub(d.voteLockedBalance);
      if (console.log("amount", p.toString()), p.eq(new yr.default(0)))
        throw Error("user do not has new stake amount");
      let f = ra(e, a).publicKey, y = sa(e, a).publicKey, { publicKey: b, nonce: g } = aa(n, u, s), A = te(b, f, c).publicKey, { publicKey: k, nonce: I } = ua(n, u, s), T = ca(t, o, r, s).publicKey, h = [], S = te(s, f, c).publicKey;
      if (await i.getAccountInfo(S) === null && h.push((0, Bt.createAssociatedTokenAccountIdempotentInstruction)(s, S, s, f)), await i.getAccountInfo(b) === null) {
        let R = fd(t, o, s, r, s, T);
        h.push(R, yd(n, u, b, k, s, s, g, I));
      }
      let { index: B, isInit: C } = await ma(i, u, b, f);
      return C || h.push(bd(n, u, b, A, s, s, f, B, 0, void 0, 0, false)), h.push(md(n, u, b, A, S, s, l, a, f, y, e, B, p), dd(n, u, b, k)), h;
    }
    async function db({ connection: i, programId: e, governanceProgramId: t, voteWeightAddinProgramId: n, realm: o, communityTokenMint: r, owner: s, poolId: a, tokenProgram: c }) {
      let u = ia(n, o, r).publicKey, l = Ot({ programId: e, poolId: a, owner: s, version: 3 }), m = await i.getAccountInfo(l);
      if (m === null)
        throw Error("user is not staker");
      let d = yi.decode(m.data);
      if (d.voteLockedBalance.eq(new yr.default(0)))
        throw Error("user has vote locked balance = 0");
      let p = ra(e, a).publicKey, f = sa(e, a).publicKey, { publicKey: y } = aa(n, u, s), b = te(y, p, c).publicKey, { publicKey: g } = ua(n, u, s), A = ca(t, o, r, s).publicKey, k = [], { index: I, isInit: T } = await ma(i, u, y, p);
      if (!T)
        throw Error("deposit entry index check error");
      return k.push(pd(n, u, y, s, A, g, b, te(s, p, c).publicKey, l, a, p, f, e, I, d.voteLockedBalance)), k;
    }
    function da({ payer: i, rewardVault: e, userRewardTokenPub: t, farmKeys: n, rewardInfo: o }) {
      let r = Buffer.alloc(Js.span);
      Js.encode({ instruction: 3, rewardReopenTime: oe(o.openTime), rewardEndTime: oe(o.endTime), rewardPerSecond: oe(o.perSecond) }, r);
      let s = [w({ pubkey: Bt.TOKEN_PROGRAM_ID, isWritable: false }), w({ pubkey: n.id }), w({ pubkey: n.lpVault, isWritable: false }), w({ pubkey: e }), w({ pubkey: t }), w({ pubkey: i, isWritable: false, isSigner: true })];
      return new Q.TransactionInstruction({ programId: n.programId, keys: s, data: r });
    }
    function pa({ payer: i, userRewardTokenPub: e, farmKeys: t, rewardVault: n, rewardInfo: o }) {
      let r = Buffer.alloc(ea.span);
      ea.encode({ instruction: 4, isSet: new yr.default(1), rewardPerSecond: oe(o.perSecond), rewardOpenTime: oe(o.openTime), rewardEndTime: oe(o.endTime), rewardType: oe(no[o.rewardType]) }, r);
      let s = [...bs, w({ pubkey: t.id }), w({ pubkey: t.authority, isWritable: false }), w({ pubkey: o.mint, isWritable: false }), w({ pubkey: n }), w({ pubkey: e }), w({ pubkey: i, isWritable: false, isSigner: true })];
      return new Q.TransactionInstruction({ programId: t.programId, keys: s, data: r });
    }
    function pb(i) {
      let { farmInfo: e, farmKeys: t, version: n, lpAccount: o, rewardAccounts: r, owner: s, instruction: a, amount: c, deposit: u } = i, [l, m] = [new Q.PublicKey(e.programId), new Q.PublicKey(e.id)], d = Ot({ programId: l, poolId: m, owner: s, version: n }), p = Buffer.alloc(Wt.span);
      Wt.encode({ instruction: a, amount: c }, p);
      let f = n === 6 ? [w({ pubkey: Bt.TOKEN_PROGRAM_ID, isWritable: false }), ...u ? [w({ pubkey: Q.SystemProgram.programId, isWritable: false })] : [], w({ pubkey: m }), w({ pubkey: new Q.PublicKey(t.authority), isWritable: false }), w({ pubkey: new Q.PublicKey(t.lpVault) }), w({ pubkey: d }), w({ pubkey: s, isWritable: false, isSigner: true }), w({ pubkey: o })] : [w({ pubkey: m }), w({ pubkey: new Q.PublicKey(t.authority), isWritable: false }), w({ pubkey: d }), w({ pubkey: s, isWritable: false, isSigner: true }), w({ pubkey: o }), w({ pubkey: new Q.PublicKey(t.lpVault) }), w({ pubkey: r[0] }), w({ pubkey: new Q.PublicKey(t.rewardInfos[0].vault) }), w({ pubkey: Q.SYSVAR_CLOCK_PUBKEY, isWritable: false }), w({ pubkey: Bt.TOKEN_PROGRAM_ID, isWritable: false })];
      if (n === 5)
        for (let y = 1; y < t.rewardInfos.length; y++)
          f.push(w({ pubkey: r[y] })), f.push(w({ pubkey: new Q.PublicKey(t.rewardInfos[y].vault) }));
      if (n === 6)
        for (let y = 0; y < t.rewardInfos.length; y++)
          f.push(w({ pubkey: new Q.PublicKey(t.rewardInfos[y].vault) })), f.push(w({ pubkey: r[y] }));
      return new Q.TransactionInstruction({ programId: l, keys: f, data: p });
    }
    function Pi(i) {
      let { farmInfo: e, farmKeys: t, lpAccount: n, rewardAccounts: o, owner: r, amount: s } = i, [a, c] = [new Q.PublicKey(e.programId), new Q.PublicKey(e.id)], u = Ot({ programId: a, poolId: c, owner: r, version: 6 }), l = Buffer.alloc(Wt.span);
      Wt.encode({ instruction: 2, amount: oe(s) }, l);
      let m = [w({ pubkey: Bt.TOKEN_PROGRAM_ID, isWritable: false }), w({ pubkey: c }), w({ pubkey: new Q.PublicKey(t.authority), isWritable: false }), w({ pubkey: new Q.PublicKey(t.lpVault) }), w({ pubkey: u }), w({ pubkey: r, isWritable: false, isSigner: true }), w({ pubkey: n })];
      for (let d = 0; d < t.rewardInfos.length; d++)
        m.push(w({ pubkey: new Q.PublicKey(t.rewardInfos[d].vault) })), m.push(w({ pubkey: o[d] }));
      return new Q.TransactionInstruction({ programId: a, keys: m, data: l });
    }
    function Ai(i) {
      let { farmInfo: e, farmKeys: t, lpAccount: n, rewardAccounts: o, owner: r, amount: s, userAuxiliaryLedgers: a } = i, [c, u] = [new Q.PublicKey(e.programId), new Q.PublicKey(e.id)], l = Ot({ programId: c, poolId: u, owner: r, version: 5 }), m = Buffer.alloc(Wt.span);
      Wt.encode({ instruction: 12, amount: oe(s) }, m);
      let d = [w({ pubkey: u }), w({ pubkey: new Q.PublicKey(t.authority), isWritable: false }), w({ pubkey: l }), w({ pubkey: r, isWritable: false, isSigner: true }), w({ pubkey: n }), w({ pubkey: new Q.PublicKey(t.lpVault) }), w({ pubkey: o[0] }), w({ pubkey: new Q.PublicKey(t.rewardInfos[0].vault) }), w({ pubkey: Q.SYSVAR_CLOCK_PUBKEY, isWritable: false }), w({ pubkey: Bt.TOKEN_PROGRAM_ID, isWritable: false })];
      for (let p = 1; p < t.rewardInfos.length; p++)
        d.push(w({ pubkey: o[p] })), d.push(w({ pubkey: new Q.PublicKey(t.rewardInfos[p].vault) }));
      if (a)
        for (let p of a)
          d.push(w({ pubkey: p }));
      return new Q.TransactionInstruction({ programId: c, keys: d, data: m });
    }
    function lc(i) {
      let { farmInfo: e, farmKeys: t, lpAccount: n, rewardAccounts: o, owner: r, amount: s, userAuxiliaryLedgers: a } = i, [c, u] = [new Q.PublicKey(e.programId), new Q.PublicKey(e.id)], l = V([W("instruction"), P2("amount")]), m = [w({ pubkey: u }), w({ pubkey: new Q.PublicKey(t.authority), isWritable: false }), w({ pubkey: a[0] }), w({ pubkey: r, isSigner: true, isWritable: false }), w({ pubkey: n }), w({ pubkey: new Q.PublicKey(t.lpVault) }), w({ pubkey: o[0] }), w({ pubkey: new Q.PublicKey(t.rewardInfos[0].vault) }), w({ pubkey: Q.SYSVAR_CLOCK_PUBKEY, isWritable: false }), w({ pubkey: Bt.TOKEN_PROGRAM_ID, isWritable: false }), w({ pubkey: o[1] }), w({ pubkey: new Q.PublicKey(t.rewardInfos[1].vault) })], d = Buffer.alloc(l.span);
      return l.encode({ instruction: 2, amount: s }, d), new Q.TransactionInstruction({ keys: m, programId: c, data: d });
    }
    function wi(i) {
      let { farmInfo: e, farmKeys: t, lpAccount: n, rewardAccounts: o, owner: r, amount: s, userAuxiliaryLedgers: a } = i, [c, u] = [new Q.PublicKey(e.programId), new Q.PublicKey(e.id)], l = Ot({ programId: c, poolId: u, owner: r, version: 3 }), m = Buffer.alloc(Wt.span);
      Wt.encode({ instruction: 11, amount: oe(s) }, m);
      let d = [w({ pubkey: u }), w({ pubkey: new Q.PublicKey(t.authority), isWritable: false }), w({ pubkey: l }), w({ pubkey: r, isWritable: false, isSigner: true }), w({ pubkey: n }), w({ pubkey: new Q.PublicKey(t.lpVault) }), w({ pubkey: o[0] }), w({ pubkey: new Q.PublicKey(t.rewardInfos[0].vault) }), w({ pubkey: Q.SYSVAR_CLOCK_PUBKEY, isWritable: false }), w({ pubkey: Bt.TOKEN_PROGRAM_ID, isWritable: false })];
      if (a)
        for (let p of a)
          d.push(w({ pubkey: p }));
      return new Q.TransactionInstruction({ programId: c, keys: d, data: m });
    }
    function mc(i) {
      let { farmInfo: e, farmKeys: t, lpAccount: n, rewardAccounts: o, owner: r, amount: s, userAuxiliaryLedgers: a } = i, [c, u] = [new Q.PublicKey(e.programId), new Q.PublicKey(e.id)], l = Ot({ programId: c, poolId: u, owner: r, version: 3 }), m = Buffer.alloc(Wt.span);
      Wt.encode({ instruction: 10, amount: oe(s) }, m);
      let d = [w({ pubkey: u }), w({ pubkey: new Q.PublicKey(t.authority), isWritable: false }), w({ pubkey: l }), w({ pubkey: r, isWritable: false, isSigner: true }), w({ pubkey: n }), w({ pubkey: new Q.PublicKey(t.lpVault) }), w({ pubkey: o[0] }), w({ pubkey: new Q.PublicKey(t.rewardInfos[0].vault) }), w({ pubkey: Q.SYSVAR_CLOCK_PUBKEY, isWritable: false }), w({ pubkey: Bt.TOKEN_PROGRAM_ID, isWritable: false })];
      if (a)
        for (let p of a)
          d.push(w({ pubkey: p }));
      return new Q.TransactionInstruction({ programId: c, keys: d, data: m });
    }
    function dc(i) {
      let { farmInfo: e, farmKeys: t, lpAccount: n, rewardAccounts: o, owner: r, amount: s, userAuxiliaryLedgers: a } = i, [c, u] = [new Q.PublicKey(e.programId), new Q.PublicKey(e.id)], l = Ot({ programId: c, poolId: u, owner: r, version: 5 }), m = Buffer.alloc(Wt.span);
      Wt.encode({ instruction: 11, amount: oe(s) }, m);
      let d = [w({ pubkey: u }), w({ pubkey: new Q.PublicKey(t.authority), isWritable: false }), w({ pubkey: l }), w({ pubkey: r, isWritable: false, isSigner: true }), w({ pubkey: n }), w({ pubkey: new Q.PublicKey(t.lpVault) }), w({ pubkey: o[0] }), w({ pubkey: new Q.PublicKey(t.rewardInfos[0].vault) }), w({ pubkey: Q.SYSVAR_CLOCK_PUBKEY, isWritable: false }), w({ pubkey: Bt.TOKEN_PROGRAM_ID, isWritable: false })];
      for (let p = 1; p < t.rewardInfos.length; p++)
        d.push(w({ pubkey: o[p] })), d.push(w({ pubkey: new Q.PublicKey(t.rewardInfos[p].vault) }));
      if (a)
        for (let p of a)
          d.push(w({ pubkey: p }));
      return new Q.TransactionInstruction({ programId: c, keys: d, data: m });
    }
    function pc(i) {
      let { farmInfo: e, farmKeys: t, lpAccount: n, rewardAccounts: o, owner: r, amount: s } = i, [a, c] = [new Q.PublicKey(e.programId), new Q.PublicKey(e.id)], u = Ot({ programId: a, poolId: c, owner: r, version: 6 }), l = Buffer.alloc(Wt.span);
      Wt.encode({ instruction: 1, amount: oe(s) }, l);
      let m = [w({ pubkey: Bt.TOKEN_PROGRAM_ID, isWritable: false }), w({ pubkey: Q.SystemProgram.programId, isWritable: false }), w({ pubkey: c }), w({ pubkey: new Q.PublicKey(t.authority), isWritable: false }), w({ pubkey: new Q.PublicKey(t.lpVault) }), w({ pubkey: u }), w({ pubkey: r, isWritable: false, isSigner: true }), w({ pubkey: n })];
      for (let d = 0; d < t.rewardInfos.length; d++)
        m.push(w({ pubkey: new Q.PublicKey(t.rewardInfos[d].vault) })), m.push(w({ pubkey: o[d] }));
      return new Q.TransactionInstruction({ programId: a, keys: m, data: l });
    }
    var gr = class extends Je {
      async _getUserRewardInfo({ payer: e, rewardInfo: t }) {
        if (t.mint.equals(ht)) {
          let n = await to({ connection: this.scope.connection, owner: this.scope.ownerPubKey, payer: e, amount: la(U(E({}, t), { openTime: t.openTime.toString(), endTime: t.endTime.toString() })) });
          return { rewardPubKey: n.addresses.newAccount, newInstruction: n };
        }
        return { rewardPubKey: await this.scope.account.getCreatedTokenAccount({ mint: t.mint, associatedOnly: false }) };
      }
      async create({ poolInfo: e, rewardInfos: t, payer: n, programId: o = vo, txVersion: r, feePayer: s, lockProgram: a }) {
        var S, x;
        this.checkDisabled(), this.scope.checkOwner();
        let u = { lpMint: new Ve.PublicKey(e.lpMint.address), lockInfo: { lockMint: (S = a == null ? void 0 : a.mint) != null ? S : nc, lockVault: (x = a == null ? void 0 : a.vault) != null ? x : oc }, version: 6, rewardInfos: t, programId: o }, l = this.createTxBuilder(s), m = n != null ? n : this.scope.ownerPubKey, d = rt({ fromPublicKey: m, programId: u.programId }), p = await this.scope.connection.getMinimumBalanceForRentExemption(fi.span);
        l.addInstruction({ instructions: [Ve.SystemProgram.createAccountWithSeed({ fromPubkey: m, basePubkey: m, seed: d.seed, newAccountPubkey: d.publicKey, lamports: p, space: fi.span, programId: u.programId })] });
        let { publicKey: f, nonce: y } = sc({ programId: new Ve.PublicKey(u.programId), poolId: d.publicKey }), b = bi({ programId: u.programId, poolId: d.publicKey, mint: u.lpMint, type: "lpVault" }), g = [], A = [];
        for (let K of u.rewardInfos) {
          K.openTime >= K.endTime && this.logAndCreateError("start time error", "rewardInfo.rewardOpenTime", K.openTime.toString()), isNaN(no[K.rewardType]) && this.logAndCreateError("rewardType error", K.rewardType), Number(K.perSecond) <= 0 && this.logAndCreateError("rewardPerSecond error", K.perSecond), g.push(ac(K));
          let { rewardPubKey: B, newInstruction: C } = await this._getUserRewardInfo({ rewardInfo: K, payer: m });
          C && l.addInstruction(C), B || this.logAndCreateError("cannot found target token accounts", this.scope.account.tokenAccounts);
          let R = K.mint.equals(ht) ? new Ve.PublicKey(kt.address) : K.mint;
          A.push({ rewardMint: R, rewardVault: bi({ programId: u.programId, poolId: d.publicKey, mint: R, type: "rewardVault" }), userRewardToken: B });
        }
        let { account: k, instructionParams: I } = await this.scope.account.getOrCreateTokenAccount({ mint: new Ve.PublicKey(u.lockInfo.lockMint), owner: this.scope.ownerPubKey, skipCloseAccount: false, createInfo: { payer: this.scope.ownerPubKey, amount: 0 }, associatedOnly: false });
        I && l.addInstruction(I), k || this.logAndCreateError("cannot found lock vault", "tokenAccounts", this.scope.account.tokenAccounts);
        let { instruction: T, instructionType: h } = uc({ farmId: d.publicKey, owner: this.scope.ownerPubKey, farmAuthority: f, lpVault: b, lpMint: u.lpMint, lockVault: u.lockInfo.lockVault, lockMint: u.lockInfo.lockMint, lockUserAccount: k, programId: u.programId, rewardInfo: A, rewardInfoConfig: g, nonce: y });
        return l.addInstruction({ instructions: [T], instructionTypes: [h] }).versionBuild({ txVersion: r, extInfo: { farmId: d.publicKey, farmAuthority: f, lpVault: b, lockUserAccount: k, nonce: y } });
      }
      async restartReward({ farmInfo: e, payer: t, newRewardInfo: n, txVersion: o, feePayer: r }) {
        var g;
        let s = mn[e.programId];
        s !== 6 && this.logAndCreateError("invalid farm version ", s);
        let a = Qe((await this.scope.api.fetchFarmKeysById({ ids: e.id }))[0]), c = { id: a.id, rewardInfos: e.rewardInfos, lpVault: a.lpVault, programId: a.programId };
        n.openTime >= n.endTime && this.logAndCreateError("start time error", "newRewardInfo", n);
        let u = t || this.scope.ownerPubKey, l = n.mint.equals(ht) ? new Ve.PublicKey(kt.address) : n.mint, m = c.rewardInfos.findIndex((A) => new Ve.PublicKey(A.mint.address).equals(l)), d = a.rewardInfos[m];
        d || this.logAndCreateError("configuration does not exist", "rewardMint", l);
        let p = (g = d.vault) != null ? g : ht, f = this.createTxBuilder(r), { rewardPubKey: y, newInstruction: b } = await this._getUserRewardInfo({ rewardInfo: n, payer: u });
        return b && f.addInstruction(b), y || this.logAndCreateError("cannot found target token accounts", this.scope.account.tokenAccounts), f.addInstruction({ instructions: [da({ payer: this.scope.ownerPubKey, rewardVault: p, userRewardTokenPub: y, farmKeys: c, rewardInfo: n })], instructionTypes: [X.FarmV6Restart] }).versionBuild({ txVersion: o });
      }
      async restartRewards({ farmInfo: e, payer: t, newRewardInfos: n, txVersion: o, feePayer: r }) {
        var m;
        let s = mn[e.programId];
        s !== 6 && this.logAndCreateError("invalid farm version ", s);
        let a = Qe((await this.scope.api.fetchFarmKeysById({ ids: e.id }))[0]), c = { id: a.id, rewardInfos: e.rewardInfos, lpVault: a.lpVault, programId: a.programId };
        n.forEach((d) => {
          d.openTime >= d.endTime && this.logAndCreateError("start time error", "newRewardInfo", d);
        });
        let u = t || this.scope.ownerPubKey, l = this.createTxBuilder(r);
        for (let d of n) {
          let p = d.mint.equals(ht) ? new Ve.PublicKey(kt.address) : d.mint, f = c.rewardInfos.findIndex((I) => new Ve.PublicKey(I.mint.address).equals(p)), y = a.rewardInfos[f];
          y || this.logAndCreateError("configuration does not exist", "rewardMint", p);
          let b = (m = y.vault) != null ? m : ht, { rewardPubKey: g, newInstruction: A } = await this._getUserRewardInfo({ rewardInfo: d, payer: u });
          A && l.addInstruction(A), g || this.logAndCreateError("cannot found target token accounts", this.scope.account.tokenAccounts);
          let k = da({ payer: this.scope.ownerPubKey, rewardVault: b, userRewardTokenPub: g, farmKeys: c, rewardInfo: d });
          l.addInstruction({ instructions: [k], instructionTypes: [X.FarmV6Restart] });
        }
        return l.versionBuild({ txVersion: o });
      }
      async addNewRewardToken(e) {
        let { txVersion: t, farmInfo: n, newRewardInfo: o, payer: r, feePayer: s } = e, a = mn[n.programId];
        a !== 6 && this.logAndCreateError("invalid farm version ", a);
        let c = Qe((await this.scope.api.fetchFarmKeysById({ ids: n.id }))[0]), u = r != null ? r : this.scope.ownerPubKey, l = this.createTxBuilder(s), m = o.mint.equals(ht) ? new Ve.PublicKey(kt.address) : o.mint, d = bi({ programId: new Ve.PublicKey(n.programId), poolId: new Ve.PublicKey(n.id), mint: m, type: "rewardVault" }), { rewardPubKey: p, newInstruction: f } = await this._getUserRewardInfo({ rewardInfo: o, payer: u });
        return f && l.addInstruction(f), p || this.logAndCreateError("annot found target token accounts", this.scope.account.tokenAccounts), o.mint = m, l.addInstruction({ instructions: [pa({ payer: this.scope.ownerPubKey, userRewardTokenPub: p, farmKeys: c, rewardVault: d, rewardInfo: o })], instructionTypes: [X.FarmV6CreatorAddReward] }).versionBuild({ txVersion: t });
      }
      async addNewRewardsToken(e) {
        let { txVersion: t, farmInfo: n, newRewardInfos: o, payer: r, feePayer: s } = e, a = mn[n.programId];
        a !== 6 && this.logAndCreateError("invalid farm version ", a);
        let c = Qe((await this.scope.api.fetchFarmKeysById({ ids: n.id }))[0]), u = r != null ? r : this.scope.ownerPubKey, l = this.createTxBuilder(s);
        for (let m of o) {
          let d = m.mint.equals(ht) ? new Ve.PublicKey(kt.address) : m.mint, p = bi({ programId: new Ve.PublicKey(n.programId), poolId: new Ve.PublicKey(n.id), mint: d, type: "rewardVault" }), { rewardPubKey: f, newInstruction: y } = await this._getUserRewardInfo({ rewardInfo: m, payer: u });
          y && l.addInstruction(y), f || this.logAndCreateError("cannot found target token accounts", this.scope.account.tokenAccounts);
          let b = pa({ payer: this.scope.ownerPubKey, userRewardTokenPub: f, farmKeys: c, rewardVault: p, rewardInfo: U(E({}, m), { mint: d }) });
          l.addInstruction({ instructions: [b], instructionTypes: [X.FarmV6CreatorAddReward] });
        }
        return l.versionBuild({ txVersion: t });
      }
      async deposit(e) {
        let { txVersion: t, farmInfo: n, amount: o, feePayer: r, useSOLBalance: s, associatedOnly: a = true, checkCreateATAOwner: c = false, userAuxiliaryLedgers: u, computeBudgetConfig: l, txTipConfig: m } = e;
        this.scope.availability.addFarm === false && this.logAndCreateError("farm deposit feature disabled in your region");
        let { rewardInfos: d, programId: p } = n, f = mn[p];
        f === 4 && this.logAndCreateError("V4 has suspended deposits:", n.programId), na(f) || this.logAndCreateError("invalid farm program:", n.programId);
        let [y, b] = [new Ve.PublicKey(n.programId), new Ve.PublicKey(n.id)], g = (await this.scope.api.fetchFarmKeysById({ ids: n.id }))[0], A = Ot({ programId: y, poolId: b, owner: this.scope.ownerPubKey, version: f }), k = this.createTxBuilder(r);
        k.addCustomComputeBudget(l), k.addTipInstruction(m);
        let I = {};
        for (let v of this.scope.account.tokenAccounts)
          if (a) {
            let L = te(this.scope.ownerPubKey, v.mint, v.programId).publicKey;
            v.publicKey && L.equals(v.publicKey) && (I[v.mint.toString()] = v.publicKey);
          } else
            I[v.mint.toString()] = v.publicKey;
        let T = g.lpMint, h = I[T.address];
        h || this.logAndCreateError("you don't have any lp", "lp zero", I);
        let S = [];
        for (let v of d) {
          let L = s && v.mint.address === ee.toString(), M = I[v.mint.address];
          if (!M) {
            let { account: Y, instructionParams: j } = await this.scope.account.getOrCreateTokenAccount({ tokenProgram: v.mint.programId, mint: new Ve.PublicKey(v.mint.address), notUseTokenAccount: L, createInfo: { payer: r || this.scope.ownerPubKey, amount: 0 }, owner: this.scope.ownerPubKey, skipCloseAccount: !L, associatedOnly: L ? false : a, checkCreateATAOwner: c });
            M = Y, j && k.addInstruction(j);
          }
          I[v.mint.address] = M, S.push(M);
        }
        let x, K = await this.scope.connection.getAccountInfo(A);
        if (K && (x = Do(f).decode(K.data)), n.programId !== vo.toString() && n.programId !== En.FARM_PROGRAM_ID_V6.toString() && !x) {
          let { instruction: v, instructionType: L } = gi({ id: b, programId: y, version: f, ledger: A, owner: this.scope.ownerPubKey });
          k.addInstruction({ instructions: [v], instructionTypes: [L] });
        }
        let B = oa({ version: f, rewardInfos: d, rewardTokenAccountsPublicKeys: S });
        B && this.logAndCreateError(B);
        let C = { amount: oe(o), owner: this.scope.ownerPubKey, farmInfo: n, farmKeys: g, lpAccount: h, rewardAccounts: S, userAuxiliaryLedgers: u == null ? void 0 : u.map((v) => new Ve.PublicKey(v)) }, R = f === 6 ? pc(C) : f === 5 ? dc(C) : mc(C), N = { 3: X.FarmV3Deposit, 5: X.FarmV5Deposit, 6: X.FarmV6Deposit };
        return k.addInstruction({ instructions: [R], instructionTypes: [N[f]] }).versionBuild({ txVersion: t });
      }
      async withdraw(e) {
        let { txVersion: t, farmInfo: n, amount: o, deposited: r, useSOLBalance: s, feePayer: a, associatedOnly: c = true, checkCreateATAOwner: u = false, userAuxiliaryLedgers: l, computeBudgetConfig: m, txTipConfig: d } = e, { rewardInfos: p } = n;
        this.scope.availability.removeFarm === false && this.logAndCreateError("farm withdraw feature disabled in your region");
        let f = mn[n.programId];
        na(f) || this.logAndCreateError("invalid farm program:", n.programId);
        let y = (await this.scope.api.fetchFarmKeysById({ ids: n.id }))[0], b = this.createTxBuilder(a);
        b.addCustomComputeBudget(m), b.addTipInstruction(d);
        let g = {};
        for (let B of this.scope.account.tokenAccounts)
          if (c) {
            let C = te(this.scope.ownerPubKey, B.mint).publicKey;
            B.publicKey && C.equals(B.publicKey) && (g[B.mint.toString()] = B.publicKey);
          } else
            g[B.mint.toString()] = B.publicKey;
        if (f !== 4) {
          let B = Ot({ programId: new Ve.PublicKey(n.programId), poolId: new Ve.PublicKey(n.id), owner: this.scope.ownerPubKey, version: f }), C = await this.scope.connection.getAccountInfo(B);
          if (C)
            Do(f).decode(C.data).deposited.isZero() && this.logAndCreateError("no deposited lp", { farmId: n.id });
          else if (f !== 6) {
            let { instruction: R, instructionType: N } = gi({ id: new Ve.PublicKey(y.id), programId: new Ve.PublicKey(y.programId), version: f, ledger: B, owner: this.scope.ownerPubKey });
            b.addInstruction({ instructions: [R], instructionTypes: [N] });
          }
        }
        r && r.isZero() && !(l || []).length && this.logAndCreateError("no deposited lp", { farmId: n.id });
        let A = y.lpMint.address, k = s && A === ee.toString(), I = g[A.toString()];
        if (!I) {
          let { account: B, instructionParams: C } = await this.scope.account.getOrCreateTokenAccount({ tokenProgram: y.lpMint.programId, mint: new Ve.PublicKey(A), notUseTokenAccount: k, createInfo: { payer: a || this.scope.ownerPubKey, amount: 0 }, owner: this.scope.ownerPubKey, skipCloseAccount: true, associatedOnly: k ? false : c, checkCreateATAOwner: u });
          I = B, C && b.addInstruction(C);
        }
        g[A.toString()] = I;
        let T = [];
        for (let B of p) {
          let C = s && B.mint.address === ee.toString(), R = g[B.mint.address];
          if (!R) {
            let { account: N, instructionParams: v } = await this.scope.account.getOrCreateTokenAccount({ tokenProgram: B.mint.programId, mint: new Ve.PublicKey(B.mint.address), notUseTokenAccount: C, createInfo: { payer: a || this.scope.ownerPubKey, amount: 0 }, owner: this.scope.ownerPubKey, skipCloseAccount: !C, associatedOnly: C ? false : c, checkCreateATAOwner: u });
            R = N, v && b.addInstruction(v);
          }
          g[B.mint.address] = R, T.push(R);
        }
        let h = oa({ version: f, rewardInfos: p, rewardTokenAccountsPublicKeys: T });
        h && this.logAndCreateError(h);
        let S = { amount: oe(o), owner: this.scope.ownerPubKey, farmInfo: n, farmKeys: y, lpAccount: I, rewardAccounts: T, userAuxiliaryLedgers: l == null ? void 0 : l.map((B) => new Ve.PublicKey(B)) }, x = f === 6 ? Pi(S) : f === 5 ? Ai(S) : f === 4 ? lc(S) : wi(S), K = { 3: X.FarmV3Withdraw, 4: X.FarmV4Withdraw, 5: X.FarmV5Withdraw, 6: X.FarmV6Withdraw };
        return b.addInstruction({ instructions: [x], instructionTypes: [K[f]] }).versionBuild({ txVersion: t });
      }
      async withdrawFarmReward({ farmInfo: e, withdrawMint: t, txVersion: n, computeBudgetConfig: o, txTipConfig: r, feePayer: s }) {
        var y;
        this.scope.checkOwner();
        let a = Qe((await this.scope.api.fetchFarmKeysById({ ids: e.id }))[0]), c = mn[e.programId];
        c !== 6 && this.logAndCreateError("invalid farm version", c);
        let u = a.rewardInfos.find((b) => Lt(b.mint.address).equals(Lt(t)));
        u || this.logAndCreateError("withdraw mint error", "rewardInfos", e);
        let l = (y = u == null ? void 0 : u.vault) != null ? y : ht, m = this.createTxBuilder(s), d;
        if (t.equals(ht) || t.equals(Ve.PublicKey.default)) {
          let b = await to({ connection: this.scope.connection, owner: this.scope.ownerPubKey, payer: this.scope.ownerPubKey, amount: la(U(E({}, u), { openTime: u.openTime, endTime: u.endTime, perSecond: new O(u.perSecond).mul(10 ** u.mint.decimals).toString() })) });
          d = b.addresses.newAccount, m.addInstruction(b);
        } else {
          let b = await this.scope.account.getCreatedTokenAccount({ mint: t });
          b ? d = b : (d = await this.scope.account.getAssociatedTokenAccount(t), m.addInstruction({ instructions: [(0, fc.createAssociatedTokenAccountIdempotentInstruction)(this.scope.ownerPubKey, d, this.scope.ownerPubKey, t)], instructionTypes: [X.CreateATA] }));
        }
        let { instruction: p, instructionType: f } = cc({ programId: a.programId, id: a.id, authority: a.authority, lpVault: a.lpVault, rewardVault: l, userRewardToken: d, owner: this.scope.ownerPubKey });
        return m.addCustomComputeBudget(o), m.addTipInstruction(r), m.addInstruction({ instructions: [p], instructionTypes: [f] }).versionBuild({ txVersion: n });
      }
      async harvestAllRewards(e) {
        let { farmInfoList: t, useSOLBalance: n, feePayer: o, associatedOnly: r = true, checkCreateATAOwner: s = false, userAuxiliaryLedgers: a, txVersion: c, computeBudgetConfig: u } = e, l = this.createTxBuilder(o), m = {};
        for (let f of this.scope.account.tokenAccounts)
          if (r) {
            let y = te(this.scope.ownerPubKey, f.mint).publicKey;
            f.publicKey && y.equals(f.publicKey) && (m[f.mint.toString()] = f.publicKey);
          } else
            m[f.mint.toString()] = f.publicKey;
        let p = (await this.scope.api.fetchFarmKeysById({ ids: Object.values(t).map((f) => f.id).join(",") })).reduce((f, y) => U(E({}, f), { [y.id]: y }), {});
        for (let f of Object.values(t)) {
          let { programId: y, lpMint: b, rewardInfos: g, id: A } = f, k = mn[y], I = b.address, T = n && I === ee.toString(), h = m[I];
          if (!h) {
            let { account: R, instructionParams: N } = await this.scope.account.getOrCreateTokenAccount({ tokenProgram: b.programId, mint: new Ve.PublicKey(I), notUseTokenAccount: T, createInfo: { payer: o || this.scope.ownerPubKey, amount: 0 }, owner: this.scope.ownerPubKey, skipCloseAccount: true, associatedOnly: T ? false : r, checkCreateATAOwner: s });
            h = R, N && l.addInstruction(N);
          }
          m[I.toString()] = h;
          let S = [];
          for (let R of g) {
            let N = n && R.mint.address === ee.toString(), v = m[R.mint.address];
            if (!v)
              if (N) {
                let { account: L, instructionParams: M } = await this.scope.account.getOrCreateTokenAccount({ tokenProgram: R.mint.programId, mint: new Ve.PublicKey(R.mint.address), notUseTokenAccount: N, createInfo: { payer: o || this.scope.ownerPubKey, amount: 0 }, owner: this.scope.ownerPubKey, skipCloseAccount: !N, associatedOnly: N ? false : r, checkCreateATAOwner: s });
                v = L, M && l.addInstruction(M);
              } else {
                let L = new Ve.PublicKey(R.mint.address);
                v = this.scope.account.getAssociatedTokenAccount(L), l.addInstruction({ instructions: [(0, fc.createAssociatedTokenAccountIdempotentInstruction)(this.scope.ownerPubKey, v, this.scope.ownerPubKey, L)] });
              }
            m[R.mint.address] = v, S.push(v);
          }
          let x = p[A], K = { amount: ut, owner: this.scope.ownerPubKey, farmInfo: f, farmKeys: x, lpAccount: h, rewardAccounts: S, userAuxiliaryLedgers: a == null ? void 0 : a.map((R) => new Ve.PublicKey(R)) }, B = k === 6 ? Pi(K) : k === 5 ? Ai(K) : wi(K), C = { 3: X.FarmV3Withdraw, 5: X.FarmV5Withdraw, 6: X.FarmV6Withdraw };
          l.addInstruction({ instructions: [B], instructionTypes: [C[k]] });
        }
        return c === 1 ? l.sizeCheckBuild({ computeBudgetConfig: u }) : l.sizeCheckBuildV0({ computeBudgetConfig: u });
      }
    };
    var lt = require("@solana/web3.js");
    var Xt = require_cjs4();
    var q = require("@solana/web3.js");
    var ha = Ae(require_bn());
    var re = require_cjs4();
    var xd = Ae(require_bn());
    var dn = Ae(require_bn());
    var Ke = new dn.default(0);
    var rn = new dn.default(1);
    var qn = new dn.default(-1);
    var Pt = new dn.default(1).shln(64);
    var Pr = new dn.default(1).shln(128);
    var ki = Pt.sub(rn);
    var hi = 64;
    var yc = Pr.subn(1);
    var Mt = -443636;
    var Dt = -Mt;
    var qt = new dn.default("4295048016");
    var Ut = new dn.default("79226673521066979257578248091");
    var Ar = new dn.default("4295048017");
    var wr = new dn.default("79226673521066979257578248090");
    var bc = 16;
    var gc = "59543866431248";
    var Pc = "184467440737095516";
    var Ac = "15793534762490258745";
    var kr = new dn.default(10).pow(new dn.default(6));
    var gd = ((n) => (n[n.rate_500 = 500] = "rate_500", n[n.rate_3000 = 3e3] = "rate_3000", n[n.rate_10000 = 1e4] = "rate_10000", n))(gd || {});
    var fb = { [500]: 10, [3e3]: 60, [1e4]: 200 };
    var yb = { version: 6, liquidity: Ke, tickCurrent: 0, feeGrowthGlobalX64A: Ke, feeGrowthGlobalX64B: Ke, protocolFeesTokenA: Ke, protocolFeesTokenB: Ke, swapInAmountTokenA: Ke, swapOutAmountTokenB: Ke, swapInAmountTokenB: Ke, swapOutAmountTokenA: Ke, tickArrayBitmap: [], rewardInfos: [], day: { volume: 0, volumeFee: 0, feeA: 0, feeB: 0, feeApr: 0, rewardApr: { A: 0, B: 0, C: 0 }, apr: 0, priceMax: 0, priceMin: 0 }, week: { volume: 0, volumeFee: 0, feeA: 0, feeB: 0, feeApr: 0, rewardApr: { A: 0, B: 0, C: 0 }, apr: 0, priceMax: 0, priceMin: 0 }, month: { volume: 0, volumeFee: 0, feeA: 0, feeB: 0, feeApr: 0, rewardApr: { A: 0, B: 0, C: 0 }, apr: 0, priceMax: 0, priceMin: 0 }, tvl: 0 };
    var wc = { tvl: 0, volumeQuote: 0, mintAmountA: 0, mintAmountB: 0, rewardDefaultInfos: [], farmUpcomingCount: 0, farmOngoingCount: 0, farmFinishedCount: 0, day: { volume: 0, volumeQuote: 0, volumeFee: 0, apr: 0, feeApr: 0, priceMin: 0, priceMax: 0, rewardApr: [0] }, week: { volume: 0, volumeQuote: 0, volumeFee: 0, apr: 0, feeApr: 0, priceMin: 0, priceMax: 0, rewardApr: [0] }, month: { volume: 0, volumeQuote: 0, volumeFee: 0, apr: 0, feeApr: 0, priceMin: 0, priceMax: 0, rewardApr: [0] }, pooltype: [] };
    var bb = new dn.default("18446744073700000000");
    var Be = Ae(require_bn());
    function hr(i) {
      let e = new ArrayBuffer(2);
      return new DataView(e).setUint16(0, i, false), new Uint8Array(e);
    }
    function gb(i) {
      let e = new ArrayBuffer(2);
      return new DataView(e).setInt16(0, i, false), new Uint8Array(e);
    }
    function Pb(i) {
      let e = new ArrayBuffer(4);
      return new DataView(e).setUint32(0, i, false), new Uint8Array(e);
    }
    function Tr(i) {
      let e = new ArrayBuffer(4);
      return new DataView(e).setInt32(0, i, false), new Uint8Array(e);
    }
    function fa(i, e) {
      let t = 0;
      for (let n = i - 1; n >= 0 && !e.testn(n); n--)
        t++;
      return t;
    }
    function ya(i, e) {
      let t = 0;
      for (let n = 0; n < i && !e.testn(n); n++)
        t++;
      return t;
    }
    function Ti(i, e) {
      for (let t = 0; t < i; t++)
        if (e.testn(t))
          return false;
      return true;
    }
    function kc(i, e) {
      return Ti(i, e) ? null : fa(i, e);
    }
    function hc(i, e) {
      return Ti(i, e) ? null : ya(i, e);
    }
    var Pd = Buffer.from("amm_config", "utf8");
    var ba = Buffer.from("pool", "utf8");
    var ga = Buffer.from("pool_vault", "utf8");
    var Ad = Buffer.from("pool_reward_vault", "utf8");
    var Tc = Buffer.from("position", "utf8");
    var wd = Buffer.from("tick_array", "utf8");
    var kd = Buffer.from("operation", "utf8");
    var hd = Buffer.from("pool_tick_array_bitmap_extension", "utf8");
    var Td = Buffer.from("observation", "utf8");
    function Ab(i, e) {
      return se([Pd, hr(e)], i);
    }
    function Ic(i, e, t, n) {
      return se([ba, e.toBuffer(), t.toBuffer(), n.toBuffer()], i);
    }
    function Pa(i, e, t) {
      return se([ga, e.toBuffer(), t.toBuffer()], i);
    }
    function Bc(i, e, t) {
      return se([Ad, e.toBuffer(), t.toBuffer()], i);
    }
    function Ce(i, e, t) {
      return se([wd, e.toBuffer(), Tr(t)], i);
    }
    function hn(i, e, t, n) {
      return se([Tc, e.toBuffer(), Tr(t), Tr(n)], i);
    }
    function Gt(i, e) {
      return se([Tc, e.toBuffer()], i);
    }
    function Un(i) {
      return se([Buffer.from("metadata", "utf8"), cn.toBuffer(), i.toBuffer()], cn);
    }
    function Ii(i) {
      return se([kd], i);
    }
    function st(i, e) {
      return se([hd, e.toBuffer()], i);
    }
    function xc(i, e) {
      return se([Td, e.toBuffer()], i);
    }
    var Sc = Buffer.from("locked_position", "utf8");
    function Aa(i, e) {
      return se([Sc, e.toBuffer()], i);
    }
    function qo(i, e) {
      return se([Sc, e.toBuffer()], i);
    }
    var Id = Buffer.from("support_mint", "utf8");
    function wa(i, e) {
      return se([Id, e.toBuffer()], i);
    }
    var sn = require("@solana/web3.js");
    var Cc = require_cjs4();
    var $e = Ae(require_bn());
    var Nn = Ae(require_bn());
    var Bi = class {
      static getfeeGrowthInside(e, t, n) {
        let o = new Nn.default(0), r = new Nn.default(0);
        e.tickCurrent >= t.tick ? (o = t.feeGrowthOutsideX64A, r = t.feeGrowthOutsideX64B) : (o = e.feeGrowthGlobalX64A.sub(t.feeGrowthOutsideX64A), r = e.feeGrowthGlobalX64B.sub(t.feeGrowthOutsideX64B));
        let s = new Nn.default(0), a = new Nn.default(0);
        e.tickCurrent < n.tick ? (s = n.feeGrowthOutsideX64A, a = n.feeGrowthOutsideX64B) : (s = e.feeGrowthGlobalX64A.sub(n.feeGrowthOutsideX64A), a = e.feeGrowthGlobalX64B.sub(n.feeGrowthOutsideX64B));
        let c = Pe.wrappingSubU128(Pe.wrappingSubU128(e.feeGrowthGlobalX64A, o), s), u = Pe.wrappingSubU128(Pe.wrappingSubU128(e.feeGrowthGlobalX64B, r), a);
        return { feeGrowthInsideX64A: c, feeGrowthInsideBX64: u };
      }
      static GetPositionFees(e, t, n, o) {
        let { feeGrowthInsideX64A: r, feeGrowthInsideBX64: s } = this.getfeeGrowthInside(e, n, o), a = Pe.mulDivFloor(Pe.wrappingSubU128(r, t.feeGrowthInsideLastX64A), t.liquidity, Pt), c = t.tokenFeesOwedA.add(a), u = Pe.mulDivFloor(Pe.wrappingSubU128(s, t.feeGrowthInsideLastX64B), t.liquidity, Pt), l = t.tokenFeesOwedB.add(u);
        return { tokenFeeAmountA: c, tokenFeeAmountB: l };
      }
      static GetPositionFeesV2(e, t, n, o) {
        let { feeGrowthInsideX64A: r, feeGrowthInsideBX64: s } = this.getfeeGrowthInside(e, n, o), a = Pe.mulDivFloor(Pe.wrappingSubU128(r, t.feeGrowthInsideLastX64A), t.liquidity, Pt), c = t.tokenFeesOwedA.add(a), u = Pe.mulDivFloor(Pe.wrappingSubU128(s, t.feeGrowthInsideLastX64B), t.liquidity, Pt), l = t.tokenFeesOwedB.add(u);
        return { tokenFeeAmountA: c, tokenFeeAmountB: l };
      }
      static GetPositionRewardsV2(e, t, n, o) {
        let r = [], s = this.getRewardGrowthInsideV2(e.tickCurrent, n, o, e.rewardInfos);
        for (let a = 0; a < s.length; a++) {
          let c = s[a], u = t.rewardInfos[a], l = Pe.wrappingSubU128(c, u.growthInsideLastX64), m = Pe.mulDivFloor(l, t.liquidity, Pt), d = u.rewardAmountOwed.add(m);
          r.push(d);
        }
        return r;
      }
      static GetPositionRewards(e, t, n, o) {
        let r = [], s = this.getRewardGrowthInside(e.tickCurrent, n, o, e.rewardInfos);
        for (let a = 0; a < s.length; a++) {
          let c = s[a], u = t.rewardInfos[a], l = Pe.wrappingSubU128(c, u.growthInsideLastX64), m = Pe.mulDivFloor(l, t.liquidity, Pt), d = u.rewardAmountOwed.add(m);
          r.push(d);
        }
        return r;
      }
      static getRewardGrowthInside(e, t, n, o) {
        let r = [];
        for (let s = 0; s < o.length; s++) {
          let a = new Nn.default(0);
          t.liquidityGross.eqn(0) ? a = o[s].rewardGrowthGlobalX64 : e < t.tick ? a = o[s].rewardGrowthGlobalX64.sub(t.rewardGrowthsOutsideX64[s]) : a = t.rewardGrowthsOutsideX64[s];
          let c = new Nn.default(0);
          n.liquidityGross.eqn(0) || (e < n.tick ? c = n.rewardGrowthsOutsideX64[s] : c = o[s].rewardGrowthGlobalX64.sub(n.rewardGrowthsOutsideX64[s])), r.push(Pe.wrappingSubU128(Pe.wrappingSubU128(o[s].rewardGrowthGlobalX64, a), c));
        }
        return r;
      }
      static getRewardGrowthInsideV2(e, t, n, o) {
        let r = [];
        for (let s = 0; s < o.length; s++) {
          let a = new Nn.default(0);
          t.liquidityGross.eqn(0) ? a = o[s].rewardGrowthGlobalX64 : e < t.tick ? a = o[s].rewardGrowthGlobalX64.sub(t.rewardGrowthsOutsideX64[s]) : a = t.rewardGrowthsOutsideX64[s];
          let c = new Nn.default(0);
          n.liquidityGross.eqn(0) || (e < n.tick ? c = n.rewardGrowthsOutsideX64[s] : c = o[s].rewardGrowthGlobalX64.sub(n.rewardGrowthsOutsideX64[s])), r.push(Pe.wrappingSubU128(Pe.wrappingSubU128(o[s].rewardGrowthGlobalX64, a), c));
        }
        return r;
      }
      static getAmountsFromLiquidity({ poolInfo: e, ownerPosition: t, liquidity: n, slippage: o, add: r, epochInfo: s }) {
        var b, g, A, k;
        let a = fe.priceToSqrtPriceX64(new O(e.price), e.mintA.decimals, e.mintB.decimals), c = fe.getSqrtPriceX64FromTick(t.tickLower), u = fe.getSqrtPriceX64FromTick(t.tickUpper), l = r ? 1 + o : 1 - o, m = Re.getAmountsFromLiquidity(a, c, u, n, r), [d, p] = [_e(m.amountA, (b = e.mintA.extensions) == null ? void 0 : b.feeConfig, s, true), _e(m.amountB, (g = e.mintB.extensions) == null ? void 0 : g.feeConfig, s, true)], [f, y] = [_e(new Nn.default(new O(m.amountA.toString()).mul(l).toFixed(0)), (A = e.mintA.extensions) == null ? void 0 : A.feeConfig, s, true), _e(new Nn.default(new O(m.amountB.toString()).mul(l).toFixed(0)), (k = e.mintB.extensions) == null ? void 0 : k.feeConfig, s, true)];
        return { liquidity: n, amountA: d, amountB: p, amountSlippageA: f, amountSlippageB: y, expirationTime: wn(d.expirationTime, p.expirationTime) };
      }
    };
    var Bd = 15;
    var Ne = class {
      static async getTickArrays(e, t, n, o, r, s, a) {
        let c = [], u = ne.getTickArrayStartIndexByTick(o, r), l = ne.getInitializedTickArrayInRange(s, a, r, u, Math.floor(Bd / 2));
        for (let p = 0; p < l.length; p++) {
          let { publicKey: f } = Ce(t, n, l[p]);
          c.push(f);
        }
        let m = (await gn(e, c)).map((p) => p !== null ? xi.decode(p.data) : null), d = {};
        for (let p = 0; p < c.length; p++) {
          let f = m[p];
          f !== null && (d[f.startTickIndex] = U(E({}, f), { address: c[p] }));
        }
        return d;
      }
      static nextInitializedTick(e, t, n, o, r, s) {
        let { initializedTick: a, tickArrayAddress: c, tickArrayStartTickIndex: u } = this.nextInitializedTickInOneArray(e, t, n, o, r, s);
        for (; a == null || a.liquidityGross.lten(0); ) {
          if (u = ne.getNextTickArrayStartIndex(u, r, s), this.checkIsValidStartIndex(u, r))
            throw new Error("No enough initialized tickArray");
          let l = n[u];
          if (l === void 0)
            continue;
          let { nextTick: m, tickArrayAddress: d, tickArrayStartTickIndex: p } = this.firstInitializedTickInOneArray(e, t, l, s);
          [a, c, u] = [m, d, p];
        }
        if (a == null)
          throw new Error("No invaild tickArray cache");
        return { nextTick: a, tickArrayAddress: c, tickArrayStartTickIndex: u };
      }
      static nextInitializedTickArray(e, t, n, o, r) {
        let s = Math.floor(e / Ne.tickCount(t)), a = n ? ne.searchLowBitFromStart(o, r, s - 1, 1, t) : ne.searchHightBitFromStart(o, r, s + 1, 1, t);
        return a.length > 0 ? { isExist: true, nextStartIndex: a[0] } : { isExist: false, nextStartIndex: 0 };
      }
      static firstInitializedTickInOneArray(e, t, n, o) {
        let r;
        if (o) {
          let a = At - 1;
          for (; a >= 0; ) {
            let c = n.ticks[a];
            if (c.liquidityGross.gtn(0)) {
              r = c;
              break;
            }
            a = a - 1;
          }
        } else {
          let a = 0;
          for (; a < At; ) {
            let c = n.ticks[a];
            if (c.liquidityGross.gtn(0)) {
              r = c;
              break;
            }
            a = a + 1;
          }
        }
        let { publicKey: s } = Ce(e, t, n.startTickIndex);
        return { nextTick: r, tickArrayAddress: s, tickArrayStartTickIndex: n.startTickIndex };
      }
      static nextInitializedTickInOneArray(e, t, n, o, r, s) {
        let a = ne.getTickArrayStartIndexByTick(o, r), c = Math.floor((o - a) / r), u = n[a];
        if (u == null)
          return { initializedTick: void 0, tickArrayAddress: void 0, tickArrayStartTickIndex: a };
        let l;
        if (s)
          for (; c >= 0; ) {
            let d = u.ticks[c];
            if (d.liquidityGross.gtn(0)) {
              l = d;
              break;
            }
            c = c - 1;
          }
        else
          for (c = c + 1; c < At; ) {
            let d = u.ticks[c];
            if (d.liquidityGross.gtn(0)) {
              l = d;
              break;
            }
            c = c + 1;
          }
        let { publicKey: m } = Ce(e, t, a);
        return { initializedTick: l, tickArrayAddress: m, tickArrayStartTickIndex: u.startTickIndex };
      }
      static getArrayStartIndex(e, t) {
        let n = this.tickCount(t);
        return Math.floor(e / n) * n;
      }
      static checkIsValidStartIndex(e, t) {
        if (ne.checkIsOutOfBoundary(e)) {
          if (e > Dt)
            return false;
          let n = ne.getTickArrayStartIndexByTick(Mt, t);
          return e == n;
        }
        return e % this.tickCount(t) == 0;
      }
      static tickCount(e) {
        return At * e;
      }
    };
    var ka = 14;
    var Gn = class {
      static maxTickInTickarrayBitmap(e) {
        return e * At * To;
      }
      static getBitmapTickBoundary(e, t) {
        let n = this.maxTickInTickarrayBitmap(t), o = Math.floor(Math.abs(e) / n);
        e < 0 && Math.abs(e) % n != 0 && (o += 1);
        let r = n * o;
        return e < 0 ? { minValue: -r, maxValue: -r + n } : { minValue: r, maxValue: r + n };
      }
      static nextInitializedTickArrayStartIndex(e, t, n, o) {
        if (!Ne.checkIsValidStartIndex(t, n))
          throw Error("nextInitializedTickArrayStartIndex check error");
        let r = this.maxTickInTickarrayBitmap(n), s = o ? t - Ne.tickCount(n) : t + Ne.tickCount(n);
        if (s < -r || s >= r)
          return { isInit: false, tickIndex: t };
        let a = n * At, c = s / a + 512;
        s < 0 && s % a != 0 && c--;
        let u = Math.abs(c);
        if (o) {
          let l = e.shln(1024 - u - 1), m = kc(1024, l);
          if (m !== null) {
            let d = (u - m - 512) * a;
            return { isInit: true, tickIndex: d };
          } else
            return { isInit: false, tickIndex: -r };
        } else {
          let l = e.shrn(u), m = hc(1024, l);
          if (m !== null) {
            let d = (u + m - 512) * a;
            return { isInit: true, tickIndex: d };
          } else
            return { isInit: false, tickIndex: r - Ne.tickCount(n) };
        }
      }
    };
    var Si = class {
      static getBitmapOffset(e, t) {
        if (!Ne.checkIsValidStartIndex(e, t))
          throw new Error("No enough initialized tickArray");
        this.checkExtensionBoundary(e, t);
        let n = Gn.maxTickInTickarrayBitmap(t), o = Math.floor(Math.abs(e) / n) - 1;
        return e < 0 && Math.abs(e) % n === 0 && o--, o;
      }
      static getBitmap(e, t, n) {
        let o = this.getBitmapOffset(e, t);
        return e < 0 ? { offset: o, tickarrayBitmap: n.negativeTickArrayBitmap[o] } : { offset: o, tickarrayBitmap: n.positiveTickArrayBitmap[o] };
      }
      static checkExtensionBoundary(e, t) {
        let { positiveTickBoundary: n, negativeTickBoundary: o } = this.extensionTickBoundary(t);
        if (e >= o && e < n)
          throw Error("checkExtensionBoundary -> InvalidTickArrayBoundary");
      }
      static extensionTickBoundary(e) {
        let t = Gn.maxTickInTickarrayBitmap(e), n = -t;
        if (Dt <= t)
          throw Error(`extensionTickBoundary check error: ${Dt}, ${t}`);
        if (n <= Mt)
          throw Error(`extensionTickBoundary check error: ${n}, ${Mt}`);
        return { positiveTickBoundary: t, negativeTickBoundary: n };
      }
      static checkTickArrayIsInit(e, t, n) {
        let { tickarrayBitmap: o } = this.getBitmap(e, t, n), r = this.tickArrayOffsetInBitmap(e, t);
        return { isInitialized: ne.mergeTickArrayBitmap(o).testn(r), startIndex: e };
      }
      static nextInitializedTickArrayFromOneBitmap(e, t, n, o) {
        let r = Ne.tickCount(t), s = n ? e - r : e + r, { tickarrayBitmap: a } = this.getBitmap(s, t, o);
        return this.nextInitializedTickArrayInBitmap(a, s, t, n);
      }
      static nextInitializedTickArrayInBitmap(e, t, n, o) {
        let { minValue: r, maxValue: s } = Gn.getBitmapTickBoundary(t, n), a = this.tickArrayOffsetInBitmap(t, n);
        if (o) {
          let c = ne.mergeTickArrayBitmap(e).shln(To - 1 - a), u = Ti(512, c) ? null : fa(512, c);
          if (u !== null) {
            let l = t - u * Ne.tickCount(n);
            return { isInit: true, tickIndex: l };
          } else
            return { isInit: false, tickIndex: r };
        } else {
          let c = ne.mergeTickArrayBitmap(e).shrn(a), u = Ti(512, c) ? null : ya(512, c);
          if (u !== null) {
            let l = t + u * Ne.tickCount(n);
            return { isInit: true, tickIndex: l };
          } else
            return { isInit: false, tickIndex: s - Ne.tickCount(n) };
        }
      }
      static tickArrayOffsetInBitmap(e, t) {
        let n = Math.abs(e) % Gn.maxTickInTickarrayBitmap(t), o = Math.floor(n / Ne.tickCount(t));
        return e < 0 && n != 0 && (o = To - o), o;
      }
    };
    var Xe = class {
      static getOutputAmountAndRemainAccounts(e, t, n, o, r, s = false) {
        let a = n.toBase58() === e.mintA.address, c = [], { isExist: u, startIndex: l, nextAccountMeta: m } = this.getFirstInitializedTickArray(e, a);
        if (!u || l === void 0 || !m)
          throw new Error("Invalid tick array");
        c.push(m);
        let { allTrade: d, amountCalculated: p, accounts: f, sqrtPriceX64: y, feeAmount: b } = Io.swapCompute(e.programId, e.id, t, e.tickArrayBitmap, e.exBitmapInfo, a, e.ammConfig.tradeFeeRate, e.liquidity, e.tickCurrent, e.tickSpacing, e.sqrtPriceX64, o, l, r, s);
        return c.push(...f), { allTrade: d, expectedAmountOut: p.mul(qn), remainingAccounts: c, executionPrice: y, feeAmount: b };
      }
      static getInputAmountAndRemainAccounts(e, t, n, o, r) {
        let s = n.toBase58() === e.mintB.address, a = [], { isExist: c, startIndex: u, nextAccountMeta: l } = this.getFirstInitializedTickArray(e, s);
        if (!c || u === void 0 || !l)
          throw new Error("Invalid tick array");
        try {
          let y = this.preInitializedTickArrayStartIndex(e, s);
          if (y.isExist) {
            let { publicKey: b } = Ce(e.programId, e.id, y.nextStartIndex);
            a.push(b);
          }
        } catch {
        }
        a.push(l);
        let { amountCalculated: m, accounts: d, sqrtPriceX64: p, feeAmount: f } = Io.swapCompute(e.programId, e.id, t, e.tickArrayBitmap, e.exBitmapInfo, s, e.ammConfig.tradeFeeRate, e.liquidity, e.tickCurrent, e.tickSpacing, e.sqrtPriceX64, o.mul(qn), u, r);
        return a.push(...d), { expectedAmountIn: m, remainingAccounts: a, executionPrice: p, feeAmount: f };
      }
      static getFirstInitializedTickArray(e, t) {
        let { isInitialized: n, startIndex: o } = Xe.isOverflowDefaultTickarrayBitmap(e.tickSpacing, [e.tickCurrent]) ? Si.checkTickArrayIsInit(Ne.getArrayStartIndex(e.tickCurrent, e.tickSpacing), e.tickSpacing, e.exBitmapInfo) : ne.checkTickArrayIsInitialized(ne.mergeTickArrayBitmap(e.tickArrayBitmap), e.tickCurrent, e.tickSpacing);
        if (n) {
          let { publicKey: a } = Ce(e.programId, e.id, o);
          return { isExist: true, startIndex: o, nextAccountMeta: a };
        }
        let { isExist: r, nextStartIndex: s } = this.nextInitializedTickArrayStartIndex(e, Ne.getArrayStartIndex(e.tickCurrent, e.tickSpacing), t);
        if (r) {
          let { publicKey: a } = Ce(e.programId, e.id, s);
          return { isExist: true, startIndex: s, nextAccountMeta: a };
        }
        return { isExist: false, nextAccountMeta: void 0, startIndex: void 0 };
      }
      static preInitializedTickArrayStartIndex(e, t) {
        let n = Math.floor(e.tickCurrent / Ne.tickCount(e.tickSpacing)), o = t ? ne.searchHightBitFromStart(e.tickArrayBitmap, e.exBitmapInfo, n + 1, 1, e.tickSpacing) : ne.searchLowBitFromStart(e.tickArrayBitmap, e.exBitmapInfo, n - 1, 1, e.tickSpacing);
        return o.length > 0 ? { isExist: true, nextStartIndex: o[0] } : { isExist: false, nextStartIndex: 0 };
      }
      static nextInitializedTickArrayStartIndex(e, t, n) {
        for (t = Ne.getArrayStartIndex(e.tickCurrent, e.tickSpacing); ; ) {
          let { isInit: o, tickIndex: r } = Gn.nextInitializedTickArrayStartIndex(ne.mergeTickArrayBitmap(e.tickArrayBitmap), t, e.tickSpacing, n);
          if (o)
            return { isExist: true, nextStartIndex: r };
          t = r;
          let { isInit: s, tickIndex: a } = Si.nextInitializedTickArrayFromOneBitmap(t, e.tickSpacing, n, e.exBitmapInfo);
          if (s)
            return { isExist: true, nextStartIndex: a };
          if (t = a, t < Mt || t > Dt)
            return { isExist: false, nextStartIndex: 0 };
        }
      }
      static async updatePoolRewardInfos({ connection: e, apiPoolInfo: t, chainTime: n, poolLiquidity: o, rewardInfos: r }) {
        var a, c, u;
        let s = [];
        for (let l = 0; l < r.length; l++) {
          let m = r[l], d = (u = (a = t.rewardDefaultInfos[l]) == null ? void 0 : a.mint.programId) != null ? u : (c = await e.getAccountInfo(m.tokenMint)) == null ? void 0 : c.owner;
          if (d === void 0)
            throw Error("get new reward mint info error");
          let p = U(E({}, m), { perSecond: Pe.x64ToDecimal(m.emissionsPerSecondX64), remainingRewards: void 0, tokenProgramId: new sn.PublicKey(d) });
          if (p.tokenMint.equals(sn.PublicKey.default))
            continue;
          if (n <= p.openTime.toNumber() || o.eq(Ke)) {
            s.push(p);
            continue;
          }
          let f = new $e.default(Math.min(p.endTime.toNumber(), n)), y = f.sub(p.lastUpdateTime), b = Pe.mulDivFloor(y, p.emissionsPerSecondX64, o), g = p.rewardGrowthGlobalX64.add(b), A = Pe.mulDivFloor(y, p.emissionsPerSecondX64, Pt), k = p.rewardTotalEmissioned.add(A);
          s.push(U(E({}, p), { rewardGrowthGlobalX64: g, rewardTotalEmissioned: k, lastUpdateTime: f }));
        }
        return s;
      }
      static isOverflowDefaultTickarrayBitmap(e, t) {
        let { maxTickBoundary: n, minTickBoundary: o } = this.tickRange(e);
        for (let r of t) {
          let s = ne.getTickArrayStartIndexByTick(r, e);
          if (s >= n || s < o)
            return true;
        }
        return false;
      }
      static tickRange(e) {
        let t = Gn.maxTickInTickarrayBitmap(e), n = -t;
        return t > Dt && (t = Ne.getArrayStartIndex(Dt, e) + Ne.tickCount(e)), n < Mt && (n = Ne.getArrayStartIndex(Mt, e)), { maxTickBoundary: t, minTickBoundary: n };
      }
      static get_tick_array_offset(e, t) {
        if (!Ne.checkIsValidStartIndex(e, t))
          throw new Error("No enough initialized tickArray");
        return e / Ne.tickCount(t) * To;
      }
      static async fetchExBitmaps({ connection: e, exBitmapAddress: t, batchRequest: n }) {
        let o = await ze(e, t.map((s) => ({ pubkey: s })), { batchRequest: n }), r = {};
        for (let s of o)
          s.accountInfo !== null && (r[s.pubkey.toString()] = Lc.decode(s.accountInfo.data));
        return r;
      }
      static async fetchMultiplePoolTickArrays({ connection: e, poolKeys: t, batchRequest: n }) {
        let o = {}, r = [];
        for (let c of t) {
          let u = ne.getTickArrayStartIndexByTick(c.tickCurrent, c.tickSpacing), l = ne.getInitializedTickArrayInRange(c.tickArrayBitmap, c.exBitmapInfo, c.tickSpacing, u, 7);
          for (let m of l) {
            let { publicKey: d } = Ce(c.programId, c.id, m);
            r.push({ pubkey: d }), o[d.toString()] = c.id;
          }
        }
        let s = await ze(e, r, { batchRequest: n }), a = {};
        for (let c of s) {
          if (!c.accountInfo)
            continue;
          let u = o[c.pubkey.toString()];
          if (!u)
            continue;
          a[u.toString()] === void 0 && (a[u.toString()] = {});
          let l = xi.decode(c.accountInfo.data);
          a[u.toString()][l.startTickIndex] = U(E({}, l), { address: c.pubkey });
        }
        return a;
      }
      static async fetchPoolsAccountPosition({ pools: e, connection: t, ownerInfo: n, batchRequest: o = false, updateOwnerRewardAndFee: r = true }) {
        var a;
        let s = [];
        for (let c = 0; c < e.length; c++) {
          let u = e[c];
          u !== null && (s.find((l) => l.equals(u.state.programId)) || s.push(u.state.programId));
        }
        if (n) {
          let c = n.tokenAccounts.map((d) => d.accountInfo.mint), u = [];
          for (let d of c)
            for (let p of s)
              u.push(Gt(p, d).publicKey);
          let l = await gn(t, u, { batchRequest: o }), m = {};
          for (let d of l) {
            if (d === null)
              continue;
            let p = Uo.decode(d.data), f = p.poolId.toString(), y = e.find((x) => x.state.id.toBase58() === f);
            if (y === void 0)
              continue;
            let b = y.state, g = ne._getTickPriceLegacy({ poolInfo: b, tick: p.tickLower, baseIn: true }), A = ne._getTickPriceLegacy({ poolInfo: b, tick: p.tickUpper, baseIn: true }), { amountA: k, amountB: I } = Re.getAmountsFromLiquidity(b.sqrtPriceX64, g.tickSqrtPriceX64, A.tickSqrtPriceX64, p.liquidity, false), T = 1 / (1 - Math.sqrt(Math.sqrt(g.price.div(A.price).toNumber())));
            y.positionAccount = [...(a = y.positionAccount) != null ? a : [], { poolId: p.poolId, nftMint: p.nftMint, priceLower: g.price, priceUpper: A.price, amountA: k, amountB: I, tickLower: p.tickLower, tickUpper: p.tickUpper, liquidity: p.liquidity, feeGrowthInsideLastX64A: p.feeGrowthInsideLastX64A, feeGrowthInsideLastX64B: p.feeGrowthInsideLastX64B, tokenFeesOwedA: p.tokenFeesOwedA, tokenFeesOwedB: p.tokenFeesOwedB, rewardInfos: p.rewardInfos.map((x) => U(E({}, x), { pendingReward: new $e.default(0) })), leverage: T, tokenFeeAmountA: new $e.default(0), tokenFeeAmountB: new $e.default(0) }];
            let h = await ne.getTickArrayAddressByTick(y.state.programId, p.poolId, p.tickLower, y.state.tickSpacing), S = await ne.getTickArrayAddressByTick(y.state.programId, p.poolId, p.tickUpper, y.state.tickSpacing);
            m[`${y.state.programId.toString()}-${p.poolId.toString()}-${p.tickLower}`] = h, m[`${y.state.programId.toString()}-${p.poolId.toString()}-${p.tickUpper}`] = S;
          }
          if (r) {
            let d = Object.values(m), p = await gn(t, d, { batchRequest: o }), f = {};
            for (let y = 0; y < d.length; y++) {
              let b = p[y];
              if (b === null)
                continue;
              let g = d[y].toString();
              f[g] = xi.decode(b.data);
            }
            for (let { state: y, positionAccount: b } of e)
              if (!!b)
                for (let g of b) {
                  let A = `${y.programId.toString()}-${y.id.toString()}-${g.tickLower}`, k = `${y.programId.toString()}-${y.id.toString()}-${g.tickUpper}`, I = f[m[A].toString()], T = f[m[k].toString()], h = I.ticks[ne.getTickOffsetInArray(g.tickLower, y.tickSpacing)], S = T.ticks[ne.getTickOffsetInArray(g.tickUpper, y.tickSpacing)], { tokenFeeAmountA: x, tokenFeeAmountB: K } = await Bi.GetPositionFees(y, g, h, S), B = await Bi.GetPositionRewards(y, g, h, S);
                  g.tokenFeeAmountA = x.gte(new $e.default(0)) ? x : new $e.default(0), g.tokenFeeAmountB = K.gte(new $e.default(0)) ? K : new $e.default(0);
                  for (let C = 0; C < B.length; C++)
                    g.rewardInfos[C].pendingReward = B[C].gte(new $e.default(0)) ? B[C] : new $e.default(0);
                }
          }
        }
        return e;
      }
      static computeAmountOut({ poolInfo: e, tickArrayCache: t, baseMint: n, epochInfo: o, amountIn: r, slippage: s, priceLimit: a = new O(0), catchLiquidityInsufficient: c = false }) {
        var R;
        let u, l = n.toBase58() === e.mintA.address, [m, d] = l ? [e.mintA.extensions.feeConfig, e.mintB.extensions.feeConfig] : [e.mintB.extensions.feeConfig, e.mintA.extensions.feeConfig];
        a.equals(new O(0)) ? u = l ? qt.add(new $e.default(1)) : Ut.sub(new $e.default(1)) : u = fe.priceToSqrtPriceX64(a, e.mintA.decimals, e.mintB.decimals);
        let p = _e(r, m, o, false), { allTrade: f, expectedAmountOut: y, remainingAccounts: b, executionPrice: g, feeAmount: A } = Xe.getOutputAmountAndRemainAccounts(e, t, n, p.amount.sub((R = p.fee) != null ? R : Ke), u, c), k = _e(y, d, o, false), I = fe.sqrtPriceX64ToPrice(g, e.mintA.decimals, e.mintB.decimals), T = l ? I : new O(1).div(I), h = y.mul(new $e.default(Math.floor((1 - s) * 1e10))).div(new $e.default(1e10)), S = _e(h, d, o, false), x = l ? e.currentPrice : new O(1).div(e.currentPrice), K = new O(T).sub(x).abs(), B = x, C = new ot(new O(K).mul(10 ** 15).toFixed(0), new O(B).mul(10 ** 15).toFixed(0));
        return { allTrade: f, realAmountIn: p, amountOut: k, minAmountOut: S, expirationTime: wn(p.expirationTime, k.expirationTime), currentPrice: e.currentPrice, executionPrice: T, priceImpact: C, fee: A, remainingAccounts: b, executionPriceX64: g };
      }
      static computeAmountOutFormat({ poolInfo: e, tickArrayCache: t, amountIn: n, tokenOut: o, slippage: r, epochInfo: s, catchLiquidityInsufficient: a = false }) {
        let c = o.address === e.mintB.address, [u, l] = c ? [e.mintA, e.mintB] : [e.mintB, e.mintA], [m, d] = [new De(U(E({}, u), { mint: u.address, isToken2022: u.programId === Cc.TOKEN_2022_PROGRAM_ID.toBase58() })), new De(U(E({}, l), { mint: l.address, isToken2022: l.programId === Cc.TOKEN_2022_PROGRAM_ID.toBase58() }))], { allTrade: p, realAmountIn: f, amountOut: y, minAmountOut: b, expirationTime: g, currentPrice: A, executionPrice: k, priceImpact: I, fee: T, remainingAccounts: h, executionPriceX64: S } = Xe.computeAmountOut({ poolInfo: e, tickArrayCache: t, baseMint: new sn.PublicKey(u.address), amountIn: n, slippage: r, epochInfo: s, catchLiquidityInsufficient: a }), x = U(E({}, f), { amount: new ve(m, f.amount), fee: f.fee === void 0 ? void 0 : new ve(m, f.fee) }), K = U(E({}, y), { amount: new ve(d, y.amount), fee: y.fee === void 0 ? void 0 : new ve(d, y.fee) }), B = U(E({}, b), { amount: new ve(d, b.amount), fee: b.fee === void 0 ? void 0 : new ve(d, b.fee) }), C = new Tt({ baseToken: m, denominator: new $e.default(10).pow(new $e.default(20 + m.decimals)), quoteToken: d, numerator: A.mul(new O(10 ** (20 + d.decimals))).toFixed(0) }), R = new Tt({ baseToken: m, denominator: new $e.default(10).pow(new $e.default(20 + m.decimals)), quoteToken: d, numerator: k.mul(new O(10 ** (20 + d.decimals))).toFixed(0) }), N = new ve(m, T);
        return { allTrade: p, realAmountIn: x, amountOut: K, minAmountOut: B, expirationTime: g, currentPrice: C, executionPrice: R, priceImpact: I, fee: N, remainingAccounts: h, executionPriceX64: S };
      }
      static computeAmountIn({ poolInfo: e, tickArrayCache: t, baseMint: n, epochInfo: o, amountOut: r, slippage: s, priceLimit: a = new O(0) }) {
        var B;
        let c = n.toBase58() === e.mintA.address, u = { [e.mintA.address]: e.mintA.extensions.feeConfig, [e.mintB.address]: e.mintB.extensions.feeConfig }, l;
        a.equals(new O(0)) ? l = c ? Ut.sub(new $e.default(1)) : qt.add(new $e.default(1)) : l = fe.priceToSqrtPriceX64(a, e.mintA.decimals, e.mintB.decimals);
        let m = _e(r, u[n.toString()], o, true), { expectedAmountIn: d, remainingAccounts: p, executionPrice: f, feeAmount: y } = Xe.getInputAmountAndRemainAccounts(e, t, n, m.amount.sub((B = m.fee) != null ? B : Ke), l), b = c ? e.mintB.address : e.mintA.address, g = _e(d, u[b], o, false), A = fe.sqrtPriceX64ToPrice(f, e.mintA.decimals, e.mintB.decimals), k = c ? A : new O(1).div(A), I = d.mul(new $e.default(Math.floor((1 + s) * 1e10))).div(new $e.default(1e10)), T = _e(I, u[b], o, true), h = c ? e.currentPrice : new O(1).div(e.currentPrice), S = new O(k).sub(h).abs(), x = h, K = new ot(new O(S).mul(10 ** 15).toFixed(0), new O(x).mul(10 ** 15).toFixed(0));
        return { amountIn: g, maxAmountIn: T, realAmountOut: m, expirationTime: wn(g.expirationTime, m.expirationTime), currentPrice: e.currentPrice, executionPrice: k, priceImpact: K, fee: y, remainingAccounts: p };
      }
      static estimateAprsForPriceRangeMultiplier({ poolInfo: e, aprType: t, positionTickLowerIndex: n, positionTickUpperIndex: o }) {
        var f, y, b;
        let r = e[t], s = ne.getTickPrice({ poolInfo: e, tick: n, baseIn: true }).price.toNumber(), a = ne.getTickPrice({ poolInfo: e, tick: o, baseIn: true }).price.toNumber(), c = Math.max(s, r.priceMin), l = Math.min(a, r.priceMax) - c, m = a - s, d = r.priceMax - r.priceMin, p;
        return l <= 0 ? p = 0 : m === l ? p = d / l : d === l ? p = l / m : p = l / d * (l / m), { feeApr: r.feeApr * p, rewardsApr: [((f = r.rewardApr[0]) != null ? f : 0) * p, ((y = r.rewardApr[1]) != null ? y : 0) * p, ((b = r.rewardApr[2]) != null ? b : 0) * p], apr: r.apr * p };
      }
      static estimateAprsForPriceRangeDelta({ poolInfo: e, poolLiquidity: t, aprType: n, mintPrice: o, liquidity: r, positionTickLowerIndex: s, positionTickUpperIndex: a, chainTime: c }) {
        let u = n === "day" ? 1 : n === "week" ? 7 : n === "month" ? 30 : 0, l = e[n], m = o[Lt(e.mintA.address).toString()], d = o[Lt(e.mintB.address).toString()], p = e.mintA.decimals, f = e.mintB.decimals;
        if (!l || !m || !d)
          return { feeApr: 0, rewardsApr: [0, 0, 0], apr: 0 };
        let y = fe.priceToSqrtPriceX64(new O(e.price), e.mintA.decimals, e.mintB.decimals), b = fe.getSqrtPriceX64FromTick(s), g = fe.getSqrtPriceX64FromTick(a), { amountSlippageA: A, amountSlippageB: k } = Re.getAmountsFromLiquidityWithSlippage(y, b, g, t, false, false, 0), { amountSlippageA: I, amountSlippageB: T } = Re.getAmountsFromLiquidityWithSlippage(y, b, g, r, false, false, 0), h = new O(A.toString()).div(new O(10).pow(p)).mul(m.value).add(new O(k.toString()).div(new O(10).pow(f)).mul(d.value)), S = new O(I.toString()).div(new O(10).pow(p)).mul(m.value).add(new O(T.toString()).div(new O(10).pow(f)).mul(d.value)), x = new O(1).div(h.add(S)), B = new O(l.volumeFee).mul(365).div(u).mul(x).mul(100).toNumber(), C = 3600 * 24 * 365, R = e.rewardDefaultInfos.map((N) => {
          var M, Y;
          let v = N.mint.decimals, L = o[N.mint.address];
          return c < ((M = N.startTime) != null ? M : 0) || c > ((Y = N.endTime) != null ? Y : 0) || !N.perSecond || !L || v === void 0 ? 0 : new O(L.value).mul(new O(N.perSecond).mul(C)).div(new O(10).pow(v)).mul(x).mul(100).toNumber();
        });
        return { feeApr: B, rewardsApr: R, apr: B + R.reduce((N, v) => N + v, 0) };
      }
      static async getLiquidityAmountOutFromAmountIn({ poolInfo: e, inputA: t, tickLower: n, tickUpper: o, amount: r, slippage: s, add: a, epochInfo: c, amountHasFee: u }) {
        var g, A;
        let l = fe.priceToSqrtPriceX64(new O(e.price), e.mintA.decimals, e.mintB.decimals), m = fe.getSqrtPriceX64FromTick(n), d = fe.getSqrtPriceX64FromTick(o), p = _e(r, (g = e[t ? "mintA" : "mintB"].extensions) == null ? void 0 : g.feeConfig, c, !u), f = new $e.default(new O(p.amount.sub((A = p.fee) != null ? A : Ke).toString()).toFixed(0)), y;
        if (l.lte(m))
          y = t ? Re.getLiquidityFromTokenAmountA(m, d, f, !a) : new $e.default(0);
        else if (l.lte(d)) {
          let k = Re.getLiquidityFromTokenAmountA(l, d, f, !a), I = Re.getLiquidityFromTokenAmountB(m, l, f);
          y = t ? k : I;
        } else
          y = t ? new $e.default(0) : Re.getLiquidityFromTokenAmountB(m, d, f);
        let b = await Xe.getAmountsFromLiquidity({ epochInfo: c, poolInfo: e, tickLower: n, tickUpper: o, liquidity: y, slippage: s, add: a });
        return { liquidity: y, amountA: t ? p : b.amountA, amountB: t ? b.amountB : p, amountSlippageA: t ? p : b.amountSlippageA, amountSlippageB: t ? b.amountSlippageB : p, expirationTime: b.expirationTime };
      }
      static async getAmountsFromLiquidity({ epochInfo: e, poolInfo: t, tickLower: n, tickUpper: o, liquidity: r, slippage: s, add: a }) {
        var b, g, A, k;
        let c = fe.getSqrtPriceX64FromTick(n), u = fe.getSqrtPriceX64FromTick(o), l = a ? 1 + s : 1 - s, m = Re.getAmountsFromLiquidity(fe.priceToSqrtPriceX64(new O(t.price), t.mintA.decimals, t.mintB.decimals), c, u, r, a), [d, p] = [_e(m.amountA, (b = t.mintA.extensions) == null ? void 0 : b.feeConfig, e, true), _e(m.amountB, (g = t.mintB.extensions) == null ? void 0 : g.feeConfig, e, true)], [f, y] = [_e(m.amountA.muln(l), (A = t.mintA.extensions) == null ? void 0 : A.feeConfig, e, true), _e(m.amountB.muln(l), (k = t.mintB.extensions) == null ? void 0 : k.feeConfig, e, true)];
        return { liquidity: r, amountA: d, amountB: p, amountSlippageA: f, amountSlippageB: y, expirationTime: wn(d.expirationTime, p.expirationTime) };
      }
      static async fetchComputeMultipleClmmInfo({ connection: e, poolList: t, rpcDataMap: n = {} }) {
        let o = t.filter((c) => !n[c.id]).map((c) => new sn.PublicKey(c.id));
        (await gn(e, o)).forEach((c, u) => {
          !c || (n[o[u].toBase58()] = Bo.decode(c.data));
        });
        let s = t.map((c) => st(new sn.PublicKey(c.programId), new sn.PublicKey(c.id)).publicKey), a = await Xe.fetchExBitmaps({ connection: e, exBitmapAddress: s, batchRequest: false });
        return t.reduce((c, u) => U(E({}, c), { [u.id]: U(E({}, n[u.id]), { id: new sn.PublicKey(u.id), version: 6, programId: new sn.PublicKey(u.programId), mintA: u.mintA, mintB: u.mintB, ammConfig: U(E({}, u.config), { id: new sn.PublicKey(u.config.id), fundOwner: "" }), currentPrice: new O(u.price), exBitmapAccount: st(new sn.PublicKey(u.programId), new sn.PublicKey(u.id)).publicKey, exBitmapInfo: a[st(new sn.PublicKey(u.programId), new sn.PublicKey(u.id)).publicKey.toBase58()], startTime: n[u.id].startTime.toNumber(), rewardInfos: n[u.id].rewardInfos }) }), {});
      }
      static async fetchComputeClmmInfo({ connection: e, poolInfo: t, rpcData: n }) {
        return (await this.fetchComputeMultipleClmmInfo({ connection: e, rpcDataMap: n ? { [t.id]: n } : void 0, poolList: [t] }))[t.id];
      }
    };
    function wb({ poolInfo: i, tickLower: e, tickUpper: t, amountA: n, amountB: o, slippage: r, add: s, epochInfo: a, amountHasFee: c }) {
      var k, I, T, h;
      let [u, l, m, d] = e < t ? [e, t, n, o] : [t, e, o, n], p = fe.priceToSqrtPriceX64(new O(i.price), i.mintA.decimals, i.mintB.decimals), f = fe.getSqrtPriceX64FromTick(u), y = fe.getSqrtPriceX64FromTick(l), [b, g] = [_e(m, (k = i.mintA.extensions) == null ? void 0 : k.feeConfig, a, !c), _e(d, (I = i.mintB.extensions) == null ? void 0 : I.feeConfig, a, !c)], A = Re.getLiquidityFromTokenAmounts(p, f, y, b.amount.sub((T = b.fee) != null ? T : Ke), g.amount.sub((h = g.fee) != null ? h : Ke));
      return Re.getAmountsOutFromLiquidity({ poolInfo: i, tickLower: e, tickUpper: t, liquidity: A, slippage: r, add: s, epochInfo: a, amountAddFee: !c });
    }
    var Kc = { volume: 0, volumeQuote: 0, volumeFee: 0, apr: 0, feeApr: 0, priceMin: 0, priceMax: 0, rewardApr: [] };
    function Rc(i) {
      return U(E({}, i), { type: "Concentrated", programId: i.programId.toString(), id: i.id.toString(), rewardDefaultInfos: [], rewardDefaultPoolInfos: "Clmm", price: i.currentPrice.toNumber(), mintAmountA: 0, mintAmountB: 0, feeRate: i.ammConfig.tradeFeeRate, openTime: i.startTime.toString(), tvl: 0, day: Kc, week: Kc, month: Kc, pooltype: [], farmUpcomingCount: 0, farmOngoingCount: 0, farmFinishedCount: 0, burnPercent: 0, config: U(E({}, i.ammConfig), { id: i.ammConfig.id.toString(), defaultRange: 0, defaultRangePoint: [] }) });
    }
    var Pe = class {
      static mulDivRoundingUp(e, t, n) {
        let o = e.mul(t), r = o.div(n);
        return o.mod(n).eq(Ke) || (r = r.add(rn)), r;
      }
      static mulDivFloor(e, t, n) {
        if (n.eq(Ke))
          throw new Error("division by 0");
        return e.mul(t).div(n);
      }
      static mulDivCeil(e, t, n) {
        if (n.eq(Ke))
          throw new Error("division by 0");
        return e.mul(t).add(n.sub(rn)).div(n);
      }
      static x64ToDecimal(e, t) {
        return new O(e.toString()).div(O.pow(2, 64)).toDecimalPlaces(t);
      }
      static decimalToX64(e) {
        return new Be.default(e.mul(O.pow(2, 64)).floor().toFixed());
      }
      static wrappingSubU128(e, t) {
        return e.add(Pr).sub(t).mod(Pr);
      }
    };
    function Ct(i, e) {
      return Nc(i.mul(e), 64, 256);
    }
    function kb(i, e, t) {
      let n = i.toTwos(t).shln(e);
      return n.imaskn(t + 1), n.fromTwos(t);
    }
    function Nc(i, e, t) {
      let n = i.toTwos(t).shrn(e);
      return n.imaskn(t - e + 1), n.fromTwos(t - e);
    }
    var fe = class {
      static sqrtPriceX64ToPrice(e, t, n) {
        return Pe.x64ToDecimal(e).pow(2).mul(O.pow(10, t - n));
      }
      static priceToSqrtPriceX64(e, t, n) {
        return Pe.decimalToX64(e.mul(O.pow(10, n - t)).sqrt());
      }
      static getNextSqrtPriceX64FromInput(e, t, n, o) {
        if (!e.gt(Ke))
          throw new Error("sqrtPriceX64 must greater than 0");
        if (!t.gt(Ke))
          throw new Error("liquidity must greater than 0");
        return o ? this.getNextSqrtPriceFromTokenAmountARoundingUp(e, t, n, true) : this.getNextSqrtPriceFromTokenAmountBRoundingDown(e, t, n, true);
      }
      static getNextSqrtPriceX64FromOutput(e, t, n, o) {
        if (!e.gt(Ke))
          throw new Error("sqrtPriceX64 must greater than 0");
        if (!t.gt(Ke))
          throw new Error("liquidity must greater than 0");
        return o ? this.getNextSqrtPriceFromTokenAmountBRoundingDown(e, t, n, false) : this.getNextSqrtPriceFromTokenAmountARoundingUp(e, t, n, false);
      }
      static getNextSqrtPriceFromTokenAmountARoundingUp(e, t, n, o) {
        if (n.eq(Ke))
          return e;
        let r = t.shln(hi);
        if (o) {
          let s = r, a = r.add(n.mul(e));
          return a.gte(s) ? Pe.mulDivCeil(s, e, a) : Pe.mulDivRoundingUp(s, rn, s.div(e).add(n));
        } else {
          let s = n.mul(e);
          if (!r.gt(s))
            throw new Error("getNextSqrtPriceFromTokenAmountARoundingUp,liquidityLeftShift must gt amountMulSqrtPrice");
          let a = r.sub(s);
          return Pe.mulDivCeil(r, e, a);
        }
      }
      static getNextSqrtPriceFromTokenAmountBRoundingDown(e, t, n, o) {
        let r = n.shln(hi);
        if (o)
          return e.add(r.div(t));
        {
          let s = Pe.mulDivRoundingUp(r, rn, t);
          if (!e.gt(s))
            throw new Error("getNextSqrtPriceFromTokenAmountBRoundingDown sqrtPriceX64 must gt amountDivLiquidity");
          return e.sub(s);
        }
      }
      static getSqrtPriceX64FromTick(e) {
        if (!Number.isInteger(e))
          throw new Error("tick must be integer");
        if (e < Mt || e > Dt)
          throw new Error("tick must be in MIN_TICK and MAX_TICK");
        let t = e < 0 ? e * -1 : e, n = (t & 1) != 0 ? new Be.default("18445821805675395072") : new Be.default("18446744073709551616");
        return (t & 2) != 0 && (n = Ct(n, new Be.default("18444899583751176192"))), (t & 4) != 0 && (n = Ct(n, new Be.default("18443055278223355904"))), (t & 8) != 0 && (n = Ct(n, new Be.default("18439367220385607680"))), (t & 16) != 0 && (n = Ct(n, new Be.default("18431993317065453568"))), (t & 32) != 0 && (n = Ct(n, new Be.default("18417254355718170624"))), (t & 64) != 0 && (n = Ct(n, new Be.default("18387811781193609216"))), (t & 128) != 0 && (n = Ct(n, new Be.default("18329067761203558400"))), (t & 256) != 0 && (n = Ct(n, new Be.default("18212142134806163456"))), (t & 512) != 0 && (n = Ct(n, new Be.default("17980523815641700352"))), (t & 1024) != 0 && (n = Ct(n, new Be.default("17526086738831433728"))), (t & 2048) != 0 && (n = Ct(n, new Be.default("16651378430235570176"))), (t & 4096) != 0 && (n = Ct(n, new Be.default("15030750278694412288"))), (t & 8192) != 0 && (n = Ct(n, new Be.default("12247334978884435968"))), (t & 16384) != 0 && (n = Ct(n, new Be.default("8131365268886854656"))), (t & 32768) != 0 && (n = Ct(n, new Be.default("3584323654725218816"))), (t & 65536) != 0 && (n = Ct(n, new Be.default("696457651848324352"))), (t & 131072) != 0 && (n = Ct(n, new Be.default("26294789957507116"))), (t & 262144) != 0 && (n = Ct(n, new Be.default("37481735321082"))), e > 0 && (n = yc.div(n)), n;
      }
      static getTickFromPrice(e, t, n) {
        return fe.getTickFromSqrtPriceX64(fe.priceToSqrtPriceX64(e, t, n));
      }
      static getTickFromSqrtPriceX64(e) {
        if (e.gt(Ut) || e.lt(qt))
          throw new Error("Provided sqrtPrice is not within the supported sqrtPrice range.");
        let t = e.bitLength() - 1, n = new Be.default(t - 64), o = kb(n, 32, 128), r = new Be.default("8000000000000000", "hex"), s = 0, a = new Be.default(0), c = t >= 64 ? e.shrn(t - 63) : e.shln(63 - t);
        for (; r.gt(new Be.default(0)) && s < bc; ) {
          c = c.mul(c);
          let f = c.shrn(127);
          c = c.shrn(63 + f.toNumber()), a = a.add(r.mul(f)), r = r.shrn(1), s += 1;
        }
        let u = a.shrn(32), m = o.add(u).mul(new Be.default(gc)), d = Nc(m.sub(new Be.default(Pc)), 64, 128).toNumber(), p = Nc(m.add(new Be.default(Ac)), 64, 128).toNumber();
        return d == p ? d : fe.getSqrtPriceX64FromTick(p).lte(e) ? p : d;
      }
    };
    var xo = class {
      static getTickWithPriceAndTickspacing(e, t, n, o) {
        let s = fe.getTickFromSqrtPriceX64(fe.priceToSqrtPriceX64(e, n, o)) / t;
        return s < 0 ? s = Math.floor(s) : s = Math.ceil(s), s * t;
      }
      static roundPriceWithTickspacing(e, t, n, o) {
        let r = xo.getTickWithPriceAndTickspacing(e, t, n, o), s = fe.getSqrtPriceX64FromTick(r);
        return fe.sqrtPriceX64ToPrice(s, n, o);
      }
    };
    var Re = class {
      static addDelta(e, t) {
        return e.add(t);
      }
      static getTokenAmountAFromLiquidity(e, t, n, o) {
        if (e.gt(t) && ([e, t] = [t, e]), !e.gt(Ke))
          throw new Error("sqrtPriceX64A must greater than 0");
        let r = n.ushln(hi), s = t.sub(e);
        return o ? Pe.mulDivRoundingUp(Pe.mulDivCeil(r, s, t), rn, e) : Pe.mulDivFloor(r, s, t).div(e);
      }
      static getTokenAmountBFromLiquidity(e, t, n, o) {
        if (e.gt(t) && ([e, t] = [t, e]), !e.gt(Ke))
          throw new Error("sqrtPriceX64A must greater than 0");
        return o ? Pe.mulDivCeil(n, t.sub(e), Pt) : Pe.mulDivFloor(n, t.sub(e), Pt);
      }
      static getLiquidityFromTokenAmountA(e, t, n, o) {
        e.gt(t) && ([e, t] = [t, e]);
        let r = n.mul(e).mul(t), s = t.sub(e), a = r.div(s);
        return o ? Pe.mulDivRoundingUp(a, rn, ki) : a.shrn(hi);
      }
      static getLiquidityFromTokenAmountB(e, t, n) {
        return e.gt(t) && ([e, t] = [t, e]), Pe.mulDivFloor(n, ki, t.sub(e));
      }
      static getLiquidityFromTokenAmounts(e, t, n, o, r) {
        if (t.gt(n) && ([t, n] = [n, t]), e.lte(t))
          return Re.getLiquidityFromTokenAmountA(t, n, o, false);
        if (e.lt(n)) {
          let s = Re.getLiquidityFromTokenAmountA(e, n, o, false), a = Re.getLiquidityFromTokenAmountB(t, e, r);
          return s.lt(a) ? s : a;
        } else
          return Re.getLiquidityFromTokenAmountB(t, n, r);
      }
      static getAmountsFromLiquidity(e, t, n, o, r) {
        if (t.gt(n) && ([t, n] = [n, t]), e.lte(t))
          return { amountA: Re.getTokenAmountAFromLiquidity(t, n, o, r), amountB: new Be.default(0) };
        if (e.lt(n)) {
          let s = Re.getTokenAmountAFromLiquidity(e, n, o, r), a = Re.getTokenAmountBFromLiquidity(t, e, o, r);
          return { amountA: s, amountB: a };
        } else
          return { amountA: new Be.default(0), amountB: Re.getTokenAmountBFromLiquidity(t, n, o, r) };
      }
      static getAmountsFromLiquidityWithSlippage(e, t, n, o, r, s, a) {
        let { amountA: c, amountB: u } = Re.getAmountsFromLiquidity(e, t, n, o, s), l = r ? 1 + a : 1 - a, m = new Be.default(new O(c.toString()).mul(l).toFixed(0)), d = new Be.default(new O(u.toString()).mul(l).toFixed(0));
        return { amountSlippageA: m, amountSlippageB: d };
      }
      static getAmountsOutFromLiquidity({ poolInfo: e, tickLower: t, tickUpper: n, liquidity: o, slippage: r, add: s, epochInfo: a, amountAddFee: c }) {
        var A, k, I, T;
        let u = fe.priceToSqrtPriceX64(new O(e.price), e.mintA.decimals, e.mintB.decimals), l = fe.getSqrtPriceX64FromTick(t), m = fe.getSqrtPriceX64FromTick(n), d = s ? 1 + r : 1 - r, p = Re.getAmountsFromLiquidity(u, l, m, o, s), [f, y] = [_e(p.amountA, (A = e.mintA.extensions) == null ? void 0 : A.feeConfig, a, c), _e(p.amountB, (k = e.mintB.extensions) == null ? void 0 : k.feeConfig, a, c)], [b, g] = [_e(new Be.default(new O(p.amountA.toString()).mul(d).toFixed(0)), (I = e.mintA.extensions) == null ? void 0 : I.feeConfig, a, c), _e(new Be.default(new O(p.amountB.toString()).mul(d).toFixed(0)), (T = e.mintB.extensions) == null ? void 0 : T.feeConfig, a, c)];
        return { liquidity: o, amountA: f, amountB: y, amountSlippageA: b, amountSlippageB: g, expirationTime: wn(f.expirationTime, y.expirationTime) };
      }
    };
    var Io = class {
      static swapCompute(e, t, n, o, r, s, a, c, u, l, m, d, p, f, y = false) {
        if (d.eq(Ke))
          throw new Error("amountSpecified must not be 0");
        if (f || (f = s ? qt.add(rn) : Ut.sub(rn)), s) {
          if (f.lt(qt))
            throw new Error("sqrtPriceX64 must greater than MIN_SQRT_PRICE_X64");
          if (f.gte(m))
            throw new Error("sqrtPriceX64 must smaller than current");
        } else {
          if (f.gt(Ut))
            throw new Error("sqrtPriceX64 must smaller than MAX_SQRT_PRICE_X64");
          if (f.lte(m))
            throw new Error("sqrtPriceX64 must greater than current");
        }
        let b = d.gt(Ke), g = { amountSpecifiedRemaining: d, amountCalculated: Ke, sqrtPriceX64: m, tick: u > p ? Math.min(p + Ne.tickCount(l) - 1, u) : p, accounts: [], liquidity: c, feeAmount: new Be.default(0) }, A = p, k = n[p], I = 0, T = !s && k.startTickIndex === g.tick;
        for (; !g.amountSpecifiedRemaining.eq(Ke) && !g.sqrtPriceX64.eq(f); ) {
          I > 10;
          let h = {};
          h.sqrtPriceStartX64 = g.sqrtPriceX64;
          let S = ne.nextInitTick(k, g.tick, l, s, T), x = S || null, K = null;
          if (!(x != null && x.liquidityGross.gtn(0))) {
            let C = Xe.nextInitializedTickArrayStartIndex({ tickCurrent: g.tick, tickSpacing: l, tickArrayBitmap: o, exBitmapInfo: r }, A, s);
            if (!C.isExist) {
              if (y)
                return { allTrade: false, amountSpecifiedRemaining: g.amountSpecifiedRemaining, amountCalculated: g.amountCalculated, feeAmount: g.feeAmount, sqrtPriceX64: g.sqrtPriceX64, liquidity: g.liquidity, tickCurrent: g.tick, accounts: g.accounts };
              throw Error("swapCompute LiquidityInsufficient");
            }
            A = C.nextStartIndex;
            let { publicKey: R } = Ce(e, t, A);
            K = R, k = n[A];
            try {
              x = ne.firstInitializedTick(k, s);
            } catch {
              throw Error("not found next tick info");
            }
          }
          h.tickNext = x.tick, h.initialized = x.liquidityGross.gtn(0), p !== A && K && (g.accounts.push(K), p = A), h.tickNext < Mt ? h.tickNext = Mt : h.tickNext > Dt && (h.tickNext = Dt), h.sqrtPriceNextX64 = fe.getSqrtPriceX64FromTick(h.tickNext);
          let B;
          if (s && h.sqrtPriceNextX64.lt(f) || !s && h.sqrtPriceNextX64.gt(f) ? B = f : B = h.sqrtPriceNextX64, [g.sqrtPriceX64, h.amountIn, h.amountOut, h.feeAmount] = Io.swapStepCompute(g.sqrtPriceX64, B, g.liquidity, g.amountSpecifiedRemaining, a, s), g.feeAmount = g.feeAmount.add(h.feeAmount), b ? (g.amountSpecifiedRemaining = g.amountSpecifiedRemaining.sub(h.amountIn.add(h.feeAmount)), g.amountCalculated = g.amountCalculated.sub(h.amountOut)) : (g.amountSpecifiedRemaining = g.amountSpecifiedRemaining.add(h.amountOut), g.amountCalculated = g.amountCalculated.add(h.amountIn.add(h.feeAmount))), g.sqrtPriceX64.eq(h.sqrtPriceNextX64)) {
            if (h.initialized) {
              let C = x.liquidityNet;
              s && (C = C.mul(qn)), g.liquidity = Re.addDelta(g.liquidity, C);
            }
            T = h.tickNext != g.tick && !s && k.startTickIndex === h.tickNext, g.tick = s ? h.tickNext - 1 : h.tickNext;
          } else if (g.sqrtPriceX64 != h.sqrtPriceStartX64) {
            let C = fe.getTickFromSqrtPriceX64(g.sqrtPriceX64);
            T = C != g.tick && !s && k.startTickIndex === C, g.tick = C;
          }
          ++I;
        }
        try {
          let { nextStartIndex: h, isExist: S } = Ne.nextInitializedTickArray(g.tick, l, s, o, r);
          S && p !== h && (g.accounts.push(Ce(e, t, h).publicKey), p = h);
        } catch {
        }
        return { allTrade: true, amountSpecifiedRemaining: Ke, amountCalculated: g.amountCalculated, feeAmount: g.feeAmount, sqrtPriceX64: g.sqrtPriceX64, liquidity: g.liquidity, tickCurrent: g.tick, accounts: g.accounts };
      }
      static swapStepCompute(e, t, n, o, r, s) {
        let a = { sqrtPriceX64Next: new Be.default(0), amountIn: new Be.default(0), amountOut: new Be.default(0), feeAmount: new Be.default(0) }, c = o.gte(Ke);
        if (c) {
          let l = Pe.mulDivFloor(o, kr.sub(new Be.default(r.toString())), kr);
          a.amountIn = s ? Re.getTokenAmountAFromLiquidity(t, e, n, true) : Re.getTokenAmountBFromLiquidity(e, t, n, true), l.gte(a.amountIn) ? a.sqrtPriceX64Next = t : a.sqrtPriceX64Next = fe.getNextSqrtPriceX64FromInput(e, n, l, s);
        } else
          a.amountOut = s ? Re.getTokenAmountBFromLiquidity(t, e, n, false) : Re.getTokenAmountAFromLiquidity(e, t, n, false), o.mul(qn).gte(a.amountOut) ? a.sqrtPriceX64Next = t : a.sqrtPriceX64Next = fe.getNextSqrtPriceX64FromOutput(e, n, o.mul(qn), s);
        let u = t.eq(a.sqrtPriceX64Next);
        return s ? (u && c || (a.amountIn = Re.getTokenAmountAFromLiquidity(a.sqrtPriceX64Next, e, n, true)), u && !c || (a.amountOut = Re.getTokenAmountBFromLiquidity(a.sqrtPriceX64Next, e, n, false))) : (a.amountIn = u && c ? a.amountIn : Re.getTokenAmountBFromLiquidity(e, a.sqrtPriceX64Next, n, true), a.amountOut = u && !c ? a.amountOut : Re.getTokenAmountAFromLiquidity(e, a.sqrtPriceX64Next, n, false)), !c && a.amountOut.gt(o.mul(qn)) && (a.amountOut = o.mul(qn)), c && !a.sqrtPriceX64Next.eq(t) ? a.feeAmount = o.sub(a.amountIn) : a.feeAmount = Pe.mulDivCeil(a.amountIn, new Be.default(r), kr.sub(new Be.default(r))), [a.sqrtPriceX64Next, a.amountIn, a.amountOut, a.feeAmount];
      }
    };
    var At = 60;
    var To = 512;
    var ne = class {
      static getTickArrayAddressByTick(e, t, n, o) {
        let r = ne.getTickArrayStartIndexByTick(n, o), { publicKey: s } = Ce(e, t, r);
        return s;
      }
      static getTickOffsetInArray(e, t) {
        if (e % t != 0)
          throw new Error("tickIndex % tickSpacing not equal 0");
        let n = ne.getTickArrayStartIndexByTick(e, t), o = Math.floor((e - n) / t);
        if (o < 0 || o >= At)
          throw new Error("tick offset in array overflow");
        return o;
      }
      static getTickArrayBitIndex(e, t) {
        let n = Ne.tickCount(t), o = e / n;
        return e < 0 && e % n != 0 ? o = Math.ceil(o) - 1 : o = Math.floor(o), o;
      }
      static getTickArrayStartIndexByTick(e, t) {
        return this.getTickArrayBitIndex(e, t) * Ne.tickCount(t);
      }
      static getTickArrayOffsetInBitmapByTick(e, t) {
        let n = t * At, o = Math.floor(e / n) + 512;
        return Math.abs(o);
      }
      static checkTickArrayIsInitialized(e, t, n) {
        let o = n * At, r = Math.floor(t / o) + 512, s = Math.abs(r);
        return { isInitialized: e.testn(s), startIndex: (s - 512) * o };
      }
      static getNextTickArrayStartIndex(e, t, n) {
        return n ? e - t * At : e + t * At;
      }
      static mergeTickArrayBitmap(e) {
        let t = new xd.default(0);
        for (let n = 0; n < e.length; n++)
          t = t.add(e[n].shln(64 * n));
        return t;
      }
      static getInitializedTickArrayInRange(e, t, n, o, r) {
        let s = Math.floor(o / (n * At));
        return [...ne.searchLowBitFromStart(e, t, s - 1, r, n), ...ne.searchHightBitFromStart(e, t, s, r, n)];
      }
      static getAllInitializedTickArrayStartIndex(e, t, n) {
        return ne.searchHightBitFromStart(e, t, -7680, To, n);
      }
      static getAllInitializedTickArrayInfo(e, t, n, o, r) {
        let s = [], a = ne.getAllInitializedTickArrayStartIndex(n, o, r);
        for (let c of a) {
          let { publicKey: u } = Ce(e, t, c);
          s.push({ tickArrayStartIndex: c, tickArrayAddress: u });
        }
        return s;
      }
      static getAllInitializedTickInTickArray(e) {
        return e.ticks.filter((t) => t.liquidityGross.gtn(0));
      }
      static searchLowBitFromStart(e, t, n, o, r) {
        let s = [...[...t.negativeTickArrayBitmap].reverse(), e.slice(0, 8), e.slice(8, 16), ...t.positiveTickArrayBitmap].map((u) => ne.mergeTickArrayBitmap(u)), a = [];
        for (; n >= -7680; ) {
          let u = Math.floor((n + 7680) / 512), l = (n + 7680) % 512;
          if (s[u].testn(l) && a.push(n), n--, a.length === o)
            break;
        }
        let c = Ne.tickCount(r);
        return a.map((u) => u * c);
      }
      static searchHightBitFromStart(e, t, n, o, r) {
        let s = [...[...t.negativeTickArrayBitmap].reverse(), e.slice(0, 8), e.slice(8, 16), ...t.positiveTickArrayBitmap].map((u) => ne.mergeTickArrayBitmap(u)), a = [];
        for (; n < 7680; ) {
          let u = Math.floor((n + 7680) / 512), l = (n + 7680) % 512;
          if (s[u].testn(l) && a.push(n), n++, a.length === o)
            break;
        }
        let c = Ne.tickCount(r);
        return a.map((u) => u * c);
      }
      static checkIsOutOfBoundary(e) {
        return e < Mt || e > Dt;
      }
      static nextInitTick(e, t, n, o, r) {
        if (Ne.getArrayStartIndex(t, n) != e.startTickIndex)
          return null;
        let a = Math.floor((t - e.startTickIndex) / n);
        if (o)
          for (; a >= 0; ) {
            if (e.ticks[a].liquidityGross.gtn(0))
              return e.ticks[a];
            a = a - 1;
          }
        else
          for (r || (a = a + 1); a < At; ) {
            if (e.ticks[a].liquidityGross.gtn(0))
              return e.ticks[a];
            a = a + 1;
          }
        return null;
      }
      static firstInitializedTick(e, t) {
        if (t) {
          let n = At - 1;
          for (; n >= 0; ) {
            if (e.ticks[n].liquidityGross.gtn(0))
              return e.ticks[n];
            n = n - 1;
          }
        } else {
          let n = 0;
          for (; n < At; ) {
            if (e.ticks[n].liquidityGross.gtn(0))
              return e.ticks[n];
            n = n + 1;
          }
        }
        throw Error(`firstInitializedTick check error: ${e} - ${t}`);
      }
      static _getTickPriceLegacy({ poolInfo: e, tick: t, baseIn: n }) {
        let o = fe.getSqrtPriceX64FromTick(t), r = fe.sqrtPriceX64ToPrice(o, e.mintA.decimals, e.mintB.decimals);
        return n ? { tick: t, price: r, tickSqrtPriceX64: o } : { tick: t, price: new O(1).div(r), tickSqrtPriceX64: o };
      }
      static _getPriceAndTickLegacy({ poolInfo: e, price: t, baseIn: n }) {
        let o = n ? t : new O(1).div(t), r = xo.getTickWithPriceAndTickspacing(o, e.ammConfig.tickSpacing, e.mintA.decimals, e.mintB.decimals), s = fe.getSqrtPriceX64FromTick(r), a = fe.sqrtPriceX64ToPrice(s, e.mintA.decimals, e.mintB.decimals);
        return n ? { tick: r, price: a } : { tick: r, price: new O(1).div(a) };
      }
      static getTickPrice({ poolInfo: e, tick: t, baseIn: n }) {
        let o = fe.getSqrtPriceX64FromTick(t), r = fe.sqrtPriceX64ToPrice(o, e.mintA.decimals, e.mintB.decimals);
        return n ? { tick: t, price: r, tickSqrtPriceX64: o } : { tick: t, price: new O(1).div(r), tickSqrtPriceX64: o };
      }
      static getPriceAndTick({ poolInfo: e, price: t, baseIn: n }) {
        let o = n ? t : new O(1).div(t), r = xo.getTickWithPriceAndTickspacing(o, e.config.tickSpacing, e.mintA.decimals, e.mintB.decimals), s = fe.getSqrtPriceX64FromTick(r), a = fe.sqrtPriceX64ToPrice(s, e.mintA.decimals, e.mintB.decimals);
        return n ? { tick: r, price: a } : { tick: r, price: new O(1).div(a) };
      }
    };
    var Oc = V([Fe(8), W("bump"), on("index"), F(""), St("protocolFeeRate"), St("tradeFeeRate"), on("tickSpacing"), Z(P2(), 8, "")]);
    var Sd = V([St("blockTimestamp"), Eo("tickCumulative"), Z(P2(), 4)]);
    var Mc = V([Fe(8), Ze("initialized"), P2("recentEpoch"), on("observationIndex"), F("poolId"), Z(Sd, 100, "observations"), Z(P2(), 4)]);
    var Kd = V([W("rewardState"), P2("openTime"), P2("endTime"), P2("lastUpdateTime"), ae("emissionsPerSecondX64"), P2("rewardTotalEmissioned"), P2("rewardClaimed"), F("tokenMint"), F("tokenVault"), F("creator"), ae("rewardGrowthGlobalX64")]);
    var Bo = V([Fe(8), W("bump"), F("ammConfig"), F("creator"), F("mintA"), F("mintB"), F("vaultA"), F("vaultB"), F("observationId"), W("mintDecimalsA"), W("mintDecimalsB"), on("tickSpacing"), ae("liquidity"), ae("sqrtPriceX64"), je("tickCurrent"), St(), ae("feeGrowthGlobalX64A"), ae("feeGrowthGlobalX64B"), P2("protocolFeesTokenA"), P2("protocolFeesTokenB"), ae("swapInAmountTokenA"), ae("swapOutAmountTokenB"), ae("swapInAmountTokenB"), ae("swapOutAmountTokenA"), W("status"), Z(W(), 7, ""), Z(Kd, 3, "rewardInfos"), Z(P2(), 16, "tickArrayBitmap"), P2("totalFeesTokenA"), P2("totalFeesClaimedTokenA"), P2("totalFeesTokenB"), P2("totalFeesClaimedTokenB"), P2("fundFeesTokenA"), P2("fundFeesTokenB"), P2("startTime"), Z(P2(), 15 * 4 - 3, "padding")]);
    var Cd = V([ae("growthInsideLastX64"), P2("rewardAmountOwed")]);
    var Uo = V([Fe(8), W("bump"), F("nftMint"), F("poolId"), je("tickLower"), je("tickUpper"), ae("liquidity"), ae("feeGrowthInsideLastX64A"), ae("feeGrowthInsideLastX64B"), P2("tokenFeesOwedA"), P2("tokenFeesOwedB"), Z(Cd, 3, "rewardInfos"), Z(P2(), 8, "")]);
    var hb = V([Fe(8), W("bump"), F("poolId"), je("tickLowerIndex"), je("tickUpperIndex"), ae("liquidity"), ae("feeGrowthInsideLastX64A"), ae("feeGrowthInsideLastX64B"), P2("tokenFeesOwedA"), P2("tokenFeesOwedB"), Z(ae(), 3, "rewardGrowthInside"), Z(P2(), 8, "")]);
    var Rd = V([je("tick"), zu("liquidityNet"), ae("liquidityGross"), ae("feeGrowthOutsideX64A"), ae("feeGrowthOutsideX64B"), Z(ae(), 3, "rewardGrowthsOutsideX64"), Z(St(), 13, "")]);
    var xi = V([Fe(8), F("poolId"), je("startTickIndex"), Z(Rd, At, "ticks"), W("initializedTickCount"), Z(W(), 115, "")]);
    var vc = V([Fe(329), Z(F(), 100, "whitelistMints")]);
    var Lc = V([Fe(8), F("poolId"), Z(Z(P2(), 8), ka, "positiveTickArrayBitmap"), Z(Z(P2(), 8), ka, "negativeTickArrayBitmap")]);
    var Tb = V([P2(), W("bump"), F("owner"), F("poolId"), F("positionId"), F("nftAccount"), Z(P2(), 8)]);
    var Fc = V([Fe(8), W("bump"), F("lockOwner"), F("poolId"), F("positionId"), F("nftAccount"), F("lockNftMint"), P2("recentEpoch"), Z(P2(), 8)]);
    Mc.span;
    var Ld = xe("Raydium_Clmm");
    var pn = { createPool: [233, 146, 209, 142, 207, 104, 64, 188], initReward: [95, 135, 192, 196, 242, 129, 230, 68], setRewardEmissions: [112, 52, 167, 75, 32, 201, 211, 137], openPosition: [77, 184, 74, 214, 112, 86, 241, 199], openPositionWithTokenEx: [77, 255, 174, 82, 125, 29, 201, 46], closePosition: [123, 134, 81, 0, 49, 68, 98, 98], increaseLiquidity: [133, 29, 89, 223, 69, 238, 176, 10], decreaseLiquidity: [58, 127, 188, 62, 79, 82, 196, 96], swap: [43, 4, 237, 11, 26, 201, 30, 98], collectReward: [18, 237, 166, 197, 34, 16, 213, 144] };
    var Nd = [188, 37, 179, 131, 82, 150, 84, 73];
    var Od = [16, 72, 250, 198, 14, 162, 212, 19];
    var Oe = class {
      static createPoolInstruction(e, t, n, o, r, s, a, c, u, l, m, d, p, f) {
        let y = V([ae("sqrtPriceX64"), P2("zero")]), b = [{ pubkey: n, isSigner: true, isWritable: true }, { pubkey: o, isSigner: false, isWritable: false }, { pubkey: t, isSigner: false, isWritable: true }, { pubkey: s, isSigner: false, isWritable: false }, { pubkey: u, isSigner: false, isWritable: false }, { pubkey: a, isSigner: false, isWritable: true }, { pubkey: l, isSigner: false, isWritable: true }, { pubkey: r, isSigner: false, isWritable: true }, { pubkey: d, isSigner: false, isWritable: true }, { pubkey: c, isSigner: false, isWritable: false }, { pubkey: m, isSigner: false, isWritable: false }, { pubkey: q.SystemProgram.programId, isSigner: false, isWritable: false }, { pubkey: at, isSigner: false, isWritable: false }, ...(f == null ? void 0 : f.map((k) => ({ pubkey: k, isSigner: false, isWritable: false }))) || []], g = Buffer.alloc(y.span);
        y.encode({ sqrtPriceX64: p, zero: Ke }, g);
        let A = Buffer.from([...pn.createPool, ...g]);
        return new q.TransactionInstruction({ keys: b, programId: e, data: A });
      }
      static async createPoolInstructions(e) {
        let { programId: t, owner: n, mintA: o, mintB: r, ammConfigId: s, initialPriceX64: a, extendMintAccount: c } = e, [u, l] = [new q.PublicKey(o.address), new q.PublicKey(r.address)], { publicKey: m } = Ic(t, s, u, l), { publicKey: d } = xc(t, m), { publicKey: p } = Pa(t, m, u), { publicKey: f } = Pa(t, m, l), y = st(t, m).publicKey, b = [this.createPoolInstruction(t, m, n, s, d, u, p, new q.PublicKey(o.programId || re.TOKEN_PROGRAM_ID), l, f, new q.PublicKey(r.programId || re.TOKEN_PROGRAM_ID), y, a, c)];
        return { signers: [], instructions: b, instructionTypes: [X.CreateAccount, X.ClmmCreatePool], address: { poolId: m, observationId: d, exBitmapAccount: y, mintAVault: p, mintBVault: f }, lookupTableAddress: [] };
      }
      static openPositionFromLiquidityInstruction(e, t, n, o, r, s, a, c, u, l, m, d, p, f, y, b, g, A, k, I, T, h, S, x, K, B) {
        let C = V([je("tickLowerIndex"), je("tickUpperIndex"), je("tickArrayLowerStartIndex"), je("tickArrayUpperStartIndex"), ae("liquidity"), P2("amountMaxA"), P2("amountMaxB"), Ze("withMetadata"), W("optionBaseFlag"), Ze("baseFlag")]), R = [...B ? [{ pubkey: B, isSigner: false, isWritable: true }] : []], N = [{ pubkey: t, isSigner: true, isWritable: true }, { pubkey: o, isSigner: false, isWritable: false }, { pubkey: r, isSigner: true, isWritable: true }, { pubkey: s, isSigner: false, isWritable: true }, { pubkey: a, isSigner: false, isWritable: true }, { pubkey: n, isSigner: false, isWritable: true }, { pubkey: c, isSigner: false, isWritable: true }, { pubkey: u, isSigner: false, isWritable: true }, { pubkey: l, isSigner: false, isWritable: true }, { pubkey: m, isSigner: false, isWritable: true }, { pubkey: d, isSigner: false, isWritable: true }, { pubkey: p, isSigner: false, isWritable: true }, { pubkey: f, isSigner: false, isWritable: true }, { pubkey: y, isSigner: false, isWritable: true }, { pubkey: at, isSigner: false, isWritable: false }, { pubkey: q.SystemProgram.programId, isSigner: false, isWritable: false }, { pubkey: re.TOKEN_PROGRAM_ID, isSigner: false, isWritable: false }, { pubkey: re.ASSOCIATED_TOKEN_PROGRAM_ID, isSigner: false, isWritable: false }, { pubkey: cn, isSigner: false, isWritable: false }, { pubkey: re.TOKEN_2022_PROGRAM_ID, isSigner: false, isWritable: false }, { pubkey: b, isSigner: false, isWritable: false }, { pubkey: g, isSigner: false, isWritable: false }, ...R], v = Buffer.alloc(C.span);
        C.encode({ tickLowerIndex: A, tickUpperIndex: k, tickArrayLowerStartIndex: I, tickArrayUpperStartIndex: T, liquidity: h, amountMaxA: S, amountMaxB: x, withMetadata: K === "create", baseFlag: false, optionBaseFlag: 0 }, v);
        let L = Buffer.from([...pn.openPosition, ...v]);
        return new q.TransactionInstruction({ keys: N, programId: e, data: L });
      }
      static openPositionFromLiquidityInstruction22(e, t, n, o, r, s, a, c, u, l, m, d, p, f, y, b, g, A, k, I, T, h, S, x, K) {
        let B = V([je("tickLowerIndex"), je("tickUpperIndex"), je("tickArrayLowerStartIndex"), je("tickArrayUpperStartIndex"), ae("liquidity"), P2("amountMaxA"), P2("amountMaxB"), Ze("withMetadata"), W("optionBaseFlag"), Ze("baseFlag")]), C = [...K ? [{ pubkey: K, isSigner: false, isWritable: true }] : []], R = [{ pubkey: t, isSigner: true, isWritable: true }, { pubkey: o, isSigner: false, isWritable: false }, { pubkey: r, isSigner: true, isWritable: true }, { pubkey: s, isSigner: false, isWritable: true }, { pubkey: n, isSigner: false, isWritable: true }, { pubkey: a, isSigner: false, isWritable: true }, { pubkey: c, isSigner: false, isWritable: true }, { pubkey: u, isSigner: false, isWritable: true }, { pubkey: l, isSigner: false, isWritable: true }, { pubkey: m, isSigner: false, isWritable: true }, { pubkey: d, isSigner: false, isWritable: true }, { pubkey: p, isSigner: false, isWritable: true }, { pubkey: f, isSigner: false, isWritable: true }, { pubkey: at, isSigner: false, isWritable: false }, { pubkey: q.SystemProgram.programId, isSigner: false, isWritable: false }, { pubkey: re.TOKEN_PROGRAM_ID, isSigner: false, isWritable: false }, { pubkey: re.ASSOCIATED_TOKEN_PROGRAM_ID, isSigner: false, isWritable: false }, { pubkey: re.TOKEN_2022_PROGRAM_ID, isSigner: false, isWritable: false }, { pubkey: y, isSigner: false, isWritable: false }, { pubkey: b, isSigner: false, isWritable: false }, ...C], N = Buffer.alloc(B.span);
        B.encode({ tickLowerIndex: g, tickUpperIndex: A, tickArrayLowerStartIndex: k, tickArrayUpperStartIndex: I, liquidity: T, amountMaxA: h, amountMaxB: S, withMetadata: x === "create", baseFlag: false, optionBaseFlag: 0 }, N);
        let v = Buffer.from([...pn.openPositionWithTokenEx, ...N]);
        return new q.TransactionInstruction({ keys: R, programId: e, data: v });
      }
      static async openPositionInstructions({ poolInfo: e, poolKeys: t, ownerInfo: n, tickLower: o, tickUpper: r, liquidity: s, amountMaxA: a, amountMaxB: c, withMetadata: u, getEphemeralSigners: l, nft2022: m }) {
        let d = [], [p, f] = [new q.PublicKey(e.programId), new q.PublicKey(e.id)], y;
        if (l)
          y = new q.PublicKey((await l(1))[0]);
        else {
          let K = q.Keypair.generate();
          d.push(K), y = K.publicKey;
        }
        let b = ne.getTickArrayStartIndexByTick(o, e.config.tickSpacing), g = ne.getTickArrayStartIndexByTick(r, e.config.tickSpacing), { publicKey: A } = Ce(p, f, b), { publicKey: k } = Ce(p, f, g), { publicKey: I } = m ? te(n.wallet, y, re.TOKEN_2022_PROGRAM_ID) : te(n.wallet, y, re.TOKEN_PROGRAM_ID), { publicKey: T } = Un(y), { publicKey: h } = Gt(p, y), { publicKey: S } = hn(p, f, o, r), x = m ? this.openPositionFromLiquidityInstruction22(p, n.feePayer, f, n.wallet, y, I, S, A, k, h, n.tokenAccountA, n.tokenAccountB, new q.PublicKey(t.vault.A), new q.PublicKey(t.vault.B), new q.PublicKey(e.mintA.address), new q.PublicKey(e.mintB.address), o, r, b, g, s, a, c, u, Xe.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing, [b, g]) ? st(p, f).publicKey : void 0) : this.openPositionFromLiquidityInstruction(p, n.feePayer, f, n.wallet, y, I, T, S, A, k, h, n.tokenAccountA, n.tokenAccountB, new q.PublicKey(t.vault.A), new q.PublicKey(t.vault.B), new q.PublicKey(e.mintA.address), new q.PublicKey(e.mintB.address), o, r, b, g, s, a, c, u, Xe.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing, [b, g]) ? st(p, f).publicKey : void 0);
        return { signers: d, instructions: [x], instructionTypes: [X.ClmmOpenPosition], lookupTableAddress: t.lookupTableAccount ? [t.lookupTableAccount] : [], address: { nftMint: y, tickArrayLower: A, tickArrayUpper: k, positionNftAccount: I, metadataAccount: T, personalPosition: h, protocolPosition: S } };
      }
      static async openPositionFromBaseInstructions({ poolInfo: e, poolKeys: t, ownerInfo: n, tickLower: o, tickUpper: r, base: s, baseAmount: a, otherAmountMax: c, withMetadata: u, getEphemeralSigners: l, nft2022: m }) {
        let d = [], [p, f] = [new q.PublicKey(e.programId), new q.PublicKey(e.id)], y;
        if (l)
          y = new q.PublicKey((await l(1))[0]);
        else {
          let K = q.Keypair.generate();
          d.push(K), y = K.publicKey;
        }
        let b = ne.getTickArrayStartIndexByTick(o, e.config.tickSpacing), g = ne.getTickArrayStartIndexByTick(r, e.config.tickSpacing), { publicKey: A } = Ce(p, f, b), { publicKey: k } = Ce(p, f, g), { publicKey: I } = m ? te(n.wallet, y, re.TOKEN_2022_PROGRAM_ID) : te(n.wallet, y, re.TOKEN_PROGRAM_ID), { publicKey: T } = Un(y), { publicKey: h } = Gt(p, y), { publicKey: S } = hn(p, f, o, r), x = m ? this.openPositionFromBaseInstruction22(p, n.feePayer, f, n.wallet, y, I, S, A, k, h, n.tokenAccountA, n.tokenAccountB, new q.PublicKey(t.vault.A), new q.PublicKey(t.vault.B), new q.PublicKey(e.mintA.address), new q.PublicKey(e.mintB.address), o, r, b, g, u, s, a, c, Xe.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing, [b, g]) ? st(p, f).publicKey : void 0) : this.openPositionFromBaseInstruction(p, n.feePayer, f, n.wallet, y, I, T, S, A, k, h, n.tokenAccountA, n.tokenAccountB, new q.PublicKey(t.vault.A), new q.PublicKey(t.vault.B), new q.PublicKey(e.mintA.address), new q.PublicKey(e.mintB.address), o, r, b, g, u, s, a, c, Xe.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing, [b, g]) ? st(p, f).publicKey : void 0);
        return { address: { nftMint: y, tickArrayLower: A, tickArrayUpper: k, positionNftAccount: I, metadataAccount: T, personalPosition: h, protocolPosition: S }, instructions: [x], signers: d, instructionTypes: [X.ClmmOpenPosition], lookupTableAddress: t.lookupTableAccount ? [t.lookupTableAccount] : [] };
      }
      static openPositionFromBaseInstruction(e, t, n, o, r, s, a, c, u, l, m, d, p, f, y, b, g, A, k, I, T, h, S, x, K, B) {
        let C = V([je("tickLowerIndex"), je("tickUpperIndex"), je("tickArrayLowerStartIndex"), je("tickArrayUpperStartIndex"), ae("liquidity"), P2("amountMaxA"), P2("amountMaxB"), Ze("withMetadata"), W("optionBaseFlag"), Ze("baseFlag")]), R = [...B ? [{ pubkey: B, isSigner: false, isWritable: true }] : []], N = [{ pubkey: t, isSigner: true, isWritable: true }, { pubkey: o, isSigner: false, isWritable: false }, { pubkey: r, isSigner: true, isWritable: true }, { pubkey: s, isSigner: false, isWritable: true }, { pubkey: a, isSigner: false, isWritable: true }, { pubkey: n, isSigner: false, isWritable: true }, { pubkey: c, isSigner: false, isWritable: true }, { pubkey: u, isSigner: false, isWritable: true }, { pubkey: l, isSigner: false, isWritable: true }, { pubkey: m, isSigner: false, isWritable: true }, { pubkey: d, isSigner: false, isWritable: true }, { pubkey: p, isSigner: false, isWritable: true }, { pubkey: f, isSigner: false, isWritable: true }, { pubkey: y, isSigner: false, isWritable: true }, { pubkey: at, isSigner: false, isWritable: false }, { pubkey: q.SystemProgram.programId, isSigner: false, isWritable: false }, { pubkey: re.TOKEN_PROGRAM_ID, isSigner: false, isWritable: false }, { pubkey: re.ASSOCIATED_TOKEN_PROGRAM_ID, isSigner: false, isWritable: false }, { pubkey: cn, isSigner: false, isWritable: false }, { pubkey: re.TOKEN_2022_PROGRAM_ID, isSigner: false, isWritable: false }, { pubkey: b, isSigner: false, isWritable: false }, { pubkey: g, isSigner: false, isWritable: false }, ...R], v = Buffer.alloc(C.span);
        C.encode({ tickLowerIndex: A, tickUpperIndex: k, tickArrayLowerStartIndex: I, tickArrayUpperStartIndex: T, liquidity: new ha.default(0), amountMaxA: S === "MintA" ? x : K, amountMaxB: S === "MintA" ? K : x, withMetadata: h === "create", baseFlag: S === "MintA", optionBaseFlag: 1 }, v);
        let L = Buffer.from([...pn.openPosition, ...v]);
        return new q.TransactionInstruction({ keys: N, programId: e, data: L });
      }
      static openPositionFromBaseInstruction22(e, t, n, o, r, s, a, c, u, l, m, d, p, f, y, b, g, A, k, I, T, h, S, x, K) {
        let B = V([je("tickLowerIndex"), je("tickUpperIndex"), je("tickArrayLowerStartIndex"), je("tickArrayUpperStartIndex"), ae("liquidity"), P2("amountMaxA"), P2("amountMaxB"), Ze("withMetadata"), W("optionBaseFlag"), Ze("baseFlag")]), C = [...K ? [{ pubkey: K, isSigner: false, isWritable: true }] : []], R = [{ pubkey: t, isSigner: true, isWritable: true }, { pubkey: o, isSigner: false, isWritable: false }, { pubkey: r, isSigner: true, isWritable: true }, { pubkey: s, isSigner: false, isWritable: true }, { pubkey: n, isSigner: false, isWritable: true }, { pubkey: a, isSigner: false, isWritable: true }, { pubkey: c, isSigner: false, isWritable: true }, { pubkey: u, isSigner: false, isWritable: true }, { pubkey: l, isSigner: false, isWritable: true }, { pubkey: m, isSigner: false, isWritable: true }, { pubkey: d, isSigner: false, isWritable: true }, { pubkey: p, isSigner: false, isWritable: true }, { pubkey: f, isSigner: false, isWritable: true }, { pubkey: at, isSigner: false, isWritable: false }, { pubkey: q.SystemProgram.programId, isSigner: false, isWritable: false }, { pubkey: re.TOKEN_PROGRAM_ID, isSigner: false, isWritable: false }, { pubkey: re.ASSOCIATED_TOKEN_PROGRAM_ID, isSigner: false, isWritable: false }, { pubkey: re.TOKEN_2022_PROGRAM_ID, isSigner: false, isWritable: false }, { pubkey: y, isSigner: false, isWritable: false }, { pubkey: b, isSigner: false, isWritable: false }, ...C], N = Buffer.alloc(B.span);
        B.encode({ tickLowerIndex: g, tickUpperIndex: A, tickArrayLowerStartIndex: k, tickArrayUpperStartIndex: I, liquidity: new ha.default(0), amountMaxA: h === "MintA" ? S : x, amountMaxB: h === "MintA" ? x : S, withMetadata: T === "create", baseFlag: h === "MintA", optionBaseFlag: 1 }, N);
        let v = Buffer.from([...pn.openPositionWithTokenEx, ...N]);
        return new q.TransactionInstruction({ keys: R, programId: e, data: v });
      }
      static async openPositionFromLiquidityInstructions({ poolInfo: e, poolKeys: t, ownerInfo: n, tickLower: o, tickUpper: r, liquidity: s, amountMaxA: a, amountMaxB: c, withMetadata: u, getEphemeralSigners: l, nft2022: m }) {
        let d, p = [];
        if (l)
          d = new q.PublicKey((await l(1))[0]);
        else {
          let K = q.Keypair.generate();
          p.push(K), d = K.publicKey;
        }
        let [f, y] = [new q.PublicKey(e.programId), new q.PublicKey(e.id)], b = ne.getTickArrayStartIndexByTick(o, e.config.tickSpacing), g = ne.getTickArrayStartIndexByTick(r, e.config.tickSpacing), { publicKey: A } = Ce(f, y, b), { publicKey: k } = Ce(f, y, g), { publicKey: I } = m ? te(n.wallet, d, re.TOKEN_2022_PROGRAM_ID) : te(n.wallet, d, re.TOKEN_PROGRAM_ID), { publicKey: T } = Un(d), { publicKey: h } = Gt(f, d), { publicKey: S } = hn(f, y, o, r), x = m ? this.openPositionFromLiquidityInstruction22(f, n.wallet, y, n.wallet, d, I, S, A, k, h, n.tokenAccountA, n.tokenAccountB, new q.PublicKey(t.vault.A), new q.PublicKey(t.vault.B), new q.PublicKey(t.mintA.address), new q.PublicKey(t.mintB.address), o, r, b, g, s, a, c, u, Xe.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing, [b, g]) ? st(f, y).publicKey : void 0) : this.openPositionFromLiquidityInstruction(f, n.wallet, y, n.wallet, d, I, T, S, A, k, h, n.tokenAccountA, n.tokenAccountB, new q.PublicKey(t.vault.A), new q.PublicKey(t.vault.B), new q.PublicKey(t.mintA.address), new q.PublicKey(t.mintB.address), o, r, b, g, s, a, c, u, Xe.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing, [b, g]) ? st(f, y).publicKey : void 0);
        return { address: { nftMint: d, tickArrayLower: A, tickArrayUpper: k, positionNftAccount: I, metadataAccount: T, personalPosition: h, protocolPosition: S }, instructions: [x], signers: p, instructionTypes: [X.ClmmOpenPosition], lookupTableAddress: t.lookupTableAccount ? [t.lookupTableAccount] : [] };
      }
      static closePositionInstruction(e, t, n, o, r, s) {
        let a = V([]), c = [{ pubkey: t, isSigner: true, isWritable: true }, { pubkey: n, isSigner: false, isWritable: true }, { pubkey: o, isSigner: false, isWritable: true }, { pubkey: r, isSigner: false, isWritable: true }, { pubkey: q.SystemProgram.programId, isSigner: false, isWritable: false }, { pubkey: s ? re.TOKEN_2022_PROGRAM_ID : re.TOKEN_PROGRAM_ID, isSigner: false, isWritable: false }], u = Buffer.alloc(a.span);
        a.encode({}, u);
        let l = Buffer.from([...pn.closePosition, ...u]);
        return new q.TransactionInstruction({ keys: c, programId: e, data: l });
      }
      static closePositionInstructions({ poolInfo: e, poolKeys: t, ownerInfo: n, ownerPosition: o, nft2022: r }) {
        let s = new q.PublicKey(e.programId), a = r ? te(n.wallet, o.nftMint, re.TOKEN_2022_PROGRAM_ID).publicKey : te(n.wallet, o.nftMint, re.TOKEN_PROGRAM_ID).publicKey, { publicKey: c } = Gt(s, o.nftMint), u = [];
        return u.push(this.closePositionInstruction(s, n.wallet, o.nftMint, a, c, r)), { address: { positionNftAccount: a, personalPosition: c }, signers: [], instructions: u, instructionTypes: [X.ClmmClosePosition], lookupTableAddress: t.lookupTableAccount ? [t.lookupTableAccount] : [] };
      }
      static increasePositionFromLiquidityInstruction(e, t, n, o, r, s, a, c, u, l, m, d, p, f, y, b, g, A) {
        let k = V([ae("liquidity"), P2("amountMaxA"), P2("amountMaxB"), W("optionBaseFlag"), Ze("baseFlag")]), I = [...A ? [{ pubkey: A, isSigner: false, isWritable: true }] : []], T = [{ pubkey: t, isSigner: true, isWritable: false }, { pubkey: n, isSigner: false, isWritable: false }, { pubkey: r, isSigner: false, isWritable: true }, { pubkey: s, isSigner: false, isWritable: true }, { pubkey: o, isSigner: false, isWritable: true }, { pubkey: a, isSigner: false, isWritable: true }, { pubkey: c, isSigner: false, isWritable: true }, { pubkey: u, isSigner: false, isWritable: true }, { pubkey: l, isSigner: false, isWritable: true }, { pubkey: m, isSigner: false, isWritable: true }, { pubkey: d, isSigner: false, isWritable: true }, { pubkey: re.TOKEN_PROGRAM_ID, isSigner: false, isWritable: false }, { pubkey: re.TOKEN_2022_PROGRAM_ID, isSigner: false, isWritable: false }, { pubkey: p, isSigner: false, isWritable: false }, { pubkey: f, isSigner: false, isWritable: false }, ...I], h = Buffer.alloc(k.span);
        k.encode({ liquidity: y, amountMaxA: b, amountMaxB: g, optionBaseFlag: 0, baseFlag: false }, h);
        let S = Buffer.from([...pn.increaseLiquidity, ...h]);
        return new q.TransactionInstruction({ keys: T, programId: e, data: S });
      }
      static increasePositionFromLiquidityInstructions({ poolInfo: e, poolKeys: t, ownerPosition: n, ownerInfo: o, liquidity: r, amountMaxA: s, amountMaxB: a, nft2022: c }) {
        let [u, l] = [new q.PublicKey(e.programId), new q.PublicKey(e.id)], m = ne.getTickArrayStartIndexByTick(n.tickLower, e.config.tickSpacing), d = ne.getTickArrayStartIndexByTick(n.tickUpper, e.config.tickSpacing), { publicKey: p } = Ce(u, l, m), { publicKey: f } = Ce(u, l, d), { publicKey: y } = c ? te(o.wallet, n.nftMint, re.TOKEN_2022_PROGRAM_ID) : te(o.wallet, n.nftMint, re.TOKEN_PROGRAM_ID), { publicKey: b } = Gt(u, n.nftMint), { publicKey: g } = hn(u, l, n.tickLower, n.tickUpper), A = this.increasePositionFromLiquidityInstruction(u, o.wallet, y, b, l, g, p, f, o.tokenAccountA, o.tokenAccountB, new q.PublicKey(t.vault.A), new q.PublicKey(t.vault.B), new q.PublicKey(e.mintA.address), new q.PublicKey(e.mintB.address), r, s, a, Xe.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing, [m, d]) ? st(u, l).publicKey : void 0);
        return { address: { tickArrayLower: p, tickArrayUpper: f, positionNftAccount: y, personalPosition: b, protocolPosition: g }, signers: [], instructions: [A], instructionTypes: [X.ClmmIncreasePosition], lookupTableAddress: t.lookupTableAccount ? [t.lookupTableAccount] : [] };
      }
      static increasePositionFromBaseInstructions({ poolInfo: e, poolKeys: t, ownerPosition: n, ownerInfo: o, base: r, baseAmount: s, otherAmountMax: a, nft2022: c }) {
        let [u, l] = [new q.PublicKey(e.programId), new q.PublicKey(e.id)], m = ne.getTickArrayStartIndexByTick(n.tickLower, e.config.tickSpacing), d = ne.getTickArrayStartIndexByTick(n.tickUpper, e.config.tickSpacing), { publicKey: p } = Ce(u, l, m), { publicKey: f } = Ce(u, l, d), { publicKey: y } = c ? te(o.wallet, n.nftMint, re.TOKEN_2022_PROGRAM_ID) : te(o.wallet, n.nftMint, re.TOKEN_PROGRAM_ID), { publicKey: b } = Gt(u, n.nftMint), { publicKey: g } = hn(u, l, n.tickLower, n.tickUpper);
        return { address: { tickArrayLower: p, tickArrayUpper: f, positionNftAccount: y, personalPosition: b, protocolPosition: g }, instructions: [this.increasePositionFromBaseInstruction(u, o.wallet, y, b, l, g, p, f, o.tokenAccountA, o.tokenAccountB, new q.PublicKey(t.vault.A), new q.PublicKey(t.vault.B), new q.PublicKey(e.mintA.address), new q.PublicKey(e.mintB.address), r, s, a, Xe.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing, [m, d]) ? st(u, l).publicKey : void 0)], signers: [], instructionTypes: [X.ClmmIncreasePosition], lookupTableAddress: t.lookupTableAccount ? [t.lookupTableAccount] : [] };
      }
      static increasePositionFromBaseInstruction(e, t, n, o, r, s, a, c, u, l, m, d, p, f, y, b, g, A) {
        let k = V([ae("liquidity"), P2("amountMaxA"), P2("amountMaxB"), W("optionBaseFlag"), Ze("baseFlag")]), I = [...A ? [{ pubkey: A, isSigner: false, isWritable: true }] : []], T = [{ pubkey: t, isSigner: true, isWritable: false }, { pubkey: n, isSigner: false, isWritable: false }, { pubkey: r, isSigner: false, isWritable: true }, { pubkey: s, isSigner: false, isWritable: true }, { pubkey: o, isSigner: false, isWritable: true }, { pubkey: a, isSigner: false, isWritable: true }, { pubkey: c, isSigner: false, isWritable: true }, { pubkey: u, isSigner: false, isWritable: true }, { pubkey: l, isSigner: false, isWritable: true }, { pubkey: m, isSigner: false, isWritable: true }, { pubkey: d, isSigner: false, isWritable: true }, { pubkey: re.TOKEN_PROGRAM_ID, isSigner: false, isWritable: false }, { pubkey: re.TOKEN_2022_PROGRAM_ID, isSigner: false, isWritable: false }, { pubkey: p, isSigner: false, isWritable: false }, { pubkey: f, isSigner: false, isWritable: false }, ...I], h = Buffer.alloc(k.span);
        k.encode({ liquidity: new ha.default(0), amountMaxA: y === "MintA" ? b : g, amountMaxB: y === "MintA" ? g : b, baseFlag: y === "MintA", optionBaseFlag: 1 }, h);
        let S = Buffer.from([...pn.increaseLiquidity, ...h]);
        return new q.TransactionInstruction({ keys: T, programId: e, data: S });
      }
      static decreaseLiquidityInstruction(e, t, n, o, r, s, a, c, u, l, m, d, p, f, y, b, g, A, k) {
        let I = V([ae("liquidity"), P2("amountMinA"), P2("amountMinB")]), T = [...k ? [{ pubkey: k, isSigner: false, isWritable: true }] : [], ...y.map((K) => [{ pubkey: K.poolRewardVault, isSigner: false, isWritable: true }, { pubkey: K.ownerRewardVault, isSigner: false, isWritable: true }, { pubkey: K.rewardMint, isSigner: false, isWritable: false }]).flat()], h = [{ pubkey: t, isSigner: true, isWritable: false }, { pubkey: n, isSigner: false, isWritable: false }, { pubkey: o, isSigner: false, isWritable: true }, { pubkey: r, isSigner: false, isWritable: true }, { pubkey: s, isSigner: false, isWritable: true }, { pubkey: m, isSigner: false, isWritable: true }, { pubkey: d, isSigner: false, isWritable: true }, { pubkey: a, isSigner: false, isWritable: true }, { pubkey: c, isSigner: false, isWritable: true }, { pubkey: u, isSigner: false, isWritable: true }, { pubkey: l, isSigner: false, isWritable: true }, { pubkey: re.TOKEN_PROGRAM_ID, isSigner: false, isWritable: false }, { pubkey: re.TOKEN_2022_PROGRAM_ID, isSigner: false, isWritable: false }, { pubkey: Zi, isSigner: false, isWritable: false }, { pubkey: p, isSigner: false, isWritable: false }, { pubkey: f, isSigner: false, isWritable: false }, ...T], S = Buffer.alloc(I.span);
        I.encode({ liquidity: b, amountMinA: g, amountMinB: A }, S);
        let x = Buffer.from([...pn.decreaseLiquidity, ...S]);
        return new q.TransactionInstruction({ keys: h, programId: e, data: x });
      }
      static decreaseLiquidityInstructions({ poolInfo: e, poolKeys: t, ownerPosition: n, ownerInfo: o, liquidity: r, amountMinA: s, amountMinB: a, programId: c, nft2022: u }) {
        let [l, m] = [new q.PublicKey(e.programId), new q.PublicKey(e.id)], d = ne.getTickArrayStartIndexByTick(n.tickLower, e.config.tickSpacing), p = ne.getTickArrayStartIndexByTick(n.tickUpper, e.config.tickSpacing), { publicKey: f } = Ce(l, m, d), { publicKey: y } = Ce(l, m, p), { publicKey: b } = u ? te(o.wallet, n.nftMint, re.TOKEN_2022_PROGRAM_ID) : te(o.wallet, n.nftMint, c), { publicKey: g } = Gt(l, n.nftMint), { publicKey: A } = hn(l, m, n.tickLower, n.tickUpper), k = [];
        for (let h = 0; h < e.rewardDefaultInfos.length; h++)
          k.push({ poolRewardVault: new q.PublicKey(t.rewardInfos[h].vault), ownerRewardVault: o.rewardAccounts[h], rewardMint: new q.PublicKey(e.rewardDefaultInfos[h].mint.address) });
        let I = [], T = this.decreaseLiquidityInstruction(l, o.wallet, b, g, m, A, f, y, o.tokenAccountA, o.tokenAccountB, new q.PublicKey(t.vault.A), new q.PublicKey(t.vault.B), new q.PublicKey(e.mintA.address), new q.PublicKey(e.mintB.address), k, r, s, a, Xe.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing, [d, p]) ? st(l, m).publicKey : void 0);
        return I.push(T), { address: { tickArrayLower: f, tickArrayUpper: y, positionNftAccount: b, personalPosition: g, protocolPosition: A }, signers: [], instructions: I, instructionTypes: [X.ClmmDecreasePosition], lookupTableAddress: t.lookupTableAccount ? [t.lookupTableAccount] : [] };
      }
      static swapInstruction(e, t, n, o, r, s, a, c, u, l, m, d, p, f, y, b, g) {
        let A = V([P2("amount"), P2("otherAmountThreshold"), ae("sqrtPriceLimitX64"), Ze("isBaseInput")]), k = [...g ? [{ pubkey: g, isSigner: false, isWritable: true }] : [], ...m.map((S) => ({ pubkey: S, isSigner: false, isWritable: true }))], I = [{ pubkey: t, isSigner: true, isWritable: false }, { pubkey: o, isSigner: false, isWritable: false }, { pubkey: n, isSigner: false, isWritable: true }, { pubkey: r, isSigner: false, isWritable: true }, { pubkey: s, isSigner: false, isWritable: true }, { pubkey: a, isSigner: false, isWritable: true }, { pubkey: c, isSigner: false, isWritable: true }, { pubkey: d, isSigner: false, isWritable: true }, { pubkey: re.TOKEN_PROGRAM_ID, isSigner: false, isWritable: false }, { pubkey: re.TOKEN_2022_PROGRAM_ID, isSigner: false, isWritable: false }, { pubkey: Zi, isSigner: false, isWritable: false }, { pubkey: u, isSigner: false, isWritable: false }, { pubkey: l, isSigner: false, isWritable: false }, ...k], T = Buffer.alloc(A.span);
        A.encode({ amount: p, otherAmountThreshold: f, sqrtPriceLimitX64: y, isBaseInput: b }, T);
        let h = Buffer.from([...pn.swap, ...T]);
        return new q.TransactionInstruction({ keys: I, programId: e, data: h });
      }
      static makeSwapBaseInInstructions({ poolInfo: e, poolKeys: t, observationId: n, ownerInfo: o, inputMint: r, amountIn: s, amountOutMin: a, sqrtPriceLimitX64: c, remainingAccounts: u }) {
        let [l, m] = [new q.PublicKey(e.programId), new q.PublicKey(e.id)], [d, p] = [new q.PublicKey(t.vault.A), new q.PublicKey(t.vault.B)], [f, y] = [new q.PublicKey(e.mintA.address), new q.PublicKey(e.mintB.address)], b = e.mintA.address === r.toString(), g = [this.swapInstruction(l, o.wallet, m, new q.PublicKey(e.config.id), b ? o.tokenAccountA : o.tokenAccountB, b ? o.tokenAccountB : o.tokenAccountA, b ? d : p, b ? p : d, b ? f : y, b ? y : f, u, n, s, a, c, true, st(l, m).publicKey)];
        return { signers: [], instructions: g, instructionTypes: [X.ClmmSwapBaseIn], lookupTableAddress: t.lookupTableAccount ? [t.lookupTableAccount] : [], address: {} };
      }
      static makeSwapBaseOutInstructions({ poolInfo: e, poolKeys: t, observationId: n, ownerInfo: o, outputMint: r, amountOut: s, amountInMax: a, sqrtPriceLimitX64: c, remainingAccounts: u }) {
        let [l, m] = [new q.PublicKey(e.programId), new q.PublicKey(e.id)], [d, p] = [new q.PublicKey(t.vault.A), new q.PublicKey(t.vault.B)], [f, y] = [new q.PublicKey(e.mintA.address), new q.PublicKey(e.mintB.address)], b = e.mintA.address === r.toBase58(), g = [this.swapInstruction(l, o.wallet, m, new q.PublicKey(e.config.id), b ? o.tokenAccountB : o.tokenAccountA, b ? o.tokenAccountA : o.tokenAccountB, b ? p : d, b ? d : p, b ? y : f, b ? f : y, u, n, s, a, c, false, st(l, m).publicKey)];
        return { signers: [], instructions: g, instructionTypes: [X.ClmmSwapBaseOut], lookupTableAddress: t.lookupTableAccount ? [t.lookupTableAccount] : [], address: {} };
      }
      static initRewardInstruction(e, t, n, o, r, s, a, c, u, l, m, d) {
        let p = V([P2("openTime"), P2("endTime"), ae("emissionsPerSecondX64")]), f = [{ pubkey: t, isSigner: true, isWritable: true }, { pubkey: s, isSigner: false, isWritable: true }, { pubkey: r, isSigner: false, isWritable: false }, { pubkey: n, isSigner: false, isWritable: true }, { pubkey: o, isSigner: false, isWritable: true }, { pubkey: c, isSigner: false, isWritable: false }, { pubkey: u, isSigner: false, isWritable: true }, { pubkey: a, isSigner: false, isWritable: false }, { pubkey: q.SystemProgram.programId, isSigner: false, isWritable: false }, { pubkey: at, isSigner: false, isWritable: false }], y = Buffer.alloc(p.span);
        p.encode({ openTime: oe(l), endTime: oe(m), emissionsPerSecondX64: d }, y);
        let b = Buffer.from([...pn.initReward, ...y]);
        return new q.TransactionInstruction({ keys: f, programId: e, data: b });
      }
      static initRewardInstructions({ poolInfo: e, poolKeys: t, ownerInfo: n, rewardInfo: o }) {
        let [r, s] = [new q.PublicKey(e.programId), new q.PublicKey(e.id)], a = Bc(r, s, o.mint).publicKey, c = Ii(r).publicKey, u = [this.initRewardInstruction(r, n.wallet, s, c, new q.PublicKey(e.config.id), n.tokenAccount, o.programId, o.mint, a, o.openTime, o.endTime, o.emissionsPerSecondX64)];
        return { address: { poolRewardVault: a, operationId: c }, signers: [], instructions: u, instructionTypes: [X.ClmmInitReward], lookupTableAddress: t.lookupTableAccount ? [t.lookupTableAccount] : [] };
      }
      static setRewardInstruction(e, t, n, o, r, s, a, c, u, l, m, d) {
        let p = V([W("rewardIndex"), ae("emissionsPerSecondX64"), P2("openTime"), P2("endTime")]), f = [{ pubkey: t, isSigner: true, isWritable: true }, { pubkey: r, isSigner: false, isWritable: false }, { pubkey: n, isSigner: false, isWritable: true }, { pubkey: o, isSigner: false, isWritable: true }, { pubkey: re.TOKEN_PROGRAM_ID, isSigner: false, isWritable: false }, { pubkey: re.TOKEN_2022_PROGRAM_ID, isSigner: false, isWritable: false }, { pubkey: a, isSigner: false, isWritable: true }, { pubkey: s, isSigner: false, isWritable: true }, { pubkey: c, isSigner: false, isWritable: true }], y = Buffer.alloc(p.span);
        p.encode({ rewardIndex: u, emissionsPerSecondX64: d, openTime: oe(l), endTime: oe(m) }, y);
        let b = Buffer.from([...pn.setRewardEmissions, ...y]);
        return new q.TransactionInstruction({ keys: f, programId: e, data: b });
      }
      static setRewardInstructions({ poolInfo: e, poolKeys: t, ownerInfo: n, rewardInfo: o }) {
        let [r, s] = [new q.PublicKey(e.programId), new q.PublicKey(e.id)], a, c, u;
        for (let d = 0; d < e.rewardDefaultInfos.length; d++)
          e.rewardDefaultInfos[d].mint.address === o.mint.toString() && (a = d, c = new q.PublicKey(t.rewardInfos[d].vault), u = new q.PublicKey(t.rewardInfos[d].mint.address));
        (a === void 0 || c === void 0) && Ld.logWithError("reward mint check error", "no reward mint", e.rewardDefaultInfos);
        let l = Ii(r).publicKey, m = [this.setRewardInstruction(r, n.wallet, s, l, new q.PublicKey(e.config.id), n.tokenAccount, c, u, a, o.openTime, o.endTime, o.emissionsPerSecondX64)];
        return { address: { rewardVault: c, operationId: l }, signers: [], instructions: m, instructionTypes: [X.ClmmSetReward], lookupTableAddress: t.lookupTableAccount ? [t.lookupTableAccount] : [] };
      }
      static collectRewardInstruction(e, t, n, o, r, s, a) {
        let c = V([W("rewardIndex")]), u = [{ pubkey: t, isSigner: true, isWritable: true }, { pubkey: o, isSigner: false, isWritable: true }, { pubkey: n, isSigner: false, isWritable: true }, { pubkey: r, isSigner: false, isWritable: true }, { pubkey: s, isSigner: false, isWritable: false }, { pubkey: re.TOKEN_PROGRAM_ID, isSigner: false, isWritable: false }, { pubkey: re.TOKEN_2022_PROGRAM_ID, isSigner: false, isWritable: false }, { pubkey: Zi, isSigner: false, isWritable: false }], l = Buffer.alloc(c.span);
        c.encode({ rewardIndex: a }, l);
        let m = Buffer.from([...pn.collectReward, ...l]);
        return new q.TransactionInstruction({ keys: u, programId: e, data: m });
      }
      static collectRewardInstructions({ poolInfo: e, poolKeys: t, ownerInfo: n, rewardMint: o }) {
        let [r, s] = [new q.PublicKey(e.programId), new q.PublicKey(e.id)], a, c;
        for (let l = 0; l < e.rewardDefaultInfos.length; l++)
          e.rewardDefaultInfos[l].mint.address === o.toString() && (a = l, c = new q.PublicKey(t.rewardInfos[l].vault));
        (a === void 0 || c === void 0) && Ld.logWithError("reward mint check error", "no reward mint", e.rewardDefaultInfos);
        let u = [this.collectRewardInstruction(r, n.wallet, s, n.tokenAccount, c, o, a)];
        return { address: { rewardVault: c }, signers: [], instructions: u, instructionTypes: [X.ClmmCollectReward], lookupTableAddress: t.lookupTableAccount ? [t.lookupTableAccount] : [] };
      }
      static async makeLockPositions({ programId: e, authProgramId: t, poolProgramId: n, payer: o, wallet: r, nftMint: s, nft2022: a, getEphemeralSigners: c }) {
        let u = [], l;
        if (c)
          l = new q.PublicKey((await c(1))[0]);
        else {
          let g = q.Keypair.generate();
          u.push(g), l = g.publicKey;
        }
        let m = a ? te(r, s, re.TOKEN_2022_PROGRAM_ID).publicKey : te(r, s, re.TOKEN_PROGRAM_ID).publicKey, { publicKey: d } = Gt(n, s), p = qo(e, l).publicKey, f = te(r, l, re.TOKEN_PROGRAM_ID).publicKey, y = Un(l).publicKey, b = Oe.lockPositionInstructionV2({ programId: e, auth: t, payer: o, positionOwner: r, lockOwner: r, positionNftAccount: m, positionId: d, lockPositionId: p, lockNftMint: l, lockNftAccount: f, metadataAccount: y, withMetadata: true, nft2022: a, positionNftMint: s, authPositionNftAccount: te(t, s, a ? re.TOKEN_2022_PROGRAM_ID : re.TOKEN_PROGRAM_ID).publicKey, positionNftProgram: a ? re.TOKEN_2022_PROGRAM_ID : re.TOKEN_PROGRAM_ID });
        return { address: { positionId: d, lockPositionId: p, lockNftAccount: f, lockNftMint: l, positionNftAccount: m, metadataAccount: y }, instructions: [b], signers: u, instructionTypes: [X.ClmmLockPosition], lookupTableAddress: [] };
      }
      static lockPositionInstructionV2({ programId: e, auth: t, payer: n, positionOwner: o, lockOwner: r, positionNftAccount: s, positionId: a, positionNftMint: c, authPositionNftAccount: u, positionNftProgram: l, lockPositionId: m, lockNftMint: d, lockNftAccount: p, metadataAccount: f, withMetadata: y }) {
        let b = [{ pubkey: t, isSigner: false, isWritable: false }, { pubkey: n, isSigner: true, isWritable: true }, { pubkey: o, isSigner: true, isWritable: true }, { pubkey: r, isSigner: false, isWritable: false }, { pubkey: s, isSigner: false, isWritable: true }, { pubkey: a, isSigner: false, isWritable: false }, { pubkey: c, isSigner: false, isWritable: true }, { pubkey: u, isSigner: false, isWritable: true }, { pubkey: m, isSigner: false, isWritable: true }, { pubkey: d, isSigner: true, isWritable: true }, { pubkey: p, isSigner: false, isWritable: true }, { pubkey: f, isSigner: false, isWritable: true }, { pubkey: cn, isSigner: false, isWritable: false }, { pubkey: re.ASSOCIATED_TOKEN_PROGRAM_ID, isSigner: false, isWritable: false }, { pubkey: at, isSigner: false, isWritable: false }, { pubkey: re.TOKEN_PROGRAM_ID, isSigner: false, isWritable: false }, { pubkey: l, isSigner: false, isWritable: false }, { pubkey: q.SystemProgram.programId, isSigner: false, isWritable: false }], g = V([Ze("withMetadata")]), A = Buffer.alloc(g.span);
        g.encode({ withMetadata: y }, A);
        let k = Buffer.from([...Nd, ...A]);
        return new q.TransactionInstruction({ keys: b, programId: e, data: k });
      }
      static lockPositionInstruction({ programId: e, authProgramId: t, poolProgramId: n, owner: o, positionNft: r }) {
        let { publicKey: s } = te(o, r, re.TOKEN_PROGRAM_ID), { publicKey: a } = Gt(n, r), c = [{ pubkey: t, isSigner: false, isWritable: false }, { pubkey: o, isSigner: true, isWritable: false }, { pubkey: s, isSigner: false, isWritable: true }, { pubkey: a, isSigner: false, isWritable: false }, { pubkey: Aa(e, a).publicKey, isSigner: false, isWritable: true }, { pubkey: re.TOKEN_PROGRAM_ID, isSigner: false, isWritable: false }, { pubkey: q.SystemProgram.programId, isSigner: false, isWritable: false }];
        return new q.TransactionInstruction({ keys: c, programId: e, data: Buffer.from(Nd) });
      }
      static harvestLockPositionInstruction(e) {
        let [t, n] = [new q.PublicKey(e.poolKeys.programId), new q.PublicKey(e.poolKeys.id)], o = ne.getTickArrayStartIndexByTick(e.ownerPosition.tickLower, e.poolKeys.config.tickSpacing), r = ne.getTickArrayStartIndexByTick(e.ownerPosition.tickUpper, e.poolKeys.config.tickSpacing), { publicKey: s } = Ce(t, n, o), { publicKey: a } = Ce(t, n, r), { publicKey: c } = te(e.owner, e.ownerPosition.nftMint, re.TOKEN_PROGRAM_ID), { publicKey: u } = Gt(t, e.ownerPosition.nftMint), { publicKey: l } = hn(t, n, e.ownerPosition.tickLower, e.ownerPosition.tickUpper), m = [];
        for (let f = 0; f < e.poolKeys.rewardInfos.length; f++)
          m.push({ poolRewardVault: new q.PublicKey(e.poolKeys.rewardInfos[f].vault), ownerRewardVault: e.ownerRewardAccounts[f], rewardMint: new q.PublicKey(e.poolKeys.rewardInfos[f].mint.address) });
        let d = [...m.map((f) => [{ pubkey: f.poolRewardVault, isSigner: false, isWritable: true }, { pubkey: f.ownerRewardVault, isSigner: false, isWritable: true }, { pubkey: f.rewardMint, isSigner: false, isWritable: false }]).flat()], p = [{ pubkey: e.authProgramId, isSigner: false, isWritable: false }, { pubkey: Aa(e.programId, u).publicKey, isSigner: false, isWritable: false }, { pubkey: t, isSigner: false, isWritable: false }, { pubkey: e.owner, isSigner: true, isWritable: false }, { pubkey: c, isSigner: false, isWritable: true }, { pubkey: u, isSigner: false, isWritable: true }, { pubkey: n, isSigner: false, isWritable: true }, { pubkey: l, isSigner: false, isWritable: true }, { pubkey: new q.PublicKey(e.poolKeys.vault.A), isSigner: false, isWritable: true }, { pubkey: new q.PublicKey(e.poolKeys.vault.B), isSigner: false, isWritable: true }, { pubkey: s, isSigner: false, isWritable: true }, { pubkey: a, isSigner: false, isWritable: true }, { pubkey: e.userVaultA, isSigner: false, isWritable: true }, { pubkey: e.userVaultB, isSigner: false, isWritable: true }, { pubkey: re.TOKEN_PROGRAM_ID, isSigner: false, isWritable: false }, { pubkey: re.TOKEN_2022_PROGRAM_ID, isSigner: false, isWritable: false }, { pubkey: Cn, isSigner: false, isWritable: false }, { pubkey: new q.PublicKey(e.poolKeys.mintA.address), isSigner: false, isWritable: false }, { pubkey: new q.PublicKey(e.poolKeys.mintB.address), isSigner: false, isWritable: false }, ...d];
        return new q.TransactionInstruction({ keys: p, programId: e.programId, data: Buffer.from(Od) });
      }
      static harvestLockPositionInstructionV2({ programId: e, auth: t, lockPositionId: n, clmmProgram: o, lockOwner: r, lockNftMint: s, lockNftAccount: a, positionNftAccount: c, positionId: u, poolId: l, protocolPosition: m, vaultA: d, vaultB: p, tickArrayLower: f, tickArrayUpper: y, userVaultA: b, userVaultB: g, mintA: A, mintB: k, rewardAccounts: I, exTickArrayBitmap: T }) {
        let h = [...T ? [{ pubkey: T, isSigner: false, isWritable: true }] : [], ...I.map((x) => [{ pubkey: x.poolRewardVault, isSigner: false, isWritable: true }, { pubkey: x.ownerRewardVault, isSigner: false, isWritable: true }, { pubkey: x.rewardMint, isSigner: false, isWritable: false }]).flat()], S = [{ pubkey: t, isSigner: false, isWritable: false }, { pubkey: r, isSigner: true, isWritable: false }, { pubkey: a, isSigner: false, isWritable: true }, { pubkey: n, isSigner: false, isWritable: false }, { pubkey: o, isSigner: false, isWritable: false }, { pubkey: c, isSigner: false, isWritable: true }, { pubkey: u, isSigner: false, isWritable: true }, { pubkey: l, isSigner: false, isWritable: true }, { pubkey: m, isSigner: false, isWritable: true }, { pubkey: d, isSigner: false, isWritable: true }, { pubkey: p, isSigner: false, isWritable: true }, { pubkey: f, isSigner: false, isWritable: true }, { pubkey: y, isSigner: false, isWritable: true }, { pubkey: b, isSigner: false, isWritable: true }, { pubkey: g, isSigner: false, isWritable: true }, { pubkey: re.TOKEN_PROGRAM_ID, isSigner: false, isWritable: false }, { pubkey: re.TOKEN_2022_PROGRAM_ID, isSigner: false, isWritable: false }, { pubkey: Cn, isSigner: false, isWritable: false }, { pubkey: A, isSigner: false, isWritable: false }, { pubkey: k, isSigner: false, isWritable: false }, ...h];
        return new q.TransactionInstruction({ keys: S, programId: e, data: Buffer.from(Od) });
      }
    };
    var Vc = V([St("mintAuthorityOption"), F("mintAuthority"), P2("supply"), W("decimals"), W("isInitialized"), St("freezeAuthorityOption"), F("freezeAuthority")]);
    var Md = require("@solana/web3.js");
    var Ir = require_cjs4();
    var Ib = async ({ connection: i, mint: e }) => {
      let t = await i.getAccountInfo(new Md.PublicKey(e));
      return !t || t.data.length !== Ir.MintLayout.span ? void 0 : Ir.MintLayout.decode(t.data);
    };
    var Bb = ({ mint: i, decimals: e, programId: t = Ir.TOKEN_PROGRAM_ID, logoURI: n = "", priority: o = 3 }) => {
      let r = i.toBase58().substring(0, 6);
      return { address: i.toBase58(), decimals: e, symbol: r, logoURI: n, extensions: {}, chainId: 101, programId: t.toString(), name: r, tags: [], priority: o };
    };
    var Br = (i) => new De({ mint: i.address, decimals: i.decimals, symbol: i.symbol, name: i.name });
    var Ki = (o) => {
      var r = o, { amount: i, isRaw: e, name: t } = r, n = tt(r, ["amount", "isRaw", "name"]);
      return new ve(new De({ mint: Lt(n.address).toBase58(), decimals: n.decimals, symbol: n.symbol, name: t }), i, e, t);
    };
    function xb(i) {
      return i.address === Kn.address ? kt : i;
    }
    function Sb(i) {
      return i.address === kt.address ? Kn : i;
    }
    var vt = (o) => {
      var r = o, { address: i, programId: e, decimals: t } = r, n = tt(r, ["address", "programId", "decimals"]);
      return E({ chainId: 101, address: Lt(i).toBase58(), programId: e, logoURI: "", symbol: "", name: "", decimals: t, tags: [], extensions: n.extensions || {} }, n);
    };
    var oo = (i) => i ? U(E({}, i), { transferFeeConfigAuthority: i.transferFeeConfigAuthority.toBase58(), withdrawWithheldAuthority: i.withdrawWithheldAuthority.toBase58(), withheldAmount: i.withheldAmount.toString(), olderTransferFee: U(E({}, i.olderTransferFee), { epoch: i.olderTransferFee.epoch.toString(), maximumFee: i.olderTransferFee.maximumFee.toString() }), newerTransferFee: U(E({}, i.newerTransferFee), { epoch: i.newerTransferFee.epoch.toString(), maximumFee: i.newerTransferFee.maximumFee.toString() }) }) : void 0;
    var _c = Ae(require_bn());
    var Ta = new _c.default(25);
    var xr = new _c.default(1e4);
    var vd = { 4: 3, 5: 3 };
    var ye = require("@solana/web3.js");
    var On = require_cjs4();
    var Sr = Ae(require_bn());
    var Ia = V([W("instruction"), P2("amountIn"), P2("minAmountOut")]);
    var Ba = V([W("instruction"), P2("maxAmountIn"), P2("amountOut")]);
    var Kb = V([W("instruction"), W("nonce")]);
    var xa = V([W("instruction"), W("nonce"), P2("startTime")]);
    var So = V([P2("status"), P2("nonce"), P2("maxOrder"), P2("depth"), P2("baseDecimal"), P2("quoteDecimal"), P2("state"), P2("resetFlag"), P2("minSize"), P2("volMaxCutRatio"), P2("amountWaveRatio"), P2("baseLotSize"), P2("quoteLotSize"), P2("minPriceMultiplier"), P2("maxPriceMultiplier"), P2("systemDecimalValue"), P2("minSeparateNumerator"), P2("minSeparateDenominator"), P2("tradeFeeNumerator"), P2("tradeFeeDenominator"), P2("pnlNumerator"), P2("pnlDenominator"), P2("swapFeeNumerator"), P2("swapFeeDenominator"), P2("baseNeedTakePnl"), P2("quoteNeedTakePnl"), P2("quoteTotalPnl"), P2("baseTotalPnl"), P2("poolOpenTime"), P2("punishPcAmount"), P2("punishCoinAmount"), P2("orderbookToInitTime"), ae("swapBaseInAmount"), ae("swapQuoteOutAmount"), P2("swapBase2QuoteFee"), ae("swapQuoteInAmount"), ae("swapBaseOutAmount"), P2("swapQuote2BaseFee"), F("baseVault"), F("quoteVault"), F("baseMint"), F("quoteMint"), F("lpMint"), F("openOrders"), F("marketId"), F("marketProgramId"), F("targetOrders"), F("withdrawQueue"), F("lpVault"), F("owner"), P2("lpReserve"), Z(P2(), 3, "padding")]);
    var Fd = V([P2("accountType"), P2("status"), P2("nonce"), P2("maxOrder"), P2("depth"), P2("baseDecimal"), P2("quoteDecimal"), P2("state"), P2("resetFlag"), P2("minSize"), P2("volMaxCutRatio"), P2("amountWaveRatio"), P2("baseLotSize"), P2("quoteLotSize"), P2("minPriceMultiplier"), P2("maxPriceMultiplier"), P2("systemDecimalsValue"), P2("abortTradeFactor"), P2("priceTickMultiplier"), P2("priceTick"), P2("minSeparateNumerator"), P2("minSeparateDenominator"), P2("tradeFeeNumerator"), P2("tradeFeeDenominator"), P2("pnlNumerator"), P2("pnlDenominator"), P2("swapFeeNumerator"), P2("swapFeeDenominator"), P2("baseNeedTakePnl"), P2("quoteNeedTakePnl"), P2("quoteTotalPnl"), P2("baseTotalPnl"), P2("poolOpenTime"), P2("punishPcAmount"), P2("punishCoinAmount"), P2("orderbookToInitTime"), ae("swapBaseInAmount"), ae("swapQuoteOutAmount"), ae("swapQuoteInAmount"), ae("swapBaseOutAmount"), P2("swapQuote2BaseFee"), P2("swapBase2QuoteFee"), F("baseVault"), F("quoteVault"), F("baseMint"), F("quoteMint"), F("lpMint"), F("modelDataAccount"), F("openOrders"), F("marketId"), F("marketProgramId"), F("targetOrders"), F("owner"), Z(P2(), 64, "padding")]);
    var Sa = V([W("instruction"), P2("baseAmountIn"), P2("quoteAmountIn"), P2("fixedSide"), P2("otherAmountMin")]);
    var Ka = V([W("instruction"), P2("lpAmount"), P2("baseAmountMin"), P2("quoteAmountMin")]);
    var Cb = { 4: So, 5: Fd };
    var Ec = V([P2("fee")]);
    var Ca = xe("Raydium_liquidity_instruction");
    function Wc(i) {
      let { poolInfo: e, poolKeys: t, userKeys: n, baseAmountIn: o, quoteAmountIn: r, fixedSide: s, otherAmountMin: a, modelDataPubKey: c = Jn } = i, u = Buffer.alloc(Sa.span);
      Sa.encode({ instruction: 3, baseAmountIn: oe(o), quoteAmountIn: oe(r), otherAmountMin: oe(a), fixedSide: s === "base" ? ut : Au }, u);
      let l = [w({ pubkey: On.TOKEN_PROGRAM_ID, isWritable: false }), w({ pubkey: new ye.PublicKey(e.id) }), w({ pubkey: new ye.PublicKey(t.authority), isWritable: false }), w({ pubkey: new ye.PublicKey(t.openOrders), isWritable: false }), w({ pubkey: new ye.PublicKey(t.targetOrders) }), w({ pubkey: new ye.PublicKey(e.lpMint.address) }), w({ pubkey: new ye.PublicKey(t.vault.A) }), w({ pubkey: new ye.PublicKey(t.vault.B) })];
      return e.pooltype.includes("StablePool") && l.push(w({ pubkey: c })), l.push(w({ pubkey: new ye.PublicKey(e.marketId), isWritable: false }), w({ pubkey: n.baseTokenAccount }), w({ pubkey: n.quoteTokenAccount }), w({ pubkey: n.lpTokenAccount }), w({ pubkey: n.owner, isWritable: false, isSigner: true }), w({ pubkey: new ye.PublicKey(t.marketEventQueue), isWritable: false })), new ye.TransactionInstruction({ programId: new ye.PublicKey(e.programId), keys: l, data: u });
    }
    function Ra(i) {
      let { poolInfo: e, poolKeys: t, userKeys: n, lpAmount: o, baseAmountMin: r, quoteAmountMin: s, modelDataPubKey: a = Jn } = i, c = Qe(t), u = 4;
      if (e.pooltype.includes("StablePool") && (u = 5), u === 4 || u === 5) {
        let l = Buffer.alloc(Ka.span);
        Ka.encode({ instruction: 4, lpAmount: oe(o), baseAmountMin: oe(r), quoteAmountMin: oe(s) }, l);
        let m = [w({ pubkey: On.TOKEN_PROGRAM_ID, isWritable: false }), w({ pubkey: c.id }), w({ pubkey: c.authority, isWritable: false }), w({ pubkey: c.openOrders }), w({ pubkey: c.targetOrders }), w({ pubkey: c.mintLp.address }), w({ pubkey: c.vault.A }), w({ pubkey: c.vault.B })];
        return u === 5 ? m.push(w({ pubkey: a })) : (m.push(w({ pubkey: c.id })), m.push(w({ pubkey: c.id }))), m.push(w({ pubkey: c.marketProgramId, isWritable: false }), w({ pubkey: c.marketId }), w({ pubkey: c.marketBaseVault }), w({ pubkey: c.marketQuoteVault }), w({ pubkey: c.marketAuthority, isWritable: false }), w({ pubkey: n.lpTokenAccount }), w({ pubkey: n.baseTokenAccount }), w({ pubkey: n.quoteTokenAccount }), w({ pubkey: n.owner, isWritable: false, isSigner: true }), w({ pubkey: c.marketEventQueue }), w({ pubkey: c.marketBids }), w({ pubkey: c.marketAsks })), new ye.TransactionInstruction({ programId: c.programId, keys: m, data: l });
      }
      return new ye.TransactionInstruction({ programId: c.programId, keys: [] });
    }
    function La({ programId: i, ammId: e, ammAuthority: t, ammOpenOrders: n, lpMint: o, coinMint: r, pcMint: s, coinVault: a, pcVault: c, withdrawQueue: u, ammTargetOrders: l, poolTempLp: m, marketProgramId: d, marketId: p, userWallet: f, userCoinVault: y, userPcVault: b, userLpVault: g, nonce: A, openTime: k, coinAmount: I, pcAmount: T, ammConfigId: h, feeDestinationId: S }) {
      let x = V([W("instruction"), W("nonce"), P2("openTime"), P2("pcAmount"), P2("coinAmount")]), K = [{ pubkey: On.TOKEN_PROGRAM_ID, isSigner: false, isWritable: false }, { pubkey: On.ASSOCIATED_TOKEN_PROGRAM_ID, isSigner: false, isWritable: false }, { pubkey: ye.SystemProgram.programId, isSigner: false, isWritable: false }, { pubkey: at, isSigner: false, isWritable: false }, { pubkey: e, isSigner: false, isWritable: true }, { pubkey: t, isSigner: false, isWritable: false }, { pubkey: n, isSigner: false, isWritable: true }, { pubkey: o, isSigner: false, isWritable: true }, { pubkey: r, isSigner: false, isWritable: false }, { pubkey: s, isSigner: false, isWritable: false }, { pubkey: a, isSigner: false, isWritable: true }, { pubkey: c, isSigner: false, isWritable: true }, { pubkey: l, isSigner: false, isWritable: true }, { pubkey: h, isSigner: false, isWritable: false }, { pubkey: S, isSigner: false, isWritable: true }, { pubkey: d, isSigner: false, isWritable: false }, { pubkey: p, isSigner: false, isWritable: false }, { pubkey: f, isSigner: true, isWritable: true }, { pubkey: y, isSigner: false, isWritable: true }, { pubkey: b, isSigner: false, isWritable: true }, { pubkey: g, isSigner: false, isWritable: true }], B = Buffer.alloc(x.span);
      return x.encode({ instruction: 1, nonce: A, openTime: k, coinAmount: I, pcAmount: T }, B), { instruction: new ye.TransactionInstruction({ keys: K, programId: i, data: B }), instructionType: X.AmmV4CreatePool };
    }
    function Rb(i) {
      let e = V([W("instruction"), W("simulateType")]), t = Buffer.alloc(e.span);
      e.encode({ instruction: 12, simulateType: 0 }, t);
      let n = [w({ pubkey: new ye.PublicKey(i.id), isWritable: false }), w({ pubkey: new ye.PublicKey(i.authority), isWritable: false }), w({ pubkey: new ye.PublicKey(i.openOrders), isWritable: false }), w({ pubkey: new ye.PublicKey(i.vault.A), isWritable: false }), w({ pubkey: new ye.PublicKey(i.vault.B), isWritable: false }), w({ pubkey: new ye.PublicKey(i.mintLp.address), isWritable: false }), w({ pubkey: new ye.PublicKey(i.marketId), isWritable: false }), w({ pubkey: new ye.PublicKey(i.marketEventQueue), isWritable: false })];
      return new ye.TransactionInstruction({ programId: new ye.PublicKey(i.programId), keys: n, data: t });
    }
    function Vd({ poolKeys: i, userKeys: e, amountIn: t, minAmountOut: n, modelDataPubKey: o = Jn }, r) {
      let s = Qe(i), a = Buffer.alloc(Ia.span);
      Ia.encode({ instruction: 9, amountIn: oe(t), minAmountOut: oe(n) }, a);
      let c = [w({ pubkey: On.TOKEN_PROGRAM_ID, isWritable: false }), w({ pubkey: s.id }), w({ pubkey: s.authority, isWritable: false }), w({ pubkey: s.openOrders })];
      return r === 4 && c.push(w({ pubkey: s.targetOrders })), c.push(w({ pubkey: s.vault.A }), w({ pubkey: s.vault.B })), r === 5 && c.push(w({ pubkey: o })), c.push(w({ pubkey: s.marketProgramId, isWritable: false }), w({ pubkey: s.marketId }), w({ pubkey: s.marketBids }), w({ pubkey: s.marketAsks }), w({ pubkey: s.marketEventQueue }), w({ pubkey: s.marketBaseVault }), w({ pubkey: s.marketQuoteVault }), w({ pubkey: s.marketAuthority, isWritable: false }), w({ pubkey: e.tokenAccountIn }), w({ pubkey: e.tokenAccountOut }), w({ pubkey: e.owner, isWritable: false, isSigner: true })), new ye.TransactionInstruction({ programId: s.programId, keys: c, data: a });
    }
    function _d({ poolKeys: i, userKeys: e, maxAmountIn: t, amountOut: n, modelDataPubKey: o = Jn }, r) {
      let s = Qe(i), a = Buffer.alloc(Ba.span);
      Ba.encode({ instruction: 11, maxAmountIn: oe(t), amountOut: oe(n) }, a);
      let c = [w({ pubkey: On.TOKEN_PROGRAM_ID, isWritable: false }), w({ pubkey: s.id }), w({ pubkey: s.authority, isWritable: false }), w({ pubkey: s.openOrders }), w({ pubkey: s.targetOrders }), w({ pubkey: s.vault.A }), w({ pubkey: s.vault.B })];
      return r === 5 && c.push(w({ pubkey: o })), c.push(w({ pubkey: s.marketProgramId, isWritable: false }), w({ pubkey: s.marketId }), w({ pubkey: s.marketBids }), w({ pubkey: s.marketAsks }), w({ pubkey: s.marketEventQueue }), w({ pubkey: s.marketBaseVault }), w({ pubkey: s.marketQuoteVault }), w({ pubkey: s.marketAuthority, isWritable: false }), w({ pubkey: e.tokenAccountIn }), w({ pubkey: e.tokenAccountOut }), w({ pubkey: e.owner, isWritable: false, isSigner: true })), new ye.TransactionInstruction({ programId: s.programId, keys: c, data: a });
    }
    function Ed(i, e, t, n, o, r, s, a, c, u) {
      let l = V([W("instructionId"), P2("amountIn"), P2("minAmountOut")]), m = Buffer.alloc(l.span);
      l.encode({ instructionId: 16, amountIn: c, minAmountOut: u }, m);
      let d = [{ pubkey: On.TOKEN_PROGRAM_ID, isWritable: false, isSigner: false }, { pubkey: e, isWritable: true, isSigner: false }, { pubkey: t, isWritable: false, isSigner: false }, { pubkey: n, isWritable: true, isSigner: false }, { pubkey: o, isWritable: true, isSigner: false }, { pubkey: r, isWritable: true, isSigner: false }, { pubkey: s, isWritable: true, isSigner: false }, { pubkey: a, isWritable: false, isSigner: true }];
      return new ye.TransactionInstruction({ programId: i, keys: d, data: m });
    }
    function Wd(i, e, t, n, o, r, s, a, c, u) {
      let l = V([W("instructionId"), P2("maxAmountIn"), P2("amountOut")]), m = Buffer.alloc(l.span);
      l.encode({ instructionId: 17, maxAmountIn: c, amountOut: u }, m);
      let d = [{ pubkey: On.TOKEN_PROGRAM_ID, isWritable: false, isSigner: false }, { pubkey: e, isWritable: true, isSigner: false }, { pubkey: t, isWritable: false, isSigner: false }, { pubkey: n, isWritable: true, isSigner: false }, { pubkey: o, isWritable: true, isSigner: false }, { pubkey: r, isWritable: true, isSigner: false }, { pubkey: s, isWritable: true, isSigner: false }, { pubkey: a, isWritable: false, isSigner: true }];
      return new ye.TransactionInstruction({ programId: i, keys: d, data: m });
    }
    function Kr(i) {
      let { poolKeys: e, version: t, userKeys: n, amountIn: o, amountOut: r, fixedSide: s } = i;
      if (t === 4) {
        if (s === "in")
          return Ed(new ye.PublicKey(e.programId), new ye.PublicKey(e.id), new ye.PublicKey(e.authority), new ye.PublicKey(e.vault.A), new ye.PublicKey(e.vault.B), n.tokenAccountIn, n.tokenAccountOut, n.owner, new Sr.default(o.toString()), new Sr.default(r.toString()));
        if (s === "out")
          return Wd(new ye.PublicKey(e.programId), new ye.PublicKey(e.id), new ye.PublicKey(e.authority), new ye.PublicKey(e.vault.A), new ye.PublicKey(e.vault.B), n.tokenAccountIn, n.tokenAccountOut, n.owner, new Sr.default(o.toString()), new Sr.default(r.toString()));
        Ca.logWithError("invalid params", "params", i);
      }
      throw Ca.logWithError("invalid version, only support pool v4", "poolKeys.version", t), new Error("invalid version");
    }
    function Cr(i) {
      let { poolKeys: e, version: t, userKeys: n, amountIn: o, amountOut: r, fixedSide: s } = i;
      if (t === 4 || t === 5) {
        let a = { poolKeys: e, userKeys: n };
        if (s === "in")
          return Vd(U(E({}, a), { amountIn: o, minAmountOut: r }), t);
        if (s === "out")
          return _d(U(E({}, a), { maxAmountIn: o, amountOut: r }), t);
        Ca.logWithError("invalid params", "params", i);
      }
      throw Ca.logWithError("invalid version", "poolKeys.version", t), new Error("invalid version");
    }
    function Lb({ poolKeys: i, userKeys: e, startTime: t }) {
      let n = Buffer.alloc(xa.span);
      xa.encode({ instruction: 0, nonce: 5, startTime: oe(t) }, n);
      let o = Qe(i), r = [w({ pubkey: On.TOKEN_PROGRAM_ID, isWritable: false }), w({ pubkey: ye.SystemProgram.programId, isWritable: false }), w({ pubkey: ye.SYSVAR_RENT_PUBKEY, isWritable: false }), w({ pubkey: o.id }), w({ pubkey: o.authority, isWritable: false }), w({ pubkey: o.openOrders }), w({ pubkey: o.mintLp.address }), w({ pubkey: o.mintA.address, isWritable: false }), w({ pubkey: o.mintB.address, isWritable: false }), w({ pubkey: o.vault.A, isWritable: false }), w({ pubkey: o.vault.B, isWritable: false }), w({ pubkey: o.id }), w({ pubkey: o.targetOrders }), w({ pubkey: e.lpTokenAccount }), w({ pubkey: o.id, isWritable: false }), w({ pubkey: o.marketProgramId, isWritable: false }), w({ pubkey: o.marketId, isWritable: false }), w({ pubkey: e.payer, isSigner: true })];
      return new ye.TransactionInstruction({ programId: o.programId, keys: r, data: n });
    }
    function Dc({ poolKeys: i }) {
      let e = V([W("instruction"), W("simulateType")]), t = Buffer.alloc(e.span);
      e.encode({ instruction: 12, simulateType: 0 }, t);
      let n = [w({ pubkey: new ye.PublicKey(i.id), isWritable: false }), w({ pubkey: new ye.PublicKey(i.authority), isWritable: false }), w({ pubkey: new ye.PublicKey(i.openOrders), isWritable: false }), w({ pubkey: new ye.PublicKey(i.vault.A), isWritable: false }), w({ pubkey: new ye.PublicKey(i.vault.B), isWritable: false }), w({ pubkey: new ye.PublicKey(i.mintLp.address), isWritable: false }), w({ pubkey: new ye.PublicKey(i.marketId), isWritable: false }), w({ pubkey: new ye.PublicKey(i.marketEventQueue), isWritable: false })];
      return { instruction: new ye.TransactionInstruction({ programId: new ye.PublicKey(i.programId), keys: n, data: t }) };
    }
    var zo = 5e4;
    var Dd = V([P2("x"), P2("y"), P2("price")]);
    var qd = V([P2("accountType"), P2("status"), P2("multiplier"), P2("validDataCount"), Z(Dd, zo, "DataElement")]);
    function Nb(i, e) {
      return [0, zo - 2];
    }
    function Ob(i) {
      return [0, zo - 2];
    }
    function Mb(i) {
      return [0, zo - 2];
    }
    function vb(i, e, t) {
      let [n, o] = Nb(e, t), r = n, s = o, a = 0, c = e * i.multiplier / t;
      for (; r <= s; ) {
        if (a = Math.floor((s + r) / 2), a === 0 || a >= zo - 2)
          return [a, a, false];
        let u = i.DataElement[a].x * i.multiplier / i.DataElement[a].y, l = i.DataElement[a - 1].x * i.multiplier / i.DataElement[a - 1].y, m = i.DataElement[a + 1].x * i.multiplier / i.DataElement[a + 1].y;
        if (c === u)
          return [a, a, true];
        if (c === l)
          return [a - 1, a - 1, true];
        if (c === m)
          return [a + 1, a + 1, true];
        if (c < l)
          s = a - 1;
        else {
          if (c > l && c < u)
            return [a - 1, a, true];
          if (c > u && c < m)
            return [a, a + 1, true];
          r = a + 1;
        }
      }
      return [a, a, false];
    }
    function qc(i, e, t) {
      let [n, o, r] = vb(i, e, t);
      if (!r)
        return 0;
      if (n === o) {
        let s = i.DataElement[n].x;
        return e * i.multiplier / s;
      } else {
        let s = i.DataElement[n].x, a = i.DataElement[n].y, c = i.DataElement[o].x, u = i.DataElement[o].y, l = t * (c * a - s * u), m = s * l, d = (c - s) * (e * a - s * t) * u, p = m + d;
        return e * i.multiplier * l / p;
      }
    }
    function Go(i, e, t) {
      return e * i.multiplier / t;
    }
    function Ud(i, e, t) {
      return e * t / i.multiplier;
    }
    function Fb(i, e) {
      let [t, n] = Ob(e), o = t, r = n, s = 0, a = e;
      for (; o < r; ) {
        if (s = Math.floor((r + o) / 2), s <= 0 || s > zo - 2)
          return [s, s, false];
        let c = i.DataElement[s].x, u = i.DataElement[s - 1].x, l = i.DataElement[s + 1].x;
        if (a === c)
          return [s, s, true];
        if (a === u)
          return [s - 1, s - 1, true];
        if (a === l)
          return [s + 1, s + 1, true];
        if (a < u)
          r = s - 1;
        else {
          if (a > u && a < c)
            return [s - 1, s, true];
          if (a > c && a < l)
            return [s, s + 1, true];
          o = s + 1;
        }
      }
      return [s, s, false];
    }
    function Vb(i, e) {
      let [t, n] = Mb(e), o = t, r = n, s = 0, a = e;
      for (; o <= r; ) {
        if (s = Math.floor((r + o) / 2), s <= 0 || s >= zo - 2)
          return [s, s, false];
        let c = i.DataElement[s].y, u = i.DataElement[s - 1].y, l = i.DataElement[s + 1].y;
        if (a === c)
          return [s, s, true];
        if (a === u)
          return [s - 1, s - 1, true];
        if (a === l)
          return [s + 1, s + 1, true];
        if (a < l)
          o = s + 1;
        else {
          if (a < u && a > c)
            return [s - 1, s, true];
          if (a < c && a > l)
            return [s, s + 1, true];
          r = s - 1;
        }
      }
      return [s, s, false];
    }
    function Gd(i, e, t, n) {
      let o = n ? e + t : e - t, [r, s, a] = Fb(i, o);
      if (!a)
        return [0, 0, false, a];
      if (r === s)
        return [i.DataElement[s].price, i.DataElement[s].y, false, a];
      {
        let c = i.DataElement[r].x, u = i.DataElement[s].x, l = i.DataElement[r].price, m = i.DataElement[s].price, d = i.DataElement[r].y, p = i.DataElement[s].y;
        if (e >= c && e <= u)
          return n ? [m, p, true, a] : [l, d, true, a];
        {
          let f, y;
          return n ? (f = l + (m - l) * (e - c) / (u - c), y = d - (o - c) * i.multiplier / m) : (f = l + (m - l) * (e - c) / (u - c), y = p + (u - o) * i.multiplier / l), [f, y, false, a];
        }
      }
    }
    function _b(i, e, t, n) {
      let o = n ? e - t : e + t, [r, s, a] = Vb(i, o);
      if (!a)
        return [0, 0, false, a];
      if (r === s)
        return [i.DataElement[s].price, i.DataElement[s].x, false, a];
      {
        let c = i.DataElement[r].x, u = i.DataElement[s].x, l = i.DataElement[r].price, m = i.DataElement[s].price, d = i.DataElement[r].y, p = i.DataElement[s].y;
        if (e >= p && e <= d)
          return n ? [m, u, true, a] : [l, c, true, a];
        {
          let f, y;
          return n ? (f = l + (m - l) * (d - e) / (d - p), y = c + m * (d - o) / i.multiplier) : (f = l + (m - l) * (d - e) / (d - p), y = u - l * (o - p) / i.multiplier), [f, y, false, a];
        }
      }
    }
    function Eb(i, e) {
      let t = Gd(i, e, 0, false);
      return t[3] ? t[0] : 0;
    }
    function Uc(i, e, t, n) {
      let o = qc(i, e, t), r = Go(i, e, o), s = Go(i, t, o), a = Go(i, n, o), c = true, [u, l, m, d] = Gd(i, r, a, c);
      if (!d)
        return 0;
      if (m)
        return n * i.multiplier / u;
      {
        let p = s - l;
        return Ud(i, p, o);
      }
    }
    function Gc(i, e, t, n) {
      let o = qc(i, e, t), r = Go(i, e, o), s = Go(i, t, o), a = Go(i, n, o), c = false, [u, l, m, d] = _b(i, s, a, c);
      if (!d)
        return 0;
      if (m)
        return n * u / i.multiplier;
      {
        let p = r - l;
        return Ud(i, p, o);
      }
    }
    function Xd(i) {
      let e = qd.decode(i);
      return { accountType: e.accountType.toNumber(), status: e.status.toNumber(), multiplier: e.multiplier.toNumber(), validDataCount: e.validDataCount.toNumber(), DataElement: e.DataElement.map((t) => ({ x: t.x.toNumber(), y: t.y.toNumber(), price: t.price.toNumber() })) };
    }
    function Xc(i, e, t, n) {
      let o = Eb(i, Go(i, e, qc(i, e, t))) / i.multiplier;
      return n ? o : 1 / o;
    }
    var Xo = class {
      constructor({ connection: e, modelDataPubKey: t = Jn }) {
        this._layoutData = { accountType: 0, status: 0, multiplier: 0, validDataCount: 0, DataElement: [] };
        this.connection = e, this.modelDataPubKey = t;
      }
      get stableModelData() {
        return this._layoutData;
      }
      async initStableModelLayout() {
        if (this._layoutData.validDataCount === 0 && this.connection) {
          let e = await this.connection.getAccountInfo(this.modelDataPubKey);
          e && (this._layoutData = Xd(e == null ? void 0 : e.data));
        }
      }
    };
    var Ri = require("@solana/web3.js");
    var Ci = Ae(require_bn());
    var Hd = require_cjs4();
    var zd = require("@solana/web3.js");
    var Wb = xe("Raydium_liquidity_serum");
    function Yd({ programId: i, marketId: e }) {
      let t = [e.toBuffer()], n = 0, o;
      for (; n < 100; ) {
        try {
          let r = t.concat(Buffer.from([n]), Buffer.alloc(7));
          o = zd.PublicKey.createProgramAddressSync(r, i);
        } catch (r) {
          if (r instanceof TypeError)
            throw r;
          n++;
          continue;
        }
        return { publicKey: o, nonce: n };
      }
      throw Wb.logWithError("unable to find a viable program address nonce", "params", { programId: i, marketId: e }), new Error("unable to find a viable program address nonce");
    }
    function Rr({ programId: i }) {
      let { publicKey: e } = se([Buffer.from("amm_config_account_seed", "utf-8")], i);
      return e;
    }
    function Ko({ name: i, programId: e, marketId: t }) {
      let { publicKey: n } = se([e.toBuffer(), t.toBuffer(), Buffer.from(i, "utf-8")], e);
      return n;
    }
    function Qd({ programId: i, marketId: e }) {
      let { publicKey: t } = se([i.toBuffer(), e.toBuffer(), Buffer.from("open_order_associated_seed", "utf-8")], i);
      return t;
    }
    function Na({ programId: i }) {
      return se([Buffer.from([97, 109, 109, 32, 97, 117, 116, 104, 111, 114, 105, 116, 121])], i);
    }
    function Oa({ version: i, marketVersion: e, marketId: t, baseMint: n, quoteMint: o, baseDecimals: r, quoteDecimals: s, programId: a, marketProgramId: c }) {
      let u = Ko({ name: "amm_associated_seed", programId: a, marketId: t }), l = Ko({ name: "lp_mint_associated_seed", programId: a, marketId: t }), { publicKey: m, nonce: d } = Na({ programId: a }), p = Ko({ name: "coin_vault_associated_seed", programId: a, marketId: t }), f = Ko({ name: "pc_vault_associated_seed", programId: a, marketId: t }), y = Ko({ name: "temp_lp_token_associated_seed", programId: a, marketId: t }), b = Qd({ programId: a, marketId: t }), g = Ko({ name: "target_associated_seed", programId: a, marketId: t }), A = Ko({ name: "withdraw_associated_seed", programId: a, marketId: t }), { publicKey: k } = Yd({ programId: c, marketId: t });
      return { id: u, baseMint: n, quoteMint: o, lpMint: l, baseDecimals: r, quoteDecimals: s, lpDecimals: r, version: i, programId: a, authority: m, nonce: d, baseVault: p, quoteVault: f, lpVault: y, openOrders: b, targetOrders: g, withdrawQueue: A, marketVersion: e, marketProgramId: c, marketId: t, marketAuthority: k, lookupTableAccount: Ri.PublicKey.default, configId: Rr({ programId: a }) };
    }
    var zc;
    async function Db({ connection: i, poolKeysList: e, config: t, modelDataPubKey: n }) {
      return e.find((r) => r.modelDataAccount) && (zc || (zc = new Xo({ connection: i, modelDataPubKey: n }), await zc.initStableModelLayout())), await Promise.all(e.map(async (r) => {
        if (r.modelDataAccount) {
          let s = Dc({ poolKeys: r });
          return (await xu(i, [s.instruction], "GetPoolData")).map((u) => {
            let l = Su(u, "GetPoolData"), m = new Ci.default(_n(l, "status")), d = Number(_n(l, "coin_decimals")), p = Number(_n(l, "pc_decimals")), f = Number(_n(l, "lp_decimals")), y = new Ci.default(_n(l, "pool_coin_amount")), b = new Ci.default(_n(l, "pool_pc_amount")), g = new Ci.default(_n(l, "pool_lp_supply")), A = "0";
            try {
              A = _n(l, "pool_open_time");
            } catch {
            }
            return { status: m, baseDecimals: d, quoteDecimals: p, lpDecimals: f, baseReserve: y, quoteReserve: b, lpSupply: g, startTime: new Ci.default(A) };
          })[0];
        } else {
          let [s, a, c, u] = await i.getMultipleAccountsInfo([new Ri.PublicKey(r.id), new Ri.PublicKey(r.vault.A), new Ri.PublicKey(r.vault.B), new Ri.PublicKey(r.mintLp.address)]);
          if (s === null)
            throw Error("fetch pool error");
          if (a === null)
            throw Error("fetch vaultAccA error");
          if (c === null)
            throw Error("fetch vaultAccB error");
          if (u === null)
            throw Error("fetch mintAccLp error");
          let l = So.decode(s.data), m = kn.decode(a.data), d = kn.decode(c.data), p = Vc.decode(u.data);
          return { status: l.status, baseDecimals: l.baseDecimal.toNumber(), quoteDecimals: l.quoteDecimal.toNumber(), lpDecimals: p.decimals, baseReserve: m.amount.sub(l.baseNeedTakePnl), quoteReserve: d.amount.sub(l.quoteNeedTakePnl), lpSupply: l.lpReserve, startTime: l.poolOpenTime };
        }
      }));
    }
    var Yc = { volume: 0, volumeQuote: 0, volumeFee: 0, apr: 0, feeApr: 0, priceMin: 0, priceMax: 0, rewardApr: [] };
    var Lr = (i) => {
      let e = {}, t = Hd.TOKEN_PROGRAM_ID.toBase58();
      return Object.keys(i).map((n) => {
        let o = i[n], [r, s] = [o.baseMint.toBase58(), o.quoteMint.toBase58()];
        e[n] = { id: n, version: 4, status: o.status.toNumber(), programId: o.programId.toBase58(), mintA: vt({ address: r, programId: t, decimals: o.baseDecimal.toNumber() }), mintB: vt({ address: s, programId: t, decimals: o.quoteDecimal.toNumber() }), rewardDefaultInfos: [], rewardDefaultPoolInfos: "Ecosystem", price: o.poolPrice.toNumber(), mintAmountA: new O(o.mintAAmount.toString()).div(10 ** o.baseDecimal.toNumber()).toNumber(), mintAmountB: new O(o.mintBAmount.toString()).div(10 ** o.quoteDecimal.toNumber()).toNumber(), baseReserve: o.baseReserve, quoteReserve: o.quoteReserve, feeRate: new O(o.tradeFeeNumerator.toString()).div(o.tradeFeeDenominator.toString()).toNumber(), openTime: o.poolOpenTime.toString(), tvl: 0, day: Yc, week: Yc, month: Yc, pooltype: [], farmUpcomingCount: 0, farmOngoingCount: 0, farmFinishedCount: 0, type: "Standard", marketId: o.marketId.toBase58(), configId: Rr({ programId: o.programId }).toBase58(), lpPrice: 0, lpAmount: new O(o.lpReserve.toString()).div(10 ** Math.min(o.baseDecimal.toNumber(), o.quoteDecimal.toNumber())).toNumber(), lpMint: vt({ address: o.lpMint.toBase58(), programId: t, decimals: Math.min(o.baseDecimal.toNumber(), o.quoteDecimal.toNumber()) }), burnPercent: 0 };
      }), e;
    };
    var nt = Ae(require_bn());
    var Ni = require("@solana/web3.js");
    var Oi = Ae(require_bn());
    var Hc = require_cjs4();
    var $t = require("@solana/web3.js");
    var Li = require_cjs4();
    function qb(i = "accountFlags") {
      let e = new mr(i);
      return e.addBoolean("initialized"), e.addBoolean("market"), e.addBoolean("openOrders"), e.addBoolean("requestQueue"), e.addBoolean("eventQueue"), e.addBoolean("bids"), e.addBoolean("asks"), e;
    }
    var Ma = V([Fe(5), qb("accountFlags"), F("ownAddress"), P2("vaultSignerNonce"), F("baseMint"), F("quoteMint"), F("baseVault"), P2("baseDepositsTotal"), P2("baseFeesAccrued"), F("quoteVault"), P2("quoteDepositsTotal"), P2("quoteFeesAccrued"), P2("quoteDustThreshold"), F("requestQueue"), F("eventQueue"), F("bids"), F("asks"), P2("baseLotSize"), P2("quoteLotSize"), P2("feeRateBps"), P2("referrerRebatesAccrued"), Fe(7)]);
    function jd({ programId: i, marketInfo: e }) {
      let t = V([W("version"), St("instruction"), P2("baseLotSize"), P2("quoteLotSize"), on("feeRateBps"), P2("vaultSignerNonce"), P2("quoteDustThreshold")]), n = [{ pubkey: e.id, isSigner: false, isWritable: true }, { pubkey: e.requestQueue, isSigner: false, isWritable: true }, { pubkey: e.eventQueue, isSigner: false, isWritable: true }, { pubkey: e.bids, isSigner: false, isWritable: true }, { pubkey: e.asks, isSigner: false, isWritable: true }, { pubkey: e.baseVault, isSigner: false, isWritable: true }, { pubkey: e.quoteVault, isSigner: false, isWritable: true }, { pubkey: e.baseMint, isSigner: false, isWritable: false }, { pubkey: e.quoteMint, isSigner: false, isWritable: false }, { pubkey: e.authority ? e.quoteMint : $t.SYSVAR_RENT_PUBKEY, isSigner: false, isWritable: false }].concat(e.authority ? { pubkey: e.authority, isSigner: false, isWritable: false } : []).concat(e.authority && e.pruneAuthority ? { pubkey: e.pruneAuthority, isSigner: false, isWritable: false } : []), o = Buffer.alloc(t.span);
      return t.encode({ version: 0, instruction: 0, baseLotSize: e.baseLotSize, quoteLotSize: e.quoteLotSize, feeRateBps: e.feeRateBps, vaultSignerNonce: e.vaultSignerNonce, quoteDustThreshold: e.quoteDustThreshold }, o), new $t.TransactionInstruction({ keys: n, programId: i, data: o });
    }
    async function Nr({ connection: i, wallet: e, marketInfo: t }) {
      var s, a, c, u, l, m, d, p;
      let n = new $t.Transaction(), o = await i.getMinimumBalanceForRentExemption(165);
      n.add($t.SystemProgram.createAccountWithSeed({ fromPubkey: e, basePubkey: e, seed: t.baseVault.seed, newAccountPubkey: t.baseVault.publicKey, lamports: o, space: 165, programId: Li.TOKEN_PROGRAM_ID }), $t.SystemProgram.createAccountWithSeed({ fromPubkey: e, basePubkey: e, seed: t.quoteVault.seed, newAccountPubkey: t.quoteVault.publicKey, lamports: o, space: 165, programId: Li.TOKEN_PROGRAM_ID }), (0, Li.createInitializeAccountInstruction)(t.baseVault.publicKey, t.baseMint, t.vaultOwner), (0, Li.createInitializeAccountInstruction)(t.quoteVault.publicKey, t.quoteMint, t.vaultOwner), $t.SystemProgram.createAccountWithSeed({ fromPubkey: e, basePubkey: e, seed: t.id.seed, newAccountPubkey: t.id.publicKey, lamports: await i.getMinimumBalanceForRentExemption(Ma.span), space: Ma.span, programId: t.programId }));
      let r = new $t.Transaction();
      return r.add($t.SystemProgram.createAccountWithSeed({ fromPubkey: e, basePubkey: e, seed: t.requestQueue.seed, newAccountPubkey: t.requestQueue.publicKey, lamports: t.lowestFeeMarket ? 6208320 : await i.getMinimumBalanceForRentExemption((s = t.requestQueueSpace) != null ? s : 5120 + 12), space: t.lowestFeeMarket ? 764 : (a = t.requestQueueSpace) != null ? a : 5120 + 12, programId: t.programId }), $t.SystemProgram.createAccountWithSeed({ fromPubkey: e, basePubkey: e, seed: t.eventQueue.seed, newAccountPubkey: t.eventQueue.publicKey, lamports: t.lowestFeeMarket ? 79594560 : await i.getMinimumBalanceForRentExemption((c = t.eventQueueSpace) != null ? c : 262144 + 12), space: t.lowestFeeMarket ? 11308 : (u = t.eventQueueSpace) != null ? u : 262144 + 12, programId: t.programId }), $t.SystemProgram.createAccountWithSeed({ fromPubkey: e, basePubkey: e, seed: t.bids.seed, newAccountPubkey: t.bids.publicKey, lamports: t.lowestFeeMarket ? 101977920 : await i.getMinimumBalanceForRentExemption((l = t.orderbookQueueSpace) != null ? l : 65536 + 12), space: t.lowestFeeMarket ? 14524 : (m = t.orderbookQueueSpace) != null ? m : 65536 + 12, programId: t.programId }), $t.SystemProgram.createAccountWithSeed({ fromPubkey: e, basePubkey: e, seed: t.asks.seed, newAccountPubkey: t.asks.publicKey, lamports: t.lowestFeeMarket ? 101977920 : await i.getMinimumBalanceForRentExemption((d = t.orderbookQueueSpace) != null ? d : 65536 + 12), space: t.lowestFeeMarket ? 14524 : (p = t.orderbookQueueSpace) != null ? p : 65536 + 12, programId: t.programId }), jd({ programId: t.programId, marketInfo: { id: t.id.publicKey, requestQueue: t.requestQueue.publicKey, eventQueue: t.eventQueue.publicKey, bids: t.bids.publicKey, asks: t.asks.publicKey, baseVault: t.baseVault.publicKey, quoteVault: t.quoteVault.publicKey, baseMint: t.baseMint, quoteMint: t.quoteMint, baseLotSize: t.baseLotSize, quoteLotSize: t.quoteLotSize, feeRateBps: t.feeRateBps, vaultSignerNonce: t.vaultSignerNonce, quoteDustThreshold: t.quoteDustThreshold } })), [{ transaction: n, signer: [], instructionTypes: [X.CreateAccount, X.CreateAccount, X.InitAccount, X.InitAccount] }, { transaction: r, signer: [], instructionTypes: [X.CreateAccount, X.CreateAccount, X.CreateAccount, X.CreateAccount, X.CreateAccount, X.InitMarket] }];
    }
    var Mi = class extends Je {
      async create({ baseInfo: e, quoteInfo: t, lotSize: n, tickSize: o, dexProgramId: r, requestQueueSpace: s, eventQueueSpace: a, orderbookQueueSpace: c, lowestFeeMarket: u, assignSeed: l, txVersion: m, computeBudgetConfig: d, txTipConfig: p, feePayer: f }) {
        let y = this.scope.ownerPubKey, b = l ? `${e.mint.toBase58().slice(0, 10)}-${t.mint.toBase58().slice(0, 10)}-${l}` : void 0, g = rt({ fromPublicKey: y, programId: r, assignSeed: b && `${b}-market` }), A = rt({ fromPublicKey: y, programId: r, assignSeed: b && `${b}-request` }), k = rt({ fromPublicKey: y, programId: r, assignSeed: b && `${b}-event` }), I = rt({ fromPublicKey: y, programId: r, assignSeed: b && `${b}-bids` }), T = rt({ fromPublicKey: y, programId: r, assignSeed: b && `${b}-asks` }), h = rt({ fromPublicKey: y, programId: Hc.TOKEN_PROGRAM_ID, assignSeed: b && `${b}-baseVault` }), S = rt({ fromPublicKey: y, programId: Hc.TOKEN_PROGRAM_ID, assignSeed: b && `${b}-quoteVault` }), x = 0, K = new Oi.default(100);
        function B() {
          let Y = new Oi.default(0);
          for (; ; )
            try {
              return { vaultOwner: Ni.PublicKey.createProgramAddressSync([g.publicKey.toBuffer(), Y.toArrayLike(Buffer, "le", 8)], r), vaultSignerNonce: Y };
            } catch {
              if (Y.iaddn(1), Y.gt(new Oi.default(25555)))
                throw Error("find vault owner error");
            }
        }
        let { vaultOwner: C, vaultSignerNonce: R } = B(), N = new Oi.default(Math.round(10 ** e.decimals * n)), v = new Oi.default(Math.round(n * 10 ** t.decimals * o));
        if (N.eq(ut))
          throw Error("lot size is too small");
        if (v.eq(ut))
          throw Error("tick size or lot size is too small");
        let L = await Nr({ connection: this.scope.connection, wallet: this.scope.ownerPubKey, marketInfo: { programId: r, id: g, baseMint: e.mint, quoteMint: t.mint, baseVault: h, quoteVault: S, vaultOwner: C, requestQueue: A, eventQueue: k, bids: I, asks: T, feeRateBps: x, quoteDustThreshold: K, vaultSignerNonce: R, baseLotSize: N, quoteLotSize: v, requestQueueSpace: s, eventQueueSpace: a, orderbookQueueSpace: c, lowestFeeMarket: u } }), M = this.createTxBuilder(f);
        M.addInstruction({ instructions: L[0].transaction.instructions, signers: L[0].signer });
        for await (let Y of L.slice(1, L.length))
          M.addInstruction({ instructions: Y.transaction.instructions, signers: Y.signer, instructionTypes: Y.instructionTypes });
        return m === 0 ? M.sizeCheckBuildV0({ computeBudgetConfig: d, address: { marketId: g.publicKey, requestQueue: A.publicKey, eventQueue: k.publicKey, bids: I.publicKey, asks: T.publicKey, baseVault: h.publicKey, quoteVault: S.publicKey, baseMint: new Ni.PublicKey(e.mint), quoteMint: new Ni.PublicKey(t.mint) } }) : M.sizeCheckBuild({ computeBudgetConfig: d, address: { marketId: g.publicKey, requestQueue: A.publicKey, eventQueue: k.publicKey, bids: I.publicKey, asks: T.publicKey, baseVault: h.publicKey, quoteVault: S.publicKey, baseMint: new Ni.PublicKey(e.mint), quoteMint: new Ni.PublicKey(t.mint) } });
      }
    };
    var Or = class extends Je {
      constructor(t) {
        super(t);
        this.stableLayout = new Xo({ connection: this.scope.connection, modelDataPubKey: this.scope.cluster === "mainnet" ? void 0 : En.MODEL_DATA_PUBKEY });
      }
      async initLayout() {
        await this.stableLayout.initStableModelLayout();
      }
      async load() {
        this.checkDisabled();
      }
      computePairAmount({ poolInfo: t, amount: n, slippage: o, baseIn: r }) {
        let s = new nt.default(new O(n).mul(10 ** t[r ? "mintA" : "mintB"].decimals).toFixed(0)), a = Br(t[r ? "mintB" : "mintA"]), [c, u] = [new nt.default(new O(t.mintAmountA).mul(10 ** t.mintA.decimals).toString()), new nt.default(new O(t.mintAmountB).mul(10 ** t.mintB.decimals).toString())], l = new nt.default(new O(t.lpAmount).mul(10 ** t.lpMint.decimals).toFixed(0, O.ROUND_DOWN));
        this.logDebug("baseReserve:", c.toString(), "quoteReserve:", u.toString()), this.logDebug("tokenIn:", r ? t.mintA.symbol : t.mintB.symbol, "amountIn:", s.toString(), "anotherToken:", r ? t.mintB.symbol : t.mintA.symbol, "slippage:", `${o.toSignificant()}%`, "baseReserve", c.toString(), "quoteReserve", u.toString());
        let m = r ? "base" : "quote";
        this.logDebug("input side:", m);
        let d = ut;
        s.isZero() || (d = m === "base" ? er(s.mul(u), c) : er(s.mul(c), u)), this.logDebug("amountRaw:", d.toString(), "lpAmount:", l.toString());
        let p = er(s.mul(l), m === "base" ? c : u);
        this.logDebug("liquidity:", p.toString());
        let f = new ot(new nt.default(1)).add(o), y = new ot(new nt.default(1)).sub(o), b = f.mul(d).quotient, g = y.mul(d).quotient, A = new ve(a, d), k = new ve(a, b), I = new ve(a, g);
        return this.logDebug("anotherAmount:", A.toFixed(), "maxAnotherAmount:", k.toFixed()), { anotherAmount: A, maxAnotherAmount: k, minAnotherAmount: I, liquidity: p };
      }
      async getAmmPoolKeys(t) {
        return (await this.scope.api.fetchPoolKeysById({ idList: [t] }))[0];
      }
      async addLiquidity(t) {
        let { poolInfo: n, poolKeys: o, amountInA: r, amountInB: s, otherAmountMin: a, fixedSide: c, config: u, txVersion: l, computeBudgetConfig: m, txTipConfig: d, feePayer: p } = t;
        this.scope.availability.addStandardPosition === false && this.logAndCreateError("add liquidity feature disabled in your region"), this.logDebug("amountInA:", r, "amountInB:", s), (r.isZero() || s.isZero()) && this.logAndCreateError("amounts must greater than zero", "amountInA & amountInB", { amountInA: r.toFixed(), amountInB: s.toFixed() });
        let { account: f } = this.scope, { bypassAssociatedCheck: y, checkCreateATAOwner: b } = E({ bypassAssociatedCheck: false, checkCreateATAOwner: false }, u), [g, A] = [r.token, s.token], k = await f.getCreatedTokenAccount({ mint: g.mint, associatedOnly: false }), I = await f.getCreatedTokenAccount({ mint: A.mint, associatedOnly: false });
        !k && !I && this.logAndCreateError("cannot found target token accounts", "tokenAccounts", f.tokenAccounts);
        let T = await f.getCreatedTokenAccount({ mint: new lt.PublicKey(n.lpMint.address) }), h = [g, A], S = [k, I], x = [r.raw, s.raw], K = r.token.mint.toBase58() === n.mintA.address ? "base" : "quote", B = "base";
        ["quote", "base"].includes(K) || this.logAndCreateError("invalid fixedSide", "fixedSide", c), K === "quote" ? (h.reverse(), S.reverse(), x.reverse(), B = c === "a" ? "quote" : "base") : K === "base" && (B = c === "a" ? "base" : "quote");
        let [C, R] = h, [N, v] = S, [L, M] = x, Y = o != null ? o : await this.getAmmPoolKeys(n.id), j = this.createTxBuilder(p), ie = await f.handleTokenAccount({ side: "in", amount: L, mint: C.mint, tokenAccount: N, bypassAssociatedCheck: y, checkCreateATAOwner: b }), { tokenAccount: le } = ie, be = tt(ie, ["tokenAccount"]);
        j.addInstruction(be);
        let We = await f.handleTokenAccount({ side: "in", amount: M, mint: R.mint, tokenAccount: v, bypassAssociatedCheck: y, checkCreateATAOwner: b }), { tokenAccount: me } = We, Ie = tt(We, ["tokenAccount"]);
        j.addInstruction(Ie);
        let He = await f.handleTokenAccount({ side: "out", amount: 0, mint: new lt.PublicKey(n.lpMint.address), tokenAccount: T, bypassAssociatedCheck: y, checkCreateATAOwner: b }), { tokenAccount: he } = He, ue = tt(He, ["tokenAccount"]);
        return j.addInstruction(ue), j.addInstruction({ instructions: [Wc({ poolInfo: n, poolKeys: Y, userKeys: { baseTokenAccount: le, quoteTokenAccount: me, lpTokenAccount: he, owner: this.scope.ownerPubKey }, baseAmountIn: L, quoteAmountIn: M, otherAmountMin: a.raw, fixedSide: B })], instructionTypes: [n.pooltype.includes("StablePool") ? X.AmmV5AddLiquidity : X.AmmV4AddLiquidity], lookupTableAddress: Y.lookupTableAccount ? [Y.lookupTableAccount] : [] }), j.addCustomComputeBudget(m), j.addTipInstruction(d), l === 0 ? await j.buildV0() : j.build();
      }
      async removeLiquidity(t) {
        this.scope.availability.removeStandardPosition === false && this.logAndCreateError("remove liquidity feature disabled in your region");
        let { poolInfo: n, poolKeys: o, lpAmount: r, baseAmountMin: s, quoteAmountMin: a, config: c, txVersion: u, computeBudgetConfig: l, txTipConfig: m, feePayer: d } = t, p = o != null ? o : await this.getAmmPoolKeys(n.id), [f, y, b] = [new lt.PublicKey(n.mintA.address), new lt.PublicKey(n.mintB.address), new lt.PublicKey(n.lpMint.address)];
        this.logDebug("lpAmount:", r), this.logDebug("baseAmountMin:", s), this.logDebug("quoteAmountMin:", a), r.isZero() && this.logAndCreateError("amount must greater than zero", "lpAmount", r.toString());
        let { account: g } = this.scope, A = await g.getCreatedTokenAccount({ mint: b, associatedOnly: false });
        A || this.logAndCreateError("cannot found lpTokenAccount", "tokenAccounts", g.tokenAccounts);
        let k = await g.getCreatedTokenAccount({ mint: f }), I = await g.getCreatedTokenAccount({ mint: y }), T = this.createTxBuilder(d), { bypassAssociatedCheck: h, checkCreateATAOwner: S } = E({ bypassAssociatedCheck: false, checkCreateATAOwner: false }, c), R = await g.handleTokenAccount({ side: "out", amount: 0, mint: f, tokenAccount: k, bypassAssociatedCheck: h, checkCreateATAOwner: S }), { tokenAccount: x } = R, K = tt(R, ["tokenAccount"]);
        T.addInstruction(K);
        let N = await g.handleTokenAccount({ side: "out", amount: 0, mint: y, tokenAccount: I, bypassAssociatedCheck: h, checkCreateATAOwner: S }), { tokenAccount: B } = N, C = tt(N, ["tokenAccount"]);
        return T.addInstruction(C), T.addInstruction({ instructions: [Ra({ poolInfo: n, poolKeys: p, userKeys: { lpTokenAccount: A, baseTokenAccount: x, quoteTokenAccount: B, owner: this.scope.ownerPubKey }, lpAmount: r, baseAmountMin: s, quoteAmountMin: a })], lookupTableAddress: p.lookupTableAccount ? [p.lookupTableAccount] : [], instructionTypes: [n.pooltype.includes("StablePool") ? X.AmmV5RemoveLiquidity : X.AmmV4RemoveLiquidity] }), T.addCustomComputeBudget(l), T.addTipInstruction(m), u === 0 ? await T.buildV0() : T.build();
      }
      async removeAllLpAndCreateClmmPosition({ poolInfo: t, clmmPoolInfo: n, removeLpAmount: o, createPositionInfo: r, farmInfo: s, userFarmLpAmount: a, base: c, computeBudgetConfig: u, payer: l, userAuxiliaryLedgers: m, tokenProgram: d = Xt.TOKEN_PROGRAM_ID, checkCreateATAOwner: p = true, getEphemeralSigners: f, txVersion: y, feePayer: b }) {
        if ((this.scope.availability.removeStandardPosition === false || this.scope.availability.createConcentratedPosition === false) && this.logAndCreateError("remove liquidity or create position feature disabled in your region"), !(t.mintA.address === n.mintA.address || t.mintA.address === n.mintB.address) || !(t.mintB.address === n.mintA.address || t.mintB.address === n.mintB.address))
          throw Error("mint check error");
        let g = this.createTxBuilder(b), A = {};
        for (let Y of this.scope.account.tokenAccountRawInfos)
          (A[Y.accountInfo.mint.toString()] === void 0 || te(this.scope.ownerPubKey, Y.accountInfo.mint, Xt.TOKEN_PROGRAM_ID).publicKey.equals(Y.pubkey)) && (A[Y.accountInfo.mint.toString()] = Y.pubkey);
        let k = A[t.lpMint.address];
        if (k === void 0)
          throw Error("find lp account error in trade accounts");
        let I = o.add(a != null ? a : new nt.default(0)), T = t.mintA.address === De.WSOL.mint.toString(), h = t.mintB.address === De.WSOL.mint.toString(), { account: S, instructionParams: x } = await this.scope.account.getOrCreateTokenAccount({ tokenProgram: Xt.TOKEN_PROGRAM_ID, mint: new lt.PublicKey(t.mintA.address), owner: this.scope.ownerPubKey, createInfo: T ? { payer: this.scope.ownerPubKey } : void 0, skipCloseAccount: !T, notUseTokenAccount: T, associatedOnly: true, checkCreateATAOwner: p });
        if (g.addInstruction(x || {}), S === void 0)
          throw new Error("base token account not found");
        let { account: K, instructionParams: B } = await this.scope.account.getOrCreateTokenAccount({ tokenProgram: Xt.TOKEN_PROGRAM_ID, mint: new lt.PublicKey(t.mintB.address), owner: this.scope.ownerPubKey, createInfo: h ? { payer: this.scope.ownerPubKey, amount: 0 } : void 0, skipCloseAccount: !h, notUseTokenAccount: h, associatedOnly: true, checkCreateATAOwner: p });
        if (g.addInstruction(B || {}), K === void 0)
          throw new Error("quote token account not found");
        if (A[t.mintA.address] = S, A[t.mintB.address] = K, s !== void 0 && !(a != null && a.isZero())) {
          let Y = mn[s.programId], j = Ot({ programId: new lt.PublicKey(s.programId), poolId: new lt.PublicKey(s.id), owner: this.scope.ownerPubKey, version: Y }), le, be = await this.scope.connection.getAccountInfo(j);
          if (be && (le = Do(Y).decode(be.data)), Y !== 6 && !le) {
            let { instruction: He, instructionType: Se } = gi({ id: new lt.PublicKey(s.id), programId: new lt.PublicKey(s.programId), version: Y, ledger: j, owner: this.scope.ownerPubKey });
            g.addInstruction({ instructions: [He], instructionTypes: [Se] });
          }
          let me = [];
          for (let He of s.rewardInfos) {
            let Se = He.mint.address === De.WSOL.mint.toString();
            if (A[He.mint.address])
              me.push(A[He.mint.address]);
            else {
              let { account: Vt, instructionParams: un } = await this.scope.account.getOrCreateTokenAccount({ mint: new lt.PublicKey(He.mint.address), tokenProgram: d, owner: this.scope.ownerPubKey, skipCloseAccount: !Se, createInfo: { payer: l || this.scope.ownerPubKey }, associatedOnly: true, checkCreateATAOwner: p });
              Vt || this.logAndCreateError("farm reward account not found:", He.mint.address), un && g.addInstruction(un), me.push(Vt);
            }
          }
          let Ie = (await this.scope.api.fetchFarmKeysById({ ids: s.id }))[0], he = { userAuxiliaryLedgers: m, amount: a, owner: this.scope.ownerPubKey, farmInfo: s, farmKeys: Ie, lpAccount: k, rewardAccounts: me }, ue = mn[s.programId], ie = ue === 6 ? Pi(he) : ue === 5 ? Ai(he) : wi(he), We = { 3: X.FarmV3Withdraw, 5: X.FarmV5Withdraw, 6: X.FarmV6Withdraw };
          g.addInstruction({ instructions: [ie], instructionTypes: [We[ue]] });
        }
        let C = await this.getAmmPoolKeys(t.id), R = Ra({ poolInfo: t, poolKeys: C, userKeys: { lpTokenAccount: k, baseTokenAccount: S, quoteTokenAccount: K, owner: this.scope.ownerPubKey }, lpAmount: I, baseAmountMin: 0, quoteAmountMin: 0 });
        g.addInstruction({ instructions: [R], instructionTypes: [t.pooltype.includes("StablePool") ? X.AmmV5RemoveLiquidity : X.AmmV4RemoveLiquidity], lookupTableAddress: C.lookupTableAccount ? [C.lookupTableAccount] : [] });
        let [N, v] = t.mintA.address === n.mintA.address ? [S, K] : [K, S], L = await this.scope.clmm.getClmmPoolKeys(n.id), M = await Oe.openPositionFromBaseInstructions(U(E({ poolInfo: n, poolKeys: L, ownerInfo: { feePayer: this.scope.ownerPubKey, wallet: this.scope.ownerPubKey, tokenAccountA: N, tokenAccountB: v }, withMetadata: "create" }, r), { base: c, getEphemeralSigners: f }));
        return g.addInstruction({ instructions: [...M.instructions], signers: M.signers, instructionTypes: [...M.instructionTypes], lookupTableAddress: L.lookupTableAccount ? [L.lookupTableAccount] : [] }), y === 0 ? g.sizeCheckBuildV0({ computeBudgetConfig: u }) : g.sizeCheckBuild({ computeBudgetConfig: u });
      }
      async createPoolV4({ programId: t, marketInfo: n, baseMintInfo: o, quoteMintInfo: r, baseAmount: s, quoteAmount: a, startTime: c, ownerInfo: u, associatedOnly: l = false, checkCreateATAOwner: m = false, tokenProgram: d, txVersion: p, feeDestinationId: f, computeBudgetConfig: y, txTipConfig: b, feePayer: g }) {
        var v;
        let A = u.feePayer || ((v = this.scope.owner) == null ? void 0 : v.publicKey), k = u.useSOLBalance && o.mint.equals(Xt.NATIVE_MINT), I = u.useSOLBalance && r.mint.equals(Xt.NATIVE_MINT), T = this.createTxBuilder(g), { account: h, instructionParams: S } = await this.scope.account.getOrCreateTokenAccount({ mint: o.mint, owner: this.scope.ownerPubKey, createInfo: k ? { payer: A, amount: s } : void 0, notUseTokenAccount: k, skipCloseAccount: !k, associatedOnly: k ? false : l, checkCreateATAOwner: m });
        T.addInstruction(S || {});
        let { account: x, instructionParams: K } = await this.scope.account.getOrCreateTokenAccount({ mint: r.mint, owner: this.scope.ownerPubKey, createInfo: I ? { payer: A, amount: a } : void 0, notUseTokenAccount: I, skipCloseAccount: !I, associatedOnly: I ? false : l, checkCreateATAOwner: m });
        if (T.addInstruction(K || {}), h === void 0 || x === void 0)
          throw Error("you don't has some token account");
        let B = Oa({ version: 4, marketVersion: 3, marketId: n.marketId, baseMint: o.mint, quoteMint: r.mint, baseDecimals: o.decimals, quoteDecimals: r.decimals, programId: t, marketProgramId: n.programId }), C = { programId: t, ammId: B.id, ammAuthority: B.authority, ammOpenOrders: B.openOrders, lpMint: B.lpMint, coinMint: B.baseMint, pcMint: B.quoteMint, coinVault: B.baseVault, pcVault: B.quoteVault, withdrawQueue: B.withdrawQueue, ammTargetOrders: B.targetOrders, poolTempLp: B.lpVault, marketProgramId: B.marketProgramId, marketId: B.marketId, ammConfigId: B.configId, feeDestinationId: f }, { instruction: R, instructionType: N } = La(U(E({}, C), { userWallet: this.scope.ownerPubKey, userCoinVault: h, userPcVault: x, userLpVault: te(this.scope.ownerPubKey, B.lpMint, d).publicKey, nonce: B.nonce, openTime: c, coinAmount: s, pcAmount: a }));
        return T.addInstruction({ instructions: [R], instructionTypes: [N] }), T.addCustomComputeBudget(y), T.addTipInstruction(b), T.versionBuild({ txVersion: p, extInfo: { address: C } });
      }
      async createMarketAndPoolV4({ programId: t = si, marketProgram: n = Ss, feeDestinationId: o = Ks, tokenProgram: r, baseMintInfo: s, quoteMintInfo: a, baseAmount: c, quoteAmount: u, startTime: l, ownerInfo: m, lowestFeeMarket: d, assignSeed: p, associatedOnly: f = false, checkCreateATAOwner: y = false, lotSize: b = 1, tickSize: g = 0.01, txVersion: A, computeBudgetConfig: k, txTipConfig: I, feePayer: T }) {
        var bn, ts, ns;
        let h = this.scope.ownerPubKey, S = m.feePayer || ((bn = this.scope.owner) == null ? void 0 : bn.publicKey), x = m.useSOLBalance && s.mint.equals(Xt.NATIVE_MINT), K = m.useSOLBalance && a.mint.equals(Xt.NATIVE_MINT), B = p ? `${s.mint.toBase58().slice(0, 7)}-${a.mint.toBase58().slice(0, 7)}-${p}` : void 0, C = rt({ fromPublicKey: h, programId: n, assignSeed: B && `${B}-market` }), R = rt({ fromPublicKey: h, programId: n, assignSeed: B && `${B}-request` }), N = rt({ fromPublicKey: h, programId: n, assignSeed: B && `${B}-event` }), v = rt({ fromPublicKey: h, programId: n, assignSeed: B && `${B}-bids` }), L = rt({ fromPublicKey: h, programId: n, assignSeed: B && `${B}-asks` }), M = rt({ fromPublicKey: h, programId: Xt.TOKEN_PROGRAM_ID, assignSeed: B && `${B}-baseVault` }), Y = rt({ fromPublicKey: h, programId: Xt.TOKEN_PROGRAM_ID, assignSeed: B && `${B}-quoteVault` }), j = 0, le = new nt.default(100);
        function be() {
          let tn = new nt.default(0);
          for (; ; )
            try {
              return { vaultOwner: lt.PublicKey.createProgramAddressSync([C.publicKey.toBuffer(), tn.toArrayLike(Buffer, "le", 8)], n), vaultSignerNonce: tn };
            } catch {
              if (tn.iaddn(1), tn.gt(new nt.default(25555)))
                throw Error("find vault owner error");
            }
        }
        let { vaultOwner: me, vaultSignerNonce: Ie } = be(), he = new nt.default(Math.round(10 ** s.decimals * b)), ue = new nt.default(Math.round(b * 10 ** a.decimals * g));
        if (he.eq(ut))
          throw Error("lot size is too small");
        if (ue.eq(ut))
          throw Error("tick size or lot size is too small");
        let ie = await Nr({ connection: this.scope.connection, wallet: this.scope.ownerPubKey, marketInfo: { programId: n, vaultOwner: me, baseMint: s.mint, quoteMint: a.mint, id: C, baseVault: M, quoteVault: Y, requestQueue: R, eventQueue: N, bids: v, asks: L, feeRateBps: j, quoteDustThreshold: le, vaultSignerNonce: Ie, baseLotSize: he, quoteLotSize: ue, lowestFeeMarket: d } }), We = this.createTxBuilder(T);
        We.addInstruction({ instructions: ie[0].transaction.instructions, signers: ie[0].signer });
        for await (let tn of ie.slice(1, ie.length))
          We.addInstruction({ instructions: tn.transaction.instructions, signers: tn.signer, instructionTypes: tn.instructionTypes });
        let { account: He, instructionParams: Se } = await this.scope.account.getOrCreateTokenAccount({ mint: s.mint, owner: this.scope.ownerPubKey, createInfo: x ? { payer: S, amount: c } : void 0, notUseTokenAccount: x, skipCloseAccount: !x, associatedOnly: x ? false : f, checkCreateATAOwner: y, assignSeed: x && B ? `${B}-wsol` : void 0 });
        We.addInstruction(Se || {});
        let { account: Vt, instructionParams: un } = await this.scope.account.getOrCreateTokenAccount({ mint: a.mint, owner: this.scope.ownerPubKey, createInfo: K ? { payer: S, amount: u } : void 0, notUseTokenAccount: K, skipCloseAccount: !K, associatedOnly: K ? false : f, checkCreateATAOwner: y, assignSeed: K && B ? `${B}-wsol` : void 0 });
        if (We.addInstruction(un || {}), He === void 0)
          throw Error("you don't has base token account");
        if (Vt === void 0)
          throw Error("you don't has quote token account");
        let bt = Oa({ version: 4, marketVersion: 3, marketId: C.publicKey, baseMint: s.mint, quoteMint: a.mint, baseDecimals: s.decimals, quoteDecimals: a.decimals, programId: t, marketProgramId: n }), Zo = { programId: t, ammId: bt.id, ammAuthority: bt.authority, ammOpenOrders: bt.openOrders, lpMint: bt.lpMint, coinMint: bt.baseMint, pcMint: bt.quoteMint, coinVault: bt.baseVault, pcVault: bt.quoteVault, withdrawQueue: bt.withdrawQueue, ammTargetOrders: bt.targetOrders, poolTempLp: bt.lpVault, marketProgramId: bt.marketProgramId, marketId: bt.marketId, ammConfigId: bt.configId, feeDestinationId: o }, { instruction: Bl, instructionType: es } = La(U(E({}, Zo), { userWallet: this.scope.ownerPubKey, userCoinVault: He, userPcVault: Vt, userLpVault: te(this.scope.ownerPubKey, bt.lpMint, r).publicKey, nonce: bt.nonce, openTime: l, coinAmount: c, pcAmount: u }));
        We.addInstruction({ instructions: [Bl], instructionTypes: [es] });
        let Lo = x || K ? [((ts = Se == null ? void 0 : Se.instructions) == null ? void 0 : ts[0]) || ((ns = un == null ? void 0 : un.instructions) == null ? void 0 : ns[0])].filter((tn) => !!tn) : void 0;
        return A === 0 ? We.sizeCheckBuildV0({ computeBudgetConfig: k, splitIns: Lo, address: E({ requestQueue: R.publicKey, eventQueue: N.publicKey, bids: v.publicKey, asks: L.publicKey, baseVault: M.publicKey, quoteVault: Y.publicKey, baseMint: new lt.PublicKey(s.mint), quoteMint: new lt.PublicKey(a.mint) }, Zo) }) : We.sizeCheckBuild({ computeBudgetConfig: k, splitIns: Lo, address: E({ requestQueue: R.publicKey, eventQueue: N.publicKey, bids: v.publicKey, asks: L.publicKey, baseVault: M.publicKey, quoteVault: Y.publicKey, baseMint: new lt.PublicKey(s.mint), quoteMint: new lt.PublicKey(a.mint) }, Zo) });
      }
      async getCreatePoolFee({ programId: t }) {
        let n = Rr({ programId: t }), o = await this.scope.connection.getAccountInfo(n, { dataSlice: { offset: 536, length: 8 } });
        if (o === null)
          throw Error("get config account error");
        return Ec.decode(o.data).fee;
      }
      computeAmountOut({ poolInfo: t, amountIn: n, mintIn: o, mintOut: r, slippage: s }) {
        let [a, c] = [o.toString(), r.toString()];
        if (a !== t.mintA.address && a !== t.mintB.address)
          throw new Error("toke not match");
        if (c !== t.mintA.address && c !== t.mintB.address)
          throw new Error("toke not match");
        let { baseReserve: u, quoteReserve: l } = t, m = [u, l], d = [t.mintA.decimals, t.mintB.decimals], p = a == t.mintA.address ? "base" : "quote";
        p === "quote" && (m.reverse(), d.reverse());
        let [f, y] = m, [b, g] = d, A = t.version === 4, k;
        if (A)
          k = new O(y.toString()).div(10 ** g).div(new O(f.toString()).div(10 ** b));
        else {
          let N = Xc(this.stableLayout.stableModelData, u.toNumber(), l.toNumber(), false);
          p === "quote" ? k = new O(1e6).div(N * 1e6) : k = new O(N * 1e6).div(1e6);
        }
        let I = n, T = new nt.default(0), h = new nt.default(0);
        if (!I.isZero())
          if (A) {
            h = An(I.mul(Ta), xr);
            let N = I.sub(h), v = f.add(N);
            T = y.mul(N).div(v);
          } else {
            h = I.mul(new nt.default(2)).div(new nt.default(1e4));
            let N = I.sub(h);
            p === "quote" ? T = new nt.default(Uc(this.stableLayout.stableModelData, l.toNumber(), u.toNumber(), N.toNumber())) : T = new nt.default(Gc(this.stableLayout.stableModelData, l.toNumber(), u.toNumber(), N.toNumber()));
          }
        let S = new nt.default(new O(T.toString()).mul(1 - s).toFixed(0)), x = T, K = S, B = new O(T.toString()).div(new O(I.sub(h).toString()).toFixed(0));
        !I.isZero() && !T.isZero() && (B = new O(T.toString()).div(10 ** g).div(new O(I.sub(h).toString()).div(10 ** b)));
        let C = k.sub(B).div(k).mul(100);
        return { amountOut: x, minAmountOut: K, currentPrice: k, executionPrice: B, priceImpact: C, fee: h };
      }
      computeAmountIn({ poolInfo: t, amountOut: n, mintIn: o, mintOut: r, slippage: s }) {
        let { baseReserve: a, quoteReserve: c } = t;
        o.toString() !== t.mintA.address && o.toString() !== t.mintB.address && this.logAndCreateError("mintIn does not match pool"), r.toString() !== t.mintA.address && r.toString() !== t.mintB.address && this.logAndCreateError("mintOut does not match pool"), this.logDebug("baseReserve:", a.toString()), this.logDebug("quoteReserve:", c.toString());
        let u = o.toString() === t.mintA.address, [l, m] = u ? [t.mintA, t.mintB] : [t.mintB, t.mintA];
        this.logDebug("currencyOut:", m.symbol || m.address), this.logDebug("amountOut:", new O(n.toString()).div(10 ** m.decimals).toDecimalPlaces(m.decimals).toString(), l.symbol || l.address), this.logDebug("slippage:", `${s * 100}%`);
        let d = [a, c], p = u ? "quote" : "base";
        p === "base" && d.reverse(), this.logDebug("output side:", p);
        let [f, y] = d, b = new O(y.toString()).div(10 ** t[u ? "mintB" : "mintA"].decimals).div(new O(f.toString()).div(10 ** t[u ? "mintA" : "mintB"].decimals));
        this.logDebug("currentPrice:", `1 ${l.symbol || l.address} \u2248 ${b.toString()} ${m.symbol || m.address}`), this.logDebug("currentPrice invert:", `1 ${m.symbol || m.address} \u2248 ${new O(1).div(b).toString()} ${l.symbol || l.address}`);
        let g = new nt.default(0), A = n;
        if (!A.isZero()) {
          A.gt(y) && (A = y.sub(new nt.default(1)));
          let K = y.sub(A);
          g = f.mul(A).div(K).mul(xr).div(xr.sub(Ta));
        }
        let k = new nt.default(new O(g.toString()).mul(1 + s).toFixed(0)), I = g, T = k;
        this.logDebug("amountIn:", new O(I.toString()).div(10 ** l.decimals).toDecimalPlaces(l.decimals).toString()), this.logDebug("maxAmountIn:", new O(T.toString()).div(10 ** l.decimals).toDecimalPlaces(l.decimals).toString());
        let h = null;
        !g.isZero() && !A.isZero() && (h = new O(A.toString()).div(10 ** m.decimals).div(new O(g.toString()).div(10 ** l.decimals)), this.logDebug("executionPrice:", `1 ${m.symbol || m.address} \u2248 ${h.toDecimalPlaces(Math.max(t.mintA.decimals, t.mintB.decimals)).toString()} ${l.symbol || l.address}`), this.logDebug("executionPrice invert:", `1 ${m.symbol || m.address} \u2248 ${new O(1).div(h).toDecimalPlaces(Math.max(t.mintA.decimals, t.mintB.decimals)).toString()} ${l.symbol || l.address}`));
        let S = b.mul(I.toString()), x = S.sub(n.toString()).abs().div(S);
        return this.logDebug("priceImpact:", `${x.toString()}%`), { amountIn: I, maxAmountIn: T, currentPrice: b, executionPrice: h, priceImpact: x };
      }
      async swap({ poolInfo: t, poolKeys: n, amountIn: o, amountOut: r, inputMint: s, fixedSide: a, txVersion: c, config: u, computeBudgetConfig: l, txTipConfig: m, feePayer: d }) {
        let p = this.createTxBuilder(d), { associatedOnly: f = true, inputUseSolBalance: y = true, outputUseSolBalance: b = true } = u || {}, [g, A] = s === t.mintA.address ? [t.mintA, t.mintB] : [t.mintB, t.mintA], k = y && g.address === ee.toBase58(), I = b && A.address === ee.toBase58(), { account: T, instructionParams: h } = await this.scope.account.getOrCreateTokenAccount({ tokenProgram: Xt.TOKEN_PROGRAM_ID, mint: new lt.PublicKey(g.address), owner: this.scope.ownerPubKey, createInfo: k ? { payer: this.scope.ownerPubKey, amount: o } : void 0, skipCloseAccount: !k, notUseTokenAccount: k, associatedOnly: f });
        p.addInstruction(h || {}), T || this.logAndCreateError("input token account not found", { token: g.symbol || g.address, tokenAccountIn: T, inputTokenUseSolBalance: k, associatedOnly: f });
        let { account: S, instructionParams: x } = await this.scope.account.getOrCreateTokenAccount({ tokenProgram: Xt.TOKEN_PROGRAM_ID, mint: new lt.PublicKey(A.address), owner: this.scope.ownerPubKey, createInfo: { payer: this.scope.ownerPubKey, amount: 0 }, skipCloseAccount: !I, notUseTokenAccount: I, associatedOnly: I ? false : f });
        p.addInstruction(x || {}), S === void 0 && this.logAndCreateError("output token account not found", { token: A.symbol || A.address, tokenAccountOut: S, outputTokenUseSolBalance: I, associatedOnly: f });
        let K = n || await this.getAmmPoolKeys(t.id), B = 4;
        return t.pooltype.includes("StablePool") && (B = 5), p.addInstruction({ instructions: [B === 4 ? Kr({ version: B, poolKeys: K, userKeys: { tokenAccountIn: T, tokenAccountOut: S, owner: this.scope.ownerPubKey }, amountIn: o, amountOut: r, fixedSide: a }) : Cr({ version: B, poolKeys: K, userKeys: { tokenAccountIn: T, tokenAccountOut: S, owner: this.scope.ownerPubKey }, amountIn: o, amountOut: r, fixedSide: a })], instructionTypes: [B === 4 ? X.AmmV4SwapBaseIn : X.AmmV5SwapBaseIn] }), p.addCustomComputeBudget(l), p.addTipInstruction(m), p.versionBuild({ txVersion: c });
      }
      async getRpcPoolInfo(t) {
        return (await this.getRpcPoolInfos([t]))[t];
      }
      async getRpcPoolInfos(t, n) {
        let o = await ze(this.scope.connection, t.map((l) => ({ pubkey: new lt.PublicKey(l) })), n), r = {}, s = [];
        for (let l = 0; l < t.length; l++) {
          let m = o[l];
          if (m === null || !m.accountInfo)
            throw Error("fetch pool info error: " + String(t[l]));
          let d = So.decode(m.accountInfo.data);
          r[String(t[l])] = U(E({}, d), { programId: m.accountInfo.owner }), s.push(d.baseVault, d.quoteVault);
        }
        let a = {}, c = await ze(this.scope.connection, s.map((l) => ({ pubkey: new lt.PublicKey(l) })), n);
        for (let l = 0; l < s.length; l++) {
          let m = c[l].accountInfo;
          if (m === null)
            throw Error("fetch vault info error: " + s[l]);
          a[String(s[l])] = new nt.default(Xt.AccountLayout.decode(m.data).amount.toString());
        }
        let u = {};
        for (let [l, m] of Object.entries(r)) {
          let d = a[m.baseVault.toString()].sub(m.baseNeedTakePnl), p = a[m.quoteVault.toString()].sub(m.quoteNeedTakePnl);
          u[l] = U(E({}, m), { baseReserve: d, mintAAmount: a[m.baseVault.toString()], mintBAmount: a[m.quoteVault.toString()], quoteReserve: p, poolPrice: new O(p.toString()).div(new O(10).pow(m.quoteDecimal.toString())).div(new O(d.toString()).div(new O(10).pow(m.baseDecimal.toString()))) });
        }
        return u;
      }
      async getPoolInfoFromRpc({ poolId: t }) {
        let n = await this.getRpcPoolInfo(t), o = Lr({ [t]: n }), r = o[t], s = await this.scope.tradeV2.computePoolToPoolKeys({ pools: [o[t]], ammRpcData: { [t]: n } });
        return { poolRpcData: n, poolInfo: r, poolKeys: s[0] };
      }
    };
    var $ = require("@solana/web3.js");
    var zt = Ae(require_bn());
    var ft = require_cjs4();
    var vi = class extends Je {
      constructor(e) {
        super(e);
      }
      async getClmmPoolKeys(e) {
        return (await this.scope.api.fetchPoolKeysById({ idList: [e] }))[0];
      }
      async createPool(e) {
        var S;
        let { programId: t, owner: n = ((S = this.scope.owner) == null ? void 0 : S.publicKey) || $.PublicKey.default, mint1: o, mint2: r, ammConfig: s, initialPrice: a, computeBudgetConfig: c, forerunCreate: u, getObserveState: l, txVersion: m, txTipConfig: d, feePayer: p } = e, f = this.createTxBuilder(p), [y, b, g] = new zt.default(new $.PublicKey(o.address).toBuffer()).gt(new zt.default(new $.PublicKey(r.address).toBuffer())) ? [r, o, new O(1).div(a)] : [o, r, a], A = fe.priceToSqrtPriceX64(g, y.decimals, b.decimals), k = [], I = [];
        y.programId === ft.TOKEN_2022_PROGRAM_ID.toBase58() && I.push(wa(t, new $.PublicKey(y.address)).publicKey), b.programId === ft.TOKEN_2022_PROGRAM_ID.toBase58() && I.push(wa(t, new $.PublicKey(b.address)).publicKey), (await this.scope.connection.getMultipleAccountsInfo(I)).forEach((x, K) => {
          x && k.push(I[K]);
        });
        let h = await Oe.createPoolInstructions({ connection: this.scope.connection, programId: t, owner: n, mintA: y, mintB: b, ammConfigId: s.id, initialPriceX64: A, forerunCreate: !l && u, extendMintAccount: k });
        return f.addInstruction(h), f.addCustomComputeBudget(c), f.addTipInstruction(d), f.versionBuild({ txVersion: m, extInfo: { address: U(E({}, h.address), { observationId: h.address.observationId.toBase58(), exBitmapAccount: h.address.exBitmapAccount.toBase58(), programId: t.toString(), id: h.address.poolId.toString(), mintA: y, mintB: b, openTime: "0", vault: { A: h.address.mintAVault.toString(), B: h.address.mintBVault.toString() }, rewardInfos: [], config: { id: s.id.toString(), index: s.index, protocolFeeRate: s.protocolFeeRate, tradeFeeRate: s.tradeFeeRate, tickSpacing: s.tickSpacing, fundFeeRate: s.fundFeeRate, description: s.description, defaultRange: 0, defaultRangePoint: [] } }), mockPoolInfo: E({ type: "Concentrated", rewardDefaultPoolInfos: "Clmm", id: h.address.poolId.toString(), mintA: y, mintB: b, feeRate: s.tradeFeeRate, openTime: "0", programId: t.toString(), price: g.toNumber(), config: { id: s.id.toString(), index: s.index, protocolFeeRate: s.protocolFeeRate, tradeFeeRate: s.tradeFeeRate, tickSpacing: s.tickSpacing, fundFeeRate: s.fundFeeRate, description: s.description, defaultRange: 0, defaultRangePoint: [] }, burnPercent: 0 }, wc), forerunCreate: u } });
      }
      async openPositionFromBase({ poolInfo: e, poolKeys: t, ownerInfo: n, tickLower: o, tickUpper: r, base: s, baseAmount: a, otherAmountMax: c, nft2022: u, associatedOnly: l = true, checkCreateATAOwner: m = false, withMetadata: d = "create", getEphemeralSigners: p, computeBudgetConfig: f, txTipConfig: y, txVersion: b, feePayer: g }) {
        this.scope.availability.addConcentratedPosition === false && this.logAndCreateError("add position feature disabled in your region"), this.scope.checkOwner();
        let A = this.createTxBuilder(g), k = null, I = null, T = n.useSOLBalance && e.mintA.address === ee.toString(), h = n.useSOLBalance && e.mintB.address === ee.toString(), [S, x] = s === "MintA" ? [a, c] : [c, a], { account: K, instructionParams: B } = await this.scope.account.getOrCreateTokenAccount({ tokenProgram: e.mintA.programId, mint: new $.PublicKey(e.mintA.address), owner: this.scope.ownerPubKey, createInfo: T || S.isZero() ? { payer: this.scope.ownerPubKey, amount: S } : void 0, skipCloseAccount: !T, notUseTokenAccount: T, associatedOnly: T ? false : l, checkCreateATAOwner: m });
        K && (k = K), A.addInstruction(B || {});
        let { account: C, instructionParams: R } = await this.scope.account.getOrCreateTokenAccount({ tokenProgram: e.mintB.programId, mint: new $.PublicKey(e.mintB.address), owner: this.scope.ownerPubKey, createInfo: h || x.isZero() ? { payer: this.scope.ownerPubKey, amount: x } : void 0, skipCloseAccount: !h, notUseTokenAccount: h, associatedOnly: h ? false : l, checkCreateATAOwner: m });
        C && (I = C), A.addInstruction(R || {}), (!k || !I) && this.logAndCreateError("cannot found target token accounts", "tokenAccounts", { ownerTokenAccountA: k == null ? void 0 : k.toBase58(), ownerTokenAccountB: I == null ? void 0 : I.toBase58() });
        let N = t || await this.getClmmPoolKeys(e.id), v = await Oe.openPositionFromBaseInstructions({ poolInfo: e, poolKeys: N, ownerInfo: U(E({}, n), { feePayer: this.scope.ownerPubKey, wallet: this.scope.ownerPubKey, tokenAccountA: k, tokenAccountB: I }), tickLower: o, tickUpper: r, base: s, baseAmount: a, otherAmountMax: c, withMetadata: d, getEphemeralSigners: p, nft2022: u });
        return A.addInstruction(v), A.addCustomComputeBudget(f), A.addTipInstruction(y), A.versionBuild({ txVersion: b, extInfo: E({}, v.address) });
      }
      async openPositionFromLiquidity({ poolInfo: e, poolKeys: t, ownerInfo: n, amountMaxA: o, amountMaxB: r, tickLower: s, tickUpper: a, liquidity: c, associatedOnly: u = true, checkCreateATAOwner: l = false, withMetadata: m = "create", txVersion: d, computeBudgetConfig: p, txTipConfig: f, getEphemeralSigners: y, nft2022: b, feePayer: g }) {
        this.scope.availability.createConcentratedPosition === false && this.logAndCreateError("open position feature disabled in your region");
        let A = this.createTxBuilder(g), k = null, I = null, T = n.useSOLBalance && e.mintA.address === ee.toBase58(), h = n.useSOLBalance && e.mintB.address === ee.toBase58(), { account: S, instructionParams: x } = await this.scope.account.getOrCreateTokenAccount({ tokenProgram: e.mintA.programId, mint: new $.PublicKey(e.mintA.address), owner: this.scope.ownerPubKey, createInfo: T || o.isZero() ? { payer: this.scope.ownerPubKey, amount: o } : void 0, skipCloseAccount: !T, notUseTokenAccount: T, associatedOnly: T ? false : u, checkCreateATAOwner: l });
        S && (k = S), A.addInstruction(x || {});
        let { account: K, instructionParams: B } = await this.scope.account.getOrCreateTokenAccount({ tokenProgram: e.mintB.programId, mint: new $.PublicKey(e.mintB.address), owner: this.scope.ownerPubKey, createInfo: h || r.isZero() ? { payer: this.scope.ownerPubKey, amount: r } : void 0, skipCloseAccount: !h, notUseTokenAccount: h, associatedOnly: h ? false : u, checkCreateATAOwner: l });
        K && (I = K), A.addInstruction(B || {}), (k === void 0 || I === void 0) && this.logAndCreateError("cannot found target token accounts", "tokenAccounts", this.scope.account.tokenAccounts);
        let C = t || await this.getClmmPoolKeys(e.id), R = await Oe.openPositionFromLiquidityInstructions({ poolInfo: e, poolKeys: C, ownerInfo: { wallet: this.scope.ownerPubKey, tokenAccountA: k, tokenAccountB: I }, tickLower: s, tickUpper: a, liquidity: c, amountMaxA: o, amountMaxB: r, withMetadata: m, getEphemeralSigners: y, nft2022: b });
        return A.addInstruction(R), A.addCustomComputeBudget(p), A.addTipInstruction(f), A.versionBuild({ txVersion: d, extInfo: { address: R.address } });
      }
      async increasePositionFromLiquidity(e) {
        var B;
        let { poolInfo: t, poolKeys: n, ownerPosition: o, amountMaxA: r, amountMaxB: s, liquidity: a, ownerInfo: c, associatedOnly: u = true, checkCreateATAOwner: l = false, computeBudgetConfig: m, txTipConfig: d, txVersion: p, feePayer: f } = e, y = this.createTxBuilder(f), b, g, A = c.useSOLBalance && t.mintA.address === ee.toString(), k = c.useSOLBalance && t.mintB.address === ee.toString(), { account: I, instructionParams: T } = await this.scope.account.getOrCreateTokenAccount({ tokenProgram: t.mintA.programId, mint: new $.PublicKey(t.mintA.address), notUseTokenAccount: A, owner: this.scope.ownerPubKey, createInfo: A || r.isZero() ? { payer: this.scope.ownerPubKey, amount: r } : void 0, skipCloseAccount: !A, associatedOnly: A ? false : u, checkCreateATAOwner: l });
        I && (b = I), y.addInstruction(T || {});
        let { account: h, instructionParams: S } = await this.scope.account.getOrCreateTokenAccount({ tokenProgram: t.mintB.programId, mint: new $.PublicKey(t.mintB.address), owner: this.scope.ownerPubKey, createInfo: k || s.isZero() ? { payer: this.scope.ownerPubKey, amount: s } : void 0, notUseTokenAccount: k, skipCloseAccount: !k, associatedOnly: k ? false : u, checkCreateATAOwner: l });
        h && (g = h), y.addInstruction(S || {}), !b && !g && this.logAndCreateError("cannot found target token accounts", "tokenAccounts", this.scope.account.tokenAccounts);
        let x = n != null ? n : await this.getClmmPoolKeys(t.id), K = Oe.increasePositionFromLiquidityInstructions({ poolInfo: t, poolKeys: x, ownerPosition: o, ownerInfo: { wallet: this.scope.ownerPubKey, tokenAccountA: b, tokenAccountB: g }, liquidity: a, amountMaxA: r, amountMaxB: s, nft2022: (B = await this.scope.connection.getAccountInfo(o.nftMint)) == null ? void 0 : B.owner.equals(ft.TOKEN_2022_PROGRAM_ID) });
        return y.addInstruction(K), y.addCustomComputeBudget(m), y.addTipInstruction(d), y.versionBuild({ txVersion: p, extInfo: { address: K.address } });
      }
      async increasePositionFromBase(e) {
        var K;
        let { poolInfo: t, ownerPosition: n, base: o, baseAmount: r, otherAmountMax: s, ownerInfo: a, associatedOnly: c = true, checkCreateATAOwner: u = false, computeBudgetConfig: l, txTipConfig: m, txVersion: d, feePayer: p } = e, f = this.createTxBuilder(p), y, b, g = a.useSOLBalance && t.mintA.address === ee.toString(), A = a.useSOLBalance && t.mintB.address === ee.toString(), { account: k, instructionParams: I } = await this.scope.account.getOrCreateTokenAccount({ tokenProgram: t.mintA.programId, mint: new $.PublicKey(t.mintA.address), notUseTokenAccount: g, owner: this.scope.ownerPubKey, createInfo: g || (o === "MintA" ? r : s).isZero() ? { payer: this.scope.ownerPubKey, amount: o === "MintA" ? r : s } : void 0, skipCloseAccount: !g, associatedOnly: g ? false : c, checkCreateATAOwner: u });
        k && (y = k), f.addInstruction(I || {});
        let { account: T, instructionParams: h } = await this.scope.account.getOrCreateTokenAccount({ tokenProgram: t.mintB.programId, mint: new $.PublicKey(t.mintB.address), owner: this.scope.ownerPubKey, createInfo: A || (o === "MintA" ? s : r).isZero() ? { payer: this.scope.ownerPubKey, amount: o === "MintA" ? s : r } : void 0, notUseTokenAccount: A, skipCloseAccount: !A, associatedOnly: A ? false : c, checkCreateATAOwner: u });
        T && (b = T), f.addInstruction(h || {}), !y && !b && this.logAndCreateError("cannot found target token accounts", "tokenAccounts", this.scope.account.tokenAccounts);
        let S = await this.getClmmPoolKeys(t.id), x = Oe.increasePositionFromBaseInstructions({ poolInfo: t, poolKeys: S, ownerPosition: n, ownerInfo: { wallet: this.scope.ownerPubKey, tokenAccountA: y, tokenAccountB: b }, base: o, baseAmount: r, otherAmountMax: s, nft2022: (K = await this.scope.connection.getAccountInfo(n.nftMint)) == null ? void 0 : K.owner.equals(ft.TOKEN_2022_PROGRAM_ID) });
        return f.addInstruction(x), f.addCustomComputeBudget(l), f.addTipInstruction(m), f.versionBuild({ txVersion: d, extInfo: { address: x.address } });
      }
      async decreaseLiquidity(e) {
        var N;
        let { poolInfo: t, poolKeys: n, ownerPosition: o, ownerInfo: r, amountMinA: s, amountMinB: a, liquidity: c, associatedOnly: u = true, checkCreateATAOwner: l = false, computeBudgetConfig: m, txTipConfig: d, txVersion: p, feePayer: f } = e;
        this.scope.availability.removeConcentratedPosition === false && this.logAndCreateError("remove position feature disabled in your region");
        let y = this.createTxBuilder(f), b = r.useSOLBalance && t.mintA.address === ee.toString(), g = r.useSOLBalance && t.mintB.address === ee.toString(), A, k, { account: I, instructionParams: T } = await this.scope.account.getOrCreateTokenAccount({ tokenProgram: t.mintA.programId, mint: new $.PublicKey(t.mintA.address), notUseTokenAccount: b, owner: this.scope.ownerPubKey, createInfo: { payer: this.scope.ownerPubKey, amount: 0 }, skipCloseAccount: !b, associatedOnly: b ? false : u, checkCreateATAOwner: l });
        A = I, T && y.addInstruction(T);
        let { account: h, instructionParams: S } = await this.scope.account.getOrCreateTokenAccount({ tokenProgram: t.mintB.programId, mint: new $.PublicKey(t.mintB.address), notUseTokenAccount: g, owner: this.scope.ownerPubKey, createInfo: { payer: this.scope.ownerPubKey, amount: 0 }, skipCloseAccount: !g, associatedOnly: g ? false : u, checkCreateATAOwner: l });
        k = h, S && y.addInstruction(S);
        let x = [];
        for (let v of t.rewardDefaultInfos) {
          let L = r.useSOLBalance && v.mint.address === ee.toString(), M;
          if (v.mint.address === t.mintA.address)
            M = A;
          else if (v.mint.address === t.mintB.address)
            M = k;
          else {
            let { account: Y, instructionParams: j } = await this.scope.account.getOrCreateTokenAccount({ tokenProgram: new $.PublicKey(v.mint.programId), mint: new $.PublicKey(v.mint.address), notUseTokenAccount: L, owner: this.scope.ownerPubKey, createInfo: { payer: this.scope.ownerPubKey, amount: 0 }, skipCloseAccount: !L, associatedOnly: L ? false : u, checkCreateATAOwner: l });
            M = Y, j && y.addInstruction(j);
          }
          x.push(M);
        }
        !A && !k && this.logAndCreateError("cannot found target token accounts", "tokenAccounts", this.scope.account.tokenAccountRawInfos);
        let K = n != null ? n : await this.getClmmPoolKeys(t.id), B = (N = await this.scope.connection.getAccountInfo(o.nftMint)) == null ? void 0 : N.owner.equals(ft.TOKEN_2022_PROGRAM_ID), C = await Oe.decreaseLiquidityInstructions({ poolInfo: t, poolKeys: K, ownerPosition: o, ownerInfo: { wallet: this.scope.ownerPubKey, tokenAccountA: A, tokenAccountB: k, rewardAccounts: x }, liquidity: c, amountMinA: s, amountMinB: a, nft2022: B });
        y.addInstruction({ instructions: C.instructions, instructionTypes: [X.ClmmDecreasePosition] });
        let R = E({}, C.address);
        if (r.closePosition) {
          let v = await Oe.closePositionInstructions({ poolInfo: t, poolKeys: K, ownerInfo: { wallet: this.scope.ownerPubKey }, ownerPosition: o, nft2022: B });
          y.addInstruction({ endInstructions: v.instructions, endInstructionTypes: v.instructionTypes }), R = E(E({}, R), v.address);
        }
        return y.addCustomComputeBudget(m), y.addTipInstruction(d), y.versionBuild({ txVersion: p, extInfo: { address: R } });
      }
      async lockPosition(e) {
        var f;
        let { programId: t = Fo, authProgramId: n = ai, poolProgramId: o = $n, ownerPosition: r, payer: s, computeBudgetConfig: a, txTipConfig: c, txVersion: u, getEphemeralSigners: l, feePayer: m } = e, d = this.createTxBuilder(m), p = await Oe.makeLockPositions({ programId: t, authProgramId: n, poolProgramId: o, wallet: this.scope.ownerPubKey, payer: s != null ? s : this.scope.ownerPubKey, nftMint: r.nftMint, getEphemeralSigners: l, nft2022: (f = await this.scope.connection.getAccountInfo(r.nftMint)) == null ? void 0 : f.owner.equals(ft.TOKEN_2022_PROGRAM_ID) });
        return d.addInstruction(p), d.addCustomComputeBudget(a), d.addTipInstruction(c), d.versionBuild({ txVersion: u, extInfo: p.address });
      }
      async harvestLockPosition(e) {
        let { programId: t = Fo, authProgramId: n = ai, clmmProgram: o = $n, poolKeys: r, lockData: s, ownerInfo: a = { useSOLBalance: true }, associatedOnly: c = true, checkCreateATAOwner: u = false, computeBudgetConfig: l, txTipConfig: m, txVersion: d, feePayer: p } = e, f = r || await this.getClmmPoolKeys(s.poolId.toString()), y = this.createTxBuilder(p), b = await this.scope.connection.getAccountInfo(s.positionId);
        b || this.logger.logWithError("position not found", s.positionId);
        let g = Uo.decode(b.data), A = a.useSOLBalance && f.mintA.address === ee.toString(), k = a.useSOLBalance && f.mintB.address === ee.toString(), I, T, { account: h, instructionParams: S } = await this.scope.account.getOrCreateTokenAccount({ tokenProgram: f.mintA.programId, mint: new $.PublicKey(f.mintA.address), notUseTokenAccount: A, owner: this.scope.ownerPubKey, createInfo: { payer: this.scope.ownerPubKey, amount: 0 }, skipCloseAccount: !A, associatedOnly: A ? false : c, checkCreateATAOwner: u });
        I = h, S && y.addInstruction(S);
        let { account: x, instructionParams: K } = await this.scope.account.getOrCreateTokenAccount({ tokenProgram: f.mintB.programId, mint: new $.PublicKey(f.mintB.address), notUseTokenAccount: k, owner: this.scope.ownerPubKey, createInfo: { payer: this.scope.ownerPubKey, amount: 0 }, skipCloseAccount: !k, associatedOnly: k ? false : c, checkCreateATAOwner: u });
        T = x, K && y.addInstruction(K);
        let B = {}, C = [];
        for (let me of f.rewardInfos) {
          let Ie = a.useSOLBalance && me.mint.address === ee.toString(), he = B[me.mint.address];
          if (!he) {
            let { account: ue, instructionParams: ie } = await this.scope.account.getOrCreateTokenAccount({ tokenProgram: new $.PublicKey(me.mint.programId), mint: new $.PublicKey(me.mint.address), notUseTokenAccount: Ie, owner: this.scope.ownerPubKey, skipCloseAccount: !Ie, createInfo: { payer: this.scope.ownerPubKey, amount: 0 }, associatedOnly: Ie ? false : c });
            he = ue, ie && y.addInstruction(ie);
          }
          B[me.mint.address] = he, C.push(he);
        }
        let R = qo(t, s.lockNftMint).publicKey, N = te(this.scope.ownerPubKey, s.lockNftMint, ft.TOKEN_PROGRAM_ID).publicKey, v = ne.getTickArrayStartIndexByTick(g.tickLower, f.config.tickSpacing), L = ne.getTickArrayStartIndexByTick(g.tickUpper, f.config.tickSpacing), { publicKey: M } = Ce(new $.PublicKey(f.programId), s.poolId, v), { publicKey: Y } = Ce(new $.PublicKey(f.programId), s.poolId, L), { publicKey: j } = hn(new $.PublicKey(f.programId), s.poolId, g.tickLower, g.tickUpper), le = [];
        for (let me = 0; me < f.rewardInfos.length; me++)
          le.push({ poolRewardVault: new $.PublicKey(f.rewardInfos[me].vault), ownerRewardVault: C[me], rewardMint: new $.PublicKey(f.rewardInfos[me].mint.address) });
        let be = await Oe.harvestLockPositionInstructionV2({ programId: t, auth: n, lockPositionId: R, clmmProgram: o, lockOwner: this.scope.ownerPubKey, lockNftMint: s.lockNftMint, lockNftAccount: N, positionNftAccount: s.nftAccount, positionId: s.positionId, poolId: s.poolId, protocolPosition: j, vaultA: new $.PublicKey(f.vault.A), vaultB: new $.PublicKey(f.vault.B), tickArrayLower: M, tickArrayUpper: Y, userVaultA: I, userVaultB: T, mintA: new $.PublicKey(f.mintA.address), mintB: new $.PublicKey(f.mintB.address), rewardAccounts: le, exTickArrayBitmap: st(o, s.poolId).publicKey });
        return y.addInstruction({ instructions: [be], instructionTypes: [X.ClmmHarvestLockPosition] }), y.addCustomComputeBudget(l), y.addTipInstruction(m), y.versionBuild({ txVersion: d });
      }
      async closePosition({ poolInfo: e, poolKeys: t, ownerPosition: n, txVersion: o, computeBudgetConfig: r, txTipConfig: s, feePayer: a }) {
        var m;
        this.scope.availability.removeConcentratedPosition === false && this.logAndCreateError("remove position feature disabled in your region");
        let c = this.createTxBuilder(a), u = t != null ? t : await this.getClmmPoolKeys(e.id), l = Oe.closePositionInstructions({ poolInfo: e, poolKeys: u, ownerInfo: { wallet: this.scope.ownerPubKey }, ownerPosition: n, nft2022: (m = await this.scope.connection.getAccountInfo(n.nftMint)) == null ? void 0 : m.owner.equals(ft.TOKEN_2022_PROGRAM_ID) });
        return c.addCustomComputeBudget(r), c.addTipInstruction(s), c.addInstruction(l).versionBuild({ txVersion: o, extInfo: { address: l.address } });
      }
      async initReward({ poolInfo: e, ownerInfo: t, rewardInfo: n, associatedOnly: o = true, checkCreateATAOwner: r = false, computeBudgetConfig: s, txVersion: a, feePayer: c }) {
        n.endTime <= n.openTime && this.logAndCreateError("reward time error", "rewardInfo", n);
        let u = this.createTxBuilder(c), l = t.useSOLBalance && n.mint.address.toString() === ee.toString(), m = n.perSecond.mul(n.endTime - n.openTime), { account: d, instructionParams: p } = await this.scope.account.getOrCreateTokenAccount({ tokenProgram: new $.PublicKey(n.mint.address), mint: new $.PublicKey(n.mint.address), notUseTokenAccount: !!l, skipCloseAccount: !l, owner: this.scope.ownerPubKey, createInfo: l ? { payer: t.feePayer || this.scope.ownerPubKey, amount: new zt.default(new O(m.toFixed(0)).gte(m) ? m.toFixed(0) : m.add(1).toFixed(0)) } : void 0, associatedOnly: l ? false : o, checkCreateATAOwner: r });
        p && u.addInstruction(p), d || this.logAndCreateError("no money", "ownerRewardAccount", this.scope.account.tokenAccountRawInfos);
        let f = await this.getClmmPoolKeys(e.id), y = Oe.initRewardInstructions({ poolInfo: e, poolKeys: f, ownerInfo: { wallet: this.scope.ownerPubKey, tokenAccount: d }, rewardInfo: { programId: new $.PublicKey(n.mint.programId), mint: new $.PublicKey(n.mint.address), openTime: n.openTime, endTime: n.endTime, emissionsPerSecondX64: Pe.decimalToX64(n.perSecond) } });
        return u.addInstruction(y), u.addCustomComputeBudget(s), u.versionBuild({ txVersion: a, extInfo: { address: y.address } });
      }
      async initRewards({ poolInfo: e, poolKeys: t, ownerInfo: n, rewardInfos: o, associatedOnly: r = true, checkCreateATAOwner: s = false, computeBudgetConfig: a, txTipConfig: c, txVersion: u, feePayer: l }) {
        for (let p of o)
          p.endTime <= p.openTime && this.logAndCreateError("reward time error", "rewardInfo", p);
        let m = this.createTxBuilder(l), d = {};
        for (let p of o) {
          let f = n.useSOLBalance && p.mint.address === ee.toString(), y = p.perSecond.mul(p.endTime - p.openTime), { account: b, instructionParams: g } = await this.scope.account.getOrCreateTokenAccount({ tokenProgram: new $.PublicKey(p.mint.programId), mint: new $.PublicKey(p.mint.address), notUseTokenAccount: !!f, skipCloseAccount: !f, owner: this.scope.ownerPubKey, createInfo: f ? { payer: n.feePayer || this.scope.ownerPubKey, amount: new zt.default(new O(y.toFixed(0)).gte(y) ? y.toFixed(0) : y.add(1).toFixed(0)) } : void 0, associatedOnly: f ? false : r, checkCreateATAOwner: s });
          g && m.addInstruction(g), b || this.logAndCreateError("no money", "ownerRewardAccount", this.scope.account.tokenAccountRawInfos);
          let A = t != null ? t : await this.getClmmPoolKeys(e.id), k = Oe.initRewardInstructions({ poolInfo: e, poolKeys: A, ownerInfo: { wallet: this.scope.ownerPubKey, tokenAccount: b }, rewardInfo: { programId: new $.PublicKey(p.mint.programId), mint: new $.PublicKey(p.mint.address), openTime: p.openTime, endTime: p.endTime, emissionsPerSecondX64: Pe.decimalToX64(p.perSecond) } });
          d = E(E({}, d), k.address), m.addInstruction(k);
        }
        return m.addCustomComputeBudget(a), m.addTipInstruction(c), m.versionBuild({ txVersion: u, extInfo: { address: d } });
      }
      async setReward({ poolInfo: e, ownerInfo: t, rewardInfo: n, associatedOnly: o = true, checkCreateATAOwner: r = false, computeBudgetConfig: s, txTipConfig: a, txVersion: c, feePayer: u }) {
        n.endTime <= n.openTime && this.logAndCreateError("reward time error", "rewardInfo", n);
        let l = this.createTxBuilder(u), m = t.useSOLBalance && n.mint.equals(ee), { account: d, instructionParams: p } = await this.scope.account.getOrCreateTokenAccount({ tokenProgram: n.programId, mint: n.mint, notUseTokenAccount: m, owner: this.scope.ownerPubKey, createInfo: m ? { payer: t.feePayer || this.scope.ownerPubKey, amount: new zt.default(new O(n.perSecond.mul(n.endTime - n.openTime).toFixed(0)).gte(n.perSecond.mul(n.endTime - n.openTime)) ? n.perSecond.mul(n.endTime - n.openTime).toFixed(0) : n.perSecond.mul(n.endTime - n.openTime).add(1).toFixed(0)) } : void 0, associatedOnly: m ? false : o, checkCreateATAOwner: r });
        p && l.addInstruction(p), d || this.logAndCreateError("no money", "ownerRewardAccount", this.scope.account.tokenAccountRawInfos);
        let f = await this.getClmmPoolKeys(e.id), y = Oe.setRewardInstructions({ poolInfo: e, poolKeys: f, ownerInfo: { wallet: this.scope.ownerPubKey, tokenAccount: d }, rewardInfo: { mint: n.mint, openTime: n.openTime, endTime: n.endTime, emissionsPerSecondX64: Pe.decimalToX64(n.perSecond) } });
        return l.addInstruction(y), l.addCustomComputeBudget(s), l.addTipInstruction(a), l.versionBuild({ txVersion: c, extInfo: { address: y.address } });
      }
      async setRewards({ poolInfo: e, poolKeys: t, ownerInfo: n, rewardInfos: o, associatedOnly: r = true, checkCreateATAOwner: s = false, computeBudgetConfig: a, txTipConfig: c, txVersion: u, feePayer: l }) {
        let m = this.createTxBuilder(l), d = {};
        for (let p of o) {
          p.endTime <= p.openTime && this.logAndCreateError("reward time error", "rewardInfo", p);
          let f = n.useSOLBalance && p.mint.address === ee.toString(), { account: y, instructionParams: b } = await this.scope.account.getOrCreateTokenAccount({ tokenProgram: new $.PublicKey(p.mint.programId), mint: new $.PublicKey(p.mint.address), notUseTokenAccount: f, owner: this.scope.ownerPubKey, createInfo: f ? { payer: n.feePayer || this.scope.ownerPubKey, amount: new zt.default(new O(p.perSecond.mul(p.endTime - p.openTime).toFixed(0)).gte(p.perSecond.mul(p.endTime - p.openTime)) ? p.perSecond.mul(p.endTime - p.openTime).toFixed(0) : p.perSecond.mul(p.endTime - p.openTime).add(1).toFixed(0)) } : void 0, associatedOnly: f ? false : r, checkCreateATAOwner: s });
          b && m.addInstruction(b), y || this.logAndCreateError("no money", "ownerRewardAccount", this.scope.account.tokenAccountRawInfos);
          let g = t != null ? t : await this.getClmmPoolKeys(e.id), A = Oe.setRewardInstructions({ poolInfo: e, poolKeys: g, ownerInfo: { wallet: this.scope.ownerPubKey, tokenAccount: y }, rewardInfo: { mint: new $.PublicKey(p.mint.address), openTime: p.openTime, endTime: p.endTime, emissionsPerSecondX64: Pe.decimalToX64(p.perSecond) } });
          m.addInstruction(A), d = E(E({}, d), A.address);
        }
        return m.addCustomComputeBudget(a), m.addTipInstruction(c), m.versionBuild({ txVersion: u, extInfo: { address: d } });
      }
      async collectReward({ poolInfo: e, ownerInfo: t, rewardMint: n, associatedOnly: o = true, checkCreateATAOwner: r = false, computeBudgetConfig: s, txTipConfig: a, txVersion: c, feePayer: u }) {
        let l = e.rewardDefaultInfos.find((g) => g.mint.address === n.toString());
        l || this.logAndCreateError("reward mint error", "not found reward mint", n);
        let m = this.createTxBuilder(u), d = t.useSOLBalance && n.equals(ee), { account: p, instructionParams: f } = await this.scope.account.getOrCreateTokenAccount({ tokenProgram: new $.PublicKey(l.mint.programId), mint: n, notUseTokenAccount: d, owner: this.scope.ownerPubKey, skipCloseAccount: !d, createInfo: { payer: t.feePayer || this.scope.ownerPubKey, amount: 0 }, associatedOnly: d ? false : o, checkCreateATAOwner: r });
        f && m.addInstruction(f), p || this.logAndCreateError("no money", "ownerRewardAccount", this.scope.account.tokenAccountRawInfos);
        let y = await this.getClmmPoolKeys(e.id), b = Oe.collectRewardInstructions({ poolInfo: e, poolKeys: y, ownerInfo: { wallet: this.scope.ownerPubKey, tokenAccount: p }, rewardMint: n });
        return m.addInstruction(b), m.addCustomComputeBudget(s), m.addTipInstruction(a), m.versionBuild({ txVersion: c, extInfo: { address: b.address } });
      }
      async collectRewards({ poolInfo: e, ownerInfo: t, rewardMints: n, associatedOnly: o = true, checkCreateATAOwner: r = false, computeBudgetConfig: s, txTipConfig: a, feePayer: c }) {
        let u = this.createTxBuilder(c), l = {};
        for (let m of n) {
          let d = e.rewardDefaultInfos.find((A) => A.mint.address === m.toString());
          if (!d) {
            this.logAndCreateError("reward mint error", "not found reward mint", m);
            continue;
          }
          let p = t.useSOLBalance && m.equals(ee), { account: f, instructionParams: y } = await this.scope.account.getOrCreateTokenAccount({ tokenProgram: new $.PublicKey(d.mint.programId), mint: m, notUseTokenAccount: p, owner: this.scope.ownerPubKey, skipCloseAccount: !p, createInfo: { payer: t.feePayer || this.scope.ownerPubKey, amount: 0 }, associatedOnly: p ? false : o, checkCreateATAOwner: r });
          f || this.logAndCreateError("no money", "ownerRewardAccount", this.scope.account.tokenAccountRawInfos), y && u.addInstruction(y);
          let b = await this.getClmmPoolKeys(e.id), g = Oe.collectRewardInstructions({ poolInfo: e, poolKeys: b, ownerInfo: { wallet: this.scope.ownerPubKey, tokenAccount: f }, rewardMint: m });
          u.addInstruction(g), l = E(E({}, l), g.address);
        }
        return u.addCustomComputeBudget(s), u.addTipInstruction(a), u.build({ address: l });
      }
      async swap({ poolInfo: e, poolKeys: t, inputMint: n, amountIn: o, amountOutMin: r, priceLimit: s, observationId: a, ownerInfo: c, remainingAccounts: u, associatedOnly: l = true, checkCreateATAOwner: m = false, txVersion: d, computeBudgetConfig: p, txTipConfig: f, feePayer: y }) {
        let b = this.createTxBuilder(y), g = n.toString() === e.mintA.address, A = c.useSOLBalance && e.mintA.address === ee.toBase58(), k = c.useSOLBalance && e.mintB.address === ee.toBase58(), I;
        !s || s.equals(new O(0)) ? I = g ? qt.add(new zt.default(1)) : Ut.sub(new zt.default(1)) : I = fe.priceToSqrtPriceX64(s, e.mintA.decimals, e.mintB.decimals);
        let T;
        if (!T) {
          let { account: x, instructionParams: K } = await this.scope.account.getOrCreateTokenAccount({ tokenProgram: e.mintA.programId, mint: new $.PublicKey(e.mintA.address), notUseTokenAccount: A, owner: this.scope.ownerPubKey, skipCloseAccount: !A, createInfo: A || !g ? { payer: c.feePayer || this.scope.ownerPubKey, amount: g ? o : 0 } : void 0, associatedOnly: A ? false : l, checkCreateATAOwner: m });
          T = x, K && b.addInstruction(K);
        }
        let h;
        if (!h) {
          let { account: x, instructionParams: K } = await this.scope.account.getOrCreateTokenAccount({ tokenProgram: e.mintB.programId, mint: new $.PublicKey(e.mintB.address), notUseTokenAccount: k, owner: this.scope.ownerPubKey, skipCloseAccount: !k, createInfo: k || g ? { payer: c.feePayer || this.scope.ownerPubKey, amount: g ? 0 : o } : void 0, associatedOnly: k ? false : l, checkCreateATAOwner: m });
          h = x, K && b.addInstruction(K);
        }
        (!T || !h) && this.logAndCreateError("user do not have token account", { tokenA: e.mintA.symbol || e.mintA.address, tokenB: e.mintB.symbol || e.mintB.address, ownerTokenAccountA: T, ownerTokenAccountB: h, mintAUseSOLBalance: A, mintBUseSOLBalance: k, associatedOnly: l });
        let S = t != null ? t : await this.getClmmPoolKeys(e.id);
        return b.addInstruction(Oe.makeSwapBaseInInstructions({ poolInfo: e, poolKeys: S, observationId: a, ownerInfo: { wallet: this.scope.ownerPubKey, tokenAccountA: T, tokenAccountB: h }, inputMint: new $.PublicKey(n), amountIn: o, amountOutMin: r, sqrtPriceLimitX64: I, remainingAccounts: u })), b.addCustomComputeBudget(p), b.addTipInstruction(f), b.versionBuild({ txVersion: d });
      }
      async swapBaseOut({ poolInfo: e, poolKeys: t, outputMint: n, amountOut: o, amountInMax: r, priceLimit: s, observationId: a, ownerInfo: c, remainingAccounts: u, associatedOnly: l = true, checkCreateATAOwner: m = false, txVersion: d, computeBudgetConfig: p, txTipConfig: f, feePayer: y }) {
        let b = this.createTxBuilder(y), g = n.toString() === e.mintB.address, A = c.useSOLBalance && e.mintA.address === ee.toBase58(), k = c.useSOLBalance && e.mintB.address === ee.toBase58(), I;
        !s || s.equals(new O(0)) ? I = n.toString() === e.mintB.address ? qt.add(new zt.default(1)) : Ut.sub(new zt.default(1)) : I = fe.priceToSqrtPriceX64(s, e.mintA.decimals, e.mintB.decimals);
        let T;
        if (!T) {
          let { account: x, instructionParams: K } = await this.scope.account.getOrCreateTokenAccount({ tokenProgram: e.mintA.programId, mint: new $.PublicKey(e.mintA.address), notUseTokenAccount: A, owner: this.scope.ownerPubKey, skipCloseAccount: !A, createInfo: A || !g ? { payer: c.feePayer || this.scope.ownerPubKey, amount: g ? r : 0 } : void 0, associatedOnly: A ? false : l, checkCreateATAOwner: m });
          T = x, K && b.addInstruction(K);
        }
        let h;
        if (!h) {
          let { account: x, instructionParams: K } = await this.scope.account.getOrCreateTokenAccount({ tokenProgram: e.mintB.programId, mint: new $.PublicKey(e.mintB.address), notUseTokenAccount: k, owner: this.scope.ownerPubKey, skipCloseAccount: !k, createInfo: k || g ? { payer: c.feePayer || this.scope.ownerPubKey, amount: g ? 0 : r } : void 0, associatedOnly: k ? false : l, checkCreateATAOwner: m });
          h = x, K && b.addInstruction(K);
        }
        (!T || !h) && this.logAndCreateError("user do not have token account", { tokenA: e.mintA.symbol || e.mintA.address, tokenB: e.mintB.symbol || e.mintB.address, ownerTokenAccountA: T, ownerTokenAccountB: h, mintAUseSOLBalance: A, mintBUseSOLBalance: k, associatedOnly: l });
        let S = t != null ? t : await this.getClmmPoolKeys(e.id);
        return b.addInstruction(Oe.makeSwapBaseOutInstructions({ poolInfo: e, poolKeys: S, observationId: a, ownerInfo: { wallet: this.scope.ownerPubKey, tokenAccountA: T, tokenAccountB: h }, outputMint: new $.PublicKey(n), amountOut: o, amountInMax: r, sqrtPriceLimitX64: I, remainingAccounts: u })), b.addCustomComputeBudget(p), b.addTipInstruction(f), b.versionBuild({ txVersion: d });
      }
      async harvestAllRewards({ allPoolInfo: e, allPositions: t, lockInfo: n, ownerInfo: o, associatedOnly: r = true, checkCreateATAOwner: s = false, programId: a, txVersion: c, computeBudgetConfig: u, feePayer: l, lockProgram: m = Fo, lockAuth: d = ai, clmmProgram: p = $n }) {
        var k, I;
        let f = {};
        for (let T of this.scope.account.tokenAccountRawInfos)
          r ? te(this.scope.ownerPubKey, T.accountInfo.mint, a).publicKey.equals(T.pubkey) && (f[T.accountInfo.mint.toString()] = T.pubkey) : f[T.accountInfo.mint.toString()] = T.pubkey;
        let y = Object.values(t).flat().map((T) => T.nftMint), b = await ze(this.scope.connection, y.map((T) => ({ pubkey: T }))), g = {};
        b.forEach((T) => {
          var h, S;
          g[T.pubkey.toBase58()] = (S = (h = T == null ? void 0 : T.accountInfo) == null ? void 0 : h.owner) != null ? S : null;
        });
        let A = this.createTxBuilder(l);
        for (let T of Object.values(e)) {
          if (t[T.id] === void 0 || !t[T.id].find((v) => !v.liquidity.isZero() || v.rewardInfos.find((L) => !L.rewardAmountOwed.isZero())))
            continue;
          let h = T, S = o.useSOLBalance && h.mintA.address === ee.toString(), x = o.useSOLBalance && h.mintB.address === ee.toString(), K = f[h.mintA.address];
          if (!K)
            if (S) {
              let { account: v, instructionParams: L } = await this.scope.account.getOrCreateTokenAccount({ tokenProgram: h.mintA.programId, mint: new $.PublicKey(h.mintA.address), notUseTokenAccount: S, owner: this.scope.ownerPubKey, skipCloseAccount: !S, createInfo: { payer: o.feePayer || this.scope.ownerPubKey, amount: 0 }, associatedOnly: S ? false : r, checkCreateATAOwner: s });
              K = v, L && A.addInstruction(L);
            } else {
              let v = new $.PublicKey(h.mintA.address);
              K = this.scope.account.getAssociatedTokenAccount(v, new $.PublicKey(h.mintA.programId)), A.addInstruction({ instructions: [(0, ft.createAssociatedTokenAccountIdempotentInstruction)(this.scope.ownerPubKey, K, this.scope.ownerPubKey, v, new $.PublicKey(h.mintA.programId))] });
            }
          let B = f[h.mintB.address];
          if (!B)
            if (x) {
              let { account: v, instructionParams: L } = await this.scope.account.getOrCreateTokenAccount({ tokenProgram: h.mintB.programId, mint: new $.PublicKey(h.mintB.address), notUseTokenAccount: x, owner: this.scope.ownerPubKey, skipCloseAccount: !x, createInfo: { payer: o.feePayer || this.scope.ownerPubKey, amount: 0 }, associatedOnly: x ? false : r, checkCreateATAOwner: s });
              B = v, L && A.addInstruction(L);
            } else {
              let v = new $.PublicKey(h.mintB.address);
              B = this.scope.account.getAssociatedTokenAccount(v, new $.PublicKey(h.mintB.programId)), A.addInstruction({ instructions: [(0, ft.createAssociatedTokenAccountIdempotentInstruction)(this.scope.ownerPubKey, B, this.scope.ownerPubKey, v, new $.PublicKey(h.mintB.programId))] });
            }
          f[h.mintA.address] = K, f[h.mintB.address] = B;
          let C = [];
          for (let v of h.rewardDefaultInfos) {
            let L = o.useSOLBalance && v.mint.address === ee.toString(), M = f[v.mint.address];
            if (!M) {
              let { account: Y, instructionParams: j } = await this.scope.account.getOrCreateTokenAccount({ tokenProgram: new $.PublicKey(v.mint.programId), mint: new $.PublicKey(v.mint.address), notUseTokenAccount: L, owner: this.scope.ownerPubKey, skipCloseAccount: !L, createInfo: { payer: o.feePayer || this.scope.ownerPubKey, amount: 0 }, associatedOnly: L ? false : r });
              M = Y, j && A.addInstruction(j);
            }
            f[v.mint.address] = M, C.push(M);
          }
          let R = await this.getClmmPoolKeys(h.id), N = [];
          for (let v = 0; v < R.rewardInfos.length; v++)
            N.push({ poolRewardVault: new $.PublicKey(R.rewardInfos[v].vault), ownerRewardVault: C[v], rewardMint: new $.PublicKey(R.rewardInfos[v].mint.address) });
          for (let v of t[T.id]) {
            let L = (k = n == null ? void 0 : n[T.id]) == null ? void 0 : k[v.nftMint.toBase58()];
            if (L) {
              let M = te(this.scope.ownerPubKey, L.lockNftMint, ft.TOKEN_PROGRAM_ID).publicKey, Y = ne.getTickArrayStartIndexByTick(v.tickLower, R.config.tickSpacing), j = ne.getTickArrayStartIndexByTick(v.tickUpper, R.config.tickSpacing), { publicKey: le } = Ce(new $.PublicKey(R.programId), L.poolId, Y), { publicKey: be } = Ce(new $.PublicKey(R.programId), L.poolId, j), { publicKey: me } = hn(new $.PublicKey(R.programId), L.poolId, v.tickLower, v.tickUpper), Ie = qo(m, L.lockNftMint).publicKey, he = Oe.harvestLockPositionInstructionV2({ programId: m, auth: d, lockPositionId: Ie, clmmProgram: p, lockOwner: this.scope.ownerPubKey, lockNftMint: L.lockNftMint, lockNftAccount: M, positionNftAccount: L.nftAccount, positionId: L.positionId, poolId: L.poolId, protocolPosition: me, vaultA: new $.PublicKey(R.vault.A), vaultB: new $.PublicKey(R.vault.B), tickArrayLower: le, tickArrayUpper: be, userVaultA: K, userVaultB: B, mintA: new $.PublicKey(R.mintA.address), mintB: new $.PublicKey(R.mintB.address), rewardAccounts: N, exTickArrayBitmap: st(p, L.poolId).publicKey });
              A.addInstruction({ instructions: [he], instructionTypes: [X.ClmmHarvestLockPosition], lookupTableAddress: R.lookupTableAccount ? [R.lookupTableAccount] : [] });
            } else {
              let M = Oe.decreaseLiquidityInstructions({ poolInfo: h, poolKeys: R, ownerPosition: v, ownerInfo: { wallet: this.scope.ownerPubKey, tokenAccountA: K, tokenAccountB: B, rewardAccounts: C }, liquidity: new zt.default(0), amountMinA: new zt.default(0), amountMinB: new zt.default(0), nft2022: (I = g[v.nftMint.toBase58()]) == null ? void 0 : I.equals(ft.TOKEN_2022_PROGRAM_ID) });
              A.addInstruction(M);
            }
          }
        }
        return c === 0 ? A.sizeCheckBuildV0({ computeBudgetConfig: u }) : A.sizeCheckBuild({ computeBudgetConfig: u });
      }
      async getWhiteListMint({ programId: e }) {
        let t = await this.scope.connection.getAccountInfo(Ii(e).publicKey);
        return t ? vc.decode(t.data).whitelistMints.filter((o) => !o.equals($.PublicKey.default)) : [];
      }
      async getOwnerPositionInfo({ programId: e = $n }) {
        await this.scope.account.fetchWalletTokenAccounts();
        let n = this.scope.account.tokenAccountRawInfos.filter((s) => s.accountInfo.amount.eq(new zt.default(1))).map((s) => Gt(new $.PublicKey(e), s.accountInfo.mint).publicKey), o = await this.scope.connection.getMultipleAccountsInfo(n), r = [];
        return o.forEach((s) => {
          if (!s)
            return;
          let a = Uo.decode(s.data);
          r.push(a);
        }), r;
      }
      async getOwnerLockedPositionInfo({ programId: e = Fo }) {
        await this.scope.account.fetchWalletTokenAccounts();
        let n = this.scope.account.tokenAccountRawInfos.filter((c) => c.accountInfo.amount.eq(new zt.default(1))).map((c) => qo(new $.PublicKey(e), c.accountInfo.mint).publicKey), o = await this.scope.connection.getMultipleAccountsInfo(n), r = [];
        o.forEach((c) => {
          if (!c)
            return;
          let u = Fc.decode(c.data);
          r.push(u);
        });
        let s = await this.scope.connection.getMultipleAccountsInfo(r.map((c) => c.positionId)), a = [];
        return s.forEach((c) => {
          if (!c)
            return;
          let u = Uo.decode(c.data);
          a.push(u);
        }), r.map((c, u) => ({ position: a[u], lockInfo: c }));
      }
      async getRpcClmmPoolInfo({ poolId: e }) {
        return (await this.getRpcClmmPoolInfos({ poolIds: [e] }))[String(e)];
      }
      async getRpcClmmPoolInfos({ poolIds: e, config: t }) {
        let n = await ze(this.scope.connection, e.map((r) => ({ pubkey: new $.PublicKey(r) })), t), o = {};
        for (let r = 0; r < e.length; r++) {
          let s = n[r];
          if (s === null || !s.accountInfo)
            throw Error("fetch pool info error: " + String(e[r]));
          let a = Bo.decode(s.accountInfo.data), c = fe.sqrtPriceX64ToPrice(a.sqrtPriceX64, a.mintDecimalsA, a.mintDecimalsB).toNumber();
          o[String(e[r])] = U(E({}, a), { currentPrice: c, programId: s.accountInfo.owner });
        }
        return o;
      }
      async getComputeClmmPoolInfos({ clmmPoolsRpcInfo: e, mintInfos: t }) {
        let n = new Set(Object.keys(e).map((c) => e[c].ammConfig.toBase58())), o = await ze(this.scope.connection, Array.from(n).map((c) => ({ pubkey: new $.PublicKey(c) }))), r = {};
        o.forEach((c) => {
          !c.accountInfo || (r[c.pubkey.toBase58()] = Oc.decode(c.accountInfo.data));
        });
        let s = await Xe.fetchComputeMultipleClmmInfo({ connection: this.scope.connection, rpcDataMap: e, poolList: Object.keys(e).map((c) => {
          var m, d, p, f;
          let [u, l] = [e[c].mintA.toBase58(), e[c].mintB.toBase58()];
          return { id: c, programId: e[c].programId.toBase58(), mintA: vt({ address: u, decimals: e[c].mintDecimalsA, programId: t[u].programId.toBase58() || ft.TOKEN_PROGRAM_ID.toBase58(), extensions: { feeConfig: (m = t[u]) != null && m.feeConfig ? oo((d = t[u]) == null ? void 0 : d.feeConfig) : void 0 } }), mintB: vt({ address: l, decimals: e[c].mintDecimalsB, programId: t[l].programId.toBase58() || ft.TOKEN_PROGRAM_ID.toBase58(), extensions: { feeConfig: (p = t[l]) != null && p.feeConfig ? oo((f = t[l]) == null ? void 0 : f.feeConfig) : void 0 } }), price: e[c].currentPrice, config: U(E({}, r[e[c].ammConfig.toBase58()]), { id: e[c].ammConfig.toBase58(), fundFeeRate: 0, description: "", defaultRange: 0, defaultRangePoint: [] }) };
        }) }), a = await Xe.fetchMultiplePoolTickArrays({ connection: this.scope.connection, poolKeys: Object.values(s) });
        return { computeClmmPoolInfo: s, computePoolTickData: a };
      }
      async getPoolInfoFromRpc(e) {
        var l;
        let t = await this.getRpcClmmPoolInfo({ poolId: e }), n = /* @__PURE__ */ new Set([t.mintA.toBase58(), t.mintB.toBase58()]), o = await Oo({ connection: this.scope.connection, mints: Array.from(n).map((m) => new $.PublicKey(m)) }), { computeClmmPoolInfo: r, computePoolTickData: s } = await this.scope.clmm.getComputeClmmPoolInfos({ clmmPoolsRpcInfo: { [e]: t }, mintInfos: o }), a = await ze(this.scope.connection, [{ pubkey: t.vaultA }, { pubkey: t.vaultB }]), c = Rc(r[e]);
        if (!a[0].accountInfo || !a[1].accountInfo)
          throw new Error("pool vault data not found");
        c.mintAmountA = Number(ft.AccountLayout.decode(a[0].accountInfo.data).amount.toString()), c.mintAmountB = Number(ft.AccountLayout.decode((l = a[1].accountInfo) == null ? void 0 : l.data).amount.toString());
        let u = U(E({}, r[e]), { exBitmapAccount: r[e].exBitmapAccount.toBase58(), observationId: r[e].observationId.toBase58(), id: e, programId: t.programId.toBase58(), openTime: t.startTime.toString(), vault: { A: t.vaultA.toBase58(), B: t.vaultB.toBase58() }, config: c.config, rewardInfos: r[e].rewardInfos.filter((m) => !m.tokenVault.equals($.PublicKey.default)).map((m) => ({ mint: vt({ address: m.tokenMint.toBase58(), programId: ft.TOKEN_PROGRAM_ID.toBase58(), decimals: 10 }), vault: m.tokenVault.toBase58() })) });
        return { poolInfo: c, poolKeys: u, computePoolInfo: r[e], tickData: s };
      }
    };
    var G = require("@solana/web3.js");
    var Ee = require_cjs4();
    var Zc = Ae(require_bn());
    var vr = Ae(require_bn());
    function Qc(i, e) {
      if (e.isZero())
        throw Error("divisor is zero");
      return i.mod(e);
    }
    function Ub(i, e) {
      if (e.isZero())
        throw Error("rhs is zero");
      let t = i.div(e);
      return Qc(i, e).gt(Mr) && (t = t.add(new vr.default(1))), [t, e];
    }
    var Mr = new vr.default(0);
    var Fi = class {
      static swapBaseInputWithoutFees(e, t, n) {
        let o = e.mul(n), r = t.add(e);
        return o.div(r);
      }
      static swapBaseOutputWithoutFees(e, t, n) {
        let o = t.mul(e), r = n.sub(e), [s] = Ub(o, r);
        return s;
      }
      static lpTokensToTradingTokens(e, t, n, o, r) {
        let s = e.mul(n).div(t), a = e.mul(o).div(t);
        if (r === 0)
          return { tokenAmount0: s, tokenAmount1: a };
        if (r === 1)
          return Qc(e.mul(n), t).gt(Mr) && s.gt(Mr) && (s = s.add(new vr.default(1))), Qc(e.mul(o), t).gt(Mr) && a.gt(Mr) && (a = a.add(new vr.default(1))), { tokenAmount0: s, tokenAmount1: a };
        throw Error("roundDirection value error");
      }
    };
    var Zd = Ae(require_bn());
    var Jt = class {
      static tradingFee(e, t) {
        return oi(e, t, jt);
      }
      static protocolFee(e, t) {
        return tr(e, t, jt);
      }
      static fundFee(e, t) {
        return tr(e, t, jt);
      }
      static creatorFee(e, t) {
        return oi(e, t, jt);
      }
      static splitCreatorFee(e, t, n) {
        return tr(e, n, t.add(n));
      }
      static calculatePreFeeAmount(e, t) {
        if (t.isZero())
          return e;
        let n = e.mul(jt), o = jt.sub(t);
        return n.add(o).sub(new Zd.default(1)).div(o);
      }
    };
    var jc = ((t) => (t[t.Floor = 0] = "Floor", t[t.Ceiling = 1] = "Ceiling", t))(jc || {});
    var $d = ((t) => (t[t.ZeroForOne = 0] = "ZeroForOne", t[t.OneForZero = 1] = "OneForZero", t))($d || {});
    var Jd = ((t) => (t[t.OneForZero = 0] = "OneForZero", t[t.ZeroForOne = 1] = "ZeroForOne", t))(Jd || {});
    var Vi = class {
      static validate_supply(e, t) {
        if (e.isZero())
          throw Error("tokenAmount0 is zero");
        if (t.isZero())
          throw Error("tokenAmount1 is zero");
      }
      static swapBaseInput(e, t, n, o, r, s, a, c) {
        let u = new Zc.default(0), l = Jt.tradingFee(e, o), m;
        c ? (u = Jt.creatorFee(e, r), m = e.sub(l).sub(u)) : m = e.sub(l);
        let d = Jt.protocolFee(l, s), p = Jt.protocolFee(l, a), f = Fi.swapBaseInputWithoutFees(m, t, n), y;
        return c ? y = f : (u = Jt.creatorFee(f, r), y = f.sub(u)), { newInputVaultAmount: t.add(m), newOutputVaultAmount: n.sub(f), inputAmount: e, outputAmount: y, tradeFee: l, protocolFee: d, fundFee: p, creatorFee: u };
      }
      static swapBaseOutput(e, t, n, o, r, s, a, c) {
        let u, l = new Zc.default(0), m;
        if (c)
          m = e;
        else {
          let b = Jt.calculatePreFeeAmount(e, r);
          l = b.sub(e), m = b;
        }
        let d = Fi.swapBaseOutputWithoutFees(m, t, n), p;
        if (c) {
          let b = Jt.calculatePreFeeAmount(d, o.add(r)), g = b.sub(d);
          l = Jt.splitCreatorFee(g, o, r), u = g.sub(l), p = b;
        } else {
          let b = Jt.calculatePreFeeAmount(d, o);
          u = b.sub(d), p = b;
        }
        let f = Jt.protocolFee(u, s), y = Jt.fundFee(u, a);
        return { newInputVaultAmount: t.add(d), newOutputVaultAmount: e.sub(m), inputAmount: p, outputAmount: e, tradeFee: u, protocolFee: f, fundFee: y, creatorFee: l };
      }
    };
    var et = Ae(require_bn());
    var mt = require("@solana/web3.js");
    var xt = require_cjs4();
    var Gb = Buffer.from("vault_and_lp_mint_auth_seed", "utf8");
    var Xb = Buffer.from("amm_config", "utf8");
    var zb = Buffer.from("pool", "utf8");
    var Yb = Buffer.from("pool_lp_mint", "utf8");
    var Hb = Buffer.from("pool_vault", "utf8");
    var Qb = Buffer.from("observation", "utf8");
    var jb = Buffer.from("permission", "utf8");
    function Yo(i) {
      return se([Gb], i);
    }
    function Zb(i, e) {
      return se([Xb, $b(e)], i);
    }
    function va(i, e, t, n) {
      return se([zb, e.toBuffer(), t.toBuffer(), n.toBuffer()], i);
    }
    function ep(i, e) {
      return se([Yb, e.toBuffer()], i);
    }
    function $c(i, e, t) {
      return se([Hb, e.toBuffer(), t.toBuffer()], i);
    }
    function _i(i, e) {
      return se([Qb, e.toBuffer()], i);
    }
    function $b(i) {
      let e = new ArrayBuffer(2);
      return new DataView(e).setUint16(0, i, false), new Uint8Array(e);
    }
    function Fa({ poolId: i, programId: e, configId: t, mintA: n, mintB: o }) {
      let r = Yo(e).publicKey, s = i || va(e, t, n, o).publicKey, a = ep(e, s).publicKey, c = $c(e, s, n).publicKey, u = $c(e, s, o).publicKey, l = _i(e, s).publicKey;
      return { poolId: s, configId: t, authority: r, lpMint: a, vaultA: c, vaultB: u, observationId: l };
    }
    var tp = Buffer.from("locked_liquidity", "utf8");
    function Ei(i, e) {
      return se([tp, e.toBuffer()], i);
    }
    function Jc(i, e) {
      return se([jb, e.toBuffer()], i);
    }
    var Jb = xe("Raydium_cpmm");
    var io = { initialize: [175, 175, 109, 31, 13, 152, 155, 237], deposit: [242, 35, 198, 137, 82, 225, 242, 182], withdraw: [183, 18, 70, 156, 148, 109, 161, 34], swapBaseInput: [143, 190, 90, 218, 196, 30, 51, 222], swapBaseOutput: [55, 217, 98, 86, 163, 74, 180, 173], lockCpLiquidity: [216, 157, 29, 78, 38, 51, 31, 26], collectCpFee: [8, 30, 51, 199, 209, 184, 247, 133], createPermissionPda: Buffer.from([135, 136, 2, 216, 137, 169, 181, 202]), closePermissionPda: Buffer.from([156, 84, 32, 118, 69, 135, 70, 123]), initializeWithPermission: Buffer.from([63, 55, 254, 65, 49, 178, 89, 121]), collectCreatorFee: Buffer.from([20, 22, 86, 123, 198, 28, 219, 132]) };
    function el(i, e, t, n, o, r, s, a, c, u, l, m, d, p, f, y, b, g, A, k) {
      let I = V([P2("amountMaxA"), P2("amountMaxB"), P2("openTime")]), T = va(i, t, r, s).publicKey, h = [{ pubkey: e, isSigner: true, isWritable: false }, { pubkey: t, isSigner: false, isWritable: false }, { pubkey: n, isSigner: false, isWritable: false }, { pubkey: o, isSigner: !o.equals(T), isWritable: true }, { pubkey: r, isSigner: false, isWritable: false }, { pubkey: s, isSigner: false, isWritable: false }, { pubkey: a, isSigner: false, isWritable: true }, { pubkey: c, isSigner: false, isWritable: true }, { pubkey: u, isSigner: false, isWritable: true }, { pubkey: l, isSigner: false, isWritable: true }, { pubkey: m, isSigner: false, isWritable: true }, { pubkey: d, isSigner: false, isWritable: true }, { pubkey: p, isSigner: false, isWritable: true }, { pubkey: b, isSigner: false, isWritable: true }, { pubkey: xt.TOKEN_PROGRAM_ID, isSigner: false, isWritable: false }, { pubkey: f, isSigner: false, isWritable: false }, { pubkey: y, isSigner: false, isWritable: false }, { pubkey: xt.ASSOCIATED_TOKEN_PROGRAM_ID, isSigner: false, isWritable: false }, { pubkey: Ji, isSigner: false, isWritable: false }, { pubkey: at, isSigner: false, isWritable: false }], S = Buffer.alloc(I.span);
      return I.encode({ amountMaxA: g, amountMaxB: A, openTime: k }, S), new mt.TransactionInstruction({ keys: h, programId: i, data: Buffer.from([...io.initialize, ...S]) });
    }
    function tl(i, e, t, n, o, r, s, a, c, u, l, m, d, p, f) {
      let y = V([P2("lpAmount"), P2("amountMaxA"), P2("amountMaxB")]), b = [{ pubkey: e, isSigner: true, isWritable: false }, { pubkey: t, isSigner: false, isWritable: false }, { pubkey: n, isSigner: false, isWritable: true }, { pubkey: o, isSigner: false, isWritable: true }, { pubkey: r, isSigner: false, isWritable: true }, { pubkey: s, isSigner: false, isWritable: true }, { pubkey: a, isSigner: false, isWritable: true }, { pubkey: c, isSigner: false, isWritable: true }, { pubkey: xt.TOKEN_PROGRAM_ID, isSigner: false, isWritable: false }, { pubkey: xt.TOKEN_2022_PROGRAM_ID, isSigner: false, isWritable: false }, { pubkey: u, isSigner: false, isWritable: false }, { pubkey: l, isSigner: false, isWritable: false }, { pubkey: m, isSigner: false, isWritable: true }], g = Buffer.alloc(y.span);
      return Jb.debug("cpmm deposit data", { lpAmount: d.toString(), amountMaxA: p.toString(), amountMaxB: f.toString() }), y.encode({ lpAmount: d, amountMaxA: p, amountMaxB: f }, g), new mt.TransactionInstruction({ keys: b, programId: i, data: Buffer.from([...io.deposit, ...g]) });
    }
    function nl(i, e, t, n, o, r, s, a, c, u, l, m, d, p, f) {
      let y = V([P2("lpAmount"), P2("amountMinA"), P2("amountMinB")]), b = [{ pubkey: e, isSigner: true, isWritable: false }, { pubkey: t, isSigner: false, isWritable: false }, { pubkey: n, isSigner: false, isWritable: true }, { pubkey: o, isSigner: false, isWritable: true }, { pubkey: r, isSigner: false, isWritable: true }, { pubkey: s, isSigner: false, isWritable: true }, { pubkey: a, isSigner: false, isWritable: true }, { pubkey: c, isSigner: false, isWritable: true }, { pubkey: xt.TOKEN_PROGRAM_ID, isSigner: false, isWritable: false }, { pubkey: xt.TOKEN_2022_PROGRAM_ID, isSigner: false, isWritable: false }, { pubkey: u, isSigner: false, isWritable: false }, { pubkey: l, isSigner: false, isWritable: false }, { pubkey: m, isSigner: false, isWritable: true }, { pubkey: Cn, isSigner: false, isWritable: false }], g = Buffer.alloc(y.span);
      return y.encode({ lpAmount: d, amountMinA: p, amountMinB: f }, g), new mt.TransactionInstruction({ keys: b, programId: i, data: Buffer.from([...io.withdraw, ...g]) });
    }
    function Fr(i, e, t, n, o, r, s, a, c, u, l, m, d, p, f, y) {
      let b = V([P2("amountIn"), P2("amounOutMin")]), g = [{ pubkey: e, isSigner: true, isWritable: false }, { pubkey: t, isSigner: false, isWritable: false }, { pubkey: n, isSigner: false, isWritable: false }, { pubkey: o, isSigner: false, isWritable: true }, { pubkey: r, isSigner: false, isWritable: true }, { pubkey: s, isSigner: false, isWritable: true }, { pubkey: a, isSigner: false, isWritable: true }, { pubkey: c, isSigner: false, isWritable: true }, { pubkey: u, isSigner: false, isWritable: false }, { pubkey: l, isSigner: false, isWritable: false }, { pubkey: m, isSigner: false, isWritable: false }, { pubkey: d, isSigner: false, isWritable: false }, { pubkey: p, isSigner: false, isWritable: true }], A = Buffer.alloc(b.span);
      return b.encode({ amountIn: f, amounOutMin: y }, A), new mt.TransactionInstruction({ keys: g, programId: i, data: Buffer.from([...io.swapBaseInput, ...A]) });
    }
    function ol(i, e, t, n, o, r, s, a, c, u, l, m, d, p, f, y) {
      let b = V([P2("amountInMax"), P2("amountOut")]), g = [{ pubkey: e, isSigner: true, isWritable: false }, { pubkey: t, isSigner: false, isWritable: false }, { pubkey: n, isSigner: false, isWritable: false }, { pubkey: o, isSigner: false, isWritable: true }, { pubkey: r, isSigner: false, isWritable: true }, { pubkey: s, isSigner: false, isWritable: true }, { pubkey: a, isSigner: false, isWritable: true }, { pubkey: c, isSigner: false, isWritable: true }, { pubkey: u, isSigner: false, isWritable: false }, { pubkey: l, isSigner: false, isWritable: false }, { pubkey: m, isSigner: false, isWritable: false }, { pubkey: d, isSigner: false, isWritable: false }, { pubkey: p, isSigner: false, isWritable: true }], A = Buffer.alloc(b.span);
      return b.encode({ amountInMax: f, amountOut: y }, A), new mt.TransactionInstruction({ keys: g, programId: i, data: Buffer.from([...io.swapBaseOutput, ...A]) });
    }
    async function il(i) {
      var b;
      let { ownerInfo: e, poolInfo: t, poolKeys: n, feeNftOwner: o, getEphemeralSigners: r } = i, s = [], [a, c] = [new mt.PublicKey(t.id), new mt.PublicKey(t.lpMint.address)], u;
      if (r)
        u = new mt.PublicKey((await r(1))[0]);
      else {
        let g = mt.Keypair.generate();
        s.push(g), u = g.publicKey;
      }
      let { publicKey: l } = te(o, u, xt.TOKEN_PROGRAM_ID), { publicKey: m } = Un(u), { publicKey: d } = Ei(i.lockProgram, u), { publicKey: p } = te(e.wallet, c, xt.TOKEN_PROGRAM_ID), { publicKey: f } = te(i.lockAuthProgram, c, xt.TOKEN_PROGRAM_ID), y = np({ programId: i.lockProgram, auth: i.lockAuthProgram, payer: e.feePayer, liquidityOwner: e.wallet, nftOwner: o, nftMint: u, nftAccount: l, poolId: a, lockPda: d, mintLp: c, userLpVault: p, lockLpVault: f, poolVaultA: new mt.PublicKey(n.vault.A), poolVaultB: new mt.PublicKey(n.vault.B), metadataAccount: m, lpAmount: i.lpAmount, withMetadata: (b = i.withMetadata) != null ? b : true });
      return { address: { nftMint: u, nftAccount: l, metadataAccount: m, lockPda: d, userLpVault: p, lockLpVault: f }, instructions: [y], signers: s, instructionTypes: [X.CpmmLockLp], lookupTableAddress: [] };
    }
    function np({ programId: i, auth: e, payer: t, liquidityOwner: n, nftOwner: o, nftMint: r, nftAccount: s, poolId: a, lockPda: c, mintLp: u, userLpVault: l, lockLpVault: m, poolVaultA: d, poolVaultB: p, metadataAccount: f, lpAmount: y, withMetadata: b }) {
      let g = [{ pubkey: e, isSigner: false, isWritable: false }, { pubkey: t, isSigner: true, isWritable: true }, { pubkey: n, isSigner: true, isWritable: false }, { pubkey: o, isSigner: false, isWritable: false }, { pubkey: r, isSigner: true, isWritable: true }, { pubkey: s, isSigner: false, isWritable: true }, { pubkey: a, isSigner: false, isWritable: false }, { pubkey: c, isSigner: false, isWritable: true }, { pubkey: u, isSigner: false, isWritable: false }, { pubkey: l, isSigner: false, isWritable: true }, { pubkey: m, isSigner: false, isWritable: true }, { pubkey: d, isSigner: false, isWritable: true }, { pubkey: p, isSigner: false, isWritable: true }, { pubkey: f, isSigner: false, isWritable: true }, { pubkey: at, isSigner: false, isWritable: false }, { pubkey: mt.SystemProgram.programId, isSigner: false, isWritable: false }, { pubkey: xt.TOKEN_PROGRAM_ID, isSigner: false, isWritable: false }, { pubkey: xt.ASSOCIATED_TOKEN_PROGRAM_ID, isSigner: false, isWritable: false }, { pubkey: cn, isSigner: false, isWritable: false }], A = V([P2("lpAmount"), Ze("withMetadata")]), k = Buffer.alloc(A.span);
      A.encode({ lpAmount: y, withMetadata: b }, k);
      let I = Buffer.from([...io.lockCpLiquidity, ...k]);
      return new mt.TransactionInstruction({ keys: g, programId: i, data: I });
    }
    function Va({ programId: i, nftOwner: e, auth: t, nftAccount: n, lockPda: o, poolId: r, mintLp: s, userVaultA: a, userVaultB: c, poolVaultA: u, poolVaultB: l, mintA: m, mintB: d, lockLpVault: p, lpFeeAmount: f, cpmmProgram: y, cpmmAuthProgram: b }) {
      let g = [{ pubkey: t, isSigner: false, isWritable: false }, { pubkey: e, isSigner: true, isWritable: false }, { pubkey: n, isSigner: false, isWritable: true }, { pubkey: o, isSigner: false, isWritable: true }, { pubkey: y != null ? y : eo, isSigner: false, isWritable: false }, { pubkey: b != null ? b : Cs, isSigner: false, isWritable: false }, { pubkey: r, isSigner: false, isWritable: true }, { pubkey: s, isSigner: false, isWritable: true }, { pubkey: a, isSigner: false, isWritable: true }, { pubkey: c, isSigner: false, isWritable: true }, { pubkey: u, isSigner: false, isWritable: true }, { pubkey: l, isSigner: false, isWritable: true }, { pubkey: m, isSigner: false, isWritable: false }, { pubkey: d, isSigner: false, isWritable: false }, { pubkey: p, isSigner: false, isWritable: true }, { pubkey: xt.TOKEN_PROGRAM_ID, isSigner: false, isWritable: false }, { pubkey: xt.TOKEN_2022_PROGRAM_ID, isSigner: false, isWritable: false }, { pubkey: Cn, isSigner: false, isWritable: false }], A = V([P2("lpFeeAmount")]), k = Buffer.alloc(A.span);
      A.encode({ lpFeeAmount: f }, k);
      let I = Buffer.from([...io.collectCpFee, ...k]);
      return new mt.TransactionInstruction({ keys: g, programId: i, data: I });
    }
    function _a(i, e, t, n, o, r, s, a, c, u, l, m, d) {
      let p = [{ pubkey: e, isSigner: true, isWritable: false }, { pubkey: t, isSigner: false, isWritable: false }, { pubkey: n, isSigner: false, isWritable: true }, { pubkey: o, isSigner: false, isWritable: false }, { pubkey: r, isSigner: false, isWritable: true }, { pubkey: s, isSigner: false, isWritable: true }, { pubkey: a, isSigner: false, isWritable: false }, { pubkey: c, isSigner: false, isWritable: false }, { pubkey: u, isSigner: false, isWritable: true }, { pubkey: l, isSigner: false, isWritable: true }, { pubkey: m, isSigner: false, isWritable: false }, { pubkey: d, isSigner: false, isWritable: false }, { pubkey: xt.ASSOCIATED_TOKEN_PROGRAM_ID, isSigner: false, isWritable: false }, { pubkey: mt.SystemProgram.programId, isSigner: false, isWritable: false }];
      return new mt.TransactionInstruction({ keys: p, programId: i, data: io.collectCreatorFee });
    }
    function rl(i, e, t, n, o, r, s, a, c, u, l, m, d, p, f, y, b, g, A, k, I, T, h) {
      let S = V([P2("amountA"), P2("amountB"), P2("openTime"), W("feeOn")]), x = [{ pubkey: e, isSigner: true, isWritable: false }, { pubkey: t, isSigner: false, isWritable: false }, { pubkey: n, isSigner: false, isWritable: false }, { pubkey: o, isSigner: false, isWritable: false }, { pubkey: r, isSigner: false, isWritable: true }, { pubkey: s, isSigner: false, isWritable: false }, { pubkey: a, isSigner: false, isWritable: false }, { pubkey: c, isSigner: false, isWritable: true }, { pubkey: u, isSigner: false, isWritable: true }, { pubkey: l, isSigner: false, isWritable: true }, { pubkey: m, isSigner: false, isWritable: true }, { pubkey: d, isSigner: false, isWritable: true }, { pubkey: p, isSigner: false, isWritable: true }, { pubkey: f, isSigner: false, isWritable: true }, { pubkey: g, isSigner: false, isWritable: true }, { pubkey: A, isSigner: false, isWritable: true }, { pubkey: xt.TOKEN_PROGRAM_ID, isSigner: false, isWritable: false }, { pubkey: y, isSigner: false, isWritable: false }, { pubkey: b, isSigner: false, isWritable: false }, { pubkey: xt.ASSOCIATED_TOKEN_PROGRAM_ID, isSigner: false, isWritable: false }, { pubkey: mt.SystemProgram.programId, isSigner: false, isWritable: false }], K = Buffer.alloc(S.span);
      return S.encode({ amountA: k, amountB: I, openTime: T, feeOn: h }, K), new mt.TransactionInstruction({ keys: x, programId: i, data: Buffer.from([...io.initializeWithPermission, ...K]) });
    }
    var sl = V([Fe(8), W("bump"), Ze("disableCreatePool"), on("index"), P2("tradeFeeRate"), P2("protocolFeeRate"), P2("fundFeeRate"), P2("createPoolFee"), F("protocolOwner"), F("fundOwner"), P2("creatorFeeRate"), Z(P2(), 15)]);
    var Vr = V([Fe(8), F("configId"), F("poolCreator"), F("vaultA"), F("vaultB"), F("mintLp"), F("mintA"), F("mintB"), F("mintProgramA"), F("mintProgramB"), F("observationId"), W("bump"), W("status"), W("lpDecimals"), W("mintDecimalA"), W("mintDecimalB"), P2("lpAmount"), P2("protocolFeesMintA"), P2("protocolFeesMintB"), P2("fundFeesMintA"), P2("fundFeesMintB"), P2("openTime"), P2("epoch"), W("feeOn"), Ze("enableCreatorFee"), Z(W(), 6), P2("creatorFeesMintA"), P2("creatorFeesMintB"), Z(P2(), 28)]);
    var eg = V([Fe(8), F("configId"), Z(P2(), 30)]);
    var al = ((n) => (n[n.BothToken = 0] = "BothToken", n[n.OnlyTokenA = 1] = "OnlyTokenA", n[n.OnlyTokenB = 2] = "OnlyTokenB", n))(al || {});
    var _r = class extends Je {
      constructor(e) {
        super(e);
      }
      async load() {
        this.checkDisabled();
      }
      async getCpmmPoolKeys(e) {
        return (await this.scope.api.fetchPoolKeysById({ idList: [e] }))[0];
      }
      async getRpcPoolInfo(e, t) {
        return (await this.getRpcPoolInfos([e], t))[e];
      }
      async getRpcPoolInfos(e, t) {
        let n = await ze(this.scope.connection, e.map((m) => ({ pubkey: new G.PublicKey(m) }))), o = {}, r = /* @__PURE__ */ new Set(), s = [];
        for (let m = 0; m < e.length; m++) {
          let d = n[m];
          if (d.accountInfo === null)
            throw Error("fetch pool info error: " + String(e[m]));
          let p = Vr.decode(d.accountInfo.data);
          o[String(e[m])] = U(E({}, p), { programId: d.accountInfo.owner }), r.add(String(p.configId)), s.push(p.vaultA, p.vaultB);
        }
        let a = {};
        if (t) {
          let m = [...r], d = await ze(this.scope.connection, m.map((p) => ({ pubkey: new G.PublicKey(p) })));
          for (let p = 0; p < m.length; p++) {
            let f = d[p].accountInfo;
            if (f === null)
              throw Error("fetch pool config error: " + m[p]);
            a[m[p]] = sl.decode(f.data);
          }
        }
        let c = {}, u = await ze(this.scope.connection, s.map((m) => ({ pubkey: new G.PublicKey(m) })));
        for (let m = 0; m < s.length; m++) {
          let d = u[m].accountInfo;
          if (d === null)
            throw Error("fetch vault info error: " + s[m]);
          c[String(s[m])] = new et.default(Ee.AccountLayout.decode(d.data).amount.toString());
        }
        let l = {};
        for (let [m, d] of Object.entries(o)) {
          let p = c[d.vaultA.toString()].sub(d.protocolFeesMintA).sub(d.fundFeesMintA).sub(d.creatorFeesMintA), f = c[d.vaultB.toString()].sub(d.protocolFeesMintB).sub(d.fundFeesMintB).sub(d.creatorFeesMintB);
          l[m] = U(E({}, d), { baseReserve: p, quoteReserve: f, vaultAAmount: c[d.vaultA.toString()], vaultBAmount: c[d.vaultB.toString()], configInfo: a[d.configId.toString()], poolPrice: new O(f.toString()).div(new O(10).pow(d.mintDecimalB)).div(new O(p.toString()).div(new O(10).pow(d.mintDecimalA))) });
        }
        return l;
      }
      toComputePoolInfos({ pools: e, mintInfos: t }) {
        return Object.keys(e).reduce((n, o) => {
          var c, u, l, m;
          let r = e[o], [s, a] = [r.mintA.toBase58(), r.mintB.toBase58()];
          return U(E({}, n), { [o]: U(E({}, r), { id: new G.PublicKey(o), configInfo: r.configInfo, version: 7, authority: Yo(r.programId).publicKey, mintA: vt({ address: s, decimals: r.mintDecimalA, programId: r.mintProgramA.toBase58(), extensions: { feeConfig: (c = t[s]) != null && c.feeConfig ? oo((u = t[s]) == null ? void 0 : u.feeConfig) : void 0 } }), mintB: vt({ address: a, decimals: r.mintDecimalB, programId: r.mintProgramB.toBase58(), extensions: { feeConfig: (l = t[a]) != null && l.feeConfig ? oo((m = t[a]) == null ? void 0 : m.feeConfig) : void 0 } }) }) });
        }, {});
      }
      async getPoolInfoFromRpc(e) {
        let t = await this.getRpcPoolInfo(e, true), n = await Oo({ connection: this.scope.connection, mints: [t.mintA, t.mintB] }), o = vt({ address: t.mintA.toBase58(), decimals: t.mintDecimalA, programId: t.mintProgramA.toBase58(), extensions: { feeConfig: n[t.mintA.toBase58()].feeConfig ? oo(n[t.mintA.toBase58()].feeConfig) : void 0 } }), r = vt({ address: t.mintB.toBase58(), decimals: t.mintDecimalB, programId: t.mintProgramB.toBase58(), extensions: { feeConfig: n[t.mintB.toBase58()].feeConfig ? oo(n[t.mintB.toBase58()].feeConfig) : void 0 } }), s = vt({ address: t.mintLp.toBase58(), decimals: t.lpDecimals, programId: Ee.TOKEN_PROGRAM_ID.toBase58() }), a = { id: t.configId.toBase58(), index: t.configInfo.index, protocolFeeRate: t.configInfo.protocolFeeRate.toNumber(), tradeFeeRate: t.configInfo.tradeFeeRate.toNumber(), fundFeeRate: t.configInfo.fundFeeRate.toNumber(), createPoolFee: t.configInfo.createPoolFee.toString() }, c = { volume: 0, volumeQuote: 0, volumeFee: 0, apr: 0, feeApr: 0, priceMin: 0, priceMax: 0, rewardApr: [] };
        return { poolInfo: { programId: t.programId.toBase58(), id: e, type: "Standard", lpMint: s, lpPrice: 0, lpAmount: t.lpAmount.toNumber(), config: a, mintA: o, mintB: r, rewardDefaultInfos: [], rewardDefaultPoolInfos: "Ecosystem", price: t.poolPrice.toNumber(), mintAmountA: new O(t.vaultAAmount.toString()).div(10 ** o.decimals).toNumber(), mintAmountB: new O(t.vaultBAmount.toString()).div(10 ** r.decimals).toNumber(), feeRate: t.configInfo.tradeFeeRate.toNumber(), openTime: t.openTime.toString(), tvl: 0, burnPercent: 0, day: c, week: c, month: c, pooltype: [], farmUpcomingCount: 0, farmOngoingCount: 0, farmFinishedCount: 0 }, poolKeys: { programId: t.programId.toBase58(), id: e, mintA: o, mintB: r, openTime: t.openTime.toString(), vault: { A: t.vaultA.toBase58(), B: t.vaultB.toBase58() }, authority: Yo(t.programId).publicKey.toBase58(), mintLp: s, config: a, observationId: _i(t.programId, new G.PublicKey(e)).publicKey.toBase58() }, rpcData: t };
      }
      async createPool(f) {
        var y = f, { poolId: e, programId: t, poolFeeAccount: n, startTime: o, ownerInfo: r, associatedOnly: s = false, checkCreateATAOwner: a = false, txVersion: c, feeConfig: u, computeBudgetConfig: l, txTipConfig: m, feePayer: d } = y, p = tt(y, ["poolId", "programId", "poolFeeAccount", "startTime", "ownerInfo", "associatedOnly", "checkCreateATAOwner", "txVersion", "feeConfig", "computeBudgetConfig", "txTipConfig", "feePayer"]);
        var M, Y, j;
        let b = r.feePayer || ((M = this.scope.owner) == null ? void 0 : M.publicKey), g = new et.default(new G.PublicKey(p.mintA.address).toBuffer()).lte(new et.default(new G.PublicKey(p.mintB.address).toBuffer())), [A, k] = g ? [p.mintA, p.mintB] : [p.mintB, p.mintA], [I, T] = g ? [p.mintAAmount, p.mintBAmount] : [p.mintBAmount, p.mintAAmount], h = r.useSOLBalance && A.address === Ee.NATIVE_MINT.toBase58(), S = r.useSOLBalance && k.address === Ee.NATIVE_MINT.toBase58(), [x, K] = [new G.PublicKey(A.address), new G.PublicKey(k.address)], B = this.createTxBuilder(d), { account: C, instructionParams: R } = await this.scope.account.getOrCreateTokenAccount({ mint: x, tokenProgram: A.programId, owner: this.scope.ownerPubKey, createInfo: h ? { payer: b, amount: I } : void 0, notUseTokenAccount: h, skipCloseAccount: !h, associatedOnly: h ? false : s, checkCreateATAOwner: a });
        B.addInstruction(R || {});
        let { account: N, instructionParams: v } = await this.scope.account.getOrCreateTokenAccount({ mint: new G.PublicKey(k.address), tokenProgram: k.programId, owner: this.scope.ownerPubKey, createInfo: S ? { payer: b, amount: T } : void 0, notUseTokenAccount: S, skipCloseAccount: !S, associatedOnly: S ? false : s, checkCreateATAOwner: a });
        if (B.addInstruction(v || {}), C === void 0 || N === void 0)
          throw Error("you don't has some token account");
        let L = Fa({ poolId: e, programId: t, configId: new G.PublicKey(u.id), mintA: x, mintB: K });
        return B.addInstruction({ instructions: [el(t, this.scope.ownerPubKey, new G.PublicKey(u.id), L.authority, L.poolId, x, K, L.lpMint, C, N, te(this.scope.ownerPubKey, L.lpMint).publicKey, L.vaultA, L.vaultB, n, new G.PublicKey((Y = A.programId) != null ? Y : Ee.TOKEN_PROGRAM_ID), new G.PublicKey((j = k.programId) != null ? j : Ee.TOKEN_PROGRAM_ID), L.observationId, I, T, o)], instructionTypes: [X.CpmmCreatePool] }), B.addCustomComputeBudget(l), B.addTipInstruction(m), B.versionBuild({ txVersion: c, extInfo: { address: U(E({}, L), { mintA: A, mintB: k, programId: t, poolFeeAccount: n, feeConfig: u }) } });
      }
      async addLiquidity(e) {
        let { poolInfo: t, poolKeys: n, inputAmount: o, baseIn: r, slippage: s, computeResult: a, computeBudgetConfig: c, txTipConfig: u, config: l, txVersion: m, feePayer: d } = e;
        this.scope.availability.addStandardPosition === false && this.logAndCreateError("add liquidity feature disabled in your region"), o.isZero() && this.logAndCreateError("amounts must greater than zero", "amountInA", { amountInA: o.toString() });
        let { account: p } = this.scope, { bypassAssociatedCheck: f, checkCreateATAOwner: y } = E({ bypassAssociatedCheck: false, checkCreateATAOwner: false }, l), b = a ? void 0 : await this.getRpcPoolInfo(t.id), { liquidity: g, inputAmountFee: A, anotherAmount: k } = a || this.computePairAmount({ poolInfo: U(E({}, t), { lpAmount: new O(b.lpAmount.toString()).div(10 ** t.lpMint.decimals).toNumber() }), baseReserve: b.baseReserve, quoteReserve: b.quoteReserve, slippage: new ot(0), baseIn: r, epochInfo: await this.scope.fetchEpochInfo(), amount: new O(o.toString()).div(10 ** (r ? t.mintA.decimals : t.mintB.decimals)) }), I = k.amount, T = t.mintA.address === Ee.NATIVE_MINT.toString(), h = t.mintB.address === Ee.NATIVE_MINT.toString(), S = this.createTxBuilder(d), [x, K] = [new G.PublicKey(t.mintA.address), new G.PublicKey(t.mintB.address)], { account: B, instructionParams: C } = await this.scope.account.getOrCreateTokenAccount({ tokenProgram: t.mintA.programId, mint: new G.PublicKey(t.mintA.address), owner: this.scope.ownerPubKey, createInfo: T || (r ? o : I).isZero() ? { payer: this.scope.ownerPubKey, amount: r ? o : I } : void 0, skipCloseAccount: !T, notUseTokenAccount: T, associatedOnly: false, checkCreateATAOwner: y });
        S.addInstruction(C || {});
        let { account: R, instructionParams: N } = await this.scope.account.getOrCreateTokenAccount({ tokenProgram: t.mintB.programId, mint: new G.PublicKey(t.mintB.address), owner: this.scope.ownerPubKey, createInfo: h || (r ? I : o).isZero() ? { payer: this.scope.ownerPubKey, amount: r ? I : o } : void 0, skipCloseAccount: !h, notUseTokenAccount: h, associatedOnly: false, checkCreateATAOwner: y });
        S.addInstruction(N || {}), !B && !R && this.logAndCreateError("cannot found target token accounts", "tokenAccounts", p.tokenAccounts);
        let v = await p.getCreatedTokenAccount({ mint: new G.PublicKey(t.lpMint.address) }), le = await p.handleTokenAccount({ side: "out", amount: 0, mint: new G.PublicKey(t.lpMint.address), tokenAccount: v, bypassAssociatedCheck: f, checkCreateATAOwner: y }), { tokenAccount: L } = le, M = tt(le, ["tokenAccount"]);
        S.addInstruction(M);
        let Y = n != null ? n : await this.getCpmmPoolKeys(t.id), j = new ot(new et.default(1)).sub(s);
        return S.addInstruction({ instructions: [tl(new G.PublicKey(t.programId), this.scope.ownerPubKey, new G.PublicKey(Y.authority), new G.PublicKey(t.id), L, B, R, new G.PublicKey(Y.vault.A), new G.PublicKey(Y.vault.B), x, K, new G.PublicKey(t.lpMint.address), a ? a == null ? void 0 : a.liquidity : j.mul(g).quotient, r ? A.amount : I, r ? I : A.amount)], instructionTypes: [X.CpmmAddLiquidity], lookupTableAddress: Y.lookupTableAccount ? [Y.lookupTableAccount] : [] }), S.addCustomComputeBudget(c), S.addTipInstruction(u), S.versionBuild({ txVersion: m });
      }
      async withdrawLiquidity(e) {
        var M, Y;
        let { poolInfo: t, poolKeys: n, lpAmount: o, slippage: r, computeBudgetConfig: s, txTipConfig: a, txVersion: c, feePayer: u, closeWsol: l = true } = e;
        this.scope.availability.addStandardPosition === false && this.logAndCreateError("add liquidity feature disabled in your region");
        let m = new ot(new et.default(1)).sub(r), d = await this.getRpcPoolInfo(t.id), [p, f] = [m.mul(o.mul(d.baseReserve).div(d.lpAmount)).quotient, m.mul(o.mul(d.quoteReserve).div(d.lpAmount)).quotient], y = await this.scope.fetchEpochInfo(), [b, g] = [_e(p, t.mintA.extensions.feeConfig, y, false), _e(f, t.mintB.extensions.feeConfig, y, false)], { account: A } = this.scope, k = this.createTxBuilder(u), [I, T] = [new G.PublicKey(t.mintA.address), new G.PublicKey(t.mintB.address)], h = I.equals(ee), S = T.equals(ee), x, K, { account: B, instructionParams: C } = await this.scope.account.getOrCreateTokenAccount({ tokenProgram: t.mintA.programId, mint: new G.PublicKey(t.mintA.address), notUseTokenAccount: h, owner: this.scope.ownerPubKey, createInfo: { payer: this.scope.ownerPubKey, amount: 0 }, skipCloseAccount: !(h && l), associatedOnly: !h, checkCreateATAOwner: false });
        x = B, C && k.addInstruction(C);
        let { account: R, instructionParams: N } = await this.scope.account.getOrCreateTokenAccount({ tokenProgram: t.mintB.programId, mint: new G.PublicKey(t.mintB.address), notUseTokenAccount: S, owner: this.scope.ownerPubKey, createInfo: { payer: this.scope.ownerPubKey, amount: 0 }, skipCloseAccount: !(S && l), associatedOnly: !S, checkCreateATAOwner: false });
        K = R, N && k.addInstruction(N), (!x || !K) && this.logAndCreateError("cannot found target token accounts", "tokenAccounts", A.tokenAccounts);
        let v = await A.getCreatedTokenAccount({ mint: new G.PublicKey(t.lpMint.address) });
        v || this.logAndCreateError("cannot found lp token account", "tokenAccounts", A.tokenAccounts);
        let L = n != null ? n : await this.getCpmmPoolKeys(t.id);
        return k.addInstruction({ instructions: [nl(new G.PublicKey(t.programId), this.scope.ownerPubKey, new G.PublicKey(L.authority), new G.PublicKey(t.id), v, x, K, new G.PublicKey(L.vault.A), new G.PublicKey(L.vault.B), I, T, new G.PublicKey(t.lpMint.address), o, p.sub((M = b.fee) != null ? M : new et.default(0)), f.sub((Y = g.fee) != null ? Y : new et.default(0)))], instructionTypes: [X.CpmmWithdrawLiquidity], lookupTableAddress: L.lookupTableAccount ? [L.lookupTableAccount] : [] }), k.addCustomComputeBudget(s), k.addTipInstruction(a), k.versionBuild({ txVersion: c });
      }
      async swap(e) {
        var C, R, N, v, L, M;
        let { poolInfo: t, poolKeys: n, baseIn: o, fixedOut: r, inputAmount: s, swapResult: a, slippage: c = 0, config: u, computeBudgetConfig: l, txTipConfig: m, txVersion: d, feePayer: p } = e, { bypassAssociatedCheck: f, checkCreateATAOwner: y, associatedOnly: b } = E({ bypassAssociatedCheck: false, checkCreateATAOwner: false, associatedOnly: true }, u), g = this.createTxBuilder(p), [A, k] = [new G.PublicKey(t.mintA.address), new G.PublicKey(t.mintB.address)];
        r ? a.inputAmount = a.inputAmount.mul(new et.default((1 + c) * 1e4)).div(new et.default(1e4)) : a.outputAmount = a.outputAmount.mul(new et.default((1 - c) * 1e4)).div(new et.default(1e4));
        let I = t.mintA.address === ee.toBase58(), T = t.mintB.address === ee.toBase58(), { account: h, instructionParams: S } = await this.scope.account.getOrCreateTokenAccount({ mint: A, tokenProgram: new G.PublicKey((C = t.mintA.programId) != null ? C : Ee.TOKEN_PROGRAM_ID), owner: this.scope.ownerPubKey, createInfo: I || !o ? { payer: this.scope.ownerPubKey, amount: o ? a.inputAmount : 0 } : void 0, notUseTokenAccount: I, skipCloseAccount: !I, associatedOnly: I ? false : b, checkCreateATAOwner: y });
        S && g.addInstruction(S);
        let { account: x, instructionParams: K } = await this.scope.account.getOrCreateTokenAccount({ mint: k, tokenProgram: new G.PublicKey((R = t.mintB.programId) != null ? R : Ee.TOKEN_PROGRAM_ID), owner: this.scope.ownerPubKey, createInfo: T || o ? { payer: this.scope.ownerPubKey, amount: o ? 0 : a.inputAmount } : void 0, notUseTokenAccount: T, skipCloseAccount: !T, associatedOnly: T ? false : b, checkCreateATAOwner: y });
        K && g.addInstruction(K), (!h || !x) && this.logAndCreateError("user do not have token account", { mintA: t.mintA.symbol || t.mintA.address, mintB: t.mintB.symbol || t.mintB.address, mintATokenAcc: h, mintBTokenAcc: x, mintAUseSOLBalance: I, mintBUseSOLBalance: T, associatedOnly: b });
        let B = n != null ? n : await this.getCpmmPoolKeys(t.id);
        return g.addInstruction({ instructions: [r ? ol(new G.PublicKey(t.programId), this.scope.ownerPubKey, new G.PublicKey(B.authority), new G.PublicKey(B.config.id), new G.PublicKey(t.id), o ? h : x, o ? x : h, new G.PublicKey(B.vault[o ? "A" : "B"]), new G.PublicKey(B.vault[o ? "B" : "A"]), new G.PublicKey((L = t[o ? "mintA" : "mintB"].programId) != null ? L : Ee.TOKEN_PROGRAM_ID), new G.PublicKey((M = t[o ? "mintB" : "mintA"].programId) != null ? M : Ee.TOKEN_PROGRAM_ID), o ? A : k, o ? k : A, _i(new G.PublicKey(t.programId), new G.PublicKey(t.id)).publicKey, a.inputAmount, a.outputAmount) : Fr(new G.PublicKey(t.programId), this.scope.ownerPubKey, new G.PublicKey(B.authority), new G.PublicKey(B.config.id), new G.PublicKey(t.id), o ? h : x, o ? x : h, new G.PublicKey(B.vault[o ? "A" : "B"]), new G.PublicKey(B.vault[o ? "B" : "A"]), new G.PublicKey((N = t[o ? "mintA" : "mintB"].programId) != null ? N : Ee.TOKEN_PROGRAM_ID), new G.PublicKey((v = t[o ? "mintB" : "mintA"].programId) != null ? v : Ee.TOKEN_PROGRAM_ID), o ? A : k, o ? k : A, _i(new G.PublicKey(t.programId), new G.PublicKey(t.id)).publicKey, s, a.outputAmount)], instructionTypes: [r ? X.CpmmSwapBaseOut : X.ClmmSwapBaseIn] }), g.addCustomComputeBudget(l), g.addTipInstruction(m), g.versionBuild({ txVersion: d });
      }
      async lockLp(e) {
        var d, p, f, y, b;
        let { poolInfo: t, lpAmount: n, computeBudgetConfig: o, txTipConfig: r, txVersion: s, feePayer: a, feeNftOwner: c } = e;
        n.isZero() && this.logAndCreateError("lpAmount must greater than zero", { lpAmount: n.toString() });
        let u = this.createTxBuilder(a), l = (d = e.poolKeys) != null ? d : await this.getCpmmPoolKeys(t.id), m = await il({ poolInfo: t, poolKeys: l, ownerInfo: { wallet: this.scope.ownerPubKey, feePayer: (p = e.feePayer) != null ? p : this.scope.ownerPubKey }, feeNftOwner: c != null ? c : this.scope.ownerPubKey, lockProgram: (f = e.programId) != null ? f : ui, lockAuthProgram: (y = e.authProgram) != null ? y : ci, lpAmount: n, withMetadata: (b = e.withMetadata) != null ? b : true, getEphemeralSigners: e.getEphemeralSigners });
        return u.addInstruction(m), u.addCustomComputeBudget(o), u.addTipInstruction(r), u.versionBuild({ txVersion: s, extInfo: m.address });
      }
      async harvestLockLp(e) {
        var R;
        let { poolInfo: t, lpFeeAmount: n, nftMint: o, programId: r = ui, authProgram: s = ci, cpmmProgram: a, computeBudgetConfig: c, txTipConfig: u, txVersion: l, closeWsol: m = true } = e;
        n.isZero() && this.logAndCreateError("lpFeeAmount must greater than zero", { lpAmount: n.toString() });
        let d = e.feePayer || this.scope.ownerPubKey, p = this.createTxBuilder(d), [f, y] = [new G.PublicKey(t.mintA.address), new G.PublicKey(t.mintB.address)], b = f.equals(ee), g = y.equals(ee), A, k, { account: I, instructionParams: T } = await this.scope.account.getOrCreateTokenAccount({ tokenProgram: t.mintA.programId, mint: new G.PublicKey(t.mintA.address), notUseTokenAccount: b, owner: this.scope.ownerPubKey, createInfo: { payer: this.scope.ownerPubKey, amount: 0 }, skipCloseAccount: !(b && m), associatedOnly: !b, checkCreateATAOwner: false });
        A = I, T && p.addInstruction(T);
        let { account: h, instructionParams: S } = await this.scope.account.getOrCreateTokenAccount({ tokenProgram: t.mintB.programId, mint: new G.PublicKey(t.mintB.address), notUseTokenAccount: g, owner: this.scope.ownerPubKey, createInfo: { payer: this.scope.ownerPubKey, amount: 0 }, skipCloseAccount: !(g && m), associatedOnly: !g, checkCreateATAOwner: false });
        k = h, S && p.addInstruction(S), (!A || !k) && this.logAndCreateError("cannot found target token accounts", { tokenAccountA: A, tokenAccountB: k });
        let x = (R = e.poolKeys) != null ? R : await this.getCpmmPoolKeys(t.id), { publicKey: K } = te(d, o, Ee.TOKEN_PROGRAM_ID), { publicKey: B } = Ei(r, o), { publicKey: C } = te(s, new G.PublicKey(t.lpMint.address), Ee.TOKEN_PROGRAM_ID);
        return p.addInstruction({ instructions: [Va({ programId: r, nftOwner: this.scope.ownerPubKey, auth: s, nftMint: o, nftAccount: K, lockPda: B, poolId: new G.PublicKey(t.id), mintLp: new G.PublicKey(x.mintLp.address), userVaultA: A, userVaultB: k, poolVaultA: new G.PublicKey(x.vault.A), poolVaultB: new G.PublicKey(x.vault.B), mintA: f, mintB: y, lockLpVault: C, lpFeeAmount: n, cpmmProgram: a == null ? void 0 : a.programId, cpmmAuthProgram: a == null ? void 0 : a.authProgram })], instructionTypes: [X.CpmmCollectLockFee] }), p.addCustomComputeBudget(c), p.addTipInstruction(u), p.versionBuild({ txVersion: l });
      }
      async harvestMultiLockLp(e) {
        var d;
        let { lockInfo: t, programId: n = ui, authProgram: o = ci, cpmmProgram: r, computeBudgetConfig: s, txVersion: a, closeWsol: c = true } = e, u = e.feePayer || this.scope.ownerPubKey, l = this.createTxBuilder(u), m = {};
        for (let p of t) {
          let { poolInfo: f, lpFeeAmount: y, nftMint: b } = p;
          if (y.isZero())
            continue;
          let [g, A] = [new G.PublicKey(f.mintA.address), new G.PublicKey(f.mintB.address)], k = g.equals(ee), I = A.equals(ee), T = m[f.mintA.address], h = m[f.mintB.address];
          if (!T)
            if (k) {
              let { account: C, instructionParams: R } = await this.scope.account.getOrCreateTokenAccount({ tokenProgram: f.mintA.programId, mint: new G.PublicKey(f.mintA.address), notUseTokenAccount: true, owner: this.scope.ownerPubKey, createInfo: { payer: this.scope.ownerPubKey, amount: 0 }, skipCloseAccount: !c, associatedOnly: false, checkCreateATAOwner: false });
              T = C, R && l.addInstruction(R), m[f.mintA.address] = C;
            } else {
              let C = new G.PublicKey(f.mintA.address);
              T = this.scope.account.getAssociatedTokenAccount(C, new G.PublicKey(f.mintA.programId)), l.addInstruction({ instructions: [(0, Ee.createAssociatedTokenAccountIdempotentInstruction)(this.scope.ownerPubKey, T, this.scope.ownerPubKey, C, new G.PublicKey(f.mintA.programId))] }), m[f.mintA.address] = T;
            }
          if (!h)
            if (I) {
              let { account: C, instructionParams: R } = await this.scope.account.getOrCreateTokenAccount({ tokenProgram: f.mintB.programId, mint: new G.PublicKey(f.mintB.address), notUseTokenAccount: true, owner: this.scope.ownerPubKey, createInfo: { payer: this.scope.ownerPubKey, amount: 0 }, skipCloseAccount: !c, associatedOnly: false, checkCreateATAOwner: false });
              h = C, R && l.addInstruction(R), m[f.mintB.address] = C;
            } else {
              let C = new G.PublicKey(f.mintB.address);
              h = this.scope.account.getAssociatedTokenAccount(C, new G.PublicKey(f.mintB.programId)), l.addInstruction({ instructions: [(0, Ee.createAssociatedTokenAccountIdempotentInstruction)(this.scope.ownerPubKey, h, this.scope.ownerPubKey, C, new G.PublicKey(f.mintB.programId))] }), m[f.mintB.address] = h;
            }
          (!T || !h) && this.logAndCreateError("cannot found target token accounts", { tokenAccountA: T, tokenAccountB: h });
          let S = (d = p.poolKeys) != null ? d : await this.getCpmmPoolKeys(f.id), { publicKey: x } = te(u, b, Ee.TOKEN_PROGRAM_ID), { publicKey: K } = Ei(n, b), { publicKey: B } = te(o, new G.PublicKey(f.lpMint.address), Ee.TOKEN_PROGRAM_ID);
          l.addInstruction({ instructions: [Va({ programId: n, nftOwner: this.scope.ownerPubKey, auth: o, nftMint: b, nftAccount: x, lockPda: K, poolId: new G.PublicKey(f.id), mintLp: new G.PublicKey(S.mintLp.address), userVaultA: T, userVaultB: h, poolVaultA: new G.PublicKey(S.vault.A), poolVaultB: new G.PublicKey(S.vault.B), mintA: g, mintB: A, lockLpVault: B, lpFeeAmount: y, cpmmProgram: r == null ? void 0 : r.programId, cpmmAuthProgram: r == null ? void 0 : r.authProgram })], instructionTypes: [X.CpmmCollectLockFee] });
        }
        return a === 0 ? l.sizeCheckBuildV0({ computeBudgetConfig: s }) : l.sizeCheckBuild({ computeBudgetConfig: s });
      }
      async createPoolWithPermission(y) {
        var b = y, { poolId: e, programId: t, poolFeeAccount: n, startTime: o, ownerInfo: r, associatedOnly: s = false, checkCreateATAOwner: a = false, txVersion: c, feeConfig: u, computeBudgetConfig: l, txTipConfig: m, feePayer: d, feeOn: p } = b, f = tt(b, ["poolId", "programId", "poolFeeAccount", "startTime", "ownerInfo", "associatedOnly", "checkCreateATAOwner", "txVersion", "feeConfig", "computeBudgetConfig", "txTipConfig", "feePayer", "feeOn"]);
        var Y, j, le;
        console.log("***this method only available for wallet with permissions***");
        let g = r.feePayer || ((Y = this.scope.owner) == null ? void 0 : Y.publicKey), A = new et.default(new G.PublicKey(f.mintA.address).toBuffer()).lte(new et.default(new G.PublicKey(f.mintB.address).toBuffer())), [k, I] = A ? [f.mintA, f.mintB] : [f.mintB, f.mintA], [T, h] = A ? [f.mintAAmount, f.mintBAmount] : [f.mintBAmount, f.mintAAmount], S = r.useSOLBalance && k.address === Ee.NATIVE_MINT.toBase58(), x = r.useSOLBalance && I.address === Ee.NATIVE_MINT.toBase58(), [K, B] = [new G.PublicKey(k.address), new G.PublicKey(I.address)], C = this.createTxBuilder(d), { account: R, instructionParams: N } = await this.scope.account.getOrCreateTokenAccount({ mint: K, tokenProgram: k.programId, owner: this.scope.ownerPubKey, createInfo: S ? { payer: g, amount: T } : void 0, notUseTokenAccount: S, skipCloseAccount: !S, associatedOnly: S ? false : s, checkCreateATAOwner: a });
        C.addInstruction(N || {});
        let { account: v, instructionParams: L } = await this.scope.account.getOrCreateTokenAccount({ mint: new G.PublicKey(I.address), tokenProgram: I.programId, owner: this.scope.ownerPubKey, createInfo: x ? { payer: g, amount: h } : void 0, notUseTokenAccount: x, skipCloseAccount: !x, associatedOnly: x ? false : s, checkCreateATAOwner: a });
        if (C.addInstruction(L || {}), R === void 0 || v === void 0)
          throw Error("you don't has some token account");
        let M = Fa({ poolId: e, programId: t, configId: new G.PublicKey(u.id), mintA: K, mintB: B });
        return C.addInstruction({ instructions: [rl(t, this.scope.ownerPubKey, this.scope.ownerPubKey, new G.PublicKey(u.id), M.authority, M.poolId, K, B, M.lpMint, R, v, te(this.scope.ownerPubKey, M.lpMint).publicKey, M.vaultA, M.vaultB, n, new G.PublicKey((j = k.programId) != null ? j : Ee.TOKEN_PROGRAM_ID), new G.PublicKey((le = I.programId) != null ? le : Ee.TOKEN_PROGRAM_ID), M.observationId, Jc(t, this.scope.ownerPubKey).publicKey, T, h, o, p)], instructionTypes: [X.CpmmCreatePool] }), C.addCustomComputeBudget(l), C.addTipInstruction(m), C.versionBuild({ txVersion: c, extInfo: { address: U(E({}, M), { mintA: k, mintB: I, programId: t, poolFeeAccount: n, feeConfig: u }) } });
      }
      async collectCreatorFees({ poolInfo: e, poolKeys: t, programId: n = eo, txVersion: o, computeBudgetConfig: r, txTipConfig: s, feePayer: a }) {
        let c = a || this.scope.ownerPubKey, u = this.createTxBuilder(c), l = t != null ? t : await this.getCpmmPoolKeys(e.id), [m, d, p, f] = [new G.PublicKey(e.mintA.address), new G.PublicKey(e.mintB.address), new G.PublicKey(e.mintA.programId), new G.PublicKey(e.mintB.programId)], y = this.scope.account.getAssociatedTokenAccount(m, p), b = this.scope.account.getAssociatedTokenAccount(d, f);
        return u.addInstruction({ instructions: [(0, Ee.createAssociatedTokenAccountIdempotentInstruction)(this.scope.ownerPubKey, y, this.scope.ownerPubKey, m, new G.PublicKey(e.mintA.programId)), (0, Ee.createAssociatedTokenAccountIdempotentInstruction)(this.scope.ownerPubKey, b, this.scope.ownerPubKey, d, new G.PublicKey(e.mintB.programId))] }), u.addInstruction({ instructions: [_a(n, this.scope.ownerPubKey, new G.PublicKey(l.authority), new G.PublicKey(l.id), new G.PublicKey(l.config.id), new G.PublicKey(l.vault.A), new G.PublicKey(l.vault.B), m, d, y, b, p, f)], instructionTypes: [] }), u.addCustomComputeBudget(r), u.addTipInstruction(s), u.versionBuild({ txVersion: o });
      }
      async collectMultiCreatorFees({ poolInfoList: e, programId: t = eo, txVersion: n, computeBudgetConfig: o, feePayer: r }) {
        let s = r || this.scope.ownerPubKey, a = this.createTxBuilder(s), c = {}, u = await this.scope.api.fetchPoolKeysById({ idList: e.map((l) => l.id) });
        for (let l of e) {
          let m = u.find((A) => A.id === l.id) || await this.getCpmmPoolKeys(l.id), [d, p, f, y] = [new G.PublicKey(l.mintA.address), new G.PublicKey(l.mintB.address), new G.PublicKey(l.mintA.programId), new G.PublicKey(l.mintB.programId)], b = c[l.mintA.address] || this.scope.account.getAssociatedTokenAccount(d, f), g = c[l.mintB.address] || this.scope.account.getAssociatedTokenAccount(p, y);
          c[l.mintA.address] || a.addInstruction({ instructions: [(0, Ee.createAssociatedTokenAccountIdempotentInstruction)(this.scope.ownerPubKey, b, this.scope.ownerPubKey, d, f)] }), c[l.mintB.address] || a.addInstruction({ instructions: [(0, Ee.createAssociatedTokenAccountIdempotentInstruction)(this.scope.ownerPubKey, g, this.scope.ownerPubKey, p, y)] }), c[l.mintA.address] = b, c[l.mintB.address] = g, a.addInstruction({ instructions: [_a(t, this.scope.ownerPubKey, new G.PublicKey(m.authority), new G.PublicKey(m.id), new G.PublicKey(m.config.id), new G.PublicKey(m.vault.A), new G.PublicKey(m.vault.B), d, p, b, g, f, y)], instructionTypes: [] });
        }
        return n === 0 ? a.sizeCheckBuildV0({ computeBudgetConfig: o }) : a.sizeCheckBuild({ computeBudgetConfig: o });
      }
      computeSwapAmount({ pool: e, amountIn: t, outputMint: n, slippage: o, swapBaseIn: r = true }) {
        let s = n.toString() === e.mintB.address, a = e.feeOn === 0 || e.feeOn === 2, c = r ? Vi.swapBaseInput(t, s ? e.baseReserve : e.quoteReserve, s ? e.quoteReserve : e.baseReserve, e.configInfo.tradeFeeRate, e.configInfo.creatorFeeRate, e.configInfo.protocolFeeRate, e.configInfo.fundFeeRate, a) : Vi.swapBaseOutput(t, s ? e.baseReserve : e.quoteReserve, s ? e.quoteReserve : e.baseReserve, e.configInfo.tradeFeeRate, e.configInfo.creatorFeeRate, e.configInfo.protocolFeeRate, e.configInfo.fundFeeRate, a), u = new O(c.outputAmount.toString()).div(c.inputAmount.toString()), l = c.outputAmount.mul(new et.default((1 - o) * 1e4)).div(new et.default(1e4));
        return { allTrade: c.inputAmount.eq(t), amountIn: t, amountOut: c.outputAmount, minAmountOut: l, executionPrice: u, fee: c.tradeFee, priceImpact: e.poolPrice.sub(u).div(e.poolPrice) };
      }
      computePairAmount({ poolInfo: e, baseReserve: t, quoteReserve: n, amount: o, slippage: r, epochInfo: s, baseIn: a }) {
        var I, T, h, S, x, K, B, C, R;
        let c = 1 - Number(r.toSignificant()) / 100, u = new et.default(new O(o).mul(10 ** e[a ? "mintA" : "mintB"].decimals).mul(c).toFixed(0)), l = _e(u, e[a ? "mintA" : "mintB"].extensions.feeConfig, s, false), m = u.sub((I = l.fee) != null ? I : new et.default(0)), d = new et.default(new O(e.lpAmount).mul(10 ** e.lpMint.decimals).toFixed(0, O.ROUND_DOWN));
        this.logDebug("baseReserve:", t.toString(), "quoteReserve:", n.toString()), this.logDebug("tokenIn:", a ? e.mintA.symbol : e.mintB.symbol, "amountIn:", u.toString(), "amountInFee:", (h = (T = l.fee) == null ? void 0 : T.toString()) != null ? h : 0, "anotherToken:", a ? e.mintB.symbol : e.mintA.symbol, "slippage:", `${r.toSignificant()}%`);
        let p = a ? "base" : "quote";
        this.logDebug("input side:", p);
        let f = m.mul(d).div(p === "base" ? t : n), y = { amount: ut, fee: void 0, expirationTime: void 0 };
        if (!m.isZero()) {
          let N = tg(f, t, n, d);
          this.logDebug("lpAmountData:", { amountA: N.amountA.toString(), amountB: N.amountB.toString() }), y = _e(N[a ? "amountB" : "amountA"], e[a ? "mintB" : "mintA"].extensions.feeConfig, s, true);
        }
        let b = new ot(new et.default(1)).add(r), g = new ot(new et.default(1)).sub(r), A = _e(b.mul(y.amount.sub((S = y.fee) != null ? S : new et.default(0))).quotient, e[a ? "mintB" : "mintA"].extensions.feeConfig, s, true), k = _e(g.mul(y.amount.sub((x = y.fee) != null ? x : new et.default(0))).quotient, e[a ? "mintB" : "mintA"].extensions.feeConfig, s, true);
        return this.logDebug("anotherAmount:", y.amount.toString(), "anotherAmountFee:", (B = (K = y.fee) == null ? void 0 : K.toString()) != null ? B : 0, "maxAnotherAmount:", A.amount.toString(), "maxAnotherAmountFee:", (R = (C = A.fee) == null ? void 0 : C.toString()) != null ? R : 0), { inputAmountFee: l, anotherAmount: y, maxAnotherAmount: A, minAnotherAmount: k, liquidity: f };
      }
    };
    function tg(i, e, t, n) {
      let o = i.mul(e).div(n);
      !o.isZero() && !i.mul(e).mod(n).isZero() && (o = o.add(new et.default(1)));
      let r = i.mul(t).div(n);
      return !r.isZero() && !i.mul(t).mod(n).isZero() && (r = r.add(new et.default(1))), { amountA: o, amountB: r };
    }
    var Ue = require("@solana/web3.js");
    var Te = require_cjs4();
    var yt = Ae(require_bn());
    var ul = { [rr.toBase58()]: 3 };
    var cl = { 3: rr };
    var Ea = V([Fe(5), Fe(8), F("ownAddress"), P2("vaultSignerNonce"), F("baseMint"), F("quoteMint"), F("baseVault"), P2("baseDepositsTotal"), P2("baseFeesAccrued"), F("quoteVault"), P2("quoteDepositsTotal"), P2("quoteFeesAccrued"), P2("quoteDustThreshold"), F("requestQueue"), F("eventQueue"), F("bids"), F("asks"), P2("baseLotSize"), P2("quoteLotSize"), P2("feeRateBps"), P2("referrerRebatesAccrued"), Fe(7)]);
    var ll = { 3: Ea };
    var ml = require("@solana/web3.js");
    var Wa = xe("Serum");
    var Er = class {
      static getProgramId(e) {
        let t = cl[e];
        return t || Wa.logWithError("invalid version", "version", e), t;
      }
      static getVersion(e) {
        let t = e.toBase58(), n = ul[t];
        return n || Wa.logWithError("invalid program id", "programId", t), n;
      }
      static getStateLayout(e) {
        let t = ll[e];
        return t || Wa.logWithError(!!t, "invalid version", "version", e), t;
      }
      static getLayouts(e) {
        return { state: this.getStateLayout(e) };
      }
      static getAssociatedAuthority({ programId: e, marketId: t }) {
        let n = [t.toBuffer()], o = 0, r;
        for (; o < 100; ) {
          try {
            let s = n.concat(Buffer.from([o]), Buffer.alloc(7));
            r = ml.PublicKey.createProgramAddressSync(s, e);
          } catch (s) {
            if (s instanceof TypeError)
              throw s;
            o++;
            continue;
          }
          return { publicKey: r, nonce: o };
        }
        return Wa.logWithError("unable to find a viable program address nonce", "params", { programId: e, marketId: t }), { publicKey: ml.PublicKey.default, nonce: o };
      }
    };
    var _ = require("@solana/web3.js");
    var Tn = Ae(require_bn());
    var Ft = require_cjs4();
    function ng(i, e, t, n, o, r, s, a, c, u, l, m) {
      let d = V([W("instruction"), P2("amountIn"), P2("amountOut")]), p = [{ pubkey: _.SystemProgram.programId, isSigner: false, isWritable: false }, { pubkey: Ft.TOKEN_PROGRAM_ID, isSigner: false, isWritable: false }, { pubkey: new _.PublicKey(t.programId), isSigner: false, isWritable: false }, { pubkey: new _.PublicKey(t.id), isSigner: false, isWritable: true }, { pubkey: new _.PublicKey(n.id), isSigner: false, isWritable: true }, { pubkey: o, isSigner: false, isWritable: true }, { pubkey: r, isSigner: false, isWritable: true }, { pubkey: s, isSigner: false, isWritable: true }, { pubkey: a, isSigner: true, isWritable: false }];
      if (e.type === "Concentrated") {
        let y = Qe(t);
        p.push({ pubkey: y.config.id, isSigner: false, isWritable: false }, { pubkey: y.id, isSigner: false, isWritable: true }, { pubkey: y.mintA.address.equals(c) ? y.vault.A : y.vault.B, isSigner: false, isWritable: true }, { pubkey: y.mintA.address.equals(c) ? y.vault.B : y.vault.A, isSigner: false, isWritable: true }, { pubkey: y.id, isSigner: false, isWritable: true }, ...m.map((b) => ({ pubkey: b, isSigner: false, isWritable: true })));
      } else if (e.pooltype.includes("StablePool")) {
        let y = Qe(t);
        p.push({ pubkey: y.authority, isSigner: false, isWritable: false }, { pubkey: y.marketProgramId, isSigner: false, isWritable: false }, { pubkey: y.id, isSigner: false, isWritable: true }, { pubkey: new _.PublicKey("CDSr3ssLcRB6XYPJwAfFt18MZvEZp4LjHcvzBVZ45duo"), isSigner: false, isWritable: false }, { pubkey: y.openOrders, isSigner: false, isWritable: true }, { pubkey: y.vault.A, isSigner: false, isWritable: true }, { pubkey: y.vault.B, isSigner: false, isWritable: true }, { pubkey: y.marketId, isSigner: false, isWritable: true }, { pubkey: y.marketBids, isSigner: false, isWritable: true }, { pubkey: y.marketAsks, isSigner: false, isWritable: true }, { pubkey: y.marketEventQueue, isSigner: false, isWritable: true }, { pubkey: y.id, isSigner: false, isWritable: true }, { pubkey: y.id, isSigner: false, isWritable: true });
      } else {
        let y = Qe(t);
        p.push({ pubkey: y.authority, isSigner: false, isWritable: false }, { pubkey: y.marketProgramId, isSigner: false, isWritable: false }, { pubkey: y.marketAuthority, isSigner: false, isWritable: false }, { pubkey: y.openOrders, isSigner: false, isWritable: true }, { pubkey: y.vault.A, isSigner: false, isWritable: true }, { pubkey: y.vault.B, isSigner: false, isWritable: true }, { pubkey: y.marketId, isSigner: false, isWritable: true }, { pubkey: y.marketBids, isSigner: false, isWritable: true }, { pubkey: y.marketAsks, isSigner: false, isWritable: true }, { pubkey: y.marketEventQueue, isSigner: false, isWritable: true }, ...y.marketProgramId.toString() === "srmqPvymJeFKQ4zGQed1GFppgkRHL9kaELCbyksJtPX" ? [{ pubkey: y.marketBaseVault, isSigner: false, isWritable: true }, { pubkey: y.marketQuoteVault, isSigner: false, isWritable: true }] : [{ pubkey: y.id, isSigner: false, isWritable: true }, { pubkey: y.id, isSigner: false, isWritable: true }]);
      }
      let f = Buffer.alloc(d.span);
      return d.encode({ instruction: 4, amountIn: u, amountOut: l }, f), new _.TransactionInstruction({ keys: p, programId: i, data: f });
    }
    function og(i, e, t, n, o, r, s, a, c, u) {
      let l = V([W("instruction")]), m = [{ pubkey: _.SystemProgram.programId, isSigner: false, isWritable: false }, { pubkey: Ft.TOKEN_PROGRAM_ID, isSigner: false, isWritable: false }, { pubkey: new _.PublicKey(String(n.programId)), isSigner: false, isWritable: false }, { pubkey: new _.PublicKey(String(n.id)), isSigner: false, isWritable: true }, { pubkey: new _.PublicKey(String(t.id)), isSigner: false, isWritable: true }, { pubkey: o, isSigner: false, isWritable: true }, { pubkey: r, isSigner: false, isWritable: true }, { pubkey: s, isSigner: false, isWritable: true }, { pubkey: a, isSigner: true, isWritable: false }];
      if (e.type === "Concentrated") {
        let p = Qe(n);
        m.push({ pubkey: p.config.id, isSigner: false, isWritable: false }, { pubkey: p.id, isSigner: false, isWritable: true }, { pubkey: p.mintA.address.equals(c) ? p.vault.A : p.vault.B, isSigner: false, isWritable: true }, { pubkey: p.mintA.address.equals(c) ? p.vault.B : p.vault.A, isSigner: false, isWritable: true }, { pubkey: p.id, isSigner: false, isWritable: true }, ...u.map((f) => ({ pubkey: f, isSigner: false, isWritable: true })));
      } else if (e.pooltype.includes("StablePool")) {
        let p = Qe(n);
        m.push({ pubkey: p.authority, isSigner: false, isWritable: false }, { pubkey: p.marketProgramId, isSigner: false, isWritable: false }, { pubkey: p.id, isSigner: false, isWritable: true }, { pubkey: new _.PublicKey("CDSr3ssLcRB6XYPJwAfFt18MZvEZp4LjHcvzBVZ45duo"), isSigner: false, isWritable: false }, { pubkey: p.openOrders, isSigner: false, isWritable: true }, { pubkey: p.vault.A, isSigner: false, isWritable: true }, { pubkey: p.vault.B, isSigner: false, isWritable: true }, { pubkey: p.marketId, isSigner: false, isWritable: true }, { pubkey: p.marketBids, isSigner: false, isWritable: true }, { pubkey: p.marketAsks, isSigner: false, isWritable: true }, { pubkey: p.marketEventQueue, isSigner: false, isWritable: true }, { pubkey: p.id, isSigner: false, isWritable: true }, { pubkey: p.id, isSigner: false, isWritable: true });
      } else {
        let p = Qe(n);
        m.push({ pubkey: p.authority, isSigner: false, isWritable: false }, { pubkey: p.marketProgramId, isSigner: false, isWritable: false }, { pubkey: p.marketAuthority, isSigner: false, isWritable: false }, { pubkey: p.openOrders, isSigner: false, isWritable: true }, { pubkey: p.vault.A, isSigner: false, isWritable: true }, { pubkey: p.vault.B, isSigner: false, isWritable: true }, { pubkey: p.marketId, isSigner: false, isWritable: true }, { pubkey: p.marketBids, isSigner: false, isWritable: true }, { pubkey: p.marketAsks, isSigner: false, isWritable: true }, { pubkey: p.marketEventQueue, isSigner: false, isWritable: true }, ...p.marketProgramId.toString() === "srmqPvymJeFKQ4zGQed1GFppgkRHL9kaELCbyksJtPX" ? [{ pubkey: p.marketBaseVault, isSigner: false, isWritable: true }, { pubkey: p.marketQuoteVault, isSigner: false, isWritable: true }] : [{ pubkey: p.id, isSigner: false, isWritable: true }, { pubkey: p.id, isSigner: false, isWritable: true }]);
      }
      let d = Buffer.alloc(l.span);
      return l.encode({ instruction: 5 }, d), new _.TransactionInstruction({ keys: m, programId: i, data: d });
    }
    function op(i, e, t, n, o, r, s, a, c, u, l, m, d, p, f) {
      var h;
      let y = [], b = [w({ pubkey: Ft.TOKEN_PROGRAM_ID, isWritable: false }), w({ pubkey: Ft.TOKEN_2022_PROGRAM_ID, isWritable: false }), w({ pubkey: Ft.ASSOCIATED_TOKEN_PROGRAM_ID, isWritable: false }), w({ pubkey: _.SystemProgram.programId, isWritable: false }), w({ pubkey: e, isSigner: true })];
      b.push(w({ pubkey: t })), b.push(w({ pubkey: o }));
      let g = [c, u], A = [l, m], k = [r, s, a];
      for (let S = 0; S < g.length; S++) {
        let x = g[S], K = k[S] === x.mintA.address;
        if (b.push(w({ pubkey: new _.PublicKey(x.programId), isWritable: false })), S === g.length - 1 ? b.push(w({ pubkey: o })) : b.push(w({ pubkey: n })), b.push(w({ pubkey: new _.PublicKey(k[S]) })), b.push(w({ pubkey: new _.PublicKey(k[S + 1]) })), x.version === 6) {
          let B = A[S];
          b.push(w({ pubkey: new _.PublicKey(B.config.id) })), b.push(w({ pubkey: new _.PublicKey(B.id) })), b.push(w({ pubkey: new _.PublicKey(K ? B.vault.A : B.vault.B) })), b.push(w({ pubkey: new _.PublicKey(K ? B.vault.B : B.vault.A) })), b.push(w({ pubkey: new _.PublicKey(x.observationId) })), b.push(w({ pubkey: Cn })), b.push(w({ pubkey: st(new _.PublicKey(x.programId), new _.PublicKey(x.id)).publicKey })), y.push(dl(x.sqrtPriceX64.toString(), K));
          for (let C of (h = f[S]) != null ? h : [])
            b.push(w({ pubkey: new _.PublicKey(C) }));
        } else if (x.version === 5) {
          let B = A[S];
          b.push(w({ pubkey: new _.PublicKey(B.id) })), b.push(w({ pubkey: new _.PublicKey(B.authority), isWritable: false })), b.push(w({ pubkey: new _.PublicKey(B.marketProgramId) })), b.push(w({ pubkey: new _.PublicKey(B.marketAuthority) })), b.push(w({ pubkey: sr, isWritable: false })), b.push(w({ pubkey: new _.PublicKey(B.openOrders) })), b.push(w({ pubkey: new _.PublicKey(B.vault.A) })), b.push(w({ pubkey: new _.PublicKey(B.vault.B) })), b.push(w({ pubkey: new _.PublicKey(B.id) })), b.push(w({ pubkey: new _.PublicKey(B.id) })), b.push(w({ pubkey: new _.PublicKey(B.id) })), b.push(w({ pubkey: new _.PublicKey(B.id) })), b.push(w({ pubkey: new _.PublicKey(B.id) })), b.push(w({ pubkey: new _.PublicKey(B.id) })), b.push(w({ pubkey: new _.PublicKey(B.marketId) })), b.push(w({ pubkey: new _.PublicKey(B.marketBids) })), b.push(w({ pubkey: new _.PublicKey(B.marketAsks) })), b.push(w({ pubkey: new _.PublicKey(B.marketEventQueue) })), b.push(w({ pubkey: new _.PublicKey(B.marketBaseVault) })), b.push(w({ pubkey: new _.PublicKey(B.marketQuoteVault) }));
        } else if (x.version === 4) {
          let B = A[S], C = x.status !== 1;
          b.push(w({ pubkey: new _.PublicKey(B.id) })), b.push(w({ pubkey: new _.PublicKey(B.authority), isWritable: false })), b.push(w({ pubkey: new _.PublicKey(C ? B.id : B.marketProgramId) })), b.push(w({ pubkey: new _.PublicKey(C ? B.id : B.marketAuthority) })), b.push(w({ pubkey: new _.PublicKey(C ? B.id : B.openOrders) })), b.push(w({ pubkey: new _.PublicKey(B.vault.A) })), b.push(w({ pubkey: new _.PublicKey(B.vault.B) })), b.push(w({ pubkey: new _.PublicKey(C ? B.id : B.marketId) })), b.push(w({ pubkey: new _.PublicKey(C ? B.id : B.marketBids) })), b.push(w({ pubkey: new _.PublicKey(C ? B.id : B.marketAsks) })), b.push(w({ pubkey: new _.PublicKey(C ? B.id : B.marketEventQueue) })), b.push(w({ pubkey: new _.PublicKey(C ? B.id : B.marketBaseVault) })), b.push(w({ pubkey: new _.PublicKey(C ? B.id : B.marketQuoteVault) }));
        } else if (x.version === 7) {
          let B = A[S];
          b.push(w({ pubkey: new _.PublicKey(B.authority) })), b.push(w({ pubkey: new _.PublicKey(B.config.id) })), b.push(w({ pubkey: new _.PublicKey(B.id) })), b.push(w({ pubkey: new _.PublicKey(K ? B.vault.A : B.vault.B) })), b.push(w({ pubkey: new _.PublicKey(K ? B.vault.B : B.vault.A) })), b.push(w({ pubkey: new _.PublicKey(x.observationId) }));
        } else
          throw Error("pool type error");
      }
      let I = V([W("insId"), P2("amountIn"), P2("amountOut"), Z(ae(), y.length, "clmmPriceLimit")]), T = Buffer.alloc(I.span);
      return I.encode({ insId: 0, amountIn: d, amountOut: p, clmmPriceLimit: y }, T), new _.TransactionInstruction({ keys: b, programId: i, data: T });
    }
    function dl(i, e) {
      if (i)
        if (e) {
          let t = new Tn.default(i).div(new Tn.default(25));
          return t.gt(Ar) ? t : Ar;
        } else {
          let t = new Tn.default(i).mul(new Tn.default(25));
          return t.lt(wr) ? t : wr;
        }
      else
        return e ? Ar : wr;
    }
    function pl({ routeProgram: i, ownerInfo: e, inputMint: t, swapInfo: n }) {
      var o, r, s, a, c, u, l, m, d;
      if (n.routeType === "amm")
        if (n.poolInfo[0].version === 6) {
          let p = n.poolKey[0], f = Qe(p), y = t.equals(f.mintA.address) ? qt.add(rn) : Ut.sub(rn);
          return Oe.makeSwapBaseInInstructions({ poolInfo: p, poolKeys: p, observationId: n.poolInfo[0].observationId, ownerInfo: { wallet: e.wallet, tokenAccountA: f.mintA.address.equals(t) ? e.sourceToken : e.destinationToken, tokenAccountB: f.mintA.address.equals(t) ? e.destinationToken : e.sourceToken }, inputMint: t, amountIn: n.amountIn.amount.raw, amountOutMin: n.minAmountOut.amount.raw.sub((r = (o = n.minAmountOut.fee) == null ? void 0 : o.raw) != null ? r : new Tn.default(0)), sqrtPriceLimitX64: y, remainingAccounts: (s = n.remainingAccounts[0]) != null ? s : [] });
        } else if (n.poolInfo[0].version === 7) {
          let p = n.poolInfo[0], f = t.toString() === n.poolInfo[0].mintA.address;
          return { signers: [], instructions: [Fr(p.programId, e.wallet, p.authority, p.configId, p.id, e.sourceToken, e.destinationToken, f ? p.vaultA : p.vaultB, f ? p.vaultB : p.vaultA, f ? p.mintProgramA : p.mintProgramB, f ? p.mintProgramB : p.mintProgramA, new _.PublicKey(p[f ? "mintA" : "mintB"].address), new _.PublicKey(p[f ? "mintB" : "mintA"].address), p.observationId, n.amountIn.amount.raw, n.minAmountOut.amount.raw)], lookupTableAddress: [], instructionTypes: [f ? X.CpmmSwapBaseIn : X.CpmmSwapBaseOut], address: {} };
        } else {
          let p = n.poolKey[0];
          return { signers: [], instructions: [n.poolInfo[0].pooltype.includes("StablePool") ? Cr({ poolKeys: p, version: n.poolInfo[0].pooltype.includes("StablePool") ? 5 : 4, userKeys: { tokenAccountIn: e.sourceToken, tokenAccountOut: e.destinationToken, owner: e.wallet }, amountIn: n.amountIn.amount.raw, amountOut: n.minAmountOut.amount.raw.sub((c = (a = n.minAmountOut.fee) == null ? void 0 : a.raw) != null ? c : new Tn.default(0)), fixedSide: "in" }) : Kr({ poolKeys: p, version: n.poolInfo[0].pooltype.includes("StablePool") ? 5 : 4, userKeys: { tokenAccountIn: e.sourceToken, tokenAccountOut: e.destinationToken, owner: e.wallet }, amountIn: n.amountIn.amount.raw, amountOut: n.minAmountOut.amount.raw.sub((l = (u = n.minAmountOut.fee) == null ? void 0 : u.raw) != null ? l : new Tn.default(0)), fixedSide: "in" })], lookupTableAddress: p.lookupTableAccount ? [p.lookupTableAccount] : [], instructionTypes: [n.poolInfo[0].pooltype.includes("StablePool") ? X.AmmV5SwapBaseIn : X.AmmV4SwapBaseIn], address: {} };
        }
      else if (n.routeType === "route") {
        let p = n.poolInfo[0], f = n.poolInfo[1], y = n.poolKey[0], b = n.poolKey[1];
        if (e.routeToken === void 0)
          throw Error("owner route token account check error");
        return { signers: [], instructions: [op(i, e.wallet, e.sourceToken, e.routeToken, e.destinationToken, t.toString(), n.middleToken.mint.toString(), n.outputMint.toString(), p, f, y, b, n.amountIn.amount.raw, n.minAmountOut.amount.raw.sub((d = (m = n.minAmountOut.fee) == null ? void 0 : m.raw) != null ? d : new Tn.default(0)), n.remainingAccounts)], instructionTypes: [X.RouteSwap], lookupTableAddress: [y.lookupTableAccount, b.lookupTableAccount].filter((g) => g !== void 0), address: {} };
      } else
        throw Error("route type error");
    }
    function ig({ programId: i, wallet: e, amount: t, inputAccount: n, outputAccount: o, routeInfo: r, poolKeys: s }) {
      var d;
      if (r.success === false)
        throw Error("route info error");
      let a = [], c = [w({ pubkey: Ft.TOKEN_PROGRAM_ID, isWritable: false }), w({ pubkey: Ft.TOKEN_2022_PROGRAM_ID, isWritable: false }), w({ pubkey: Ft.ASSOCIATED_TOKEN_PROGRAM_ID, isWritable: false }), w({ pubkey: _.SystemProgram.programId, isWritable: false }), w({ pubkey: e, isSigner: true })], u = { [r.data.inputMint]: n, [r.data.outputMint]: o };
      c.push(w({ pubkey: u[r.data.inputMint] })), c.push(w({ pubkey: u[r.data.outputMint] }));
      for (let p = 0; p < s.length; p++) {
        let f = r.data.routePlan[p], y = s[p], b = f.inputMint === y.mintA.address;
        if (c.push(w({ pubkey: new _.PublicKey(y.programId), isWritable: false })), p === s.length - 1)
          c.push(w({ pubkey: u[f.outputMint] }));
        else {
          let g = f.outputMint;
          if (u[g] === void 0) {
            let A = te(e, new _.PublicKey(g), y.programId === Et.CLMM_PROGRAM_ID.toBase58() || y.programId === Et.CREATE_CPMM_POOL_PROGRAM.toBase58() ? new _.PublicKey(b ? y.mintB.programId : y.mintA.programId) : Ft.TOKEN_PROGRAM_ID).publicKey;
            u[g] = A;
          }
          c.push(w({ pubkey: u[g] }));
        }
        if (c.push(w({ pubkey: new _.PublicKey(f.inputMint) })), c.push(w({ pubkey: new _.PublicKey(f.outputMint) })), y.programId === Et.CLMM_PROGRAM_ID.toBase58()) {
          let g = y;
          c.push(w({ pubkey: new _.PublicKey(g.config.id) })), c.push(w({ pubkey: new _.PublicKey(g.id) })), c.push(w({ pubkey: new _.PublicKey(b ? g.vault.A : g.vault.B) })), c.push(w({ pubkey: new _.PublicKey(b ? g.vault.B : g.vault.A) })), c.push(w({ pubkey: new _.PublicKey(g.observationId) })), c.push(w({ pubkey: Cn, isWritable: false })), c.push(w({ pubkey: new _.PublicKey(g.exBitmapAccount) })), a.push(dl(f.lastPoolPriceX64, b));
          for (let A of (d = f.remainingAccounts) != null ? d : [])
            c.push(w({ pubkey: new _.PublicKey(A) }));
        } else if (y.programId === Et.AMM_STABLE.toBase58()) {
          let g = y;
          c.push(w({ pubkey: new _.PublicKey(g.id) })), c.push(w({ pubkey: new _.PublicKey(g.authority), isWritable: false })), c.push(w({ pubkey: new _.PublicKey(g.marketProgramId), isWritable: false })), c.push(w({ pubkey: new _.PublicKey(g.marketAuthority), isWritable: false })), c.push(w({ pubkey: sr, isWritable: false })), c.push(w({ pubkey: new _.PublicKey(g.openOrders) })), c.push(w({ pubkey: new _.PublicKey(g.vault.A) })), c.push(w({ pubkey: new _.PublicKey(g.vault.B) })), c.push(w({ pubkey: new _.PublicKey(g.marketId) })), c.push(w({ pubkey: new _.PublicKey(g.marketBids) })), c.push(w({ pubkey: new _.PublicKey(g.marketAsks) })), c.push(w({ pubkey: new _.PublicKey(g.marketEventQueue) })), c.push(w({ pubkey: new _.PublicKey(g.marketBaseVault) })), c.push(w({ pubkey: new _.PublicKey(g.marketQuoteVault) }));
        } else if (y.programId === Et.AMM_V4.toBase58()) {
          let g = y;
          c.push(w({ pubkey: new _.PublicKey(g.id) })), c.push(w({ pubkey: new _.PublicKey(g.authority), isWritable: false })), c.push(w({ pubkey: new _.PublicKey(g.id) })), c.push(w({ pubkey: new _.PublicKey(g.id) })), c.push(w({ pubkey: new _.PublicKey(g.id) })), c.push(w({ pubkey: new _.PublicKey(g.vault.A) })), c.push(w({ pubkey: new _.PublicKey(g.vault.B) })), c.push(w({ pubkey: new _.PublicKey(g.id) })), c.push(w({ pubkey: new _.PublicKey(g.id) })), c.push(w({ pubkey: new _.PublicKey(g.id) })), c.push(w({ pubkey: new _.PublicKey(g.id) })), c.push(w({ pubkey: new _.PublicKey(g.id) })), c.push(w({ pubkey: new _.PublicKey(g.id) }));
        } else if (y.programId === Et.CREATE_CPMM_POOL_PROGRAM.toBase58()) {
          let g = y;
          c.push(w({ pubkey: new _.PublicKey(g.authority) })), c.push(w({ pubkey: new _.PublicKey(g.config.id) })), c.push(w({ pubkey: new _.PublicKey(g.id) })), c.push(w({ pubkey: new _.PublicKey(b ? g.vault.A : g.vault.B) })), c.push(w({ pubkey: new _.PublicKey(b ? g.vault.B : g.vault.A) })), c.push(w({ pubkey: new _.PublicKey(g.observationId) }));
        } else
          throw Error("pool type error");
      }
      let l = V([W("insId"), P2("amountIn"), P2("amountOut"), Z(ae(), a.length, "clmmPriceLimit")]), m = Buffer.alloc(l.span);
      return l.encode({ insId: 0, amountIn: t, amountOut: new Tn.default(r.data.otherAmountThreshold), clmmPriceLimit: a }, m), new _.TransactionInstruction({ keys: c, programId: i, data: m });
    }
    function rg({ programId: i, wallet: e, inputAccount: t, outputAccount: n, routeInfo: o, poolKeys: r }) {
      var m;
      if (o.success === false)
        throw Error("route info error");
      let s = [], a = [w({ pubkey: Ft.TOKEN_PROGRAM_ID, isWritable: false }), w({ pubkey: Ft.TOKEN_2022_PROGRAM_ID, isWritable: false }), w({ pubkey: Ft.ASSOCIATED_TOKEN_PROGRAM_ID, isWritable: false }), w({ pubkey: _.SystemProgram.programId, isWritable: false }), w({ pubkey: e, isSigner: true })], c = { [o.data.inputMint]: t, [o.data.outputMint]: n };
      for (let d = r.length - 1; d >= 0; d--) {
        let p = o.data.routePlan[d], f = r[d], y = p.inputMint === f.mintA.address;
        if (a.push(w({ pubkey: new _.PublicKey(f.programId) })), d === 0)
          a.push(w({ pubkey: c[p.inputMint] }));
        else {
          let b = p.inputMint;
          if (c[b] === void 0) {
            let g = te(e, new _.PublicKey(b), f.programId === Et.CLMM_PROGRAM_ID.toBase58() || f.programId === Et.CREATE_CPMM_POOL_PROGRAM.toBase58() ? new _.PublicKey(y ? f.mintA.programId : f.mintB.programId) : Ft.TOKEN_PROGRAM_ID).publicKey;
            c[b] = g;
          }
          a.push(w({ pubkey: c[b] }));
        }
        if (d === r.length - 1)
          a.push(w({ pubkey: c[p.outputMint] }));
        else {
          let b = p.outputMint;
          if (c[b] === void 0) {
            let g = te(e, new _.PublicKey(b), f.programId === Et.CLMM_PROGRAM_ID.toBase58() || f.programId === Et.CREATE_CPMM_POOL_PROGRAM.toBase58() ? new _.PublicKey(y ? f.mintB.programId : f.mintA.programId) : Ft.TOKEN_PROGRAM_ID).publicKey;
            c[b] = g;
          }
          a.push(w({ pubkey: c[b] }));
        }
        if (a.push(w({ pubkey: new _.PublicKey(p.inputMint) })), a.push(w({ pubkey: new _.PublicKey(p.outputMint) })), f.programId === Et.CLMM_PROGRAM_ID.toBase58()) {
          let b = f;
          a.push(w({ pubkey: new _.PublicKey(b.config.id) })), a.push(w({ pubkey: new _.PublicKey(b.id) })), a.push(w({ pubkey: new _.PublicKey(y ? b.vault.A : b.vault.B) })), a.push(w({ pubkey: new _.PublicKey(y ? b.vault.B : b.vault.A) })), a.push(w({ pubkey: new _.PublicKey(b.observationId) })), a.push(w({ pubkey: Cn, isWritable: false })), a.push(w({ pubkey: new _.PublicKey(b.exBitmapAccount) })), s.push(dl(p.lastPoolPriceX64, y));
          for (let g of (m = p.remainingAccounts) != null ? m : [])
            a.push(w({ pubkey: new _.PublicKey(g) }));
        } else if (f.programId === Et.AMM_STABLE.toBase58()) {
          let b = f;
          a.push(w({ pubkey: new _.PublicKey(b.id) })), a.push(w({ pubkey: new _.PublicKey(b.authority), isWritable: false })), a.push(w({ pubkey: new _.PublicKey(b.marketProgramId), isWritable: false })), a.push(w({ pubkey: new _.PublicKey(b.marketAuthority), isWritable: false })), a.push(w({ pubkey: sr, isWritable: false })), a.push(w({ pubkey: new _.PublicKey(b.openOrders) })), a.push(w({ pubkey: new _.PublicKey(b.vault.A) })), a.push(w({ pubkey: new _.PublicKey(b.vault.B) })), a.push(w({ pubkey: new _.PublicKey(b.marketId) })), a.push(w({ pubkey: new _.PublicKey(b.marketBids) })), a.push(w({ pubkey: new _.PublicKey(b.marketAsks) })), a.push(w({ pubkey: new _.PublicKey(b.marketEventQueue) })), a.push(w({ pubkey: new _.PublicKey(b.marketBaseVault) })), a.push(w({ pubkey: new _.PublicKey(b.marketQuoteVault) }));
        } else if (f.programId === Et.AMM_V4.toBase58()) {
          let b = f;
          a.push(w({ pubkey: new _.PublicKey(b.id) })), a.push(w({ pubkey: new _.PublicKey(b.authority), isWritable: false })), a.push(w({ pubkey: new _.PublicKey(b.id) })), a.push(w({ pubkey: new _.PublicKey(b.id) })), a.push(w({ pubkey: new _.PublicKey(b.id) })), a.push(w({ pubkey: new _.PublicKey(b.vault.A) })), a.push(w({ pubkey: new _.PublicKey(b.vault.B) })), a.push(w({ pubkey: new _.PublicKey(b.id) })), a.push(w({ pubkey: new _.PublicKey(b.id) })), a.push(w({ pubkey: new _.PublicKey(b.id) })), a.push(w({ pubkey: new _.PublicKey(b.id) })), a.push(w({ pubkey: new _.PublicKey(b.id) })), a.push(w({ pubkey: new _.PublicKey(b.id) }));
        } else if (f.programId === Et.CREATE_CPMM_POOL_PROGRAM.toBase58()) {
          let b = f;
          a.push(w({ pubkey: new _.PublicKey(b.authority) })), a.push(w({ pubkey: new _.PublicKey(b.config.id) })), a.push(w({ pubkey: new _.PublicKey(b.id) })), a.push(w({ pubkey: new _.PublicKey(y ? b.vault.A : b.vault.B) })), a.push(w({ pubkey: new _.PublicKey(y ? b.vault.B : b.vault.A) })), a.push(w({ pubkey: new _.PublicKey(b.observationId) }));
        } else
          throw Error("pool type error");
      }
      let u = V([W("insId"), P2("amountIn"), P2("amountOut"), Z(ae(), s.length, "clmmPriceLimit")]), l = Buffer.alloc(u.span);
      return u.encode({ insId: 1, amountIn: new Tn.default(o.data.otherAmountThreshold), amountOut: new Tn.default(o.data.outputAmount), clmmPriceLimit: s }, l), new _.TransactionInstruction({ keys: a, programId: i, data: l });
    }
    var fn = require_cjs4();
    var Me = require("@solana/web3.js");
    var zn = Ae(require_bn());
    var ro = V([P2(), P2("epoch"), W("curveType"), on("index"), P2("migrateFee"), P2("tradeFeeRate"), P2("maxShareFeeRate"), P2("minSupplyA"), P2("maxLockRate"), P2("minSellRateA"), P2("minMigrateRateA"), P2("minFundRaisingB"), F("mintB"), F("protocolFeeOwner"), F("migrateFeeOwner"), F("migrateToAmmWallet"), F("migrateToCpmmWallet"), Z(P2(), 16)]);
    var ip = V([P2("totalLockedAmount"), P2("cliffPeriod"), P2("unlockPeriod"), P2("startTime"), P2("totalAllocatedShare")]);
    var In = V([P2(), P2("epoch"), W("bump"), W("status"), W("mintDecimalsA"), W("mintDecimalsB"), W("migrateType"), P2("supply"), P2("totalSellA"), P2("virtualA"), P2("virtualB"), P2("realA"), P2("realB"), P2("totalFundRaisingB"), P2("protocolFee"), P2("platformFee"), P2("migrateFee"), ip.replicate("vestingSchedule"), F("configId"), F("platformId"), F("mintA"), F("mintB"), F("vaultA"), F("vaultB"), F("creator"), W("mintProgramFlag"), W("cpmmCreatorFeeOn"), P2("platformVestingShare"), Z(W(), 54)]);
    var sg = V([P2(), P2("epoch"), F("poolId"), F("beneficiary"), P2("claimedAmount"), P2("tokenShareAmount"), Z(P2(), 8)]);
    var Da = V([W("migrateType"), W("migrateCpmmFeeOn"), P2("supply"), P2("totalSellA"), P2("totalFundRaisingB"), P2("totalLockedAmount"), P2("cliffPeriod"), P2("unlockPeriod")]);
    var rp = V([P2("epoch"), W("index"), F("configId"), Da.replicate("bondingCurveParam"), Z(P2(), 50)]);
    var Xn = V([P2(), P2("epoch"), F("platformClaimFeeWallet"), F("platformLockNftWallet"), P2("platformScale"), P2("creatorScale"), P2("burnScale"), P2("feeRate"), Z(W(), 64, "name"), Z(W(), 256, "web"), Z(W(), 256, "img"), F("cpConfigId"), P2("creatorFeeRate"), F("transferFeeExtensionAuth"), F("platformVestingWallet"), P2("platformVestingScale"), Z(W(), 140), Yu(rp, "platformCurve")]);
    var sp = Buffer.from("vault_auth_seed", "utf8");
    var ap = Buffer.from("global_config", "utf8");
    var up = Buffer.from("pool_vesting", "utf8");
    var cp = Buffer.from("platform_config", "utf8");
    var lp = Buffer.from("platform_fee_vault_auth_seed", "utf8");
    var mp = Buffer.from("creator_fee_vault_auth_seed", "utf8");
    function an(i) {
      return se([sp], i);
    }
    function ag(i, e, t, n) {
      return se([ap, e.toBuffer(), dp(t), hr(n)], i);
    }
    function Ho(i, e, t) {
      return se([ba, e.toBuffer(), t.toBuffer()], i);
    }
    function qa(i, e, t) {
      return se([ga, e.toBuffer(), t.toBuffer()], i);
    }
    function so(i) {
      return se([Buffer.from("__event_authority", "utf8")], i);
    }
    function dp(i) {
      let e = new ArrayBuffer(1);
      return new DataView(e).setUint8(0, i), new Uint8Array(e);
    }
    function Ua(i, e) {
      return se([cp, e.toBuffer()], i);
    }
    function Qo(i, e, t) {
      return se([up, e.toBuffer(), t.toBuffer()], i);
    }
    function Mn(i, e, t) {
      return se([e.toBuffer(), t.toBuffer()], i);
    }
    function Ga(i) {
      return se([lp], i);
    }
    function vn(i, e, t) {
      return se([e.toBuffer(), t.toBuffer()], i);
    }
    function Xa(i) {
      return se([mp], i);
    }
    var Rt = { initialize: Buffer.from([175, 175, 109, 31, 13, 152, 155, 237]), initializeV2: Buffer.from([67, 153, 175, 39, 218, 16, 38, 32]), buyExactIn: Buffer.from([250, 234, 13, 123, 213, 156, 19, 236]), buyExactOut: Buffer.from([24, 211, 116, 40, 105, 3, 153, 56]), sellExactIn: Buffer.from([149, 39, 222, 155, 211, 124, 152, 26]), sellExactOut: Buffer.from([95, 200, 71, 34, 8, 9, 11, 166]), createVestingAccount: Buffer.from([129, 178, 2, 13, 217, 172, 230, 218]), claimVestedToken: Buffer.from([49, 33, 104, 30, 189, 157, 79, 35]), createPlatformConfig: Buffer.from([176, 90, 196, 175, 253, 113, 220, 20]), claimPlatformFee: Buffer.from([156, 39, 208, 135, 76, 237, 61, 72]), updatePlaformConfig: Buffer.from([195, 60, 76, 129, 146, 45, 67, 143]), initializeWithToken2022: Buffer.from([37, 190, 126, 222, 44, 154, 171, 17]), claimPlatformFeeFromVault: Buffer.from([117, 241, 198, 168, 248, 218, 80, 29]), claimCreatorFee: Buffer.from([26, 97, 138, 203, 132, 171, 141, 252]), updatePlatformCurveParam: Buffer.from([138, 144, 138, 250, 220, 128, 4, 57]), removePlatformCurveParam: Buffer.from([27, 30, 62, 169, 93, 224, 24, 145]), createPlatformVestingAccount: Buffer.from([146, 71, 173, 69, 98, 19, 15, 106]) };
    function ug(i, e, t, n, o, r, s, a, c, u, l, m, d, p, f, y, b, g, A, k) {
      throw new Error("*** launchlab initialize has been deprecated, please use initializeV2 instead! ***");
    }
    function yl(i, e, t, n, o, r, s, a, c, u, l, m, d, p, f, y, b, g, A, k, I) {
      let T = V([W("decimals"), Kt("name"), Kt("symbol"), Kt("uri")]), h = V([P2("totalLockedAmount"), P2("cliffPeriod"), P2("unlockPeriod"), W("cpmmCreatorFeeOn")]), S = V([W("index"), P2("supply"), P2("totalFundRaisingB"), W("migrateType")]), x = V([W("index"), P2("supply"), P2("totalSellA"), P2("totalFundRaisingB"), W("migrateType")]), K = [{ pubkey: e, isSigner: true, isWritable: true }, { pubkey: t, isSigner: false, isWritable: false }, { pubkey: n, isSigner: false, isWritable: false }, { pubkey: o, isSigner: false, isWritable: false }, { pubkey: r, isSigner: false, isWritable: false }, { pubkey: s, isSigner: false, isWritable: true }, { pubkey: a, isSigner: true, isWritable: true }, { pubkey: c, isSigner: false, isWritable: false }, { pubkey: u, isSigner: false, isWritable: true }, { pubkey: l, isSigner: false, isWritable: true }, { pubkey: m, isSigner: false, isWritable: true }, { pubkey: fn.TOKEN_PROGRAM_ID, isSigner: false, isWritable: false }, { pubkey: fn.TOKEN_PROGRAM_ID, isSigner: false, isWritable: false }, { pubkey: cn, isSigner: false, isWritable: false }, { pubkey: Me.SystemProgram.programId, isSigner: false, isWritable: false }, { pubkey: at, isSigner: false, isWritable: false }, { pubkey: so(i).publicKey, isSigner: false, isWritable: false }, { pubkey: i, isSigner: false, isWritable: false }], B = Buffer.alloc(Buffer.from(p, "utf-8").length + Buffer.from(f, "utf-8").length + Buffer.from(y, "utf-8").length + 4 * 3 + 1), C = Buffer.alloc(h.span), R = Buffer.alloc(b.type === "ConstantCurve" ? x.span : S.span);
      return T.encode({ decimals: d, name: p, symbol: f, uri: y }, B), b.type === "ConstantCurve" ? x.encode(U(E({ index: 0 }, b), { migrateType: b.migrateType === "amm" ? 0 : 1 }), R) : b.type === "FixedCurve" ? S.encode(U(E({ index: 1 }, b), { migrateType: b.migrateType === "amm" ? 0 : 1 }), R) : b.type === "LinearCurve" && S.encode(U(E({ index: 2 }, b), { migrateType: b.migrateType === "amm" ? 0 : 1 }), R), h.encode({ totalLockedAmount: g, cliffPeriod: A, unlockPeriod: k, cpmmCreatorFeeOn: I }, C), new Me.TransactionInstruction({ keys: K, programId: i, data: Buffer.from([...Rt.initializeV2, ...B, ...R, ...C]) });
    }
    function bl(i, e, t, n, o, r, s, a, c, u, l, m, d, p, f, y, b, g, A, k, I) {
      let T = V([W("decimals"), Kt("name"), Kt("symbol"), Kt("uri")]), h = V([P2("totalLockedAmount"), P2("cliffPeriod"), P2("unlockPeriod"), W("cpmmCreatorFeeOn"), W("transferFeeExtensionParamsOption"), V([on("transferFeeBasePoints"), P2("maxinumFee")]).replicate("transferFeeExtensionParams")]), S = V([W("index"), P2("supply"), P2("totalFundRaisingB"), W("migrateType")]), x = V([W("index"), P2("supply"), P2("totalSellA"), P2("totalFundRaisingB"), W("migrateType")]), K = [{ pubkey: e, isSigner: true, isWritable: true }, { pubkey: t, isSigner: false, isWritable: false }, { pubkey: n, isSigner: false, isWritable: false }, { pubkey: o, isSigner: false, isWritable: false }, { pubkey: r, isSigner: false, isWritable: false }, { pubkey: s, isSigner: false, isWritable: true }, { pubkey: a, isSigner: true, isWritable: true }, { pubkey: c, isSigner: false, isWritable: false }, { pubkey: u, isSigner: false, isWritable: true }, { pubkey: l, isSigner: false, isWritable: true }, { pubkey: fn.TOKEN_2022_PROGRAM_ID, isSigner: false, isWritable: false }, { pubkey: fn.TOKEN_PROGRAM_ID, isSigner: false, isWritable: false }, { pubkey: Me.SystemProgram.programId, isSigner: false, isWritable: false }, { pubkey: so(i).publicKey, isSigner: false, isWritable: false }, { pubkey: i, isSigner: false, isWritable: false }], B = Buffer.alloc(Buffer.from(d, "utf-8").length + Buffer.from(p, "utf-8").length + Buffer.from(f, "utf-8").length + 4 * 3 + 1), C = Buffer.alloc(h.span), R = Buffer.alloc(y.type === "ConstantCurve" ? x.span : S.span);
      return T.encode({ decimals: m, name: d, symbol: p, uri: f }, B), y.type === "ConstantCurve" ? x.encode(U(E({ index: 0 }, y), { migrateType: y.migrateType === "amm" ? 0 : 1 }), R) : y.type === "FixedCurve" ? S.encode(U(E({ index: 1 }, y), { migrateType: y.migrateType === "amm" ? 0 : 1 }), R) : y.type === "LinearCurve" && S.encode(U(E({ index: 2 }, y), { migrateType: y.migrateType === "amm" ? 0 : 1 }), R), h.encode({ totalLockedAmount: b, cliffPeriod: g, unlockPeriod: A, cpmmCreatorFeeOn: k, transferFeeExtensionParamsOption: I ? 1 : 0, transferFeeExtensionParams: I != null ? I : { transferFeeBasePoints: 0, maxinumFee: new zn.default(0) } }, C), new Me.TransactionInstruction({ keys: K, programId: i, data: Buffer.from([...Rt.initializeWithToken2022, ...B, ...R, ...C]) });
    }
    function Wr(i, e, t, n, o, r, s, a, c, u, l, m, d, p, f, y, b, g, A, k) {
      let I = V([P2("amountB"), P2("minAmountA"), P2("shareFeeRate")]), T = [{ pubkey: e, isSigner: true, isWritable: true }, { pubkey: t, isSigner: false, isWritable: false }, { pubkey: n, isSigner: false, isWritable: false }, { pubkey: o, isSigner: false, isWritable: false }, { pubkey: r, isSigner: false, isWritable: true }, { pubkey: s, isSigner: false, isWritable: true }, { pubkey: a, isSigner: false, isWritable: true }, { pubkey: c, isSigner: false, isWritable: true }, { pubkey: u, isSigner: false, isWritable: true }, { pubkey: l, isSigner: false, isWritable: false }, { pubkey: m, isSigner: false, isWritable: false }, { pubkey: d, isSigner: false, isWritable: false }, { pubkey: p, isSigner: false, isWritable: false }, { pubkey: so(i).publicKey, isSigner: false, isWritable: false }, { pubkey: i, isSigner: false, isWritable: false }];
      k && T.push({ pubkey: k, isSigner: false, isWritable: true }), T.push({ pubkey: Me.SystemProgram.programId, isSigner: false, isWritable: false }), T.push({ pubkey: f, isSigner: false, isWritable: true }), T.push({ pubkey: y, isSigner: false, isWritable: true });
      let h = Buffer.alloc(I.span);
      return I.encode({ amountB: b, minAmountA: g, shareFeeRate: A != null ? A : new zn.default(0) }, h), new Me.TransactionInstruction({ keys: T, programId: i, data: Buffer.from([...Rt.buyExactIn, ...h]) });
    }
    function gl(i, e, t, n, o, r, s, a, c, u, l, m, d, p, f, y, b, g, A, k) {
      let I = V([P2("amountA"), P2("maxAmountB"), P2("shareFeeRate")]), T = [{ pubkey: e, isSigner: true, isWritable: true }, { pubkey: t, isSigner: false, isWritable: false }, { pubkey: n, isSigner: false, isWritable: false }, { pubkey: o, isSigner: false, isWritable: false }, { pubkey: r, isSigner: false, isWritable: true }, { pubkey: s, isSigner: false, isWritable: true }, { pubkey: a, isSigner: false, isWritable: true }, { pubkey: c, isSigner: false, isWritable: true }, { pubkey: u, isSigner: false, isWritable: true }, { pubkey: l, isSigner: false, isWritable: false }, { pubkey: m, isSigner: false, isWritable: false }, { pubkey: d, isSigner: false, isWritable: false }, { pubkey: p, isSigner: false, isWritable: false }, { pubkey: so(i).publicKey, isSigner: false, isWritable: false }, { pubkey: i, isSigner: false, isWritable: false }];
      k && T.push({ pubkey: k, isSigner: false, isWritable: true }), T.push({ pubkey: Me.SystemProgram.programId, isSigner: false, isWritable: false }), T.push({ pubkey: f, isSigner: false, isWritable: true }), T.push({ pubkey: y, isSigner: false, isWritable: true });
      let h = Buffer.alloc(I.span);
      return I.encode({ amountA: b, maxAmountB: g, shareFeeRate: A != null ? A : new zn.default(0) }, h), new Me.TransactionInstruction({ keys: T, programId: i, data: Buffer.from([...Rt.buyExactOut, ...h]) });
    }
    function Dr(i, e, t, n, o, r, s, a, c, u, l, m, d, p, f, y, b, g, A, k) {
      let I = V([P2("amountA"), P2("minAmountB"), P2("shareFeeRate")]), T = [{ pubkey: e, isSigner: true, isWritable: true }, { pubkey: t, isSigner: false, isWritable: false }, { pubkey: n, isSigner: false, isWritable: false }, { pubkey: o, isSigner: false, isWritable: false }, { pubkey: r, isSigner: false, isWritable: true }, { pubkey: s, isSigner: false, isWritable: true }, { pubkey: a, isSigner: false, isWritable: true }, { pubkey: c, isSigner: false, isWritable: true }, { pubkey: u, isSigner: false, isWritable: true }, { pubkey: l, isSigner: false, isWritable: false }, { pubkey: m, isSigner: false, isWritable: false }, { pubkey: d, isSigner: false, isWritable: false }, { pubkey: p, isSigner: false, isWritable: false }, { pubkey: so(i).publicKey, isSigner: false, isWritable: false }, { pubkey: i, isSigner: false, isWritable: false }];
      k && T.push({ pubkey: k, isSigner: false, isWritable: true }), T.push({ pubkey: Me.SystemProgram.programId, isSigner: false, isWritable: false }), T.push({ pubkey: f, isSigner: false, isWritable: true }), T.push({ pubkey: y, isSigner: false, isWritable: true });
      let h = Buffer.alloc(I.span);
      return I.encode({ amountA: b, minAmountB: g, shareFeeRate: A != null ? A : new zn.default(0) }, h), new Me.TransactionInstruction({ keys: T, programId: i, data: Buffer.from([...Rt.sellExactIn, ...h]) });
    }
    function Pl(i, e, t, n, o, r, s, a, c, u, l, m, d, p, f, y, b, g, A, k) {
      let I = V([P2("amountB"), P2("maxAmountA"), P2("shareFeeRate")]), T = [{ pubkey: e, isSigner: true, isWritable: true }, { pubkey: t, isSigner: false, isWritable: false }, { pubkey: n, isSigner: false, isWritable: false }, { pubkey: o, isSigner: false, isWritable: false }, { pubkey: r, isSigner: false, isWritable: true }, { pubkey: s, isSigner: false, isWritable: true }, { pubkey: a, isSigner: false, isWritable: true }, { pubkey: c, isSigner: false, isWritable: true }, { pubkey: u, isSigner: false, isWritable: true }, { pubkey: l, isSigner: false, isWritable: false }, { pubkey: m, isSigner: false, isWritable: false }, { pubkey: d, isSigner: false, isWritable: false }, { pubkey: p, isSigner: false, isWritable: false }, { pubkey: so(i).publicKey, isSigner: false, isWritable: false }, { pubkey: i, isSigner: false, isWritable: false }];
      k && T.push({ pubkey: k, isSigner: false, isWritable: true }), T.push({ pubkey: Me.SystemProgram.programId, isSigner: false, isWritable: false }), T.push({ pubkey: f, isSigner: false, isWritable: true }), T.push({ pubkey: y, isSigner: false, isWritable: true });
      let h = Buffer.alloc(I.span);
      return I.encode({ amountB: b, maxAmountA: g, shareFeeRate: A != null ? A : new zn.default(0) }, h), new Me.TransactionInstruction({ keys: T, programId: i, data: Buffer.from([...Rt.sellExactOut, ...h]) });
    }
    function za(i, e, t, n, o, r, s, a, c) {
      let u = V([]), l = [{ pubkey: e, isSigner: true, isWritable: true }, { pubkey: t, isSigner: false, isWritable: false }, { pubkey: n, isSigner: false, isWritable: true }, { pubkey: o, isSigner: false, isWritable: true }, { pubkey: s, isSigner: false, isWritable: true }, { pubkey: r, isSigner: false, isWritable: true }, { pubkey: a, isSigner: false, isWritable: false }, { pubkey: c, isSigner: false, isWritable: false }, { pubkey: Me.SystemProgram.programId, isSigner: false, isWritable: false }, { pubkey: fn.ASSOCIATED_TOKEN_PROGRAM_ID, isSigner: false, isWritable: false }], m = Buffer.alloc(u.span);
      return u.encode({}, m), new Me.TransactionInstruction({ keys: l, programId: i, data: Buffer.from([...Rt.claimVestedToken, ...m]) });
    }
    function Ya(i, e, t, n, o, r) {
      let s = V([P2("shareAmount")]), a = [{ pubkey: e, isSigner: true, isWritable: true }, { pubkey: t, isSigner: false, isWritable: true }, { pubkey: n, isSigner: false, isWritable: true }, { pubkey: o, isSigner: false, isWritable: true }, { pubkey: Me.SystemProgram.programId, isSigner: false, isWritable: false }], c = Buffer.alloc(s.span);
      return s.encode({ shareAmount: r }, c), new Me.TransactionInstruction({ keys: a, programId: i, data: Buffer.from([...Rt.createVestingAccount, ...c]) });
    }
    function Ha(i, e, t, n, o, r, s, a, c) {
      let u = [{ pubkey: e, isSigner: true, isWritable: true }, { pubkey: t, isSigner: false, isWritable: false }, { pubkey: n, isSigner: false, isWritable: true }, { pubkey: o, isSigner: false, isWritable: true }, { pubkey: r, isSigner: false, isWritable: true }, { pubkey: s, isSigner: false, isWritable: true }, { pubkey: a, isSigner: false, isWritable: true }, { pubkey: c, isSigner: false, isWritable: true }, { pubkey: Me.SystemProgram.programId, isSigner: false, isWritable: true }, { pubkey: fn.ASSOCIATED_TOKEN_PROGRAM_ID, isSigner: false, isWritable: true }];
      return new Me.TransactionInstruction({ keys: u, programId: i, data: Rt.claimPlatformFee });
    }
    function Al(i, e, t, n, o, r, s, a, c, u, l, m, d, p, f) {
      let y = V([P2("platformScale"), P2("creatorScale"), P2("burnScale"), P2("feeRate"), Kt("name"), Kt("web"), Kt("img"), P2("creatorFeeRate"), P2("platformVestingScale")]), b = [{ pubkey: e, isSigner: true, isWritable: true }, { pubkey: t, isSigner: false, isWritable: false }, { pubkey: n, isSigner: false, isWritable: false }, { pubkey: r, isSigner: false, isWritable: true }, { pubkey: s, isSigner: false, isWritable: true }, { pubkey: Me.SystemProgram.programId, isSigner: false, isWritable: false }, { pubkey: a, isSigner: false, isWritable: false }, { pubkey: o, isSigner: false, isWritable: false }], g = Buffer.alloc(8 * 6 + Buffer.from(m, "utf-8").length + Buffer.from(d, "utf-8").length + Buffer.from(p, "utf-8").length + 4 * 3);
      return y.encode({ platformScale: c.platformScale, creatorScale: c.creatorScale, burnScale: c.burnScale, feeRate: u, name: m, web: d, img: p, creatorFeeRate: l, platformVestingScale: f }, g), new Me.TransactionInstruction({ keys: b, programId: i, data: Buffer.from([...Rt.createPlatformConfig, ...g]) });
    }
    function wl(i, e, t, n) {
      let o = [{ pubkey: e, isSigner: true, isWritable: false }, { pubkey: t, isSigner: false, isWritable: true }], r;
      if (n.type === "updateClaimFeeWallet") {
        let s = V([W("index"), F("value")]);
        r = Buffer.alloc(s.span), s.encode({ index: 0, value: n.value }, r);
      } else if (n.type === "updateLockNftWallet") {
        let s = V([W("index"), F("value")]);
        r = Buffer.alloc(s.span), s.encode({ index: 1, value: n.value }, r);
      } else if (n.type === "migrateCpLockNftScale") {
        let s = V([W("index"), P2("platformScale"), P2("creatorScale"), P2("burnScale")]);
        r = Buffer.alloc(s.span), s.encode(E({ index: 2 }, n.value), r);
      } else if (n.type === "updateFeeRate") {
        let s = V([W("index"), P2("value")]);
        r = Buffer.alloc(s.span), s.encode({ index: 3, value: n.value }, r);
      } else if (n.type === "updateImg" || n.type === "updateName" || n.type === "updateWeb") {
        let s = V([W("index"), Kt("value")]);
        r = Buffer.alloc(Buffer.from(n.value, "utf-8").length + 4 + 1 * 1), n.type === "updateName" ? s.encode({ index: 4, value: n.value }, r) : n.type === "updateWeb" ? s.encode({ index: 5, value: n.value }, r) : n.type === "updateImg" && s.encode({ index: 6, value: n.value }, r);
      } else if (n.type === "updateCpConfigId") {
        o.push({ pubkey: n.value, isSigner: false, isWritable: false });
        let s = V([W("index")]);
        r = Buffer.alloc(s.span), s.encode({ index: 7 }, r);
      } else if (n.type === "updateAll") {
        o.push({ pubkey: n.value.cpConfigId, isSigner: false, isWritable: false });
        let s = V([W("index"), F("platformClaimFeeWallet"), F("platformLockNftWallet"), P2("platformScale"), P2("creatorScale"), P2("burnScale"), P2("feeRate"), Kt("name"), Kt("web"), Kt("img"), F("transferFeeExtensionAuth"), P2("creatorFeeRate"), P2("platformVestingScale"), F("platformVestingWallet")]);
        r = Buffer.alloc(1 + 32 + 32 + 32 + 8 * 5 + 4 * 3 + Buffer.from(n.value.name, "utf-8").length + Buffer.from(n.value.web, "utf-8").length + Buffer.from(n.value.img, "utf-8").length + 32 + 8), s.encode({ index: 8, platformClaimFeeWallet: n.value.platformClaimFeeWallet, platformLockNftWallet: n.value.platformLockNftWallet, platformVestingWallet: n.value.platformVestingWallet, platformScale: n.value.migrateCpLockNftScale.platformScale, creatorScale: n.value.migrateCpLockNftScale.creatorScale, burnScale: n.value.migrateCpLockNftScale.burnScale, feeRate: n.value.feeRate, name: n.value.name, web: n.value.web, img: n.value.img, transferFeeExtensionAuth: n.value.transferFeeExtensionAuth, creatorFeeRate: n.value.creatorFeeRate, platformVestingScale: n.value.platformVestingScale }, r);
      } else if (n.type === "updateVestingWallet") {
        let s = V([W("index"), F("value")]);
        r = Buffer.alloc(s.span), s.encode({ index: 9, value: n.value }, r);
      } else if (n.type === "updatePlatformVestingScale") {
        let s = V([W("index"), P2("value")]);
        r = Buffer.alloc(s.span), s.encode({ index: 10, value: n.value }, r);
      } else
        throw Error("updateInfo params type error");
      return new Me.TransactionInstruction({ keys: o, programId: i, data: Buffer.from([...Rt.updatePlaformConfig, ...r]) });
    }
    function Qa(i, e, t, n, o, r, s, a) {
      let c = [{ pubkey: t, isSigner: true, isWritable: true }, { pubkey: n, isSigner: false, isWritable: false }, { pubkey: e, isSigner: false, isWritable: false }, { pubkey: o, isSigner: false, isWritable: true }, { pubkey: r, isSigner: false, isWritable: true }, { pubkey: s, isSigner: false, isWritable: false }, { pubkey: a, isSigner: false, isWritable: false }, { pubkey: Me.SystemProgram.programId, isSigner: false, isWritable: false }, { pubkey: fn.ASSOCIATED_TOKEN_PROGRAM_ID, isSigner: false, isWritable: false }];
      return new Me.TransactionInstruction({ keys: c, programId: i, data: Rt.claimPlatformFeeFromVault });
    }
    function ja(i, e, t, n, o, r, s) {
      let a = [{ pubkey: e, isSigner: true, isWritable: true }, { pubkey: t, isSigner: false, isWritable: false }, { pubkey: n, isSigner: false, isWritable: true }, { pubkey: o, isSigner: false, isWritable: true }, { pubkey: r, isSigner: false, isWritable: false }, { pubkey: s, isSigner: false, isWritable: false }, { pubkey: Me.SystemProgram.programId, isSigner: false, isWritable: false }, { pubkey: fn.ASSOCIATED_TOKEN_PROGRAM_ID, isSigner: false, isWritable: false }];
      return new Me.TransactionInstruction({ keys: a, programId: i, data: Rt.claimCreatorFee });
    }
    var pp = 255;
    var fl = new zn.default("18446744073709551615");
    function cg(i, e, t, n, o, r) {
      let s = [{ pubkey: e, isSigner: true, isWritable: true }, { pubkey: t, isSigner: false, isWritable: true }, { pubkey: n, isSigner: false, isWritable: false }, { pubkey: Me.SystemProgram.programId, isSigner: false, isWritable: false }], a = Buffer.alloc(1 * 2 + 8 * 6 + W().span);
      return W().encode(o, a), Da.encode({ migrateType: r.migrateType ? r.migrateType : pp, migrateCpmmFeeOn: r.migrateCpmmFeeOn ? r.migrateCpmmFeeOn : pp, supply: r.supply ? r.supply : new zn.default(0), totalSellA: r.totalSellA ? r.totalSellA : new zn.default(0), totalFundRaisingB: r.totalFundRaisingB ? r.totalFundRaisingB : new zn.default(0), totalLockedAmount: r.totalLockedAmount ? r.totalLockedAmount : fl, cliffPeriod: r.cliffPeriod ? r.cliffPeriod : fl, unlockPeriod: r.unlockPeriod ? r.unlockPeriod : fl }, a, 1), new Me.TransactionInstruction({ keys: s, programId: i, data: Buffer.from([...Rt.updatePlatformCurveParam, ...a]) });
    }
    function lg(i, e, t, n) {
      let o = [{ pubkey: e, isSigner: true, isWritable: false }, { pubkey: t, isSigner: false, isWritable: true }], r = Buffer.alloc(W().span);
      return W().encode(n, r), new Me.TransactionInstruction({ keys: o, programId: i, data: Buffer.from([...Rt.removePlatformCurveParam, ...r, 1, 2]) });
    }
    function kl(i, e, t, n, o, r) {
      let s = [{ pubkey: e, isSigner: true, isWritable: true }, { pubkey: t, isSigner: false, isWritable: true }, { pubkey: n, isSigner: false, isWritable: true }, { pubkey: o, isSigner: false, isWritable: true }, { pubkey: r, isSigner: false, isWritable: true }, { pubkey: Me.SystemProgram.programId, isSigner: false, isWritable: false }];
      return new Me.TransactionInstruction({ keys: s, programId: i, data: Rt.createPlatformVestingAccount });
    }
    var hl = ((t) => (t[t.OnlyTokenB = 0] = "OnlyTokenB", t[t.BothToken = 1] = "BothToken", t))(hl || {});
    var qr = Ae(require_bn());
    var ao = class {
      static getPoolInitPriceByPool({ poolInfo: e, decimalA: t, decimalB: n }) {
        throw Error();
      }
      static getPoolInitPriceByInit({ a: e, b: t, decimalA: n, decimalB: o }) {
        throw Error();
      }
      static getPoolPrice({ poolInfo: e, decimalA: t, decimalB: n }) {
        throw Error();
      }
      static getPoolEndPrice({ supply: e, totalSell: t, totalLockedAmount: n, totalFundRaising: o, migrateFee: r, decimalA: s, decimalB: a }) {
        throw Error();
      }
      static getPoolEndPriceReal({ poolInfo: e, decimalA: t, decimalB: n }) {
        throw Error();
      }
      static getInitParam({ supply: e, totalFundRaising: t, totalSell: n, totalLockedAmount: o, migrateFee: r }) {
        throw Error();
      }
      static buyExactIn({ poolInfo: e, amount: t }) {
        throw Error();
      }
      static buyExactOut({ poolInfo: e, amount: t }) {
        throw Error();
      }
      static sellExactIn({ poolInfo: e, amount: t }) {
        throw Error();
      }
      static sellExactOut({ poolInfo: e, amount: t }) {
        throw Error();
      }
    };
    var Ur = class extends ao {
      static getPoolInitPriceByPool({ poolInfo: e, decimalA: t, decimalB: n }) {
        return new O(e.virtualB.toString()).div(e.virtualA.toString()).mul(10 ** (t - n));
      }
      static getPoolInitPriceByInit({ a: e, b: t, decimalA: n, decimalB: o }) {
        return new O(t.toString()).div(e.toString()).mul(10 ** (n - o));
      }
      static getPoolPrice({ poolInfo: e, decimalA: t, decimalB: n }) {
        return new O(e.virtualB.add(e.realB).toString()).div(e.virtualA.sub(e.realA).toString()).mul(10 ** (t - n));
      }
      static getPoolEndPrice({ supply: e, totalSell: t, totalLockedAmount: n, totalFundRaising: o, migrateFee: r, decimalA: s, decimalB: a }) {
        return new O(o.sub(r).toString()).div(e.sub(t).sub(n).toString()).mul(10 ** (s - a));
      }
      static getPoolEndPriceReal({ poolInfo: e, decimalA: t, decimalB: n }) {
        let o = e.totalSellA.sub(e.realA), r = e.totalFundRaisingB.sub(e.realB);
        return new O(e.virtualB.add(e.realB.add(r)).toString()).div(e.virtualA.sub(e.realA.add(o)).toString()).mul(10 ** (t - n));
      }
      static getInitParam({ supply: e, totalFundRaising: t, totalSell: n, totalLockedAmount: o, migrateFee: r }) {
        if (e.lte(n))
          throw Error("supply need gt total sell");
        let s = e.sub(n).sub(o);
        if (s.lte(new qr.default(0)))
          throw Error("supplyMinusSellLocked <= 0");
        let a = t.sub(r);
        if (a.lte(new qr.default(0)))
          throw Error("tfMinusMf <= 0");
        let c = a.mul(n).mul(n).div(s), u = a.mul(n).div(s).sub(t), l = c.div(u), m = t.mul(t).div(u);
        if (l.lt(new qr.default(0)) || m.lt(new qr.default(0)))
          throw Error("invalid input 0");
        return { a: l, b: m, c: n };
      }
      static buyExactIn({ poolInfo: e, amount: t }) {
        return this.getAmountOut({ amountIn: t, inputReserve: e.virtualB.add(e.realB), outputReserve: e.virtualA.sub(e.realA) });
      }
      static buyExactOut({ poolInfo: e, amount: t }) {
        return this.getAmountIn({ amountOut: t, inputReserve: e.virtualB.add(e.realB), outputReserve: e.virtualA.sub(e.realA) });
      }
      static sellExactIn({ poolInfo: e, amount: t }) {
        return this.getAmountOut({ amountIn: t, inputReserve: e.virtualA.sub(e.realA), outputReserve: e.virtualB.add(e.realB) });
      }
      static sellExactOut({ poolInfo: e, amount: t }) {
        return this.getAmountIn({ amountOut: t, inputReserve: e.virtualA.sub(e.realA), outputReserve: e.virtualB.add(e.realB) });
      }
      static getAmountOut({ amountIn: e, inputReserve: t, outputReserve: n }) {
        let o = e.mul(n), r = t.add(e);
        return o.div(r);
      }
      static getAmountIn({ amountOut: e, inputReserve: t, outputReserve: n }) {
        let o = t.mul(e), r = n.sub(e);
        return Ao(o, r);
      }
    };
    var yn = Ae(require_bn());
    var Gr = Ae(require_bn());
    var Xr = class extends ao {
      static getPoolInitPriceByPool({ poolInfo: e, decimalA: t, decimalB: n }) {
        return new O(e.virtualB.toString()).div(e.virtualA.toString()).mul(10 ** (t - n));
      }
      static getPoolInitPriceByInit({ a: e, b: t, decimalA: n, decimalB: o }) {
        return new O(t.toString()).div(e.toString()).mul(10 ** (n - o));
      }
      static getPoolPrice({ poolInfo: e, decimalA: t, decimalB: n }) {
        return new O(e.virtualB.toString()).div(e.virtualA.toString()).mul(10 ** (t - n));
      }
      static getPoolEndPrice({ supply: e, totalSell: t, totalLockedAmount: n, totalFundRaising: o, migrateFee: r, decimalA: s, decimalB: a }) {
        return new O(o.sub(r).toString()).div(e.sub(t).sub(n).toString()).mul(10 ** (s - a));
      }
      static getPoolEndPriceReal({ poolInfo: e, decimalA: t, decimalB: n }) {
        let o = e.totalSellA.sub(e.realA), r = e.totalFundRaisingB.sub(e.realB);
        return new O(e.virtualB.add(e.realB).add(r).toString()).div(e.virtualA.sub(e.realA).add(o).toString()).mul(10 ** (t - n));
      }
      static getInitParam({ supply: e, totalFundRaising: t, totalSell: n, totalLockedAmount: o, migrateFee: r }) {
        let s = e.sub(o);
        if (s.lte(new Gr.default(0)))
          throw Error("invalid input 1");
        let a = new Gr.default(2).mul(t).sub(r), u = t.mul(s).div(a);
        if (u.lt(new Gr.default(0)) || t.lt(new Gr.default(0)))
          throw Error("invalid input 0");
        return { a: u, b: t, c: u };
      }
      static buyExactIn({ poolInfo: e, amount: t }) {
        return this.getAmountOut({ amountIn: t, initInput: e.virtualB, initOutput: e.virtualA });
      }
      static buyExactOut({ poolInfo: e, amount: t }) {
        return this.getAmountIn({ amountOut: t, initInput: e.virtualB, initOutput: e.virtualA });
      }
      static sellExactIn({ poolInfo: e, amount: t }) {
        return this.getAmountOut({ amountIn: t, initInput: e.virtualA, initOutput: e.virtualB });
      }
      static sellExactOut({ poolInfo: e, amount: t }) {
        return this.getAmountIn({ amountOut: t, initInput: e.virtualA, initOutput: e.virtualB });
      }
      static getAmountOut({ amountIn: e, initInput: t, initOutput: n }) {
        return n.mul(e).div(t);
      }
      static getAmountIn({ amountOut: e, initInput: t, initOutput: n }) {
        let o = t.mul(e);
        return Ao(o, n);
      }
    };
    var en = Ae(require_bn());
    var jo = Ae(require_bn());
    var Wi = class {
      static _multipler(e) {
        return new O(10).pow(e);
      }
      static getPrice({ priceX64: e, decimalA: t, decimalB: n }) {
        return new O(e.toString()).div(this._Q64).mul(this._multipler(t)).div(this._multipler(n));
      }
      static getPriceX64({ price: e, decimalA: t, decimalB: n }) {
        let o = e.mul(this._multipler(n)).div(this._multipler(t));
        return new jo.default(o.mul(this._Q64).toFixed(0));
      }
    };
    Wi._Q64 = new O(new jo.default(1).shln(64).toString());
    function mg({ supply: i, totalFundRaisingB: e, totalLockedAmount: t, totalSellA: n, migrateType: o, decimalsA: r }) {
      let s = i.sub(n).sub(t), a = new jo.default(new O(s.mul(e).toString()).sqrt().toFixed(0));
      if (o === "amm") {
        if (a.gt(new jo.default(10).pow(new jo.default(r))))
          return true;
      } else if (o === "cpmm") {
        if (a.gt(new jo.default(100)))
          return true;
      } else
        throw Error("migrate type error");
      return false;
    }
    var zr = class extends ao {
      static getPoolInitPriceByPool({ poolInfo: e, decimalA: t, decimalB: n }) {
        return new O(0);
      }
      static getPoolInitPriceByInit({ a: e, b: t, decimalA: n, decimalB: o }) {
        return new O(0);
      }
      static getPoolPrice({ poolInfo: e, decimalA: t, decimalB: n }) {
        return new O(e.virtualA.mul(e.realA).toString()).div(Wi._Q64).mul(10 ** (t - n));
      }
      static getPoolEndPrice({ supply: e, totalSell: t, totalLockedAmount: n, totalFundRaising: o, migrateFee: r, decimalA: s, decimalB: a }) {
        return new O(o.sub(r).toString()).div(e.sub(t).sub(n).toString()).mul(10 ** (s - a));
      }
      static getPoolEndPriceReal({ poolInfo: e, decimalA: t, decimalB: n }) {
        let o = e.totalSellA.sub(e.realA), r = e.totalFundRaisingB.sub(e.realB);
        return new O(e.virtualB.add(e.realB).add(r).toString()).div(e.virtualA.sub(e.realA).add(o).toString()).mul(10 ** (t - n));
      }
      static getInitParam({ supply: e, totalFundRaising: t, totalSell: n, totalLockedAmount: o, migrateFee: r }) {
        let s = e.sub(o);
        if (s.lte(new en.default(0)))
          throw Error("supplyMinusLocked need gt 0");
        let a = t.mul(new en.default(3)).sub(r), u = t.mul(new en.default(2)).mul(s).div(a), l = u.mul(u), m = t.mul(new en.default(2)).mul(Pt).div(l);
        if (!m.gt(new en.default(0)))
          throw Error("a need gt 0");
        if (!ki.gt(m))
          throw Error("a need lt u64 max");
        if (m.lt(new en.default(0)) || u.lt(new en.default(0)))
          throw Error("invalid input 0");
        return { a: m, b: new en.default(0), c: u };
      }
      static buyExactIn({ poolInfo: e, amount: t }) {
        let n = e.realB.add(t), o = new en.default(2).mul(n).mul(Pt).div(e.virtualA);
        return new en.default(new O(o.toString()).sqrt().toFixed(0)).sub(e.realA);
      }
      static buyExactOut({ poolInfo: e, amount: t }) {
        let n = e.realA.add(t), o = n.mul(n);
        return Ao(e.virtualA.mul(o), new en.default(2).mul(Pt)).sub(e.realB);
      }
      static sellExactIn({ poolInfo: e, amount: t }) {
        let n = e.realA.sub(t), o = n.mul(n), r = Ao(e.virtualA.mul(o), new en.default(2).mul(Pt));
        return e.realB.sub(r);
      }
      static sellExactOut({ poolInfo: e, amount: t }) {
        let n = e.realB.sub(t), o = new en.default(2).mul(n).mul(Pt).div(e.virtualA), r = new en.default(new O(o.toString()).sqrt().toFixed(0));
        return e.realA.sub(r);
      }
    };
    var Yt = class {
      static getPoolCurvePointByPoolInfo({ curveType: e, pointCount: t, poolInfo: n }) {
        return this.getPoolCurvePointByInit({ curveType: e, pointCount: t, supply: n.supply, totalFundRaising: n.totalFundRaisingB, totalSell: n.totalSellA, totalLockedAmount: n.vestingSchedule.totalLockedAmount, migrateFee: n.migrateFee, decimalA: n.mintDecimalsA, decimalB: n.mintDecimalsB });
      }
      static getPoolCurvePointByInit({ curveType: e, pointCount: t, supply: n, totalFundRaising: o, totalSell: r, totalLockedAmount: s, migrateFee: a, decimalA: c, decimalB: u }) {
        if (t < 3)
          throw Error("point count < 3");
        let l = this.getCurve(e), m = l.getInitParam({ supply: n, totalFundRaising: o, totalSell: r, totalLockedAmount: s, migrateFee: a }), d = l.getPoolInitPriceByInit(U(E({}, m), { decimalA: c, decimalB: u })), p = o.div(new yn.default(t - 1)), f = new yn.default(0), y = [{ price: d, totalSellSupply: 0 }], { a: b, b: g } = m, A = f, k = f;
        for (let I = 1; I < t; I++) {
          let T = I !== t - 1 ? p : o.sub(k), h = this.buyExactIn({ poolInfo: { virtualA: b, virtualB: g, realA: A, realB: k, totalFundRaisingB: o, totalSellA: r }, amountB: T, protocolFeeRate: f, platformFeeRate: f, curveType: e, shareFeeRate: f, creatorFeeRate: f, transferFeeConfigA: void 0, slot: 0 });
          A = A.add(h.amountA.amount), k = k.add(h.amountB);
          let S = this.getPrice({ poolInfo: { virtualA: b, virtualB: g, realA: A, realB: k }, decimalA: c, decimalB: u, curveType: e });
          y.push({ price: S, totalSellSupply: new O(A.toString()).div(10 ** c).toNumber() });
        }
        return y;
      }
      static getPoolInitPriceByPool({ poolInfo: e, decimalA: t, decimalB: n, curveType: o }) {
        return this.getCurve(o).getPoolInitPriceByPool({ poolInfo: e, decimalA: t, decimalB: n });
      }
      static getPoolInitPriceByInit({ a: e, b: t, decimalA: n, decimalB: o, curveType: r }) {
        return this.getCurve(r).getPoolInitPriceByInit({ a: e, b: t, decimalA: n, decimalB: o });
      }
      static getPrice({ poolInfo: e, curveType: t, decimalA: n, decimalB: o }) {
        return this.getCurve(t).getPoolPrice({ poolInfo: e, decimalA: n, decimalB: o });
      }
      static getEndPrice({ poolInfo: e, curveType: t, decimalA: n, decimalB: o }) {
        return this.getCurve(t).getPoolPrice({ poolInfo: e, decimalA: n, decimalB: o });
      }
      static getPoolEndPriceReal({ poolInfo: e, curveType: t, decimalA: n, decimalB: o }) {
        return this.getCurve(t).getPoolEndPriceReal({ poolInfo: e, decimalA: n, decimalB: o });
      }
      static checkParam({ supply: e, totalFundRaising: t, totalSell: n, totalLockedAmount: o, decimals: r, config: s, migrateType: a }) {
        if (Number(r) !== 6)
          throw Error("decimals = 6");
        if (e.mul(s.maxLockRate).div(jt).lt(o))
          throw Error("total lock amount gte max lock amount");
        if (e.lt(s.minSupplyA.mul(new yn.default(10 ** r))))
          throw Error("supply lt min supply");
        let u = e.mul(s.minSellRateA).div(jt);
        if (n.lt(u))
          throw Error("invalid input");
        if (t.lt(s.minFundRaisingB))
          throw Error("total fund raising lt min fund raising");
        let l = e.sub(n).sub(o), m = e.mul(s.minMigrateRateA).div(jt);
        if (l.lt(m))
          throw Error("migrate lt min migrate amoount");
        let d = e.sub(n).sub(o), p = new yn.default(new O(d.mul(t).toString()).sqrt().toFixed(0));
        if (a === "amm") {
          let f = new yn.default(10).pow(new yn.default(r));
          if (p.lte(f))
            throw Error("check migrate lp error");
        } else if (a === "cpmm") {
          let f = new yn.default(100);
          if (p.lte(f))
            throw Error("check migrate lp error");
        } else
          throw Error("migrate type error");
      }
      static buyExactIn({ poolInfo: e, amountB: t, protocolFeeRate: n, platformFeeRate: o, curveType: r, shareFeeRate: s, creatorFeeRate: a, transferFeeConfigA: c, slot: u }) {
        let l = this.totalFeeRate({ protocolFeeRate: n, platformFeeRate: o, shareFeeRate: s, creatorFeeRate: a }), m = this.calculateFee({ amount: t, feeRate: l }), d = t.sub(m), p = this.getCurve(r), f = p.buyExactIn({ poolInfo: e, amount: d }), y = e.totalSellA.sub(e.realA), b, g, A;
        if (f.gt(y)) {
          b = y;
          let I = p.buyExactOut({ poolInfo: e, amount: b });
          g = this.calculatePreFee({ postFeeAmount: I, feeRate: l }), A = g.sub(I);
        } else
          b = f, g = t, A = m;
        let k = this.splitFee({ totalFee: A, protocolFeeRate: n, platformFeeRate: o, shareFeeRate: s, creatorFeeRate: a });
        return { amountA: Rs(b, c, u), amountB: g, splitFee: k };
      }
      static buyExactOut({ poolInfo: e, amountA: t, protocolFeeRate: n, platformFeeRate: o, curveType: r, shareFeeRate: s, creatorFeeRate: a, transferFeeConfigA: c, slot: u }) {
        let l = e.totalSellA.sub(e.realA), m = Ls(t, c, u), d = m.fee ? m.amount.add(m.fee) : m.amount;
        t.gt(l) && (d = l);
        let f = this.getCurve(r).buyExactOut({ poolInfo: e, amount: d }), y = this.totalFeeRate({ protocolFeeRate: n, platformFeeRate: o, shareFeeRate: s, creatorFeeRate: a }), b = this.calculatePreFee({ postFeeAmount: f, feeRate: y }), g = b.sub(f), A = this.splitFee({ totalFee: g, protocolFeeRate: n, platformFeeRate: o, shareFeeRate: s, creatorFeeRate: a });
        return { amountA: m, amountB: b, splitFee: A };
      }
      static sellExactIn({ poolInfo: e, amountA: t, protocolFeeRate: n, platformFeeRate: o, curveType: r, shareFeeRate: s, creatorFeeRate: a, transferFeeConfigA: c, slot: u }) {
        let l = this.getCurve(r), m = Rs(t, c, u), d = m.fee ? m.amount.sub(m.fee) : m.amount, p = l.sellExactIn({ poolInfo: e, amount: d }), f = this.calculateFee({ amount: p, feeRate: this.totalFeeRate({ protocolFeeRate: n, platformFeeRate: o, shareFeeRate: s, creatorFeeRate: a }) }), y = this.splitFee({ totalFee: f, protocolFeeRate: n, platformFeeRate: o, shareFeeRate: s, creatorFeeRate: a });
        return { amountA: m, amountB: p.sub(f), splitFee: y };
      }
      static sellExactOut({ poolInfo: e, amountB: t, protocolFeeRate: n, platformFeeRate: o, curveType: r, shareFeeRate: s, creatorFeeRate: a, transferFeeConfigA: c, slot: u }) {
        let l = this.totalFeeRate({ protocolFeeRate: n, platformFeeRate: o, shareFeeRate: s, creatorFeeRate: a }), m = this.calculatePreFee({ postFeeAmount: t, feeRate: l });
        if (e.realB.lt(m))
          throw Error("Insufficient liquidity");
        let d = m.sub(t), f = Yt.getCurve(r).sellExactOut({ poolInfo: e, amount: m });
        if (f.gt(e.realA))
          throw Error();
        let y = this.splitFee({ totalFee: d, protocolFeeRate: n, platformFeeRate: o, shareFeeRate: s, creatorFeeRate: a });
        return { amountA: Ls(f, c, u), amountB: t, splitFee: y };
      }
      static splitFee({ totalFee: e, protocolFeeRate: t, platformFeeRate: n, shareFeeRate: o, creatorFeeRate: r }) {
        let s = this.totalFeeRate({ protocolFeeRate: t, platformFeeRate: n, shareFeeRate: o, creatorFeeRate: r }), a = s.isZero() ? new yn.default(0) : e.mul(n).div(s), c = s.isZero() ? new yn.default(0) : e.mul(o).div(s), u = s.isZero() ? new yn.default(0) : e.mul(r).div(s), l = e.sub(a).sub(c).sub(u);
        return { platformFee: a, shareFee: c, protocolFee: l, creatorFee: u };
      }
      static calculateFee({ amount: e, feeRate: t }) {
        return oi(e, t, jt);
      }
      static calculatePreFee({ postFeeAmount: e, feeRate: t }) {
        if (t.isZero())
          return e;
        let n = e.mul(jt), o = jt.sub(t);
        return n.add(o).sub(new yn.default(1)).div(o);
      }
      static totalFeeRate({ protocolFeeRate: e, platformFeeRate: t, shareFeeRate: n, creatorFeeRate: o }) {
        if (e.add(t).add(n).add(o).gt(new yn.default(1e6)))
          throw Error("total fee rate gt 1_000_000");
        return e.add(t).add(n).add(o);
      }
      static getCurve(e) {
        switch (e) {
          case 0:
            return Ur;
          case 1:
            return Xr;
          case 2:
            return zr;
        }
        throw Error("find curve error");
      }
    };
    var J = require_cjs4();
    var ce = Ae(require_bn());
    var Qr = require("@solana/web3.js");
    var Yr = { initPriceX64: new ce.default("515752397214619"), supply: new ce.default(1e15), totalSellA: new ce.default(7931e11), totalFundRaisingB: new ce.default(85e9), totalFundRaisingBUSD: new ce.default(125e8), totalLockedAmount: new ce.default("0"), cliffPeriod: new ce.default("0"), unlockPeriod: new ce.default("0"), decimals: 6, virtualA: new ce.default("1073471847374405"), virtualB: new ce.default("30050573465"), realA: new ce.default(0), realB: new ce.default(0), protocolFee: new ce.default(0), platformId: new Qr.PublicKey("4Bu96XjU84XjPDSpveTVf6LYGCkfW5FK7SNkREWcEfV4"), vestingSchedule: { totalLockedAmount: new ce.default(0), cliffPeriod: new ce.default(0), unlockPeriod: new ce.default(0), startTime: new ce.default(0), totalAllocatedShare: new ce.default(0) } };
    var Co = new ce.default(1e4);
    var dg = /* @__PURE__ */ new Set(["USDCoctVLVnvTXBEuP9s8hntucdJokbo17RwHuNXemT", "USD1ttGY1N17NEEHLmELoaybftRBUSErhqYiQzvEmuB"]);
    var Hr = class extends Je {
      constructor(e) {
        super(e);
      }
      async createLaunchpad(N) {
        var v = N, { programId: e = pt, authProgramId: t, platformId: n = Yr.platformId, mintA: o, decimals: r = 6, mintBDecimals: s = 9, name: a, symbol: c, uri: u, migrateType: l, configId: m, configInfo: d, platformFeeRate: p, platformVestingScale: f, txVersion: y, computeBudgetConfig: b, txTipConfig: g, feePayer: A, buyAmount: k, minMintAAmount: I, slippage: T, associatedOnly: h = true, checkCreateATAOwner: S = false, extraSigners: x, token2022: K, transferFeeExtensionParams: B, creatorFeeOn: C = 0 } = v, R = tt(v, ["programId", "authProgramId", "platformId", "mintA", "decimals", "mintBDecimals", "name", "symbol", "uri", "migrateType", "configId", "configInfo", "platformFeeRate", "platformVestingScale", "txVersion", "computeBudgetConfig", "txTipConfig", "feePayer", "buyAmount", "minMintAAmount", "slippage", "associatedOnly", "checkCreateATAOwner", "extraSigners", "token2022", "transferFeeExtensionParams", "creatorFeeOn"]);
        var xl, Sl, Kl, Cl, Rl, Ll, Nl, Ol, Ml, vl, Fl;
        let L = this.createTxBuilder(A);
        t = t != null ? t : an(e).publicKey, K = !!B, K && (l = "cpmm");
        let M = d;
        if (!M && m) {
          let Hn = await this.scope.connection.getAccountInfo(m);
          Hn && (M = ro.decode(Hn.data));
        }
        M || this.logAndCreateError("config not found");
        let Y = M.mintB, j = M.curveType, { publicKey: le } = Ho(e, o, Y), { publicKey: be } = qa(e, le, o), { publicKey: me } = qa(e, le, Y), { publicKey: Ie } = Un(o);
        this.logDebug(`create token: ${o.toBase58()}, mintB: ${Y.toBase58()}, decimals A:${r}/B:${s}, config:${m.toBase58()}`), c.length > 10 && this.logAndCreateError("Symbol length should shorter than 11"), u || this.logAndCreateError("uri should not empty");
        let ue = (await this.scope.api.fetchLaunchConfigs()).find((Hn) => Hn.key.pubKey === m.toBase58()), ie = (xl = R == null ? void 0 : R.supply) != null ? xl : new ce.default(ue.defaultParams.supplyInit), We = (Sl = R == null ? void 0 : R.totalSellA) != null ? Sl : new ce.default(ue.defaultParams.totalSellA), He = (Kl = R == null ? void 0 : R.totalFundRaisingB) != null ? Kl : new ce.default(ue.defaultParams.totalFundRaisingB), Se = (Cl = R == null ? void 0 : R.totalLockedAmount) != null ? Cl : new ce.default(0), Vt = await this.scope.connection.getAccountInfo(n);
        Vt || this.logAndCreateError("platform id not found:", n.toString());
        let un = Xn.decode(Vt.data), bt = un.platformVestingScale, Zo = un.feeRate, es = Yt.getCurve(M.curveType).getInitParam({ supply: ie, totalFundRaising: He, totalSell: We, totalLockedAmount: Se, migrateFee: M.migrateFee }), Lo;
        try {
          Lo = await this.scope.token.getTokenInfo(Y);
        } catch {
          this.logDebug("can not get mintB info from getTokenInfo");
        }
        let bn = { epoch: new ce.default(896), bump: 254, status: 0, mintDecimalsA: r, mintDecimalsB: (Rl = Lo == null ? void 0 : Lo.decimals) != null ? Rl : s, supply: ie, totalSellA: We, mintA: new Qr.PublicKey(o), mintB: Y, virtualA: es.a, virtualB: es.b, realA: Yr.realA, realB: Yr.realB, migrateFee: M.migrateFee, migrateType: l === "amm" ? 0 : 1, protocolFee: Yr.protocolFee, platformFee: Zo, platformId: n, configId: m, vaultA: be, vaultB: me, creator: this.scope.ownerPubKey, totalFundRaisingB: He, vestingSchedule: { totalLockedAmount: Se, cliffPeriod: new ce.default(0), unlockPeriod: new ce.default(0), startTime: new ce.default(0), totalAllocatedShare: new ce.default(0) }, mintProgramFlag: K ? 1 : 0, cpmmCreatorFeeOn: C, platformVestingShare: bt != null ? bt : new ce.default(0) }, ts = Yt.getCurve(M.curveType), { c: ns } = ts.getInitParam({ supply: bn.supply, totalFundRaising: bn.totalFundRaisingB, totalLockedAmount: Se, totalSell: M.curveType === 0 ? bn.totalSellA : new ce.default(0), migrateFee: M.migrateFee });
        try {
          Yt.checkParam({ supply: bn.supply, totalFundRaising: bn.totalFundRaisingB, totalSell: ns, totalLockedAmount: Se, decimals: bn.mintDecimalsA, config: M, migrateType: l }), this.logDebug("check init params success");
        } catch (Hn) {
          this.logAndCreateError(`check create mint params failed, ${Hn.message}`);
        }
        L.addInstruction({ instructions: [K ? bl(e, A != null ? A : this.scope.ownerPubKey, this.scope.ownerPubKey, m, n, t, le, o, Y, be, me, r, a, c, u || "https://", { type: j === 0 ? "ConstantCurve" : j === 1 ? "FixedCurve" : j === 2 ? "LinearCurve" : "ConstantCurve", totalSellA: We, migrateType: l, supply: ie, totalFundRaisingB: He }, Se, (Ll = R == null ? void 0 : R.cliffPeriod) != null ? Ll : new ce.default(0), (Nl = R == null ? void 0 : R.unlockPeriod) != null ? Nl : new ce.default(0), C, B) : yl(e, A != null ? A : this.scope.ownerPubKey, this.scope.ownerPubKey, m, n, t, le, o, Y, be, me, Ie, r, a, c, u || "https://", { type: j === 0 ? "ConstantCurve" : j === 1 ? "FixedCurve" : j === 2 ? "LinearCurve" : "ConstantCurve", totalSellA: We, migrateType: l, supply: ie, totalFundRaisingB: He }, Se, (Ol = R == null ? void 0 : R.cliffPeriod) != null ? Ol : new ce.default(0), (Ml = R == null ? void 0 : R.unlockPeriod) != null ? Ml : new ce.default(0), C)] });
        let tn = K ? await this.scope.connection.getEpochInfo() : void 0, $o = B ? { epoch: BigInt((tn == null ? void 0 : tn.epoch) || 0), maximumFee: BigInt((vl = B == null ? void 0 : B.maxinumFee.toString()) != null ? vl : 0), transferFeeBasisPoints: (Fl = B == null ? void 0 : B.transferFeeBasePoints) != null ? Fl : 0 } : void 0, eu = { amountA: { amount: new ce.default(0), fee: void 0, expirationTime: void 0 }, amountB: new ce.default(0), splitFee: { platformFee: new ce.default(0), shareFee: new ce.default(0), protocolFee: new ce.default(0), creatorFee: new ce.default(0) } }, tu;
        if (x != null && x.length && L.addInstruction({ signers: x }), !R.createOnly) {
          let { builder: Hn, extInfo: gp } = await this.buyToken({ programId: e, authProgramId: t, mintAProgram: K ? J.TOKEN_2022_PROGRAM_ID : void 0, mintA: o, mintB: Y, poolInfo: bn, buyAmount: k, minMintAAmount: I, shareFeeRate: R.shareFeeRate, shareFeeReceiver: R.shareFeeReceiver, configInfo: M, platformFeeRate: Zo, slippage: T, associatedOnly: h, checkCreateATAOwner: S, skipCheckMintA: !$o, transferFeeConfigA: $o ? { transferFeeConfigAuthority: t, withdrawWithheldAuthority: t, withheldAmount: BigInt(0), olderTransferFee: $o, newerTransferFee: $o } : void 0, fromCreate: true });
          L.addInstruction(E({}, Hn.AllTxData)), eu = E({}, gp), tu = (this.scope.cluster === "devnet" || y === 1) && R.shareFeeReceiver ? [Hn.allInstructions[0]] : void 0;
        }
        return L.addTipInstruction(g), y === 0 ? L.sizeCheckBuildV0({ computeBudgetConfig: b, swapInfo: eu, splitIns: tu, address: U(E({}, bn), { poolId: le }) }) : L.sizeCheckBuild({ computeBudgetConfig: b, swapInfo: eu, splitIns: tu, address: U(E({}, bn), { poolId: le }) });
      }
      async buyToken({ programId: e = pt, authProgramId: t, mintA: n, mintAProgram: o = J.TOKEN_PROGRAM_ID, mintB: r = J.NATIVE_MINT, poolInfo: s, configInfo: a, platformFeeRate: c, txVersion: u, computeBudgetConfig: l, txTipConfig: m, feePayer: d, buyAmount: p, minMintAAmount: f, slippage: y, shareFeeRate: b = new ce.default(0), shareFeeReceiver: g, associatedOnly: A = true, checkCreateATAOwner: k = false, fromCreate: I = false, transferFeeConfigA: T, skipCheckMintA: h = false }) {
        var ie, We, He;
        p.lte(new ce.default(0)) && this.logAndCreateError("buy amount should gt 0:", p.toString());
        let S = this.createTxBuilder(d), { publicKey: x } = Ho(e, n, r);
        t = t != null ? t : an(e).publicKey;
        let K = T;
        if (!h)
          if (K)
            o = J.TOKEN_2022_PROGRAM_ID;
          else {
            let Se = await this.scope.connection.getAccountInfo(n);
            if (Se && Se.owner.equals(J.TOKEN_2022_PROGRAM_ID)) {
              o = Se.owner;
              let Vt = (0, J.unpackMint)(n, Se, o);
              K = (0, J.getTransferFeeConfig)(Vt) || void 0;
            }
          }
        let B = this.scope.account.getAssociatedTokenAccount(n, o), C = r.equals(J.NATIVE_MINT), R = I && C, N = R ? this.scope.account.getAssociatedTokenAccount(r, J.TOKEN_PROGRAM_ID) : null, v = C;
        if (S.addInstruction({ instructions: [(0, J.createAssociatedTokenAccountIdempotentInstruction)(this.scope.ownerPubKey, B, this.scope.ownerPubKey, n, o), ...R ? [(0, J.createAssociatedTokenAccountIdempotentInstruction)(this.scope.ownerPubKey, N, this.scope.ownerPubKey, r, J.TOKEN_PROGRAM_ID), Qr.SystemProgram.transfer({ fromPubkey: this.scope.ownerPubKey, toPubkey: N, lamports: BigInt(p.toString()) }), (0, J.createSyncNativeInstruction)(N)] : []] }), !R) {
          let { account: Se, instructionParams: Vt } = await this.scope.account.getOrCreateTokenAccount({ mint: r, owner: this.scope.ownerPubKey, createInfo: v ? { payer: this.scope.ownerPubKey, amount: p } : void 0, skipCloseAccount: !v, notUseTokenAccount: v, associatedOnly: v ? false : A, checkCreateATAOwner: k });
          Se && (N = Se), S.addInstruction(Vt || {});
        }
        N || this.logAndCreateError(`cannot found mintB(${r.toBase58()}) buy token accounts`, "tokenAccounts", this.scope.account.tokenAccounts);
        let L = s;
        if (!L) {
          let Se = await this.scope.connection.getAccountInfo(x, { commitment: "processed" });
          Se || this.logAndCreateError("cannot found pool:", x.toBase58()), L = In.decode(Se.data);
        }
        let M = a, Y = await ze(this.scope.connection, [M ? void 0 : L.configId, L.platformId].filter(Boolean).map((Se) => ({ pubkey: Se })));
        if (!M) {
          let Se = Y.find((Vt) => Vt.pubkey.equals(L.configId));
          (!Se || !Se.accountInfo) && this.logAndCreateError("config not found: ", L.configId.toBase58()), M = ro.decode(Se.accountInfo.data);
        }
        let j = Y.find((Se) => Se.pubkey.equals(L.platformId));
        (!j || !j.accountInfo) && this.logAndCreateError("platform info not found: ", L.configId.toBase58());
        let le = Xn.decode(j.accountInfo.data);
        c = c || le.feeRate;
        let be = Yt.buyExactIn({ poolInfo: L, amountB: p, protocolFeeRate: M.tradeFeeRate, platformFeeRate: c, curveType: M.curveType, shareFeeRate: b, creatorFeeRate: le.creatorFeeRate, transferFeeConfigA: K, slot: await this.scope.connection.getSlot() }), me = new O(be.amountA.amount.toString()).sub((We = (ie = be.amountA.fee) == null ? void 0 : ie.toString()) != null ? We : 0), Ie = y ? new O(Co.sub(y).toNumber() / Co.toNumber()).clampedTo(0, 1) : new O(1), he = f != null ? f : y ? new ce.default(me.mul(Ie).toFixed(0)) : be.amountA.amount.sub((He = be.amountA.fee) != null ? He : new ce.default(0));
        be.amountB.lt(p) && console.log(`maximum ${n.toBase58()} amount can buy is ${be.amountA.toString()}, input ${r.toBase58()} amount: ${be.amountB.toString()}`);
        let ue = g ? te(g, r, J.TOKEN_PROGRAM_ID).publicKey : void 0;
        return ue && S.addInstruction({ instructions: [(0, J.createAssociatedTokenAccountIdempotentInstruction)(this.scope.ownerPubKey, ue, g, r)] }), S.addInstruction({ instructions: [Wr(e, this.scope.ownerPubKey, t, L.configId, L.platformId, x, B, N, L.vaultA, L.vaultB, n, r, o, J.TOKEN_PROGRAM_ID, Mn(e, L.platformId, r).publicKey, vn(e, L.creator, r).publicKey, be.amountB.lt(p) ? be.amountB : p, he, b, ue)] }), S.addCustomComputeBudget(l), S.addTipInstruction(m), S.versionBuild({ txVersion: u, extInfo: U(E({}, be), { decimalOutAmount: me, minDecimalOutAmount: new O(he.toString()) }) });
      }
      async buyTokenExactOut({ programId: e = pt, authProgramId: t, mintA: n, mintAProgram: o = J.TOKEN_PROGRAM_ID, mintB: r = J.NATIVE_MINT, poolInfo: s, configInfo: a, transferFeeConfigA: c, platformFeeRate: u, txVersion: l, computeBudgetConfig: m, txTipConfig: d, feePayer: p, maxBuyAmount: f, outAmount: y, slippage: b, shareFeeRate: g = new ce.default(0), shareFeeReceiver: A, associatedOnly: k = true, checkCreateATAOwner: I = false, skipCheckMintA: T = false }) {
        y.lte(new ce.default(0)) && this.logAndCreateError("out amount should gt 0:", y.toString());
        let h = this.createTxBuilder(p), { publicKey: S } = Ho(e, n, r);
        t = t != null ? t : an(e).publicKey;
        let x = s;
        if (!x) {
          let ue = await this.scope.connection.getAccountInfo(S, { commitment: "processed" });
          ue || this.logAndCreateError("cannot found pool:", S.toBase58()), x = In.decode(ue.data);
        }
        let K = a, B = await ze(this.scope.connection, [K ? void 0 : x.configId, x.platformId].filter(Boolean).map((ue) => ({ pubkey: ue })));
        if (!K) {
          let ue = B.find((ie) => ie.pubkey.equals(x.configId));
          (!ue || !ue.accountInfo) && this.logAndCreateError("config not found: ", x.configId.toBase58()), K = ro.decode(ue.accountInfo.data);
        }
        let C = B.find((ue) => ue.pubkey.equals(x.platformId));
        (!C || !C.accountInfo) && this.logAndCreateError("platform info not found: ", x.configId.toBase58());
        let R = Xn.decode(C.accountInfo.data);
        u = u || R.feeRate;
        let N = c;
        if (!T)
          if (N)
            o = J.TOKEN_2022_PROGRAM_ID;
          else {
            let ue = await this.scope.connection.getAccountInfo(n);
            if (ue && ue.owner.equals(J.TOKEN_2022_PROGRAM_ID)) {
              o = ue.owner;
              let ie = (0, J.unpackMint)(n, ue, o);
              N = (0, J.getTransferFeeConfig)(ie) || void 0;
            }
          }
        let v = Yt.buyExactOut({ poolInfo: x, amountA: y, protocolFeeRate: K.tradeFeeRate, platformFeeRate: u, curveType: K.curveType, shareFeeRate: g, creatorFeeRate: R.creatorFeeRate, transferFeeConfigA: N, slot: await this.scope.connection.getSlot() }), L = new O(v.amountB.toString()), M = b ? new O(Co.add(b).toNumber() / Co.toNumber()).clampedTo(0, Number.MIN_SAFE_INTEGER) : new O(1), Y = (f != null ? f : b) ? new ce.default(L.mul(M).toFixed(0)) : v.amountB, j = this.scope.account.getAssociatedTokenAccount(n, o), le = null, be = r.equals(J.NATIVE_MINT);
        h.addInstruction({ instructions: [(0, J.createAssociatedTokenAccountIdempotentInstruction)(this.scope.ownerPubKey, j, this.scope.ownerPubKey, n, o)] });
        let { account: me, instructionParams: Ie } = await this.scope.account.getOrCreateTokenAccount({ mint: r, owner: this.scope.ownerPubKey, createInfo: be ? { payer: this.scope.ownerPubKey, amount: v.amountB } : void 0, skipCloseAccount: !be, notUseTokenAccount: be, associatedOnly: be ? false : k, checkCreateATAOwner: I });
        me && (le = me), h.addInstruction(Ie || {}), le === void 0 && this.logAndCreateError(`cannot found mintB(${r.toBase58()}) token accounts`, "tokenAccounts", this.scope.account.tokenAccounts);
        let he = A ? te(A, r, J.TOKEN_PROGRAM_ID).publicKey : void 0;
        return he && h.addInstruction({ instructions: [(0, J.createAssociatedTokenAccountIdempotentInstruction)(this.scope.ownerPubKey, he, A, r)] }), h.addInstruction({ instructions: [gl(e, this.scope.ownerPubKey, t, x.configId, x.platformId, S, j, le, x.vaultA, x.vaultB, n, r, o, J.TOKEN_PROGRAM_ID, Mn(e, x.platformId, r).publicKey, vn(e, x.creator, r).publicKey, y, Y, g, he)] }), h.addCustomComputeBudget(m), h.addTipInstruction(d), h.versionBuild({ txVersion: l, extInfo: { maxSpentAmount: Y, outAmount: y } });
      }
      async sellToken({ programId: e = pt, authProgramId: t, mintAProgram: n = J.TOKEN_PROGRAM_ID, mintA: o, mintB: r = J.NATIVE_MINT, poolInfo: s, configInfo: a, platformFeeRate: c, txVersion: u, computeBudgetConfig: l, txTipConfig: m, feePayer: d, sellAmount: p, minAmountB: f, slippage: y, shareFeeRate: b = new ce.default(0), shareFeeReceiver: g, associatedOnly: A = true, checkCreateATAOwner: k = false, skipCheckMintA: I = false }) {
        t = t != null ? t : an(e).publicKey;
        let T = this.createTxBuilder(d);
        p.lte(new ce.default(0)) && this.logAndCreateError("sell amount should be gt 0");
        let { publicKey: h } = Ho(e, o, r), S;
        if (!I) {
          let ie = await this.scope.connection.getAccountInfo(o);
          if (ie && ie.owner.equals(J.TOKEN_2022_PROGRAM_ID)) {
            n = ie.owner;
            let We = (0, J.unpackMint)(o, ie, n);
            S = (0, J.getTransferFeeConfig)(We) || void 0;
          }
        }
        let x = null, K = null, B = r.equals(J.NATIVE_MINT), { account: C, instructionParams: R } = await this.scope.account.getOrCreateTokenAccount({ tokenProgram: n, mint: o, owner: this.scope.ownerPubKey, createInfo: void 0, skipCloseAccount: true, notUseTokenAccount: false, associatedOnly: A, checkCreateATAOwner: k });
        C && (x = C), T.addInstruction(R || {}), x === void 0 && this.logAndCreateError("cannot found mintA token accounts", "tokenAccounts", this.scope.account.tokenAccounts);
        let { account: N, instructionParams: v } = await this.scope.account.getOrCreateTokenAccount({ mint: r, owner: this.scope.ownerPubKey, createInfo: B ? { payer: this.scope.ownerPubKey, amount: 0 } : void 0, skipCloseAccount: !B, notUseTokenAccount: B, associatedOnly: B ? false : A, checkCreateATAOwner: k });
        N && (K = N), T.addInstruction(v || {}), K === void 0 && this.logAndCreateError("cannot found mintB token accounts", "tokenAccounts", this.scope.account.tokenAccounts);
        let L = s;
        if (!L) {
          let ie = await this.scope.connection.getAccountInfo(h, { commitment: "processed" });
          ie || this.logAndCreateError("cannot found pool", h.toBase58()), L = In.decode(ie.data);
        }
        let M = a, Y = await ze(this.scope.connection, [M ? void 0 : L.configId, L.platformId].filter(Boolean).map((ie) => ({ pubkey: ie })));
        if (!M) {
          let ie = Y.find((We) => We.pubkey.equals(L.configId));
          (!ie || !ie.accountInfo) && this.logAndCreateError("config not found: ", L.configId.toBase58()), M = ro.decode(ie.accountInfo.data);
        }
        let j = Y.find((ie) => ie.pubkey.equals(L.platformId));
        (!j || !j.accountInfo) && this.logAndCreateError("platform info not found: ", L.configId.toBase58());
        let le = Xn.decode(j.accountInfo.data);
        c = c || le.feeRate;
        let be = Yt.sellExactIn({ poolInfo: L, amountA: p, protocolFeeRate: M.tradeFeeRate, platformFeeRate: c, curveType: M.curveType, shareFeeRate: b, creatorFeeRate: le.creatorFeeRate, transferFeeConfigA: S, slot: await this.scope.connection.getSlot() }), me = new O(be.amountB.toString()), Ie = y ? new O(Co.sub(y).toNumber() / Co.toNumber()).clampedTo(0, 1) : new O(1), he = f != null ? f : y ? new ce.default(me.mul(Ie).toFixed(0)) : be.amountB;
        he.lte(new ce.default(0)) && this.logAndCreateError(`out ${r.toBase58()} amount should be gt 0`);
        let ue = g ? te(g, r, J.TOKEN_PROGRAM_ID).publicKey : void 0;
        return ue && T.addInstruction({ instructions: [(0, J.createAssociatedTokenAccountIdempotentInstruction)(this.scope.ownerPubKey, ue, g, r)] }), T.addInstruction({ instructions: [Dr(e, this.scope.ownerPubKey, t, L.configId, L.platformId, h, x, K, L.vaultA, L.vaultB, o, r, n, J.TOKEN_PROGRAM_ID, Mn(e, L.platformId, r).publicKey, vn(e, L.creator, r).publicKey, be.amountA.amount.lt(p) ? be.amountA.amount : p, he, b, ue)] }), T.addCustomComputeBudget(l), T.addTipInstruction(m), T.versionBuild({ txVersion: u, extInfo: { outAmount: he } });
      }
      async sellTokenExactOut({ programId: e = pt, authProgramId: t, mintAProgram: n = J.TOKEN_PROGRAM_ID, mintA: o, mintB: r = J.NATIVE_MINT, poolInfo: s, configInfo: a, platformFeeRate: c, txVersion: u, computeBudgetConfig: l, txTipConfig: m, feePayer: d, inAmount: p, maxSellAmount: f, slippage: y, shareFeeRate: b = new ce.default(0), shareFeeReceiver: g, associatedOnly: A = true, checkCreateATAOwner: k = false, skipCheckMintA: I = false }) {
        t = t != null ? t : an(e).publicKey;
        let T = this.createTxBuilder(d);
        f != null && f.lte(new ce.default(0)) && this.logAndCreateError("max sell amount should be gt 0");
        let { publicKey: h } = Ho(e, o, r), S;
        if (!I) {
          let ie = await this.scope.connection.getAccountInfo(o);
          if (ie && ie.owner.equals(J.TOKEN_2022_PROGRAM_ID)) {
            n = ie.owner;
            let We = (0, J.unpackMint)(o, ie, n);
            S = (0, J.getTransferFeeConfig)(We) || void 0;
          }
        }
        let x = null, K = null, B = r.equals(J.NATIVE_MINT), { account: C, instructionParams: R } = await this.scope.account.getOrCreateTokenAccount({ tokenProgram: n, mint: o, owner: this.scope.ownerPubKey, createInfo: void 0, skipCloseAccount: true, notUseTokenAccount: false, associatedOnly: A, checkCreateATAOwner: k });
        C && (x = C), T.addInstruction(R || {}), x === void 0 && this.logAndCreateError("cannot found mintA token accounts", "tokenAccounts", this.scope.account.tokenAccounts);
        let { account: N, instructionParams: v } = await this.scope.account.getOrCreateTokenAccount({ mint: r, owner: this.scope.ownerPubKey, createInfo: B ? { payer: this.scope.ownerPubKey, amount: 0 } : void 0, skipCloseAccount: !B, notUseTokenAccount: B, associatedOnly: B ? false : A, checkCreateATAOwner: k });
        N && (K = N), T.addInstruction(v || {}), K === void 0 && this.logAndCreateError("cannot found mintB token accounts", "tokenAccounts", this.scope.account.tokenAccounts);
        let L = s;
        if (!L) {
          let ie = await this.scope.connection.getAccountInfo(h, { commitment: "processed" });
          ie || this.logAndCreateError("cannot found pool", h.toBase58()), L = In.decode(ie.data);
        }
        let M = a, Y = await ze(this.scope.connection, [M ? void 0 : L.configId, L.platformId].filter(Boolean).map((ie) => ({ pubkey: ie })));
        if (!M) {
          let ie = Y.find((We) => We.pubkey.equals(L.configId));
          (!ie || !ie.accountInfo) && this.logAndCreateError("config not found: ", L.configId.toBase58()), M = ro.decode(ie.accountInfo.data);
        }
        let j = Y.find((ie) => ie.pubkey.equals(L.platformId));
        (!j || !j.accountInfo) && this.logAndCreateError("platform info not found: ", L.configId.toBase58());
        let le = Xn.decode(j.accountInfo.data);
        c = c || le.feeRate;
        let be = Yt.sellExactOut({ poolInfo: L, amountB: p, protocolFeeRate: M.tradeFeeRate, platformFeeRate: c, curveType: M.curveType, shareFeeRate: b, creatorFeeRate: le.creatorFeeRate, transferFeeConfigA: S, slot: await this.scope.connection.getSlot() }), me = new O(be.amountA.amount.toString()), Ie = y ? new O(Co.add(y).toNumber() / Co.toNumber()).clampedTo(0, Number.MAX_SAFE_INTEGER) : new O(1), he = (f != null ? f : y) ? new ce.default(me.mul(Ie).toFixed(0)) : be.amountA.amount, ue = g ? te(g, r, J.TOKEN_PROGRAM_ID).publicKey : void 0;
        return ue && T.addInstruction({ instructions: [(0, J.createAssociatedTokenAccountIdempotentInstruction)(this.scope.ownerPubKey, ue, g, r)] }), T.addInstruction({ instructions: [Pl(e, this.scope.ownerPubKey, t, L.configId, L.platformId, h, x, K, L.vaultA, L.vaultB, o, r, n, J.TOKEN_PROGRAM_ID, Mn(e, L.platformId, r).publicKey, vn(e, L.creator, r).publicKey, p, he, b, ue)] }), T.addCustomComputeBudget(l), T.addTipInstruction(m), T.versionBuild({ txVersion: u, extInfo: { maxSellAmount: he } });
      }
      async createPlatformConfig({ programId: e = pt, platformAdmin: t, platformClaimFeeWallet: n, platformLockNftWallet: o, platformVestingWallet: r, cpConfigId: s, migrateCpLockNftScale: a, transferFeeExtensionAuth: c, creatorFeeRate: u, feeRate: l, name: m, web: d, img: p, platformVestingScale: f = new ce.default(0), txVersion: y, computeBudgetConfig: b, txTipConfig: g, feePayer: A }) {
        let k = this.createTxBuilder(A), { publicKey: I } = Ua(e, t);
        return k.addInstruction({ instructions: [Al(e, t, n, o, r, I, s, c, a, l, u, m, d, p, f)] }), k.addCustomComputeBudget(b), k.addTipInstruction(g), k.versionBuild({ txVersion: y, extInfo: { platformId: I } });
      }
      async updatePlatformConfig({ programId: e = pt, platformAdmin: t, platformId: n, updateInfo: o, txVersion: r, computeBudgetConfig: s, txTipConfig: a, feePayer: c }) {
        let u = this.createTxBuilder(c), l = n != null ? n : Ua(e, t).publicKey;
        return u.addInstruction({ instructions: [wl(e, t, l, o)] }), u.addCustomComputeBudget(s), u.addTipInstruction(a), u.versionBuild({ txVersion: r });
      }
      async createPlatformVestingAccount({ programId: e = pt, platformVestingWallet: t, beneficiary: n, platformId: o, poolId: r, vestingRecord: s, txVersion: a, computeBudgetConfig: c, txTipConfig: u, feePayer: l }) {
        let m = this.createTxBuilder(l), d = s != null ? s : Qo(e, r, n).publicKey;
        return m.addInstruction({ instructions: [kl(e, t, n, o, r, d)] }), m.addCustomComputeBudget(c), m.addTipInstruction(u), m.versionBuild({ txVersion: a });
      }
      async claimPlatformFee({ programId: e = pt, authProgramId: t, platformId: n, poolId: o, platformClaimFeeWallet: r, mintB: s, vaultB: a, mintBProgram: c = J.TOKEN_PROGRAM_ID, txVersion: u, computeBudgetConfig: l, txTipConfig: m, feePayer: d }) {
        var g;
        let p = this.createTxBuilder(d);
        t = t != null ? t : an(e).publicKey;
        let f = s, y = a;
        if (!f) {
          let A = await this.scope.connection.getAccountInfo(o, { commitment: "processed" });
          A || this.logAndCreateError("cannot found pool:", o.toBase58());
          let k = In.decode(A.data), I = await this.scope.connection.getAccountInfo(k.configId, { commitment: "processed" });
          I || this.logAndCreateError("cannot found config:", k.configId.toBase58()), f = ro.decode(I.data).mintB, y = y != null ? y : k.vaultB;
        }
        (!f || !y) && this.logAndCreateError("cannot found mint info, mintB: ", f.toBase58(), ", vaultB: ", (g = y == null ? void 0 : y.toBase58()) != null ? g : "");
        let b = te(this.scope.ownerPubKey, f, J.TOKEN_PROGRAM_ID).publicKey;
        return p.addInstruction({ instructions: [(0, J.createAssociatedTokenAccountIdempotentInstruction)(this.scope.ownerPubKey, b, this.scope.ownerPubKey, f)] }), p.addInstruction({ instructions: [Ha(e, r, t, o, n, y, b, f, c)] }), p.addCustomComputeBudget(l), p.addTipInstruction(m), p.versionBuild({ txVersion: u });
      }
      async claimAllPlatformFee({ programId: e = pt, authProgramId: t, platformId: n, platformClaimFeeWallet: o, txVersion: r, computeBudgetConfig: s, txTipConfig: a, feePayer: c }) {
        let u = this.createTxBuilder(c);
        return t = t != null ? t : an(e).publicKey, (await this.scope.connection.getProgramAccounts(e, { filters: [{ dataSize: In.span }, { memcmp: { offset: In.offsetOf("platformId"), bytes: n.toString() } }] })).forEach((m) => {
          let d = In.decode(m.account.data);
          if (d.platformFee.lte(new ce.default(0)))
            return;
          let p = te(this.scope.ownerPubKey, d.mintB, J.TOKEN_PROGRAM_ID).publicKey;
          u.addInstruction({ instructions: [(0, J.createAssociatedTokenAccountIdempotentInstruction)(this.scope.ownerPubKey, p, this.scope.ownerPubKey, d.mintB)] }), u.addInstruction({ instructions: [Ha(e, o, t, m.pubkey, n, d.vaultB, p, d.mintB, J.TOKEN_PROGRAM_ID)] });
        }), u.addTipInstruction(a), r === 0 ? u.sizeCheckBuildV0({ computeBudgetConfig: s }) : u.sizeCheckBuild({ computeBudgetConfig: s });
      }
      async createVesting({ programId: e = pt, poolId: t, beneficiary: n, shareAmount: o, txVersion: r, computeBudgetConfig: s, txTipConfig: a, feePayer: c }) {
        let u = this.createTxBuilder(c), l = await this.getRpcPoolInfo({ poolId: t });
        o.add(l.vestingSchedule.totalAllocatedShare).gt(l.vestingSchedule.totalLockedAmount) && this.logAndCreateError("share amount exceed total locked amount");
        let m = Qo(e, t, n).publicKey;
        return u.addInstruction({ instructions: [Ya(e, this.scope.ownerPubKey, n, t, m, o)] }), u.addCustomComputeBudget(s), u.addTipInstruction(a), u.versionBuild({ txVersion: r });
      }
      async createMultipleVesting({ programId: e = pt, poolId: t, beneficiaryList: n, txVersion: o, computeBudgetConfig: r, feePayer: s }) {
        let a = this.createTxBuilder(s);
        n.length === 0 && this.logAndCreateError("beneficiaryList is null");
        let c = await this.getRpcPoolInfo({ poolId: t });
        return n.reduce((l, m) => l.add(m.shareAmount), c.vestingSchedule.totalAllocatedShare).gt(c.vestingSchedule.totalLockedAmount) && this.logAndCreateError("share amount exceed total locked amount"), n.forEach((l) => {
          let m = Qo(e, t, l.wallet).publicKey;
          a.addInstruction({ instructions: [Ya(e, this.scope.ownerPubKey, l.wallet, t, m, l.shareAmount)] });
        }), o === 0 ? a.sizeCheckBuildV0({ computeBudgetConfig: r }) : a.sizeCheckBuild({ computeBudgetConfig: r });
      }
      async claimVesting({ programId: e = pt, poolId: t, poolInfo: n, vestingRecord: o, txVersion: r, computeBudgetConfig: s, txTipConfig: a, feePayer: c }) {
        let u = this.createTxBuilder(c), l = an(e).publicKey, m = o || Qo(e, t, this.scope.ownerPubKey).publicKey, d = n;
        if (!d) {
          let f = await this.scope.connection.getAccountInfo(t);
          f || this.logAndCreateError("pool not found"), d = In.decode(f.data);
        }
        let p = te(this.scope.ownerPubKey, d.mintA, J.TOKEN_PROGRAM_ID).publicKey;
        return u.addInstruction({ instructions: [(0, J.createAssociatedTokenAccountIdempotentInstruction)(this.scope.ownerPubKey, p, this.scope.ownerPubKey, d.mintA)] }), u.addInstruction({ instructions: [za(e, this.scope.ownerPubKey, l, t, m, p, d.vaultA, d.mintA, J.TOKEN_PROGRAM_ID)] }), u.addCustomComputeBudget(s), u.addTipInstruction(a), u.versionBuild({ txVersion: r });
      }
      async claimMultiVesting({ programId: e = pt, poolIdList: t, poolsInfo: n = {}, vestingRecords: o = {}, txVersion: r, computeBudgetConfig: s, feePayer: a }) {
        let c = this.createTxBuilder(a), u = E({}, n), l = an(e).publicKey, m = t.filter((d) => !u[d.toBase58()]);
        if (m.length) {
          let d = await this.getRpcPoolsInfo({ poolIdList: m });
          u = E(E({}, u), d.poolInfoMap);
        }
        return t.forEach((d) => {
          let p = d.toBase58(), f = u[p];
          f || this.logAndCreateError(`pool info not found: ${p}`);
          let y = o[p] || Qo(e, d, this.scope.ownerPubKey).publicKey, b = te(this.scope.ownerPubKey, f.mintA, J.TOKEN_PROGRAM_ID).publicKey;
          c.addInstruction({ instructions: [(0, J.createAssociatedTokenAccountIdempotentInstruction)(this.scope.ownerPubKey, b, this.scope.ownerPubKey, f.mintA)] }), c.addInstruction({ instructions: [za(e, this.scope.ownerPubKey, l, d, y, b, f.vaultA, f.mintA, J.TOKEN_PROGRAM_ID)] });
        }), r === 0 ? c.sizeCheckBuildV0({ computeBudgetConfig: s }) : c.sizeCheckBuild({ computeBudgetConfig: s });
      }
      async claimVaultPlatformFee({ programId: e = pt, platformId: t, mintB: n, mintBProgram: o = J.TOKEN_PROGRAM_ID, claimFeeWallet: r, txVersion: s, computeBudgetConfig: a, txTipConfig: c, feePayer: u }) {
        let l = this.createTxBuilder(u), m = Mn(e, t, n).publicKey, d = Ga(e).publicKey, p = this.scope.account.getAssociatedTokenAccount(n, o);
        return l.addInstruction({ instructions: [(0, J.createAssociatedTokenAccountIdempotentInstruction)(this.scope.ownerPubKey, p, this.scope.ownerPubKey, n, o), Qa(e, t, r != null ? r : this.scope.ownerPubKey, d, m, p, n, o)] }), l.addCustomComputeBudget(a), l.addTipInstruction(c), l.versionBuild({ txVersion: s });
      }
      async claimMultipleVaultPlatformFee({ programId: e = pt, platformList: t, unwrapSol: n = true, txVersion: o, computeBudgetConfig: r, feePayer: s, associatedOnly: a = true, checkCreateATAOwner: c = false }) {
        let u = this.createTxBuilder(s), l = {};
        return t.forEach(async (m) => {
          var b, g;
          let d = Ga(e).publicKey, p = Mn(e, m.id, m.mintB).publicKey, f = m.mintB.equals(J.NATIVE_MINT) && n, y = l[m.mintB.toBase58()];
          if (!y) {
            let { account: A, instructionParams: k } = await this.scope.account.getOrCreateTokenAccount({ mint: m.mintB, owner: this.scope.ownerPubKey, createInfo: f ? { payer: this.scope.ownerPubKey, amount: 0 } : void 0, skipCloseAccount: !f, notUseTokenAccount: f, associatedOnly: f ? false : a, checkCreateATAOwner: c });
            A && (y = A), u.addInstruction(k || {}), y === void 0 && this.logAndCreateError(`cannot found platform ${m.id.toBase58()} mintB(${m.mintB.toBase58()}) token accounts`, "tokenAccounts", this.scope.account.tokenAccounts);
          }
          u.addInstruction({ instructions: [Qa(e, m.id, (b = m.claimFeeWallet) != null ? b : this.scope.ownerPubKey, p, d, y, m.mintB, (g = m.mintBProgram) != null ? g : J.TOKEN_PROGRAM_ID)] });
        }), o === 0 ? u.sizeCheckBuildV0({ computeBudgetConfig: r }) : u.sizeCheckBuild({ computeBudgetConfig: r });
      }
      async claimCreatorFee({ programId: e = pt, mintB: t, mintBProgram: n = J.TOKEN_PROGRAM_ID, txVersion: o, computeBudgetConfig: r, txTipConfig: s, feePayer: a }) {
        let c = this.createTxBuilder(a), u = vn(e, this.scope.ownerPubKey, t).publicKey, l = Xa(e).publicKey, m = this.scope.account.getAssociatedTokenAccount(t, n);
        return c.addInstruction({ instructions: [(0, J.createAssociatedTokenAccountIdempotentInstruction)(this.scope.ownerPubKey, m, this.scope.ownerPubKey, t, n), ja(e, this.scope.ownerPubKey, l, u, m, t, n)] }), c.addCustomComputeBudget(r), c.addTipInstruction(s), c.versionBuild({ txVersion: o });
      }
      async claimMultipleCreatorFee({ programId: e = pt, mintBList: t, txVersion: n, computeBudgetConfig: o, feePayer: r }) {
        let s = this.createTxBuilder(r);
        return t.forEach((a) => {
          var p;
          let c = a.pubKey, u = (p = a.programId) != null ? p : J.TOKEN_PROGRAM_ID, l = vn(e, this.scope.ownerPubKey, c).publicKey, m = Xa(e).publicKey, d = this.scope.account.getAssociatedTokenAccount(c, u);
          s.addInstruction({ instructions: [(0, J.createAssociatedTokenAccountIdempotentInstruction)(this.scope.ownerPubKey, d, this.scope.ownerPubKey, c, u), ja(e, this.scope.ownerPubKey, m, l, d, c, u)] });
        }), n == 0 ? s.sizeCheckBuildV0({ computeBudgetConfig: o }) : s.sizeCheckBuild({ computeBudgetConfig: o });
      }
      async getRpcPoolInfo({ poolId: e }) {
        return (await this.getRpcPoolsInfo({ poolIdList: [e] })).poolInfoMap[e.toBase58()];
      }
      async getRpcPoolsInfo({ poolIdList: e, config: t }) {
        let n = await ze(this.scope.connection, e.map((c) => ({ pubkey: c })), t), o = {}, r = [];
        for (let c = 0; c < e.length; c++) {
          let u = n[c];
          if (u === null || !u.accountInfo)
            throw Error("fetch pool info error: " + e[c].toBase58());
          let l = In.decode(u.accountInfo.data);
          o[e[c].toBase58()] = U(E({}, l), { poolId: e[c], programId: u.accountInfo.owner }), r.push(l.configId);
        }
        let s = await ze(this.scope.connection, r.map((c) => ({ pubkey: c })), t), a = {};
        for (let c = 0; c < r.length; c++) {
          let u = s[c];
          if (u === null || !u.accountInfo)
            throw Error("fetch config info error: " + r[c].toBase58());
          let l = ro.decode(u.accountInfo.data);
          a[r[c].toBase58()] = U(E({}, l), { configId: u.accountInfo.owner });
        }
        return { poolInfoMap: Object.keys(o).reduce((c, u) => U(E({}, c), { [u]: U(E({}, o[u]), { configInfo: a[o[u].configId.toBase58()] }) }), {}) };
      }
    };
    var uo = new yt.default(0);
    var jr = class extends Je {
      constructor(e) {
        super(e);
      }
      async getWSolAccounts() {
        this.scope.checkOwner(), await this.scope.account.fetchWalletTokenAccounts();
        let e = this.scope.account.tokenAccounts.filter((t) => t.mint.equals(ee));
        return e.sort((t, n) => t.isAssociated ? 1 : n.isAssociated || t.amount.lt(n.amount) ? -1 : 1), e;
      }
      async unWrapWSol(e) {
        let { amount: t, tokenProgram: n, txVersion: o = 1, feePayer: r } = e, s = await this.getWSolAccounts(), a = this.createTxBuilder(r);
        a.addCustomComputeBudget(e.computeBudgetConfig);
        let c = oe(t);
        for (let u = 0; u < s.length; u++)
          c.gte(s[u].amount) ? (a.addInstruction({ instructions: [Dn({ tokenAccount: s[u].publicKey, payer: this.scope.ownerPubKey, owner: this.scope.ownerPubKey, programId: n })] }), c.sub(s[u].amount)) : a.addInstruction({ instructions: [Dn({ tokenAccount: s[u].publicKey, payer: this.scope.ownerPubKey, owner: this.scope.ownerPubKey, programId: n })] });
        return a.versionBuild({ txVersion: o });
      }
      async wrapWSol(e, t, n, o) {
        let r = this.createTxBuilder(o), s = await to({ connection: this.scope.connection, owner: this.scope.ownerPubKey, payer: this.scope.ownerPubKey, amount: e, skipCloseAccount: true });
        return r.addInstruction(s), r.versionBuild({ txVersion: n != null ? n : 1 });
      }
      async swap({ swapInfo: e, swapPoolKeys: t, ownerInfo: n, computeBudgetConfig: o, routeProgram: r, txVersion: s, feePayer: a }) {
        let c = this.createTxBuilder(a), u = e.amountIn, l = e.amountOut, m = u.amount.token.mint.equals(ee), d = l.amount.token.mint.equals(ee), p = u.amount.token.mint, f = l.amount.token.mint, { account: y, instructionParams: b } = await this.scope.account.getOrCreateTokenAccount({ tokenProgram: u.amount.token.isToken2022 ? Te.TOKEN_2022_PROGRAM_ID : Te.TOKEN_PROGRAM_ID, mint: p, notUseTokenAccount: m, owner: this.scope.ownerPubKey, skipCloseAccount: !m, createInfo: m ? { payer: this.scope.ownerPubKey, amount: u.amount.raw } : void 0, associatedOnly: m ? false : n.associatedOnly, checkCreateATAOwner: n.checkCreateATAOwner });
        if (b && c.addInstruction(b), y === void 0)
          throw Error("input account check error");
        let g;
        if (e.routeType === "route" && !d)
          g = this.scope.account.getAssociatedTokenAccount(f, l.amount.token.isToken2022 ? Te.TOKEN_2022_PROGRAM_ID : Te.TOKEN_PROGRAM_ID);
        else {
          let { account: T, instructionParams: h } = await this.scope.account.getOrCreateTokenAccount({ tokenProgram: l.amount.token.isToken2022 ? Te.TOKEN_2022_PROGRAM_ID : Te.TOKEN_PROGRAM_ID, mint: f, notUseTokenAccount: d, owner: this.scope.ownerPubKey, skipCloseAccount: true, createInfo: { payer: this.scope.ownerPubKey, amount: 0 }, associatedOnly: d ? false : n.associatedOnly, checkCreateATAOwner: n.checkCreateATAOwner });
          g = T, h && c.addInstruction(h);
        }
        d && c.addInstruction({ endInstructions: [Dn({ owner: this.scope.ownerPubKey, payer: this.scope.ownerPubKey, tokenAccount: g, programId: Te.TOKEN_PROGRAM_ID })], endInstructionTypes: [X.CloseAccount] });
        let A;
        if (e.routeType === "route") {
          let T = e.middleToken;
          A = this.scope.account.getAssociatedTokenAccount(T.mint, T.isToken2022 ? Te.TOKEN_2022_PROGRAM_ID : Te.TOKEN_PROGRAM_ID);
        }
        let k = t || await this.computePoolToPoolKeys({ pools: e.poolInfoList }), I = pl({ routeProgram: r, inputMint: p, swapInfo: U(E({}, e), { poolInfo: [...e.poolInfoList], poolKey: k, outputMint: f }), ownerInfo: { wallet: this.scope.ownerPubKey, sourceToken: y, routeToken: A, destinationToken: g } });
        if (e.feeConfig !== void 0) {
          let T = this.createTxBuilder();
          T.addInstruction({ instructions: [(0, Te.createTransferInstruction)(y, e.feeConfig.feeAccount, this.scope.ownerPubKey, e.feeConfig.feeAmount.toNumber())], instructionTypes: [X.TransferAmount] }), T.addInstruction(I);
          let { transactions: h } = s === 0 ? await T.sizeCheckBuildV0() : await T.sizeCheckBuild();
          h.length < 2 && c.addInstruction({ instructions: [(0, Te.createTransferInstruction)(y, e.feeConfig.feeAccount, this.scope.ownerPubKey, e.feeConfig.feeAmount.toNumber())], instructionTypes: [X.TransferAmount] });
        }
        return c.addInstruction(I), s === 0 ? c.sizeCheckBuildV0({ computeBudgetConfig: o, address: I.address }) : c.sizeCheckBuild({ computeBudgetConfig: o, address: I.address });
      }
      async swapClmmToLaunchMint({ inputMint: e, inputAmount: t, fixClmmOut: n = false, clmmPoolId: o, launchPoolId: r, priceLimit: s, slippage: a = 0.01, shareFeeRate: c = new yt.default(0), shareFeeReceiver: u, launchPlatformInfo: l, slot: m, mintInfo: d, epochInfo: p, ownerInfo: f = { useSOLBalance: true }, checkCreateATAOwner: y = false, computeBudgetConfig: b, txVersion: g }) {
        let A = (f == null ? void 0 : f.feePayer) || this.scope.ownerPubKey, k = p != null ? p : await this.scope.fetchEpochInfo(), { clmmPoolData: I, clmmComputeAmount: { maxClmmAmountIn: T, clmmAmountOut: h, remainingAccounts: S }, launchPoolInfo: x, launchAuthProgramId: K, launchSwapInfo: B, outAmount: C, minOutAmount: R } = await this.computeClmmToLaunchAmount({ inputMint: e, inputAmount: t, fixClmmOut: n, clmmPoolId: o, launchPoolId: r, slippage: a, epochInfo: k, shareFeeRate: c, launchPlatformInfo: l, slot: m, mintInfo: d }), N = e.toString() === I.poolInfo.mintA.address, v = f.useSOLBalance && I.poolInfo.mintA.address === ee.toBase58(), L = f.useSOLBalance && I.poolInfo.mintB.address === ee.toBase58(), M = {}, Y;
        !s || s.equals(new O(0)) ? Y = N ? qt.add(new yt.default(1)) : Ut.sub(new yt.default(1)) : Y = fe.priceToSqrtPriceX64(s, I.poolInfo.mintA.decimals, I.poolInfo.mintB.decimals);
        let j = this.createTxBuilder(A), [le, be] = [new Ue.PublicKey(I.poolInfo.mintA.address), new Ue.PublicKey(I.poolInfo.mintB.address)], [me, Ie] = [new Ue.PublicKey(I.poolInfo.mintA.programId), new Ue.PublicKey(I.poolInfo.mintB.programId)], he = this.scope.account.getAssociatedTokenAccount(le, me), ue = this.scope.account.getAssociatedTokenAccount(be, Ie);
        j.addInstruction({ instructions: [(0, Te.createAssociatedTokenAccountIdempotentInstruction)(this.scope.ownerPubKey, he, this.scope.ownerPubKey, le, me), (0, Te.createAssociatedTokenAccountIdempotentInstruction)(this.scope.ownerPubKey, ue, this.scope.ownerPubKey, be, Ie)] }), (N && v || !N && L) && j.addInstruction({ instructions: [Ue.SystemProgram.transfer({ fromPubkey: this.scope.ownerPubKey, toPubkey: N ? he : ue, lamports: BigInt(T.toString()) }), (0, Te.createSyncNativeInstruction)(N ? he : ue)] }), M[I.poolInfo.mintA.address] = he, M[I.poolInfo.mintB.address] = ue, (!he || !ue) && this.logAndCreateError("user do not have token account", { ownerTokenAccountA: he, ownerTokenAccountB: ue }), j.addInstruction(n ? Oe.makeSwapBaseOutInstructions({ poolInfo: I.poolInfo, poolKeys: I.poolKeys, observationId: I.computePoolInfo.observationId, ownerInfo: { wallet: this.scope.ownerPubKey, tokenAccountA: he, tokenAccountB: ue }, outputMint: N ? be : le, amountOut: h, amountInMax: T, sqrtPriceLimitX64: Y, remainingAccounts: S }) : Oe.makeSwapBaseInInstructions({ poolInfo: I.poolInfo, poolKeys: I.poolKeys, observationId: I.computePoolInfo.observationId, ownerInfo: { wallet: this.scope.ownerPubKey, tokenAccountA: he, tokenAccountB: ue }, inputMint: new Ue.PublicKey(e), amountIn: t, amountOutMin: h, sqrtPriceLimitX64: Y, remainingAccounts: S }));
        let ie = x.mintProgramFlag === 0 ? Te.TOKEN_PROGRAM_ID : Te.TOKEN_2022_PROGRAM_ID, We = this.scope.account.getAssociatedTokenAccount(x.mintA, ie), He = M[x.mintB.toBase58()];
        if (j.addInstruction({ instructions: [(0, Te.createAssociatedTokenAccountIdempotentInstruction)(this.scope.ownerPubKey, We, this.scope.ownerPubKey, x.mintA, ie)] }), !He) {
          let Se = x.mintB.equals(ee), { account: Vt, instructionParams: un } = await this.scope.account.getOrCreateTokenAccount({ tokenProgram: Te.TOKEN_PROGRAM_ID, mint: x.mintB, notUseTokenAccount: Se, owner: this.scope.ownerPubKey, skipCloseAccount: !Se, createInfo: Se ? { payer: this.scope.ownerPubKey, amount: h } : void 0, associatedOnly: false, checkCreateATAOwner: y });
          He = Vt, un && j.addInstruction(un);
        }
        return j.addInstruction({ instructions: [Wr(x.programId, this.scope.ownerPubKey, K, x.configId, x.platformId, new Ue.PublicKey(r), We, He, x.vaultA, x.vaultB, x.mintA, x.mintB, ie, Te.TOKEN_PROGRAM_ID, Mn(x.programId, x.platformId, x.mintB).publicKey, vn(x.programId, x.creator, x.mintB).publicKey, B.amountB.lt(h) ? B.amountB : h, R, c, u)] }), j.addCustomComputeBudget(b), j.versionBuild({ txVersion: g, extInfo: { routes: [{ mint: new Ue.PublicKey(e), amount: n ? T : t, decimal: I.poolInfo[N ? "mintA" : "mintB"].decimals }, { mint: N ? be : le, amount: h, decimal: I.poolInfo[N ? "mintB" : "mintA"].decimals }, { mint: x.mintA, amount: C, decimal: x.mintDecimalsA }], outAmount: C, minOutAmount: R } });
      }
      async computeClmmToLaunchAmount({ inputMint: e, inputAmount: t, fixClmmOut: n = false, clmmPoolId: o, launchPoolId: r, slippage: s, epochInfo: a, shareFeeRate: c = new yt.default(0), clmmPoolData: u, launchPoolInfo: l, launchPlatformInfo: m, slot: d, mintInfo: p }) {
        var v, L, M, Y, j, le;
        let f = s > 0 ? new O(s).div(2).toDecimalPlaces(4, O.ROUND_DOWN).toNumber() : s, y = u != null ? u : await this.scope.clmm.getPoolInfoFromRpc(o.toString());
        if (e.toString() !== y.poolInfo.mintA.address && e.toString() !== y.poolInfo.mintB.address)
          throw new Error("input mint does not match clmm pool mints, please check");
        let b = e.toString() === y.poolInfo.mintA.address, g = y.poolInfo[b ? "mintB" : "mintA"], A = n ? await Xe.computeAmountIn({ poolInfo: y.computePoolInfo, tickArrayCache: y.tickData[o.toString()], amountOut: t, baseMint: new Ue.PublicKey(y.poolInfo[b ? "mintB" : "mintA"].address), slippage: f, epochInfo: a != null ? a : await this.scope.fetchEpochInfo() }) : await Xe.computeAmountOutFormat({ poolInfo: y.computePoolInfo, tickArrayCache: y.tickData[o.toString()], amountIn: t, tokenOut: g, slippage: f, epochInfo: a != null ? a : await this.scope.fetchEpochInfo() }), k = l;
        if (k || (k = await this.scope.launchpad.getRpcPoolInfo({ poolId: new Ue.PublicKey(r) })), g.address !== k.mintB.toBase58())
          throw new Error(`clmm swap mint(${g.address}) != launch pool mintB(${k.mintB.toBase58()})`);
        let I = m;
        if (!I) {
          let be = await this.scope.connection.getAccountInfo(k.platformId);
          I = Xn.decode(be.data);
        }
        let T = p != null ? p : await this.scope.token.getTokenInfo(k.mintA), h = an(k.programId).publicKey, S = T.extensions.feeConfig ? { transferFeeConfigAuthority: Ue.PublicKey.default, withdrawWithheldAuthority: Ue.PublicKey.default, withheldAmount: BigInt(0), olderTransferFee: { epoch: BigInt((L = (v = T.extensions.feeConfig.olderTransferFee.epoch) != null ? v : a == null ? void 0 : a.epoch) != null ? L : 0), maximumFee: BigInt(T.extensions.feeConfig.olderTransferFee.maximumFee), transferFeeBasisPoints: T.extensions.feeConfig.olderTransferFee.transferFeeBasisPoints }, newerTransferFee: { epoch: BigInt((Y = (M = T.extensions.feeConfig.newerTransferFee.epoch) != null ? M : a == null ? void 0 : a.epoch) != null ? Y : 0), maximumFee: BigInt(T.extensions.feeConfig.newerTransferFee.maximumFee), transferFeeBasisPoints: T.extensions.feeConfig.newerTransferFee.transferFeeBasisPoints } } : void 0, x = n ? t : A.minAmountOut.amount.raw, K = Yt.buyExactIn({ poolInfo: k, amountB: x, protocolFeeRate: k.configInfo.tradeFeeRate, platformFeeRate: I.feeRate, curveType: k.configInfo.curveType, shareFeeRate: c, creatorFeeRate: I.creatorFeeRate, transferFeeConfigA: S, slot: d != null ? d : await this.scope.connection.getSlot() }), B = K.amountA.amount.sub((j = K.amountA.fee) != null ? j : new yt.default(0)), C = new O(B.toString()), R = new yt.default(1e4), N = f ? new O(R.sub(new yt.default(f * 1e4)).toNumber() / R.toNumber()).clampedTo(0, 1) : new O(1);
        return { clmmPoolData: y, clmmComputeAmount: { maxClmmAmountIn: n ? A.maxAmountIn.amount : t, clmmAmountOut: x, remainingAccounts: A.remainingAccounts }, clmmComputeInfo: A, launchPoolInfo: k, launchAuthProgramId: h, launchMintTransferFeeConfig: S, launchSwapInfo: K, outAmount: K.amountA.amount.sub((le = K.amountA.fee) != null ? le : new yt.default(0)), minOutAmount: new yt.default(C.mul(N).toFixed(0)) };
      }
      async swapLaunchMintToClmm({ inputAmount: e, clmmPoolId: t, launchPoolId: n, priceLimit: o, slippage: r = 0.01, shareFeeRate: s = new yt.default(0), shareFeeReceiver: a, ownerInfo: c = { useSOLBalance: true }, checkCreateATAOwner: u = false, computeBudgetConfig: l, txVersion: m }) {
        let d = (c == null ? void 0 : c.feePayer) || this.scope.ownerPubKey, p = await this.scope.fetchEpochInfo(), { clmmPoolData: f, clmmComputeAmount: { remainingAccounts: y }, launchPoolInfo: b, launchAuthProgramId: g, launchSwapInfo: A, minLaunchOutAmount: k, outAmount: I, minOutAmount: T } = await this.computeLaunchToClmmAmount({ inputAmount: e, clmmPoolId: t, launchPoolId: n, slippage: r, epochInfo: p, shareFeeRate: s }), h = this.createTxBuilder(d), S = {}, x = b.mintProgramFlag === 0 ? Te.TOKEN_PROGRAM_ID : Te.TOKEN_2022_PROGRAM_ID, { account: K } = await this.scope.account.getOrCreateTokenAccount({ tokenProgram: x, mint: b.mintA, notUseTokenAccount: false, owner: this.scope.ownerPubKey, skipCloseAccount: true, createInfo: void 0, associatedOnly: true, checkCreateATAOwner: u });
        if (!K)
          throw new Error(`do not have launch mint(${b.mintA.toString()}) token account`);
        let B = b.mintB.equals(ee), { account: C, instructionParams: R } = await this.scope.account.getOrCreateTokenAccount({ tokenProgram: Te.TOKEN_PROGRAM_ID, mint: b.mintB, notUseTokenAccount: B, owner: this.scope.ownerPubKey, skipCloseAccount: !B, createInfo: { payer: this.scope.ownerPubKey, amount: 0 }, associatedOnly: false, checkCreateATAOwner: u });
        if (R && h.addInstruction(R), !C)
          throw new Error(`do not have launch mint(${b.mintA.toString()}) token account`);
        S[b.mintB.toBase58()] = C, h.addInstruction({ instructions: [Dr(b.programId, this.scope.ownerPubKey, g, b.configId, b.platformId, new Ue.PublicKey(n), K, C, b.vaultA, b.vaultB, b.mintA, b.mintB, x, Te.TOKEN_PROGRAM_ID, Mn(b.programId, b.platformId, b.mintB).publicKey, vn(b.programId, b.creator, b.mintB).publicKey, A.amountA.amount.lt(e) ? A.amountA.amount : e, k, s, a)] });
        let N = b.mintB.toString() === f.poolInfo.mintA.address, v = c.useSOLBalance && f.poolInfo.mintA.address === ee.toBase58(), L = c.useSOLBalance && f.poolInfo.mintB.address === ee.toBase58(), M;
        !o || o.equals(new O(0)) ? M = N ? qt.add(new yt.default(1)) : Ut.sub(new yt.default(1)) : M = fe.priceToSqrtPriceX64(o, f.poolInfo.mintA.decimals, f.poolInfo.mintB.decimals);
        let [Y, j] = [new Ue.PublicKey(f.poolInfo.mintA.address), new Ue.PublicKey(f.poolInfo.mintB.address)], [le, be] = [new Ue.PublicKey(f.poolInfo.mintA.programId), new Ue.PublicKey(f.poolInfo.mintB.programId)], me = v ? void 0 : this.scope.account.getAssociatedTokenAccount(Y, le), Ie = L ? void 0 : this.scope.account.getAssociatedTokenAccount(j, be);
        if (!me) {
          let { account: he, instructionParams: ue } = await this.scope.account.getOrCreateTokenAccount({ tokenProgram: le, mint: Y, notUseTokenAccount: true, owner: this.scope.ownerPubKey, skipCloseAccount: false, createInfo: { payer: c.feePayer || this.scope.ownerPubKey, amount: N ? e : 0 }, associatedOnly: false, checkCreateATAOwner: u });
          me = he, ue && h.addInstruction(ue);
        }
        if (!Ie) {
          let { account: he, instructionParams: ue } = await this.scope.account.getOrCreateTokenAccount({ tokenProgram: be, mint: j, notUseTokenAccount: true, owner: this.scope.ownerPubKey, skipCloseAccount: false, createInfo: { payer: c.feePayer || this.scope.ownerPubKey, amount: N ? 0 : e }, associatedOnly: false, checkCreateATAOwner: u });
          Ie = he, ue && h.addInstruction(ue);
        }
        return S[f.poolInfo.mintA.address] = me, S[f.poolInfo.mintB.address] = Ie, (!me || !Ie) && this.logAndCreateError("user do not have token account", { ownerTokenAccountA: me, ownerTokenAccountB: Ie }), h.addInstruction(Oe.makeSwapBaseInInstructions({ poolInfo: f.poolInfo, poolKeys: f.poolKeys, observationId: f.computePoolInfo.observationId, ownerInfo: { wallet: this.scope.ownerPubKey, tokenAccountA: me, tokenAccountB: Ie }, inputMint: new Ue.PublicKey(f.poolKeys[N ? "mintA" : "mintB"].address), amountIn: k, amountOutMin: T, sqrtPriceLimitX64: M, remainingAccounts: y })), h.addCustomComputeBudget(l), h.versionBuild({ txVersion: m, extInfo: { routes: [{ mint: b.mintA, amount: e, decimal: b.mintDecimalsA }, { mint: b.mintB, amount: k, decimal: b.mintDecimalsB }, { mint: new Ue.PublicKey(f.poolKeys[N ? "mintB" : "mintA"].address), amount: I, decimal: f.poolKeys[N ? "mintB" : "mintA"].decimals }], outAmount: I, minOutAmount: T } });
      }
      async computeLaunchToClmmAmount({ inputAmount: e, clmmPoolId: t, launchPoolId: n, slippage: o, epochInfo: r, shareFeeRate: s = new yt.default(0), clmmPoolData: a, launchPoolInfo: c, launchPlatformInfo: u }) {
        var C, R, N, v;
        let l = o > 0 ? new O(o).div(2).toDecimalPlaces(4, O.ROUND_DOWN).toNumber() : o, m = c;
        m || (m = await this.scope.launchpad.getRpcPoolInfo({ poolId: new Ue.PublicKey(n) }));
        let d = m.mintB, p = a != null ? a : await this.scope.clmm.getPoolInfoFromRpc(t.toString());
        if (d.toString() !== p.poolInfo.mintA.address && d.toString() !== p.poolInfo.mintB.address)
          throw new Error("input mint does not match clmm pool mints, please check");
        let f = d.toString() === p.poolInfo.mintA.address, y = p.poolInfo[f ? "mintB" : "mintA"], b = u;
        if (!b) {
          let L = await this.scope.connection.getAccountInfo(m.platformId);
          b = Xn.decode(L.data);
        }
        let g = await this.scope.token.getTokenInfo(m.mintA), A = an(m.programId).publicKey, k = g.extensions.feeConfig ? { transferFeeConfigAuthority: Ue.PublicKey.default, withdrawWithheldAuthority: Ue.PublicKey.default, withheldAmount: BigInt(0), olderTransferFee: { epoch: BigInt((R = (C = g.extensions.feeConfig.olderTransferFee.epoch) != null ? C : r == null ? void 0 : r.epoch) != null ? R : 0), maximumFee: BigInt(g.extensions.feeConfig.olderTransferFee.maximumFee), transferFeeBasisPoints: g.extensions.feeConfig.olderTransferFee.transferFeeBasisPoints }, newerTransferFee: { epoch: BigInt((v = (N = g.extensions.feeConfig.newerTransferFee.epoch) != null ? N : r == null ? void 0 : r.epoch) != null ? v : 0), maximumFee: BigInt(g.extensions.feeConfig.newerTransferFee.maximumFee), transferFeeBasisPoints: g.extensions.feeConfig.newerTransferFee.transferFeeBasisPoints } } : void 0, I = Yt.sellExactIn({ poolInfo: m, amountA: e, protocolFeeRate: m.configInfo.tradeFeeRate, platformFeeRate: b.feeRate, curveType: m.configInfo.curveType, shareFeeRate: s, creatorFeeRate: b.creatorFeeRate, transferFeeConfigA: k, slot: await this.scope.connection.getSlot() }), T = I.amountB, h = new O(T.toString()), S = new yt.default(1e4), x = l ? new O(S.sub(new yt.default(l * 1e4)).toNumber() / S.toNumber()).clampedTo(0, 1) : new O(1), K = new yt.default(h.mul(x).toFixed(0)), B = await Xe.computeAmountOutFormat({ poolInfo: p.computePoolInfo, tickArrayCache: p.tickData[t.toString()], amountIn: K, tokenOut: y, slippage: l, epochInfo: r != null ? r : await this.scope.fetchEpochInfo() });
        return { clmmPoolData: p, clmmComputeAmount: B, launchPoolInfo: m, launchAuthProgramId: A, launchMintTransferFeeConfig: k, launchSwapInfo: I, minLaunchOutAmount: K, outAmount: B.amountOut.amount.raw, minOutAmount: B.minAmountOut.amount.raw };
      }
      async fetchRoutePoolBasicInfo(e) {
        let { amm: t = si, clmm: n = $n, cpmm: o = eo } = e || {}, r = await this.scope.connection.getProgramAccounts(t, { dataSlice: { offset: So.offsetOf("baseMint"), length: 64 } }), s = V([F("baseMint"), F("quoteMint")]), a = r.map((p) => ({ id: p.pubkey, version: 4, mintA: s.decode(p.account.data).baseMint, mintB: s.decode(p.account.data).quoteMint })), c = V([F("mintA"), F("mintB")]), l = (await this.scope.connection.getProgramAccounts(n, { filters: [{ dataSize: Bo.span }], dataSlice: { offset: Bo.offsetOf("mintA"), length: 64 } })).map((p) => {
          let f = c.decode(p.account.data);
          return { id: p.pubkey, version: 6, mintA: f.mintA, mintB: f.mintB };
        }), d = (await this.scope.connection.getProgramAccounts(o, { dataSlice: { offset: Vr.offsetOf("mintA"), length: 64 } })).map((p) => {
          let f = c.decode(p.account.data);
          return { id: p.pubkey, version: 7, mintA: f.mintA, mintB: f.mintB };
        });
        return { clmmPools: l, ammPools: a, cpmmPools: d };
      }
      getAllRoute({ inputMint: e, outputMint: t, clmmPools: n, ammPools: o, cpmmPools: r }) {
        e = e.toString() === Ue.PublicKey.default.toString() ? ee : e, t = t.toString() === Ue.PublicKey.default.toString() ? ee : t;
        let s = {}, a = {}, c = {}, u = [], l = {};
        for (let d of n != null ? n : []) {
          if ((d.mintA.equals(e) && d.mintB.equals(t) || d.mintA.equals(t) && d.mintB.equals(e)) && (u.push(d), a[d.id.toString()] = d), d.mintA.equals(e)) {
            let p = d.mintB.toString();
            l[p] === void 0 && (l[p] = { mintProgram: Te.TOKEN_PROGRAM_ID, in: [], out: [], mDecimals: 0 }), l[p].in.push(d);
          }
          if (d.mintB.equals(e)) {
            let p = d.mintA.toString();
            l[p] === void 0 && (l[p] = { mintProgram: Te.TOKEN_PROGRAM_ID, in: [], out: [], mDecimals: 0 }), l[p].in.push(d);
          }
          if (d.mintA.equals(t)) {
            let p = d.mintB.toString();
            l[p] === void 0 && (l[p] = { mintProgram: Te.TOKEN_PROGRAM_ID, in: [], out: [], mDecimals: 0 }), l[p].out.push(d);
          }
          if (d.mintB.equals(t)) {
            let p = d.mintA.toString();
            l[p] === void 0 && (l[p] = { mintProgram: Te.TOKEN_PROGRAM_ID, in: [], out: [], mDecimals: 0 }), l[p].out.push(d);
          }
        }
        let m = [];
        for (let d of o)
          (d.mintA.equals(e) && d.mintB.equals(t) || d.mintA.equals(t) && d.mintB.equals(e)) && (u.push(d), s[d.id.toBase58()] = d, m.push(d)), d.mintA.equals(e) && (l[d.mintB.toBase58()] === void 0 && (l[d.mintB.toBase58()] = { mintProgram: Te.TOKEN_PROGRAM_ID, in: [], out: [], mDecimals: 0 }), l[d.mintB.toBase58()].in.push(d)), d.mintB.equals(e) && (l[d.mintA.toBase58()] === void 0 && (l[d.mintA.toBase58()] = { mintProgram: Te.TOKEN_PROGRAM_ID, in: [], out: [], mDecimals: 0 }), l[d.mintA.toBase58()].in.push(d)), d.mintA.equals(t) && (l[d.mintB.toBase58()] === void 0 && (l[d.mintB.toBase58()] = { mintProgram: Te.TOKEN_PROGRAM_ID, in: [], out: [], mDecimals: 0 }), l[d.mintB.toBase58()].out.push(d)), d.mintB.equals(t) && (l[d.mintA.toBase58()] === void 0 && (l[d.mintA.toBase58()] = { mintProgram: Te.TOKEN_PROGRAM_ID, in: [], out: [], mDecimals: 0 }), l[d.mintA.toBase58()].out.push(d));
        for (let d of r)
          (d.mintA.equals(e) && d.mintB.equals(t) || d.mintA.equals(t) && d.mintB.equals(e)) && (u.push(d), c[d.id.toBase58()] = d), d.mintA.equals(e) && (l[d.mintB.toBase58()] === void 0 && (l[d.mintB.toBase58()] = { mintProgram: Te.TOKEN_PROGRAM_ID, in: [], out: [], mDecimals: 0 }), l[d.mintB.toBase58()].in.push(d)), d.mintB.equals(e) && (l[d.mintA.toBase58()] === void 0 && (l[d.mintA.toBase58()] = { mintProgram: Te.TOKEN_PROGRAM_ID, in: [], out: [], mDecimals: 0 }), l[d.mintA.toBase58()].in.push(d)), d.mintA.equals(t) && (l[d.mintB.toBase58()] === void 0 && (l[d.mintB.toBase58()] = { mintProgram: Te.TOKEN_PROGRAM_ID, in: [], out: [], mDecimals: 0 }), l[d.mintB.toBase58()].out.push(d)), d.mintB.equals(t) && (l[d.mintA.toBase58()] === void 0 && (l[d.mintA.toBase58()] = { mintProgram: Te.TOKEN_PROGRAM_ID, in: [], out: [], mDecimals: 0 }), l[d.mintA.toBase58()].out.push(d));
        for (let d of Object.keys(l)) {
          if (l[d].in.length === 1 && l[d].out.length === 1 && l[d].in[0].id.equals(l[d].out[0].id)) {
            delete l[d];
            continue;
          }
          if (l[d].in.length === 0 || l[d].out.length === 0) {
            delete l[d];
            continue;
          }
          let p = l[d];
          for (let f of p.in)
            for (let y of p.out)
              f.version === 6 && a[f.id.toString()] === void 0 ? a[f.id.toString()] = f : f.version === 7 && c[f.id.toString()] === void 0 ? c[f.id.toString()] = f : (f.version === 4 || f.version === 5) && s[f.id.toString()] === void 0 && (s[f.id.toString()] = f), y.version === 6 && a[y.id.toString()] === void 0 ? a[y.id.toString()] = y : y.version === 7 && c[y.id.toString()] === void 0 ? c[y.id.toString()] = y : (y.version === 4 || y.version === 5) && s[y.id.toString()] === void 0 && (s[y.id.toString()] = y);
        }
        return { directPath: u, addLiquidityPools: m, routePathDict: l, needSimulate: Object.values(s), needTickArray: Object.values(a), cpmmPoolList: Object.values(c) };
      }
      async fetchSwapRoutesData({ routes: e, inputMint: t, outputMint: n }) {
        let o = /* @__PURE__ */ new Set([...e.needTickArray.map((y) => [y.mintA.toBase58(), y.mintB.toBase58()]).flat(), t.toString(), n.toString()]);
        console.log("fetching amm pools info, total: ", e.needSimulate.length);
        let r = await this.scope.liquidity.getRpcPoolInfos(e.needSimulate.map((y) => y.id)), s = Lr(r), a = {};
        Object.values(s).forEach((y) => {
          o.delete(y.mintA.address), a[y.mintA.address] = { address: new Ue.PublicKey(y.mintA.address), programId: Te.TOKEN_PROGRAM_ID, mintAuthority: null, supply: BigInt(0), decimals: y.mintA.decimals, isInitialized: true, freezeAuthority: null, tlvData: Buffer.from("0", "hex"), feeConfig: void 0 }, o.delete(y.mintB.address), a[y.mintB.address] = { address: new Ue.PublicKey(y.mintB.address), programId: Te.TOKEN_PROGRAM_ID, mintAuthority: null, supply: BigInt(0), decimals: y.mintB.decimals, isInitialized: true, freezeAuthority: null, tlvData: Buffer.from("0", "hex"), feeConfig: void 0 };
        }), console.log("fetching cpmm pools info, total: ", e.cpmmPoolList.length);
        let c = await this.scope.cpmm.getRpcPoolInfos(e.cpmmPoolList.map((y) => y.id.toBase58()), true);
        Object.values(c).forEach((y) => {
          let [b, g] = [y.mintA.toBase58(), y.mintB.toBase58()];
          y.mintProgramA.equals(Te.TOKEN_PROGRAM_ID) ? (o.delete(b), a[b] = { address: y.mintA, programId: y.mintProgramA, mintAuthority: null, supply: BigInt(0), decimals: y.mintDecimalA, isInitialized: true, freezeAuthority: null, tlvData: Buffer.from("0", "hex"), feeConfig: void 0 }) : o.add(b), y.mintProgramB.equals(Te.TOKEN_PROGRAM_ID) ? (o.delete(g), a[g] = { address: y.mintB, programId: y.mintProgramB, mintAuthority: null, supply: BigInt(0), decimals: y.mintDecimalB, isInitialized: true, freezeAuthority: null, tlvData: Buffer.from("0", "hex"), feeConfig: void 0 }) : o.add(g);
        }), console.log("fetching mints info, total: ", o.size);
        let u = await Oo({ connection: this.scope.connection, mints: Array.from(o).map((y) => new Ue.PublicKey(y)) });
        a = E(E({}, a), u);
        let l = this.scope.cpmm.toComputePoolInfos({ pools: c, mintInfos: a });
        console.log("fetching clmm pools info, total:", e.needTickArray.length);
        let m = await this.scope.clmm.getRpcClmmPoolInfos({ poolIds: e.needTickArray.map((y) => y.id) }), { computeClmmPoolInfo: d, computePoolTickData: p } = await this.scope.clmm.getComputeClmmPoolInfos({ clmmPoolsRpcInfo: m, mintInfos: a }), f = Object.keys(e.routePathDict).reduce((y, b) => U(E({}, y), { [b]: U(E({}, e.routePathDict[b]), { mintProgram: a[b].programId, mDecimals: a[b].decimals, in: e.routePathDict[b].in.map((g) => s[g.id.toBase58()] || d[g.id.toBase58()] || l[g.id.toBase58()]), out: e.routePathDict[b].out.map((g) => s[g.id.toBase58()] || d[g.id.toBase58()] || l[g.id.toBase58()]) }) }), {});
        return { mintInfos: a, ammPoolsRpcInfo: r, ammSimulateCache: s, clmmPoolsRpcInfo: m, computeClmmPoolInfo: d, computePoolTickData: p, computeCpmmData: l, routePathDict: f };
      }
      getAllRouteComputeAmountOut({ inputTokenAmount: e, outputToken: t, directPath: n, routePathDict: o, simulateCache: r, tickCache: s, slippage: a, chainTime: c, epochInfo: u, feeConfig: l }) {
        var g, A, k, I, T, h, S, x, K;
        let m = l === void 0 ? new yt.default(0) : e.raw.mul(new yt.default(l.feeBps.toNumber())).div(new yt.default(1e4)), d = e.raw.sub(m), p = new ve(e.token, d), f = l === void 0 ? void 0 : { feeAmount: m, feeAccount: l.feeAccount }, y = U(E({}, t), { address: Lt(t.address).toString() }), b = [];
        for (let B of n)
          try {
            b.push(U(E({}, this.computeAmountOut({ itemPool: B, tickCache: s, simulateCache: r, chainTime: c, epochInfo: u, slippage: a, outputToken: y, amountIn: p })), { feeConfig: f }));
          } catch (C) {
            this.logDebug("direct error", B.version, B.id.toString(), C.message);
          }
        this.logDebug("direct done");
        for (let [B, C] of Object.entries(o)) {
          let R = { chainId: 101, address: B, programId: C.mintProgram.toBase58(), logoURI: "", symbol: "", name: "", decimals: C.mDecimals, tags: [], extensions: {} }, N = C.in.map((L) => {
            try {
              return { pool: L, data: this.computeAmountOut({ itemPool: L, tickCache: s, simulateCache: r, chainTime: c, epochInfo: u, slippage: a, outputToken: R, amountIn: p }) };
            } catch (M) {
              this.logDebug("route in error", L.version, L.id.toString(), M.message);
              return;
            }
          }).sort((L, M) => {
            var le, be, me, Ie;
            let Y = L === void 0 ? uo : L.data.amountOut.amount.raw.sub((be = (le = L.data.amountOut.fee) == null ? void 0 : le.raw) != null ? be : uo), j = M === void 0 ? uo : M.data.amountOut.amount.raw.sub((Ie = (me = M.data.amountOut.fee) == null ? void 0 : me.raw) != null ? Ie : uo);
            return Y.lt(j) ? 1 : -1;
          })[0];
          if (N === void 0)
            continue;
          let v = new ve(Br(R), N.data.amountOut.amount.raw.sub((A = (g = N.data.amountOut.fee) == null ? void 0 : g.raw) != null ? A : uo));
          for (let L of C.out)
            try {
              let M = this.computeAmountOut({ itemPool: L, tickCache: s, simulateCache: r, chainTime: c, epochInfo: u, slippage: a, outputToken: y, amountIn: v });
              b.push(U(E({}, M), { allTrade: !!(N.data.allTrade && M.allTrade), amountIn: N.data.amountIn, amountOut: M.amountOut, minAmountOut: M.minAmountOut, currentPrice: void 0, executionPrice: new O(new Tt({ baseToken: N.data.amountIn.amount.token, denominator: N.data.amountIn.amount.raw, quoteToken: M.amountOut.amount.token, numerator: M.amountOut.amount.raw.sub((I = (k = M.amountOut.fee) == null ? void 0 : k.raw) != null ? I : uo) }).toFixed()), priceImpact: new O(N.data.priceImpact.add(M.priceImpact).toFixed()), fee: [N.data.fee[0], M.fee[0]], routeType: "route", poolInfoList: [N.pool, L], remainingAccounts: [N.data.remainingAccounts[0], M.remainingAccounts[0]], minMiddleAmountFee: (T = M.amountOut.fee) != null && T.raw ? new ve(N.data.amountOut.amount.token, ((S = (h = N.data.amountOut.fee) == null ? void 0 : h.raw) != null ? S : uo).add((K = (x = M.amountOut.fee) == null ? void 0 : x.raw) != null ? K : uo)) : void 0, middleToken: N.data.amountOut.amount.token, poolReady: N.data.poolReady && M.poolReady, poolType: [N.data.poolType, M.poolType], feeConfig: f, expirationTime: wn(N.data.expirationTime, M.expirationTime) }));
            } catch (M) {
              this.logDebug("route out error", L.version, L.id.toString(), M.message);
            }
        }
        return b.filter((B) => (B.allTrade || this.logDebug(`pool ${B.poolInfoList.map((C) => C.id.toString()).join(",")} filter out since not all trade`), B.allTrade)).sort((B, C) => B.amountOut.amount.raw.sub(C.amountOut.amount.raw).gt(uo) ? -1 : 1);
      }
      computeAmountOut({ itemPool: e, tickCache: t, simulateCache: n, chainTime: o, epochInfo: r, slippage: s, outputToken: a, amountIn: c }) {
        if (e.version === 6) {
          let { allTrade: u, realAmountIn: l, amountOut: m, minAmountOut: d, expirationTime: p, currentPrice: f, executionPrice: y, priceImpact: b, fee: g, remainingAccounts: A, executionPriceX64: k } = Xe.computeAmountOutFormat({ poolInfo: e, tickArrayCache: t[e.id.toString()], amountIn: c.raw, tokenOut: a, slippage: s, epochInfo: r, catchLiquidityInsufficient: true });
          return { allTrade: u, amountIn: l, amountOut: m, minAmountOut: d, currentPrice: new O(f.toFixed()), executionPrice: new O(y.toFixed()), priceImpact: new O(b.toFixed()), fee: [g], remainingAccounts: [A], routeType: "amm", poolInfoList: [e], poolReady: e.startTime < o, poolType: "CLMM", slippage: s, clmmExPriceX64: [k], expirationTime: wn(l.expirationTime, p) };
        } else if (e.version === 7) {
          let { allTrade: u, executionPrice: l, amountOut: m, minAmountOut: d, priceImpact: p, fee: f } = this.scope.cpmm.computeSwapAmount({ pool: e, outputMint: a.address, amountIn: c.raw, slippage: s });
          return { allTrade: u, amountIn: { amount: c, fee: void 0, expirationTime: void 0 }, amountOut: { amount: Ki(U(E({}, a), { amount: m })), fee: void 0, expirationTime: void 0 }, minAmountOut: { amount: Ki(U(E({}, a), { amount: d })), fee: void 0, expirationTime: void 0 }, currentPrice: e.poolPrice, executionPrice: l, priceImpact: p, fee: [new ve(c.token, f)], remainingAccounts: [], routeType: "amm", poolInfoList: [e], poolReady: e.openTime.toNumber() < o, poolType: "CPMM", slippage: s, clmmExPriceX64: [void 0], expirationTime: void 0 };
        } else {
          if (![1, 6, 7].includes(n[e.id.toString()].status))
            throw Error("swap error");
          let { amountOut: u, minAmountOut: l, currentPrice: m, executionPrice: d, priceImpact: p, fee: f } = this.scope.liquidity.computeAmountOut({ poolInfo: n[e.id.toString()], amountIn: c.raw, mintIn: c.token.mint, mintOut: a.address, slippage: s });
          return { amountIn: { amount: c, fee: void 0, expirationTime: void 0 }, amountOut: { amount: Ki(U(E({}, a), { amount: u })), fee: void 0, expirationTime: void 0 }, minAmountOut: { amount: Ki(U(E({}, a), { amount: l })), fee: void 0, expirationTime: void 0 }, currentPrice: m, executionPrice: d, priceImpact: p, fee: [new ve(c.token, f)], routeType: "amm", poolInfoList: [e], remainingAccounts: [], poolReady: Number(n[e.id].openTime) < o, poolType: e.version === 5 ? "STABLE" : void 0, expirationTime: void 0, allTrade: true, slippage: s, clmmExPriceX64: [void 0] };
        }
      }
      async computePoolToPoolKeys({ pools: e, clmmRpcData: t = {}, ammRpcData: n = {} }) {
        let o = new Set(e.filter((u) => u.version === 6 && !t[u.id.toString()]).map((u) => u.id.toString()));
        if (o.size > 0) {
          let u = await this.scope.clmm.getRpcClmmPoolInfos({ poolIds: Array.from(o) });
          Object.keys(u).forEach((l) => {
            t[l] = u[l];
          });
        }
        let r = new Set(e.filter((u) => u.version === 4 && !n[u.id.toString()]).map((u) => u.id.toString()));
        if (r.size > 0) {
          let u = await this.scope.liquidity.getRpcPoolInfos(Array.from(r));
          Object.keys(u).forEach((l) => {
            n[l] = u[l];
          });
        }
        let s = new Set(e.filter((u) => u.version === 4).map((u) => u.marketId)), a = {};
        s.size > 0 && (await ze(this.scope.connection, Array.from(s).map((l) => ({ pubkey: new Ue.PublicKey(l) })))).forEach((l) => {
          if (!l.accountInfo)
            return;
          let m = Ea.decode(l.accountInfo.data);
          a[l.pubkey.toBase58()] = { marketId: l.pubkey.toString(), marketProgramId: l.accountInfo.owner.toString(), marketAuthority: Er.getAssociatedAuthority({ programId: l.accountInfo.owner, marketId: l.pubkey }).publicKey.toString(), marketBaseVault: m.baseVault.toString(), marketQuoteVault: m.quoteVault.toString(), marketBids: m.bids.toString(), marketAsks: m.asks.toString(), marketEventQueue: m.eventQueue.toString() };
        });
        let c = [];
        return e.forEach((u) => {
          if (u.version === 6) {
            let l = t[u.id.toString()], m = { programId: u.programId.toBase58(), id: u.id.toBase58(), mintA: u.mintA, mintB: u.mintB, openTime: String(u.startTime), vault: { A: l.vaultA.toBase58(), B: l.vaultB.toBase58() }, config: U(E({}, u.ammConfig), { id: u.ammConfig.id.toString(), defaultRange: 0, defaultRangePoint: [] }), rewardInfos: [], observationId: u.observationId.toBase58(), exBitmapAccount: u.exBitmapAccount.toBase58() };
            c.push(m);
          } else if (u.version === 4) {
            let l = n[u.id.toString()], m = E({ programId: u.programId, id: u.id, mintA: u.mintA, mintB: u.mintB, openTime: String(u.openTime), vault: { A: l.baseVault.toBase58(), B: l.quoteVault.toBase58() }, authority: Na({ programId: new Ue.PublicKey(u.programId) }).publicKey.toString(), openOrders: l.openOrders.toBase58(), targetOrders: l.targetOrders.toBase58(), mintLp: u.lpMint }, a[u.marketId]);
            c.push(m);
          } else
            u.version === 7 && c.push({ observationId: u.observationId.toBase58(), programId: u.programId.toBase58(), id: u.id.toBase58(), mintA: u.mintA, mintB: u.mintB, openTime: String(u.openTime), authority: Yo(u.programId).publicKey.toBase58(), vault: { A: u.vaultA.toBase58(), B: u.vaultB.toBase58() }, mintLp: vt({ address: u.mintLp.toBase58(), programId: Te.TOKEN_PROGRAM_ID.toBase58(), decimals: u.lpDecimals }), config: U(E({ id: u.configId.toBase58() }, u.configInfo), { protocolFeeRate: u.configInfo.protocolFeeRate.toNumber(), tradeFeeRate: u.configInfo.tradeFeeRate.toNumber(), fundFeeRate: u.configInfo.fundFeeRate.toNumber(), createPoolFee: u.configInfo.createPoolFee.toString() }) });
        }), c;
      }
    };
    var Ro = require("@solana/web3.js");
    var fp = require_cjs4();
    var Tl = Ae(require_bn());
    var Ht = class extends Je {
      static getPdaPoolId(e, t) {
        return se([Ht.SEED_CONFIG.pool.id, t.toBuffer()], e);
      }
      static getPdaOwnerId(e, t, n, o) {
        return se([Ht.SEED_CONFIG.owner.id, t.toBuffer(), n.toBuffer(), Buffer.from(new Tl.default(o).toArray())], e);
      }
      static async getAllInfo({ connection: e, programId: t, poolIds: n, wallet: o, chainTime: r }) {
        if (n.length === 0)
          return [];
        let s = n.map((l) => Ht.getPdaPoolId(t, l).publicKey), a = [];
        for (let l = 0; l < Ht.VERSION_PROJECT.length; l++)
          a.push(...s.map((m) => Ht.getPdaOwnerId(t, m, o, l).publicKey));
        let c = await gn(e, [...s, ...a]), u = [];
        for (let l = 0; l < c.length; l++) {
          let m = Math.floor(l / n.length), d = l % n.length, p = s[d], f = a[l], y = c[d], b = c[n.length + l];
          if (!(y && b) || y.data.length !== Ht.POOL_LAYOUT.span || b.data.length !== Ht.OWNER_LAYOUT.span)
            continue;
          let g = Ht.POOL_LAYOUT.decode(y.data), A = Ht.OWNER_LAYOUT.decode(b.data), k = g.openTime.toNumber(), I = g.endTime.toNumber(), T = A.tokenInfo.map((x) => x.debtAmount.gt(new Tl.default(0))).filter((x) => !x).length !== 3, h = r > k && r < I && g.status === 1, S = T && h;
          u.push({ programId: t, poolId: p, ammId: g.ammId, ownerAccountId: f, snapshotLpAmount: A.lpAmount, project: Ht.VERSION_PROJECT[m], openTime: k, endTime: I, canClaim: S, canClaimErrorType: T ? h ? void 0 : "outOfOperationalTime" : "alreadyClaimIt", tokenInfo: g.tokenInfo.map((x, K) => ({ mintAddress: x.mintAddress, mintVault: x.mintVault, mintDecimals: x.mintDecimals, perLpLoss: x.perLpLoss, debtAmount: A.tokenInfo[K].debtAmount.add(A.tokenInfo[K].claimedAmount) })) });
        }
        return u;
      }
      async makeClaimTransaction({ poolInfo: e, ownerInfo: t, feePayer: n }) {
        t.wallet || this.scope.checkOwner();
        let o = this.createTxBuilder(n), r = t.wallet || this.scope.ownerPubKey, s = [];
        for (let u of e.tokenInfo) {
          let { account: l, instructionParams: m } = await this.scope.account.getOrCreateTokenAccount({ mint: u.mintAddress, owner: this.scope.ownerPubKey, notUseTokenAccount: u.mintAddress.equals(De.WSOL.mint), createInfo: { payer: r, amount: 0 }, skipCloseAccount: !u.mintAddress.equals(De.WSOL.mint), associatedOnly: u.mintAddress.equals(De.WSOL.mint) ? false : t.associatedOnly });
          m && o.addInstruction(m), s.push(l);
        }
        o.addInstruction({ instructions: [Ht.makeClaimInstruction({ programId: e.programId, poolInfo: e, ownerInfo: { wallet: r, ownerPda: e.ownerAccountId, claimAddress: s } })] });
        let { transaction: a, signers: c } = o.build();
        return [{ transaction: a, signer: c }];
      }
      async makeClaimAllTransaction({ poolInfos: e, ownerInfo: t, feePayer: n }) {
        let o = this.createTxBuilder(n), r = t.wallet || this.scope.ownerPubKey, s = {};
        for (let l of e) {
          let m = [];
          for (let d of l.tokenInfo) {
            let { account: p, instructionParams: f } = await this.scope.account.getOrCreateTokenAccount({ mint: d.mintAddress, owner: this.scope.ownerPubKey, notUseTokenAccount: d.mintAddress.equals(De.WSOL.mint), createInfo: { payer: r, amount: 0 }, skipCloseAccount: !d.mintAddress.equals(De.WSOL.mint), associatedOnly: d.mintAddress.equals(De.WSOL.mint) ? false : t.associatedOnly });
            f && o.addInstruction(f), p && (s[d.mintAddress.toString()] = p, m.push(p));
          }
          o.addInstruction({ instructions: [Ht.makeClaimInstruction({ programId: l.programId, poolInfo: l, ownerInfo: { wallet: r, ownerPda: l.ownerAccountId, claimAddress: m } })] });
        }
        let { transaction: a, signers: c } = o.build(), u = o.allInstructions;
        return ir(u, [r, ...c.map((l) => l.publicKey)]) ? [{ transaction: a, signer: c }] : [{ transaction: new Ro.Transaction().add(...u.slice(0, o.AllTxData.instructions.length - 1)), signer: c }, { transaction: new Ro.Transaction().add(...u.slice(o.AllTxData.instructions.length - 1)), signer: [] }, { transaction: new Ro.Transaction().add(...o.AllTxData.endInstructions), signer: [] }];
      }
      static makeClaimInstruction({ programId: e, poolInfo: t, ownerInfo: n }) {
        let o = V([]), r = [{ pubkey: n.wallet, isSigner: true, isWritable: true }, { pubkey: t.poolId, isSigner: false, isWritable: true }, { pubkey: n.ownerPda, isSigner: false, isWritable: true }, ...n.claimAddress.map((c) => ({ pubkey: c, isSigner: false, isWritable: true })), ...t.tokenInfo.map(({ mintVault: c }) => ({ pubkey: c, isSigner: false, isWritable: true })), { pubkey: fp.TOKEN_PROGRAM_ID, isSigner: false, isWritable: false }], s = Buffer.alloc(o.span);
        o.encode({}, s);
        let a = Buffer.from([10, 66, 208, 184, 161, 6, 191, 98, ...s]);
        return new Ro.TransactionInstruction({ keys: r, programId: e, data: a });
      }
    };
    var Bn = Ht;
    Bn.CLAIMED_NUM = 3, Bn.POOL_LAYOUT = V([Fe(8), W("bump"), W("status"), P2("openTime"), P2("endTime"), F("ammId"), Z(V([W("mintDecimals"), F("mintAddress"), F("mintVault"), P2("perLpLoss"), P2("totalClaimedAmount")]), Ht.CLAIMED_NUM, "tokenInfo"), Z(P2(), 10, "padding")]), Bn.OWNER_LAYOUT = V([Fe(8), W("bump"), W("version"), F("poolId"), F("owner"), P2("lpAmount"), Z(V([F("mintAddress"), P2("debtAmount"), P2("claimedAmount")]), Ht.CLAIMED_NUM, "tokenInfo"), Z(P2(), 4, "padding")]), Bn.DEFAULT_POOL_ID = ["58oQChx4yWmvKdwLLZzBi4ChoCc2fqCUWBkwMihLYQo2", "6UmmUiYoBjSrhakAobJw8BvkmJtDVxaeBtbt7rxWo1mg", "AVs9TA4nWDzfPJE9gGVNJMVhcQy3V9PGazuz33BfG2RA", "DVa7Qmb5ct9RCpaU7UTpSaf3GVMYz17vNVU67XpdCRut", "7XawhbbxtsRcQA8KTkHT9f9nc6d69UwqCDh6U5EEbEmX", "6a1CsrpeZubDjEJE9s1CMVheB6HWM5d7m1cj2jkhyXhj", "EoNrn8iUhwgJySD1pHu8Qxm5gSQqLK3za4m8xzD2RuEb", "AceAyRTWt4PyB2pHqf2qhDgNZDtKVNaxgL8Ru3V4aN1P", "6tmFJbMk5yVHFcFy7X2K8RwHjKLr6KVFLYXpgpBNeAxB"].map((e) => new Ro.PublicKey(e)), Bn.SEED_CONFIG = { pool: { id: Buffer.from("pool_seed", "utf8") }, owner: { id: Buffer.from("user_claim_seed", "utf8") } }, Bn.VERSION_PROJECT = [void 0, "Francium", "Tulip", "Larix"];
    var Ui = require("@solana/web3.js");
    var Il = Ae(require_bn());
    var qi = require("@solana/web3.js");
    var $a = require_cjs4();
    var Za = V([W("instruction"), Uu("amount")]);
    var Di = V([W("instruction")]);
    function pg({ programId: i, amount: e, instructionKeys: t }) {
      let n = [{ pubkey: Ji, isSigner: false, isWritable: false }, { pubkey: $a.TOKEN_PROGRAM_ID, isSigner: false, isWritable: false }, { pubkey: at, isSigner: false, isWritable: false }, { pubkey: As, isSigner: false, isWritable: false }, ...Object.entries(t).map(([r, s]) => ({ pubkey: s, isSigner: r === "userOwner", isWritable: !["authority", "userOwner", "userIdoCheck", "userStakeInfo"].includes(r) }))], o = Buffer.alloc(Za.span);
      return Za.encode({ instruction: 1, amount: Number(e) }, o), new qi.TransactionInstruction({ keys: n, programId: i, data: o });
    }
    function Zr({ programId: i }, e) {
      let t = [{ pubkey: $a.TOKEN_PROGRAM_ID, isSigner: false, isWritable: false }, { pubkey: As, isSigner: false, isWritable: false }, ...Object.entries(e).map(([o, r]) => ({ pubkey: r, isSigner: o === "userOwner", isWritable: !["authority", "userOwner"].includes(o) }))], n = Buffer.alloc(Di.span);
      return Di.encode({ instruction: 2 }, n), new qi.TransactionInstruction({ keys: t, programId: i, data: n });
    }
    function Ja(i) {
      let { poolConfig: e, userKeys: t, side: n } = i, o = n === "base" ? t.baseTokenAccount : t.quoteTokenAccount, r = n === "base" ? e.baseVault : e.quoteVault, s = Buffer.alloc(Di.span);
      Di.encode({ instruction: 2 }, s);
      let a = [{ pubkey: $a.TOKEN_PROGRAM_ID, isWritable: false, isSigner: false }, { pubkey: qi.SYSVAR_CLOCK_PUBKEY, isWritable: false, isSigner: false }, { pubkey: e.id, isWritable: true, isSigner: false }, { pubkey: e.authority, isWritable: false, isSigner: false }, { pubkey: r, isWritable: true, isSigner: false }, { pubkey: o, isWritable: true, isSigner: false }, { pubkey: t.ledgerAccount, isWritable: true, isSigner: false }, { pubkey: t.owner, isWritable: false, isSigner: true }];
      return new qi.TransactionInstruction({ programId: e.programId, keys: a, data: s });
    }
    var fg = { [li.IDO_PROGRAM_ID_V1.toString()]: 1, [li.IDO_PROGRAM_ID_V2.toString()]: 2, [li.IDO_PROGRAM_ID_V3.toString()]: 3, [li.IDO_PROGRAM_ID_V4.toString()]: 4 };
    var Gi = class extends Je {
      async claim({ ownerInfo: e, idoKeys: t, associatedOnly: n = true, checkCreateATAOwner: o = false, txVersion: r, feePayer: s }) {
        let a = this.createTxBuilder(s), c = fg[t.programId];
        c || this.logAndCreateError("invalid version", c);
        let u = Qe(t), [l, m] = [!new Il.default(e.coin).isZero(), !new Il.default(e.pc).isZero()], d = u.projectInfo.mint.address.equals(ee), { account: p, instructionParams: f } = await this.scope.account.getOrCreateTokenAccount({ tokenProgram: u.projectInfo.mint.programId, mint: u.projectInfo.mint.address, owner: this.scope.ownerPubKey, createInfo: { payer: this.scope.ownerPubKey, amount: 0 }, skipCloseAccount: !d, notUseTokenAccount: d, associatedOnly: d ? false : n, checkCreateATAOwner: o });
        !p && l && this.logAndCreateError("target token accounts not found", "mint", t.projectInfo.mint.address), l && f && a.addInstruction(f);
        let y = u.buyInfo.mint.address.equals(ee), { account: b, instructionParams: g } = await this.scope.account.getOrCreateTokenAccount({ tokenProgram: u.buyInfo.mint.programId, mint: u.buyInfo.mint.address, owner: this.scope.ownerPubKey, createInfo: { payer: this.scope.ownerPubKey, amount: 0 }, skipCloseAccount: !y, notUseTokenAccount: y, associatedOnly: y ? false : n, checkCreateATAOwner: o });
        if (!p && m && this.logAndCreateError("target token accounts not found", "mint", t.projectInfo.mint.address), m && g && a.addInstruction(g), (!p || !b) && this.logAndCreateError("target token accounts not found", "mint", t.projectInfo.mint.address, t.buyInfo.mint.address), c === 3)
          return a.addInstruction({ instructions: [...l ? [Zr({ programId: u.programId }, { idoId: u.id, authority: u.authority, poolTokenAccount: u.projectInfo.vault, userTokenAccount: p, userIdoInfo: new Ui.PublicKey(e.userIdoInfo), userOwner: this.scope.ownerPubKey })] : [], ...m ? [Zr({ programId: new Ui.PublicKey(t.programId) }, { idoId: u.id, authority: u.authority, poolTokenAccount: u.buyInfo.vault, userTokenAccount: b, userIdoInfo: new Ui.PublicKey(e.userIdoInfo), userOwner: this.scope.ownerPubKey })] : []] }).versionBuild({ txVersion: r });
        if (c < 3)
          return !l && !m && this.logAndCreateError("no claimable rewards"), a.addInstruction({ instructions: [Zr({ programId: u.programId }, { idoId: u.id, authority: u.authority, poolQuoteTokenAccount: u.buyInfo.vault, poolBaseTokenAccount: u.projectInfo.vault, userQuoteTokenAccount: b, userBaseTokenAccount: p, userIdoInfo: new Ui.PublicKey(e.userIdoInfo), userOwner: this.scope.ownerPubKey })] }).versionBuild({ txVersion: r });
        let A = { poolConfig: { id: u.id, programId: u.programId, authority: u.authority, baseVault: u.projectInfo.vault, quoteVault: u.buyInfo.vault, baseToken: t.projectInfo.mint, quoteToken: t.buyInfo.mint }, userKeys: { baseTokenAccount: p, quoteTokenAccount: b, ledgerAccount: new Ui.PublicKey(e.userIdoInfo), owner: this.scope.ownerPubKey } };
        return a.addInstruction({ instructions: [...l ? [Ja(U(E({}, A), { side: "base" }))] : [], ...m ? [Ja(U(E({}, A), { side: "quote" }))] : []] }).versionBuild({ txVersion: r });
      }
    };
    var yp = require("@solana/web3.js");
    var Yn = require_cjs4();
    var $r = class extends Je {
      constructor(t) {
        super(t);
        this._tokenList = [];
        this._tokenMap = /* @__PURE__ */ new Map();
        this._blackTokenMap = /* @__PURE__ */ new Set();
        this._mintGroup = { official: /* @__PURE__ */ new Set(), jup: /* @__PURE__ */ new Set(), extra: /* @__PURE__ */ new Set() };
        this._whiteMap = /* @__PURE__ */ new Set();
        this._extraTokenList = [];
      }
      async load(t) {
        this.checkDisabled();
        let { forceUpdate: n = false, type: o = "strict" } = t || {}, { mintList: r, blacklist: s, whiteList: a } = await this.scope.fetchV3TokenList(n), c = await this.scope.fetchJupTokenList(n);
        this._tokenList = [], this._tokenMap = /* @__PURE__ */ new Map(), this._blackTokenMap = new Set(s), this._mintGroup = { official: /* @__PURE__ */ new Set(), jup: /* @__PURE__ */ new Set(), extra: /* @__PURE__ */ new Set() }, this._whiteMap = new Set(a), this._tokenMap.set(Kn.address, Kn), this._mintGroup.official.add(Kn.address), r.forEach((u) => {
          var l;
          this._blackTokenMap.has(u.address) || (this._tokenMap.set(u.address, U(E({}, u), { type: "raydium", priority: 2, programId: (l = u.programId) != null ? l : u.tags.includes("token-2022") ? Yn.TOKEN_2022_PROGRAM_ID.toBase58() : Yn.TOKEN_PROGRAM_ID.toBase58() })), this._mintGroup.official.add(u.address));
        }), c.forEach((u) => {
          var l;
          this._blackTokenMap.has(u.address) || this._tokenMap.has(u.address) || (this._tokenMap.set(u.address, U(E({}, u), { type: "jupiter", priority: 1, programId: (l = u.programId) != null ? l : u.tags.includes("token-2022") ? Yn.TOKEN_2022_PROGRAM_ID.toBase58() : Yn.TOKEN_PROGRAM_ID.toBase58(), tags: u.freezeAuthority ? [...u.tags || [], "hasFreeze"] : u.tags })), this._mintGroup.jup.add(u.address));
        }), this._extraTokenList.forEach((u) => {
          this._blackTokenMap.has(u.address) || this._tokenMap.has(u.address) || (this._tokenMap.set(u.address, U(E({}, u), { type: "extra", priority: 1, programId: u.programId || u.tags.includes("token-2022") ? Yn.TOKEN_2022_PROGRAM_ID.toBase58() : Yn.TOKEN_PROGRAM_ID.toBase58() })), this._mintGroup.extra.add(u.address));
        }), this._tokenList = Array.from(this._tokenMap).map((u) => u[1]);
      }
      get tokenList() {
        return this._tokenList;
      }
      get tokenMap() {
        return this._tokenMap;
      }
      get blackTokenMap() {
        return this._blackTokenMap;
      }
      get mintGroup() {
        return this._mintGroup;
      }
      get whiteListMap() {
        return this._whiteMap;
      }
      async getTokenInfo(t) {
        if (!t)
          throw new Error("please input mint");
        let n = t.toString(), o = this._tokenMap.get(n);
        if (o)
          return o;
        if (n.toLocaleUpperCase() === "SOL")
          return Kn;
        let r = (await this.scope.api.getTokenInfo([n]))[0];
        if (r)
          return this._mintGroup.extra.add(n), this._tokenMap.set(n, U(E({}, r), { priority: 2 })), r;
        let s = await this.scope.connection.getAccountInfo(new yp.PublicKey(n));
        if (!s)
          throw new Error(`mint address not found: ${n}`);
        let a = Yn.MintLayout.decode(s.data), c = n.toString().substring(0, 6), u = { chainId: 101, address: n, programId: s.owner.toBase58(), logoURI: "", symbol: c, name: c, decimals: a.decimals, tags: [], extensions: {}, priority: 0, type: "unknown" };
        return this._mintGroup.extra.add(n), this._tokenMap.set(n, u), u;
      }
    };
    var Jr = class {
      constructor(e) {
        this.rawBalances = /* @__PURE__ */ new Map();
        let { connection: t, cluster: n, owner: o, api: r, defaultChainTime: s, defaultChainTimeOffset: a, apiCacheTime: c, blockhashCommitment: u = "confirmed", loopMultiTxStatus: l } = e;
        this._connection = t, this.cluster = n || "mainnet", this._owner = o ? new Pn(o) : void 0, this._signAllTransactions = e.signAllTransactions, this.blockhashCommitment = u, this.loopMultiTxStatus = l, this.api = r, this._apiCacheTime = c || 5 * 60 * 1e3, this.logger = xe("Raydium"), this.farm = new gr({ scope: this, moduleName: "Raydium_Farm" }), this.account = new pr({ scope: this, moduleName: "Raydium_Account", tokenAccounts: e.tokenAccounts, tokenAccountRawInfos: e.tokenAccountRawInfos }), this.liquidity = new Or({ scope: this, moduleName: "Raydium_LiquidityV2" }), this.token = new $r({ scope: this, moduleName: "Raydium_tokenV2" }), this.tradeV2 = new jr({ scope: this, moduleName: "Raydium_tradeV2" }), this.clmm = new vi({ scope: this, moduleName: "Raydium_clmm" }), this.cpmm = new _r({ scope: this, moduleName: "Raydium_cpmm" }), this.utils1216 = new Bn({ scope: this, moduleName: "Raydium_utils1216" }), this.marketV2 = new Mi({ scope: this, moduleName: "Raydium_marketV2" }), this.ido = new Gi({ scope: this, moduleName: "Raydium_ido" }), this.launchpad = new Hr({ scope: this, moduleName: "Raydium_lauchpad" }), this.availability = {};
        let m = (/* @__PURE__ */ new Date()).getTime();
        this.apiData = {}, a && (this._chainTime = { fetched: m, value: { chainTime: s || Date.now() - a, offset: a } });
      }
      static async load(e) {
        var l;
        let t = (0, bp.merge)({ cluster: "mainnet", owner: null, apiRequestInterval: 3e5, apiRequestTimeout: 1e4 }, e), { cluster: n, apiRequestTimeout: o, logCount: r, logRequests: s, urlConfigs: a } = t, c = new cr({ cluster: n, timeout: o, urlConfigs: a, logCount: r, logRequests: s }), u = new Jr(U(E({}, t), { api: c }));
        return await u.fetchAvailabilityStatus((l = e.disableFeatureCheck) != null ? l : true), e.disableLoadToken || await u.token.load({ type: e.jupTokenType }), u;
      }
      get owner() {
        return this._owner;
      }
      get ownerPubKey() {
        if (!this._owner)
          throw new Error(Vs);
        return this._owner.publicKey;
      }
      setOwner(e) {
        return this._owner = e ? new Pn(e) : void 0, this.account.resetTokenAccounts(), this;
      }
      get connection() {
        if (!this._connection)
          throw new Error(_m);
        return this._connection;
      }
      setConnection(e) {
        return this._connection = e, this;
      }
      get signAllTransactions() {
        return this._signAllTransactions;
      }
      setSignAllTransactions(e) {
        return this._signAllTransactions = e, this;
      }
      checkOwner() {
        if (!this.owner)
          throw console.error(Vs), new Error(Vs);
      }
      isCacheInvalidate(e) {
        return (/* @__PURE__ */ new Date()).getTime() - e > this._apiCacheTime;
      }
      async fetchChainTime() {
        try {
          let e = await this.api.getChainTimeOffset();
          this._chainTime = { fetched: Date.now(), value: { chainTime: Date.now() + e.offset * 1e3, offset: e.offset * 1e3 } };
        } catch {
          this._chainTime = void 0;
        }
      }
      async fetchV3TokenList(e) {
        if (this.apiData.tokenList && !this.isCacheInvalidate(this.apiData.tokenList.fetched) && !e)
          return this.apiData.tokenList.data;
        try {
          let t = await this.api.getTokenList(), n = { fetched: Date.now(), data: t };
          return this.apiData.tokenList = n, n.data;
        } catch (t) {
          return console.error(t), { mintList: [], blacklist: [], whiteList: [] };
        }
      }
      async fetchJupTokenList(e) {
        if (this.cluster === "devnet")
          return [];
        let t = this.apiData.jupTokenList;
        if (t && !this.isCacheInvalidate(t.fetched) && !e)
          return t.data;
        try {
          let n = await this.api.getJupTokenList();
          return this.apiData.jupTokenList = { fetched: Date.now(), data: n.map((o) => U(E({}, o), { mintAuthority: o.mint_authority || void 0, freezeAuthority: o.freeze_authority || void 0 })) }, this.apiData.jupTokenList.data;
        } catch (n) {
          return console.error(n), [];
        }
      }
      get chainTimeData() {
        var e;
        return (e = this._chainTime) == null ? void 0 : e.value;
      }
      async chainTimeOffset() {
        var e;
        return this._chainTime && Date.now() - this._chainTime.fetched <= 1e3 * 60 * 5 ? this._chainTime.value.offset : (await this.fetchChainTime(), ((e = this._chainTime) == null ? void 0 : e.value.offset) || 0);
      }
      async currentBlockChainTime() {
        var e;
        return this._chainTime && Date.now() - this._chainTime.fetched <= 1e3 * 60 * 5 ? this._chainTime.value.chainTime : (await this.fetchChainTime(), ((e = this._chainTime) == null ? void 0 : e.value.chainTime) || Date.now());
      }
      async fetchEpochInfo() {
        return this._epochInfo && Date.now() - this._epochInfo.fetched <= 1e3 * 30 ? this._epochInfo.value : (this._epochInfo = { fetched: Date.now(), value: await this.connection.getEpochInfo() }, this._epochInfo.value);
      }
      async fetchAvailabilityStatus(e) {
        if (e)
          return {};
        try {
          let t = await this.api.fetchAvailabilityStatus(), n = t.all === false;
          return this.availability = { all: t.all, swap: n ? false : t.swap, createConcentratedPosition: n ? false : t.createConcentratedPosition, addConcentratedPosition: n ? false : t.addConcentratedPosition, addStandardPosition: n ? false : t.addStandardPosition, removeConcentratedPosition: n ? false : t.removeConcentratedPosition, removeStandardPosition: n ? false : t.removeStandardPosition, addFarm: n ? false : t.addFarm, removeFarm: n ? false : t.removeFarm }, t;
        } catch {
          return {};
        }
      }
    };
    var yg = (i) => i;
  }
});

// node_modules/@solana/spl-token/lib/cjs/constants.js
var require_constants2 = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/constants.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.programSupportsExtensions = exports2.NATIVE_MINT_2022 = exports2.NATIVE_MINT = exports2.ASSOCIATED_TOKEN_PROGRAM_ID = exports2.TOKEN_2022_PROGRAM_ID = exports2.TOKEN_PROGRAM_ID = void 0;
    var web3_js_1 = require("@solana/web3.js");
    exports2.TOKEN_PROGRAM_ID = new web3_js_1.PublicKey("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA");
    exports2.TOKEN_2022_PROGRAM_ID = new web3_js_1.PublicKey("TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb");
    exports2.ASSOCIATED_TOKEN_PROGRAM_ID = new web3_js_1.PublicKey("ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL");
    exports2.NATIVE_MINT = new web3_js_1.PublicKey("So11111111111111111111111111111111111111112");
    exports2.NATIVE_MINT_2022 = new web3_js_1.PublicKey("9pan9bMn5HatX4EJdBwg9VgCa7Uz5HL8N1m5D3NdXejP");
    function programSupportsExtensions(programId) {
      if (programId === exports2.TOKEN_PROGRAM_ID) {
        return false;
      } else {
        return true;
      }
    }
    exports2.programSupportsExtensions = programSupportsExtensions;
  }
});

// node_modules/@solana/spl-token/lib/cjs/errors.js
var require_errors4 = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/errors.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TokenTransferHookAccountDataNotFound = exports2.TokenTransferHookInvalidSeed = exports2.TokenTransferHookAccountNotFound = exports2.TokenUnsupportedInstructionError = exports2.TokenInvalidInstructionTypeError = exports2.TokenInvalidInstructionDataError = exports2.TokenInvalidInstructionKeysError = exports2.TokenInvalidInstructionProgramError = exports2.TokenOwnerOffCurveError = exports2.TokenInvalidOwnerError = exports2.TokenInvalidMintError = exports2.TokenInvalidAccountSizeError = exports2.TokenInvalidAccountOwnerError = exports2.TokenInvalidAccountDataError = exports2.TokenInvalidAccountError = exports2.TokenAccountNotFoundError = exports2.TokenError = void 0;
    var TokenError = class extends Error {
      constructor(message) {
        super(message);
      }
    };
    exports2.TokenError = TokenError;
    var TokenAccountNotFoundError = class extends TokenError {
      constructor() {
        super(...arguments);
        this.name = "TokenAccountNotFoundError";
      }
    };
    exports2.TokenAccountNotFoundError = TokenAccountNotFoundError;
    var TokenInvalidAccountError = class extends TokenError {
      constructor() {
        super(...arguments);
        this.name = "TokenInvalidAccountError";
      }
    };
    exports2.TokenInvalidAccountError = TokenInvalidAccountError;
    var TokenInvalidAccountDataError = class extends TokenError {
      constructor() {
        super(...arguments);
        this.name = "TokenInvalidAccountDataError";
      }
    };
    exports2.TokenInvalidAccountDataError = TokenInvalidAccountDataError;
    var TokenInvalidAccountOwnerError = class extends TokenError {
      constructor() {
        super(...arguments);
        this.name = "TokenInvalidAccountOwnerError";
      }
    };
    exports2.TokenInvalidAccountOwnerError = TokenInvalidAccountOwnerError;
    var TokenInvalidAccountSizeError = class extends TokenError {
      constructor() {
        super(...arguments);
        this.name = "TokenInvalidAccountSizeError";
      }
    };
    exports2.TokenInvalidAccountSizeError = TokenInvalidAccountSizeError;
    var TokenInvalidMintError = class extends TokenError {
      constructor() {
        super(...arguments);
        this.name = "TokenInvalidMintError";
      }
    };
    exports2.TokenInvalidMintError = TokenInvalidMintError;
    var TokenInvalidOwnerError = class extends TokenError {
      constructor() {
        super(...arguments);
        this.name = "TokenInvalidOwnerError";
      }
    };
    exports2.TokenInvalidOwnerError = TokenInvalidOwnerError;
    var TokenOwnerOffCurveError = class extends TokenError {
      constructor() {
        super(...arguments);
        this.name = "TokenOwnerOffCurveError";
      }
    };
    exports2.TokenOwnerOffCurveError = TokenOwnerOffCurveError;
    var TokenInvalidInstructionProgramError = class extends TokenError {
      constructor() {
        super(...arguments);
        this.name = "TokenInvalidInstructionProgramError";
      }
    };
    exports2.TokenInvalidInstructionProgramError = TokenInvalidInstructionProgramError;
    var TokenInvalidInstructionKeysError = class extends TokenError {
      constructor() {
        super(...arguments);
        this.name = "TokenInvalidInstructionKeysError";
      }
    };
    exports2.TokenInvalidInstructionKeysError = TokenInvalidInstructionKeysError;
    var TokenInvalidInstructionDataError = class extends TokenError {
      constructor() {
        super(...arguments);
        this.name = "TokenInvalidInstructionDataError";
      }
    };
    exports2.TokenInvalidInstructionDataError = TokenInvalidInstructionDataError;
    var TokenInvalidInstructionTypeError = class extends TokenError {
      constructor() {
        super(...arguments);
        this.name = "TokenInvalidInstructionTypeError";
      }
    };
    exports2.TokenInvalidInstructionTypeError = TokenInvalidInstructionTypeError;
    var TokenUnsupportedInstructionError = class extends TokenError {
      constructor() {
        super(...arguments);
        this.name = "TokenUnsupportedInstructionError";
      }
    };
    exports2.TokenUnsupportedInstructionError = TokenUnsupportedInstructionError;
    var TokenTransferHookAccountNotFound = class extends TokenError {
      constructor() {
        super(...arguments);
        this.name = "TokenTransferHookAccountNotFound";
      }
    };
    exports2.TokenTransferHookAccountNotFound = TokenTransferHookAccountNotFound;
    var TokenTransferHookInvalidSeed = class extends TokenError {
      constructor() {
        super(...arguments);
        this.name = "TokenTransferHookInvalidSeed";
      }
    };
    exports2.TokenTransferHookInvalidSeed = TokenTransferHookInvalidSeed;
    var TokenTransferHookAccountDataNotFound = class extends TokenError {
      constructor() {
        super(...arguments);
        this.name = "TokenTransferHookAccountDataNotFound";
      }
    };
    exports2.TokenTransferHookAccountDataNotFound = TokenTransferHookAccountDataNotFound;
  }
});

// node_modules/@solana/spl-token/lib/cjs/instructions/types.js
var require_types2 = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/instructions/types.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TokenInstruction = void 0;
    var TokenInstruction;
    (function(TokenInstruction2) {
      TokenInstruction2[TokenInstruction2["InitializeMint"] = 0] = "InitializeMint";
      TokenInstruction2[TokenInstruction2["InitializeAccount"] = 1] = "InitializeAccount";
      TokenInstruction2[TokenInstruction2["InitializeMultisig"] = 2] = "InitializeMultisig";
      TokenInstruction2[TokenInstruction2["Transfer"] = 3] = "Transfer";
      TokenInstruction2[TokenInstruction2["Approve"] = 4] = "Approve";
      TokenInstruction2[TokenInstruction2["Revoke"] = 5] = "Revoke";
      TokenInstruction2[TokenInstruction2["SetAuthority"] = 6] = "SetAuthority";
      TokenInstruction2[TokenInstruction2["MintTo"] = 7] = "MintTo";
      TokenInstruction2[TokenInstruction2["Burn"] = 8] = "Burn";
      TokenInstruction2[TokenInstruction2["CloseAccount"] = 9] = "CloseAccount";
      TokenInstruction2[TokenInstruction2["FreezeAccount"] = 10] = "FreezeAccount";
      TokenInstruction2[TokenInstruction2["ThawAccount"] = 11] = "ThawAccount";
      TokenInstruction2[TokenInstruction2["TransferChecked"] = 12] = "TransferChecked";
      TokenInstruction2[TokenInstruction2["ApproveChecked"] = 13] = "ApproveChecked";
      TokenInstruction2[TokenInstruction2["MintToChecked"] = 14] = "MintToChecked";
      TokenInstruction2[TokenInstruction2["BurnChecked"] = 15] = "BurnChecked";
      TokenInstruction2[TokenInstruction2["InitializeAccount2"] = 16] = "InitializeAccount2";
      TokenInstruction2[TokenInstruction2["SyncNative"] = 17] = "SyncNative";
      TokenInstruction2[TokenInstruction2["InitializeAccount3"] = 18] = "InitializeAccount3";
      TokenInstruction2[TokenInstruction2["InitializeMultisig2"] = 19] = "InitializeMultisig2";
      TokenInstruction2[TokenInstruction2["InitializeMint2"] = 20] = "InitializeMint2";
      TokenInstruction2[TokenInstruction2["GetAccountDataSize"] = 21] = "GetAccountDataSize";
      TokenInstruction2[TokenInstruction2["InitializeImmutableOwner"] = 22] = "InitializeImmutableOwner";
      TokenInstruction2[TokenInstruction2["AmountToUiAmount"] = 23] = "AmountToUiAmount";
      TokenInstruction2[TokenInstruction2["UiAmountToAmount"] = 24] = "UiAmountToAmount";
      TokenInstruction2[TokenInstruction2["InitializeMintCloseAuthority"] = 25] = "InitializeMintCloseAuthority";
      TokenInstruction2[TokenInstruction2["TransferFeeExtension"] = 26] = "TransferFeeExtension";
      TokenInstruction2[TokenInstruction2["ConfidentialTransferExtension"] = 27] = "ConfidentialTransferExtension";
      TokenInstruction2[TokenInstruction2["DefaultAccountStateExtension"] = 28] = "DefaultAccountStateExtension";
      TokenInstruction2[TokenInstruction2["Reallocate"] = 29] = "Reallocate";
      TokenInstruction2[TokenInstruction2["MemoTransferExtension"] = 30] = "MemoTransferExtension";
      TokenInstruction2[TokenInstruction2["CreateNativeMint"] = 31] = "CreateNativeMint";
      TokenInstruction2[TokenInstruction2["InitializeNonTransferableMint"] = 32] = "InitializeNonTransferableMint";
      TokenInstruction2[TokenInstruction2["InterestBearingMintExtension"] = 33] = "InterestBearingMintExtension";
      TokenInstruction2[TokenInstruction2["CpiGuardExtension"] = 34] = "CpiGuardExtension";
      TokenInstruction2[TokenInstruction2["InitializePermanentDelegate"] = 35] = "InitializePermanentDelegate";
      TokenInstruction2[TokenInstruction2["TransferHookExtension"] = 36] = "TransferHookExtension";
      TokenInstruction2[TokenInstruction2["MetadataPointerExtension"] = 39] = "MetadataPointerExtension";
    })(TokenInstruction || (exports2.TokenInstruction = TokenInstruction = {}));
  }
});

// node_modules/@solana/spl-token/lib/cjs/instructions/amountToUiAmount.js
var require_amountToUiAmount3 = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/instructions/amountToUiAmount.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.decodeAmountToUiAmountInstructionUnchecked = exports2.decodeAmountToUiAmountInstruction = exports2.createAmountToUiAmountInstruction = exports2.amountToUiAmountInstructionData = void 0;
    var buffer_layout_1 = require_Layout();
    var buffer_layout_utils_1 = require_cjs();
    var web3_js_1 = require("@solana/web3.js");
    var constants_js_1 = require_constants2();
    var errors_js_1 = require_errors4();
    var types_js_1 = require_types2();
    exports2.amountToUiAmountInstructionData = (0, buffer_layout_1.struct)([
      (0, buffer_layout_1.u8)("instruction"),
      (0, buffer_layout_utils_1.u64)("amount")
    ]);
    function createAmountToUiAmountInstruction(mint, amount, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      const keys = [{ pubkey: mint, isSigner: false, isWritable: false }];
      const data = Buffer.alloc(exports2.amountToUiAmountInstructionData.span);
      exports2.amountToUiAmountInstructionData.encode({
        instruction: types_js_1.TokenInstruction.AmountToUiAmount,
        amount: BigInt(amount)
      }, data);
      return new web3_js_1.TransactionInstruction({ keys, programId, data });
    }
    exports2.createAmountToUiAmountInstruction = createAmountToUiAmountInstruction;
    function decodeAmountToUiAmountInstruction(instruction, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      if (!instruction.programId.equals(programId))
        throw new errors_js_1.TokenInvalidInstructionProgramError();
      if (instruction.data.length !== exports2.amountToUiAmountInstructionData.span)
        throw new errors_js_1.TokenInvalidInstructionDataError();
      const { keys: { mint }, data } = decodeAmountToUiAmountInstructionUnchecked(instruction);
      if (data.instruction !== types_js_1.TokenInstruction.AmountToUiAmount)
        throw new errors_js_1.TokenInvalidInstructionTypeError();
      if (!mint)
        throw new errors_js_1.TokenInvalidInstructionKeysError();
      return {
        programId,
        keys: {
          mint
        },
        data
      };
    }
    exports2.decodeAmountToUiAmountInstruction = decodeAmountToUiAmountInstruction;
    function decodeAmountToUiAmountInstructionUnchecked({ programId, keys: [mint], data }) {
      return {
        programId,
        keys: {
          mint
        },
        data: exports2.amountToUiAmountInstructionData.decode(data)
      };
    }
    exports2.decodeAmountToUiAmountInstructionUnchecked = decodeAmountToUiAmountInstructionUnchecked;
  }
});

// node_modules/@solana/spl-token/lib/cjs/actions/amountToUiAmount.js
var require_amountToUiAmount4 = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/actions/amountToUiAmount.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.amountToUiAmount = void 0;
    var web3_js_1 = require("@solana/web3.js");
    var constants_js_1 = require_constants2();
    var amountToUiAmount_js_1 = require_amountToUiAmount3();
    function amountToUiAmount(connection, payer, mint, amount, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      return __awaiter(this, void 0, void 0, function* () {
        const transaction = new web3_js_1.Transaction().add((0, amountToUiAmount_js_1.createAmountToUiAmountInstruction)(mint, amount, programId));
        const { returnData, err } = (yield connection.simulateTransaction(transaction, [payer], false)).value;
        if (returnData === null || returnData === void 0 ? void 0 : returnData.data) {
          return Buffer.from(returnData.data[0], returnData.data[1]).toString("utf-8");
        }
        return err;
      });
    }
    exports2.amountToUiAmount = amountToUiAmount;
  }
});

// node_modules/@solana/spl-token/lib/cjs/instructions/internal.js
var require_internal3 = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/instructions/internal.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.addSigners = void 0;
    var web3_js_1 = require("@solana/web3.js");
    function addSigners(keys, ownerOrAuthority, multiSigners) {
      if (multiSigners.length) {
        keys.push({ pubkey: ownerOrAuthority, isSigner: false, isWritable: false });
        for (const signer of multiSigners) {
          keys.push({
            pubkey: signer instanceof web3_js_1.PublicKey ? signer : signer.publicKey,
            isSigner: true,
            isWritable: false
          });
        }
      } else {
        keys.push({ pubkey: ownerOrAuthority, isSigner: true, isWritable: false });
      }
      return keys;
    }
    exports2.addSigners = addSigners;
  }
});

// node_modules/@solana/spl-token/lib/cjs/instructions/approve.js
var require_approve3 = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/instructions/approve.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.decodeApproveInstructionUnchecked = exports2.decodeApproveInstruction = exports2.createApproveInstruction = exports2.approveInstructionData = void 0;
    var buffer_layout_1 = require_Layout();
    var buffer_layout_utils_1 = require_cjs();
    var web3_js_1 = require("@solana/web3.js");
    var constants_js_1 = require_constants2();
    var errors_js_1 = require_errors4();
    var internal_js_1 = require_internal3();
    var types_js_1 = require_types2();
    exports2.approveInstructionData = (0, buffer_layout_1.struct)([(0, buffer_layout_1.u8)("instruction"), (0, buffer_layout_utils_1.u64)("amount")]);
    function createApproveInstruction(account, delegate, owner, amount, multiSigners = [], programId = constants_js_1.TOKEN_PROGRAM_ID) {
      const keys = (0, internal_js_1.addSigners)([
        { pubkey: account, isSigner: false, isWritable: true },
        { pubkey: delegate, isSigner: false, isWritable: false }
      ], owner, multiSigners);
      const data = Buffer.alloc(exports2.approveInstructionData.span);
      exports2.approveInstructionData.encode({
        instruction: types_js_1.TokenInstruction.Approve,
        amount: BigInt(amount)
      }, data);
      return new web3_js_1.TransactionInstruction({ keys, programId, data });
    }
    exports2.createApproveInstruction = createApproveInstruction;
    function decodeApproveInstruction(instruction, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      if (!instruction.programId.equals(programId))
        throw new errors_js_1.TokenInvalidInstructionProgramError();
      if (instruction.data.length !== exports2.approveInstructionData.span)
        throw new errors_js_1.TokenInvalidInstructionDataError();
      const { keys: { account, delegate, owner, multiSigners }, data } = decodeApproveInstructionUnchecked(instruction);
      if (data.instruction !== types_js_1.TokenInstruction.Approve)
        throw new errors_js_1.TokenInvalidInstructionTypeError();
      if (!account || !delegate || !owner)
        throw new errors_js_1.TokenInvalidInstructionKeysError();
      return {
        programId,
        keys: {
          account,
          delegate,
          owner,
          multiSigners
        },
        data
      };
    }
    exports2.decodeApproveInstruction = decodeApproveInstruction;
    function decodeApproveInstructionUnchecked({ programId, keys: [account, delegate, owner, ...multiSigners], data }) {
      return {
        programId,
        keys: {
          account,
          delegate,
          owner,
          multiSigners
        },
        data: exports2.approveInstructionData.decode(data)
      };
    }
    exports2.decodeApproveInstructionUnchecked = decodeApproveInstructionUnchecked;
  }
});

// node_modules/@solana/spl-token/lib/cjs/actions/internal.js
var require_internal4 = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/actions/internal.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getSigners = void 0;
    var web3_js_1 = require("@solana/web3.js");
    function getSigners(signerOrMultisig, multiSigners) {
      return signerOrMultisig instanceof web3_js_1.PublicKey ? [signerOrMultisig, multiSigners] : [signerOrMultisig.publicKey, [signerOrMultisig]];
    }
    exports2.getSigners = getSigners;
  }
});

// node_modules/@solana/spl-token/lib/cjs/actions/approve.js
var require_approve4 = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/actions/approve.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.approve = void 0;
    var web3_js_1 = require("@solana/web3.js");
    var constants_js_1 = require_constants2();
    var approve_js_1 = require_approve3();
    var internal_js_1 = require_internal4();
    function approve(connection, payer, account, delegate, owner, amount, multiSigners = [], confirmOptions, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      return __awaiter(this, void 0, void 0, function* () {
        const [ownerPublicKey, signers] = (0, internal_js_1.getSigners)(owner, multiSigners);
        const transaction = new web3_js_1.Transaction().add((0, approve_js_1.createApproveInstruction)(account, delegate, ownerPublicKey, amount, multiSigners, programId));
        return yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer, ...signers], confirmOptions);
      });
    }
    exports2.approve = approve;
  }
});

// node_modules/@solana/spl-token/lib/cjs/instructions/approveChecked.js
var require_approveChecked3 = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/instructions/approveChecked.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.decodeApproveCheckedInstructionUnchecked = exports2.decodeApproveCheckedInstruction = exports2.createApproveCheckedInstruction = exports2.approveCheckedInstructionData = void 0;
    var buffer_layout_1 = require_Layout();
    var buffer_layout_utils_1 = require_cjs();
    var web3_js_1 = require("@solana/web3.js");
    var constants_js_1 = require_constants2();
    var errors_js_1 = require_errors4();
    var internal_js_1 = require_internal3();
    var types_js_1 = require_types2();
    exports2.approveCheckedInstructionData = (0, buffer_layout_1.struct)([
      (0, buffer_layout_1.u8)("instruction"),
      (0, buffer_layout_utils_1.u64)("amount"),
      (0, buffer_layout_1.u8)("decimals")
    ]);
    function createApproveCheckedInstruction(account, mint, delegate, owner, amount, decimals, multiSigners = [], programId = constants_js_1.TOKEN_PROGRAM_ID) {
      const keys = (0, internal_js_1.addSigners)([
        { pubkey: account, isSigner: false, isWritable: true },
        { pubkey: mint, isSigner: false, isWritable: false },
        { pubkey: delegate, isSigner: false, isWritable: false }
      ], owner, multiSigners);
      const data = Buffer.alloc(exports2.approveCheckedInstructionData.span);
      exports2.approveCheckedInstructionData.encode({
        instruction: types_js_1.TokenInstruction.ApproveChecked,
        amount: BigInt(amount),
        decimals
      }, data);
      return new web3_js_1.TransactionInstruction({ keys, programId, data });
    }
    exports2.createApproveCheckedInstruction = createApproveCheckedInstruction;
    function decodeApproveCheckedInstruction(instruction, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      if (!instruction.programId.equals(programId))
        throw new errors_js_1.TokenInvalidInstructionProgramError();
      if (instruction.data.length !== exports2.approveCheckedInstructionData.span)
        throw new errors_js_1.TokenInvalidInstructionDataError();
      const { keys: { account, mint, delegate, owner, multiSigners }, data } = decodeApproveCheckedInstructionUnchecked(instruction);
      if (data.instruction !== types_js_1.TokenInstruction.ApproveChecked)
        throw new errors_js_1.TokenInvalidInstructionTypeError();
      if (!account || !mint || !delegate || !owner)
        throw new errors_js_1.TokenInvalidInstructionKeysError();
      return {
        programId,
        keys: {
          account,
          mint,
          delegate,
          owner,
          multiSigners
        },
        data
      };
    }
    exports2.decodeApproveCheckedInstruction = decodeApproveCheckedInstruction;
    function decodeApproveCheckedInstructionUnchecked({ programId, keys: [account, mint, delegate, owner, ...multiSigners], data }) {
      return {
        programId,
        keys: {
          account,
          mint,
          delegate,
          owner,
          multiSigners
        },
        data: exports2.approveCheckedInstructionData.decode(data)
      };
    }
    exports2.decodeApproveCheckedInstructionUnchecked = decodeApproveCheckedInstructionUnchecked;
  }
});

// node_modules/@solana/spl-token/lib/cjs/actions/approveChecked.js
var require_approveChecked4 = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/actions/approveChecked.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.approveChecked = void 0;
    var web3_js_1 = require("@solana/web3.js");
    var constants_js_1 = require_constants2();
    var approveChecked_js_1 = require_approveChecked3();
    var internal_js_1 = require_internal4();
    function approveChecked(connection, payer, mint, account, delegate, owner, amount, decimals, multiSigners = [], confirmOptions, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      return __awaiter(this, void 0, void 0, function* () {
        const [ownerPublicKey, signers] = (0, internal_js_1.getSigners)(owner, multiSigners);
        const transaction = new web3_js_1.Transaction().add((0, approveChecked_js_1.createApproveCheckedInstruction)(account, mint, delegate, ownerPublicKey, amount, decimals, multiSigners, programId));
        return yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer, ...signers], confirmOptions);
      });
    }
    exports2.approveChecked = approveChecked;
  }
});

// node_modules/@solana/spl-token/lib/cjs/instructions/burn.js
var require_burn3 = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/instructions/burn.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.decodeBurnInstructionUnchecked = exports2.decodeBurnInstruction = exports2.createBurnInstruction = exports2.burnInstructionData = void 0;
    var buffer_layout_1 = require_Layout();
    var buffer_layout_utils_1 = require_cjs();
    var web3_js_1 = require("@solana/web3.js");
    var constants_js_1 = require_constants2();
    var errors_js_1 = require_errors4();
    var internal_js_1 = require_internal3();
    var types_js_1 = require_types2();
    exports2.burnInstructionData = (0, buffer_layout_1.struct)([(0, buffer_layout_1.u8)("instruction"), (0, buffer_layout_utils_1.u64)("amount")]);
    function createBurnInstruction(account, mint, owner, amount, multiSigners = [], programId = constants_js_1.TOKEN_PROGRAM_ID) {
      const keys = (0, internal_js_1.addSigners)([
        { pubkey: account, isSigner: false, isWritable: true },
        { pubkey: mint, isSigner: false, isWritable: true }
      ], owner, multiSigners);
      const data = Buffer.alloc(exports2.burnInstructionData.span);
      exports2.burnInstructionData.encode({
        instruction: types_js_1.TokenInstruction.Burn,
        amount: BigInt(amount)
      }, data);
      return new web3_js_1.TransactionInstruction({ keys, programId, data });
    }
    exports2.createBurnInstruction = createBurnInstruction;
    function decodeBurnInstruction(instruction, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      if (!instruction.programId.equals(programId))
        throw new errors_js_1.TokenInvalidInstructionProgramError();
      if (instruction.data.length !== exports2.burnInstructionData.span)
        throw new errors_js_1.TokenInvalidInstructionDataError();
      const { keys: { account, mint, owner, multiSigners }, data } = decodeBurnInstructionUnchecked(instruction);
      if (data.instruction !== types_js_1.TokenInstruction.Burn)
        throw new errors_js_1.TokenInvalidInstructionTypeError();
      if (!account || !mint || !owner)
        throw new errors_js_1.TokenInvalidInstructionKeysError();
      return {
        programId,
        keys: {
          account,
          mint,
          owner,
          multiSigners
        },
        data
      };
    }
    exports2.decodeBurnInstruction = decodeBurnInstruction;
    function decodeBurnInstructionUnchecked({ programId, keys: [account, mint, owner, ...multiSigners], data }) {
      return {
        programId,
        keys: {
          account,
          mint,
          owner,
          multiSigners
        },
        data: exports2.burnInstructionData.decode(data)
      };
    }
    exports2.decodeBurnInstructionUnchecked = decodeBurnInstructionUnchecked;
  }
});

// node_modules/@solana/spl-token/lib/cjs/actions/burn.js
var require_burn4 = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/actions/burn.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.burn = void 0;
    var web3_js_1 = require("@solana/web3.js");
    var constants_js_1 = require_constants2();
    var burn_js_1 = require_burn3();
    var internal_js_1 = require_internal4();
    function burn(connection, payer, account, mint, owner, amount, multiSigners = [], confirmOptions, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      return __awaiter(this, void 0, void 0, function* () {
        const [ownerPublicKey, signers] = (0, internal_js_1.getSigners)(owner, multiSigners);
        const transaction = new web3_js_1.Transaction().add((0, burn_js_1.createBurnInstruction)(account, mint, ownerPublicKey, amount, multiSigners, programId));
        return yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer, ...signers], confirmOptions);
      });
    }
    exports2.burn = burn;
  }
});

// node_modules/@solana/spl-token/lib/cjs/instructions/burnChecked.js
var require_burnChecked3 = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/instructions/burnChecked.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.decodeBurnCheckedInstructionUnchecked = exports2.decodeBurnCheckedInstruction = exports2.createBurnCheckedInstruction = exports2.burnCheckedInstructionData = void 0;
    var buffer_layout_1 = require_Layout();
    var buffer_layout_utils_1 = require_cjs();
    var web3_js_1 = require("@solana/web3.js");
    var constants_js_1 = require_constants2();
    var errors_js_1 = require_errors4();
    var internal_js_1 = require_internal3();
    var types_js_1 = require_types2();
    exports2.burnCheckedInstructionData = (0, buffer_layout_1.struct)([
      (0, buffer_layout_1.u8)("instruction"),
      (0, buffer_layout_utils_1.u64)("amount"),
      (0, buffer_layout_1.u8)("decimals")
    ]);
    function createBurnCheckedInstruction(account, mint, owner, amount, decimals, multiSigners = [], programId = constants_js_1.TOKEN_PROGRAM_ID) {
      const keys = (0, internal_js_1.addSigners)([
        { pubkey: account, isSigner: false, isWritable: true },
        { pubkey: mint, isSigner: false, isWritable: true }
      ], owner, multiSigners);
      const data = Buffer.alloc(exports2.burnCheckedInstructionData.span);
      exports2.burnCheckedInstructionData.encode({
        instruction: types_js_1.TokenInstruction.BurnChecked,
        amount: BigInt(amount),
        decimals
      }, data);
      return new web3_js_1.TransactionInstruction({ keys, programId, data });
    }
    exports2.createBurnCheckedInstruction = createBurnCheckedInstruction;
    function decodeBurnCheckedInstruction(instruction, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      if (!instruction.programId.equals(programId))
        throw new errors_js_1.TokenInvalidInstructionProgramError();
      if (instruction.data.length !== exports2.burnCheckedInstructionData.span)
        throw new errors_js_1.TokenInvalidInstructionDataError();
      const { keys: { account, mint, owner, multiSigners }, data } = decodeBurnCheckedInstructionUnchecked(instruction);
      if (data.instruction !== types_js_1.TokenInstruction.BurnChecked)
        throw new errors_js_1.TokenInvalidInstructionTypeError();
      if (!account || !mint || !owner)
        throw new errors_js_1.TokenInvalidInstructionKeysError();
      return {
        programId,
        keys: {
          account,
          mint,
          owner,
          multiSigners
        },
        data
      };
    }
    exports2.decodeBurnCheckedInstruction = decodeBurnCheckedInstruction;
    function decodeBurnCheckedInstructionUnchecked({ programId, keys: [account, mint, owner, ...multiSigners], data }) {
      return {
        programId,
        keys: {
          account,
          mint,
          owner,
          multiSigners
        },
        data: exports2.burnCheckedInstructionData.decode(data)
      };
    }
    exports2.decodeBurnCheckedInstructionUnchecked = decodeBurnCheckedInstructionUnchecked;
  }
});

// node_modules/@solana/spl-token/lib/cjs/actions/burnChecked.js
var require_burnChecked4 = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/actions/burnChecked.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.burnChecked = void 0;
    var web3_js_1 = require("@solana/web3.js");
    var constants_js_1 = require_constants2();
    var burnChecked_js_1 = require_burnChecked3();
    var internal_js_1 = require_internal4();
    function burnChecked(connection, payer, account, mint, owner, amount, decimals, multiSigners = [], confirmOptions, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      return __awaiter(this, void 0, void 0, function* () {
        const [ownerPublicKey, signers] = (0, internal_js_1.getSigners)(owner, multiSigners);
        const transaction = new web3_js_1.Transaction().add((0, burnChecked_js_1.createBurnCheckedInstruction)(account, mint, ownerPublicKey, amount, decimals, multiSigners, programId));
        return yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer, ...signers], confirmOptions);
      });
    }
    exports2.burnChecked = burnChecked;
  }
});

// node_modules/@solana/spl-token/lib/cjs/instructions/closeAccount.js
var require_closeAccount3 = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/instructions/closeAccount.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.decodeCloseAccountInstructionUnchecked = exports2.decodeCloseAccountInstruction = exports2.createCloseAccountInstruction = exports2.closeAccountInstructionData = void 0;
    var buffer_layout_1 = require_Layout();
    var web3_js_1 = require("@solana/web3.js");
    var constants_js_1 = require_constants2();
    var errors_js_1 = require_errors4();
    var internal_js_1 = require_internal3();
    var types_js_1 = require_types2();
    exports2.closeAccountInstructionData = (0, buffer_layout_1.struct)([(0, buffer_layout_1.u8)("instruction")]);
    function createCloseAccountInstruction(account, destination, authority, multiSigners = [], programId = constants_js_1.TOKEN_PROGRAM_ID) {
      const keys = (0, internal_js_1.addSigners)([
        { pubkey: account, isSigner: false, isWritable: true },
        { pubkey: destination, isSigner: false, isWritable: true }
      ], authority, multiSigners);
      const data = Buffer.alloc(exports2.closeAccountInstructionData.span);
      exports2.closeAccountInstructionData.encode({ instruction: types_js_1.TokenInstruction.CloseAccount }, data);
      return new web3_js_1.TransactionInstruction({ keys, programId, data });
    }
    exports2.createCloseAccountInstruction = createCloseAccountInstruction;
    function decodeCloseAccountInstruction(instruction, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      if (!instruction.programId.equals(programId))
        throw new errors_js_1.TokenInvalidInstructionProgramError();
      if (instruction.data.length !== exports2.closeAccountInstructionData.span)
        throw new errors_js_1.TokenInvalidInstructionDataError();
      const { keys: { account, destination, authority, multiSigners }, data } = decodeCloseAccountInstructionUnchecked(instruction);
      if (data.instruction !== types_js_1.TokenInstruction.CloseAccount)
        throw new errors_js_1.TokenInvalidInstructionTypeError();
      if (!account || !destination || !authority)
        throw new errors_js_1.TokenInvalidInstructionKeysError();
      return {
        programId,
        keys: {
          account,
          destination,
          authority,
          multiSigners
        },
        data
      };
    }
    exports2.decodeCloseAccountInstruction = decodeCloseAccountInstruction;
    function decodeCloseAccountInstructionUnchecked({ programId, keys: [account, destination, authority, ...multiSigners], data }) {
      return {
        programId,
        keys: {
          account,
          destination,
          authority,
          multiSigners
        },
        data: exports2.closeAccountInstructionData.decode(data)
      };
    }
    exports2.decodeCloseAccountInstructionUnchecked = decodeCloseAccountInstructionUnchecked;
  }
});

// node_modules/@solana/spl-token/lib/cjs/actions/closeAccount.js
var require_closeAccount4 = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/actions/closeAccount.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.closeAccount = void 0;
    var web3_js_1 = require("@solana/web3.js");
    var constants_js_1 = require_constants2();
    var closeAccount_js_1 = require_closeAccount3();
    var internal_js_1 = require_internal4();
    function closeAccount(connection, payer, account, destination, authority, multiSigners = [], confirmOptions, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      return __awaiter(this, void 0, void 0, function* () {
        const [authorityPublicKey, signers] = (0, internal_js_1.getSigners)(authority, multiSigners);
        const transaction = new web3_js_1.Transaction().add((0, closeAccount_js_1.createCloseAccountInstruction)(account, destination, authorityPublicKey, multiSigners, programId));
        return yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer, ...signers], confirmOptions);
      });
    }
    exports2.closeAccount = closeAccount;
  }
});

// node_modules/@solana/spl-token/lib/cjs/extensions/accountType.js
var require_accountType2 = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/extensions/accountType.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ACCOUNT_TYPE_SIZE = exports2.AccountType = void 0;
    var AccountType2;
    (function(AccountType3) {
      AccountType3[AccountType3["Uninitialized"] = 0] = "Uninitialized";
      AccountType3[AccountType3["Mint"] = 1] = "Mint";
      AccountType3[AccountType3["Account"] = 2] = "Account";
    })(AccountType2 || (exports2.AccountType = AccountType2 = {}));
    exports2.ACCOUNT_TYPE_SIZE = 1;
  }
});

// node_modules/@solana/spl-token/lib/cjs/state/multisig.js
var require_multisig2 = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/state/multisig.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getMinimumBalanceForRentExemptMultisig = exports2.unpackMultisig = exports2.getMultisig = exports2.MULTISIG_SIZE = exports2.MultisigLayout = void 0;
    var buffer_layout_1 = require_Layout();
    var buffer_layout_utils_1 = require_cjs();
    var constants_js_1 = require_constants2();
    var errors_js_1 = require_errors4();
    exports2.MultisigLayout = (0, buffer_layout_1.struct)([
      (0, buffer_layout_1.u8)("m"),
      (0, buffer_layout_1.u8)("n"),
      (0, buffer_layout_utils_1.bool)("isInitialized"),
      (0, buffer_layout_utils_1.publicKey)("signer1"),
      (0, buffer_layout_utils_1.publicKey)("signer2"),
      (0, buffer_layout_utils_1.publicKey)("signer3"),
      (0, buffer_layout_utils_1.publicKey)("signer4"),
      (0, buffer_layout_utils_1.publicKey)("signer5"),
      (0, buffer_layout_utils_1.publicKey)("signer6"),
      (0, buffer_layout_utils_1.publicKey)("signer7"),
      (0, buffer_layout_utils_1.publicKey)("signer8"),
      (0, buffer_layout_utils_1.publicKey)("signer9"),
      (0, buffer_layout_utils_1.publicKey)("signer10"),
      (0, buffer_layout_utils_1.publicKey)("signer11")
    ]);
    exports2.MULTISIG_SIZE = exports2.MultisigLayout.span;
    function getMultisig(connection, address, commitment, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      return __awaiter(this, void 0, void 0, function* () {
        const info = yield connection.getAccountInfo(address, commitment);
        return unpackMultisig(address, info, programId);
      });
    }
    exports2.getMultisig = getMultisig;
    function unpackMultisig(address, info, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      if (!info)
        throw new errors_js_1.TokenAccountNotFoundError();
      if (!info.owner.equals(programId))
        throw new errors_js_1.TokenInvalidAccountOwnerError();
      if (info.data.length != exports2.MULTISIG_SIZE)
        throw new errors_js_1.TokenInvalidAccountSizeError();
      const multisig = exports2.MultisigLayout.decode(info.data);
      return Object.assign({ address }, multisig);
    }
    exports2.unpackMultisig = unpackMultisig;
    function getMinimumBalanceForRentExemptMultisig(connection, commitment) {
      return __awaiter(this, void 0, void 0, function* () {
        return yield connection.getMinimumBalanceForRentExemption(exports2.MULTISIG_SIZE, commitment);
      });
    }
    exports2.getMinimumBalanceForRentExemptMultisig = getMinimumBalanceForRentExemptMultisig;
  }
});

// node_modules/@solana/spl-token/lib/cjs/state/account.js
var require_account2 = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/state/account.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.unpackAccount = exports2.getMinimumBalanceForRentExemptAccountWithExtensions = exports2.getMinimumBalanceForRentExemptAccount = exports2.getMultipleAccounts = exports2.getAccount = exports2.ACCOUNT_SIZE = exports2.AccountLayout = exports2.AccountState = void 0;
    var buffer_layout_1 = require_Layout();
    var buffer_layout_utils_1 = require_cjs();
    var constants_js_1 = require_constants2();
    var errors_js_1 = require_errors4();
    var accountType_js_1 = require_accountType2();
    var extensionType_js_1 = require_extensionType2();
    var multisig_js_1 = require_multisig2();
    var AccountState2;
    (function(AccountState3) {
      AccountState3[AccountState3["Uninitialized"] = 0] = "Uninitialized";
      AccountState3[AccountState3["Initialized"] = 1] = "Initialized";
      AccountState3[AccountState3["Frozen"] = 2] = "Frozen";
    })(AccountState2 || (exports2.AccountState = AccountState2 = {}));
    exports2.AccountLayout = (0, buffer_layout_1.struct)([
      (0, buffer_layout_utils_1.publicKey)("mint"),
      (0, buffer_layout_utils_1.publicKey)("owner"),
      (0, buffer_layout_utils_1.u64)("amount"),
      (0, buffer_layout_1.u32)("delegateOption"),
      (0, buffer_layout_utils_1.publicKey)("delegate"),
      (0, buffer_layout_1.u8)("state"),
      (0, buffer_layout_1.u32)("isNativeOption"),
      (0, buffer_layout_utils_1.u64)("isNative"),
      (0, buffer_layout_utils_1.u64)("delegatedAmount"),
      (0, buffer_layout_1.u32)("closeAuthorityOption"),
      (0, buffer_layout_utils_1.publicKey)("closeAuthority")
    ]);
    exports2.ACCOUNT_SIZE = exports2.AccountLayout.span;
    function getAccount(connection, address, commitment, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      return __awaiter(this, void 0, void 0, function* () {
        const info = yield connection.getAccountInfo(address, commitment);
        return unpackAccount(address, info, programId);
      });
    }
    exports2.getAccount = getAccount;
    function getMultipleAccounts(connection, addresses, commitment, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      return __awaiter(this, void 0, void 0, function* () {
        const infos = yield connection.getMultipleAccountsInfo(addresses, commitment);
        return addresses.map((address, i) => unpackAccount(address, infos[i], programId));
      });
    }
    exports2.getMultipleAccounts = getMultipleAccounts;
    function getMinimumBalanceForRentExemptAccount(connection, commitment) {
      return __awaiter(this, void 0, void 0, function* () {
        return yield getMinimumBalanceForRentExemptAccountWithExtensions(connection, [], commitment);
      });
    }
    exports2.getMinimumBalanceForRentExemptAccount = getMinimumBalanceForRentExemptAccount;
    function getMinimumBalanceForRentExemptAccountWithExtensions(connection, extensions, commitment) {
      return __awaiter(this, void 0, void 0, function* () {
        const accountLen = (0, extensionType_js_1.getAccountLen)(extensions);
        return yield connection.getMinimumBalanceForRentExemption(accountLen, commitment);
      });
    }
    exports2.getMinimumBalanceForRentExemptAccountWithExtensions = getMinimumBalanceForRentExemptAccountWithExtensions;
    function unpackAccount(address, info, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      if (!info)
        throw new errors_js_1.TokenAccountNotFoundError();
      if (!info.owner.equals(programId))
        throw new errors_js_1.TokenInvalidAccountOwnerError();
      if (info.data.length < exports2.ACCOUNT_SIZE)
        throw new errors_js_1.TokenInvalidAccountSizeError();
      const rawAccount = exports2.AccountLayout.decode(info.data.slice(0, exports2.ACCOUNT_SIZE));
      let tlvData = Buffer.alloc(0);
      if (info.data.length > exports2.ACCOUNT_SIZE) {
        if (info.data.length === multisig_js_1.MULTISIG_SIZE)
          throw new errors_js_1.TokenInvalidAccountSizeError();
        if (info.data[exports2.ACCOUNT_SIZE] != accountType_js_1.AccountType.Account)
          throw new errors_js_1.TokenInvalidAccountError();
        tlvData = info.data.slice(exports2.ACCOUNT_SIZE + accountType_js_1.ACCOUNT_TYPE_SIZE);
      }
      return {
        address,
        mint: rawAccount.mint,
        owner: rawAccount.owner,
        amount: rawAccount.amount,
        delegate: rawAccount.delegateOption ? rawAccount.delegate : null,
        delegatedAmount: rawAccount.delegatedAmount,
        isInitialized: rawAccount.state !== AccountState2.Uninitialized,
        isFrozen: rawAccount.state === AccountState2.Frozen,
        isNative: !!rawAccount.isNativeOption,
        rentExemptReserve: rawAccount.isNativeOption ? rawAccount.isNative : null,
        closeAuthority: rawAccount.closeAuthorityOption ? rawAccount.closeAuthority : null,
        tlvData
      };
    }
    exports2.unpackAccount = unpackAccount;
  }
});

// node_modules/@solana/spl-token/lib/cjs/state/mint.js
var require_mint2 = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/state/mint.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getAssociatedTokenAddressSync = exports2.getAssociatedTokenAddress = exports2.getMinimumBalanceForRentExemptMintWithExtensions = exports2.getMinimumBalanceForRentExemptMint = exports2.unpackMint = exports2.getMint = exports2.MINT_SIZE = exports2.MintLayout = void 0;
    var buffer_layout_1 = require_Layout();
    var buffer_layout_utils_1 = require_cjs();
    var web3_js_1 = require("@solana/web3.js");
    var constants_js_1 = require_constants2();
    var errors_js_1 = require_errors4();
    var accountType_js_1 = require_accountType2();
    var extensionType_js_1 = require_extensionType2();
    var account_js_1 = require_account2();
    var multisig_js_1 = require_multisig2();
    exports2.MintLayout = (0, buffer_layout_1.struct)([
      (0, buffer_layout_1.u32)("mintAuthorityOption"),
      (0, buffer_layout_utils_1.publicKey)("mintAuthority"),
      (0, buffer_layout_utils_1.u64)("supply"),
      (0, buffer_layout_1.u8)("decimals"),
      (0, buffer_layout_utils_1.bool)("isInitialized"),
      (0, buffer_layout_1.u32)("freezeAuthorityOption"),
      (0, buffer_layout_utils_1.publicKey)("freezeAuthority")
    ]);
    exports2.MINT_SIZE = exports2.MintLayout.span;
    function getMint(connection, address, commitment, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      return __awaiter(this, void 0, void 0, function* () {
        const info = yield connection.getAccountInfo(address, commitment);
        return unpackMint(address, info, programId);
      });
    }
    exports2.getMint = getMint;
    function unpackMint(address, info, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      if (!info)
        throw new errors_js_1.TokenAccountNotFoundError();
      if (!info.owner.equals(programId))
        throw new errors_js_1.TokenInvalidAccountOwnerError();
      if (info.data.length < exports2.MINT_SIZE)
        throw new errors_js_1.TokenInvalidAccountSizeError();
      const rawMint = exports2.MintLayout.decode(info.data.slice(0, exports2.MINT_SIZE));
      let tlvData = Buffer.alloc(0);
      if (info.data.length > exports2.MINT_SIZE) {
        if (info.data.length <= account_js_1.ACCOUNT_SIZE)
          throw new errors_js_1.TokenInvalidAccountSizeError();
        if (info.data.length === multisig_js_1.MULTISIG_SIZE)
          throw new errors_js_1.TokenInvalidAccountSizeError();
        if (info.data[account_js_1.ACCOUNT_SIZE] != accountType_js_1.AccountType.Mint)
          throw new errors_js_1.TokenInvalidMintError();
        tlvData = info.data.slice(account_js_1.ACCOUNT_SIZE + accountType_js_1.ACCOUNT_TYPE_SIZE);
      }
      return {
        address,
        mintAuthority: rawMint.mintAuthorityOption ? rawMint.mintAuthority : null,
        supply: rawMint.supply,
        decimals: rawMint.decimals,
        isInitialized: rawMint.isInitialized,
        freezeAuthority: rawMint.freezeAuthorityOption ? rawMint.freezeAuthority : null,
        tlvData
      };
    }
    exports2.unpackMint = unpackMint;
    function getMinimumBalanceForRentExemptMint(connection, commitment) {
      return __awaiter(this, void 0, void 0, function* () {
        return yield getMinimumBalanceForRentExemptMintWithExtensions(connection, [], commitment);
      });
    }
    exports2.getMinimumBalanceForRentExemptMint = getMinimumBalanceForRentExemptMint;
    function getMinimumBalanceForRentExemptMintWithExtensions(connection, extensions, commitment) {
      return __awaiter(this, void 0, void 0, function* () {
        const mintLen = (0, extensionType_js_1.getMintLen)(extensions);
        return yield connection.getMinimumBalanceForRentExemption(mintLen, commitment);
      });
    }
    exports2.getMinimumBalanceForRentExemptMintWithExtensions = getMinimumBalanceForRentExemptMintWithExtensions;
    function getAssociatedTokenAddress(mint, owner, allowOwnerOffCurve = false, programId = constants_js_1.TOKEN_PROGRAM_ID, associatedTokenProgramId = constants_js_1.ASSOCIATED_TOKEN_PROGRAM_ID) {
      return __awaiter(this, void 0, void 0, function* () {
        if (!allowOwnerOffCurve && !web3_js_1.PublicKey.isOnCurve(owner.toBuffer()))
          throw new errors_js_1.TokenOwnerOffCurveError();
        const [address] = yield web3_js_1.PublicKey.findProgramAddress([owner.toBuffer(), programId.toBuffer(), mint.toBuffer()], associatedTokenProgramId);
        return address;
      });
    }
    exports2.getAssociatedTokenAddress = getAssociatedTokenAddress;
    function getAssociatedTokenAddressSync(mint, owner, allowOwnerOffCurve = false, programId = constants_js_1.TOKEN_PROGRAM_ID, associatedTokenProgramId = constants_js_1.ASSOCIATED_TOKEN_PROGRAM_ID) {
      if (!allowOwnerOffCurve && !web3_js_1.PublicKey.isOnCurve(owner.toBuffer()))
        throw new errors_js_1.TokenOwnerOffCurveError();
      const [address] = web3_js_1.PublicKey.findProgramAddressSync([owner.toBuffer(), programId.toBuffer(), mint.toBuffer()], associatedTokenProgramId);
      return address;
    }
    exports2.getAssociatedTokenAddressSync = getAssociatedTokenAddressSync;
  }
});

// node_modules/@solana/spl-token/lib/cjs/extensions/cpiGuard/instructions.js
var require_instructions13 = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/extensions/cpiGuard/instructions.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createDisableCpiGuardInstruction = exports2.createEnableCpiGuardInstruction = exports2.cpiGuardInstructionData = exports2.CpiGuardInstruction = void 0;
    var buffer_layout_1 = require_Layout();
    var web3_js_1 = require("@solana/web3.js");
    var constants_js_1 = require_constants2();
    var errors_js_1 = require_errors4();
    var internal_js_1 = require_internal3();
    var types_js_1 = require_types2();
    var CpiGuardInstruction;
    (function(CpiGuardInstruction2) {
      CpiGuardInstruction2[CpiGuardInstruction2["Enable"] = 0] = "Enable";
      CpiGuardInstruction2[CpiGuardInstruction2["Disable"] = 1] = "Disable";
    })(CpiGuardInstruction || (exports2.CpiGuardInstruction = CpiGuardInstruction = {}));
    exports2.cpiGuardInstructionData = (0, buffer_layout_1.struct)([(0, buffer_layout_1.u8)("instruction"), (0, buffer_layout_1.u8)("cpiGuardInstruction")]);
    function createEnableCpiGuardInstruction(account, authority, multiSigners = [], programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
      return createCpiGuardInstruction(CpiGuardInstruction.Enable, account, authority, multiSigners, programId);
    }
    exports2.createEnableCpiGuardInstruction = createEnableCpiGuardInstruction;
    function createDisableCpiGuardInstruction(account, authority, multiSigners = [], programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
      return createCpiGuardInstruction(CpiGuardInstruction.Disable, account, authority, multiSigners, programId);
    }
    exports2.createDisableCpiGuardInstruction = createDisableCpiGuardInstruction;
    function createCpiGuardInstruction(cpiGuardInstruction, account, authority, multiSigners, programId) {
      if (!(0, constants_js_1.programSupportsExtensions)(programId)) {
        throw new errors_js_1.TokenUnsupportedInstructionError();
      }
      const keys = (0, internal_js_1.addSigners)([{ pubkey: account, isSigner: false, isWritable: true }], authority, multiSigners);
      const data = Buffer.alloc(exports2.cpiGuardInstructionData.span);
      exports2.cpiGuardInstructionData.encode({
        instruction: types_js_1.TokenInstruction.CpiGuardExtension,
        cpiGuardInstruction
      }, data);
      return new web3_js_1.TransactionInstruction({ keys, programId, data });
    }
  }
});

// node_modules/@solana/spl-token/lib/cjs/extensions/cpiGuard/actions.js
var require_actions12 = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/extensions/cpiGuard/actions.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.disableCpiGuard = exports2.enableCpiGuard = void 0;
    var web3_js_1 = require("@solana/web3.js");
    var internal_js_1 = require_internal4();
    var constants_js_1 = require_constants2();
    var instructions_js_1 = require_instructions13();
    function enableCpiGuard(connection, payer, account, owner, multiSigners = [], confirmOptions, programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
      return __awaiter(this, void 0, void 0, function* () {
        const [ownerPublicKey, signers] = (0, internal_js_1.getSigners)(owner, multiSigners);
        const transaction = new web3_js_1.Transaction().add((0, instructions_js_1.createEnableCpiGuardInstruction)(account, ownerPublicKey, signers, programId));
        return yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer, ...signers], confirmOptions);
      });
    }
    exports2.enableCpiGuard = enableCpiGuard;
    function disableCpiGuard(connection, payer, account, owner, multiSigners = [], confirmOptions, programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
      return __awaiter(this, void 0, void 0, function* () {
        const [ownerPublicKey, signers] = (0, internal_js_1.getSigners)(owner, multiSigners);
        const transaction = new web3_js_1.Transaction().add((0, instructions_js_1.createDisableCpiGuardInstruction)(account, ownerPublicKey, signers, programId));
        return yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer, ...signers], confirmOptions);
      });
    }
    exports2.disableCpiGuard = disableCpiGuard;
  }
});

// node_modules/@solana/spl-token/lib/cjs/extensions/cpiGuard/state.js
var require_state18 = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/extensions/cpiGuard/state.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getCpiGuard = exports2.CPI_GUARD_SIZE = exports2.CpiGuardLayout = void 0;
    var buffer_layout_1 = require_Layout();
    var buffer_layout_utils_1 = require_cjs();
    var extensionType_js_1 = require_extensionType2();
    exports2.CpiGuardLayout = (0, buffer_layout_1.struct)([(0, buffer_layout_utils_1.bool)("lockCpi")]);
    exports2.CPI_GUARD_SIZE = exports2.CpiGuardLayout.span;
    function getCpiGuard(account) {
      const extensionData = (0, extensionType_js_1.getExtensionData)(extensionType_js_1.ExtensionType.CpiGuard, account.tlvData);
      if (extensionData !== null) {
        return exports2.CpiGuardLayout.decode(extensionData);
      } else {
        return null;
      }
    }
    exports2.getCpiGuard = getCpiGuard;
  }
});

// node_modules/@solana/spl-token/lib/cjs/extensions/cpiGuard/index.js
var require_cpiGuard2 = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/extensions/cpiGuard/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_actions12(), exports2);
    __exportStar(require_instructions13(), exports2);
    __exportStar(require_state18(), exports2);
  }
});

// node_modules/@solana/spl-token/lib/cjs/extensions/defaultAccountState/instructions.js
var require_instructions14 = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/extensions/defaultAccountState/instructions.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createUpdateDefaultAccountStateInstruction = exports2.createInitializeDefaultAccountStateInstruction = exports2.defaultAccountStateInstructionData = exports2.DefaultAccountStateInstruction = void 0;
    var buffer_layout_1 = require_Layout();
    var web3_js_1 = require("@solana/web3.js");
    var constants_js_1 = require_constants2();
    var errors_js_1 = require_errors4();
    var internal_js_1 = require_internal3();
    var types_js_1 = require_types2();
    var DefaultAccountStateInstruction;
    (function(DefaultAccountStateInstruction2) {
      DefaultAccountStateInstruction2[DefaultAccountStateInstruction2["Initialize"] = 0] = "Initialize";
      DefaultAccountStateInstruction2[DefaultAccountStateInstruction2["Update"] = 1] = "Update";
    })(DefaultAccountStateInstruction || (exports2.DefaultAccountStateInstruction = DefaultAccountStateInstruction = {}));
    exports2.defaultAccountStateInstructionData = (0, buffer_layout_1.struct)([
      (0, buffer_layout_1.u8)("instruction"),
      (0, buffer_layout_1.u8)("defaultAccountStateInstruction"),
      (0, buffer_layout_1.u8)("accountState")
    ]);
    function createInitializeDefaultAccountStateInstruction(mint, accountState, programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
      if (!(0, constants_js_1.programSupportsExtensions)(programId)) {
        throw new errors_js_1.TokenUnsupportedInstructionError();
      }
      const keys = [{ pubkey: mint, isSigner: false, isWritable: true }];
      const data = Buffer.alloc(exports2.defaultAccountStateInstructionData.span);
      exports2.defaultAccountStateInstructionData.encode({
        instruction: types_js_1.TokenInstruction.DefaultAccountStateExtension,
        defaultAccountStateInstruction: DefaultAccountStateInstruction.Initialize,
        accountState
      }, data);
      return new web3_js_1.TransactionInstruction({ keys, programId, data });
    }
    exports2.createInitializeDefaultAccountStateInstruction = createInitializeDefaultAccountStateInstruction;
    function createUpdateDefaultAccountStateInstruction(mint, accountState, freezeAuthority, multiSigners = [], programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
      if (!(0, constants_js_1.programSupportsExtensions)(programId)) {
        throw new errors_js_1.TokenUnsupportedInstructionError();
      }
      const keys = (0, internal_js_1.addSigners)([{ pubkey: mint, isSigner: false, isWritable: true }], freezeAuthority, multiSigners);
      const data = Buffer.alloc(exports2.defaultAccountStateInstructionData.span);
      exports2.defaultAccountStateInstructionData.encode({
        instruction: types_js_1.TokenInstruction.DefaultAccountStateExtension,
        defaultAccountStateInstruction: DefaultAccountStateInstruction.Update,
        accountState
      }, data);
      return new web3_js_1.TransactionInstruction({ keys, programId, data });
    }
    exports2.createUpdateDefaultAccountStateInstruction = createUpdateDefaultAccountStateInstruction;
  }
});

// node_modules/@solana/spl-token/lib/cjs/extensions/defaultAccountState/actions.js
var require_actions13 = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/extensions/defaultAccountState/actions.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.updateDefaultAccountState = exports2.initializeDefaultAccountState = void 0;
    var web3_js_1 = require("@solana/web3.js");
    var internal_js_1 = require_internal4();
    var constants_js_1 = require_constants2();
    var instructions_js_1 = require_instructions14();
    function initializeDefaultAccountState(connection, payer, mint, state, confirmOptions, programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
      return __awaiter(this, void 0, void 0, function* () {
        const transaction = new web3_js_1.Transaction().add((0, instructions_js_1.createInitializeDefaultAccountStateInstruction)(mint, state, programId));
        return yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer], confirmOptions);
      });
    }
    exports2.initializeDefaultAccountState = initializeDefaultAccountState;
    function updateDefaultAccountState(connection, payer, mint, state, freezeAuthority, multiSigners = [], confirmOptions, programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
      return __awaiter(this, void 0, void 0, function* () {
        const [freezeAuthorityPublicKey, signers] = (0, internal_js_1.getSigners)(freezeAuthority, multiSigners);
        const transaction = new web3_js_1.Transaction().add((0, instructions_js_1.createUpdateDefaultAccountStateInstruction)(mint, state, freezeAuthorityPublicKey, signers, programId));
        return yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer, ...signers], confirmOptions);
      });
    }
    exports2.updateDefaultAccountState = updateDefaultAccountState;
  }
});

// node_modules/@solana/spl-token/lib/cjs/extensions/defaultAccountState/state.js
var require_state19 = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/extensions/defaultAccountState/state.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getDefaultAccountState = exports2.DEFAULT_ACCOUNT_STATE_SIZE = exports2.DefaultAccountStateLayout = void 0;
    var buffer_layout_1 = require_Layout();
    var extensionType_js_1 = require_extensionType2();
    exports2.DefaultAccountStateLayout = (0, buffer_layout_1.struct)([(0, buffer_layout_1.u8)("state")]);
    exports2.DEFAULT_ACCOUNT_STATE_SIZE = exports2.DefaultAccountStateLayout.span;
    function getDefaultAccountState(mint) {
      const extensionData = (0, extensionType_js_1.getExtensionData)(extensionType_js_1.ExtensionType.DefaultAccountState, mint.tlvData);
      if (extensionData !== null) {
        return exports2.DefaultAccountStateLayout.decode(extensionData);
      } else {
        return null;
      }
    }
    exports2.getDefaultAccountState = getDefaultAccountState;
  }
});

// node_modules/@solana/spl-token/lib/cjs/extensions/defaultAccountState/index.js
var require_defaultAccountState2 = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/extensions/defaultAccountState/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_actions13(), exports2);
    __exportStar(require_instructions14(), exports2);
    __exportStar(require_state19(), exports2);
  }
});

// node_modules/@solana/spl-token/lib/cjs/extensions/immutableOwner.js
var require_immutableOwner2 = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/extensions/immutableOwner.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getImmutableOwner = exports2.IMMUTABLE_OWNER_SIZE = exports2.ImmutableOwnerLayout = void 0;
    var buffer_layout_1 = require_Layout();
    var extensionType_js_1 = require_extensionType2();
    exports2.ImmutableOwnerLayout = (0, buffer_layout_1.struct)([]);
    exports2.IMMUTABLE_OWNER_SIZE = exports2.ImmutableOwnerLayout.span;
    function getImmutableOwner(account) {
      const extensionData = (0, extensionType_js_1.getExtensionData)(extensionType_js_1.ExtensionType.ImmutableOwner, account.tlvData);
      if (extensionData !== null) {
        return exports2.ImmutableOwnerLayout.decode(extensionData);
      } else {
        return null;
      }
    }
    exports2.getImmutableOwner = getImmutableOwner;
  }
});

// node_modules/@solana/spl-token/lib/cjs/extensions/interestBearingMint/state.js
var require_state20 = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/extensions/interestBearingMint/state.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getInterestBearingMintConfigState = exports2.INTEREST_BEARING_MINT_CONFIG_STATE_SIZE = exports2.InterestBearingMintConfigStateLayout = void 0;
    var buffer_layout_1 = require_Layout();
    var buffer_layout_utils_1 = require_cjs();
    var extensionType_js_1 = require_extensionType2();
    exports2.InterestBearingMintConfigStateLayout = (0, buffer_layout_1.struct)([
      (0, buffer_layout_utils_1.publicKey)("rateAuthority"),
      (0, buffer_layout_1.ns64)("initializationTimestamp"),
      (0, buffer_layout_1.s16)("preUpdateAverageRate"),
      (0, buffer_layout_1.ns64)("lastUpdateTimestamp"),
      (0, buffer_layout_1.s16)("currentRate")
    ]);
    exports2.INTEREST_BEARING_MINT_CONFIG_STATE_SIZE = exports2.InterestBearingMintConfigStateLayout.span;
    function getInterestBearingMintConfigState(mint) {
      const extensionData = (0, extensionType_js_1.getExtensionData)(extensionType_js_1.ExtensionType.InterestBearingConfig, mint.tlvData);
      if (extensionData !== null) {
        return exports2.InterestBearingMintConfigStateLayout.decode(extensionData);
      }
      return null;
    }
    exports2.getInterestBearingMintConfigState = getInterestBearingMintConfigState;
  }
});

// node_modules/@solana/spl-token/lib/cjs/extensions/memoTransfer/instructions.js
var require_instructions15 = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/extensions/memoTransfer/instructions.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createDisableRequiredMemoTransfersInstruction = exports2.createEnableRequiredMemoTransfersInstruction = exports2.memoTransferInstructionData = exports2.MemoTransferInstruction = void 0;
    var buffer_layout_1 = require_Layout();
    var web3_js_1 = require("@solana/web3.js");
    var constants_js_1 = require_constants2();
    var errors_js_1 = require_errors4();
    var internal_js_1 = require_internal3();
    var types_js_1 = require_types2();
    var MemoTransferInstruction;
    (function(MemoTransferInstruction2) {
      MemoTransferInstruction2[MemoTransferInstruction2["Enable"] = 0] = "Enable";
      MemoTransferInstruction2[MemoTransferInstruction2["Disable"] = 1] = "Disable";
    })(MemoTransferInstruction || (exports2.MemoTransferInstruction = MemoTransferInstruction = {}));
    exports2.memoTransferInstructionData = (0, buffer_layout_1.struct)([
      (0, buffer_layout_1.u8)("instruction"),
      (0, buffer_layout_1.u8)("memoTransferInstruction")
    ]);
    function createEnableRequiredMemoTransfersInstruction(account, authority, multiSigners = [], programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
      return createMemoTransferInstruction(MemoTransferInstruction.Enable, account, authority, multiSigners, programId);
    }
    exports2.createEnableRequiredMemoTransfersInstruction = createEnableRequiredMemoTransfersInstruction;
    function createDisableRequiredMemoTransfersInstruction(account, authority, multiSigners = [], programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
      return createMemoTransferInstruction(MemoTransferInstruction.Disable, account, authority, multiSigners, programId);
    }
    exports2.createDisableRequiredMemoTransfersInstruction = createDisableRequiredMemoTransfersInstruction;
    function createMemoTransferInstruction(memoTransferInstruction, account, authority, multiSigners, programId) {
      if (!(0, constants_js_1.programSupportsExtensions)(programId)) {
        throw new errors_js_1.TokenUnsupportedInstructionError();
      }
      const keys = (0, internal_js_1.addSigners)([{ pubkey: account, isSigner: false, isWritable: true }], authority, multiSigners);
      const data = Buffer.alloc(exports2.memoTransferInstructionData.span);
      exports2.memoTransferInstructionData.encode({
        instruction: types_js_1.TokenInstruction.MemoTransferExtension,
        memoTransferInstruction
      }, data);
      return new web3_js_1.TransactionInstruction({ keys, programId, data });
    }
  }
});

// node_modules/@solana/spl-token/lib/cjs/extensions/memoTransfer/actions.js
var require_actions14 = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/extensions/memoTransfer/actions.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.disableRequiredMemoTransfers = exports2.enableRequiredMemoTransfers = void 0;
    var web3_js_1 = require("@solana/web3.js");
    var internal_js_1 = require_internal4();
    var constants_js_1 = require_constants2();
    var instructions_js_1 = require_instructions15();
    function enableRequiredMemoTransfers(connection, payer, account, owner, multiSigners = [], confirmOptions, programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
      return __awaiter(this, void 0, void 0, function* () {
        const [ownerPublicKey, signers] = (0, internal_js_1.getSigners)(owner, multiSigners);
        const transaction = new web3_js_1.Transaction().add((0, instructions_js_1.createEnableRequiredMemoTransfersInstruction)(account, ownerPublicKey, signers, programId));
        return yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer, ...signers], confirmOptions);
      });
    }
    exports2.enableRequiredMemoTransfers = enableRequiredMemoTransfers;
    function disableRequiredMemoTransfers(connection, payer, account, owner, multiSigners = [], confirmOptions, programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
      return __awaiter(this, void 0, void 0, function* () {
        const [ownerPublicKey, signers] = (0, internal_js_1.getSigners)(owner, multiSigners);
        const transaction = new web3_js_1.Transaction().add((0, instructions_js_1.createDisableRequiredMemoTransfersInstruction)(account, ownerPublicKey, signers, programId));
        return yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer, ...signers], confirmOptions);
      });
    }
    exports2.disableRequiredMemoTransfers = disableRequiredMemoTransfers;
  }
});

// node_modules/@solana/spl-token/lib/cjs/extensions/memoTransfer/state.js
var require_state21 = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/extensions/memoTransfer/state.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getMemoTransfer = exports2.MEMO_TRANSFER_SIZE = exports2.MemoTransferLayout = void 0;
    var buffer_layout_1 = require_Layout();
    var buffer_layout_utils_1 = require_cjs();
    var extensionType_js_1 = require_extensionType2();
    exports2.MemoTransferLayout = (0, buffer_layout_1.struct)([(0, buffer_layout_utils_1.bool)("requireIncomingTransferMemos")]);
    exports2.MEMO_TRANSFER_SIZE = exports2.MemoTransferLayout.span;
    function getMemoTransfer(account) {
      const extensionData = (0, extensionType_js_1.getExtensionData)(extensionType_js_1.ExtensionType.MemoTransfer, account.tlvData);
      if (extensionData !== null) {
        return exports2.MemoTransferLayout.decode(extensionData);
      } else {
        return null;
      }
    }
    exports2.getMemoTransfer = getMemoTransfer;
  }
});

// node_modules/@solana/spl-token/lib/cjs/extensions/memoTransfer/index.js
var require_memoTransfer2 = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/extensions/memoTransfer/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_actions14(), exports2);
    __exportStar(require_instructions15(), exports2);
    __exportStar(require_state21(), exports2);
  }
});

// node_modules/@solana/spl-token/lib/cjs/extensions/metadataPointer/state.js
var require_state22 = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/extensions/metadataPointer/state.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getMetadataPointerState = exports2.METADATA_POINTER_SIZE = exports2.MetadataPointerLayout = void 0;
    var buffer_layout_1 = require_Layout();
    var buffer_layout_utils_1 = require_cjs();
    var web3_js_1 = require("@solana/web3.js");
    var extensionType_js_1 = require_extensionType2();
    exports2.MetadataPointerLayout = (0, buffer_layout_1.struct)([
      (0, buffer_layout_utils_1.publicKey)("authority"),
      (0, buffer_layout_utils_1.publicKey)("metadataAddress")
    ]);
    exports2.METADATA_POINTER_SIZE = exports2.MetadataPointerLayout.span;
    function getMetadataPointerState(mint) {
      const extensionData = (0, extensionType_js_1.getExtensionData)(extensionType_js_1.ExtensionType.MetadataPointer, mint.tlvData);
      if (extensionData !== null) {
        const { authority, metadataAddress } = exports2.MetadataPointerLayout.decode(extensionData);
        return {
          authority: authority.equals(web3_js_1.PublicKey.default) ? null : authority,
          metadataAddress: metadataAddress.equals(web3_js_1.PublicKey.default) ? null : metadataAddress
        };
      } else {
        return null;
      }
    }
    exports2.getMetadataPointerState = getMetadataPointerState;
  }
});

// node_modules/@solana/spl-token/lib/cjs/extensions/mintCloseAuthority.js
var require_mintCloseAuthority2 = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/extensions/mintCloseAuthority.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getMintCloseAuthority = exports2.MINT_CLOSE_AUTHORITY_SIZE = exports2.MintCloseAuthorityLayout = void 0;
    var buffer_layout_1 = require_Layout();
    var buffer_layout_utils_1 = require_cjs();
    var extensionType_js_1 = require_extensionType2();
    exports2.MintCloseAuthorityLayout = (0, buffer_layout_1.struct)([(0, buffer_layout_utils_1.publicKey)("closeAuthority")]);
    exports2.MINT_CLOSE_AUTHORITY_SIZE = exports2.MintCloseAuthorityLayout.span;
    function getMintCloseAuthority(mint) {
      const extensionData = (0, extensionType_js_1.getExtensionData)(extensionType_js_1.ExtensionType.MintCloseAuthority, mint.tlvData);
      if (extensionData !== null) {
        return exports2.MintCloseAuthorityLayout.decode(extensionData);
      } else {
        return null;
      }
    }
    exports2.getMintCloseAuthority = getMintCloseAuthority;
  }
});

// node_modules/@solana/spl-token/lib/cjs/extensions/nonTransferable.js
var require_nonTransferable2 = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/extensions/nonTransferable.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getNonTransferableAccount = exports2.getNonTransferable = exports2.NON_TRANSFERABLE_ACCOUNT_SIZE = exports2.NON_TRANSFERABLE_SIZE = exports2.NonTransferableLayout = void 0;
    var buffer_layout_1 = require_Layout();
    var extensionType_js_1 = require_extensionType2();
    exports2.NonTransferableLayout = (0, buffer_layout_1.struct)([]);
    exports2.NON_TRANSFERABLE_SIZE = exports2.NonTransferableLayout.span;
    exports2.NON_TRANSFERABLE_ACCOUNT_SIZE = exports2.NonTransferableLayout.span;
    function getNonTransferable(mint) {
      const extensionData = (0, extensionType_js_1.getExtensionData)(extensionType_js_1.ExtensionType.NonTransferable, mint.tlvData);
      if (extensionData !== null) {
        return exports2.NonTransferableLayout.decode(extensionData);
      } else {
        return null;
      }
    }
    exports2.getNonTransferable = getNonTransferable;
    function getNonTransferableAccount(account) {
      const extensionData = (0, extensionType_js_1.getExtensionData)(extensionType_js_1.ExtensionType.NonTransferableAccount, account.tlvData);
      if (extensionData !== null) {
        return exports2.NonTransferableLayout.decode(extensionData);
      } else {
        return null;
      }
    }
    exports2.getNonTransferableAccount = getNonTransferableAccount;
  }
});

// node_modules/@solana/spl-token/lib/cjs/extensions/permanentDelegate.js
var require_permanentDelegate2 = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/extensions/permanentDelegate.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getPermanentDelegate = exports2.PERMANENT_DELEGATE_SIZE = exports2.PermanentDelegateLayout = void 0;
    var buffer_layout_1 = require_Layout();
    var buffer_layout_utils_1 = require_cjs();
    var extensionType_js_1 = require_extensionType2();
    exports2.PermanentDelegateLayout = (0, buffer_layout_1.struct)([(0, buffer_layout_utils_1.publicKey)("delegate")]);
    exports2.PERMANENT_DELEGATE_SIZE = exports2.PermanentDelegateLayout.span;
    function getPermanentDelegate(mint) {
      const extensionData = (0, extensionType_js_1.getExtensionData)(extensionType_js_1.ExtensionType.PermanentDelegate, mint.tlvData);
      if (extensionData !== null) {
        return exports2.PermanentDelegateLayout.decode(extensionData);
      } else {
        return null;
      }
    }
    exports2.getPermanentDelegate = getPermanentDelegate;
  }
});

// node_modules/@solana/spl-token/lib/cjs/extensions/transferFee/instructions.js
var require_instructions16 = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/extensions/transferFee/instructions.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.decodeHarvestWithheldTokensToMintInstructionUnchecked = exports2.decodeHarvestWithheldTokensToMintInstruction = exports2.createHarvestWithheldTokensToMintInstruction = exports2.harvestWithheldTokensToMintInstructionData = exports2.decodeWithdrawWithheldTokensFromAccountsInstructionUnchecked = exports2.decodeWithdrawWithheldTokensFromAccountsInstruction = exports2.createWithdrawWithheldTokensFromAccountsInstruction = exports2.withdrawWithheldTokensFromAccountsInstructionData = exports2.decodeWithdrawWithheldTokensFromMintInstructionUnchecked = exports2.decodeWithdrawWithheldTokensFromMintInstruction = exports2.createWithdrawWithheldTokensFromMintInstruction = exports2.withdrawWithheldTokensFromMintInstructionData = exports2.decodeTransferCheckedWithFeeInstructionUnchecked = exports2.decodeTransferCheckedWithFeeInstruction = exports2.createTransferCheckedWithFeeInstruction = exports2.transferCheckedWithFeeInstructionData = exports2.decodeInitializeTransferFeeConfigInstructionUnchecked = exports2.decodeInitializeTransferFeeConfigInstruction = exports2.createInitializeTransferFeeConfigInstruction = exports2.initializeTransferFeeConfigInstructionData = exports2.TransferFeeInstruction = void 0;
    var buffer_layout_1 = require_Layout();
    var buffer_layout_utils_1 = require_cjs();
    var web3_js_1 = require("@solana/web3.js");
    var constants_js_1 = require_constants2();
    var errors_js_1 = require_errors4();
    var internal_js_1 = require_internal3();
    var types_js_1 = require_types2();
    var TransferFeeInstruction;
    (function(TransferFeeInstruction2) {
      TransferFeeInstruction2[TransferFeeInstruction2["InitializeTransferFeeConfig"] = 0] = "InitializeTransferFeeConfig";
      TransferFeeInstruction2[TransferFeeInstruction2["TransferCheckedWithFee"] = 1] = "TransferCheckedWithFee";
      TransferFeeInstruction2[TransferFeeInstruction2["WithdrawWithheldTokensFromMint"] = 2] = "WithdrawWithheldTokensFromMint";
      TransferFeeInstruction2[TransferFeeInstruction2["WithdrawWithheldTokensFromAccounts"] = 3] = "WithdrawWithheldTokensFromAccounts";
      TransferFeeInstruction2[TransferFeeInstruction2["HarvestWithheldTokensToMint"] = 4] = "HarvestWithheldTokensToMint";
      TransferFeeInstruction2[TransferFeeInstruction2["SetTransferFee"] = 5] = "SetTransferFee";
    })(TransferFeeInstruction || (exports2.TransferFeeInstruction = TransferFeeInstruction = {}));
    exports2.initializeTransferFeeConfigInstructionData = (0, buffer_layout_1.struct)([
      (0, buffer_layout_1.u8)("instruction"),
      (0, buffer_layout_1.u8)("transferFeeInstruction"),
      (0, buffer_layout_1.u8)("transferFeeConfigAuthorityOption"),
      (0, buffer_layout_utils_1.publicKey)("transferFeeConfigAuthority"),
      (0, buffer_layout_1.u8)("withdrawWithheldAuthorityOption"),
      (0, buffer_layout_utils_1.publicKey)("withdrawWithheldAuthority"),
      (0, buffer_layout_1.u16)("transferFeeBasisPoints"),
      (0, buffer_layout_utils_1.u64)("maximumFee")
    ]);
    function createInitializeTransferFeeConfigInstruction(mint, transferFeeConfigAuthority, withdrawWithheldAuthority, transferFeeBasisPoints, maximumFee, programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
      if (!(0, constants_js_1.programSupportsExtensions)(programId)) {
        throw new errors_js_1.TokenUnsupportedInstructionError();
      }
      const keys = [{ pubkey: mint, isSigner: false, isWritable: true }];
      const data = Buffer.alloc(exports2.initializeTransferFeeConfigInstructionData.span);
      exports2.initializeTransferFeeConfigInstructionData.encode({
        instruction: types_js_1.TokenInstruction.TransferFeeExtension,
        transferFeeInstruction: TransferFeeInstruction.InitializeTransferFeeConfig,
        transferFeeConfigAuthorityOption: transferFeeConfigAuthority ? 1 : 0,
        transferFeeConfigAuthority: transferFeeConfigAuthority || new web3_js_1.PublicKey(0),
        withdrawWithheldAuthorityOption: withdrawWithheldAuthority ? 1 : 0,
        withdrawWithheldAuthority: withdrawWithheldAuthority || new web3_js_1.PublicKey(0),
        transferFeeBasisPoints,
        maximumFee
      }, data);
      return new web3_js_1.TransactionInstruction({ keys, programId, data });
    }
    exports2.createInitializeTransferFeeConfigInstruction = createInitializeTransferFeeConfigInstruction;
    function decodeInitializeTransferFeeConfigInstruction(instruction, programId) {
      if (!instruction.programId.equals(programId))
        throw new errors_js_1.TokenInvalidInstructionProgramError();
      if (instruction.data.length !== exports2.initializeTransferFeeConfigInstructionData.span)
        throw new errors_js_1.TokenInvalidInstructionDataError();
      const { keys: { mint }, data } = decodeInitializeTransferFeeConfigInstructionUnchecked(instruction);
      if (data.instruction !== types_js_1.TokenInstruction.TransferFeeExtension || data.transferFeeInstruction !== TransferFeeInstruction.InitializeTransferFeeConfig)
        throw new errors_js_1.TokenInvalidInstructionTypeError();
      if (!mint)
        throw new errors_js_1.TokenInvalidInstructionKeysError();
      return {
        programId,
        keys: {
          mint
        },
        data
      };
    }
    exports2.decodeInitializeTransferFeeConfigInstruction = decodeInitializeTransferFeeConfigInstruction;
    function decodeInitializeTransferFeeConfigInstructionUnchecked({ programId, keys: [mint], data }) {
      const { instruction, transferFeeInstruction, transferFeeConfigAuthorityOption, transferFeeConfigAuthority, withdrawWithheldAuthorityOption, withdrawWithheldAuthority, transferFeeBasisPoints, maximumFee } = exports2.initializeTransferFeeConfigInstructionData.decode(data);
      return {
        programId,
        keys: {
          mint
        },
        data: {
          instruction,
          transferFeeInstruction,
          transferFeeConfigAuthority: transferFeeConfigAuthorityOption ? transferFeeConfigAuthority : null,
          withdrawWithheldAuthority: withdrawWithheldAuthorityOption ? withdrawWithheldAuthority : null,
          transferFeeBasisPoints,
          maximumFee
        }
      };
    }
    exports2.decodeInitializeTransferFeeConfigInstructionUnchecked = decodeInitializeTransferFeeConfigInstructionUnchecked;
    exports2.transferCheckedWithFeeInstructionData = (0, buffer_layout_1.struct)([
      (0, buffer_layout_1.u8)("instruction"),
      (0, buffer_layout_1.u8)("transferFeeInstruction"),
      (0, buffer_layout_utils_1.u64)("amount"),
      (0, buffer_layout_1.u8)("decimals"),
      (0, buffer_layout_utils_1.u64)("fee")
    ]);
    function createTransferCheckedWithFeeInstruction(source, mint, destination, authority, amount, decimals, fee, multiSigners = [], programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
      if (!(0, constants_js_1.programSupportsExtensions)(programId)) {
        throw new errors_js_1.TokenUnsupportedInstructionError();
      }
      const data = Buffer.alloc(exports2.transferCheckedWithFeeInstructionData.span);
      exports2.transferCheckedWithFeeInstructionData.encode({
        instruction: types_js_1.TokenInstruction.TransferFeeExtension,
        transferFeeInstruction: TransferFeeInstruction.TransferCheckedWithFee,
        amount,
        decimals,
        fee
      }, data);
      const keys = (0, internal_js_1.addSigners)([
        { pubkey: source, isSigner: false, isWritable: true },
        { pubkey: mint, isSigner: false, isWritable: false },
        { pubkey: destination, isSigner: false, isWritable: true }
      ], authority, multiSigners);
      return new web3_js_1.TransactionInstruction({ keys, programId, data });
    }
    exports2.createTransferCheckedWithFeeInstruction = createTransferCheckedWithFeeInstruction;
    function decodeTransferCheckedWithFeeInstruction(instruction, programId) {
      if (!instruction.programId.equals(programId))
        throw new errors_js_1.TokenInvalidInstructionProgramError();
      if (instruction.data.length !== exports2.transferCheckedWithFeeInstructionData.span)
        throw new errors_js_1.TokenInvalidInstructionDataError();
      const { keys: { source, mint, destination, authority, signers }, data } = decodeTransferCheckedWithFeeInstructionUnchecked(instruction);
      if (data.instruction !== types_js_1.TokenInstruction.TransferFeeExtension || data.transferFeeInstruction !== TransferFeeInstruction.TransferCheckedWithFee)
        throw new errors_js_1.TokenInvalidInstructionTypeError();
      if (!mint)
        throw new errors_js_1.TokenInvalidInstructionKeysError();
      return {
        programId,
        keys: {
          source,
          mint,
          destination,
          authority,
          signers: signers ? signers : null
        },
        data
      };
    }
    exports2.decodeTransferCheckedWithFeeInstruction = decodeTransferCheckedWithFeeInstruction;
    function decodeTransferCheckedWithFeeInstructionUnchecked({ programId, keys: [source, mint, destination, authority, ...signers], data }) {
      const { instruction, transferFeeInstruction, amount, decimals, fee } = exports2.transferCheckedWithFeeInstructionData.decode(data);
      return {
        programId,
        keys: {
          source,
          mint,
          destination,
          authority,
          signers
        },
        data: {
          instruction,
          transferFeeInstruction,
          amount,
          decimals,
          fee
        }
      };
    }
    exports2.decodeTransferCheckedWithFeeInstructionUnchecked = decodeTransferCheckedWithFeeInstructionUnchecked;
    exports2.withdrawWithheldTokensFromMintInstructionData = (0, buffer_layout_1.struct)([
      (0, buffer_layout_1.u8)("instruction"),
      (0, buffer_layout_1.u8)("transferFeeInstruction")
    ]);
    function createWithdrawWithheldTokensFromMintInstruction(mint, destination, authority, signers = [], programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
      if (!(0, constants_js_1.programSupportsExtensions)(programId)) {
        throw new errors_js_1.TokenUnsupportedInstructionError();
      }
      const data = Buffer.alloc(exports2.withdrawWithheldTokensFromMintInstructionData.span);
      exports2.withdrawWithheldTokensFromMintInstructionData.encode({
        instruction: types_js_1.TokenInstruction.TransferFeeExtension,
        transferFeeInstruction: TransferFeeInstruction.WithdrawWithheldTokensFromMint
      }, data);
      const keys = (0, internal_js_1.addSigners)([
        { pubkey: mint, isSigner: false, isWritable: true },
        { pubkey: destination, isSigner: false, isWritable: true }
      ], authority, signers);
      return new web3_js_1.TransactionInstruction({ keys, programId, data });
    }
    exports2.createWithdrawWithheldTokensFromMintInstruction = createWithdrawWithheldTokensFromMintInstruction;
    function decodeWithdrawWithheldTokensFromMintInstruction(instruction, programId) {
      if (!instruction.programId.equals(programId))
        throw new errors_js_1.TokenInvalidInstructionProgramError();
      if (instruction.data.length !== exports2.withdrawWithheldTokensFromMintInstructionData.span)
        throw new errors_js_1.TokenInvalidInstructionDataError();
      const { keys: { mint, destination, authority, signers }, data } = decodeWithdrawWithheldTokensFromMintInstructionUnchecked(instruction);
      if (data.instruction !== types_js_1.TokenInstruction.TransferFeeExtension || data.transferFeeInstruction !== TransferFeeInstruction.WithdrawWithheldTokensFromMint)
        throw new errors_js_1.TokenInvalidInstructionTypeError();
      if (!mint)
        throw new errors_js_1.TokenInvalidInstructionKeysError();
      return {
        programId,
        keys: {
          mint,
          destination,
          authority,
          signers: signers ? signers : null
        },
        data
      };
    }
    exports2.decodeWithdrawWithheldTokensFromMintInstruction = decodeWithdrawWithheldTokensFromMintInstruction;
    function decodeWithdrawWithheldTokensFromMintInstructionUnchecked({ programId, keys: [mint, destination, authority, ...signers], data }) {
      const { instruction, transferFeeInstruction } = exports2.withdrawWithheldTokensFromMintInstructionData.decode(data);
      return {
        programId,
        keys: {
          mint,
          destination,
          authority,
          signers
        },
        data: {
          instruction,
          transferFeeInstruction
        }
      };
    }
    exports2.decodeWithdrawWithheldTokensFromMintInstructionUnchecked = decodeWithdrawWithheldTokensFromMintInstructionUnchecked;
    exports2.withdrawWithheldTokensFromAccountsInstructionData = (0, buffer_layout_1.struct)([
      (0, buffer_layout_1.u8)("instruction"),
      (0, buffer_layout_1.u8)("transferFeeInstruction"),
      (0, buffer_layout_1.u8)("numTokenAccounts")
    ]);
    function createWithdrawWithheldTokensFromAccountsInstruction(mint, destination, authority, signers, sources, programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
      if (!(0, constants_js_1.programSupportsExtensions)(programId)) {
        throw new errors_js_1.TokenUnsupportedInstructionError();
      }
      const data = Buffer.alloc(exports2.withdrawWithheldTokensFromAccountsInstructionData.span);
      exports2.withdrawWithheldTokensFromAccountsInstructionData.encode({
        instruction: types_js_1.TokenInstruction.TransferFeeExtension,
        transferFeeInstruction: TransferFeeInstruction.WithdrawWithheldTokensFromAccounts,
        numTokenAccounts: sources.length
      }, data);
      const keys = (0, internal_js_1.addSigners)([
        { pubkey: mint, isSigner: false, isWritable: true },
        { pubkey: destination, isSigner: false, isWritable: true }
      ], authority, signers);
      for (const source of sources) {
        keys.push({ pubkey: source, isSigner: false, isWritable: true });
      }
      return new web3_js_1.TransactionInstruction({ keys, programId, data });
    }
    exports2.createWithdrawWithheldTokensFromAccountsInstruction = createWithdrawWithheldTokensFromAccountsInstruction;
    function decodeWithdrawWithheldTokensFromAccountsInstruction(instruction, programId) {
      if (!instruction.programId.equals(programId))
        throw new errors_js_1.TokenInvalidInstructionProgramError();
      if (instruction.data.length !== exports2.withdrawWithheldTokensFromAccountsInstructionData.span)
        throw new errors_js_1.TokenInvalidInstructionDataError();
      const { keys: { mint, destination, authority, signers, sources }, data } = decodeWithdrawWithheldTokensFromAccountsInstructionUnchecked(instruction);
      if (data.instruction !== types_js_1.TokenInstruction.TransferFeeExtension || data.transferFeeInstruction !== TransferFeeInstruction.WithdrawWithheldTokensFromAccounts)
        throw new errors_js_1.TokenInvalidInstructionTypeError();
      if (!mint)
        throw new errors_js_1.TokenInvalidInstructionKeysError();
      return {
        programId,
        keys: {
          mint,
          destination,
          authority,
          signers: signers ? signers : null,
          sources: sources ? sources : null
        },
        data
      };
    }
    exports2.decodeWithdrawWithheldTokensFromAccountsInstruction = decodeWithdrawWithheldTokensFromAccountsInstruction;
    function decodeWithdrawWithheldTokensFromAccountsInstructionUnchecked({ programId, keys, data }) {
      const { instruction, transferFeeInstruction, numTokenAccounts } = exports2.withdrawWithheldTokensFromAccountsInstructionData.decode(data);
      const [mint, destination, authority, signers, sources] = [
        keys[0],
        keys[1],
        keys[2],
        keys.slice(3, 3 + numTokenAccounts),
        keys.slice(-1 * numTokenAccounts)
      ];
      return {
        programId,
        keys: {
          mint,
          destination,
          authority,
          signers,
          sources
        },
        data: {
          instruction,
          transferFeeInstruction,
          numTokenAccounts
        }
      };
    }
    exports2.decodeWithdrawWithheldTokensFromAccountsInstructionUnchecked = decodeWithdrawWithheldTokensFromAccountsInstructionUnchecked;
    exports2.harvestWithheldTokensToMintInstructionData = (0, buffer_layout_1.struct)([
      (0, buffer_layout_1.u8)("instruction"),
      (0, buffer_layout_1.u8)("transferFeeInstruction")
    ]);
    function createHarvestWithheldTokensToMintInstruction(mint, sources, programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
      if (!(0, constants_js_1.programSupportsExtensions)(programId)) {
        throw new errors_js_1.TokenUnsupportedInstructionError();
      }
      const data = Buffer.alloc(exports2.harvestWithheldTokensToMintInstructionData.span);
      exports2.harvestWithheldTokensToMintInstructionData.encode({
        instruction: types_js_1.TokenInstruction.TransferFeeExtension,
        transferFeeInstruction: TransferFeeInstruction.HarvestWithheldTokensToMint
      }, data);
      const keys = [];
      keys.push({ pubkey: mint, isSigner: false, isWritable: true });
      for (const source of sources) {
        keys.push({ pubkey: source, isSigner: false, isWritable: true });
      }
      return new web3_js_1.TransactionInstruction({ keys, programId, data });
    }
    exports2.createHarvestWithheldTokensToMintInstruction = createHarvestWithheldTokensToMintInstruction;
    function decodeHarvestWithheldTokensToMintInstruction(instruction, programId) {
      if (!instruction.programId.equals(programId))
        throw new errors_js_1.TokenInvalidInstructionProgramError();
      if (instruction.data.length !== exports2.harvestWithheldTokensToMintInstructionData.span)
        throw new errors_js_1.TokenInvalidInstructionDataError();
      const { keys: { mint, sources }, data } = decodeHarvestWithheldTokensToMintInstructionUnchecked(instruction);
      if (data.instruction !== types_js_1.TokenInstruction.TransferFeeExtension || data.transferFeeInstruction !== TransferFeeInstruction.HarvestWithheldTokensToMint)
        throw new errors_js_1.TokenInvalidInstructionTypeError();
      if (!mint)
        throw new errors_js_1.TokenInvalidInstructionKeysError();
      return {
        programId,
        keys: {
          mint,
          sources
        },
        data
      };
    }
    exports2.decodeHarvestWithheldTokensToMintInstruction = decodeHarvestWithheldTokensToMintInstruction;
    function decodeHarvestWithheldTokensToMintInstructionUnchecked({ programId, keys: [mint, ...sources], data }) {
      const { instruction, transferFeeInstruction } = exports2.harvestWithheldTokensToMintInstructionData.decode(data);
      return {
        programId,
        keys: {
          mint,
          sources
        },
        data: {
          instruction,
          transferFeeInstruction
        }
      };
    }
    exports2.decodeHarvestWithheldTokensToMintInstructionUnchecked = decodeHarvestWithheldTokensToMintInstructionUnchecked;
  }
});

// node_modules/@solana/spl-token/lib/cjs/extensions/transferFee/actions.js
var require_actions15 = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/extensions/transferFee/actions.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.harvestWithheldTokensToMint = exports2.withdrawWithheldTokensFromAccounts = exports2.withdrawWithheldTokensFromMint = exports2.transferCheckedWithFee = void 0;
    var web3_js_1 = require("@solana/web3.js");
    var internal_js_1 = require_internal4();
    var constants_js_1 = require_constants2();
    var instructions_js_1 = require_instructions16();
    function transferCheckedWithFee(connection, payer, source, mint, destination, owner, amount, decimals, fee, multiSigners = [], confirmOptions, programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
      return __awaiter(this, void 0, void 0, function* () {
        const [ownerPublicKey, signers] = (0, internal_js_1.getSigners)(owner, multiSigners);
        const transaction = new web3_js_1.Transaction().add((0, instructions_js_1.createTransferCheckedWithFeeInstruction)(source, mint, destination, ownerPublicKey, amount, decimals, fee, multiSigners, programId));
        return yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer, ...signers], confirmOptions);
      });
    }
    exports2.transferCheckedWithFee = transferCheckedWithFee;
    function withdrawWithheldTokensFromMint(connection, payer, mint, destination, authority, multiSigners = [], confirmOptions, programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
      return __awaiter(this, void 0, void 0, function* () {
        const [authorityPublicKey, signers] = (0, internal_js_1.getSigners)(authority, multiSigners);
        const transaction = new web3_js_1.Transaction().add((0, instructions_js_1.createWithdrawWithheldTokensFromMintInstruction)(mint, destination, authorityPublicKey, signers, programId));
        return yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer, ...signers], confirmOptions);
      });
    }
    exports2.withdrawWithheldTokensFromMint = withdrawWithheldTokensFromMint;
    function withdrawWithheldTokensFromAccounts(connection, payer, mint, destination, authority, multiSigners, sources, confirmOptions, programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
      return __awaiter(this, void 0, void 0, function* () {
        const [authorityPublicKey, signers] = (0, internal_js_1.getSigners)(authority, multiSigners);
        const transaction = new web3_js_1.Transaction().add((0, instructions_js_1.createWithdrawWithheldTokensFromAccountsInstruction)(mint, destination, authorityPublicKey, signers, sources, programId));
        return yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer, ...signers], confirmOptions);
      });
    }
    exports2.withdrawWithheldTokensFromAccounts = withdrawWithheldTokensFromAccounts;
    function harvestWithheldTokensToMint(connection, payer, mint, sources, confirmOptions, programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
      return __awaiter(this, void 0, void 0, function* () {
        const transaction = new web3_js_1.Transaction().add((0, instructions_js_1.createHarvestWithheldTokensToMintInstruction)(mint, sources, programId));
        return yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer], confirmOptions);
      });
    }
    exports2.harvestWithheldTokensToMint = harvestWithheldTokensToMint;
  }
});

// node_modules/@solana/spl-token/lib/cjs/extensions/transferFee/state.js
var require_state23 = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/extensions/transferFee/state.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getTransferFeeAmount = exports2.getTransferFeeConfig = exports2.TRANSFER_FEE_AMOUNT_SIZE = exports2.TransferFeeAmountLayout = exports2.calculateEpochFee = exports2.getEpochFee = exports2.TRANSFER_FEE_CONFIG_SIZE = exports2.TransferFeeConfigLayout = exports2.calculateFee = exports2.transferFeeLayout = exports2.ONE_IN_BASIS_POINTS = exports2.MAX_FEE_BASIS_POINTS = void 0;
    var buffer_layout_1 = require_Layout();
    var buffer_layout_utils_1 = require_cjs();
    var extensionType_js_1 = require_extensionType2();
    exports2.MAX_FEE_BASIS_POINTS = 1e4;
    exports2.ONE_IN_BASIS_POINTS = BigInt(exports2.MAX_FEE_BASIS_POINTS);
    function transferFeeLayout(property) {
      return (0, buffer_layout_1.struct)([(0, buffer_layout_utils_1.u64)("epoch"), (0, buffer_layout_utils_1.u64)("maximumFee"), (0, buffer_layout_1.u16)("transferFeeBasisPoints")], property);
    }
    exports2.transferFeeLayout = transferFeeLayout;
    function calculateFee(transferFee, preFeeAmount) {
      const transferFeeBasisPoints = transferFee.transferFeeBasisPoints;
      if (transferFeeBasisPoints === 0 || preFeeAmount === BigInt(0)) {
        return BigInt(0);
      } else {
        const numerator = preFeeAmount * BigInt(transferFeeBasisPoints);
        const rawFee = (numerator + exports2.ONE_IN_BASIS_POINTS - BigInt(1)) / exports2.ONE_IN_BASIS_POINTS;
        const fee = rawFee > transferFee.maximumFee ? transferFee.maximumFee : rawFee;
        return BigInt(fee);
      }
    }
    exports2.calculateFee = calculateFee;
    exports2.TransferFeeConfigLayout = (0, buffer_layout_1.struct)([
      (0, buffer_layout_utils_1.publicKey)("transferFeeConfigAuthority"),
      (0, buffer_layout_utils_1.publicKey)("withdrawWithheldAuthority"),
      (0, buffer_layout_utils_1.u64)("withheldAmount"),
      transferFeeLayout("olderTransferFee"),
      transferFeeLayout("newerTransferFee")
    ]);
    exports2.TRANSFER_FEE_CONFIG_SIZE = exports2.TransferFeeConfigLayout.span;
    function getEpochFee(transferFeeConfig, epoch) {
      if (epoch >= transferFeeConfig.newerTransferFee.epoch) {
        return transferFeeConfig.newerTransferFee;
      } else {
        return transferFeeConfig.olderTransferFee;
      }
    }
    exports2.getEpochFee = getEpochFee;
    function calculateEpochFee(transferFeeConfig, epoch, preFeeAmount) {
      const transferFee = getEpochFee(transferFeeConfig, epoch);
      return calculateFee(transferFee, preFeeAmount);
    }
    exports2.calculateEpochFee = calculateEpochFee;
    exports2.TransferFeeAmountLayout = (0, buffer_layout_1.struct)([(0, buffer_layout_utils_1.u64)("withheldAmount")]);
    exports2.TRANSFER_FEE_AMOUNT_SIZE = exports2.TransferFeeAmountLayout.span;
    function getTransferFeeConfig(mint) {
      const extensionData = (0, extensionType_js_1.getExtensionData)(extensionType_js_1.ExtensionType.TransferFeeConfig, mint.tlvData);
      if (extensionData !== null) {
        return exports2.TransferFeeConfigLayout.decode(extensionData);
      } else {
        return null;
      }
    }
    exports2.getTransferFeeConfig = getTransferFeeConfig;
    function getTransferFeeAmount(account) {
      const extensionData = (0, extensionType_js_1.getExtensionData)(extensionType_js_1.ExtensionType.TransferFeeAmount, account.tlvData);
      if (extensionData !== null) {
        return exports2.TransferFeeAmountLayout.decode(extensionData);
      } else {
        return null;
      }
    }
    exports2.getTransferFeeAmount = getTransferFeeAmount;
  }
});

// node_modules/@solana/spl-token/lib/cjs/extensions/transferFee/index.js
var require_transferFee2 = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/extensions/transferFee/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_actions15(), exports2);
    __exportStar(require_instructions16(), exports2);
    __exportStar(require_state23(), exports2);
  }
});

// node_modules/@solana/spl-token/lib/cjs/instructions/transferChecked.js
var require_transferChecked3 = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/instructions/transferChecked.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.decodeTransferCheckedInstructionUnchecked = exports2.decodeTransferCheckedInstruction = exports2.createTransferCheckedInstruction = exports2.transferCheckedInstructionData = void 0;
    var buffer_layout_1 = require_Layout();
    var buffer_layout_utils_1 = require_cjs();
    var web3_js_1 = require("@solana/web3.js");
    var constants_js_1 = require_constants2();
    var errors_js_1 = require_errors4();
    var internal_js_1 = require_internal3();
    var types_js_1 = require_types2();
    exports2.transferCheckedInstructionData = (0, buffer_layout_1.struct)([
      (0, buffer_layout_1.u8)("instruction"),
      (0, buffer_layout_utils_1.u64)("amount"),
      (0, buffer_layout_1.u8)("decimals")
    ]);
    function createTransferCheckedInstruction(source, mint, destination, owner, amount, decimals, multiSigners = [], programId = constants_js_1.TOKEN_PROGRAM_ID) {
      const keys = (0, internal_js_1.addSigners)([
        { pubkey: source, isSigner: false, isWritable: true },
        { pubkey: mint, isSigner: false, isWritable: false },
        { pubkey: destination, isSigner: false, isWritable: true }
      ], owner, multiSigners);
      const data = Buffer.alloc(exports2.transferCheckedInstructionData.span);
      exports2.transferCheckedInstructionData.encode({
        instruction: types_js_1.TokenInstruction.TransferChecked,
        amount: BigInt(amount),
        decimals
      }, data);
      return new web3_js_1.TransactionInstruction({ keys, programId, data });
    }
    exports2.createTransferCheckedInstruction = createTransferCheckedInstruction;
    function decodeTransferCheckedInstruction(instruction, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      if (!instruction.programId.equals(programId))
        throw new errors_js_1.TokenInvalidInstructionProgramError();
      if (instruction.data.length !== exports2.transferCheckedInstructionData.span)
        throw new errors_js_1.TokenInvalidInstructionDataError();
      const { keys: { source, mint, destination, owner, multiSigners }, data } = decodeTransferCheckedInstructionUnchecked(instruction);
      if (data.instruction !== types_js_1.TokenInstruction.TransferChecked)
        throw new errors_js_1.TokenInvalidInstructionTypeError();
      if (!source || !mint || !destination || !owner)
        throw new errors_js_1.TokenInvalidInstructionKeysError();
      return {
        programId,
        keys: {
          source,
          mint,
          destination,
          owner,
          multiSigners
        },
        data
      };
    }
    exports2.decodeTransferCheckedInstruction = decodeTransferCheckedInstruction;
    function decodeTransferCheckedInstructionUnchecked({ programId, keys: [source, mint, destination, owner, ...multiSigners], data }) {
      return {
        programId,
        keys: {
          source,
          mint,
          destination,
          owner,
          multiSigners
        },
        data: exports2.transferCheckedInstructionData.decode(data)
      };
    }
    exports2.decodeTransferCheckedInstructionUnchecked = decodeTransferCheckedInstructionUnchecked;
  }
});

// node_modules/@solana/spl-token/lib/cjs/extensions/transferHook/seeds.js
var require_seeds2 = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/extensions/transferHook/seeds.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.unpackSeeds = void 0;
    var errors_js_1 = require_errors4();
    var DISCRIMINATOR_SPAN = 1;
    var LITERAL_LENGTH_SPAN = 1;
    var INSTRUCTION_ARG_OFFSET_SPAN = 1;
    var INSTRUCTION_ARG_LENGTH_SPAN = 1;
    var ACCOUNT_KEY_INDEX_SPAN = 1;
    var ACCOUNT_DATA_ACCOUNT_INDEX_SPAN = 1;
    var ACCOUNT_DATA_OFFSET_SPAN = 1;
    var ACCOUNT_DATA_LENGTH_SPAN = 1;
    function unpackSeedLiteral(seeds) {
      if (seeds.length < 1) {
        throw new errors_js_1.TokenTransferHookInvalidSeed();
      }
      const [length, ...rest] = seeds;
      if (rest.length < length) {
        throw new errors_js_1.TokenTransferHookInvalidSeed();
      }
      return {
        data: Buffer.from(rest.slice(0, length)),
        packedLength: DISCRIMINATOR_SPAN + LITERAL_LENGTH_SPAN + length
      };
    }
    function unpackSeedInstructionArg(seeds, instructionData) {
      if (seeds.length < 2) {
        throw new errors_js_1.TokenTransferHookInvalidSeed();
      }
      const [index, length] = seeds;
      if (instructionData.length < length + index) {
        throw new errors_js_1.TokenTransferHookInvalidSeed();
      }
      return {
        data: instructionData.subarray(index, index + length),
        packedLength: DISCRIMINATOR_SPAN + INSTRUCTION_ARG_OFFSET_SPAN + INSTRUCTION_ARG_LENGTH_SPAN
      };
    }
    function unpackSeedAccountKey(seeds, previousMetas) {
      if (seeds.length < 1) {
        throw new errors_js_1.TokenTransferHookInvalidSeed();
      }
      const [index] = seeds;
      if (previousMetas.length <= index) {
        throw new errors_js_1.TokenTransferHookInvalidSeed();
      }
      return {
        data: previousMetas[index].pubkey.toBuffer(),
        packedLength: DISCRIMINATOR_SPAN + ACCOUNT_KEY_INDEX_SPAN
      };
    }
    function unpackSeedAccountData(seeds, previousMetas, connection) {
      return __awaiter(this, void 0, void 0, function* () {
        if (seeds.length < 3) {
          throw new errors_js_1.TokenTransferHookInvalidSeed();
        }
        const [accountIndex, dataIndex, length] = seeds;
        if (previousMetas.length <= accountIndex) {
          throw new errors_js_1.TokenTransferHookInvalidSeed();
        }
        const accountInfo = yield connection.getAccountInfo(previousMetas[accountIndex].pubkey);
        if (accountInfo == null) {
          throw new errors_js_1.TokenTransferHookAccountDataNotFound();
        }
        if (accountInfo.data.length < dataIndex + length) {
          throw new errors_js_1.TokenTransferHookInvalidSeed();
        }
        return {
          data: accountInfo.data.subarray(dataIndex, dataIndex + length),
          packedLength: DISCRIMINATOR_SPAN + ACCOUNT_DATA_ACCOUNT_INDEX_SPAN + ACCOUNT_DATA_OFFSET_SPAN + ACCOUNT_DATA_LENGTH_SPAN
        };
      });
    }
    function unpackFirstSeed(seeds, previousMetas, instructionData, connection) {
      return __awaiter(this, void 0, void 0, function* () {
        const [discriminator, ...rest] = seeds;
        const remaining = new Uint8Array(rest);
        switch (discriminator) {
          case 0:
            return null;
          case 1:
            return unpackSeedLiteral(remaining);
          case 2:
            return unpackSeedInstructionArg(remaining, instructionData);
          case 3:
            return unpackSeedAccountKey(remaining, previousMetas);
          case 4:
            return unpackSeedAccountData(remaining, previousMetas, connection);
          default:
            throw new errors_js_1.TokenTransferHookInvalidSeed();
        }
      });
    }
    function unpackSeeds(seeds, previousMetas, instructionData, connection) {
      return __awaiter(this, void 0, void 0, function* () {
        const unpackedSeeds = [];
        let i = 0;
        while (i < 32) {
          const seed = yield unpackFirstSeed(seeds.slice(i), previousMetas, instructionData, connection);
          if (seed == null) {
            break;
          }
          unpackedSeeds.push(seed.data);
          i += seed.packedLength;
        }
        return unpackedSeeds;
      });
    }
    exports2.unpackSeeds = unpackSeeds;
  }
});

// node_modules/@solana/spl-token/lib/cjs/extensions/transferHook/state.js
var require_state24 = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/extensions/transferHook/state.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.resolveExtraAccountMeta = exports2.getExtraAccountMetas = exports2.ExtraAccountMetaAccountDataLayout = exports2.ExtraAccountMetaListLayout = exports2.ExtraAccountMetaLayout = exports2.getExtraAccountMetaAddress = exports2.getTransferHookAccount = exports2.TRANSFER_HOOK_ACCOUNT_SIZE = exports2.TransferHookAccountLayout = exports2.getTransferHook = exports2.TRANSFER_HOOK_SIZE = exports2.TransferHookLayout = void 0;
    var buffer_layout_1 = require_Layout();
    var extensionType_js_1 = require_extensionType2();
    var web3_js_1 = require("@solana/web3.js");
    var buffer_layout_utils_1 = require_cjs();
    var errors_js_1 = require_errors4();
    var seeds_js_1 = require_seeds2();
    exports2.TransferHookLayout = (0, buffer_layout_1.struct)([(0, buffer_layout_utils_1.publicKey)("authority"), (0, buffer_layout_utils_1.publicKey)("programId")]);
    exports2.TRANSFER_HOOK_SIZE = exports2.TransferHookLayout.span;
    function getTransferHook(mint) {
      const extensionData = (0, extensionType_js_1.getExtensionData)(extensionType_js_1.ExtensionType.TransferHook, mint.tlvData);
      if (extensionData !== null) {
        return exports2.TransferHookLayout.decode(extensionData);
      } else {
        return null;
      }
    }
    exports2.getTransferHook = getTransferHook;
    exports2.TransferHookAccountLayout = (0, buffer_layout_1.struct)([(0, buffer_layout_utils_1.bool)("transferring")]);
    exports2.TRANSFER_HOOK_ACCOUNT_SIZE = exports2.TransferHookAccountLayout.span;
    function getTransferHookAccount(account) {
      const extensionData = (0, extensionType_js_1.getExtensionData)(extensionType_js_1.ExtensionType.TransferHookAccount, account.tlvData);
      if (extensionData !== null) {
        return exports2.TransferHookAccountLayout.decode(extensionData);
      } else {
        return null;
      }
    }
    exports2.getTransferHookAccount = getTransferHookAccount;
    function getExtraAccountMetaAddress(mint, programId) {
      const seeds = [Buffer.from("extra-account-metas"), mint.toBuffer()];
      return web3_js_1.PublicKey.findProgramAddressSync(seeds, programId)[0];
    }
    exports2.getExtraAccountMetaAddress = getExtraAccountMetaAddress;
    exports2.ExtraAccountMetaLayout = (0, buffer_layout_1.struct)([
      (0, buffer_layout_1.u8)("discriminator"),
      (0, buffer_layout_1.blob)(32, "addressConfig"),
      (0, buffer_layout_utils_1.bool)("isSigner"),
      (0, buffer_layout_utils_1.bool)("isWritable")
    ]);
    exports2.ExtraAccountMetaListLayout = (0, buffer_layout_1.struct)([
      (0, buffer_layout_1.u32)("count"),
      (0, buffer_layout_1.seq)(exports2.ExtraAccountMetaLayout, (0, buffer_layout_1.greedy)(exports2.ExtraAccountMetaLayout.span), "extraAccounts")
    ]);
    exports2.ExtraAccountMetaAccountDataLayout = (0, buffer_layout_1.struct)([
      (0, buffer_layout_utils_1.u64)("instructionDiscriminator"),
      (0, buffer_layout_1.u32)("length"),
      exports2.ExtraAccountMetaListLayout.replicate("extraAccountsList")
    ]);
    function getExtraAccountMetas(account) {
      const extraAccountsList = exports2.ExtraAccountMetaAccountDataLayout.decode(account.data).extraAccountsList;
      return extraAccountsList.extraAccounts.slice(0, extraAccountsList.count);
    }
    exports2.getExtraAccountMetas = getExtraAccountMetas;
    function resolveExtraAccountMeta(connection, extraMeta, previousMetas, instructionData, transferHookProgramId) {
      return __awaiter(this, void 0, void 0, function* () {
        if (extraMeta.discriminator === 0) {
          return {
            pubkey: new web3_js_1.PublicKey(extraMeta.addressConfig),
            isSigner: extraMeta.isSigner,
            isWritable: extraMeta.isWritable
          };
        }
        let programId = web3_js_1.PublicKey.default;
        if (extraMeta.discriminator === 1) {
          programId = transferHookProgramId;
        } else {
          const accountIndex = extraMeta.discriminator - (1 << 7);
          if (previousMetas.length <= accountIndex) {
            throw new errors_js_1.TokenTransferHookAccountNotFound();
          }
          programId = previousMetas[accountIndex].pubkey;
        }
        const seeds = yield (0, seeds_js_1.unpackSeeds)(extraMeta.addressConfig, previousMetas, instructionData, connection);
        const pubkey = web3_js_1.PublicKey.findProgramAddressSync(seeds, programId)[0];
        return { pubkey, isSigner: extraMeta.isSigner, isWritable: extraMeta.isWritable };
      });
    }
    exports2.resolveExtraAccountMeta = resolveExtraAccountMeta;
  }
});

// node_modules/@solana/spl-token/lib/cjs/extensions/transferHook/instructions.js
var require_instructions17 = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/extensions/transferHook/instructions.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createTransferCheckedWithFeeAndTransferHookInstruction = exports2.createTransferCheckedWithTransferHookInstruction = exports2.addExtraAccountsToInstruction = exports2.createUpdateTransferHookInstruction = exports2.updateTransferHookInstructionData = exports2.createInitializeTransferHookInstruction = exports2.initializeTransferHookInstructionData = exports2.TransferHookInstruction = void 0;
    var buffer_layout_1 = require_Layout();
    var web3_js_1 = require("@solana/web3.js");
    var constants_js_1 = require_constants2();
    var errors_js_1 = require_errors4();
    var internal_js_1 = require_internal3();
    var types_js_1 = require_types2();
    var buffer_layout_utils_1 = require_cjs();
    var transferChecked_js_1 = require_transferChecked3();
    var instructions_js_1 = require_instructions16();
    var mint_js_1 = require_mint2();
    var state_js_1 = require_state24();
    var TransferHookInstruction;
    (function(TransferHookInstruction2) {
      TransferHookInstruction2[TransferHookInstruction2["Initialize"] = 0] = "Initialize";
      TransferHookInstruction2[TransferHookInstruction2["Update"] = 1] = "Update";
    })(TransferHookInstruction || (exports2.TransferHookInstruction = TransferHookInstruction = {}));
    exports2.initializeTransferHookInstructionData = (0, buffer_layout_1.struct)([
      (0, buffer_layout_1.u8)("instruction"),
      (0, buffer_layout_1.u8)("transferHookInstruction"),
      (0, buffer_layout_utils_1.publicKey)("authority"),
      (0, buffer_layout_utils_1.publicKey)("transferHookProgramId")
    ]);
    function createInitializeTransferHookInstruction(mint, authority, transferHookProgramId, programId) {
      if (!(0, constants_js_1.programSupportsExtensions)(programId)) {
        throw new errors_js_1.TokenUnsupportedInstructionError();
      }
      const keys = [{ pubkey: mint, isSigner: false, isWritable: true }];
      const data = Buffer.alloc(exports2.initializeTransferHookInstructionData.span);
      exports2.initializeTransferHookInstructionData.encode({
        instruction: types_js_1.TokenInstruction.TransferHookExtension,
        transferHookInstruction: TransferHookInstruction.Initialize,
        authority,
        transferHookProgramId
      }, data);
      return new web3_js_1.TransactionInstruction({ keys, programId, data });
    }
    exports2.createInitializeTransferHookInstruction = createInitializeTransferHookInstruction;
    exports2.updateTransferHookInstructionData = (0, buffer_layout_1.struct)([
      (0, buffer_layout_1.u8)("instruction"),
      (0, buffer_layout_1.u8)("transferHookInstruction"),
      (0, buffer_layout_utils_1.publicKey)("transferHookProgramId")
    ]);
    function createUpdateTransferHookInstruction(mint, authority, transferHookProgramId, multiSigners = [], programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
      if (!(0, constants_js_1.programSupportsExtensions)(programId)) {
        throw new errors_js_1.TokenUnsupportedInstructionError();
      }
      const keys = (0, internal_js_1.addSigners)([{ pubkey: mint, isSigner: false, isWritable: true }], authority, multiSigners);
      const data = Buffer.alloc(exports2.updateTransferHookInstructionData.span);
      exports2.updateTransferHookInstructionData.encode({
        instruction: types_js_1.TokenInstruction.TransferHookExtension,
        transferHookInstruction: TransferHookInstruction.Update,
        transferHookProgramId
      }, data);
      return new web3_js_1.TransactionInstruction({ keys, programId, data });
    }
    exports2.createUpdateTransferHookInstruction = createUpdateTransferHookInstruction;
    function deEscalateAccountMeta(accountMeta2, accountMetas) {
      const maybeHighestPrivileges = accountMetas.filter((x) => x.pubkey === accountMeta2.pubkey).reduce((acc, x) => {
        if (!acc)
          return { isSigner: x.isSigner, isWritable: x.isWritable };
        return { isSigner: acc.isSigner || x.isSigner, isWritable: acc.isWritable || x.isWritable };
      }, void 0);
      if (maybeHighestPrivileges) {
        const { isSigner, isWritable } = maybeHighestPrivileges;
        if (!isSigner && isSigner !== accountMeta2.isSigner) {
          accountMeta2.isSigner = false;
        }
        if (!isWritable && isWritable !== accountMeta2.isWritable) {
          accountMeta2.isWritable = false;
        }
      }
      return accountMeta2;
    }
    function addExtraAccountsToInstruction(connection, instruction, mint, commitment, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      return __awaiter(this, void 0, void 0, function* () {
        if (!(0, constants_js_1.programSupportsExtensions)(programId)) {
          throw new errors_js_1.TokenUnsupportedInstructionError();
        }
        const mintInfo = yield (0, mint_js_1.getMint)(connection, mint, commitment, programId);
        const transferHook = (0, state_js_1.getTransferHook)(mintInfo);
        if (transferHook == null) {
          return instruction;
        }
        const extraAccountsAccount = (0, state_js_1.getExtraAccountMetaAddress)(mint, transferHook.programId);
        const extraAccountsInfo = yield connection.getAccountInfo(extraAccountsAccount, commitment);
        if (extraAccountsInfo == null) {
          return instruction;
        }
        const extraAccountMetas = (0, state_js_1.getExtraAccountMetas)(extraAccountsInfo);
        const accountMetas = instruction.keys;
        for (const extraAccountMeta of extraAccountMetas) {
          const accountMetaUnchecked = yield (0, state_js_1.resolveExtraAccountMeta)(connection, extraAccountMeta, accountMetas, instruction.data, transferHook.programId);
          const accountMeta2 = deEscalateAccountMeta(accountMetaUnchecked, accountMetas);
          accountMetas.push(accountMeta2);
        }
        accountMetas.push({ pubkey: transferHook.programId, isSigner: false, isWritable: false });
        accountMetas.push({ pubkey: extraAccountsAccount, isSigner: false, isWritable: false });
        return new web3_js_1.TransactionInstruction({ keys: accountMetas, programId, data: instruction.data });
      });
    }
    exports2.addExtraAccountsToInstruction = addExtraAccountsToInstruction;
    function createTransferCheckedWithTransferHookInstruction(connection, source, mint, destination, authority, amount, decimals, multiSigners = [], commitment, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      return __awaiter(this, void 0, void 0, function* () {
        const rawInstruction = (0, transferChecked_js_1.createTransferCheckedInstruction)(source, mint, destination, authority, amount, decimals, multiSigners, programId);
        const hydratedInstruction = yield addExtraAccountsToInstruction(connection, rawInstruction, mint, commitment, programId);
        return hydratedInstruction;
      });
    }
    exports2.createTransferCheckedWithTransferHookInstruction = createTransferCheckedWithTransferHookInstruction;
    function createTransferCheckedWithFeeAndTransferHookInstruction(connection, source, mint, destination, authority, amount, decimals, fee, multiSigners = [], commitment, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      return __awaiter(this, void 0, void 0, function* () {
        const rawInstruction = (0, instructions_js_1.createTransferCheckedWithFeeInstruction)(source, mint, destination, authority, amount, decimals, fee, multiSigners, programId);
        const hydratedInstruction = yield addExtraAccountsToInstruction(connection, rawInstruction, mint, commitment, programId);
        return hydratedInstruction;
      });
    }
    exports2.createTransferCheckedWithFeeAndTransferHookInstruction = createTransferCheckedWithFeeAndTransferHookInstruction;
  }
});

// node_modules/@solana/spl-token/lib/cjs/extensions/transferHook/actions.js
var require_actions16 = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/extensions/transferHook/actions.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.transferCheckedWithFeeAndTransferHook = exports2.transferCheckedWithTransferHook = exports2.updateTransferHook = exports2.initializeTransferHook = void 0;
    var web3_js_1 = require("@solana/web3.js");
    var internal_js_1 = require_internal4();
    var constants_js_1 = require_constants2();
    var instructions_js_1 = require_instructions17();
    function initializeTransferHook(connection, payer, mint, authority, transferHookProgramId, confirmOptions, programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
      return __awaiter(this, void 0, void 0, function* () {
        const transaction = new web3_js_1.Transaction().add((0, instructions_js_1.createInitializeTransferHookInstruction)(mint, authority, transferHookProgramId, programId));
        return yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer], confirmOptions);
      });
    }
    exports2.initializeTransferHook = initializeTransferHook;
    function updateTransferHook(connection, payer, mint, transferHookProgramId, authority, multiSigners = [], confirmOptions, programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
      return __awaiter(this, void 0, void 0, function* () {
        const [authorityPublicKey, signers] = (0, internal_js_1.getSigners)(authority, multiSigners);
        const transaction = new web3_js_1.Transaction().add((0, instructions_js_1.createUpdateTransferHookInstruction)(mint, authorityPublicKey, transferHookProgramId, signers, programId));
        return yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer, ...signers], confirmOptions);
      });
    }
    exports2.updateTransferHook = updateTransferHook;
    function transferCheckedWithTransferHook(connection, payer, source, mint, destination, authority, amount, decimals, multiSigners = [], confirmOptions, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      return __awaiter(this, void 0, void 0, function* () {
        const [authorityPublicKey, signers] = (0, internal_js_1.getSigners)(authority, multiSigners);
        const transaction = new web3_js_1.Transaction().add(yield (0, instructions_js_1.createTransferCheckedWithTransferHookInstruction)(connection, source, mint, destination, authorityPublicKey, amount, decimals, signers, confirmOptions === null || confirmOptions === void 0 ? void 0 : confirmOptions.commitment, programId));
        return yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer, ...signers], confirmOptions);
      });
    }
    exports2.transferCheckedWithTransferHook = transferCheckedWithTransferHook;
    function transferCheckedWithFeeAndTransferHook(connection, payer, source, mint, destination, authority, amount, decimals, fee, multiSigners = [], confirmOptions, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      return __awaiter(this, void 0, void 0, function* () {
        const [authorityPublicKey, signers] = (0, internal_js_1.getSigners)(authority, multiSigners);
        const transaction = new web3_js_1.Transaction().add(yield (0, instructions_js_1.createTransferCheckedWithFeeAndTransferHookInstruction)(connection, source, mint, destination, authorityPublicKey, amount, decimals, fee, signers, confirmOptions === null || confirmOptions === void 0 ? void 0 : confirmOptions.commitment, programId));
        return yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer, ...signers], confirmOptions);
      });
    }
    exports2.transferCheckedWithFeeAndTransferHook = transferCheckedWithFeeAndTransferHook;
  }
});

// node_modules/@solana/spl-token/lib/cjs/extensions/transferHook/index.js
var require_transferHook2 = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/extensions/transferHook/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_actions16(), exports2);
    __exportStar(require_instructions17(), exports2);
    __exportStar(require_seeds2(), exports2);
    __exportStar(require_state24(), exports2);
  }
});

// node_modules/@solana/spl-token/lib/cjs/extensions/extensionType.js
var require_extensionType2 = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/extensions/extensionType.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getNewAccountLenForExtensionLen = exports2.getAccountLenForMint = exports2.getExtensionTypes = exports2.getExtensionData = exports2.getAccountLen = exports2.getMintLen = exports2.getAccountTypeOfMintType = exports2.isAccountExtension = exports2.isMintExtension = exports2.getTypeLen = exports2.LENGTH_SIZE = exports2.TYPE_SIZE = exports2.ExtensionType = void 0;
    var account_js_1 = require_account2();
    var mint_js_1 = require_mint2();
    var multisig_js_1 = require_multisig2();
    var accountType_js_1 = require_accountType2();
    var index_js_1 = require_cpiGuard2();
    var index_js_2 = require_defaultAccountState2();
    var immutableOwner_js_1 = require_immutableOwner2();
    var state_js_1 = require_state20();
    var index_js_3 = require_memoTransfer2();
    var state_js_2 = require_state22();
    var mintCloseAuthority_js_1 = require_mintCloseAuthority2();
    var nonTransferable_js_1 = require_nonTransferable2();
    var permanentDelegate_js_1 = require_permanentDelegate2();
    var index_js_4 = require_transferFee2();
    var index_js_5 = require_transferHook2();
    var constants_js_1 = require_constants2();
    var ExtensionType;
    (function(ExtensionType2) {
      ExtensionType2[ExtensionType2["Uninitialized"] = 0] = "Uninitialized";
      ExtensionType2[ExtensionType2["TransferFeeConfig"] = 1] = "TransferFeeConfig";
      ExtensionType2[ExtensionType2["TransferFeeAmount"] = 2] = "TransferFeeAmount";
      ExtensionType2[ExtensionType2["MintCloseAuthority"] = 3] = "MintCloseAuthority";
      ExtensionType2[ExtensionType2["ConfidentialTransferMint"] = 4] = "ConfidentialTransferMint";
      ExtensionType2[ExtensionType2["ConfidentialTransferAccount"] = 5] = "ConfidentialTransferAccount";
      ExtensionType2[ExtensionType2["DefaultAccountState"] = 6] = "DefaultAccountState";
      ExtensionType2[ExtensionType2["ImmutableOwner"] = 7] = "ImmutableOwner";
      ExtensionType2[ExtensionType2["MemoTransfer"] = 8] = "MemoTransfer";
      ExtensionType2[ExtensionType2["NonTransferable"] = 9] = "NonTransferable";
      ExtensionType2[ExtensionType2["InterestBearingConfig"] = 10] = "InterestBearingConfig";
      ExtensionType2[ExtensionType2["CpiGuard"] = 11] = "CpiGuard";
      ExtensionType2[ExtensionType2["PermanentDelegate"] = 12] = "PermanentDelegate";
      ExtensionType2[ExtensionType2["NonTransferableAccount"] = 13] = "NonTransferableAccount";
      ExtensionType2[ExtensionType2["TransferHook"] = 14] = "TransferHook";
      ExtensionType2[ExtensionType2["TransferHookAccount"] = 15] = "TransferHookAccount";
      ExtensionType2[ExtensionType2["MetadataPointer"] = 18] = "MetadataPointer";
      ExtensionType2[ExtensionType2["TokenMetadata"] = 19] = "TokenMetadata";
    })(ExtensionType || (exports2.ExtensionType = ExtensionType = {}));
    exports2.TYPE_SIZE = 2;
    exports2.LENGTH_SIZE = 2;
    function addTypeAndLengthToLen(len) {
      return len + exports2.TYPE_SIZE + exports2.LENGTH_SIZE;
    }
    function isVariableLengthExtension(e) {
      switch (e) {
        case ExtensionType.TokenMetadata:
          return true;
        default:
          return false;
      }
    }
    function getTypeLen(e) {
      switch (e) {
        case ExtensionType.Uninitialized:
          return 0;
        case ExtensionType.TransferFeeConfig:
          return index_js_4.TRANSFER_FEE_CONFIG_SIZE;
        case ExtensionType.TransferFeeAmount:
          return index_js_4.TRANSFER_FEE_AMOUNT_SIZE;
        case ExtensionType.MintCloseAuthority:
          return mintCloseAuthority_js_1.MINT_CLOSE_AUTHORITY_SIZE;
        case ExtensionType.ConfidentialTransferMint:
          return 97;
        case ExtensionType.ConfidentialTransferAccount:
          return 286;
        case ExtensionType.CpiGuard:
          return index_js_1.CPI_GUARD_SIZE;
        case ExtensionType.DefaultAccountState:
          return index_js_2.DEFAULT_ACCOUNT_STATE_SIZE;
        case ExtensionType.ImmutableOwner:
          return immutableOwner_js_1.IMMUTABLE_OWNER_SIZE;
        case ExtensionType.MemoTransfer:
          return index_js_3.MEMO_TRANSFER_SIZE;
        case ExtensionType.MetadataPointer:
          return state_js_2.METADATA_POINTER_SIZE;
        case ExtensionType.NonTransferable:
          return nonTransferable_js_1.NON_TRANSFERABLE_SIZE;
        case ExtensionType.InterestBearingConfig:
          return state_js_1.INTEREST_BEARING_MINT_CONFIG_STATE_SIZE;
        case ExtensionType.PermanentDelegate:
          return permanentDelegate_js_1.PERMANENT_DELEGATE_SIZE;
        case ExtensionType.NonTransferableAccount:
          return nonTransferable_js_1.NON_TRANSFERABLE_ACCOUNT_SIZE;
        case ExtensionType.TransferHook:
          return index_js_5.TRANSFER_HOOK_SIZE;
        case ExtensionType.TransferHookAccount:
          return index_js_5.TRANSFER_HOOK_ACCOUNT_SIZE;
        case ExtensionType.TokenMetadata:
          throw Error(`Cannot get type length for variable extension type: ${e}`);
        default:
          throw Error(`Unknown extension type: ${e}`);
      }
    }
    exports2.getTypeLen = getTypeLen;
    function isMintExtension(e) {
      switch (e) {
        case ExtensionType.TransferFeeConfig:
        case ExtensionType.MintCloseAuthority:
        case ExtensionType.ConfidentialTransferMint:
        case ExtensionType.DefaultAccountState:
        case ExtensionType.NonTransferable:
        case ExtensionType.InterestBearingConfig:
        case ExtensionType.PermanentDelegate:
        case ExtensionType.TransferHook:
        case ExtensionType.MetadataPointer:
        case ExtensionType.TokenMetadata:
          return true;
        case ExtensionType.Uninitialized:
        case ExtensionType.TransferFeeAmount:
        case ExtensionType.ConfidentialTransferAccount:
        case ExtensionType.ImmutableOwner:
        case ExtensionType.MemoTransfer:
        case ExtensionType.CpiGuard:
        case ExtensionType.NonTransferableAccount:
        case ExtensionType.TransferHookAccount:
          return false;
        default:
          throw Error(`Unknown extension type: ${e}`);
      }
    }
    exports2.isMintExtension = isMintExtension;
    function isAccountExtension(e) {
      switch (e) {
        case ExtensionType.TransferFeeAmount:
        case ExtensionType.ConfidentialTransferAccount:
        case ExtensionType.ImmutableOwner:
        case ExtensionType.MemoTransfer:
        case ExtensionType.CpiGuard:
        case ExtensionType.NonTransferableAccount:
        case ExtensionType.TransferHookAccount:
          return true;
        case ExtensionType.Uninitialized:
        case ExtensionType.TransferFeeConfig:
        case ExtensionType.MintCloseAuthority:
        case ExtensionType.ConfidentialTransferMint:
        case ExtensionType.DefaultAccountState:
        case ExtensionType.NonTransferable:
        case ExtensionType.InterestBearingConfig:
        case ExtensionType.PermanentDelegate:
        case ExtensionType.TransferHook:
        case ExtensionType.MetadataPointer:
        case ExtensionType.TokenMetadata:
          return false;
        default:
          throw Error(`Unknown extension type: ${e}`);
      }
    }
    exports2.isAccountExtension = isAccountExtension;
    function getAccountTypeOfMintType(e) {
      switch (e) {
        case ExtensionType.TransferFeeConfig:
          return ExtensionType.TransferFeeAmount;
        case ExtensionType.ConfidentialTransferMint:
          return ExtensionType.ConfidentialTransferAccount;
        case ExtensionType.NonTransferable:
          return ExtensionType.NonTransferableAccount;
        case ExtensionType.TransferHook:
          return ExtensionType.TransferHookAccount;
        case ExtensionType.TransferFeeAmount:
        case ExtensionType.ConfidentialTransferAccount:
        case ExtensionType.CpiGuard:
        case ExtensionType.DefaultAccountState:
        case ExtensionType.ImmutableOwner:
        case ExtensionType.MemoTransfer:
        case ExtensionType.MintCloseAuthority:
        case ExtensionType.MetadataPointer:
        case ExtensionType.TokenMetadata:
        case ExtensionType.Uninitialized:
        case ExtensionType.InterestBearingConfig:
        case ExtensionType.PermanentDelegate:
        case ExtensionType.NonTransferableAccount:
        case ExtensionType.TransferHookAccount:
          return ExtensionType.Uninitialized;
      }
    }
    exports2.getAccountTypeOfMintType = getAccountTypeOfMintType;
    function getLen(extensionTypes, baseSize, variableLengthExtensions = {}) {
      if (extensionTypes.length === 0 && Object.keys(variableLengthExtensions).length === 0) {
        return baseSize;
      } else {
        const accountLength = account_js_1.ACCOUNT_SIZE + accountType_js_1.ACCOUNT_TYPE_SIZE + extensionTypes.filter((element, i) => i === extensionTypes.indexOf(element)).map((element) => addTypeAndLengthToLen(getTypeLen(element))).reduce((a, b) => a + b, 0) + Object.entries(variableLengthExtensions).map(([extension, len]) => {
          if (!isVariableLengthExtension(Number(extension))) {
            throw Error(`Extension ${extension} is not variable length`);
          }
          return addTypeAndLengthToLen(len);
        }).reduce((a, b) => a + b, 0);
        if (accountLength === multisig_js_1.MULTISIG_SIZE) {
          return accountLength + exports2.TYPE_SIZE;
        } else {
          return accountLength;
        }
      }
    }
    function getMintLen(extensionTypes, variableLengthExtensions = {}) {
      return getLen(extensionTypes, mint_js_1.MINT_SIZE, variableLengthExtensions);
    }
    exports2.getMintLen = getMintLen;
    function getAccountLen(extensionTypes) {
      return getLen(extensionTypes, account_js_1.ACCOUNT_SIZE);
    }
    exports2.getAccountLen = getAccountLen;
    function getExtensionData(extension, tlvData) {
      let extensionTypeIndex = 0;
      while (addTypeAndLengthToLen(extensionTypeIndex) <= tlvData.length) {
        const entryType = tlvData.readUInt16LE(extensionTypeIndex);
        const entryLength = tlvData.readUInt16LE(extensionTypeIndex + exports2.TYPE_SIZE);
        const typeIndex = addTypeAndLengthToLen(extensionTypeIndex);
        if (entryType == extension) {
          return tlvData.slice(typeIndex, typeIndex + entryLength);
        }
        extensionTypeIndex = typeIndex + entryLength;
      }
      return null;
    }
    exports2.getExtensionData = getExtensionData;
    function getExtensionTypes(tlvData) {
      const extensionTypes = [];
      let extensionTypeIndex = 0;
      while (extensionTypeIndex < tlvData.length) {
        const entryType = tlvData.readUInt16LE(extensionTypeIndex);
        extensionTypes.push(entryType);
        const entryLength = tlvData.readUInt16LE(extensionTypeIndex + exports2.TYPE_SIZE);
        extensionTypeIndex += addTypeAndLengthToLen(entryLength);
      }
      return extensionTypes;
    }
    exports2.getExtensionTypes = getExtensionTypes;
    function getAccountLenForMint(mint) {
      const extensionTypes = getExtensionTypes(mint.tlvData);
      const accountExtensions = extensionTypes.map(getAccountTypeOfMintType);
      return getAccountLen(accountExtensions);
    }
    exports2.getAccountLenForMint = getAccountLenForMint;
    function getNewAccountLenForExtensionLen(info, address, extensionType, extensionLen, programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
      const mint = (0, mint_js_1.unpackMint)(address, info, programId);
      const extensionData = getExtensionData(extensionType, mint.tlvData);
      const currentExtensionLen = extensionData ? addTypeAndLengthToLen(extensionData.length) : 0;
      const newExtensionLen = addTypeAndLengthToLen(extensionLen);
      return info.data.length + newExtensionLen - currentExtensionLen;
    }
    exports2.getNewAccountLenForExtensionLen = getNewAccountLenForExtensionLen;
  }
});

// node_modules/@solana/spl-token/lib/cjs/instructions/initializeAccount.js
var require_initializeAccount4 = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/instructions/initializeAccount.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.decodeInitializeAccountInstructionUnchecked = exports2.decodeInitializeAccountInstruction = exports2.createInitializeAccountInstruction = exports2.initializeAccountInstructionData = void 0;
    var buffer_layout_1 = require_Layout();
    var web3_js_1 = require("@solana/web3.js");
    var constants_js_1 = require_constants2();
    var errors_js_1 = require_errors4();
    var types_js_1 = require_types2();
    exports2.initializeAccountInstructionData = (0, buffer_layout_1.struct)([(0, buffer_layout_1.u8)("instruction")]);
    function createInitializeAccountInstruction(account, mint, owner, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      const keys = [
        { pubkey: account, isSigner: false, isWritable: true },
        { pubkey: mint, isSigner: false, isWritable: false },
        { pubkey: owner, isSigner: false, isWritable: false },
        { pubkey: web3_js_1.SYSVAR_RENT_PUBKEY, isSigner: false, isWritable: false }
      ];
      const data = Buffer.alloc(exports2.initializeAccountInstructionData.span);
      exports2.initializeAccountInstructionData.encode({ instruction: types_js_1.TokenInstruction.InitializeAccount }, data);
      return new web3_js_1.TransactionInstruction({ keys, programId, data });
    }
    exports2.createInitializeAccountInstruction = createInitializeAccountInstruction;
    function decodeInitializeAccountInstruction(instruction, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      if (!instruction.programId.equals(programId))
        throw new errors_js_1.TokenInvalidInstructionProgramError();
      if (instruction.data.length !== exports2.initializeAccountInstructionData.span)
        throw new errors_js_1.TokenInvalidInstructionDataError();
      const { keys: { account, mint, owner, rent }, data } = decodeInitializeAccountInstructionUnchecked(instruction);
      if (data.instruction !== types_js_1.TokenInstruction.InitializeAccount)
        throw new errors_js_1.TokenInvalidInstructionTypeError();
      if (!account || !mint || !owner || !rent)
        throw new errors_js_1.TokenInvalidInstructionKeysError();
      return {
        programId,
        keys: {
          account,
          mint,
          owner,
          rent
        },
        data
      };
    }
    exports2.decodeInitializeAccountInstruction = decodeInitializeAccountInstruction;
    function decodeInitializeAccountInstructionUnchecked({ programId, keys: [account, mint, owner, rent], data }) {
      return {
        programId,
        keys: {
          account,
          mint,
          owner,
          rent
        },
        data: exports2.initializeAccountInstructionData.decode(data)
      };
    }
    exports2.decodeInitializeAccountInstructionUnchecked = decodeInitializeAccountInstructionUnchecked;
  }
});

// node_modules/@solana/spl-token/lib/cjs/instructions/associatedTokenAccount.js
var require_associatedTokenAccount2 = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/instructions/associatedTokenAccount.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createRecoverNestedInstruction = exports2.createAssociatedTokenAccountIdempotentInstruction = exports2.createAssociatedTokenAccountInstruction = void 0;
    var web3_js_1 = require("@solana/web3.js");
    var constants_js_1 = require_constants2();
    function createAssociatedTokenAccountInstruction(payer, associatedToken, owner, mint, programId = constants_js_1.TOKEN_PROGRAM_ID, associatedTokenProgramId = constants_js_1.ASSOCIATED_TOKEN_PROGRAM_ID) {
      return buildAssociatedTokenAccountInstruction(payer, associatedToken, owner, mint, Buffer.alloc(0), programId, associatedTokenProgramId);
    }
    exports2.createAssociatedTokenAccountInstruction = createAssociatedTokenAccountInstruction;
    function createAssociatedTokenAccountIdempotentInstruction(payer, associatedToken, owner, mint, programId = constants_js_1.TOKEN_PROGRAM_ID, associatedTokenProgramId = constants_js_1.ASSOCIATED_TOKEN_PROGRAM_ID) {
      return buildAssociatedTokenAccountInstruction(payer, associatedToken, owner, mint, Buffer.from([1]), programId, associatedTokenProgramId);
    }
    exports2.createAssociatedTokenAccountIdempotentInstruction = createAssociatedTokenAccountIdempotentInstruction;
    function buildAssociatedTokenAccountInstruction(payer, associatedToken, owner, mint, instructionData, programId = constants_js_1.TOKEN_PROGRAM_ID, associatedTokenProgramId = constants_js_1.ASSOCIATED_TOKEN_PROGRAM_ID) {
      const keys = [
        { pubkey: payer, isSigner: true, isWritable: true },
        { pubkey: associatedToken, isSigner: false, isWritable: true },
        { pubkey: owner, isSigner: false, isWritable: false },
        { pubkey: mint, isSigner: false, isWritable: false },
        { pubkey: web3_js_1.SystemProgram.programId, isSigner: false, isWritable: false },
        { pubkey: programId, isSigner: false, isWritable: false }
      ];
      return new web3_js_1.TransactionInstruction({
        keys,
        programId: associatedTokenProgramId,
        data: instructionData
      });
    }
    function createRecoverNestedInstruction(nestedAssociatedToken, nestedMint, destinationAssociatedToken, ownerAssociatedToken, ownerMint, owner, programId = constants_js_1.TOKEN_PROGRAM_ID, associatedTokenProgramId = constants_js_1.ASSOCIATED_TOKEN_PROGRAM_ID) {
      const keys = [
        { pubkey: nestedAssociatedToken, isSigner: false, isWritable: true },
        { pubkey: nestedMint, isSigner: false, isWritable: false },
        { pubkey: destinationAssociatedToken, isSigner: false, isWritable: true },
        { pubkey: ownerAssociatedToken, isSigner: false, isWritable: true },
        { pubkey: ownerMint, isSigner: false, isWritable: false },
        { pubkey: owner, isSigner: true, isWritable: true },
        { pubkey: programId, isSigner: false, isWritable: false }
      ];
      return new web3_js_1.TransactionInstruction({
        keys,
        programId: associatedTokenProgramId,
        data: Buffer.from([2])
      });
    }
    exports2.createRecoverNestedInstruction = createRecoverNestedInstruction;
  }
});

// node_modules/@solana/spl-token/lib/cjs/actions/createAssociatedTokenAccount.js
var require_createAssociatedTokenAccount2 = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/actions/createAssociatedTokenAccount.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createAssociatedTokenAccount = void 0;
    var web3_js_1 = require("@solana/web3.js");
    var constants_js_1 = require_constants2();
    var associatedTokenAccount_js_1 = require_associatedTokenAccount2();
    var mint_js_1 = require_mint2();
    function createAssociatedTokenAccount(connection, payer, mint, owner, confirmOptions, programId = constants_js_1.TOKEN_PROGRAM_ID, associatedTokenProgramId = constants_js_1.ASSOCIATED_TOKEN_PROGRAM_ID) {
      return __awaiter(this, void 0, void 0, function* () {
        const associatedToken = (0, mint_js_1.getAssociatedTokenAddressSync)(mint, owner, false, programId, associatedTokenProgramId);
        const transaction = new web3_js_1.Transaction().add((0, associatedTokenAccount_js_1.createAssociatedTokenAccountInstruction)(payer.publicKey, associatedToken, owner, mint, programId, associatedTokenProgramId));
        yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer], confirmOptions);
        return associatedToken;
      });
    }
    exports2.createAssociatedTokenAccount = createAssociatedTokenAccount;
  }
});

// node_modules/@solana/spl-token/lib/cjs/actions/createAccount.js
var require_createAccount2 = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/actions/createAccount.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createAccount = void 0;
    var web3_js_1 = require("@solana/web3.js");
    var constants_js_1 = require_constants2();
    var extensionType_js_1 = require_extensionType2();
    var initializeAccount_js_1 = require_initializeAccount4();
    var mint_js_1 = require_mint2();
    var createAssociatedTokenAccount_js_1 = require_createAssociatedTokenAccount2();
    function createAccount(connection, payer, mint, owner, keypair, confirmOptions, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      return __awaiter(this, void 0, void 0, function* () {
        if (!keypair)
          return yield (0, createAssociatedTokenAccount_js_1.createAssociatedTokenAccount)(connection, payer, mint, owner, confirmOptions, programId);
        const mintState = yield (0, mint_js_1.getMint)(connection, mint, confirmOptions === null || confirmOptions === void 0 ? void 0 : confirmOptions.commitment, programId);
        const space = (0, extensionType_js_1.getAccountLenForMint)(mintState);
        const lamports = yield connection.getMinimumBalanceForRentExemption(space);
        const transaction = new web3_js_1.Transaction().add(web3_js_1.SystemProgram.createAccount({
          fromPubkey: payer.publicKey,
          newAccountPubkey: keypair.publicKey,
          space,
          lamports,
          programId
        }), (0, initializeAccount_js_1.createInitializeAccountInstruction)(keypair.publicKey, mint, owner, programId));
        yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer, keypair], confirmOptions);
        return keypair.publicKey;
      });
    }
    exports2.createAccount = createAccount;
  }
});

// node_modules/@solana/spl-token/lib/cjs/actions/createAssociatedTokenAccountIdempotent.js
var require_createAssociatedTokenAccountIdempotent2 = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/actions/createAssociatedTokenAccountIdempotent.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createAssociatedTokenAccountIdempotent = void 0;
    var web3_js_1 = require("@solana/web3.js");
    var constants_js_1 = require_constants2();
    var associatedTokenAccount_js_1 = require_associatedTokenAccount2();
    var mint_js_1 = require_mint2();
    function createAssociatedTokenAccountIdempotent(connection, payer, mint, owner, confirmOptions, programId = constants_js_1.TOKEN_PROGRAM_ID, associatedTokenProgramId = constants_js_1.ASSOCIATED_TOKEN_PROGRAM_ID) {
      return __awaiter(this, void 0, void 0, function* () {
        const associatedToken = (0, mint_js_1.getAssociatedTokenAddressSync)(mint, owner, false, programId, associatedTokenProgramId);
        const transaction = new web3_js_1.Transaction().add((0, associatedTokenAccount_js_1.createAssociatedTokenAccountIdempotentInstruction)(payer.publicKey, associatedToken, owner, mint, programId, associatedTokenProgramId));
        yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer], confirmOptions);
        return associatedToken;
      });
    }
    exports2.createAssociatedTokenAccountIdempotent = createAssociatedTokenAccountIdempotent;
  }
});

// node_modules/@solana/spl-token/lib/cjs/instructions/initializeMint2.js
var require_initializeMint22 = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/instructions/initializeMint2.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.decodeInitializeMint2InstructionUnchecked = exports2.decodeInitializeMint2Instruction = exports2.createInitializeMint2Instruction = exports2.initializeMint2InstructionData = void 0;
    var buffer_layout_1 = require_Layout();
    var buffer_layout_utils_1 = require_cjs();
    var web3_js_1 = require("@solana/web3.js");
    var constants_js_1 = require_constants2();
    var errors_js_1 = require_errors4();
    var types_js_1 = require_types2();
    exports2.initializeMint2InstructionData = (0, buffer_layout_1.struct)([
      (0, buffer_layout_1.u8)("instruction"),
      (0, buffer_layout_1.u8)("decimals"),
      (0, buffer_layout_utils_1.publicKey)("mintAuthority"),
      (0, buffer_layout_1.u8)("freezeAuthorityOption"),
      (0, buffer_layout_utils_1.publicKey)("freezeAuthority")
    ]);
    function createInitializeMint2Instruction(mint, decimals, mintAuthority, freezeAuthority, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      const keys = [{ pubkey: mint, isSigner: false, isWritable: true }];
      const data = Buffer.alloc(exports2.initializeMint2InstructionData.span);
      exports2.initializeMint2InstructionData.encode({
        instruction: types_js_1.TokenInstruction.InitializeMint2,
        decimals,
        mintAuthority,
        freezeAuthorityOption: freezeAuthority ? 1 : 0,
        freezeAuthority: freezeAuthority || new web3_js_1.PublicKey(0)
      }, data);
      return new web3_js_1.TransactionInstruction({ keys, programId, data });
    }
    exports2.createInitializeMint2Instruction = createInitializeMint2Instruction;
    function decodeInitializeMint2Instruction(instruction, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      if (!instruction.programId.equals(programId))
        throw new errors_js_1.TokenInvalidInstructionProgramError();
      if (instruction.data.length !== exports2.initializeMint2InstructionData.span)
        throw new errors_js_1.TokenInvalidInstructionDataError();
      const { keys: { mint }, data } = decodeInitializeMint2InstructionUnchecked(instruction);
      if (data.instruction !== types_js_1.TokenInstruction.InitializeMint2)
        throw new errors_js_1.TokenInvalidInstructionTypeError();
      if (!mint)
        throw new errors_js_1.TokenInvalidInstructionKeysError();
      return {
        programId,
        keys: {
          mint
        },
        data
      };
    }
    exports2.decodeInitializeMint2Instruction = decodeInitializeMint2Instruction;
    function decodeInitializeMint2InstructionUnchecked({ programId, keys: [mint], data }) {
      const { instruction, decimals, mintAuthority, freezeAuthorityOption, freezeAuthority } = exports2.initializeMint2InstructionData.decode(data);
      return {
        programId,
        keys: {
          mint
        },
        data: {
          instruction,
          decimals,
          mintAuthority,
          freezeAuthority: freezeAuthorityOption ? freezeAuthority : null
        }
      };
    }
    exports2.decodeInitializeMint2InstructionUnchecked = decodeInitializeMint2InstructionUnchecked;
  }
});

// node_modules/@solana/spl-token/lib/cjs/actions/createMint.js
var require_createMint2 = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/actions/createMint.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createMint = void 0;
    var web3_js_1 = require("@solana/web3.js");
    var constants_js_1 = require_constants2();
    var initializeMint2_js_1 = require_initializeMint22();
    var mint_js_1 = require_mint2();
    function createMint(connection, payer, mintAuthority, freezeAuthority, decimals, keypair = web3_js_1.Keypair.generate(), confirmOptions, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      return __awaiter(this, void 0, void 0, function* () {
        const lamports = yield (0, mint_js_1.getMinimumBalanceForRentExemptMint)(connection);
        const transaction = new web3_js_1.Transaction().add(web3_js_1.SystemProgram.createAccount({
          fromPubkey: payer.publicKey,
          newAccountPubkey: keypair.publicKey,
          space: mint_js_1.MINT_SIZE,
          lamports,
          programId
        }), (0, initializeMint2_js_1.createInitializeMint2Instruction)(keypair.publicKey, decimals, mintAuthority, freezeAuthority, programId));
        yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer, keypair], confirmOptions);
        return keypair.publicKey;
      });
    }
    exports2.createMint = createMint;
  }
});

// node_modules/@solana/spl-token/lib/cjs/instructions/initializeMultisig.js
var require_initializeMultisig3 = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/instructions/initializeMultisig.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.decodeInitializeMultisigInstructionUnchecked = exports2.decodeInitializeMultisigInstruction = exports2.createInitializeMultisigInstruction = exports2.initializeMultisigInstructionData = void 0;
    var buffer_layout_1 = require_Layout();
    var web3_js_1 = require("@solana/web3.js");
    var constants_js_1 = require_constants2();
    var errors_js_1 = require_errors4();
    var types_js_1 = require_types2();
    exports2.initializeMultisigInstructionData = (0, buffer_layout_1.struct)([
      (0, buffer_layout_1.u8)("instruction"),
      (0, buffer_layout_1.u8)("m")
    ]);
    function createInitializeMultisigInstruction(account, signers, m, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      const keys = [
        { pubkey: account, isSigner: false, isWritable: true },
        { pubkey: web3_js_1.SYSVAR_RENT_PUBKEY, isSigner: false, isWritable: false }
      ];
      for (const signer of signers) {
        keys.push({
          pubkey: signer instanceof web3_js_1.PublicKey ? signer : signer.publicKey,
          isSigner: false,
          isWritable: false
        });
      }
      const data = Buffer.alloc(exports2.initializeMultisigInstructionData.span);
      exports2.initializeMultisigInstructionData.encode({
        instruction: types_js_1.TokenInstruction.InitializeMultisig,
        m
      }, data);
      return new web3_js_1.TransactionInstruction({ keys, programId, data });
    }
    exports2.createInitializeMultisigInstruction = createInitializeMultisigInstruction;
    function decodeInitializeMultisigInstruction(instruction, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      if (!instruction.programId.equals(programId))
        throw new errors_js_1.TokenInvalidInstructionProgramError();
      if (instruction.data.length !== exports2.initializeMultisigInstructionData.span)
        throw new errors_js_1.TokenInvalidInstructionDataError();
      const { keys: { account, rent, signers }, data } = decodeInitializeMultisigInstructionUnchecked(instruction);
      if (data.instruction !== types_js_1.TokenInstruction.InitializeMultisig)
        throw new errors_js_1.TokenInvalidInstructionTypeError();
      if (!account || !rent || !signers.length)
        throw new errors_js_1.TokenInvalidInstructionKeysError();
      return {
        programId,
        keys: {
          account,
          rent,
          signers
        },
        data
      };
    }
    exports2.decodeInitializeMultisigInstruction = decodeInitializeMultisigInstruction;
    function decodeInitializeMultisigInstructionUnchecked({ programId, keys: [account, rent, ...signers], data }) {
      return {
        programId,
        keys: {
          account,
          rent,
          signers
        },
        data: exports2.initializeMultisigInstructionData.decode(data)
      };
    }
    exports2.decodeInitializeMultisigInstructionUnchecked = decodeInitializeMultisigInstructionUnchecked;
  }
});

// node_modules/@solana/spl-token/lib/cjs/actions/createMultisig.js
var require_createMultisig2 = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/actions/createMultisig.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createMultisig = void 0;
    var web3_js_1 = require("@solana/web3.js");
    var constants_js_1 = require_constants2();
    var initializeMultisig_js_1 = require_initializeMultisig3();
    var multisig_js_1 = require_multisig2();
    function createMultisig(connection, payer, signers, m, keypair = web3_js_1.Keypair.generate(), confirmOptions, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      return __awaiter(this, void 0, void 0, function* () {
        const lamports = yield (0, multisig_js_1.getMinimumBalanceForRentExemptMultisig)(connection);
        const transaction = new web3_js_1.Transaction().add(web3_js_1.SystemProgram.createAccount({
          fromPubkey: payer.publicKey,
          newAccountPubkey: keypair.publicKey,
          space: multisig_js_1.MULTISIG_SIZE,
          lamports,
          programId
        }), (0, initializeMultisig_js_1.createInitializeMultisigInstruction)(keypair.publicKey, signers, m, programId));
        yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer, keypair], confirmOptions);
        return keypair.publicKey;
      });
    }
    exports2.createMultisig = createMultisig;
  }
});

// node_modules/@solana/spl-token/lib/cjs/instructions/createNativeMint.js
var require_createNativeMint3 = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/instructions/createNativeMint.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createCreateNativeMintInstruction = exports2.createNativeMintInstructionData = void 0;
    var buffer_layout_1 = require_Layout();
    var web3_js_1 = require("@solana/web3.js");
    var constants_js_1 = require_constants2();
    var errors_js_1 = require_errors4();
    var types_js_1 = require_types2();
    exports2.createNativeMintInstructionData = (0, buffer_layout_1.struct)([(0, buffer_layout_1.u8)("instruction")]);
    function createCreateNativeMintInstruction(payer, nativeMintId = constants_js_1.NATIVE_MINT_2022, programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
      if (!(0, constants_js_1.programSupportsExtensions)(programId)) {
        throw new errors_js_1.TokenUnsupportedInstructionError();
      }
      const keys = [
        { pubkey: payer, isSigner: true, isWritable: true },
        { pubkey: nativeMintId, isSigner: false, isWritable: true },
        { pubkey: web3_js_1.SystemProgram.programId, isSigner: false, isWritable: false }
      ];
      const data = Buffer.alloc(exports2.createNativeMintInstructionData.span);
      exports2.createNativeMintInstructionData.encode({ instruction: types_js_1.TokenInstruction.CreateNativeMint }, data);
      return new web3_js_1.TransactionInstruction({ keys, programId, data });
    }
    exports2.createCreateNativeMintInstruction = createCreateNativeMintInstruction;
  }
});

// node_modules/@solana/spl-token/lib/cjs/actions/createNativeMint.js
var require_createNativeMint4 = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/actions/createNativeMint.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createNativeMint = void 0;
    var web3_js_1 = require("@solana/web3.js");
    var constants_js_1 = require_constants2();
    var createNativeMint_js_1 = require_createNativeMint3();
    function createNativeMint(connection, payer, confirmOptions, nativeMint = constants_js_1.NATIVE_MINT_2022, programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
      return __awaiter(this, void 0, void 0, function* () {
        const transaction = new web3_js_1.Transaction().add((0, createNativeMint_js_1.createCreateNativeMintInstruction)(payer.publicKey, nativeMint, programId));
        yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer], confirmOptions);
      });
    }
    exports2.createNativeMint = createNativeMint;
  }
});

// node_modules/@solana/spl-token/lib/cjs/instructions/syncNative.js
var require_syncNative3 = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/instructions/syncNative.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.decodeSyncNativeInstructionUnchecked = exports2.decodeSyncNativeInstruction = exports2.createSyncNativeInstruction = exports2.syncNativeInstructionData = void 0;
    var buffer_layout_1 = require_Layout();
    var web3_js_1 = require("@solana/web3.js");
    var constants_js_1 = require_constants2();
    var errors_js_1 = require_errors4();
    var types_js_1 = require_types2();
    exports2.syncNativeInstructionData = (0, buffer_layout_1.struct)([(0, buffer_layout_1.u8)("instruction")]);
    function createSyncNativeInstruction(account, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      const keys = [{ pubkey: account, isSigner: false, isWritable: true }];
      const data = Buffer.alloc(exports2.syncNativeInstructionData.span);
      exports2.syncNativeInstructionData.encode({ instruction: types_js_1.TokenInstruction.SyncNative }, data);
      return new web3_js_1.TransactionInstruction({ keys, programId, data });
    }
    exports2.createSyncNativeInstruction = createSyncNativeInstruction;
    function decodeSyncNativeInstruction(instruction, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      if (!instruction.programId.equals(programId))
        throw new errors_js_1.TokenInvalidInstructionProgramError();
      if (instruction.data.length !== exports2.syncNativeInstructionData.span)
        throw new errors_js_1.TokenInvalidInstructionDataError();
      const { keys: { account }, data } = decodeSyncNativeInstructionUnchecked(instruction);
      if (data.instruction !== types_js_1.TokenInstruction.SyncNative)
        throw new errors_js_1.TokenInvalidInstructionTypeError();
      if (!account)
        throw new errors_js_1.TokenInvalidInstructionKeysError();
      return {
        programId,
        keys: {
          account
        },
        data
      };
    }
    exports2.decodeSyncNativeInstruction = decodeSyncNativeInstruction;
    function decodeSyncNativeInstructionUnchecked({ programId, keys: [account], data }) {
      return {
        programId,
        keys: {
          account
        },
        data: exports2.syncNativeInstructionData.decode(data)
      };
    }
    exports2.decodeSyncNativeInstructionUnchecked = decodeSyncNativeInstructionUnchecked;
  }
});

// node_modules/@solana/spl-token/lib/cjs/actions/createWrappedNativeAccount.js
var require_createWrappedNativeAccount2 = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/actions/createWrappedNativeAccount.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createWrappedNativeAccount = void 0;
    var web3_js_1 = require("@solana/web3.js");
    var constants_js_1 = require_constants2();
    var associatedTokenAccount_js_1 = require_associatedTokenAccount2();
    var initializeAccount_js_1 = require_initializeAccount4();
    var syncNative_js_1 = require_syncNative3();
    var account_js_1 = require_account2();
    var mint_js_1 = require_mint2();
    var createAccount_js_1 = require_createAccount2();
    function createWrappedNativeAccount(connection, payer, owner, amount, keypair, confirmOptions, programId = constants_js_1.TOKEN_PROGRAM_ID, nativeMint = constants_js_1.NATIVE_MINT) {
      return __awaiter(this, void 0, void 0, function* () {
        if (!amount)
          return yield (0, createAccount_js_1.createAccount)(connection, payer, nativeMint, owner, keypair, confirmOptions, programId);
        if (!keypair) {
          const associatedToken = (0, mint_js_1.getAssociatedTokenAddressSync)(nativeMint, owner, false, programId, constants_js_1.ASSOCIATED_TOKEN_PROGRAM_ID);
          const transaction2 = new web3_js_1.Transaction().add((0, associatedTokenAccount_js_1.createAssociatedTokenAccountInstruction)(payer.publicKey, associatedToken, owner, nativeMint, programId, constants_js_1.ASSOCIATED_TOKEN_PROGRAM_ID), web3_js_1.SystemProgram.transfer({
            fromPubkey: payer.publicKey,
            toPubkey: associatedToken,
            lamports: amount
          }), (0, syncNative_js_1.createSyncNativeInstruction)(associatedToken, programId));
          yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction2, [payer], confirmOptions);
          return associatedToken;
        }
        const lamports = yield (0, account_js_1.getMinimumBalanceForRentExemptAccount)(connection);
        const transaction = new web3_js_1.Transaction().add(web3_js_1.SystemProgram.createAccount({
          fromPubkey: payer.publicKey,
          newAccountPubkey: keypair.publicKey,
          space: account_js_1.ACCOUNT_SIZE,
          lamports,
          programId
        }), web3_js_1.SystemProgram.transfer({
          fromPubkey: payer.publicKey,
          toPubkey: keypair.publicKey,
          lamports: amount
        }), (0, initializeAccount_js_1.createInitializeAccountInstruction)(keypair.publicKey, nativeMint, owner, programId));
        yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer, keypair], confirmOptions);
        return keypair.publicKey;
      });
    }
    exports2.createWrappedNativeAccount = createWrappedNativeAccount;
  }
});

// node_modules/@solana/spl-token/lib/cjs/instructions/freezeAccount.js
var require_freezeAccount3 = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/instructions/freezeAccount.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.decodeFreezeAccountInstructionUnchecked = exports2.decodeFreezeAccountInstruction = exports2.createFreezeAccountInstruction = exports2.freezeAccountInstructionData = void 0;
    var buffer_layout_1 = require_Layout();
    var web3_js_1 = require("@solana/web3.js");
    var constants_js_1 = require_constants2();
    var errors_js_1 = require_errors4();
    var internal_js_1 = require_internal3();
    var types_js_1 = require_types2();
    exports2.freezeAccountInstructionData = (0, buffer_layout_1.struct)([(0, buffer_layout_1.u8)("instruction")]);
    function createFreezeAccountInstruction(account, mint, authority, multiSigners = [], programId = constants_js_1.TOKEN_PROGRAM_ID) {
      const keys = (0, internal_js_1.addSigners)([
        { pubkey: account, isSigner: false, isWritable: true },
        { pubkey: mint, isSigner: false, isWritable: false }
      ], authority, multiSigners);
      const data = Buffer.alloc(exports2.freezeAccountInstructionData.span);
      exports2.freezeAccountInstructionData.encode({ instruction: types_js_1.TokenInstruction.FreezeAccount }, data);
      return new web3_js_1.TransactionInstruction({ keys, programId, data });
    }
    exports2.createFreezeAccountInstruction = createFreezeAccountInstruction;
    function decodeFreezeAccountInstruction(instruction, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      if (!instruction.programId.equals(programId))
        throw new errors_js_1.TokenInvalidInstructionProgramError();
      if (instruction.data.length !== exports2.freezeAccountInstructionData.span)
        throw new errors_js_1.TokenInvalidInstructionDataError();
      const { keys: { account, mint, authority, multiSigners }, data } = decodeFreezeAccountInstructionUnchecked(instruction);
      if (data.instruction !== types_js_1.TokenInstruction.FreezeAccount)
        throw new errors_js_1.TokenInvalidInstructionTypeError();
      if (!account || !mint || !authority)
        throw new errors_js_1.TokenInvalidInstructionKeysError();
      return {
        programId,
        keys: {
          account,
          mint,
          authority,
          multiSigners
        },
        data
      };
    }
    exports2.decodeFreezeAccountInstruction = decodeFreezeAccountInstruction;
    function decodeFreezeAccountInstructionUnchecked({ programId, keys: [account, mint, authority, ...multiSigners], data }) {
      return {
        programId,
        keys: {
          account,
          mint,
          authority,
          multiSigners
        },
        data: exports2.freezeAccountInstructionData.decode(data)
      };
    }
    exports2.decodeFreezeAccountInstructionUnchecked = decodeFreezeAccountInstructionUnchecked;
  }
});

// node_modules/@solana/spl-token/lib/cjs/actions/freezeAccount.js
var require_freezeAccount4 = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/actions/freezeAccount.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.freezeAccount = void 0;
    var web3_js_1 = require("@solana/web3.js");
    var constants_js_1 = require_constants2();
    var freezeAccount_js_1 = require_freezeAccount3();
    var internal_js_1 = require_internal4();
    function freezeAccount(connection, payer, account, mint, authority, multiSigners = [], confirmOptions, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      return __awaiter(this, void 0, void 0, function* () {
        const [authorityPublicKey, signers] = (0, internal_js_1.getSigners)(authority, multiSigners);
        const transaction = new web3_js_1.Transaction().add((0, freezeAccount_js_1.createFreezeAccountInstruction)(account, mint, authorityPublicKey, multiSigners, programId));
        return yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer, ...signers], confirmOptions);
      });
    }
    exports2.freezeAccount = freezeAccount;
  }
});

// node_modules/@solana/spl-token/lib/cjs/actions/getOrCreateAssociatedTokenAccount.js
var require_getOrCreateAssociatedTokenAccount2 = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/actions/getOrCreateAssociatedTokenAccount.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getOrCreateAssociatedTokenAccount = void 0;
    var web3_js_1 = require("@solana/web3.js");
    var constants_js_1 = require_constants2();
    var errors_js_1 = require_errors4();
    var associatedTokenAccount_js_1 = require_associatedTokenAccount2();
    var account_js_1 = require_account2();
    var mint_js_1 = require_mint2();
    function getOrCreateAssociatedTokenAccount(connection, payer, mint, owner, allowOwnerOffCurve = false, commitment, confirmOptions, programId = constants_js_1.TOKEN_PROGRAM_ID, associatedTokenProgramId = constants_js_1.ASSOCIATED_TOKEN_PROGRAM_ID) {
      return __awaiter(this, void 0, void 0, function* () {
        const associatedToken = (0, mint_js_1.getAssociatedTokenAddressSync)(mint, owner, allowOwnerOffCurve, programId, associatedTokenProgramId);
        let account;
        try {
          account = yield (0, account_js_1.getAccount)(connection, associatedToken, commitment, programId);
        } catch (error) {
          if (error instanceof errors_js_1.TokenAccountNotFoundError || error instanceof errors_js_1.TokenInvalidAccountOwnerError) {
            try {
              const transaction = new web3_js_1.Transaction().add((0, associatedTokenAccount_js_1.createAssociatedTokenAccountInstruction)(payer.publicKey, associatedToken, owner, mint, programId, associatedTokenProgramId));
              yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer], confirmOptions);
            } catch (error2) {
            }
            account = yield (0, account_js_1.getAccount)(connection, associatedToken, commitment, programId);
          } else {
            throw error;
          }
        }
        if (!account.mint.equals(mint))
          throw new errors_js_1.TokenInvalidMintError();
        if (!account.owner.equals(owner))
          throw new errors_js_1.TokenInvalidOwnerError();
        return account;
      });
    }
    exports2.getOrCreateAssociatedTokenAccount = getOrCreateAssociatedTokenAccount;
  }
});

// node_modules/@solana/spl-token/lib/cjs/instructions/mintTo.js
var require_mintTo3 = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/instructions/mintTo.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.decodeMintToInstructionUnchecked = exports2.decodeMintToInstruction = exports2.createMintToInstruction = exports2.mintToInstructionData = void 0;
    var buffer_layout_1 = require_Layout();
    var buffer_layout_utils_1 = require_cjs();
    var web3_js_1 = require("@solana/web3.js");
    var constants_js_1 = require_constants2();
    var errors_js_1 = require_errors4();
    var internal_js_1 = require_internal3();
    var types_js_1 = require_types2();
    exports2.mintToInstructionData = (0, buffer_layout_1.struct)([(0, buffer_layout_1.u8)("instruction"), (0, buffer_layout_utils_1.u64)("amount")]);
    function createMintToInstruction(mint, destination, authority, amount, multiSigners = [], programId = constants_js_1.TOKEN_PROGRAM_ID) {
      const keys = (0, internal_js_1.addSigners)([
        { pubkey: mint, isSigner: false, isWritable: true },
        { pubkey: destination, isSigner: false, isWritable: true }
      ], authority, multiSigners);
      const data = Buffer.alloc(exports2.mintToInstructionData.span);
      exports2.mintToInstructionData.encode({
        instruction: types_js_1.TokenInstruction.MintTo,
        amount: BigInt(amount)
      }, data);
      return new web3_js_1.TransactionInstruction({ keys, programId, data });
    }
    exports2.createMintToInstruction = createMintToInstruction;
    function decodeMintToInstruction(instruction, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      if (!instruction.programId.equals(programId))
        throw new errors_js_1.TokenInvalidInstructionProgramError();
      if (instruction.data.length !== exports2.mintToInstructionData.span)
        throw new errors_js_1.TokenInvalidInstructionDataError();
      const { keys: { mint, destination, authority, multiSigners }, data } = decodeMintToInstructionUnchecked(instruction);
      if (data.instruction !== types_js_1.TokenInstruction.MintTo)
        throw new errors_js_1.TokenInvalidInstructionTypeError();
      if (!mint || !destination || !authority)
        throw new errors_js_1.TokenInvalidInstructionKeysError();
      return {
        programId,
        keys: {
          mint,
          destination,
          authority,
          multiSigners
        },
        data
      };
    }
    exports2.decodeMintToInstruction = decodeMintToInstruction;
    function decodeMintToInstructionUnchecked({ programId, keys: [mint, destination, authority, ...multiSigners], data }) {
      return {
        programId,
        keys: {
          mint,
          destination,
          authority,
          multiSigners
        },
        data: exports2.mintToInstructionData.decode(data)
      };
    }
    exports2.decodeMintToInstructionUnchecked = decodeMintToInstructionUnchecked;
  }
});

// node_modules/@solana/spl-token/lib/cjs/actions/mintTo.js
var require_mintTo4 = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/actions/mintTo.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.mintTo = void 0;
    var web3_js_1 = require("@solana/web3.js");
    var constants_js_1 = require_constants2();
    var mintTo_js_1 = require_mintTo3();
    var internal_js_1 = require_internal4();
    function mintTo(connection, payer, mint, destination, authority, amount, multiSigners = [], confirmOptions, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      return __awaiter(this, void 0, void 0, function* () {
        const [authorityPublicKey, signers] = (0, internal_js_1.getSigners)(authority, multiSigners);
        const transaction = new web3_js_1.Transaction().add((0, mintTo_js_1.createMintToInstruction)(mint, destination, authorityPublicKey, amount, multiSigners, programId));
        return yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer, ...signers], confirmOptions);
      });
    }
    exports2.mintTo = mintTo;
  }
});

// node_modules/@solana/spl-token/lib/cjs/instructions/mintToChecked.js
var require_mintToChecked3 = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/instructions/mintToChecked.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.decodeMintToCheckedInstructionUnchecked = exports2.decodeMintToCheckedInstruction = exports2.createMintToCheckedInstruction = exports2.mintToCheckedInstructionData = void 0;
    var buffer_layout_1 = require_Layout();
    var buffer_layout_utils_1 = require_cjs();
    var web3_js_1 = require("@solana/web3.js");
    var constants_js_1 = require_constants2();
    var errors_js_1 = require_errors4();
    var internal_js_1 = require_internal3();
    var types_js_1 = require_types2();
    exports2.mintToCheckedInstructionData = (0, buffer_layout_1.struct)([
      (0, buffer_layout_1.u8)("instruction"),
      (0, buffer_layout_utils_1.u64)("amount"),
      (0, buffer_layout_1.u8)("decimals")
    ]);
    function createMintToCheckedInstruction(mint, destination, authority, amount, decimals, multiSigners = [], programId = constants_js_1.TOKEN_PROGRAM_ID) {
      const keys = (0, internal_js_1.addSigners)([
        { pubkey: mint, isSigner: false, isWritable: true },
        { pubkey: destination, isSigner: false, isWritable: true }
      ], authority, multiSigners);
      const data = Buffer.alloc(exports2.mintToCheckedInstructionData.span);
      exports2.mintToCheckedInstructionData.encode({
        instruction: types_js_1.TokenInstruction.MintToChecked,
        amount: BigInt(amount),
        decimals
      }, data);
      return new web3_js_1.TransactionInstruction({ keys, programId, data });
    }
    exports2.createMintToCheckedInstruction = createMintToCheckedInstruction;
    function decodeMintToCheckedInstruction(instruction, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      if (!instruction.programId.equals(programId))
        throw new errors_js_1.TokenInvalidInstructionProgramError();
      if (instruction.data.length !== exports2.mintToCheckedInstructionData.span)
        throw new errors_js_1.TokenInvalidInstructionDataError();
      const { keys: { mint, destination, authority, multiSigners }, data } = decodeMintToCheckedInstructionUnchecked(instruction);
      if (data.instruction !== types_js_1.TokenInstruction.MintToChecked)
        throw new errors_js_1.TokenInvalidInstructionTypeError();
      if (!mint || !destination || !authority)
        throw new errors_js_1.TokenInvalidInstructionKeysError();
      return {
        programId,
        keys: {
          mint,
          destination,
          authority,
          multiSigners
        },
        data
      };
    }
    exports2.decodeMintToCheckedInstruction = decodeMintToCheckedInstruction;
    function decodeMintToCheckedInstructionUnchecked({ programId, keys: [mint, destination, authority, ...multiSigners], data }) {
      return {
        programId,
        keys: {
          mint,
          destination,
          authority,
          multiSigners
        },
        data: exports2.mintToCheckedInstructionData.decode(data)
      };
    }
    exports2.decodeMintToCheckedInstructionUnchecked = decodeMintToCheckedInstructionUnchecked;
  }
});

// node_modules/@solana/spl-token/lib/cjs/actions/mintToChecked.js
var require_mintToChecked4 = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/actions/mintToChecked.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.mintToChecked = void 0;
    var web3_js_1 = require("@solana/web3.js");
    var constants_js_1 = require_constants2();
    var mintToChecked_js_1 = require_mintToChecked3();
    var internal_js_1 = require_internal4();
    function mintToChecked(connection, payer, mint, destination, authority, amount, decimals, multiSigners = [], confirmOptions, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      return __awaiter(this, void 0, void 0, function* () {
        const [authorityPublicKey, signers] = (0, internal_js_1.getSigners)(authority, multiSigners);
        const transaction = new web3_js_1.Transaction().add((0, mintToChecked_js_1.createMintToCheckedInstruction)(mint, destination, authorityPublicKey, amount, decimals, multiSigners, programId));
        return yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer, ...signers], confirmOptions);
      });
    }
    exports2.mintToChecked = mintToChecked;
  }
});

// node_modules/@solana/spl-token/lib/cjs/actions/recoverNested.js
var require_recoverNested2 = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/actions/recoverNested.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.recoverNested = void 0;
    var web3_js_1 = require("@solana/web3.js");
    var constants_js_1 = require_constants2();
    var associatedTokenAccount_js_1 = require_associatedTokenAccount2();
    var mint_js_1 = require_mint2();
    function recoverNested(connection, payer, owner, mint, nestedMint, confirmOptions, programId = constants_js_1.TOKEN_PROGRAM_ID, associatedTokenProgramId = constants_js_1.ASSOCIATED_TOKEN_PROGRAM_ID) {
      return __awaiter(this, void 0, void 0, function* () {
        const ownerAssociatedToken = (0, mint_js_1.getAssociatedTokenAddressSync)(mint, owner.publicKey, false, programId, associatedTokenProgramId);
        const destinationAssociatedToken = (0, mint_js_1.getAssociatedTokenAddressSync)(nestedMint, owner.publicKey, false, programId, associatedTokenProgramId);
        const nestedAssociatedToken = (0, mint_js_1.getAssociatedTokenAddressSync)(nestedMint, ownerAssociatedToken, true, programId, associatedTokenProgramId);
        const transaction = new web3_js_1.Transaction().add((0, associatedTokenAccount_js_1.createRecoverNestedInstruction)(nestedAssociatedToken, nestedMint, destinationAssociatedToken, ownerAssociatedToken, mint, owner.publicKey, programId, associatedTokenProgramId));
        return yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer, owner], confirmOptions);
      });
    }
    exports2.recoverNested = recoverNested;
  }
});

// node_modules/@solana/spl-token/lib/cjs/instructions/revoke.js
var require_revoke3 = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/instructions/revoke.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.decodeRevokeInstructionUnchecked = exports2.decodeRevokeInstruction = exports2.createRevokeInstruction = exports2.revokeInstructionData = void 0;
    var buffer_layout_1 = require_Layout();
    var web3_js_1 = require("@solana/web3.js");
    var constants_js_1 = require_constants2();
    var errors_js_1 = require_errors4();
    var internal_js_1 = require_internal3();
    var types_js_1 = require_types2();
    exports2.revokeInstructionData = (0, buffer_layout_1.struct)([(0, buffer_layout_1.u8)("instruction")]);
    function createRevokeInstruction(account, owner, multiSigners = [], programId = constants_js_1.TOKEN_PROGRAM_ID) {
      const keys = (0, internal_js_1.addSigners)([{ pubkey: account, isSigner: false, isWritable: true }], owner, multiSigners);
      const data = Buffer.alloc(exports2.revokeInstructionData.span);
      exports2.revokeInstructionData.encode({ instruction: types_js_1.TokenInstruction.Revoke }, data);
      return new web3_js_1.TransactionInstruction({ keys, programId, data });
    }
    exports2.createRevokeInstruction = createRevokeInstruction;
    function decodeRevokeInstruction(instruction, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      if (!instruction.programId.equals(programId))
        throw new errors_js_1.TokenInvalidInstructionProgramError();
      if (instruction.data.length !== exports2.revokeInstructionData.span)
        throw new errors_js_1.TokenInvalidInstructionDataError();
      const { keys: { account, owner, multiSigners }, data } = decodeRevokeInstructionUnchecked(instruction);
      if (data.instruction !== types_js_1.TokenInstruction.Revoke)
        throw new errors_js_1.TokenInvalidInstructionTypeError();
      if (!account || !owner)
        throw new errors_js_1.TokenInvalidInstructionKeysError();
      return {
        programId,
        keys: {
          account,
          owner,
          multiSigners
        },
        data
      };
    }
    exports2.decodeRevokeInstruction = decodeRevokeInstruction;
    function decodeRevokeInstructionUnchecked({ programId, keys: [account, owner, ...multiSigners], data }) {
      return {
        programId,
        keys: {
          account,
          owner,
          multiSigners
        },
        data: exports2.revokeInstructionData.decode(data)
      };
    }
    exports2.decodeRevokeInstructionUnchecked = decodeRevokeInstructionUnchecked;
  }
});

// node_modules/@solana/spl-token/lib/cjs/actions/revoke.js
var require_revoke4 = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/actions/revoke.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.revoke = void 0;
    var web3_js_1 = require("@solana/web3.js");
    var constants_js_1 = require_constants2();
    var revoke_js_1 = require_revoke3();
    var internal_js_1 = require_internal4();
    function revoke(connection, payer, account, owner, multiSigners = [], confirmOptions, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      return __awaiter(this, void 0, void 0, function* () {
        const [ownerPublicKey, signers] = (0, internal_js_1.getSigners)(owner, multiSigners);
        const transaction = new web3_js_1.Transaction().add((0, revoke_js_1.createRevokeInstruction)(account, ownerPublicKey, multiSigners, programId));
        return yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer, ...signers], confirmOptions);
      });
    }
    exports2.revoke = revoke;
  }
});

// node_modules/@solana/spl-token/lib/cjs/instructions/setAuthority.js
var require_setAuthority3 = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/instructions/setAuthority.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.decodeSetAuthorityInstructionUnchecked = exports2.decodeSetAuthorityInstruction = exports2.createSetAuthorityInstruction = exports2.setAuthorityInstructionData = exports2.AuthorityType = void 0;
    var buffer_layout_1 = require_Layout();
    var buffer_layout_utils_1 = require_cjs();
    var web3_js_1 = require("@solana/web3.js");
    var constants_js_1 = require_constants2();
    var errors_js_1 = require_errors4();
    var internal_js_1 = require_internal3();
    var types_js_1 = require_types2();
    var AuthorityType;
    (function(AuthorityType2) {
      AuthorityType2[AuthorityType2["MintTokens"] = 0] = "MintTokens";
      AuthorityType2[AuthorityType2["FreezeAccount"] = 1] = "FreezeAccount";
      AuthorityType2[AuthorityType2["AccountOwner"] = 2] = "AccountOwner";
      AuthorityType2[AuthorityType2["CloseAccount"] = 3] = "CloseAccount";
      AuthorityType2[AuthorityType2["TransferFeeConfig"] = 4] = "TransferFeeConfig";
      AuthorityType2[AuthorityType2["WithheldWithdraw"] = 5] = "WithheldWithdraw";
      AuthorityType2[AuthorityType2["CloseMint"] = 6] = "CloseMint";
      AuthorityType2[AuthorityType2["InterestRate"] = 7] = "InterestRate";
      AuthorityType2[AuthorityType2["PermanentDelegate"] = 8] = "PermanentDelegate";
      AuthorityType2[AuthorityType2["ConfidentialTransferMint"] = 9] = "ConfidentialTransferMint";
      AuthorityType2[AuthorityType2["TransferHookProgramId"] = 10] = "TransferHookProgramId";
      AuthorityType2[AuthorityType2["ConfidentialTransferFeeConfig"] = 11] = "ConfidentialTransferFeeConfig";
      AuthorityType2[AuthorityType2["MetadataPointer"] = 12] = "MetadataPointer";
    })(AuthorityType || (exports2.AuthorityType = AuthorityType = {}));
    exports2.setAuthorityInstructionData = (0, buffer_layout_1.struct)([
      (0, buffer_layout_1.u8)("instruction"),
      (0, buffer_layout_1.u8)("authorityType"),
      (0, buffer_layout_1.u8)("newAuthorityOption"),
      (0, buffer_layout_utils_1.publicKey)("newAuthority")
    ]);
    function createSetAuthorityInstruction(account, currentAuthority, authorityType, newAuthority, multiSigners = [], programId = constants_js_1.TOKEN_PROGRAM_ID) {
      const keys = (0, internal_js_1.addSigners)([{ pubkey: account, isSigner: false, isWritable: true }], currentAuthority, multiSigners);
      const data = Buffer.alloc(exports2.setAuthorityInstructionData.span);
      exports2.setAuthorityInstructionData.encode({
        instruction: types_js_1.TokenInstruction.SetAuthority,
        authorityType,
        newAuthorityOption: newAuthority ? 1 : 0,
        newAuthority: newAuthority || new web3_js_1.PublicKey(0)
      }, data);
      return new web3_js_1.TransactionInstruction({ keys, programId, data });
    }
    exports2.createSetAuthorityInstruction = createSetAuthorityInstruction;
    function decodeSetAuthorityInstruction(instruction, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      if (!instruction.programId.equals(programId))
        throw new errors_js_1.TokenInvalidInstructionProgramError();
      if (instruction.data.length !== exports2.setAuthorityInstructionData.span)
        throw new errors_js_1.TokenInvalidInstructionDataError();
      const { keys: { account, currentAuthority, multiSigners }, data } = decodeSetAuthorityInstructionUnchecked(instruction);
      if (data.instruction !== types_js_1.TokenInstruction.SetAuthority)
        throw new errors_js_1.TokenInvalidInstructionTypeError();
      if (!account || !currentAuthority)
        throw new errors_js_1.TokenInvalidInstructionKeysError();
      return {
        programId,
        keys: {
          account,
          currentAuthority,
          multiSigners
        },
        data
      };
    }
    exports2.decodeSetAuthorityInstruction = decodeSetAuthorityInstruction;
    function decodeSetAuthorityInstructionUnchecked({ programId, keys: [account, currentAuthority, ...multiSigners], data }) {
      const { instruction, authorityType, newAuthorityOption, newAuthority } = exports2.setAuthorityInstructionData.decode(data);
      return {
        programId,
        keys: {
          account,
          currentAuthority,
          multiSigners
        },
        data: {
          instruction,
          authorityType,
          newAuthority: newAuthorityOption ? newAuthority : null
        }
      };
    }
    exports2.decodeSetAuthorityInstructionUnchecked = decodeSetAuthorityInstructionUnchecked;
  }
});

// node_modules/@solana/spl-token/lib/cjs/actions/setAuthority.js
var require_setAuthority4 = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/actions/setAuthority.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.setAuthority = void 0;
    var web3_js_1 = require("@solana/web3.js");
    var constants_js_1 = require_constants2();
    var setAuthority_js_1 = require_setAuthority3();
    var internal_js_1 = require_internal4();
    function setAuthority(connection, payer, account, currentAuthority, authorityType, newAuthority, multiSigners = [], confirmOptions, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      return __awaiter(this, void 0, void 0, function* () {
        const [currentAuthorityPublicKey, signers] = (0, internal_js_1.getSigners)(currentAuthority, multiSigners);
        const transaction = new web3_js_1.Transaction().add((0, setAuthority_js_1.createSetAuthorityInstruction)(account, currentAuthorityPublicKey, authorityType, newAuthority, multiSigners, programId));
        return yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer, ...signers], confirmOptions);
      });
    }
    exports2.setAuthority = setAuthority;
  }
});

// node_modules/@solana/spl-token/lib/cjs/actions/syncNative.js
var require_syncNative4 = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/actions/syncNative.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.syncNative = void 0;
    var web3_js_1 = require("@solana/web3.js");
    var constants_js_1 = require_constants2();
    var syncNative_js_1 = require_syncNative3();
    function syncNative(connection, payer, account, confirmOptions, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      return __awaiter(this, void 0, void 0, function* () {
        const transaction = new web3_js_1.Transaction().add((0, syncNative_js_1.createSyncNativeInstruction)(account, programId));
        return yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer], confirmOptions);
      });
    }
    exports2.syncNative = syncNative;
  }
});

// node_modules/@solana/spl-token/lib/cjs/instructions/thawAccount.js
var require_thawAccount3 = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/instructions/thawAccount.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.decodeThawAccountInstructionUnchecked = exports2.decodeThawAccountInstruction = exports2.createThawAccountInstruction = exports2.thawAccountInstructionData = void 0;
    var buffer_layout_1 = require_Layout();
    var web3_js_1 = require("@solana/web3.js");
    var constants_js_1 = require_constants2();
    var errors_js_1 = require_errors4();
    var internal_js_1 = require_internal3();
    var types_js_1 = require_types2();
    exports2.thawAccountInstructionData = (0, buffer_layout_1.struct)([(0, buffer_layout_1.u8)("instruction")]);
    function createThawAccountInstruction(account, mint, authority, multiSigners = [], programId = constants_js_1.TOKEN_PROGRAM_ID) {
      const keys = (0, internal_js_1.addSigners)([
        { pubkey: account, isSigner: false, isWritable: true },
        { pubkey: mint, isSigner: false, isWritable: false }
      ], authority, multiSigners);
      const data = Buffer.alloc(exports2.thawAccountInstructionData.span);
      exports2.thawAccountInstructionData.encode({ instruction: types_js_1.TokenInstruction.ThawAccount }, data);
      return new web3_js_1.TransactionInstruction({ keys, programId, data });
    }
    exports2.createThawAccountInstruction = createThawAccountInstruction;
    function decodeThawAccountInstruction(instruction, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      if (!instruction.programId.equals(programId))
        throw new errors_js_1.TokenInvalidInstructionProgramError();
      if (instruction.data.length !== exports2.thawAccountInstructionData.span)
        throw new errors_js_1.TokenInvalidInstructionDataError();
      const { keys: { account, mint, authority, multiSigners }, data } = decodeThawAccountInstructionUnchecked(instruction);
      if (data.instruction !== types_js_1.TokenInstruction.ThawAccount)
        throw new errors_js_1.TokenInvalidInstructionTypeError();
      if (!account || !mint || !authority)
        throw new errors_js_1.TokenInvalidInstructionKeysError();
      return {
        programId,
        keys: {
          account,
          mint,
          authority,
          multiSigners
        },
        data
      };
    }
    exports2.decodeThawAccountInstruction = decodeThawAccountInstruction;
    function decodeThawAccountInstructionUnchecked({ programId, keys: [account, mint, authority, ...multiSigners], data }) {
      return {
        programId,
        keys: {
          account,
          mint,
          authority,
          multiSigners
        },
        data: exports2.thawAccountInstructionData.decode(data)
      };
    }
    exports2.decodeThawAccountInstructionUnchecked = decodeThawAccountInstructionUnchecked;
  }
});

// node_modules/@solana/spl-token/lib/cjs/actions/thawAccount.js
var require_thawAccount4 = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/actions/thawAccount.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.thawAccount = void 0;
    var web3_js_1 = require("@solana/web3.js");
    var constants_js_1 = require_constants2();
    var thawAccount_js_1 = require_thawAccount3();
    var internal_js_1 = require_internal4();
    function thawAccount(connection, payer, account, mint, authority, multiSigners = [], confirmOptions, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      return __awaiter(this, void 0, void 0, function* () {
        const [authorityPublicKey, signers] = (0, internal_js_1.getSigners)(authority, multiSigners);
        const transaction = new web3_js_1.Transaction().add((0, thawAccount_js_1.createThawAccountInstruction)(account, mint, authorityPublicKey, multiSigners, programId));
        return yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer, ...signers], confirmOptions);
      });
    }
    exports2.thawAccount = thawAccount;
  }
});

// node_modules/@solana/spl-token/lib/cjs/instructions/transfer.js
var require_transfer3 = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/instructions/transfer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.decodeTransferInstructionUnchecked = exports2.decodeTransferInstruction = exports2.createTransferInstruction = exports2.transferInstructionData = void 0;
    var buffer_layout_1 = require_Layout();
    var buffer_layout_utils_1 = require_cjs();
    var web3_js_1 = require("@solana/web3.js");
    var constants_js_1 = require_constants2();
    var errors_js_1 = require_errors4();
    var internal_js_1 = require_internal3();
    var types_js_1 = require_types2();
    exports2.transferInstructionData = (0, buffer_layout_1.struct)([(0, buffer_layout_1.u8)("instruction"), (0, buffer_layout_utils_1.u64)("amount")]);
    function createTransferInstruction(source, destination, owner, amount, multiSigners = [], programId = constants_js_1.TOKEN_PROGRAM_ID) {
      const keys = (0, internal_js_1.addSigners)([
        { pubkey: source, isSigner: false, isWritable: true },
        { pubkey: destination, isSigner: false, isWritable: true }
      ], owner, multiSigners);
      const data = Buffer.alloc(exports2.transferInstructionData.span);
      exports2.transferInstructionData.encode({
        instruction: types_js_1.TokenInstruction.Transfer,
        amount: BigInt(amount)
      }, data);
      return new web3_js_1.TransactionInstruction({ keys, programId, data });
    }
    exports2.createTransferInstruction = createTransferInstruction;
    function decodeTransferInstruction(instruction, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      if (!instruction.programId.equals(programId))
        throw new errors_js_1.TokenInvalidInstructionProgramError();
      if (instruction.data.length !== exports2.transferInstructionData.span)
        throw new errors_js_1.TokenInvalidInstructionDataError();
      const { keys: { source, destination, owner, multiSigners }, data } = decodeTransferInstructionUnchecked(instruction);
      if (data.instruction !== types_js_1.TokenInstruction.Transfer)
        throw new errors_js_1.TokenInvalidInstructionTypeError();
      if (!source || !destination || !owner)
        throw new errors_js_1.TokenInvalidInstructionKeysError();
      return {
        programId,
        keys: {
          source,
          destination,
          owner,
          multiSigners
        },
        data
      };
    }
    exports2.decodeTransferInstruction = decodeTransferInstruction;
    function decodeTransferInstructionUnchecked({ programId, keys: [source, destination, owner, ...multiSigners], data }) {
      return {
        programId,
        keys: {
          source,
          destination,
          owner,
          multiSigners
        },
        data: exports2.transferInstructionData.decode(data)
      };
    }
    exports2.decodeTransferInstructionUnchecked = decodeTransferInstructionUnchecked;
  }
});

// node_modules/@solana/spl-token/lib/cjs/actions/transfer.js
var require_transfer4 = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/actions/transfer.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.transfer = void 0;
    var web3_js_1 = require("@solana/web3.js");
    var constants_js_1 = require_constants2();
    var transfer_js_1 = require_transfer3();
    var internal_js_1 = require_internal4();
    function transfer(connection, payer, source, destination, owner, amount, multiSigners = [], confirmOptions, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      return __awaiter(this, void 0, void 0, function* () {
        const [ownerPublicKey, signers] = (0, internal_js_1.getSigners)(owner, multiSigners);
        const transaction = new web3_js_1.Transaction().add((0, transfer_js_1.createTransferInstruction)(source, destination, ownerPublicKey, amount, multiSigners, programId));
        return yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer, ...signers], confirmOptions);
      });
    }
    exports2.transfer = transfer;
  }
});

// node_modules/@solana/spl-token/lib/cjs/actions/transferChecked.js
var require_transferChecked4 = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/actions/transferChecked.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.transferChecked = void 0;
    var web3_js_1 = require("@solana/web3.js");
    var constants_js_1 = require_constants2();
    var transferChecked_js_1 = require_transferChecked3();
    var internal_js_1 = require_internal4();
    function transferChecked(connection, payer, source, mint, destination, owner, amount, decimals, multiSigners = [], confirmOptions, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      return __awaiter(this, void 0, void 0, function* () {
        const [ownerPublicKey, signers] = (0, internal_js_1.getSigners)(owner, multiSigners);
        const transaction = new web3_js_1.Transaction().add((0, transferChecked_js_1.createTransferCheckedInstruction)(source, mint, destination, ownerPublicKey, amount, decimals, multiSigners, programId));
        return yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer, ...signers], confirmOptions);
      });
    }
    exports2.transferChecked = transferChecked;
  }
});

// node_modules/@solana/spl-token/lib/cjs/instructions/uiAmountToAmount.js
var require_uiAmountToAmount3 = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/instructions/uiAmountToAmount.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.decodeUiAmountToAmountInstructionUnchecked = exports2.decodeUiAmountToAmountInstruction = exports2.createUiAmountToAmountInstruction = void 0;
    var buffer_layout_1 = require_Layout();
    var web3_js_1 = require("@solana/web3.js");
    var constants_js_1 = require_constants2();
    var errors_js_1 = require_errors4();
    var types_js_1 = require_types2();
    function createUiAmountToAmountInstruction(mint, amount, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      const keys = [{ pubkey: mint, isSigner: false, isWritable: false }];
      const buf = Buffer.from(amount, "utf8");
      const uiAmountToAmountInstructionData = (0, buffer_layout_1.struct)([
        (0, buffer_layout_1.u8)("instruction"),
        (0, buffer_layout_1.blob)(buf.length, "amount")
      ]);
      const data = Buffer.alloc(uiAmountToAmountInstructionData.span);
      uiAmountToAmountInstructionData.encode({
        instruction: types_js_1.TokenInstruction.UiAmountToAmount,
        amount: buf
      }, data);
      return new web3_js_1.TransactionInstruction({ keys, programId, data });
    }
    exports2.createUiAmountToAmountInstruction = createUiAmountToAmountInstruction;
    function decodeUiAmountToAmountInstruction(instruction, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      if (!instruction.programId.equals(programId))
        throw new errors_js_1.TokenInvalidInstructionProgramError();
      const uiAmountToAmountInstructionData = (0, buffer_layout_1.struct)([
        (0, buffer_layout_1.u8)("instruction"),
        (0, buffer_layout_1.blob)(instruction.data.length - 1, "amount")
      ]);
      if (instruction.data.length !== uiAmountToAmountInstructionData.span)
        throw new errors_js_1.TokenInvalidInstructionDataError();
      const { keys: { mint }, data } = decodeUiAmountToAmountInstructionUnchecked(instruction);
      if (data.instruction !== types_js_1.TokenInstruction.UiAmountToAmount)
        throw new errors_js_1.TokenInvalidInstructionTypeError();
      if (!mint)
        throw new errors_js_1.TokenInvalidInstructionKeysError();
      return {
        programId,
        keys: {
          mint
        },
        data
      };
    }
    exports2.decodeUiAmountToAmountInstruction = decodeUiAmountToAmountInstruction;
    function decodeUiAmountToAmountInstructionUnchecked({ programId, keys: [mint], data }) {
      const uiAmountToAmountInstructionData = (0, buffer_layout_1.struct)([
        (0, buffer_layout_1.u8)("instruction"),
        (0, buffer_layout_1.blob)(data.length - 1, "amount")
      ]);
      return {
        programId,
        keys: {
          mint
        },
        data: uiAmountToAmountInstructionData.decode(data)
      };
    }
    exports2.decodeUiAmountToAmountInstructionUnchecked = decodeUiAmountToAmountInstructionUnchecked;
  }
});

// node_modules/@solana/spl-token/lib/cjs/actions/uiAmountToAmount.js
var require_uiAmountToAmount4 = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/actions/uiAmountToAmount.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.uiAmountToAmount = void 0;
    var buffer_layout_utils_1 = require_cjs();
    var web3_js_1 = require("@solana/web3.js");
    var constants_js_1 = require_constants2();
    var uiAmountToAmount_js_1 = require_uiAmountToAmount3();
    function uiAmountToAmount(connection, payer, mint, amount, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      return __awaiter(this, void 0, void 0, function* () {
        const transaction = new web3_js_1.Transaction().add((0, uiAmountToAmount_js_1.createUiAmountToAmountInstruction)(mint, amount, programId));
        const { returnData, err } = (yield connection.simulateTransaction(transaction, [payer], false)).value;
        if (returnData) {
          const data = Buffer.from(returnData.data[0], returnData.data[1]);
          return (0, buffer_layout_utils_1.u64)().decode(data);
        }
        return err;
      });
    }
    exports2.uiAmountToAmount = uiAmountToAmount;
  }
});

// node_modules/@solana/spl-token/lib/cjs/actions/index.js
var require_actions17 = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/actions/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_amountToUiAmount4(), exports2);
    __exportStar(require_approve4(), exports2);
    __exportStar(require_approveChecked4(), exports2);
    __exportStar(require_burn4(), exports2);
    __exportStar(require_burnChecked4(), exports2);
    __exportStar(require_closeAccount4(), exports2);
    __exportStar(require_createAccount2(), exports2);
    __exportStar(require_createAssociatedTokenAccount2(), exports2);
    __exportStar(require_createAssociatedTokenAccountIdempotent2(), exports2);
    __exportStar(require_createMint2(), exports2);
    __exportStar(require_createMultisig2(), exports2);
    __exportStar(require_createNativeMint4(), exports2);
    __exportStar(require_createWrappedNativeAccount2(), exports2);
    __exportStar(require_freezeAccount4(), exports2);
    __exportStar(require_getOrCreateAssociatedTokenAccount2(), exports2);
    __exportStar(require_mintTo4(), exports2);
    __exportStar(require_mintToChecked4(), exports2);
    __exportStar(require_recoverNested2(), exports2);
    __exportStar(require_revoke4(), exports2);
    __exportStar(require_setAuthority4(), exports2);
    __exportStar(require_syncNative4(), exports2);
    __exportStar(require_thawAccount4(), exports2);
    __exportStar(require_transfer4(), exports2);
    __exportStar(require_transferChecked4(), exports2);
    __exportStar(require_uiAmountToAmount4(), exports2);
  }
});

// node_modules/@solana/spl-token/lib/cjs/instructions/initializeMint.js
var require_initializeMint3 = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/instructions/initializeMint.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.decodeInitializeMintInstructionUnchecked = exports2.decodeInitializeMintInstruction = exports2.createInitializeMintInstruction = exports2.initializeMintInstructionData = void 0;
    var buffer_layout_1 = require_Layout();
    var buffer_layout_utils_1 = require_cjs();
    var web3_js_1 = require("@solana/web3.js");
    var constants_js_1 = require_constants2();
    var errors_js_1 = require_errors4();
    var types_js_1 = require_types2();
    exports2.initializeMintInstructionData = (0, buffer_layout_1.struct)([
      (0, buffer_layout_1.u8)("instruction"),
      (0, buffer_layout_1.u8)("decimals"),
      (0, buffer_layout_utils_1.publicKey)("mintAuthority"),
      (0, buffer_layout_1.u8)("freezeAuthorityOption"),
      (0, buffer_layout_utils_1.publicKey)("freezeAuthority")
    ]);
    function createInitializeMintInstruction(mint, decimals, mintAuthority, freezeAuthority, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      const keys = [
        { pubkey: mint, isSigner: false, isWritable: true },
        { pubkey: web3_js_1.SYSVAR_RENT_PUBKEY, isSigner: false, isWritable: false }
      ];
      const data = Buffer.alloc(exports2.initializeMintInstructionData.span);
      exports2.initializeMintInstructionData.encode({
        instruction: types_js_1.TokenInstruction.InitializeMint,
        decimals,
        mintAuthority,
        freezeAuthorityOption: freezeAuthority ? 1 : 0,
        freezeAuthority: freezeAuthority || new web3_js_1.PublicKey(0)
      }, data);
      return new web3_js_1.TransactionInstruction({ keys, programId, data });
    }
    exports2.createInitializeMintInstruction = createInitializeMintInstruction;
    function decodeInitializeMintInstruction(instruction, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      if (!instruction.programId.equals(programId))
        throw new errors_js_1.TokenInvalidInstructionProgramError();
      if (instruction.data.length !== exports2.initializeMintInstructionData.span)
        throw new errors_js_1.TokenInvalidInstructionDataError();
      const { keys: { mint, rent }, data } = decodeInitializeMintInstructionUnchecked(instruction);
      if (data.instruction !== types_js_1.TokenInstruction.InitializeMint)
        throw new errors_js_1.TokenInvalidInstructionTypeError();
      if (!mint || !rent)
        throw new errors_js_1.TokenInvalidInstructionKeysError();
      return {
        programId,
        keys: {
          mint,
          rent
        },
        data
      };
    }
    exports2.decodeInitializeMintInstruction = decodeInitializeMintInstruction;
    function decodeInitializeMintInstructionUnchecked({ programId, keys: [mint, rent], data }) {
      const { instruction, decimals, mintAuthority, freezeAuthorityOption, freezeAuthority } = exports2.initializeMintInstructionData.decode(data);
      return {
        programId,
        keys: {
          mint,
          rent
        },
        data: {
          instruction,
          decimals,
          mintAuthority,
          freezeAuthority: freezeAuthorityOption ? freezeAuthority : null
        }
      };
    }
    exports2.decodeInitializeMintInstructionUnchecked = decodeInitializeMintInstructionUnchecked;
  }
});

// node_modules/@solana/spl-token/lib/cjs/extensions/interestBearingMint/instructions.js
var require_instructions18 = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/extensions/interestBearingMint/instructions.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createUpdateRateInterestBearingMintInstruction = exports2.createInitializeInterestBearingMintInstruction = exports2.interestBearingMintUpdateRateInstructionData = exports2.interestBearingMintInitializeInstructionData = exports2.InterestBearingMintInstruction = void 0;
    var buffer_layout_1 = require_Layout();
    var buffer_layout_utils_1 = require_cjs();
    var web3_js_1 = require("@solana/web3.js");
    var constants_js_1 = require_constants2();
    var internal_js_1 = require_internal3();
    var types_js_1 = require_types2();
    var InterestBearingMintInstruction;
    (function(InterestBearingMintInstruction2) {
      InterestBearingMintInstruction2[InterestBearingMintInstruction2["Initialize"] = 0] = "Initialize";
      InterestBearingMintInstruction2[InterestBearingMintInstruction2["UpdateRate"] = 1] = "UpdateRate";
    })(InterestBearingMintInstruction || (exports2.InterestBearingMintInstruction = InterestBearingMintInstruction = {}));
    exports2.interestBearingMintInitializeInstructionData = (0, buffer_layout_1.struct)([
      (0, buffer_layout_1.u8)("instruction"),
      (0, buffer_layout_1.u8)("interestBearingMintInstruction"),
      // TODO: Make this an optional public key
      (0, buffer_layout_utils_1.publicKey)("rateAuthority"),
      (0, buffer_layout_1.s16)("rate")
    ]);
    exports2.interestBearingMintUpdateRateInstructionData = (0, buffer_layout_1.struct)([
      (0, buffer_layout_1.u8)("instruction"),
      (0, buffer_layout_1.u8)("interestBearingMintInstruction"),
      (0, buffer_layout_1.s16)("rate")
    ]);
    function createInitializeInterestBearingMintInstruction(mint, rateAuthority, rate, programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
      const keys = [{ pubkey: mint, isSigner: false, isWritable: true }];
      const data = Buffer.alloc(exports2.interestBearingMintInitializeInstructionData.span);
      exports2.interestBearingMintInitializeInstructionData.encode({
        instruction: types_js_1.TokenInstruction.InterestBearingMintExtension,
        interestBearingMintInstruction: InterestBearingMintInstruction.Initialize,
        rateAuthority,
        rate
      }, data);
      return new web3_js_1.TransactionInstruction({ keys, programId, data });
    }
    exports2.createInitializeInterestBearingMintInstruction = createInitializeInterestBearingMintInstruction;
    function createUpdateRateInterestBearingMintInstruction(mint, rateAuthority, rate, multiSigners = [], programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
      const keys = (0, internal_js_1.addSigners)([
        { pubkey: mint, isSigner: false, isWritable: true },
        { pubkey: rateAuthority, isSigner: !multiSigners.length, isWritable: false }
      ], rateAuthority, multiSigners);
      const data = Buffer.alloc(exports2.interestBearingMintUpdateRateInstructionData.span);
      exports2.interestBearingMintUpdateRateInstructionData.encode({
        instruction: types_js_1.TokenInstruction.InterestBearingMintExtension,
        interestBearingMintInstruction: InterestBearingMintInstruction.UpdateRate,
        rate
      }, data);
      return new web3_js_1.TransactionInstruction({ keys, programId, data });
    }
    exports2.createUpdateRateInterestBearingMintInstruction = createUpdateRateInterestBearingMintInstruction;
  }
});

// node_modules/@solana/spl-token/lib/cjs/extensions/interestBearingMint/actions.js
var require_actions18 = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/extensions/interestBearingMint/actions.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.updateRateInterestBearingMint = exports2.createInterestBearingMint = void 0;
    var web3_js_1 = require("@solana/web3.js");
    var internal_js_1 = require_internal4();
    var constants_js_1 = require_constants2();
    var initializeMint_js_1 = require_initializeMint3();
    var extensionType_js_1 = require_extensionType2();
    var instructions_js_1 = require_instructions18();
    function createInterestBearingMint(connection, payer, mintAuthority, freezeAuthority, rateAuthority, rate, decimals, keypair = web3_js_1.Keypair.generate(), confirmOptions, programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
      return __awaiter(this, void 0, void 0, function* () {
        const mintLen = (0, extensionType_js_1.getMintLen)([extensionType_js_1.ExtensionType.InterestBearingConfig]);
        const lamports = yield connection.getMinimumBalanceForRentExemption(mintLen);
        const transaction = new web3_js_1.Transaction().add(web3_js_1.SystemProgram.createAccount({
          fromPubkey: payer.publicKey,
          newAccountPubkey: keypair.publicKey,
          space: mintLen,
          lamports,
          programId
        }), (0, instructions_js_1.createInitializeInterestBearingMintInstruction)(keypair.publicKey, rateAuthority, rate, programId), (0, initializeMint_js_1.createInitializeMintInstruction)(keypair.publicKey, decimals, mintAuthority, freezeAuthority, programId));
        yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer, keypair], confirmOptions);
        return keypair.publicKey;
      });
    }
    exports2.createInterestBearingMint = createInterestBearingMint;
    function updateRateInterestBearingMint(connection, payer, mint, rateAuthority, rate, multiSigners = [], confirmOptions, programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
      return __awaiter(this, void 0, void 0, function* () {
        const [rateAuthorityPublicKey, signers] = (0, internal_js_1.getSigners)(rateAuthority, multiSigners);
        const transaction = new web3_js_1.Transaction().add((0, instructions_js_1.createUpdateRateInterestBearingMintInstruction)(mint, rateAuthorityPublicKey, rate, signers, programId));
        return yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer, rateAuthority, ...signers], confirmOptions);
      });
    }
    exports2.updateRateInterestBearingMint = updateRateInterestBearingMint;
  }
});

// node_modules/@solana/spl-token/lib/cjs/extensions/interestBearingMint/index.js
var require_interestBearingMint2 = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/extensions/interestBearingMint/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_actions18(), exports2);
    __exportStar(require_instructions18(), exports2);
    __exportStar(require_state20(), exports2);
  }
});

// node_modules/@solana/spl-token/lib/cjs/extensions/metadataPointer/instructions.js
var require_instructions19 = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/extensions/metadataPointer/instructions.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createUpdateMetadataPointerInstruction = exports2.updateMetadataPointerData = exports2.createInitializeMetadataPointerInstruction = exports2.initializeMetadataPointerData = exports2.MetadataPointerInstruction = void 0;
    var buffer_layout_1 = require_Layout();
    var buffer_layout_utils_1 = require_cjs();
    var web3_js_1 = require("@solana/web3.js");
    var constants_js_1 = require_constants2();
    var errors_js_1 = require_errors4();
    var types_js_1 = require_types2();
    var internal_js_1 = require_internal3();
    var MetadataPointerInstruction;
    (function(MetadataPointerInstruction2) {
      MetadataPointerInstruction2[MetadataPointerInstruction2["Initialize"] = 0] = "Initialize";
      MetadataPointerInstruction2[MetadataPointerInstruction2["Update"] = 1] = "Update";
    })(MetadataPointerInstruction || (exports2.MetadataPointerInstruction = MetadataPointerInstruction = {}));
    exports2.initializeMetadataPointerData = (0, buffer_layout_1.struct)([
      // prettier-ignore
      (0, buffer_layout_1.u8)("instruction"),
      (0, buffer_layout_1.u8)("metadataPointerInstruction"),
      (0, buffer_layout_utils_1.publicKey)("authority"),
      (0, buffer_layout_utils_1.publicKey)("metadataAddress")
    ]);
    function createInitializeMetadataPointerInstruction(mint, authority, metadataAddress, programId) {
      if (!(0, constants_js_1.programSupportsExtensions)(programId)) {
        throw new errors_js_1.TokenUnsupportedInstructionError();
      }
      const keys = [{ pubkey: mint, isSigner: false, isWritable: true }];
      const data = Buffer.alloc(exports2.initializeMetadataPointerData.span);
      exports2.initializeMetadataPointerData.encode({
        instruction: types_js_1.TokenInstruction.MetadataPointerExtension,
        metadataPointerInstruction: MetadataPointerInstruction.Initialize,
        authority: authority !== null && authority !== void 0 ? authority : web3_js_1.PublicKey.default,
        metadataAddress: metadataAddress !== null && metadataAddress !== void 0 ? metadataAddress : web3_js_1.PublicKey.default
      }, data);
      return new web3_js_1.TransactionInstruction({ keys, programId, data });
    }
    exports2.createInitializeMetadataPointerInstruction = createInitializeMetadataPointerInstruction;
    exports2.updateMetadataPointerData = (0, buffer_layout_1.struct)([
      // prettier-ignore
      (0, buffer_layout_1.u8)("instruction"),
      (0, buffer_layout_1.u8)("metadataPointerInstruction"),
      (0, buffer_layout_utils_1.publicKey)("metadataAddress")
    ]);
    function createUpdateMetadataPointerInstruction(mint, authority, metadataAddress, multiSigners = [], programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
      if (!(0, constants_js_1.programSupportsExtensions)(programId)) {
        throw new errors_js_1.TokenUnsupportedInstructionError();
      }
      const keys = (0, internal_js_1.addSigners)([{ pubkey: mint, isSigner: false, isWritable: true }], authority, multiSigners);
      const data = Buffer.alloc(exports2.updateMetadataPointerData.span);
      exports2.updateMetadataPointerData.encode({
        instruction: types_js_1.TokenInstruction.MetadataPointerExtension,
        metadataPointerInstruction: MetadataPointerInstruction.Update,
        metadataAddress: metadataAddress !== null && metadataAddress !== void 0 ? metadataAddress : web3_js_1.PublicKey.default
      }, data);
      return new web3_js_1.TransactionInstruction({ keys, programId, data });
    }
    exports2.createUpdateMetadataPointerInstruction = createUpdateMetadataPointerInstruction;
  }
});

// node_modules/@solana/spl-token/lib/cjs/extensions/metadataPointer/index.js
var require_metadataPointer2 = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/extensions/metadataPointer/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_instructions19(), exports2);
    __exportStar(require_state22(), exports2);
  }
});

// node_modules/@solana/spl-token/lib/cjs/extensions/tokenMetadata/state.js
var require_state25 = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/extensions/tokenMetadata/state.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getTokenMetadata = exports2.updateTokenMetadata = void 0;
    var spl_token_metadata_1 = require_cjs3();
    var constants_js_1 = require_constants2();
    var extensionType_js_1 = require_extensionType2();
    var mint_js_1 = require_mint2();
    var getNormalizedTokenMetadataField = (field) => {
      if (field === spl_token_metadata_1.Field.Name || field === "Name" || field === "name") {
        return "name";
      }
      if (field === spl_token_metadata_1.Field.Symbol || field === "Symbol" || field === "symbol") {
        return "symbol";
      }
      if (field === spl_token_metadata_1.Field.Uri || field === "Uri" || field === "uri") {
        return "uri";
      }
      return field;
    };
    function updateTokenMetadata(current, key, value) {
      const field = getNormalizedTokenMetadataField(key);
      if (field === "mint" || field === "updateAuthority") {
        throw new Error(`Cannot update ${field} via this instruction`);
      }
      if (["name", "symbol", "uri"].includes(field)) {
        return Object.assign(Object.assign({}, current), { [field]: value });
      }
      const additionalMetadata = [...current.additionalMetadata];
      const i = current.additionalMetadata.findIndex((x) => x[0] === field);
      if (i === -1) {
        additionalMetadata.push([field, value]);
      } else {
        additionalMetadata[i] = [field, value];
      }
      return Object.assign(Object.assign({}, current), { additionalMetadata });
    }
    exports2.updateTokenMetadata = updateTokenMetadata;
    function getTokenMetadata(connection, address, commitment, programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
      return __awaiter(this, void 0, void 0, function* () {
        const mintInfo = yield (0, mint_js_1.getMint)(connection, address, commitment, programId);
        const data = (0, extensionType_js_1.getExtensionData)(extensionType_js_1.ExtensionType.TokenMetadata, mintInfo.tlvData);
        if (data === null) {
          return null;
        }
        return (0, spl_token_metadata_1.unpack)(data);
      });
    }
    exports2.getTokenMetadata = getTokenMetadata;
  }
});

// node_modules/@solana/spl-token/lib/cjs/state/index.js
var require_state26 = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/state/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_account2(), exports2);
    __exportStar(require_mint2(), exports2);
    __exportStar(require_multisig2(), exports2);
  }
});

// node_modules/@solana/spl-token/lib/cjs/extensions/tokenMetadata/actions.js
var require_actions19 = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/extensions/tokenMetadata/actions.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.tokenMetadataUpdateAuthority = exports2.tokenMetadataRemoveKey = exports2.tokenMetadataUpdateFieldWithRentTransfer = exports2.tokenMetadataUpdateField = exports2.tokenMetadataInitializeWithRentTransfer = exports2.tokenMetadataInitialize = void 0;
    var web3_js_1 = require("@solana/web3.js");
    var spl_token_metadata_1 = require_cjs3();
    var constants_js_1 = require_constants2();
    var internal_js_1 = require_internal4();
    var extensionType_js_1 = require_extensionType2();
    var state_js_1 = require_state25();
    var errors_js_1 = require_errors4();
    var index_js_1 = require_state26();
    function getAdditionalRentForNewMetadata(connection, address, tokenMetadata, programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
      return __awaiter(this, void 0, void 0, function* () {
        const info = yield connection.getAccountInfo(address);
        if (!info) {
          throw new errors_js_1.TokenAccountNotFoundError();
        }
        const extensionLen = (0, spl_token_metadata_1.pack)(tokenMetadata).length;
        const newAccountLen = (0, extensionType_js_1.getNewAccountLenForExtensionLen)(info, address, extensionType_js_1.ExtensionType.TokenMetadata, extensionLen, programId);
        if (newAccountLen <= info.data.length) {
          return 0;
        }
        const newRentExemptMinimum = yield connection.getMinimumBalanceForRentExemption(newAccountLen);
        return newRentExemptMinimum - info.lamports;
      });
    }
    function getAdditionalRentForUpdatedMetadata(connection, address, field, value, programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
      return __awaiter(this, void 0, void 0, function* () {
        const info = yield connection.getAccountInfo(address);
        if (!info) {
          throw new errors_js_1.TokenAccountNotFoundError();
        }
        const mint = (0, index_js_1.unpackMint)(address, info, programId);
        const extensionData = (0, extensionType_js_1.getExtensionData)(extensionType_js_1.ExtensionType.TokenMetadata, mint.tlvData);
        if (extensionData === null) {
          throw new Error("TokenMetadata extension not initialized");
        }
        const updatedTokenMetadata = (0, state_js_1.updateTokenMetadata)((0, spl_token_metadata_1.unpack)(extensionData), field, value);
        const extensionLen = (0, spl_token_metadata_1.pack)(updatedTokenMetadata).length;
        const newAccountLen = (0, extensionType_js_1.getNewAccountLenForExtensionLen)(info, address, extensionType_js_1.ExtensionType.TokenMetadata, extensionLen, programId);
        if (newAccountLen <= info.data.length) {
          return 0;
        }
        const newRentExemptMinimum = yield connection.getMinimumBalanceForRentExemption(newAccountLen);
        return newRentExemptMinimum - info.lamports;
      });
    }
    function tokenMetadataInitialize(connection, payer, mint, updateAuthority, mintAuthority, name, symbol, uri, multiSigners = [], confirmOptions, programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
      return __awaiter(this, void 0, void 0, function* () {
        const [mintAuthorityPublicKey, signers] = (0, internal_js_1.getSigners)(mintAuthority, multiSigners);
        const transaction = new web3_js_1.Transaction().add((0, spl_token_metadata_1.createInitializeInstruction)({
          programId,
          metadata: mint,
          updateAuthority,
          mint,
          mintAuthority: mintAuthorityPublicKey,
          name,
          symbol,
          uri
        }));
        return yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer, ...signers], confirmOptions);
      });
    }
    exports2.tokenMetadataInitialize = tokenMetadataInitialize;
    function tokenMetadataInitializeWithRentTransfer(connection, payer, mint, updateAuthority, mintAuthority, name, symbol, uri, multiSigners = [], confirmOptions, programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
      return __awaiter(this, void 0, void 0, function* () {
        const [mintAuthorityPublicKey, signers] = (0, internal_js_1.getSigners)(mintAuthority, multiSigners);
        const transaction = new web3_js_1.Transaction();
        const lamports = yield getAdditionalRentForNewMetadata(connection, mint, {
          updateAuthority,
          mint,
          name,
          symbol,
          uri,
          additionalMetadata: []
        }, programId);
        if (lamports > 0) {
          transaction.add(web3_js_1.SystemProgram.transfer({ fromPubkey: payer.publicKey, toPubkey: mint, lamports }));
        }
        transaction.add((0, spl_token_metadata_1.createInitializeInstruction)({
          programId,
          metadata: mint,
          updateAuthority,
          mint,
          mintAuthority: mintAuthorityPublicKey,
          name,
          symbol,
          uri
        }));
        return yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer, ...signers], confirmOptions);
      });
    }
    exports2.tokenMetadataInitializeWithRentTransfer = tokenMetadataInitializeWithRentTransfer;
    function tokenMetadataUpdateField(connection, payer, mint, updateAuthority, field, value, multiSigners = [], confirmOptions, programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
      return __awaiter(this, void 0, void 0, function* () {
        const [updateAuthorityPublicKey, signers] = (0, internal_js_1.getSigners)(updateAuthority, multiSigners);
        const transaction = new web3_js_1.Transaction().add((0, spl_token_metadata_1.createUpdateFieldInstruction)({
          programId,
          metadata: mint,
          updateAuthority: updateAuthorityPublicKey,
          field,
          value
        }));
        return yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer, ...signers], confirmOptions);
      });
    }
    exports2.tokenMetadataUpdateField = tokenMetadataUpdateField;
    function tokenMetadataUpdateFieldWithRentTransfer(connection, payer, mint, updateAuthority, field, value, multiSigners = [], confirmOptions, programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
      return __awaiter(this, void 0, void 0, function* () {
        const [updateAuthorityPublicKey, signers] = (0, internal_js_1.getSigners)(updateAuthority, multiSigners);
        const transaction = new web3_js_1.Transaction();
        const lamports = yield getAdditionalRentForUpdatedMetadata(connection, mint, field, value, programId);
        if (lamports > 0) {
          transaction.add(web3_js_1.SystemProgram.transfer({ fromPubkey: payer.publicKey, toPubkey: mint, lamports }));
        }
        transaction.add((0, spl_token_metadata_1.createUpdateFieldInstruction)({
          programId,
          metadata: mint,
          updateAuthority: updateAuthorityPublicKey,
          field,
          value
        }));
        return yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer, ...signers], confirmOptions);
      });
    }
    exports2.tokenMetadataUpdateFieldWithRentTransfer = tokenMetadataUpdateFieldWithRentTransfer;
    function tokenMetadataRemoveKey(connection, payer, mint, updateAuthority, key, idempotent, multiSigners = [], confirmOptions, programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
      return __awaiter(this, void 0, void 0, function* () {
        const [updateAuthorityPublicKey, signers] = (0, internal_js_1.getSigners)(updateAuthority, multiSigners);
        const transaction = new web3_js_1.Transaction().add((0, spl_token_metadata_1.createRemoveKeyInstruction)({
          programId,
          metadata: mint,
          updateAuthority: updateAuthorityPublicKey,
          key,
          idempotent
        }));
        return yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer, ...signers], confirmOptions);
      });
    }
    exports2.tokenMetadataRemoveKey = tokenMetadataRemoveKey;
    function tokenMetadataUpdateAuthority(connection, payer, mint, updateAuthority, newAuthority, multiSigners = [], confirmOptions, programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
      return __awaiter(this, void 0, void 0, function* () {
        const [updateAuthorityPublicKey, signers] = (0, internal_js_1.getSigners)(updateAuthority, multiSigners);
        const transaction = new web3_js_1.Transaction().add((0, spl_token_metadata_1.createUpdateAuthorityInstruction)({
          programId,
          metadata: mint,
          oldAuthority: updateAuthorityPublicKey,
          newAuthority
        }));
        return yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer, ...signers], confirmOptions);
      });
    }
    exports2.tokenMetadataUpdateAuthority = tokenMetadataUpdateAuthority;
  }
});

// node_modules/@solana/spl-token/lib/cjs/extensions/tokenMetadata/index.js
var require_tokenMetadata2 = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/extensions/tokenMetadata/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_actions19(), exports2);
    __exportStar(require_state25(), exports2);
  }
});

// node_modules/@solana/spl-token/lib/cjs/extensions/index.js
var require_extensions2 = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/extensions/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_accountType2(), exports2);
    __exportStar(require_cpiGuard2(), exports2);
    __exportStar(require_defaultAccountState2(), exports2);
    __exportStar(require_extensionType2(), exports2);
    __exportStar(require_immutableOwner2(), exports2);
    __exportStar(require_interestBearingMint2(), exports2);
    __exportStar(require_memoTransfer2(), exports2);
    __exportStar(require_metadataPointer2(), exports2);
    __exportStar(require_tokenMetadata2(), exports2);
    __exportStar(require_mintCloseAuthority2(), exports2);
    __exportStar(require_nonTransferable2(), exports2);
    __exportStar(require_transferFee2(), exports2);
    __exportStar(require_permanentDelegate2(), exports2);
    __exportStar(require_transferHook2(), exports2);
  }
});

// node_modules/@solana/spl-token/lib/cjs/instructions/initializeAccount2.js
var require_initializeAccount22 = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/instructions/initializeAccount2.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.decodeInitializeAccount2InstructionUnchecked = exports2.decodeInitializeAccount2Instruction = exports2.createInitializeAccount2Instruction = exports2.initializeAccount2InstructionData = void 0;
    var buffer_layout_1 = require_Layout();
    var buffer_layout_utils_1 = require_cjs();
    var web3_js_1 = require("@solana/web3.js");
    var constants_js_1 = require_constants2();
    var errors_js_1 = require_errors4();
    var types_js_1 = require_types2();
    exports2.initializeAccount2InstructionData = (0, buffer_layout_1.struct)([
      (0, buffer_layout_1.u8)("instruction"),
      (0, buffer_layout_utils_1.publicKey)("owner")
    ]);
    function createInitializeAccount2Instruction(account, mint, owner, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      const keys = [
        { pubkey: account, isSigner: false, isWritable: true },
        { pubkey: mint, isSigner: false, isWritable: false },
        { pubkey: web3_js_1.SYSVAR_RENT_PUBKEY, isSigner: false, isWritable: false }
      ];
      const data = Buffer.alloc(exports2.initializeAccount2InstructionData.span);
      exports2.initializeAccount2InstructionData.encode({ instruction: types_js_1.TokenInstruction.InitializeAccount2, owner }, data);
      return new web3_js_1.TransactionInstruction({ keys, programId, data });
    }
    exports2.createInitializeAccount2Instruction = createInitializeAccount2Instruction;
    function decodeInitializeAccount2Instruction(instruction, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      if (!instruction.programId.equals(programId))
        throw new errors_js_1.TokenInvalidInstructionProgramError();
      if (instruction.data.length !== exports2.initializeAccount2InstructionData.span)
        throw new errors_js_1.TokenInvalidInstructionDataError();
      const { keys: { account, mint, rent }, data } = decodeInitializeAccount2InstructionUnchecked(instruction);
      if (data.instruction !== types_js_1.TokenInstruction.InitializeAccount2)
        throw new errors_js_1.TokenInvalidInstructionTypeError();
      if (!account || !mint || !rent)
        throw new errors_js_1.TokenInvalidInstructionKeysError();
      return {
        programId,
        keys: {
          account,
          mint,
          rent
        },
        data
      };
    }
    exports2.decodeInitializeAccount2Instruction = decodeInitializeAccount2Instruction;
    function decodeInitializeAccount2InstructionUnchecked({ programId, keys: [account, mint, rent], data }) {
      return {
        programId,
        keys: {
          account,
          mint,
          rent
        },
        data: exports2.initializeAccount2InstructionData.decode(data)
      };
    }
    exports2.decodeInitializeAccount2InstructionUnchecked = decodeInitializeAccount2InstructionUnchecked;
  }
});

// node_modules/@solana/spl-token/lib/cjs/instructions/initializeAccount3.js
var require_initializeAccount32 = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/instructions/initializeAccount3.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.decodeInitializeAccount3InstructionUnchecked = exports2.decodeInitializeAccount3Instruction = exports2.createInitializeAccount3Instruction = exports2.initializeAccount3InstructionData = void 0;
    var buffer_layout_1 = require_Layout();
    var buffer_layout_utils_1 = require_cjs();
    var web3_js_1 = require("@solana/web3.js");
    var constants_js_1 = require_constants2();
    var errors_js_1 = require_errors4();
    var types_js_1 = require_types2();
    exports2.initializeAccount3InstructionData = (0, buffer_layout_1.struct)([
      (0, buffer_layout_1.u8)("instruction"),
      (0, buffer_layout_utils_1.publicKey)("owner")
    ]);
    function createInitializeAccount3Instruction(account, mint, owner, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      const keys = [
        { pubkey: account, isSigner: false, isWritable: true },
        { pubkey: mint, isSigner: false, isWritable: false }
      ];
      const data = Buffer.alloc(exports2.initializeAccount3InstructionData.span);
      exports2.initializeAccount3InstructionData.encode({ instruction: types_js_1.TokenInstruction.InitializeAccount3, owner }, data);
      return new web3_js_1.TransactionInstruction({ keys, programId, data });
    }
    exports2.createInitializeAccount3Instruction = createInitializeAccount3Instruction;
    function decodeInitializeAccount3Instruction(instruction, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      if (!instruction.programId.equals(programId))
        throw new errors_js_1.TokenInvalidInstructionProgramError();
      if (instruction.data.length !== exports2.initializeAccount3InstructionData.span)
        throw new errors_js_1.TokenInvalidInstructionDataError();
      const { keys: { account, mint }, data } = decodeInitializeAccount3InstructionUnchecked(instruction);
      if (data.instruction !== types_js_1.TokenInstruction.InitializeAccount3)
        throw new errors_js_1.TokenInvalidInstructionTypeError();
      if (!account || !mint)
        throw new errors_js_1.TokenInvalidInstructionKeysError();
      return {
        programId,
        keys: {
          account,
          mint
        },
        data
      };
    }
    exports2.decodeInitializeAccount3Instruction = decodeInitializeAccount3Instruction;
    function decodeInitializeAccount3InstructionUnchecked({ programId, keys: [account, mint], data }) {
      return {
        programId,
        keys: {
          account,
          mint
        },
        data: exports2.initializeAccount3InstructionData.decode(data)
      };
    }
    exports2.decodeInitializeAccount3InstructionUnchecked = decodeInitializeAccount3InstructionUnchecked;
  }
});

// node_modules/@solana/spl-token/lib/cjs/instructions/decode.js
var require_decode2 = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/instructions/decode.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isUiamountToAmountInstruction = exports2.isAmountToUiAmountInstruction = exports2.isInitializeMint2Instruction = exports2.isInitializeAccount3Instruction = exports2.isSyncNativeInstruction = exports2.isInitializeAccount2Instruction = exports2.isBurnCheckedInstruction = exports2.isMintToCheckedInstruction = exports2.isApproveCheckedInstruction = exports2.isTransferCheckedInstruction = exports2.isThawAccountInstruction = exports2.isFreezeAccountInstruction = exports2.isCloseAccountInstruction = exports2.isBurnInstruction = exports2.isMintToInstruction = exports2.isSetAuthorityInstruction = exports2.isRevokeInstruction = exports2.isApproveInstruction = exports2.isTransferInstruction = exports2.isInitializeMultisigInstruction = exports2.isInitializeAccountInstruction = exports2.isInitializeMintInstruction = exports2.decodeInstruction = void 0;
    var buffer_layout_1 = require_Layout();
    var constants_js_1 = require_constants2();
    var errors_js_1 = require_errors4();
    var amountToUiAmount_js_1 = require_amountToUiAmount3();
    var approve_js_1 = require_approve3();
    var approveChecked_js_1 = require_approveChecked3();
    var burn_js_1 = require_burn3();
    var burnChecked_js_1 = require_burnChecked3();
    var closeAccount_js_1 = require_closeAccount3();
    var freezeAccount_js_1 = require_freezeAccount3();
    var initializeAccount_js_1 = require_initializeAccount4();
    var initializeAccount2_js_1 = require_initializeAccount22();
    var initializeAccount3_js_1 = require_initializeAccount32();
    var initializeMint_js_1 = require_initializeMint3();
    var initializeMint2_js_1 = require_initializeMint22();
    var initializeMultisig_js_1 = require_initializeMultisig3();
    var mintTo_js_1 = require_mintTo3();
    var mintToChecked_js_1 = require_mintToChecked3();
    var revoke_js_1 = require_revoke3();
    var setAuthority_js_1 = require_setAuthority3();
    var syncNative_js_1 = require_syncNative3();
    var thawAccount_js_1 = require_thawAccount3();
    var transfer_js_1 = require_transfer3();
    var transferChecked_js_1 = require_transferChecked3();
    var types_js_1 = require_types2();
    var uiAmountToAmount_js_1 = require_uiAmountToAmount3();
    function decodeInstruction(instruction, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      if (!instruction.data.length)
        throw new errors_js_1.TokenInvalidInstructionDataError();
      const type = (0, buffer_layout_1.u8)().decode(instruction.data);
      if (type === types_js_1.TokenInstruction.InitializeMint)
        return (0, initializeMint_js_1.decodeInitializeMintInstruction)(instruction, programId);
      if (type === types_js_1.TokenInstruction.InitializeAccount)
        return (0, initializeAccount_js_1.decodeInitializeAccountInstruction)(instruction, programId);
      if (type === types_js_1.TokenInstruction.InitializeMultisig)
        return (0, initializeMultisig_js_1.decodeInitializeMultisigInstruction)(instruction, programId);
      if (type === types_js_1.TokenInstruction.Transfer)
        return (0, transfer_js_1.decodeTransferInstruction)(instruction, programId);
      if (type === types_js_1.TokenInstruction.Approve)
        return (0, approve_js_1.decodeApproveInstruction)(instruction, programId);
      if (type === types_js_1.TokenInstruction.Revoke)
        return (0, revoke_js_1.decodeRevokeInstruction)(instruction, programId);
      if (type === types_js_1.TokenInstruction.SetAuthority)
        return (0, setAuthority_js_1.decodeSetAuthorityInstruction)(instruction, programId);
      if (type === types_js_1.TokenInstruction.MintTo)
        return (0, mintTo_js_1.decodeMintToInstruction)(instruction, programId);
      if (type === types_js_1.TokenInstruction.Burn)
        return (0, burn_js_1.decodeBurnInstruction)(instruction, programId);
      if (type === types_js_1.TokenInstruction.CloseAccount)
        return (0, closeAccount_js_1.decodeCloseAccountInstruction)(instruction, programId);
      if (type === types_js_1.TokenInstruction.FreezeAccount)
        return (0, freezeAccount_js_1.decodeFreezeAccountInstruction)(instruction, programId);
      if (type === types_js_1.TokenInstruction.ThawAccount)
        return (0, thawAccount_js_1.decodeThawAccountInstruction)(instruction, programId);
      if (type === types_js_1.TokenInstruction.TransferChecked)
        return (0, transferChecked_js_1.decodeTransferCheckedInstruction)(instruction, programId);
      if (type === types_js_1.TokenInstruction.ApproveChecked)
        return (0, approveChecked_js_1.decodeApproveCheckedInstruction)(instruction, programId);
      if (type === types_js_1.TokenInstruction.MintToChecked)
        return (0, mintToChecked_js_1.decodeMintToCheckedInstruction)(instruction, programId);
      if (type === types_js_1.TokenInstruction.BurnChecked)
        return (0, burnChecked_js_1.decodeBurnCheckedInstruction)(instruction, programId);
      if (type === types_js_1.TokenInstruction.InitializeAccount2)
        return (0, initializeAccount2_js_1.decodeInitializeAccount2Instruction)(instruction, programId);
      if (type === types_js_1.TokenInstruction.SyncNative)
        return (0, syncNative_js_1.decodeSyncNativeInstruction)(instruction, programId);
      if (type === types_js_1.TokenInstruction.InitializeAccount3)
        return (0, initializeAccount3_js_1.decodeInitializeAccount3Instruction)(instruction, programId);
      if (type === types_js_1.TokenInstruction.InitializeMint2)
        return (0, initializeMint2_js_1.decodeInitializeMint2Instruction)(instruction, programId);
      if (type === types_js_1.TokenInstruction.AmountToUiAmount)
        return (0, amountToUiAmount_js_1.decodeAmountToUiAmountInstruction)(instruction, programId);
      if (type === types_js_1.TokenInstruction.UiAmountToAmount)
        return (0, uiAmountToAmount_js_1.decodeUiAmountToAmountInstruction)(instruction, programId);
      if (type === types_js_1.TokenInstruction.InitializeMultisig2)
        throw new errors_js_1.TokenInvalidInstructionTypeError();
      throw new errors_js_1.TokenInvalidInstructionTypeError();
    }
    exports2.decodeInstruction = decodeInstruction;
    function isInitializeMintInstruction(decoded) {
      return decoded.data.instruction === types_js_1.TokenInstruction.InitializeMint;
    }
    exports2.isInitializeMintInstruction = isInitializeMintInstruction;
    function isInitializeAccountInstruction(decoded) {
      return decoded.data.instruction === types_js_1.TokenInstruction.InitializeAccount;
    }
    exports2.isInitializeAccountInstruction = isInitializeAccountInstruction;
    function isInitializeMultisigInstruction(decoded) {
      return decoded.data.instruction === types_js_1.TokenInstruction.InitializeMultisig;
    }
    exports2.isInitializeMultisigInstruction = isInitializeMultisigInstruction;
    function isTransferInstruction(decoded) {
      return decoded.data.instruction === types_js_1.TokenInstruction.Transfer;
    }
    exports2.isTransferInstruction = isTransferInstruction;
    function isApproveInstruction(decoded) {
      return decoded.data.instruction === types_js_1.TokenInstruction.Approve;
    }
    exports2.isApproveInstruction = isApproveInstruction;
    function isRevokeInstruction(decoded) {
      return decoded.data.instruction === types_js_1.TokenInstruction.Revoke;
    }
    exports2.isRevokeInstruction = isRevokeInstruction;
    function isSetAuthorityInstruction(decoded) {
      return decoded.data.instruction === types_js_1.TokenInstruction.SetAuthority;
    }
    exports2.isSetAuthorityInstruction = isSetAuthorityInstruction;
    function isMintToInstruction(decoded) {
      return decoded.data.instruction === types_js_1.TokenInstruction.MintTo;
    }
    exports2.isMintToInstruction = isMintToInstruction;
    function isBurnInstruction(decoded) {
      return decoded.data.instruction === types_js_1.TokenInstruction.Burn;
    }
    exports2.isBurnInstruction = isBurnInstruction;
    function isCloseAccountInstruction(decoded) {
      return decoded.data.instruction === types_js_1.TokenInstruction.CloseAccount;
    }
    exports2.isCloseAccountInstruction = isCloseAccountInstruction;
    function isFreezeAccountInstruction(decoded) {
      return decoded.data.instruction === types_js_1.TokenInstruction.FreezeAccount;
    }
    exports2.isFreezeAccountInstruction = isFreezeAccountInstruction;
    function isThawAccountInstruction(decoded) {
      return decoded.data.instruction === types_js_1.TokenInstruction.ThawAccount;
    }
    exports2.isThawAccountInstruction = isThawAccountInstruction;
    function isTransferCheckedInstruction(decoded) {
      return decoded.data.instruction === types_js_1.TokenInstruction.TransferChecked;
    }
    exports2.isTransferCheckedInstruction = isTransferCheckedInstruction;
    function isApproveCheckedInstruction(decoded) {
      return decoded.data.instruction === types_js_1.TokenInstruction.ApproveChecked;
    }
    exports2.isApproveCheckedInstruction = isApproveCheckedInstruction;
    function isMintToCheckedInstruction(decoded) {
      return decoded.data.instruction === types_js_1.TokenInstruction.MintToChecked;
    }
    exports2.isMintToCheckedInstruction = isMintToCheckedInstruction;
    function isBurnCheckedInstruction(decoded) {
      return decoded.data.instruction === types_js_1.TokenInstruction.BurnChecked;
    }
    exports2.isBurnCheckedInstruction = isBurnCheckedInstruction;
    function isInitializeAccount2Instruction(decoded) {
      return decoded.data.instruction === types_js_1.TokenInstruction.InitializeAccount2;
    }
    exports2.isInitializeAccount2Instruction = isInitializeAccount2Instruction;
    function isSyncNativeInstruction(decoded) {
      return decoded.data.instruction === types_js_1.TokenInstruction.SyncNative;
    }
    exports2.isSyncNativeInstruction = isSyncNativeInstruction;
    function isInitializeAccount3Instruction(decoded) {
      return decoded.data.instruction === types_js_1.TokenInstruction.InitializeAccount3;
    }
    exports2.isInitializeAccount3Instruction = isInitializeAccount3Instruction;
    function isInitializeMint2Instruction(decoded) {
      return decoded.data.instruction === types_js_1.TokenInstruction.InitializeMint2;
    }
    exports2.isInitializeMint2Instruction = isInitializeMint2Instruction;
    function isAmountToUiAmountInstruction(decoded) {
      return decoded.data.instruction === types_js_1.TokenInstruction.AmountToUiAmount;
    }
    exports2.isAmountToUiAmountInstruction = isAmountToUiAmountInstruction;
    function isUiamountToAmountInstruction(decoded) {
      return decoded.data.instruction === types_js_1.TokenInstruction.UiAmountToAmount;
    }
    exports2.isUiamountToAmountInstruction = isUiamountToAmountInstruction;
  }
});

// node_modules/@solana/spl-token/lib/cjs/instructions/initializeMultisig2.js
var require_initializeMultisig22 = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/instructions/initializeMultisig2.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/@solana/spl-token/lib/cjs/instructions/initializeImmutableOwner.js
var require_initializeImmutableOwner2 = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/instructions/initializeImmutableOwner.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.decodeInitializeImmutableOwnerInstructionUnchecked = exports2.decodeInitializeImmutableOwnerInstruction = exports2.createInitializeImmutableOwnerInstruction = exports2.initializeImmutableOwnerInstructionData = void 0;
    var buffer_layout_1 = require_Layout();
    var web3_js_1 = require("@solana/web3.js");
    var errors_js_1 = require_errors4();
    var types_js_1 = require_types2();
    exports2.initializeImmutableOwnerInstructionData = (0, buffer_layout_1.struct)([
      (0, buffer_layout_1.u8)("instruction")
    ]);
    function createInitializeImmutableOwnerInstruction(account, programId) {
      const keys = [{ pubkey: account, isSigner: false, isWritable: true }];
      const data = Buffer.alloc(exports2.initializeImmutableOwnerInstructionData.span);
      exports2.initializeImmutableOwnerInstructionData.encode({
        instruction: types_js_1.TokenInstruction.InitializeImmutableOwner
      }, data);
      return new web3_js_1.TransactionInstruction({ keys, programId, data });
    }
    exports2.createInitializeImmutableOwnerInstruction = createInitializeImmutableOwnerInstruction;
    function decodeInitializeImmutableOwnerInstruction(instruction, programId) {
      if (!instruction.programId.equals(programId))
        throw new errors_js_1.TokenInvalidInstructionProgramError();
      if (instruction.data.length !== exports2.initializeImmutableOwnerInstructionData.span)
        throw new errors_js_1.TokenInvalidInstructionDataError();
      const { keys: { account }, data } = decodeInitializeImmutableOwnerInstructionUnchecked(instruction);
      if (data.instruction !== types_js_1.TokenInstruction.InitializeImmutableOwner)
        throw new errors_js_1.TokenInvalidInstructionTypeError();
      if (!account)
        throw new errors_js_1.TokenInvalidInstructionKeysError();
      return {
        programId,
        keys: {
          account
        },
        data
      };
    }
    exports2.decodeInitializeImmutableOwnerInstruction = decodeInitializeImmutableOwnerInstruction;
    function decodeInitializeImmutableOwnerInstructionUnchecked({ programId, keys: [account], data }) {
      const { instruction } = exports2.initializeImmutableOwnerInstructionData.decode(data);
      return {
        programId,
        keys: {
          account
        },
        data: {
          instruction
        }
      };
    }
    exports2.decodeInitializeImmutableOwnerInstructionUnchecked = decodeInitializeImmutableOwnerInstructionUnchecked;
  }
});

// node_modules/@solana/spl-token/lib/cjs/instructions/initializeMintCloseAuthority.js
var require_initializeMintCloseAuthority2 = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/instructions/initializeMintCloseAuthority.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.decodeInitializeMintCloseAuthorityInstructionUnchecked = exports2.decodeInitializeMintCloseAuthorityInstruction = exports2.createInitializeMintCloseAuthorityInstruction = exports2.initializeMintCloseAuthorityInstructionData = void 0;
    var buffer_layout_1 = require_Layout();
    var buffer_layout_utils_1 = require_cjs();
    var web3_js_1 = require("@solana/web3.js");
    var constants_js_1 = require_constants2();
    var errors_js_1 = require_errors4();
    var types_js_1 = require_types2();
    exports2.initializeMintCloseAuthorityInstructionData = (0, buffer_layout_1.struct)([
      (0, buffer_layout_1.u8)("instruction"),
      (0, buffer_layout_1.u8)("closeAuthorityOption"),
      (0, buffer_layout_utils_1.publicKey)("closeAuthority")
    ]);
    function createInitializeMintCloseAuthorityInstruction(mint, closeAuthority, programId) {
      if (!(0, constants_js_1.programSupportsExtensions)(programId)) {
        throw new errors_js_1.TokenUnsupportedInstructionError();
      }
      const keys = [{ pubkey: mint, isSigner: false, isWritable: true }];
      const data = Buffer.alloc(exports2.initializeMintCloseAuthorityInstructionData.span);
      exports2.initializeMintCloseAuthorityInstructionData.encode({
        instruction: types_js_1.TokenInstruction.InitializeMintCloseAuthority,
        closeAuthorityOption: closeAuthority ? 1 : 0,
        closeAuthority: closeAuthority || new web3_js_1.PublicKey(0)
      }, data);
      return new web3_js_1.TransactionInstruction({ keys, programId, data });
    }
    exports2.createInitializeMintCloseAuthorityInstruction = createInitializeMintCloseAuthorityInstruction;
    function decodeInitializeMintCloseAuthorityInstruction(instruction, programId) {
      if (!instruction.programId.equals(programId))
        throw new errors_js_1.TokenInvalidInstructionProgramError();
      if (instruction.data.length !== exports2.initializeMintCloseAuthorityInstructionData.span)
        throw new errors_js_1.TokenInvalidInstructionDataError();
      const { keys: { mint }, data } = decodeInitializeMintCloseAuthorityInstructionUnchecked(instruction);
      if (data.instruction !== types_js_1.TokenInstruction.InitializeMintCloseAuthority)
        throw new errors_js_1.TokenInvalidInstructionTypeError();
      if (!mint)
        throw new errors_js_1.TokenInvalidInstructionKeysError();
      return {
        programId,
        keys: {
          mint
        },
        data
      };
    }
    exports2.decodeInitializeMintCloseAuthorityInstruction = decodeInitializeMintCloseAuthorityInstruction;
    function decodeInitializeMintCloseAuthorityInstructionUnchecked({ programId, keys: [mint], data }) {
      const { instruction, closeAuthorityOption, closeAuthority } = exports2.initializeMintCloseAuthorityInstructionData.decode(data);
      return {
        programId,
        keys: {
          mint
        },
        data: {
          instruction,
          closeAuthority: closeAuthorityOption ? closeAuthority : null
        }
      };
    }
    exports2.decodeInitializeMintCloseAuthorityInstructionUnchecked = decodeInitializeMintCloseAuthorityInstructionUnchecked;
  }
});

// node_modules/@solana/spl-token/lib/cjs/instructions/reallocate.js
var require_reallocate2 = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/instructions/reallocate.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createReallocateInstruction = void 0;
    var buffer_layout_1 = require_Layout();
    var web3_js_1 = require("@solana/web3.js");
    var constants_js_1 = require_constants2();
    var errors_js_1 = require_errors4();
    var internal_js_1 = require_internal3();
    var types_js_1 = require_types2();
    function createReallocateInstruction(account, payer, extensionTypes, owner, multiSigners = [], programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
      if (!(0, constants_js_1.programSupportsExtensions)(programId)) {
        throw new errors_js_1.TokenUnsupportedInstructionError();
      }
      const baseKeys = [
        { pubkey: account, isSigner: false, isWritable: true },
        { pubkey: payer, isSigner: true, isWritable: true },
        { pubkey: web3_js_1.SystemProgram.programId, isSigner: false, isWritable: false }
      ];
      const keys = (0, internal_js_1.addSigners)(baseKeys, owner, multiSigners);
      const reallocateInstructionData = (0, buffer_layout_1.struct)([
        (0, buffer_layout_1.u8)("instruction"),
        (0, buffer_layout_1.seq)((0, buffer_layout_1.u16)(), extensionTypes.length, "extensionTypes")
      ]);
      const data = Buffer.alloc(reallocateInstructionData.span);
      reallocateInstructionData.encode({ instruction: types_js_1.TokenInstruction.Reallocate, extensionTypes }, data);
      return new web3_js_1.TransactionInstruction({ keys, programId, data });
    }
    exports2.createReallocateInstruction = createReallocateInstruction;
  }
});

// node_modules/@solana/spl-token/lib/cjs/instructions/initializeNonTransferableMint.js
var require_initializeNonTransferableMint2 = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/instructions/initializeNonTransferableMint.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createInitializeNonTransferableMintInstruction = exports2.initializeNonTransferableMintInstructionData = void 0;
    var buffer_layout_1 = require_Layout();
    var web3_js_1 = require("@solana/web3.js");
    var constants_js_1 = require_constants2();
    var errors_js_1 = require_errors4();
    var types_js_1 = require_types2();
    exports2.initializeNonTransferableMintInstructionData = (0, buffer_layout_1.struct)([
      (0, buffer_layout_1.u8)("instruction")
    ]);
    function createInitializeNonTransferableMintInstruction(mint, programId) {
      if (!(0, constants_js_1.programSupportsExtensions)(programId)) {
        throw new errors_js_1.TokenUnsupportedInstructionError();
      }
      const keys = [{ pubkey: mint, isSigner: false, isWritable: true }];
      const data = Buffer.alloc(exports2.initializeNonTransferableMintInstructionData.span);
      exports2.initializeNonTransferableMintInstructionData.encode({
        instruction: types_js_1.TokenInstruction.InitializeNonTransferableMint
      }, data);
      return new web3_js_1.TransactionInstruction({ keys, programId, data });
    }
    exports2.createInitializeNonTransferableMintInstruction = createInitializeNonTransferableMintInstruction;
  }
});

// node_modules/@solana/spl-token/lib/cjs/instructions/initializePermanentDelegate.js
var require_initializePermanentDelegate2 = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/instructions/initializePermanentDelegate.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.decodeInitializePermanentDelegateInstructionUnchecked = exports2.decodeInitializePermanentDelegateInstruction = exports2.createInitializePermanentDelegateInstruction = exports2.initializePermanentDelegateInstructionData = void 0;
    var buffer_layout_1 = require_Layout();
    var buffer_layout_utils_1 = require_cjs();
    var web3_js_1 = require("@solana/web3.js");
    var web3_js_2 = require("@solana/web3.js");
    var constants_js_1 = require_constants2();
    var errors_js_1 = require_errors4();
    var types_js_1 = require_types2();
    exports2.initializePermanentDelegateInstructionData = (0, buffer_layout_1.struct)([
      (0, buffer_layout_1.u8)("instruction"),
      (0, buffer_layout_utils_1.publicKey)("delegate")
    ]);
    function createInitializePermanentDelegateInstruction(mint, permanentDelegate, programId) {
      if (!(0, constants_js_1.programSupportsExtensions)(programId)) {
        throw new errors_js_1.TokenUnsupportedInstructionError();
      }
      const keys = [{ pubkey: mint, isSigner: false, isWritable: true }];
      const data = Buffer.alloc(exports2.initializePermanentDelegateInstructionData.span);
      exports2.initializePermanentDelegateInstructionData.encode({
        instruction: types_js_1.TokenInstruction.InitializePermanentDelegate,
        delegate: permanentDelegate || new web3_js_1.PublicKey(0)
      }, data);
      return new web3_js_2.TransactionInstruction({ keys, programId, data });
    }
    exports2.createInitializePermanentDelegateInstruction = createInitializePermanentDelegateInstruction;
    function decodeInitializePermanentDelegateInstruction(instruction, programId) {
      if (!instruction.programId.equals(programId))
        throw new errors_js_1.TokenInvalidInstructionProgramError();
      if (instruction.data.length !== exports2.initializePermanentDelegateInstructionData.span)
        throw new errors_js_1.TokenInvalidInstructionDataError();
      const { keys: { mint }, data } = decodeInitializePermanentDelegateInstructionUnchecked(instruction);
      if (data.instruction !== types_js_1.TokenInstruction.InitializePermanentDelegate)
        throw new errors_js_1.TokenInvalidInstructionTypeError();
      if (!mint)
        throw new errors_js_1.TokenInvalidInstructionKeysError();
      return {
        programId,
        keys: {
          mint
        },
        data
      };
    }
    exports2.decodeInitializePermanentDelegateInstruction = decodeInitializePermanentDelegateInstruction;
    function decodeInitializePermanentDelegateInstructionUnchecked({ programId, keys: [mint], data }) {
      const { instruction, delegate } = exports2.initializePermanentDelegateInstructionData.decode(data);
      return {
        programId,
        keys: {
          mint
        },
        data: {
          instruction,
          delegate
        }
      };
    }
    exports2.decodeInitializePermanentDelegateInstructionUnchecked = decodeInitializePermanentDelegateInstructionUnchecked;
  }
});

// node_modules/@solana/spl-token/lib/cjs/instructions/index.js
var require_instructions20 = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/instructions/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createEmitInstruction = exports2.createUpdateAuthorityInstruction = exports2.createRemoveKeyInstruction = exports2.createUpdateFieldInstruction = exports2.createInitializeInstruction = void 0;
    var spl_token_metadata_1 = require_cjs3();
    Object.defineProperty(exports2, "createInitializeInstruction", { enumerable: true, get: function() {
      return spl_token_metadata_1.createInitializeInstruction;
    } });
    Object.defineProperty(exports2, "createUpdateFieldInstruction", { enumerable: true, get: function() {
      return spl_token_metadata_1.createUpdateFieldInstruction;
    } });
    Object.defineProperty(exports2, "createRemoveKeyInstruction", { enumerable: true, get: function() {
      return spl_token_metadata_1.createRemoveKeyInstruction;
    } });
    Object.defineProperty(exports2, "createUpdateAuthorityInstruction", { enumerable: true, get: function() {
      return spl_token_metadata_1.createUpdateAuthorityInstruction;
    } });
    Object.defineProperty(exports2, "createEmitInstruction", { enumerable: true, get: function() {
      return spl_token_metadata_1.createEmitInstruction;
    } });
    __exportStar(require_associatedTokenAccount2(), exports2);
    __exportStar(require_decode2(), exports2);
    __exportStar(require_types2(), exports2);
    __exportStar(require_initializeMint3(), exports2);
    __exportStar(require_initializeAccount4(), exports2);
    __exportStar(require_initializeMultisig3(), exports2);
    __exportStar(require_transfer3(), exports2);
    __exportStar(require_approve3(), exports2);
    __exportStar(require_revoke3(), exports2);
    __exportStar(require_setAuthority3(), exports2);
    __exportStar(require_mintTo3(), exports2);
    __exportStar(require_burn3(), exports2);
    __exportStar(require_closeAccount3(), exports2);
    __exportStar(require_freezeAccount3(), exports2);
    __exportStar(require_thawAccount3(), exports2);
    __exportStar(require_transferChecked3(), exports2);
    __exportStar(require_approveChecked3(), exports2);
    __exportStar(require_mintToChecked3(), exports2);
    __exportStar(require_burnChecked3(), exports2);
    __exportStar(require_initializeAccount22(), exports2);
    __exportStar(require_syncNative3(), exports2);
    __exportStar(require_initializeAccount32(), exports2);
    __exportStar(require_initializeMultisig22(), exports2);
    __exportStar(require_initializeMint22(), exports2);
    __exportStar(require_initializeImmutableOwner2(), exports2);
    __exportStar(require_amountToUiAmount3(), exports2);
    __exportStar(require_uiAmountToAmount3(), exports2);
    __exportStar(require_initializeMintCloseAuthority2(), exports2);
    __exportStar(require_reallocate2(), exports2);
    __exportStar(require_createNativeMint3(), exports2);
    __exportStar(require_initializeNonTransferableMint2(), exports2);
    __exportStar(require_initializePermanentDelegate2(), exports2);
  }
});

// node_modules/@solana/spl-token/lib/cjs/index.js
var require_cjs5 = __commonJS({
  "node_modules/@solana/spl-token/lib/cjs/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_actions17(), exports2);
    __exportStar(require_constants2(), exports2);
    __exportStar(require_errors4(), exports2);
    __exportStar(require_extensions2(), exports2);
    __exportStar(require_instructions20(), exports2);
    __exportStar(require_state26(), exports2);
  }
});

// node_modules/decimal.js/decimal.js
var require_decimal3 = __commonJS({
  "node_modules/decimal.js/decimal.js"(exports2, module2) {
    (function(globalScope) {
      "use strict";
      var EXP_LIMIT2 = 9e15, MAX_DIGITS2 = 1e9, NUMERALS2 = "0123456789abcdef", LN102 = "2.3025850929940456840179914546843642076011014886287729760333279009675726096773524802359972050895982983419677840422862486334095254650828067566662873690987816894829072083255546808437998948262331985283935053089653777326288461633662222876982198867465436674744042432743651550489343149393914796194044002221051017141748003688084012647080685567743216228355220114804663715659121373450747856947683463616792101806445070648000277502684916746550586856935673420670581136429224554405758925724208241314695689016758940256776311356919292033376587141660230105703089634572075440370847469940168269282808481184289314848524948644871927809676271275775397027668605952496716674183485704422507197965004714951050492214776567636938662976979522110718264549734772662425709429322582798502585509785265383207606726317164309505995087807523710333101197857547331541421808427543863591778117054309827482385045648019095610299291824318237525357709750539565187697510374970888692180205189339507238539205144634197265287286965110862571492198849978748873771345686209167058", PI2 = "3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632789", DEFAULTS2 = {
        // These values must be integers within the stated ranges (inclusive).
        // Most of these values can be changed at run-time using the `Decimal.config` method.
        // The maximum number of significant digits of the result of a calculation or base conversion.
        // E.g. `Decimal.config({ precision: 20 });`
        precision: 20,
        // 1 to MAX_DIGITS
        // The rounding mode used when rounding to `precision`.
        //
        // ROUND_UP         0 Away from zero.
        // ROUND_DOWN       1 Towards zero.
        // ROUND_CEIL       2 Towards +Infinity.
        // ROUND_FLOOR      3 Towards -Infinity.
        // ROUND_HALF_UP    4 Towards nearest neighbour. If equidistant, up.
        // ROUND_HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.
        // ROUND_HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.
        // ROUND_HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.
        // ROUND_HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.
        //
        // E.g.
        // `Decimal.rounding = 4;`
        // `Decimal.rounding = Decimal.ROUND_HALF_UP;`
        rounding: 4,
        // 0 to 8
        // The modulo mode used when calculating the modulus: a mod n.
        // The quotient (q = a / n) is calculated according to the corresponding rounding mode.
        // The remainder (r) is calculated as: r = a - n * q.
        //
        // UP         0 The remainder is positive if the dividend is negative, else is negative.
        // DOWN       1 The remainder has the same sign as the dividend (JavaScript %).
        // FLOOR      3 The remainder has the same sign as the divisor (Python %).
        // HALF_EVEN  6 The IEEE 754 remainder function.
        // EUCLID     9 Euclidian division. q = sign(n) * floor(a / abs(n)). Always positive.
        //
        // Truncated division (1), floored division (3), the IEEE 754 remainder (6), and Euclidian
        // division (9) are commonly used for the modulus operation. The other rounding modes can also
        // be used, but they may not give useful results.
        modulo: 1,
        // 0 to 9
        // The exponent value at and beneath which `toString` returns exponential notation.
        // JavaScript numbers: -7
        toExpNeg: -7,
        // 0 to -EXP_LIMIT
        // The exponent value at and above which `toString` returns exponential notation.
        // JavaScript numbers: 21
        toExpPos: 21,
        // 0 to EXP_LIMIT
        // The minimum exponent value, beneath which underflow to zero occurs.
        // JavaScript numbers: -324  (5e-324)
        minE: -EXP_LIMIT2,
        // -1 to -EXP_LIMIT
        // The maximum exponent value, above which overflow to Infinity occurs.
        // JavaScript numbers: 308  (1.7976931348623157e+308)
        maxE: EXP_LIMIT2,
        // 1 to EXP_LIMIT
        // Whether to use cryptographically-secure random number generation, if available.
        crypto: false
        // true/false
      }, Decimal2, inexact2, noConflict, quadrant2, external2 = true, decimalError2 = "[DecimalError] ", invalidArgument2 = decimalError2 + "Invalid argument: ", precisionLimitExceeded2 = decimalError2 + "Precision limit exceeded", cryptoUnavailable2 = decimalError2 + "crypto unavailable", tag2 = "[object Decimal]", mathfloor3 = Math.floor, mathpow2 = Math.pow, isBinary2 = /^0b([01]+(\.[01]*)?|\.[01]+)(p[+-]?\d+)?$/i, isHex2 = /^0x([0-9a-f]+(\.[0-9a-f]*)?|\.[0-9a-f]+)(p[+-]?\d+)?$/i, isOctal2 = /^0o([0-7]+(\.[0-7]*)?|\.[0-7]+)(p[+-]?\d+)?$/i, isDecimal3 = /^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i, BASE3 = 1e7, LOG_BASE3 = 7, MAX_SAFE_INTEGER3 = 9007199254740991, LN10_PRECISION2 = LN102.length - 1, PI_PRECISION2 = PI2.length - 1, P2 = { toStringTag: tag2 };
      P2.absoluteValue = P2.abs = function() {
        var x = new this.constructor(this);
        if (x.s < 0)
          x.s = 1;
        return finalise2(x);
      };
      P2.ceil = function() {
        return finalise2(new this.constructor(this), this.e + 1, 2);
      };
      P2.clampedTo = P2.clamp = function(min3, max3) {
        var k, x = this, Ctor = x.constructor;
        min3 = new Ctor(min3);
        max3 = new Ctor(max3);
        if (!min3.s || !max3.s)
          return new Ctor(NaN);
        if (min3.gt(max3))
          throw Error(invalidArgument2 + max3);
        k = x.cmp(min3);
        return k < 0 ? min3 : x.cmp(max3) > 0 ? max3 : new Ctor(x);
      };
      P2.comparedTo = P2.cmp = function(y) {
        var i, j, xdL, ydL, x = this, xd = x.d, yd = (y = new x.constructor(y)).d, xs = x.s, ys = y.s;
        if (!xd || !yd) {
          return !xs || !ys ? NaN : xs !== ys ? xs : xd === yd ? 0 : !xd ^ xs < 0 ? 1 : -1;
        }
        if (!xd[0] || !yd[0])
          return xd[0] ? xs : yd[0] ? -ys : 0;
        if (xs !== ys)
          return xs;
        if (x.e !== y.e)
          return x.e > y.e ^ xs < 0 ? 1 : -1;
        xdL = xd.length;
        ydL = yd.length;
        for (i = 0, j = xdL < ydL ? xdL : ydL; i < j; ++i) {
          if (xd[i] !== yd[i])
            return xd[i] > yd[i] ^ xs < 0 ? 1 : -1;
        }
        return xdL === ydL ? 0 : xdL > ydL ^ xs < 0 ? 1 : -1;
      };
      P2.cosine = P2.cos = function() {
        var pr, rm, x = this, Ctor = x.constructor;
        if (!x.d)
          return new Ctor(NaN);
        if (!x.d[0])
          return new Ctor(1);
        pr = Ctor.precision;
        rm = Ctor.rounding;
        Ctor.precision = pr + Math.max(x.e, x.sd()) + LOG_BASE3;
        Ctor.rounding = 1;
        x = cosine2(Ctor, toLessThanHalfPi2(Ctor, x));
        Ctor.precision = pr;
        Ctor.rounding = rm;
        return finalise2(quadrant2 == 2 || quadrant2 == 3 ? x.neg() : x, pr, rm, true);
      };
      P2.cubeRoot = P2.cbrt = function() {
        var e, m, n, r, rep, s, sd, t, t3, t3plusx, x = this, Ctor = x.constructor;
        if (!x.isFinite() || x.isZero())
          return new Ctor(x);
        external2 = false;
        s = x.s * mathpow2(x.s * x, 1 / 3);
        if (!s || Math.abs(s) == 1 / 0) {
          n = digitsToString2(x.d);
          e = x.e;
          if (s = (e - n.length + 1) % 3)
            n += s == 1 || s == -2 ? "0" : "00";
          s = mathpow2(n, 1 / 3);
          e = mathfloor3((e + 1) / 3) - (e % 3 == (e < 0 ? -1 : 2));
          if (s == 1 / 0) {
            n = "5e" + e;
          } else {
            n = s.toExponential();
            n = n.slice(0, n.indexOf("e") + 1) + e;
          }
          r = new Ctor(n);
          r.s = x.s;
        } else {
          r = new Ctor(s.toString());
        }
        sd = (e = Ctor.precision) + 3;
        for (; ; ) {
          t = r;
          t3 = t.times(t).times(t);
          t3plusx = t3.plus(x);
          r = divide2(t3plusx.plus(x).times(t), t3plusx.plus(t3), sd + 2, 1);
          if (digitsToString2(t.d).slice(0, sd) === (n = digitsToString2(r.d)).slice(0, sd)) {
            n = n.slice(sd - 3, sd + 1);
            if (n == "9999" || !rep && n == "4999") {
              if (!rep) {
                finalise2(t, e + 1, 0);
                if (t.times(t).times(t).eq(x)) {
                  r = t;
                  break;
                }
              }
              sd += 4;
              rep = 1;
            } else {
              if (!+n || !+n.slice(1) && n.charAt(0) == "5") {
                finalise2(r, e + 1, 1);
                m = !r.times(r).times(r).eq(x);
              }
              break;
            }
          }
        }
        external2 = true;
        return finalise2(r, e, Ctor.rounding, m);
      };
      P2.decimalPlaces = P2.dp = function() {
        var w, d = this.d, n = NaN;
        if (d) {
          w = d.length - 1;
          n = (w - mathfloor3(this.e / LOG_BASE3)) * LOG_BASE3;
          w = d[w];
          if (w)
            for (; w % 10 == 0; w /= 10)
              n--;
          if (n < 0)
            n = 0;
        }
        return n;
      };
      P2.dividedBy = P2.div = function(y) {
        return divide2(this, new this.constructor(y));
      };
      P2.dividedToIntegerBy = P2.divToInt = function(y) {
        var x = this, Ctor = x.constructor;
        return finalise2(divide2(x, new Ctor(y), 0, 1, 1), Ctor.precision, Ctor.rounding);
      };
      P2.equals = P2.eq = function(y) {
        return this.cmp(y) === 0;
      };
      P2.floor = function() {
        return finalise2(new this.constructor(this), this.e + 1, 3);
      };
      P2.greaterThan = P2.gt = function(y) {
        return this.cmp(y) > 0;
      };
      P2.greaterThanOrEqualTo = P2.gte = function(y) {
        var k = this.cmp(y);
        return k == 1 || k === 0;
      };
      P2.hyperbolicCosine = P2.cosh = function() {
        var k, n, pr, rm, len, x = this, Ctor = x.constructor, one = new Ctor(1);
        if (!x.isFinite())
          return new Ctor(x.s ? 1 / 0 : NaN);
        if (x.isZero())
          return one;
        pr = Ctor.precision;
        rm = Ctor.rounding;
        Ctor.precision = pr + Math.max(x.e, x.sd()) + 4;
        Ctor.rounding = 1;
        len = x.d.length;
        if (len < 32) {
          k = Math.ceil(len / 3);
          n = (1 / tinyPow2(4, k)).toString();
        } else {
          k = 16;
          n = "2.3283064365386962890625e-10";
        }
        x = taylorSeries2(Ctor, 1, x.times(n), new Ctor(1), true);
        var cosh2_x, i = k, d8 = new Ctor(8);
        for (; i--; ) {
          cosh2_x = x.times(x);
          x = one.minus(cosh2_x.times(d8.minus(cosh2_x.times(d8))));
        }
        return finalise2(x, Ctor.precision = pr, Ctor.rounding = rm, true);
      };
      P2.hyperbolicSine = P2.sinh = function() {
        var k, pr, rm, len, x = this, Ctor = x.constructor;
        if (!x.isFinite() || x.isZero())
          return new Ctor(x);
        pr = Ctor.precision;
        rm = Ctor.rounding;
        Ctor.precision = pr + Math.max(x.e, x.sd()) + 4;
        Ctor.rounding = 1;
        len = x.d.length;
        if (len < 3) {
          x = taylorSeries2(Ctor, 2, x, x, true);
        } else {
          k = 1.4 * Math.sqrt(len);
          k = k > 16 ? 16 : k | 0;
          x = x.times(1 / tinyPow2(5, k));
          x = taylorSeries2(Ctor, 2, x, x, true);
          var sinh2_x, d5 = new Ctor(5), d16 = new Ctor(16), d20 = new Ctor(20);
          for (; k--; ) {
            sinh2_x = x.times(x);
            x = x.times(d5.plus(sinh2_x.times(d16.times(sinh2_x).plus(d20))));
          }
        }
        Ctor.precision = pr;
        Ctor.rounding = rm;
        return finalise2(x, pr, rm, true);
      };
      P2.hyperbolicTangent = P2.tanh = function() {
        var pr, rm, x = this, Ctor = x.constructor;
        if (!x.isFinite())
          return new Ctor(x.s);
        if (x.isZero())
          return new Ctor(x);
        pr = Ctor.precision;
        rm = Ctor.rounding;
        Ctor.precision = pr + 7;
        Ctor.rounding = 1;
        return divide2(x.sinh(), x.cosh(), Ctor.precision = pr, Ctor.rounding = rm);
      };
      P2.inverseCosine = P2.acos = function() {
        var x = this, Ctor = x.constructor, k = x.abs().cmp(1), pr = Ctor.precision, rm = Ctor.rounding;
        if (k !== -1) {
          return k === 0 ? x.isNeg() ? getPi2(Ctor, pr, rm) : new Ctor(0) : new Ctor(NaN);
        }
        if (x.isZero())
          return getPi2(Ctor, pr + 4, rm).times(0.5);
        Ctor.precision = pr + 6;
        Ctor.rounding = 1;
        x = new Ctor(1).minus(x).div(x.plus(1)).sqrt().atan();
        Ctor.precision = pr;
        Ctor.rounding = rm;
        return x.times(2);
      };
      P2.inverseHyperbolicCosine = P2.acosh = function() {
        var pr, rm, x = this, Ctor = x.constructor;
        if (x.lte(1))
          return new Ctor(x.eq(1) ? 0 : NaN);
        if (!x.isFinite())
          return new Ctor(x);
        pr = Ctor.precision;
        rm = Ctor.rounding;
        Ctor.precision = pr + Math.max(Math.abs(x.e), x.sd()) + 4;
        Ctor.rounding = 1;
        external2 = false;
        x = x.times(x).minus(1).sqrt().plus(x);
        external2 = true;
        Ctor.precision = pr;
        Ctor.rounding = rm;
        return x.ln();
      };
      P2.inverseHyperbolicSine = P2.asinh = function() {
        var pr, rm, x = this, Ctor = x.constructor;
        if (!x.isFinite() || x.isZero())
          return new Ctor(x);
        pr = Ctor.precision;
        rm = Ctor.rounding;
        Ctor.precision = pr + 2 * Math.max(Math.abs(x.e), x.sd()) + 6;
        Ctor.rounding = 1;
        external2 = false;
        x = x.times(x).plus(1).sqrt().plus(x);
        external2 = true;
        Ctor.precision = pr;
        Ctor.rounding = rm;
        return x.ln();
      };
      P2.inverseHyperbolicTangent = P2.atanh = function() {
        var pr, rm, wpr, xsd, x = this, Ctor = x.constructor;
        if (!x.isFinite())
          return new Ctor(NaN);
        if (x.e >= 0)
          return new Ctor(x.abs().eq(1) ? x.s / 0 : x.isZero() ? x : NaN);
        pr = Ctor.precision;
        rm = Ctor.rounding;
        xsd = x.sd();
        if (Math.max(xsd, pr) < 2 * -x.e - 1)
          return finalise2(new Ctor(x), pr, rm, true);
        Ctor.precision = wpr = xsd - x.e;
        x = divide2(x.plus(1), new Ctor(1).minus(x), wpr + pr, 1);
        Ctor.precision = pr + 4;
        Ctor.rounding = 1;
        x = x.ln();
        Ctor.precision = pr;
        Ctor.rounding = rm;
        return x.times(0.5);
      };
      P2.inverseSine = P2.asin = function() {
        var halfPi, k, pr, rm, x = this, Ctor = x.constructor;
        if (x.isZero())
          return new Ctor(x);
        k = x.abs().cmp(1);
        pr = Ctor.precision;
        rm = Ctor.rounding;
        if (k !== -1) {
          if (k === 0) {
            halfPi = getPi2(Ctor, pr + 4, rm).times(0.5);
            halfPi.s = x.s;
            return halfPi;
          }
          return new Ctor(NaN);
        }
        Ctor.precision = pr + 6;
        Ctor.rounding = 1;
        x = x.div(new Ctor(1).minus(x.times(x)).sqrt().plus(1)).atan();
        Ctor.precision = pr;
        Ctor.rounding = rm;
        return x.times(2);
      };
      P2.inverseTangent = P2.atan = function() {
        var i, j, k, n, px, t, r, wpr, x2, x = this, Ctor = x.constructor, pr = Ctor.precision, rm = Ctor.rounding;
        if (!x.isFinite()) {
          if (!x.s)
            return new Ctor(NaN);
          if (pr + 4 <= PI_PRECISION2) {
            r = getPi2(Ctor, pr + 4, rm).times(0.5);
            r.s = x.s;
            return r;
          }
        } else if (x.isZero()) {
          return new Ctor(x);
        } else if (x.abs().eq(1) && pr + 4 <= PI_PRECISION2) {
          r = getPi2(Ctor, pr + 4, rm).times(0.25);
          r.s = x.s;
          return r;
        }
        Ctor.precision = wpr = pr + 10;
        Ctor.rounding = 1;
        k = Math.min(28, wpr / LOG_BASE3 + 2 | 0);
        for (i = k; i; --i)
          x = x.div(x.times(x).plus(1).sqrt().plus(1));
        external2 = false;
        j = Math.ceil(wpr / LOG_BASE3);
        n = 1;
        x2 = x.times(x);
        r = new Ctor(x);
        px = x;
        for (; i !== -1; ) {
          px = px.times(x2);
          t = r.minus(px.div(n += 2));
          px = px.times(x2);
          r = t.plus(px.div(n += 2));
          if (r.d[j] !== void 0)
            for (i = j; r.d[i] === t.d[i] && i--; )
              ;
        }
        if (k)
          r = r.times(2 << k - 1);
        external2 = true;
        return finalise2(r, Ctor.precision = pr, Ctor.rounding = rm, true);
      };
      P2.isFinite = function() {
        return !!this.d;
      };
      P2.isInteger = P2.isInt = function() {
        return !!this.d && mathfloor3(this.e / LOG_BASE3) > this.d.length - 2;
      };
      P2.isNaN = function() {
        return !this.s;
      };
      P2.isNegative = P2.isNeg = function() {
        return this.s < 0;
      };
      P2.isPositive = P2.isPos = function() {
        return this.s > 0;
      };
      P2.isZero = function() {
        return !!this.d && this.d[0] === 0;
      };
      P2.lessThan = P2.lt = function(y) {
        return this.cmp(y) < 0;
      };
      P2.lessThanOrEqualTo = P2.lte = function(y) {
        return this.cmp(y) < 1;
      };
      P2.logarithm = P2.log = function(base) {
        var isBase10, d, denominator, k, inf, num, sd, r, arg = this, Ctor = arg.constructor, pr = Ctor.precision, rm = Ctor.rounding, guard = 5;
        if (base == null) {
          base = new Ctor(10);
          isBase10 = true;
        } else {
          base = new Ctor(base);
          d = base.d;
          if (base.s < 0 || !d || !d[0] || base.eq(1))
            return new Ctor(NaN);
          isBase10 = base.eq(10);
        }
        d = arg.d;
        if (arg.s < 0 || !d || !d[0] || arg.eq(1)) {
          return new Ctor(d && !d[0] ? -1 / 0 : arg.s != 1 ? NaN : d ? 0 : 1 / 0);
        }
        if (isBase10) {
          if (d.length > 1) {
            inf = true;
          } else {
            for (k = d[0]; k % 10 === 0; )
              k /= 10;
            inf = k !== 1;
          }
        }
        external2 = false;
        sd = pr + guard;
        num = naturalLogarithm2(arg, sd);
        denominator = isBase10 ? getLn102(Ctor, sd + 10) : naturalLogarithm2(base, sd);
        r = divide2(num, denominator, sd, 1);
        if (checkRoundingDigits2(r.d, k = pr, rm)) {
          do {
            sd += 10;
            num = naturalLogarithm2(arg, sd);
            denominator = isBase10 ? getLn102(Ctor, sd + 10) : naturalLogarithm2(base, sd);
            r = divide2(num, denominator, sd, 1);
            if (!inf) {
              if (+digitsToString2(r.d).slice(k + 1, k + 15) + 1 == 1e14) {
                r = finalise2(r, pr + 1, 0);
              }
              break;
            }
          } while (checkRoundingDigits2(r.d, k += 10, rm));
        }
        external2 = true;
        return finalise2(r, pr, rm);
      };
      P2.minus = P2.sub = function(y) {
        var d, e, i, j, k, len, pr, rm, xd, xe, xLTy, yd, x = this, Ctor = x.constructor;
        y = new Ctor(y);
        if (!x.d || !y.d) {
          if (!x.s || !y.s)
            y = new Ctor(NaN);
          else if (x.d)
            y.s = -y.s;
          else
            y = new Ctor(y.d || x.s !== y.s ? x : NaN);
          return y;
        }
        if (x.s != y.s) {
          y.s = -y.s;
          return x.plus(y);
        }
        xd = x.d;
        yd = y.d;
        pr = Ctor.precision;
        rm = Ctor.rounding;
        if (!xd[0] || !yd[0]) {
          if (yd[0])
            y.s = -y.s;
          else if (xd[0])
            y = new Ctor(x);
          else
            return new Ctor(rm === 3 ? -0 : 0);
          return external2 ? finalise2(y, pr, rm) : y;
        }
        e = mathfloor3(y.e / LOG_BASE3);
        xe = mathfloor3(x.e / LOG_BASE3);
        xd = xd.slice();
        k = xe - e;
        if (k) {
          xLTy = k < 0;
          if (xLTy) {
            d = xd;
            k = -k;
            len = yd.length;
          } else {
            d = yd;
            e = xe;
            len = xd.length;
          }
          i = Math.max(Math.ceil(pr / LOG_BASE3), len) + 2;
          if (k > i) {
            k = i;
            d.length = 1;
          }
          d.reverse();
          for (i = k; i--; )
            d.push(0);
          d.reverse();
        } else {
          i = xd.length;
          len = yd.length;
          xLTy = i < len;
          if (xLTy)
            len = i;
          for (i = 0; i < len; i++) {
            if (xd[i] != yd[i]) {
              xLTy = xd[i] < yd[i];
              break;
            }
          }
          k = 0;
        }
        if (xLTy) {
          d = xd;
          xd = yd;
          yd = d;
          y.s = -y.s;
        }
        len = xd.length;
        for (i = yd.length - len; i > 0; --i)
          xd[len++] = 0;
        for (i = yd.length; i > k; ) {
          if (xd[--i] < yd[i]) {
            for (j = i; j && xd[--j] === 0; )
              xd[j] = BASE3 - 1;
            --xd[j];
            xd[i] += BASE3;
          }
          xd[i] -= yd[i];
        }
        for (; xd[--len] === 0; )
          xd.pop();
        for (; xd[0] === 0; xd.shift())
          --e;
        if (!xd[0])
          return new Ctor(rm === 3 ? -0 : 0);
        y.d = xd;
        y.e = getBase10Exponent2(xd, e);
        return external2 ? finalise2(y, pr, rm) : y;
      };
      P2.modulo = P2.mod = function(y) {
        var q, x = this, Ctor = x.constructor;
        y = new Ctor(y);
        if (!x.d || !y.s || y.d && !y.d[0])
          return new Ctor(NaN);
        if (!y.d || x.d && !x.d[0]) {
          return finalise2(new Ctor(x), Ctor.precision, Ctor.rounding);
        }
        external2 = false;
        if (Ctor.modulo == 9) {
          q = divide2(x, y.abs(), 0, 3, 1);
          q.s *= y.s;
        } else {
          q = divide2(x, y, 0, Ctor.modulo, 1);
        }
        q = q.times(y);
        external2 = true;
        return x.minus(q);
      };
      P2.naturalExponential = P2.exp = function() {
        return naturalExponential2(this);
      };
      P2.naturalLogarithm = P2.ln = function() {
        return naturalLogarithm2(this);
      };
      P2.negated = P2.neg = function() {
        var x = new this.constructor(this);
        x.s = -x.s;
        return finalise2(x);
      };
      P2.plus = P2.add = function(y) {
        var carry, d, e, i, k, len, pr, rm, xd, yd, x = this, Ctor = x.constructor;
        y = new Ctor(y);
        if (!x.d || !y.d) {
          if (!x.s || !y.s)
            y = new Ctor(NaN);
          else if (!x.d)
            y = new Ctor(y.d || x.s === y.s ? x : NaN);
          return y;
        }
        if (x.s != y.s) {
          y.s = -y.s;
          return x.minus(y);
        }
        xd = x.d;
        yd = y.d;
        pr = Ctor.precision;
        rm = Ctor.rounding;
        if (!xd[0] || !yd[0]) {
          if (!yd[0])
            y = new Ctor(x);
          return external2 ? finalise2(y, pr, rm) : y;
        }
        k = mathfloor3(x.e / LOG_BASE3);
        e = mathfloor3(y.e / LOG_BASE3);
        xd = xd.slice();
        i = k - e;
        if (i) {
          if (i < 0) {
            d = xd;
            i = -i;
            len = yd.length;
          } else {
            d = yd;
            e = k;
            len = xd.length;
          }
          k = Math.ceil(pr / LOG_BASE3);
          len = k > len ? k + 1 : len + 1;
          if (i > len) {
            i = len;
            d.length = 1;
          }
          d.reverse();
          for (; i--; )
            d.push(0);
          d.reverse();
        }
        len = xd.length;
        i = yd.length;
        if (len - i < 0) {
          i = len;
          d = yd;
          yd = xd;
          xd = d;
        }
        for (carry = 0; i; ) {
          carry = (xd[--i] = xd[i] + yd[i] + carry) / BASE3 | 0;
          xd[i] %= BASE3;
        }
        if (carry) {
          xd.unshift(carry);
          ++e;
        }
        for (len = xd.length; xd[--len] == 0; )
          xd.pop();
        y.d = xd;
        y.e = getBase10Exponent2(xd, e);
        return external2 ? finalise2(y, pr, rm) : y;
      };
      P2.precision = P2.sd = function(z) {
        var k, x = this;
        if (z !== void 0 && z !== !!z && z !== 1 && z !== 0)
          throw Error(invalidArgument2 + z);
        if (x.d) {
          k = getPrecision2(x.d);
          if (z && x.e + 1 > k)
            k = x.e + 1;
        } else {
          k = NaN;
        }
        return k;
      };
      P2.round = function() {
        var x = this, Ctor = x.constructor;
        return finalise2(new Ctor(x), x.e + 1, Ctor.rounding);
      };
      P2.sine = P2.sin = function() {
        var pr, rm, x = this, Ctor = x.constructor;
        if (!x.isFinite())
          return new Ctor(NaN);
        if (x.isZero())
          return new Ctor(x);
        pr = Ctor.precision;
        rm = Ctor.rounding;
        Ctor.precision = pr + Math.max(x.e, x.sd()) + LOG_BASE3;
        Ctor.rounding = 1;
        x = sine2(Ctor, toLessThanHalfPi2(Ctor, x));
        Ctor.precision = pr;
        Ctor.rounding = rm;
        return finalise2(quadrant2 > 2 ? x.neg() : x, pr, rm, true);
      };
      P2.squareRoot = P2.sqrt = function() {
        var m, n, sd, r, rep, t, x = this, d = x.d, e = x.e, s = x.s, Ctor = x.constructor;
        if (s !== 1 || !d || !d[0]) {
          return new Ctor(!s || s < 0 && (!d || d[0]) ? NaN : d ? x : 1 / 0);
        }
        external2 = false;
        s = Math.sqrt(+x);
        if (s == 0 || s == 1 / 0) {
          n = digitsToString2(d);
          if ((n.length + e) % 2 == 0)
            n += "0";
          s = Math.sqrt(n);
          e = mathfloor3((e + 1) / 2) - (e < 0 || e % 2);
          if (s == 1 / 0) {
            n = "5e" + e;
          } else {
            n = s.toExponential();
            n = n.slice(0, n.indexOf("e") + 1) + e;
          }
          r = new Ctor(n);
        } else {
          r = new Ctor(s.toString());
        }
        sd = (e = Ctor.precision) + 3;
        for (; ; ) {
          t = r;
          r = t.plus(divide2(x, t, sd + 2, 1)).times(0.5);
          if (digitsToString2(t.d).slice(0, sd) === (n = digitsToString2(r.d)).slice(0, sd)) {
            n = n.slice(sd - 3, sd + 1);
            if (n == "9999" || !rep && n == "4999") {
              if (!rep) {
                finalise2(t, e + 1, 0);
                if (t.times(t).eq(x)) {
                  r = t;
                  break;
                }
              }
              sd += 4;
              rep = 1;
            } else {
              if (!+n || !+n.slice(1) && n.charAt(0) == "5") {
                finalise2(r, e + 1, 1);
                m = !r.times(r).eq(x);
              }
              break;
            }
          }
        }
        external2 = true;
        return finalise2(r, e, Ctor.rounding, m);
      };
      P2.tangent = P2.tan = function() {
        var pr, rm, x = this, Ctor = x.constructor;
        if (!x.isFinite())
          return new Ctor(NaN);
        if (x.isZero())
          return new Ctor(x);
        pr = Ctor.precision;
        rm = Ctor.rounding;
        Ctor.precision = pr + 10;
        Ctor.rounding = 1;
        x = x.sin();
        x.s = 1;
        x = divide2(x, new Ctor(1).minus(x.times(x)).sqrt(), pr + 10, 0);
        Ctor.precision = pr;
        Ctor.rounding = rm;
        return finalise2(quadrant2 == 2 || quadrant2 == 4 ? x.neg() : x, pr, rm, true);
      };
      P2.times = P2.mul = function(y) {
        var carry, e, i, k, r, rL, t, xdL, ydL, x = this, Ctor = x.constructor, xd = x.d, yd = (y = new Ctor(y)).d;
        y.s *= x.s;
        if (!xd || !xd[0] || !yd || !yd[0]) {
          return new Ctor(!y.s || xd && !xd[0] && !yd || yd && !yd[0] && !xd ? NaN : !xd || !yd ? y.s / 0 : y.s * 0);
        }
        e = mathfloor3(x.e / LOG_BASE3) + mathfloor3(y.e / LOG_BASE3);
        xdL = xd.length;
        ydL = yd.length;
        if (xdL < ydL) {
          r = xd;
          xd = yd;
          yd = r;
          rL = xdL;
          xdL = ydL;
          ydL = rL;
        }
        r = [];
        rL = xdL + ydL;
        for (i = rL; i--; )
          r.push(0);
        for (i = ydL; --i >= 0; ) {
          carry = 0;
          for (k = xdL + i; k > i; ) {
            t = r[k] + yd[i] * xd[k - i - 1] + carry;
            r[k--] = t % BASE3 | 0;
            carry = t / BASE3 | 0;
          }
          r[k] = (r[k] + carry) % BASE3 | 0;
        }
        for (; !r[--rL]; )
          r.pop();
        if (carry)
          ++e;
        else
          r.shift();
        y.d = r;
        y.e = getBase10Exponent2(r, e);
        return external2 ? finalise2(y, Ctor.precision, Ctor.rounding) : y;
      };
      P2.toBinary = function(sd, rm) {
        return toStringBinary2(this, 2, sd, rm);
      };
      P2.toDecimalPlaces = P2.toDP = function(dp, rm) {
        var x = this, Ctor = x.constructor;
        x = new Ctor(x);
        if (dp === void 0)
          return x;
        checkInt322(dp, 0, MAX_DIGITS2);
        if (rm === void 0)
          rm = Ctor.rounding;
        else
          checkInt322(rm, 0, 8);
        return finalise2(x, dp + x.e + 1, rm);
      };
      P2.toExponential = function(dp, rm) {
        var str2, x = this, Ctor = x.constructor;
        if (dp === void 0) {
          str2 = finiteToString2(x, true);
        } else {
          checkInt322(dp, 0, MAX_DIGITS2);
          if (rm === void 0)
            rm = Ctor.rounding;
          else
            checkInt322(rm, 0, 8);
          x = finalise2(new Ctor(x), dp + 1, rm);
          str2 = finiteToString2(x, true, dp + 1);
        }
        return x.isNeg() && !x.isZero() ? "-" + str2 : str2;
      };
      P2.toFixed = function(dp, rm) {
        var str2, y, x = this, Ctor = x.constructor;
        if (dp === void 0) {
          str2 = finiteToString2(x);
        } else {
          checkInt322(dp, 0, MAX_DIGITS2);
          if (rm === void 0)
            rm = Ctor.rounding;
          else
            checkInt322(rm, 0, 8);
          y = finalise2(new Ctor(x), dp + x.e + 1, rm);
          str2 = finiteToString2(y, false, dp + y.e + 1);
        }
        return x.isNeg() && !x.isZero() ? "-" + str2 : str2;
      };
      P2.toFraction = function(maxD) {
        var d, d0, d1, d2, e, k, n, n0, n1, pr, q, r, x = this, xd = x.d, Ctor = x.constructor;
        if (!xd)
          return new Ctor(x);
        n1 = d0 = new Ctor(1);
        d1 = n0 = new Ctor(0);
        d = new Ctor(d1);
        e = d.e = getPrecision2(xd) - x.e - 1;
        k = e % LOG_BASE3;
        d.d[0] = mathpow2(10, k < 0 ? LOG_BASE3 + k : k);
        if (maxD == null) {
          maxD = e > 0 ? d : n1;
        } else {
          n = new Ctor(maxD);
          if (!n.isInt() || n.lt(n1))
            throw Error(invalidArgument2 + n);
          maxD = n.gt(d) ? e > 0 ? d : n1 : n;
        }
        external2 = false;
        n = new Ctor(digitsToString2(xd));
        pr = Ctor.precision;
        Ctor.precision = e = xd.length * LOG_BASE3 * 2;
        for (; ; ) {
          q = divide2(n, d, 0, 1, 1);
          d2 = d0.plus(q.times(d1));
          if (d2.cmp(maxD) == 1)
            break;
          d0 = d1;
          d1 = d2;
          d2 = n1;
          n1 = n0.plus(q.times(d2));
          n0 = d2;
          d2 = d;
          d = n.minus(q.times(d2));
          n = d2;
        }
        d2 = divide2(maxD.minus(d0), d1, 0, 1, 1);
        n0 = n0.plus(d2.times(n1));
        d0 = d0.plus(d2.times(d1));
        n0.s = n1.s = x.s;
        r = divide2(n1, d1, e, 1).minus(x).abs().cmp(divide2(n0, d0, e, 1).minus(x).abs()) < 1 ? [n1, d1] : [n0, d0];
        Ctor.precision = pr;
        external2 = true;
        return r;
      };
      P2.toHexadecimal = P2.toHex = function(sd, rm) {
        return toStringBinary2(this, 16, sd, rm);
      };
      P2.toNearest = function(y, rm) {
        var x = this, Ctor = x.constructor;
        x = new Ctor(x);
        if (y == null) {
          if (!x.d)
            return x;
          y = new Ctor(1);
          rm = Ctor.rounding;
        } else {
          y = new Ctor(y);
          if (rm === void 0) {
            rm = Ctor.rounding;
          } else {
            checkInt322(rm, 0, 8);
          }
          if (!x.d)
            return y.s ? x : y;
          if (!y.d) {
            if (y.s)
              y.s = x.s;
            return y;
          }
        }
        if (y.d[0]) {
          external2 = false;
          x = divide2(x, y, 0, rm, 1).times(y);
          external2 = true;
          finalise2(x);
        } else {
          y.s = x.s;
          x = y;
        }
        return x;
      };
      P2.toNumber = function() {
        return +this;
      };
      P2.toOctal = function(sd, rm) {
        return toStringBinary2(this, 8, sd, rm);
      };
      P2.toPower = P2.pow = function(y) {
        var e, k, pr, r, rm, s, x = this, Ctor = x.constructor, yn = +(y = new Ctor(y));
        if (!x.d || !y.d || !x.d[0] || !y.d[0])
          return new Ctor(mathpow2(+x, yn));
        x = new Ctor(x);
        if (x.eq(1))
          return x;
        pr = Ctor.precision;
        rm = Ctor.rounding;
        if (y.eq(1))
          return finalise2(x, pr, rm);
        e = mathfloor3(y.e / LOG_BASE3);
        if (e >= y.d.length - 1 && (k = yn < 0 ? -yn : yn) <= MAX_SAFE_INTEGER3) {
          r = intPow2(Ctor, x, k, pr);
          return y.s < 0 ? new Ctor(1).div(r) : finalise2(r, pr, rm);
        }
        s = x.s;
        if (s < 0) {
          if (e < y.d.length - 1)
            return new Ctor(NaN);
          if ((y.d[e] & 1) == 0)
            s = 1;
          if (x.e == 0 && x.d[0] == 1 && x.d.length == 1) {
            x.s = s;
            return x;
          }
        }
        k = mathpow2(+x, yn);
        e = k == 0 || !isFinite(k) ? mathfloor3(yn * (Math.log("0." + digitsToString2(x.d)) / Math.LN10 + x.e + 1)) : new Ctor(k + "").e;
        if (e > Ctor.maxE + 1 || e < Ctor.minE - 1)
          return new Ctor(e > 0 ? s / 0 : 0);
        external2 = false;
        Ctor.rounding = x.s = 1;
        k = Math.min(12, (e + "").length);
        r = naturalExponential2(y.times(naturalLogarithm2(x, pr + k)), pr);
        if (r.d) {
          r = finalise2(r, pr + 5, 1);
          if (checkRoundingDigits2(r.d, pr, rm)) {
            e = pr + 10;
            r = finalise2(naturalExponential2(y.times(naturalLogarithm2(x, e + k)), e), e + 5, 1);
            if (+digitsToString2(r.d).slice(pr + 1, pr + 15) + 1 == 1e14) {
              r = finalise2(r, pr + 1, 0);
            }
          }
        }
        r.s = s;
        external2 = true;
        Ctor.rounding = rm;
        return finalise2(r, pr, rm);
      };
      P2.toPrecision = function(sd, rm) {
        var str2, x = this, Ctor = x.constructor;
        if (sd === void 0) {
          str2 = finiteToString2(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);
        } else {
          checkInt322(sd, 1, MAX_DIGITS2);
          if (rm === void 0)
            rm = Ctor.rounding;
          else
            checkInt322(rm, 0, 8);
          x = finalise2(new Ctor(x), sd, rm);
          str2 = finiteToString2(x, sd <= x.e || x.e <= Ctor.toExpNeg, sd);
        }
        return x.isNeg() && !x.isZero() ? "-" + str2 : str2;
      };
      P2.toSignificantDigits = P2.toSD = function(sd, rm) {
        var x = this, Ctor = x.constructor;
        if (sd === void 0) {
          sd = Ctor.precision;
          rm = Ctor.rounding;
        } else {
          checkInt322(sd, 1, MAX_DIGITS2);
          if (rm === void 0)
            rm = Ctor.rounding;
          else
            checkInt322(rm, 0, 8);
        }
        return finalise2(new Ctor(x), sd, rm);
      };
      P2.toString = function() {
        var x = this, Ctor = x.constructor, str2 = finiteToString2(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);
        return x.isNeg() && !x.isZero() ? "-" + str2 : str2;
      };
      P2.truncated = P2.trunc = function() {
        return finalise2(new this.constructor(this), this.e + 1, 1);
      };
      P2.valueOf = P2.toJSON = function() {
        var x = this, Ctor = x.constructor, str2 = finiteToString2(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);
        return x.isNeg() ? "-" + str2 : str2;
      };
      function digitsToString2(d) {
        var i, k, ws, indexOfLastWord = d.length - 1, str2 = "", w = d[0];
        if (indexOfLastWord > 0) {
          str2 += w;
          for (i = 1; i < indexOfLastWord; i++) {
            ws = d[i] + "";
            k = LOG_BASE3 - ws.length;
            if (k)
              str2 += getZeroString2(k);
            str2 += ws;
          }
          w = d[i];
          ws = w + "";
          k = LOG_BASE3 - ws.length;
          if (k)
            str2 += getZeroString2(k);
        } else if (w === 0) {
          return "0";
        }
        for (; w % 10 === 0; )
          w /= 10;
        return str2 + w;
      }
      function checkInt322(i, min3, max3) {
        if (i !== ~~i || i < min3 || i > max3) {
          throw Error(invalidArgument2 + i);
        }
      }
      function checkRoundingDigits2(d, i, rm, repeating) {
        var di, k, r, rd;
        for (k = d[0]; k >= 10; k /= 10)
          --i;
        if (--i < 0) {
          i += LOG_BASE3;
          di = 0;
        } else {
          di = Math.ceil((i + 1) / LOG_BASE3);
          i %= LOG_BASE3;
        }
        k = mathpow2(10, LOG_BASE3 - i);
        rd = d[di] % k | 0;
        if (repeating == null) {
          if (i < 3) {
            if (i == 0)
              rd = rd / 100 | 0;
            else if (i == 1)
              rd = rd / 10 | 0;
            r = rm < 4 && rd == 99999 || rm > 3 && rd == 49999 || rd == 5e4 || rd == 0;
          } else {
            r = (rm < 4 && rd + 1 == k || rm > 3 && rd + 1 == k / 2) && (d[di + 1] / k / 100 | 0) == mathpow2(10, i - 2) - 1 || (rd == k / 2 || rd == 0) && (d[di + 1] / k / 100 | 0) == 0;
          }
        } else {
          if (i < 4) {
            if (i == 0)
              rd = rd / 1e3 | 0;
            else if (i == 1)
              rd = rd / 100 | 0;
            else if (i == 2)
              rd = rd / 10 | 0;
            r = (repeating || rm < 4) && rd == 9999 || !repeating && rm > 3 && rd == 4999;
          } else {
            r = ((repeating || rm < 4) && rd + 1 == k || !repeating && rm > 3 && rd + 1 == k / 2) && (d[di + 1] / k / 1e3 | 0) == mathpow2(10, i - 3) - 1;
          }
        }
        return r;
      }
      function convertBase2(str2, baseIn, baseOut) {
        var j, arr = [0], arrL, i = 0, strL = str2.length;
        for (; i < strL; ) {
          for (arrL = arr.length; arrL--; )
            arr[arrL] *= baseIn;
          arr[0] += NUMERALS2.indexOf(str2.charAt(i++));
          for (j = 0; j < arr.length; j++) {
            if (arr[j] > baseOut - 1) {
              if (arr[j + 1] === void 0)
                arr[j + 1] = 0;
              arr[j + 1] += arr[j] / baseOut | 0;
              arr[j] %= baseOut;
            }
          }
        }
        return arr.reverse();
      }
      function cosine2(Ctor, x) {
        var k, len, y;
        if (x.isZero())
          return x;
        len = x.d.length;
        if (len < 32) {
          k = Math.ceil(len / 3);
          y = (1 / tinyPow2(4, k)).toString();
        } else {
          k = 16;
          y = "2.3283064365386962890625e-10";
        }
        Ctor.precision += k;
        x = taylorSeries2(Ctor, 1, x.times(y), new Ctor(1));
        for (var i = k; i--; ) {
          var cos2x = x.times(x);
          x = cos2x.times(cos2x).minus(cos2x).times(8).plus(1);
        }
        Ctor.precision -= k;
        return x;
      }
      var divide2 = /* @__PURE__ */ function() {
        function multiplyInteger(x, k, base) {
          var temp, carry = 0, i = x.length;
          for (x = x.slice(); i--; ) {
            temp = x[i] * k + carry;
            x[i] = temp % base | 0;
            carry = temp / base | 0;
          }
          if (carry)
            x.unshift(carry);
          return x;
        }
        function compare2(a, b, aL, bL) {
          var i, r;
          if (aL != bL) {
            r = aL > bL ? 1 : -1;
          } else {
            for (i = r = 0; i < aL; i++) {
              if (a[i] != b[i]) {
                r = a[i] > b[i] ? 1 : -1;
                break;
              }
            }
          }
          return r;
        }
        function subtract(a, b, aL, base) {
          var i = 0;
          for (; aL--; ) {
            a[aL] -= i;
            i = a[aL] < b[aL] ? 1 : 0;
            a[aL] = i * base + a[aL] - b[aL];
          }
          for (; !a[0] && a.length > 1; )
            a.shift();
        }
        return function(x, y, pr, rm, dp, base) {
          var cmp, e, i, k, logBase, more, prod, prodL, q, qd, rem, remL, rem0, sd, t, xi, xL, yd0, yL, yz, Ctor = x.constructor, sign3 = x.s == y.s ? 1 : -1, xd = x.d, yd = y.d;
          if (!xd || !xd[0] || !yd || !yd[0]) {
            return new Ctor(
              // Return NaN if either NaN, or both Infinity or 0.
              !x.s || !y.s || (xd ? yd && xd[0] == yd[0] : !yd) ? NaN : (
                // Return 0 if x is 0 or y is Infinity, or return Infinity as y is 0.
                xd && xd[0] == 0 || !yd ? sign3 * 0 : sign3 / 0
              )
            );
          }
          if (base) {
            logBase = 1;
            e = x.e - y.e;
          } else {
            base = BASE3;
            logBase = LOG_BASE3;
            e = mathfloor3(x.e / logBase) - mathfloor3(y.e / logBase);
          }
          yL = yd.length;
          xL = xd.length;
          q = new Ctor(sign3);
          qd = q.d = [];
          for (i = 0; yd[i] == (xd[i] || 0); i++)
            ;
          if (yd[i] > (xd[i] || 0))
            e--;
          if (pr == null) {
            sd = pr = Ctor.precision;
            rm = Ctor.rounding;
          } else if (dp) {
            sd = pr + (x.e - y.e) + 1;
          } else {
            sd = pr;
          }
          if (sd < 0) {
            qd.push(1);
            more = true;
          } else {
            sd = sd / logBase + 2 | 0;
            i = 0;
            if (yL == 1) {
              k = 0;
              yd = yd[0];
              sd++;
              for (; (i < xL || k) && sd--; i++) {
                t = k * base + (xd[i] || 0);
                qd[i] = t / yd | 0;
                k = t % yd | 0;
              }
              more = k || i < xL;
            } else {
              k = base / (yd[0] + 1) | 0;
              if (k > 1) {
                yd = multiplyInteger(yd, k, base);
                xd = multiplyInteger(xd, k, base);
                yL = yd.length;
                xL = xd.length;
              }
              xi = yL;
              rem = xd.slice(0, yL);
              remL = rem.length;
              for (; remL < yL; )
                rem[remL++] = 0;
              yz = yd.slice();
              yz.unshift(0);
              yd0 = yd[0];
              if (yd[1] >= base / 2)
                ++yd0;
              do {
                k = 0;
                cmp = compare2(yd, rem, yL, remL);
                if (cmp < 0) {
                  rem0 = rem[0];
                  if (yL != remL)
                    rem0 = rem0 * base + (rem[1] || 0);
                  k = rem0 / yd0 | 0;
                  if (k > 1) {
                    if (k >= base)
                      k = base - 1;
                    prod = multiplyInteger(yd, k, base);
                    prodL = prod.length;
                    remL = rem.length;
                    cmp = compare2(prod, rem, prodL, remL);
                    if (cmp == 1) {
                      k--;
                      subtract(prod, yL < prodL ? yz : yd, prodL, base);
                    }
                  } else {
                    if (k == 0)
                      cmp = k = 1;
                    prod = yd.slice();
                  }
                  prodL = prod.length;
                  if (prodL < remL)
                    prod.unshift(0);
                  subtract(rem, prod, remL, base);
                  if (cmp == -1) {
                    remL = rem.length;
                    cmp = compare2(yd, rem, yL, remL);
                    if (cmp < 1) {
                      k++;
                      subtract(rem, yL < remL ? yz : yd, remL, base);
                    }
                  }
                  remL = rem.length;
                } else if (cmp === 0) {
                  k++;
                  rem = [0];
                }
                qd[i++] = k;
                if (cmp && rem[0]) {
                  rem[remL++] = xd[xi] || 0;
                } else {
                  rem = [xd[xi]];
                  remL = 1;
                }
              } while ((xi++ < xL || rem[0] !== void 0) && sd--);
              more = rem[0] !== void 0;
            }
            if (!qd[0])
              qd.shift();
          }
          if (logBase == 1) {
            q.e = e;
            inexact2 = more;
          } else {
            for (i = 1, k = qd[0]; k >= 10; k /= 10)
              i++;
            q.e = i + e * logBase - 1;
            finalise2(q, dp ? pr + q.e + 1 : pr, rm, more);
          }
          return q;
        };
      }();
      function finalise2(x, sd, rm, isTruncated) {
        var digits, i, j, k, rd, roundUp, w, xd, xdi, Ctor = x.constructor;
        out:
          if (sd != null) {
            xd = x.d;
            if (!xd)
              return x;
            for (digits = 1, k = xd[0]; k >= 10; k /= 10)
              digits++;
            i = sd - digits;
            if (i < 0) {
              i += LOG_BASE3;
              j = sd;
              w = xd[xdi = 0];
              rd = w / mathpow2(10, digits - j - 1) % 10 | 0;
            } else {
              xdi = Math.ceil((i + 1) / LOG_BASE3);
              k = xd.length;
              if (xdi >= k) {
                if (isTruncated) {
                  for (; k++ <= xdi; )
                    xd.push(0);
                  w = rd = 0;
                  digits = 1;
                  i %= LOG_BASE3;
                  j = i - LOG_BASE3 + 1;
                } else {
                  break out;
                }
              } else {
                w = k = xd[xdi];
                for (digits = 1; k >= 10; k /= 10)
                  digits++;
                i %= LOG_BASE3;
                j = i - LOG_BASE3 + digits;
                rd = j < 0 ? 0 : w / mathpow2(10, digits - j - 1) % 10 | 0;
              }
            }
            isTruncated = isTruncated || sd < 0 || xd[xdi + 1] !== void 0 || (j < 0 ? w : w % mathpow2(10, digits - j - 1));
            roundUp = rm < 4 ? (rd || isTruncated) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : rd > 5 || rd == 5 && (rm == 4 || isTruncated || rm == 6 && // Check whether the digit to the left of the rounding digit is odd.
            (i > 0 ? j > 0 ? w / mathpow2(10, digits - j) : 0 : xd[xdi - 1]) % 10 & 1 || rm == (x.s < 0 ? 8 : 7));
            if (sd < 1 || !xd[0]) {
              xd.length = 0;
              if (roundUp) {
                sd -= x.e + 1;
                xd[0] = mathpow2(10, (LOG_BASE3 - sd % LOG_BASE3) % LOG_BASE3);
                x.e = -sd || 0;
              } else {
                xd[0] = x.e = 0;
              }
              return x;
            }
            if (i == 0) {
              xd.length = xdi;
              k = 1;
              xdi--;
            } else {
              xd.length = xdi + 1;
              k = mathpow2(10, LOG_BASE3 - i);
              xd[xdi] = j > 0 ? (w / mathpow2(10, digits - j) % mathpow2(10, j) | 0) * k : 0;
            }
            if (roundUp) {
              for (; ; ) {
                if (xdi == 0) {
                  for (i = 1, j = xd[0]; j >= 10; j /= 10)
                    i++;
                  j = xd[0] += k;
                  for (k = 1; j >= 10; j /= 10)
                    k++;
                  if (i != k) {
                    x.e++;
                    if (xd[0] == BASE3)
                      xd[0] = 1;
                  }
                  break;
                } else {
                  xd[xdi] += k;
                  if (xd[xdi] != BASE3)
                    break;
                  xd[xdi--] = 0;
                  k = 1;
                }
              }
            }
            for (i = xd.length; xd[--i] === 0; )
              xd.pop();
          }
        if (external2) {
          if (x.e > Ctor.maxE) {
            x.d = null;
            x.e = NaN;
          } else if (x.e < Ctor.minE) {
            x.e = 0;
            x.d = [0];
          }
        }
        return x;
      }
      function finiteToString2(x, isExp, sd) {
        if (!x.isFinite())
          return nonFiniteToString2(x);
        var k, e = x.e, str2 = digitsToString2(x.d), len = str2.length;
        if (isExp) {
          if (sd && (k = sd - len) > 0) {
            str2 = str2.charAt(0) + "." + str2.slice(1) + getZeroString2(k);
          } else if (len > 1) {
            str2 = str2.charAt(0) + "." + str2.slice(1);
          }
          str2 = str2 + (x.e < 0 ? "e" : "e+") + x.e;
        } else if (e < 0) {
          str2 = "0." + getZeroString2(-e - 1) + str2;
          if (sd && (k = sd - len) > 0)
            str2 += getZeroString2(k);
        } else if (e >= len) {
          str2 += getZeroString2(e + 1 - len);
          if (sd && (k = sd - e - 1) > 0)
            str2 = str2 + "." + getZeroString2(k);
        } else {
          if ((k = e + 1) < len)
            str2 = str2.slice(0, k) + "." + str2.slice(k);
          if (sd && (k = sd - len) > 0) {
            if (e + 1 === len)
              str2 += ".";
            str2 += getZeroString2(k);
          }
        }
        return str2;
      }
      function getBase10Exponent2(digits, e) {
        var w = digits[0];
        for (e *= LOG_BASE3; w >= 10; w /= 10)
          e++;
        return e;
      }
      function getLn102(Ctor, sd, pr) {
        if (sd > LN10_PRECISION2) {
          external2 = true;
          if (pr)
            Ctor.precision = pr;
          throw Error(precisionLimitExceeded2);
        }
        return finalise2(new Ctor(LN102), sd, 1, true);
      }
      function getPi2(Ctor, sd, rm) {
        if (sd > PI_PRECISION2)
          throw Error(precisionLimitExceeded2);
        return finalise2(new Ctor(PI2), sd, rm, true);
      }
      function getPrecision2(digits) {
        var w = digits.length - 1, len = w * LOG_BASE3 + 1;
        w = digits[w];
        if (w) {
          for (; w % 10 == 0; w /= 10)
            len--;
          for (w = digits[0]; w >= 10; w /= 10)
            len++;
        }
        return len;
      }
      function getZeroString2(k) {
        var zs = "";
        for (; k--; )
          zs += "0";
        return zs;
      }
      function intPow2(Ctor, x, n, pr) {
        var isTruncated, r = new Ctor(1), k = Math.ceil(pr / LOG_BASE3 + 4);
        external2 = false;
        for (; ; ) {
          if (n % 2) {
            r = r.times(x);
            if (truncate2(r.d, k))
              isTruncated = true;
          }
          n = mathfloor3(n / 2);
          if (n === 0) {
            n = r.d.length - 1;
            if (isTruncated && r.d[n] === 0)
              ++r.d[n];
            break;
          }
          x = x.times(x);
          truncate2(x.d, k);
        }
        external2 = true;
        return r;
      }
      function isOdd3(n) {
        return n.d[n.d.length - 1] & 1;
      }
      function maxOrMin2(Ctor, args, n) {
        var k, y, x = new Ctor(args[0]), i = 0;
        for (; ++i < args.length; ) {
          y = new Ctor(args[i]);
          if (!y.s) {
            x = y;
            break;
          }
          k = x.cmp(y);
          if (k === n || k === 0 && x.s === n) {
            x = y;
          }
        }
        return x;
      }
      function naturalExponential2(x, sd) {
        var denominator, guard, j, pow3, sum3, t, wpr, rep = 0, i = 0, k = 0, Ctor = x.constructor, rm = Ctor.rounding, pr = Ctor.precision;
        if (!x.d || !x.d[0] || x.e > 17) {
          return new Ctor(x.d ? !x.d[0] ? 1 : x.s < 0 ? 0 : 1 / 0 : x.s ? x.s < 0 ? 0 : x : 0 / 0);
        }
        if (sd == null) {
          external2 = false;
          wpr = pr;
        } else {
          wpr = sd;
        }
        t = new Ctor(0.03125);
        while (x.e > -2) {
          x = x.times(t);
          k += 5;
        }
        guard = Math.log(mathpow2(2, k)) / Math.LN10 * 2 + 5 | 0;
        wpr += guard;
        denominator = pow3 = sum3 = new Ctor(1);
        Ctor.precision = wpr;
        for (; ; ) {
          pow3 = finalise2(pow3.times(x), wpr, 1);
          denominator = denominator.times(++i);
          t = sum3.plus(divide2(pow3, denominator, wpr, 1));
          if (digitsToString2(t.d).slice(0, wpr) === digitsToString2(sum3.d).slice(0, wpr)) {
            j = k;
            while (j--)
              sum3 = finalise2(sum3.times(sum3), wpr, 1);
            if (sd == null) {
              if (rep < 3 && checkRoundingDigits2(sum3.d, wpr - guard, rm, rep)) {
                Ctor.precision = wpr += 10;
                denominator = pow3 = t = new Ctor(1);
                i = 0;
                rep++;
              } else {
                return finalise2(sum3, Ctor.precision = pr, rm, external2 = true);
              }
            } else {
              Ctor.precision = pr;
              return sum3;
            }
          }
          sum3 = t;
        }
      }
      function naturalLogarithm2(y, sd) {
        var c, c0, denominator, e, numerator, rep, sum3, t, wpr, x1, x2, n = 1, guard = 10, x = y, xd = x.d, Ctor = x.constructor, rm = Ctor.rounding, pr = Ctor.precision;
        if (x.s < 0 || !xd || !xd[0] || !x.e && xd[0] == 1 && xd.length == 1) {
          return new Ctor(xd && !xd[0] ? -1 / 0 : x.s != 1 ? NaN : xd ? 0 : x);
        }
        if (sd == null) {
          external2 = false;
          wpr = pr;
        } else {
          wpr = sd;
        }
        Ctor.precision = wpr += guard;
        c = digitsToString2(xd);
        c0 = c.charAt(0);
        if (Math.abs(e = x.e) < 15e14) {
          while (c0 < 7 && c0 != 1 || c0 == 1 && c.charAt(1) > 3) {
            x = x.times(y);
            c = digitsToString2(x.d);
            c0 = c.charAt(0);
            n++;
          }
          e = x.e;
          if (c0 > 1) {
            x = new Ctor("0." + c);
            e++;
          } else {
            x = new Ctor(c0 + "." + c.slice(1));
          }
        } else {
          t = getLn102(Ctor, wpr + 2, pr).times(e + "");
          x = naturalLogarithm2(new Ctor(c0 + "." + c.slice(1)), wpr - guard).plus(t);
          Ctor.precision = pr;
          return sd == null ? finalise2(x, pr, rm, external2 = true) : x;
        }
        x1 = x;
        sum3 = numerator = x = divide2(x.minus(1), x.plus(1), wpr, 1);
        x2 = finalise2(x.times(x), wpr, 1);
        denominator = 3;
        for (; ; ) {
          numerator = finalise2(numerator.times(x2), wpr, 1);
          t = sum3.plus(divide2(numerator, new Ctor(denominator), wpr, 1));
          if (digitsToString2(t.d).slice(0, wpr) === digitsToString2(sum3.d).slice(0, wpr)) {
            sum3 = sum3.times(2);
            if (e !== 0)
              sum3 = sum3.plus(getLn102(Ctor, wpr + 2, pr).times(e + ""));
            sum3 = divide2(sum3, new Ctor(n), wpr, 1);
            if (sd == null) {
              if (checkRoundingDigits2(sum3.d, wpr - guard, rm, rep)) {
                Ctor.precision = wpr += guard;
                t = numerator = x = divide2(x1.minus(1), x1.plus(1), wpr, 1);
                x2 = finalise2(x.times(x), wpr, 1);
                denominator = rep = 1;
              } else {
                return finalise2(sum3, Ctor.precision = pr, rm, external2 = true);
              }
            } else {
              Ctor.precision = pr;
              return sum3;
            }
          }
          sum3 = t;
          denominator += 2;
        }
      }
      function nonFiniteToString2(x) {
        return String(x.s * x.s / 0);
      }
      function parseDecimal2(x, str2) {
        var e, i, len;
        if ((e = str2.indexOf(".")) > -1)
          str2 = str2.replace(".", "");
        if ((i = str2.search(/e/i)) > 0) {
          if (e < 0)
            e = i;
          e += +str2.slice(i + 1);
          str2 = str2.substring(0, i);
        } else if (e < 0) {
          e = str2.length;
        }
        for (i = 0; str2.charCodeAt(i) === 48; i++)
          ;
        for (len = str2.length; str2.charCodeAt(len - 1) === 48; --len)
          ;
        str2 = str2.slice(i, len);
        if (str2) {
          len -= i;
          x.e = e = e - i - 1;
          x.d = [];
          i = (e + 1) % LOG_BASE3;
          if (e < 0)
            i += LOG_BASE3;
          if (i < len) {
            if (i)
              x.d.push(+str2.slice(0, i));
            for (len -= LOG_BASE3; i < len; )
              x.d.push(+str2.slice(i, i += LOG_BASE3));
            str2 = str2.slice(i);
            i = LOG_BASE3 - str2.length;
          } else {
            i -= len;
          }
          for (; i--; )
            str2 += "0";
          x.d.push(+str2);
          if (external2) {
            if (x.e > x.constructor.maxE) {
              x.d = null;
              x.e = NaN;
            } else if (x.e < x.constructor.minE) {
              x.e = 0;
              x.d = [0];
            }
          }
        } else {
          x.e = 0;
          x.d = [0];
        }
        return x;
      }
      function parseOther2(x, str2) {
        var base, Ctor, divisor, i, isFloat, len, p, xd, xe;
        if (str2.indexOf("_") > -1) {
          str2 = str2.replace(/(\d)_(?=\d)/g, "$1");
          if (isDecimal3.test(str2))
            return parseDecimal2(x, str2);
        } else if (str2 === "Infinity" || str2 === "NaN") {
          if (!+str2)
            x.s = NaN;
          x.e = NaN;
          x.d = null;
          return x;
        }
        if (isHex2.test(str2)) {
          base = 16;
          str2 = str2.toLowerCase();
        } else if (isBinary2.test(str2)) {
          base = 2;
        } else if (isOctal2.test(str2)) {
          base = 8;
        } else {
          throw Error(invalidArgument2 + str2);
        }
        i = str2.search(/p/i);
        if (i > 0) {
          p = +str2.slice(i + 1);
          str2 = str2.substring(2, i);
        } else {
          str2 = str2.slice(2);
        }
        i = str2.indexOf(".");
        isFloat = i >= 0;
        Ctor = x.constructor;
        if (isFloat) {
          str2 = str2.replace(".", "");
          len = str2.length;
          i = len - i;
          divisor = intPow2(Ctor, new Ctor(base), i, i * 2);
        }
        xd = convertBase2(str2, base, BASE3);
        xe = xd.length - 1;
        for (i = xe; xd[i] === 0; --i)
          xd.pop();
        if (i < 0)
          return new Ctor(x.s * 0);
        x.e = getBase10Exponent2(xd, xe);
        x.d = xd;
        external2 = false;
        if (isFloat)
          x = divide2(x, divisor, len * 4);
        if (p)
          x = x.times(Math.abs(p) < 54 ? mathpow2(2, p) : Decimal2.pow(2, p));
        external2 = true;
        return x;
      }
      function sine2(Ctor, x) {
        var k, len = x.d.length;
        if (len < 3) {
          return x.isZero() ? x : taylorSeries2(Ctor, 2, x, x);
        }
        k = 1.4 * Math.sqrt(len);
        k = k > 16 ? 16 : k | 0;
        x = x.times(1 / tinyPow2(5, k));
        x = taylorSeries2(Ctor, 2, x, x);
        var sin2_x, d5 = new Ctor(5), d16 = new Ctor(16), d20 = new Ctor(20);
        for (; k--; ) {
          sin2_x = x.times(x);
          x = x.times(d5.plus(sin2_x.times(d16.times(sin2_x).minus(d20))));
        }
        return x;
      }
      function taylorSeries2(Ctor, n, x, y, isHyperbolic) {
        var j, t, u, x2, i = 1, pr = Ctor.precision, k = Math.ceil(pr / LOG_BASE3);
        external2 = false;
        x2 = x.times(x);
        u = new Ctor(y);
        for (; ; ) {
          t = divide2(u.times(x2), new Ctor(n++ * n++), pr, 1);
          u = isHyperbolic ? y.plus(t) : y.minus(t);
          y = divide2(t.times(x2), new Ctor(n++ * n++), pr, 1);
          t = u.plus(y);
          if (t.d[k] !== void 0) {
            for (j = k; t.d[j] === u.d[j] && j--; )
              ;
            if (j == -1)
              break;
          }
          j = u;
          u = y;
          y = t;
          t = j;
          i++;
        }
        external2 = true;
        t.d.length = k + 1;
        return t;
      }
      function tinyPow2(b, e) {
        var n = b;
        while (--e)
          n *= b;
        return n;
      }
      function toLessThanHalfPi2(Ctor, x) {
        var t, isNeg = x.s < 0, pi = getPi2(Ctor, Ctor.precision, 1), halfPi = pi.times(0.5);
        x = x.abs();
        if (x.lte(halfPi)) {
          quadrant2 = isNeg ? 4 : 1;
          return x;
        }
        t = x.divToInt(pi);
        if (t.isZero()) {
          quadrant2 = isNeg ? 3 : 2;
        } else {
          x = x.minus(t.times(pi));
          if (x.lte(halfPi)) {
            quadrant2 = isOdd3(t) ? isNeg ? 2 : 3 : isNeg ? 4 : 1;
            return x;
          }
          quadrant2 = isOdd3(t) ? isNeg ? 1 : 4 : isNeg ? 3 : 2;
        }
        return x.minus(pi).abs();
      }
      function toStringBinary2(x, baseOut, sd, rm) {
        var base, e, i, k, len, roundUp, str2, xd, y, Ctor = x.constructor, isExp = sd !== void 0;
        if (isExp) {
          checkInt322(sd, 1, MAX_DIGITS2);
          if (rm === void 0)
            rm = Ctor.rounding;
          else
            checkInt322(rm, 0, 8);
        } else {
          sd = Ctor.precision;
          rm = Ctor.rounding;
        }
        if (!x.isFinite()) {
          str2 = nonFiniteToString2(x);
        } else {
          str2 = finiteToString2(x);
          i = str2.indexOf(".");
          if (isExp) {
            base = 2;
            if (baseOut == 16) {
              sd = sd * 4 - 3;
            } else if (baseOut == 8) {
              sd = sd * 3 - 2;
            }
          } else {
            base = baseOut;
          }
          if (i >= 0) {
            str2 = str2.replace(".", "");
            y = new Ctor(1);
            y.e = str2.length - i;
            y.d = convertBase2(finiteToString2(y), 10, base);
            y.e = y.d.length;
          }
          xd = convertBase2(str2, 10, base);
          e = len = xd.length;
          for (; xd[--len] == 0; )
            xd.pop();
          if (!xd[0]) {
            str2 = isExp ? "0p+0" : "0";
          } else {
            if (i < 0) {
              e--;
            } else {
              x = new Ctor(x);
              x.d = xd;
              x.e = e;
              x = divide2(x, y, sd, rm, 0, base);
              xd = x.d;
              e = x.e;
              roundUp = inexact2;
            }
            i = xd[sd];
            k = base / 2;
            roundUp = roundUp || xd[sd + 1] !== void 0;
            roundUp = rm < 4 ? (i !== void 0 || roundUp) && (rm === 0 || rm === (x.s < 0 ? 3 : 2)) : i > k || i === k && (rm === 4 || roundUp || rm === 6 && xd[sd - 1] & 1 || rm === (x.s < 0 ? 8 : 7));
            xd.length = sd;
            if (roundUp) {
              for (; ++xd[--sd] > base - 1; ) {
                xd[sd] = 0;
                if (!sd) {
                  ++e;
                  xd.unshift(1);
                }
              }
            }
            for (len = xd.length; !xd[len - 1]; --len)
              ;
            for (i = 0, str2 = ""; i < len; i++)
              str2 += NUMERALS2.charAt(xd[i]);
            if (isExp) {
              if (len > 1) {
                if (baseOut == 16 || baseOut == 8) {
                  i = baseOut == 16 ? 4 : 3;
                  for (--len; len % i; len++)
                    str2 += "0";
                  xd = convertBase2(str2, base, baseOut);
                  for (len = xd.length; !xd[len - 1]; --len)
                    ;
                  for (i = 1, str2 = "1."; i < len; i++)
                    str2 += NUMERALS2.charAt(xd[i]);
                } else {
                  str2 = str2.charAt(0) + "." + str2.slice(1);
                }
              }
              str2 = str2 + (e < 0 ? "p" : "p+") + e;
            } else if (e < 0) {
              for (; ++e; )
                str2 = "0" + str2;
              str2 = "0." + str2;
            } else {
              if (++e > len)
                for (e -= len; e--; )
                  str2 += "0";
              else if (e < len)
                str2 = str2.slice(0, e) + "." + str2.slice(e);
            }
          }
          str2 = (baseOut == 16 ? "0x" : baseOut == 2 ? "0b" : baseOut == 8 ? "0o" : "") + str2;
        }
        return x.s < 0 ? "-" + str2 : str2;
      }
      function truncate2(arr, len) {
        if (arr.length > len) {
          arr.length = len;
          return true;
        }
      }
      function abs2(x) {
        return new this(x).abs();
      }
      function acos2(x) {
        return new this(x).acos();
      }
      function acosh2(x) {
        return new this(x).acosh();
      }
      function add3(x, y) {
        return new this(x).plus(y);
      }
      function asin2(x) {
        return new this(x).asin();
      }
      function asinh2(x) {
        return new this(x).asinh();
      }
      function atan3(x) {
        return new this(x).atan();
      }
      function atanh2(x) {
        return new this(x).atanh();
      }
      function atan22(y, x) {
        y = new this(y);
        x = new this(x);
        var r, pr = this.precision, rm = this.rounding, wpr = pr + 4;
        if (!y.s || !x.s) {
          r = new this(NaN);
        } else if (!y.d && !x.d) {
          r = getPi2(this, wpr, 1).times(x.s > 0 ? 0.25 : 0.75);
          r.s = y.s;
        } else if (!x.d || y.isZero()) {
          r = x.s < 0 ? getPi2(this, pr, rm) : new this(0);
          r.s = y.s;
        } else if (!y.d || x.isZero()) {
          r = getPi2(this, wpr, 1).times(0.5);
          r.s = y.s;
        } else if (x.s < 0) {
          this.precision = wpr;
          this.rounding = 1;
          r = this.atan(divide2(y, x, wpr, 1));
          x = getPi2(this, wpr, 1);
          this.precision = pr;
          this.rounding = rm;
          r = y.s < 0 ? r.minus(x) : r.plus(x);
        } else {
          r = this.atan(divide2(y, x, wpr, 1));
        }
        return r;
      }
      function cbrt2(x) {
        return new this(x).cbrt();
      }
      function ceil2(x) {
        return finalise2(x = new this(x), x.e + 1, 2);
      }
      function clamp2(x, min3, max3) {
        return new this(x).clamp(min3, max3);
      }
      function config2(obj) {
        if (!obj || typeof obj !== "object")
          throw Error(decimalError2 + "Object expected");
        var i, p, v, useDefaults = obj.defaults === true, ps = [
          "precision",
          1,
          MAX_DIGITS2,
          "rounding",
          0,
          8,
          "toExpNeg",
          -EXP_LIMIT2,
          0,
          "toExpPos",
          0,
          EXP_LIMIT2,
          "maxE",
          0,
          EXP_LIMIT2,
          "minE",
          -EXP_LIMIT2,
          0,
          "modulo",
          0,
          9
        ];
        for (i = 0; i < ps.length; i += 3) {
          if (p = ps[i], useDefaults)
            this[p] = DEFAULTS2[p];
          if ((v = obj[p]) !== void 0) {
            if (mathfloor3(v) === v && v >= ps[i + 1] && v <= ps[i + 2])
              this[p] = v;
            else
              throw Error(invalidArgument2 + p + ": " + v);
          }
        }
        if (p = "crypto", useDefaults)
          this[p] = DEFAULTS2[p];
        if ((v = obj[p]) !== void 0) {
          if (v === true || v === false || v === 0 || v === 1) {
            if (v) {
              if (typeof crypto != "undefined" && crypto && (crypto.getRandomValues || crypto.randomBytes)) {
                this[p] = true;
              } else {
                throw Error(cryptoUnavailable2);
              }
            } else {
              this[p] = false;
            }
          } else {
            throw Error(invalidArgument2 + p + ": " + v);
          }
        }
        return this;
      }
      function cos2(x) {
        return new this(x).cos();
      }
      function cosh2(x) {
        return new this(x).cosh();
      }
      function clone3(obj) {
        var i, p, ps;
        function Decimal3(v) {
          var e, i2, t, x = this;
          if (!(x instanceof Decimal3))
            return new Decimal3(v);
          x.constructor = Decimal3;
          if (isDecimalInstance2(v)) {
            x.s = v.s;
            if (external2) {
              if (!v.d || v.e > Decimal3.maxE) {
                x.e = NaN;
                x.d = null;
              } else if (v.e < Decimal3.minE) {
                x.e = 0;
                x.d = [0];
              } else {
                x.e = v.e;
                x.d = v.d.slice();
              }
            } else {
              x.e = v.e;
              x.d = v.d ? v.d.slice() : v.d;
            }
            return;
          }
          t = typeof v;
          if (t === "number") {
            if (v === 0) {
              x.s = 1 / v < 0 ? -1 : 1;
              x.e = 0;
              x.d = [0];
              return;
            }
            if (v < 0) {
              v = -v;
              x.s = -1;
            } else {
              x.s = 1;
            }
            if (v === ~~v && v < 1e7) {
              for (e = 0, i2 = v; i2 >= 10; i2 /= 10)
                e++;
              if (external2) {
                if (e > Decimal3.maxE) {
                  x.e = NaN;
                  x.d = null;
                } else if (e < Decimal3.minE) {
                  x.e = 0;
                  x.d = [0];
                } else {
                  x.e = e;
                  x.d = [v];
                }
              } else {
                x.e = e;
                x.d = [v];
              }
              return;
            }
            if (v * 0 !== 0) {
              if (!v)
                x.s = NaN;
              x.e = NaN;
              x.d = null;
              return;
            }
            return parseDecimal2(x, v.toString());
          }
          if (t === "string") {
            if ((i2 = v.charCodeAt(0)) === 45) {
              v = v.slice(1);
              x.s = -1;
            } else {
              if (i2 === 43)
                v = v.slice(1);
              x.s = 1;
            }
            return isDecimal3.test(v) ? parseDecimal2(x, v) : parseOther2(x, v);
          }
          if (t === "bigint") {
            if (v < 0) {
              v = -v;
              x.s = -1;
            } else {
              x.s = 1;
            }
            return parseDecimal2(x, v.toString());
          }
          throw Error(invalidArgument2 + v);
        }
        Decimal3.prototype = P2;
        Decimal3.ROUND_UP = 0;
        Decimal3.ROUND_DOWN = 1;
        Decimal3.ROUND_CEIL = 2;
        Decimal3.ROUND_FLOOR = 3;
        Decimal3.ROUND_HALF_UP = 4;
        Decimal3.ROUND_HALF_DOWN = 5;
        Decimal3.ROUND_HALF_EVEN = 6;
        Decimal3.ROUND_HALF_CEIL = 7;
        Decimal3.ROUND_HALF_FLOOR = 8;
        Decimal3.EUCLID = 9;
        Decimal3.config = Decimal3.set = config2;
        Decimal3.clone = clone3;
        Decimal3.isDecimal = isDecimalInstance2;
        Decimal3.abs = abs2;
        Decimal3.acos = acos2;
        Decimal3.acosh = acosh2;
        Decimal3.add = add3;
        Decimal3.asin = asin2;
        Decimal3.asinh = asinh2;
        Decimal3.atan = atan3;
        Decimal3.atanh = atanh2;
        Decimal3.atan2 = atan22;
        Decimal3.cbrt = cbrt2;
        Decimal3.ceil = ceil2;
        Decimal3.clamp = clamp2;
        Decimal3.cos = cos2;
        Decimal3.cosh = cosh2;
        Decimal3.div = div3;
        Decimal3.exp = exp2;
        Decimal3.floor = floor2;
        Decimal3.hypot = hypot2;
        Decimal3.ln = ln2;
        Decimal3.log = log3;
        Decimal3.log10 = log102;
        Decimal3.log2 = log22;
        Decimal3.max = max2;
        Decimal3.min = min2;
        Decimal3.mod = mod2;
        Decimal3.mul = mul3;
        Decimal3.pow = pow2;
        Decimal3.random = random2;
        Decimal3.round = round2;
        Decimal3.sign = sign2;
        Decimal3.sin = sin2;
        Decimal3.sinh = sinh2;
        Decimal3.sqrt = sqrt2;
        Decimal3.sub = sub3;
        Decimal3.sum = sum2;
        Decimal3.tan = tan2;
        Decimal3.tanh = tanh2;
        Decimal3.trunc = trunc2;
        if (obj === void 0)
          obj = {};
        if (obj) {
          if (obj.defaults !== true) {
            ps = ["precision", "rounding", "toExpNeg", "toExpPos", "maxE", "minE", "modulo", "crypto"];
            for (i = 0; i < ps.length; )
              if (!obj.hasOwnProperty(p = ps[i++]))
                obj[p] = this[p];
          }
        }
        Decimal3.config(obj);
        return Decimal3;
      }
      function div3(x, y) {
        return new this(x).div(y);
      }
      function exp2(x) {
        return new this(x).exp();
      }
      function floor2(x) {
        return finalise2(x = new this(x), x.e + 1, 3);
      }
      function hypot2() {
        var i, n, t = new this(0);
        external2 = false;
        for (i = 0; i < arguments.length; ) {
          n = new this(arguments[i++]);
          if (!n.d) {
            if (n.s) {
              external2 = true;
              return new this(1 / 0);
            }
            t = n;
          } else if (t.d) {
            t = t.plus(n.times(n));
          }
        }
        external2 = true;
        return t.sqrt();
      }
      function isDecimalInstance2(obj) {
        return obj instanceof Decimal2 || obj && obj.toStringTag === tag2 || false;
      }
      function ln2(x) {
        return new this(x).ln();
      }
      function log3(x, y) {
        return new this(x).log(y);
      }
      function log22(x) {
        return new this(x).log(2);
      }
      function log102(x) {
        return new this(x).log(10);
      }
      function max2() {
        return maxOrMin2(this, arguments, -1);
      }
      function min2() {
        return maxOrMin2(this, arguments, 1);
      }
      function mod2(x, y) {
        return new this(x).mod(y);
      }
      function mul3(x, y) {
        return new this(x).mul(y);
      }
      function pow2(x, y) {
        return new this(x).pow(y);
      }
      function random2(sd) {
        var d, e, k, n, i = 0, r = new this(1), rd = [];
        if (sd === void 0)
          sd = this.precision;
        else
          checkInt322(sd, 1, MAX_DIGITS2);
        k = Math.ceil(sd / LOG_BASE3);
        if (!this.crypto) {
          for (; i < k; )
            rd[i++] = Math.random() * 1e7 | 0;
        } else if (crypto.getRandomValues) {
          d = crypto.getRandomValues(new Uint32Array(k));
          for (; i < k; ) {
            n = d[i];
            if (n >= 429e7) {
              d[i] = crypto.getRandomValues(new Uint32Array(1))[0];
            } else {
              rd[i++] = n % 1e7;
            }
          }
        } else if (crypto.randomBytes) {
          d = crypto.randomBytes(k *= 4);
          for (; i < k; ) {
            n = d[i] + (d[i + 1] << 8) + (d[i + 2] << 16) + ((d[i + 3] & 127) << 24);
            if (n >= 214e7) {
              crypto.randomBytes(4).copy(d, i);
            } else {
              rd.push(n % 1e7);
              i += 4;
            }
          }
          i = k / 4;
        } else {
          throw Error(cryptoUnavailable2);
        }
        k = rd[--i];
        sd %= LOG_BASE3;
        if (k && sd) {
          n = mathpow2(10, LOG_BASE3 - sd);
          rd[i] = (k / n | 0) * n;
        }
        for (; rd[i] === 0; i--)
          rd.pop();
        if (i < 0) {
          e = 0;
          rd = [0];
        } else {
          e = -1;
          for (; rd[0] === 0; e -= LOG_BASE3)
            rd.shift();
          for (k = 1, n = rd[0]; n >= 10; n /= 10)
            k++;
          if (k < LOG_BASE3)
            e -= LOG_BASE3 - k;
        }
        r.e = e;
        r.d = rd;
        return r;
      }
      function round2(x) {
        return finalise2(x = new this(x), x.e + 1, this.rounding);
      }
      function sign2(x) {
        x = new this(x);
        return x.d ? x.d[0] ? x.s : 0 * x.s : x.s || NaN;
      }
      function sin2(x) {
        return new this(x).sin();
      }
      function sinh2(x) {
        return new this(x).sinh();
      }
      function sqrt2(x) {
        return new this(x).sqrt();
      }
      function sub3(x, y) {
        return new this(x).sub(y);
      }
      function sum2() {
        var i = 0, args = arguments, x = new this(args[i]);
        external2 = false;
        for (; x.s && ++i < args.length; )
          x = x.plus(args[i]);
        external2 = true;
        return finalise2(x, this.precision, this.rounding);
      }
      function tan2(x) {
        return new this(x).tan();
      }
      function tanh2(x) {
        return new this(x).tanh();
      }
      function trunc2(x) {
        return finalise2(x = new this(x), x.e + 1, 1);
      }
      Decimal2 = clone3(DEFAULTS2);
      Decimal2.prototype.constructor = Decimal2;
      Decimal2["default"] = Decimal2.Decimal = Decimal2;
      LN102 = new Decimal2(LN102);
      PI2 = new Decimal2(PI2);
      if (typeof define == "function" && define.amd) {
        define(function() {
          return Decimal2;
        });
      } else if (typeof module2 != "undefined" && module2.exports) {
        if (typeof Symbol == "function" && typeof Symbol.iterator == "symbol") {
          P2[Symbol["for"]("nodejs.util.inspect.custom")] = P2.toString;
          P2[Symbol.toStringTag] = "Decimal";
        }
        module2.exports = Decimal2;
      } else {
        if (!globalScope) {
          globalScope = typeof self != "undefined" && self && self.self == self ? self : window;
        }
        noConflict = globalScope.Decimal;
        Decimal2.noConflict = function() {
          globalScope.Decimal = noConflict;
          return Decimal2;
        };
        globalScope.Decimal = Decimal2;
      }
    })(exports2);
  }
});

// node_modules/@raydium-io/raydium-sdk/dist/index.js
var require_dist = __commonJS({
  "node_modules/@raydium-io/raydium-sdk/dist/index.js"(exports2, module2) {
    "use strict";
    var __create2 = Object.create;
    var __defProp2 = Object.defineProperty;
    var __defProps = Object.defineProperties;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __getOwnPropSymbols = Object.getOwnPropertySymbols;
    var __getProtoOf2 = Object.getPrototypeOf;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __propIsEnum = Object.prototype.propertyIsEnumerable;
    var __pow = Math.pow;
    var __defNormalProp = (obj, key, value) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
    var __spreadValues = (a, b) => {
      for (var prop in b || (b = {}))
        if (__hasOwnProp2.call(b, prop))
          __defNormalProp(a, prop, b[prop]);
      if (__getOwnPropSymbols)
        for (var prop of __getOwnPropSymbols(b)) {
          if (__propIsEnum.call(b, prop))
            __defNormalProp(a, prop, b[prop]);
        }
      return a;
    };
    var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
    var __export = (target, all) => {
      for (var name in all)
        __defProp2(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toESM2 = (mod2, isNodeMode, target) => (target = mod2 != null ? __create2(__getProtoOf2(mod2)) : {}, __copyProps2(
      // If the importer is in node compatibility mode or this is not an ESM
      // file that has been converted to a CommonJS file using a Babel-
      // compatible transform (i.e. "__esModule" has not been set), then set
      // "default" to the CommonJS "module.exports" for node compatibility.
      isNodeMode || !mod2 || !mod2.__esModule ? __defProp2(target, "default", { value: mod2, enumerable: true }) : target,
      mod2
    ));
    var __toCommonJS = (mod2) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod2);
    var __async = (__this, __arguments, generator) => {
      return new Promise((resolve, reject) => {
        var fulfilled = (value) => {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        };
        var rejected = (value) => {
          try {
            step(generator.throw(value));
          } catch (e) {
            reject(e);
          }
        };
        var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
        step((generator = generator.apply(__this, __arguments)).next());
      });
    };
    var src_exports = {};
    __export(src_exports, {
      AMM_CONFIG_SEED: () => AMM_CONFIG_SEED2,
      ASSOCIATED_TOKEN_PROGRAM_ID: () => import_spl_token2.ASSOCIATED_TOKEN_PROGRAM_ID,
      AccountMeta: () => AccountMeta,
      AccountMetaReadonly: () => AccountMetaReadonly,
      AmmConfigLayout: () => AmmConfigLayout,
      BIT_PRECISION: () => BIT_PRECISION2,
      BNDivCeil: () => BNDivCeil2,
      BNLayout: () => BNLayout2,
      Base: () => Base,
      BitStructure: () => BitStructure2,
      Blob: () => Blob2,
      Clmm: () => Clmm2,
      Currency: () => Currency2,
      CurrencyAmount: () => CurrencyAmount2,
      DEVNET_FARM_POOLS: () => DEVNET_FARM_POOLS,
      DEVNET_LP_TOKENS: () => DEVNET_LP_TOKENS,
      DEVNET_OFFICIAL_LIQUIDITY_POOLS: () => DEVNET_OFFICIAL_LIQUIDITY_POOLS,
      DEVNET_PROGRAM_ID: () => DEVNET_PROGRAM_ID2,
      DEVNET_SPL_TOKENS: () => DEVNET_SPL_TOKENS,
      DataElement: () => DataElement2,
      ENDPOINT: () => ENDPOINT,
      EXTENSION_TICKARRAY_BITMAP_SIZE: () => EXTENSION_TICKARRAY_BITMAP_SIZE2,
      ErrorCode: () => ErrorCode,
      FARM_LEDGER_LAYOUT_V3_1: () => FARM_LEDGER_LAYOUT_V3_1,
      FARM_LEDGER_LAYOUT_V3_2: () => FARM_LEDGER_LAYOUT_V3_2,
      FARM_LEDGER_LAYOUT_V5_1: () => FARM_LEDGER_LAYOUT_V5_1,
      FARM_LEDGER_LAYOUT_V5_2: () => FARM_LEDGER_LAYOUT_V5_2,
      FARM_LEDGER_LAYOUT_V6_1: () => FARM_LEDGER_LAYOUT_V6_1,
      FARM_STATE_LAYOUT_V3: () => FARM_STATE_LAYOUT_V3,
      FARM_STATE_LAYOUT_V5: () => FARM_STATE_LAYOUT_V5,
      FARM_STATE_LAYOUT_V6: () => FARM_STATE_LAYOUT_V6,
      FARM_VERSION_TO_LEDGER_LAYOUT: () => FARM_VERSION_TO_LEDGER_LAYOUT2,
      FARM_VERSION_TO_STATE_LAYOUT: () => FARM_VERSION_TO_STATE_LAYOUT2,
      FEE_RATE_DENOMINATOR: () => FEE_RATE_DENOMINATOR2,
      FETCH_TICKARRAY_COUNT: () => FETCH_TICKARRAY_COUNT2,
      FIVE: () => FIVE,
      Farm: () => Farm,
      Fee: () => Fee2,
      Fraction: () => Fraction2,
      INSTRUCTION_PROGRAM_ID: () => INSTRUCTION_PROGRAM_ID2,
      InstructionType: () => InstructionType2,
      LIQUIDITY_FEES_DENOMINATOR: () => LIQUIDITY_FEES_DENOMINATOR2,
      LIQUIDITY_FEES_NUMERATOR: () => LIQUIDITY_FEES_NUMERATOR2,
      LIQUIDITY_STATE_LAYOUT_V4: () => LIQUIDITY_STATE_LAYOUT_V4,
      LIQUIDITY_STATE_LAYOUT_V5: () => LIQUIDITY_STATE_LAYOUT_V5,
      LIQUIDITY_VERSION_TO_STATE_LAYOUT: () => LIQUIDITY_VERSION_TO_STATE_LAYOUT2,
      LOG_B_2_X32: () => LOG_B_2_X322,
      LOG_B_P_ERR_MARGIN_LOWER_X64: () => LOG_B_P_ERR_MARGIN_LOWER_X642,
      LOG_B_P_ERR_MARGIN_UPPER_X64: () => LOG_B_P_ERR_MARGIN_UPPER_X642,
      LOOKUP_TABLE_CACHE: () => LOOKUP_TABLE_CACHE2,
      Layout: () => Layout2,
      Liquidity: () => Liquidity2,
      LiquidityMath: () => LiquidityMath2,
      LiquidityPoolStatus: () => LiquidityPoolStatus,
      LogLevel: () => LogLevel2,
      Logger: () => Logger2,
      MAINNET_FARM_POOLS: () => MAINNET_FARM_POOLS,
      MAINNET_LP_TOKENS: () => MAINNET_LP_TOKENS,
      MAINNET_OFFICIAL_LIQUIDITY_POOLS: () => MAINNET_OFFICIAL_LIQUIDITY_POOLS,
      MAINNET_PROGRAM_ID: () => MAINNET_PROGRAM_ID,
      MAINNET_SPL_TOKENS: () => MAINNET_SPL_TOKENS,
      MARKET_STATE_LAYOUT_V2: () => MARKET_STATE_LAYOUT_V22,
      MARKET_STATE_LAYOUT_V3: () => MARKET_STATE_LAYOUT_V32,
      MARKET_VERSION_TO_STATE_LAYOUT: () => MARKET_VERSION_TO_STATE_LAYOUT2,
      MAX_BASE64_SIZE: () => MAX_BASE64_SIZE2,
      MAX_SQRT_PRICE_X64: () => MAX_SQRT_PRICE_X642,
      MAX_TICK: () => MAX_TICK2,
      MEMO_PROGRAM_ID: () => MEMO_PROGRAM_ID3,
      METADATA_PROGRAM_ID: () => METADATA_PROGRAM_ID2,
      MIN_SQRT_PRICE_X64: () => MIN_SQRT_PRICE_X642,
      MIN_TICK: () => MIN_TICK2,
      Market: () => Market2,
      MarketV2: () => MarketV2,
      MathUtil: () => MathUtil2,
      MaxU64: () => MaxU642,
      MaxUint128: () => MaxUint1282,
      ModelDataInfo: () => ModelDataInfo,
      ModelDataPubkey: () => ModelDataPubkey,
      NEGATIVE_ONE: () => NEGATIVE_ONE2,
      ONE: () => ONE2,
      OPERATION_SEED: () => OPERATION_SEED2,
      ObservationInfoLayout: () => ObservationInfoLayout2,
      ObservationLayout: () => ObservationLayout2,
      OperationLayout: () => OperationLayout2,
      OptionLayout: () => OptionLayout2,
      POOL_REWARD_VAULT_SEED: () => POOL_REWARD_VAULT_SEED2,
      POOL_SEED: () => POOL_SEED2,
      POOL_TICK_ARRAY_BITMAP_SEED: () => POOL_TICK_ARRAY_BITMAP_SEED2,
      POOL_VAULT_SEED: () => POOL_VAULT_SEED2,
      POSITION_SEED: () => POSITION_SEED2,
      Percent: () => Percent3,
      PoolInfoLayout: () => PoolInfoLayout2,
      PoolUtils: () => PoolUtils3,
      PositionInfoLayout: () => PositionInfoLayout2,
      PositionRewardInfoLayout: () => PositionRewardInfoLayout2,
      PositionUtils: () => PositionUtils2,
      Price: () => Price2,
      ProtocolPositionLayout: () => ProtocolPositionLayout2,
      Q128: () => Q1282,
      Q64: () => Q642,
      RAYDIUM_MAINNET: () => RAYDIUM_MAINNET,
      REAL_FARM_STATE_LAYOUT_V3: () => REAL_FARM_STATE_LAYOUT_V3,
      REAL_FARM_STATE_LAYOUT_V5: () => REAL_FARM_STATE_LAYOUT_V5,
      REAL_FARM_STATE_LAYOUT_V6: () => REAL_FARM_STATE_LAYOUT_V6,
      RENT_PROGRAM_ID: () => RENT_PROGRAM_ID2,
      RewardInfo: () => RewardInfo2,
      Rounding: () => Rounding2,
      SERUM_PROGRAMID_TO_VERSION: () => SERUM_PROGRAMID_TO_VERSION2,
      SERUM_PROGRAM_ID_V3: () => SERUM_PROGRAM_ID_V32,
      SERUM_VERSION_TO_PROGRAMID: () => SERUM_VERSION_TO_PROGRAMID2,
      SOL: () => SOL,
      SPL_ACCOUNT_LAYOUT: () => SPL_ACCOUNT_LAYOUT,
      SPL_MINT_LAYOUT: () => SPL_MINT_LAYOUT2,
      SYSTEM_PROGRAM_ID: () => SYSTEM_PROGRAM_ID2,
      SYSVAR_CLOCK_PUBKEY: () => import_web332.SYSVAR_CLOCK_PUBKEY,
      SYSVAR_RENT_PUBKEY: () => import_web332.SYSVAR_RENT_PUBKEY,
      Spl: () => Spl,
      SqrtPriceMath: () => SqrtPriceMath2,
      Structure: () => Structure22,
      SwapMath: () => SwapMath2,
      TEN: () => TEN,
      TESTNET_FARM_POOLS: () => TESTNET_FARM_POOLS,
      TESTNET_LP_TOKENS: () => TESTNET_LP_TOKENS,
      TESTNET_OFFICIAL_LIQUIDITY_POOLS: () => TESTNET_OFFICIAL_LIQUIDITY_POOLS,
      TESTNET_SPL_TOKENS: () => TESTNET_SPL_TOKENS,
      THREE: () => THREE,
      TICK_ARRAY_BITMAP_SIZE: () => TICK_ARRAY_BITMAP_SIZE2,
      TICK_ARRAY_SEED: () => TICK_ARRAY_SEED2,
      TICK_ARRAY_SIZE: () => TICK_ARRAY_SIZE2,
      TICK_SPACINGS: () => TICK_SPACINGS2,
      TOKEN_PROGRAM_ID: () => import_spl_token2.TOKEN_PROGRAM_ID,
      TWO: () => TWO,
      TickArrayBitmap: () => TickArrayBitmap2,
      TickArrayBitmapExtension: () => TickArrayBitmapExtension,
      TickArrayBitmapExtensionLayout: () => TickArrayBitmapExtensionLayout2,
      TickArrayLayout: () => TickArrayLayout2,
      TickLayout: () => TickLayout2,
      TickMath: () => TickMath2,
      TickQuery: () => TickQuery2,
      TickUtils: () => TickUtils2,
      Token: () => Token3,
      TokenAmount: () => TokenAmount3,
      TokenList: () => TokenList,
      TradeV2: () => TradeV2,
      TxVersion: () => TxVersion3,
      U64Resolution: () => U64Resolution2,
      U64_IGNORE_RANGE: () => U64_IGNORE_RANGE2,
      UInt: () => UInt2,
      Union: () => Union22,
      Utils1216: () => Utils1216,
      Voter: () => Voter2,
      VoterDepositEntry: () => VoterDepositEntry2,
      VoterLockup: () => VoterLockup2,
      VoterRegistrar: () => VoterRegistrar2,
      VoterVotingMintConfig: () => VoterVotingMintConfig2,
      WSOL: () => WSOL,
      WideBits: () => WideBits2,
      WrappedLayout: () => WrappedLayout2,
      ZERO: () => ZERO2,
      _100: () => _100,
      _1000: () => _1000,
      _10000: () => _10000,
      _100_PERCENT: () => _100_PERCENT2,
      _SERUM_PROGRAM_ID_V3: () => _SERUM_PROGRAM_ID_V3,
      array: () => array2,
      bits: () => bits2,
      blob: () => blob4,
      bool: () => bool22,
      buildSimpleTransaction: () => buildSimpleTransaction,
      buildTransaction: () => buildTransaction,
      chunkArray: () => chunkArray2,
      closePositionInstruction: () => closePositionInstruction,
      collectRewardInstruction: () => collectRewardInstruction,
      createPoolInstruction: () => createPoolInstruction,
      cstr: () => cstr2,
      currencyEquals: () => currencyEquals2,
      decodeBool: () => decodeBool2,
      decreaseLiquidityInstruction: () => decreaseLiquidityInstruction,
      divCeil: () => divCeil2,
      encodeBool: () => encodeBool2,
      f32: () => f322,
      f32be: () => f32be2,
      f64: () => f642,
      f64be: () => f64be2,
      fetchMultipleMintInfos: () => fetchMultipleMintInfos2,
      findProgramAddress: () => findProgramAddress2,
      forecastTransactionSize: () => forecastTransactionSize2,
      formatLayout: () => formatLayout2,
      generatePubKey: () => generatePubKey2,
      getDxByDyBaseIn: () => getDxByDyBaseIn2,
      getDyByDxBaseIn: () => getDyByDxBaseIn2,
      getMultipleAccountsInfo: () => getMultipleAccountsInfo2,
      getMultipleAccountsInfoWithCustomFlags: () => getMultipleAccountsInfoWithCustomFlags2,
      getMultipleLookupTableInfo: () => getMultipleLookupTableInfo2,
      getPdaAmmConfigId: () => getPdaAmmConfigId2,
      getPdaExBitmapAccount: () => getPdaExBitmapAccount2,
      getPdaMetadataKey: () => getPdaMetadataKey2,
      getPdaOperationAccount: () => getPdaOperationAccount2,
      getPdaPersonalPositionAddress: () => getPdaPersonalPositionAddress2,
      getPdaPoolId: () => getPdaPoolId2,
      getPdaPoolRewardVaulId: () => getPdaPoolRewardVaulId2,
      getPdaPoolVaultId: () => getPdaPoolVaultId2,
      getPdaProtocolPositionAddress: () => getPdaProtocolPositionAddress2,
      getPdaTickArrayAddress: () => getPdaTickArrayAddress2,
      getStablePrice: () => getStablePrice2,
      getTransferAmountFee: () => getTransferAmountFee2,
      getWSOLAmount: () => getWSOLAmount,
      greedy: () => greedy2,
      i128: () => i1282,
      i16ToBytes: () => i16ToBytes2,
      i32ToBytes: () => i32ToBytes2,
      i64: () => i642,
      i8: () => i82,
      increasePositionFromBaseInstruction: () => increasePositionFromBaseInstruction,
      increasePositionFromLiquidityInstruction: () => increasePositionFromLiquidityInstruction,
      initRewardInstruction: () => initRewardInstruction,
      initStableModelLayout: () => initStableModelLayout,
      inspectAll: () => inspectAll,
      inspectBN: () => inspectBN,
      inspectCurrency: () => inspectCurrency,
      inspectPublicKey: () => inspectPublicKey,
      inspectToken: () => inspectToken,
      intersection: () => intersection2,
      isZero: () => isZero2,
      jsonInfo2PoolKeys: () => jsonInfo2PoolKeys2,
      leadingZeros: () => leadingZeros2,
      leastSignificantBit: () => leastSignificantBit2,
      minExpirationTime: () => minExpirationTime2,
      mostSignificantBit: () => mostSignificantBit2,
      ns64: () => ns642,
      ns64be: () => ns64be2,
      nu64: () => nu642,
      nu64be: () => nu64be2,
      offset: () => offset2,
      openPositionFromBaseInstruction: () => openPositionFromBaseInstruction,
      openPositionFromLiquidityInstruction: () => openPositionFromLiquidityInstruction,
      option: () => option2,
      parseBigNumberish: () => parseBigNumberish2,
      parseSimulateLogToJson: () => parseSimulateLogToJson2,
      parseSimulateValue: () => parseSimulateValue2,
      poolKeys2JsonInfo: () => poolKeys2JsonInfo,
      poolTypeV6: () => poolTypeV62,
      publicKey: () => publicKey3,
      rustEnum: () => rustEnum2,
      s16: () => s162,
      s16be: () => s16be2,
      s24: () => s242,
      s24be: () => s24be2,
      s32: () => s322,
      s32be: () => s32be2,
      s40: () => s402,
      s40be: () => s40be2,
      s48: () => s482,
      s48be: () => s48be2,
      s8: () => s82,
      seq: () => seq22,
      setRewardInstruction: () => setRewardInstruction,
      simulateMultipleInstruction: () => simulateMultipleInstruction2,
      simulateTransaction: () => simulateTransaction2,
      splitNumber: () => splitNumber2,
      splitTxAndSigners: () => splitTxAndSigners,
      str: () => str2,
      struct: () => struct3,
      swapInstruction: () => swapInstruction,
      tagged: () => tagged2,
      tenExponentiate: () => tenExponentiate,
      trailingZeros: () => trailingZeros2,
      u128: () => u1283,
      u16: () => u162,
      u16ToBytes: () => u16ToBytes2,
      u16be: () => u16be2,
      u24: () => u242,
      u24be: () => u24be2,
      u32: () => u3222,
      u32ToBytes: () => u32ToBytes2,
      u32be: () => u32be2,
      u40: () => u402,
      u40be: () => u40be2,
      u48: () => u482,
      u48be: () => u48be2,
      u64: () => u643,
      u8: () => u822,
      union: () => union22,
      unionLayoutDiscriminator: () => unionLayoutDiscriminator2,
      uniq: () => uniq2,
      unwarpSol: () => unwarpSol,
      utf8: () => utf82,
      validateAndParsePublicKey: () => validateAndParsePublicKey2,
      vec: () => vec2,
      vecU8: () => vecU82,
      xor: () => xor2,
      zeros: () => zeros2
    });
    module2.exports = __toCommonJS(src_exports);
    function number(n) {
      if (!Number.isSafeInteger(n) || n < 0)
        throw new Error(`Wrong positive integer: ${n}`);
    }
    function bool2(b) {
      if (typeof b !== "boolean")
        throw new Error(`Expected boolean, not ${b}`);
    }
    function bytes(b, ...lengths) {
      if (!(b instanceof Uint8Array))
        throw new TypeError("Expected Uint8Array");
      if (lengths.length > 0 && !lengths.includes(b.length))
        throw new TypeError(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);
    }
    function hash(hash2) {
      if (typeof hash2 !== "function" || typeof hash2.create !== "function")
        throw new Error("Hash should be wrapped by utils.wrapConstructor");
      number(hash2.outputLen);
      number(hash2.blockLen);
    }
    function exists(instance, checkFinished = true) {
      if (instance.destroyed)
        throw new Error("Hash instance has been destroyed");
      if (checkFinished && instance.finished)
        throw new Error("Hash#digest() has already been called");
    }
    function output(out, instance) {
      bytes(out);
      const min2 = instance.outputLen;
      if (out.length < min2) {
        throw new Error(`digestInto() expects output buffer of length at least ${min2}`);
      }
    }
    var assert = {
      number,
      bool: bool2,
      bytes,
      hash,
      exists,
      output
    };
    var assert_default = assert;
    var createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
    var rotr = (word, shift) => word << 32 - shift | word >>> shift;
    var isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
    if (!isLE)
      throw new Error("Non little-endian hardware is not supported");
    var hexes = Array.from({ length: 256 }, (v, i) => i.toString(16).padStart(2, "0"));
    function utf8ToBytes(str22) {
      if (typeof str22 !== "string") {
        throw new TypeError(`utf8ToBytes expected string, got ${typeof str22}`);
      }
      return new TextEncoder().encode(str22);
    }
    function toBytes(data) {
      if (typeof data === "string")
        data = utf8ToBytes(data);
      if (!(data instanceof Uint8Array))
        throw new TypeError(`Expected input type is Uint8Array (got ${typeof data})`);
      return data;
    }
    var Hash = class {
      // Safe version that clones internal state
      clone() {
        return this._cloneInto();
      }
    };
    function wrapConstructor(hashConstructor) {
      const hashC = (message) => hashConstructor().update(toBytes(message)).digest();
      const tmp = hashConstructor();
      hashC.outputLen = tmp.outputLen;
      hashC.blockLen = tmp.blockLen;
      hashC.create = () => hashConstructor();
      return hashC;
    }
    function setBigUint64(view, byteOffset, value, isLE2) {
      if (typeof view.setBigUint64 === "function")
        return view.setBigUint64(byteOffset, value, isLE2);
      const _32n = BigInt(32);
      const _u32_max = BigInt(4294967295);
      const wh = Number(value >> _32n & _u32_max);
      const wl = Number(value & _u32_max);
      const h = isLE2 ? 4 : 0;
      const l = isLE2 ? 0 : 4;
      view.setUint32(byteOffset + h, wh, isLE2);
      view.setUint32(byteOffset + l, wl, isLE2);
    }
    var SHA2 = class extends Hash {
      constructor(blockLen, outputLen, padOffset, isLE2) {
        super();
        this.blockLen = blockLen;
        this.outputLen = outputLen;
        this.padOffset = padOffset;
        this.isLE = isLE2;
        this.finished = false;
        this.length = 0;
        this.pos = 0;
        this.destroyed = false;
        this.buffer = new Uint8Array(blockLen);
        this.view = createView(this.buffer);
      }
      update(data) {
        assert_default.exists(this);
        const { view, buffer, blockLen } = this;
        data = toBytes(data);
        const len = data.length;
        for (let pos = 0; pos < len; ) {
          const take = Math.min(blockLen - this.pos, len - pos);
          if (take === blockLen) {
            const dataView = createView(data);
            for (; blockLen <= len - pos; pos += blockLen)
              this.process(dataView, pos);
            continue;
          }
          buffer.set(data.subarray(pos, pos + take), this.pos);
          this.pos += take;
          pos += take;
          if (this.pos === blockLen) {
            this.process(view, 0);
            this.pos = 0;
          }
        }
        this.length += data.length;
        this.roundClean();
        return this;
      }
      digestInto(out) {
        assert_default.exists(this);
        assert_default.output(out, this);
        this.finished = true;
        const { buffer, view, blockLen, isLE: isLE2 } = this;
        let { pos } = this;
        buffer[pos++] = 128;
        this.buffer.subarray(pos).fill(0);
        if (this.padOffset > blockLen - pos) {
          this.process(view, 0);
          pos = 0;
        }
        for (let i = pos; i < blockLen; i++)
          buffer[i] = 0;
        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE2);
        this.process(view, 0);
        const oview = createView(out);
        const len = this.outputLen;
        if (len % 4)
          throw new Error("_sha2: outputLen should be aligned to 32bit");
        const outLen = len / 4;
        const state = this.get();
        if (outLen > state.length)
          throw new Error("_sha2: outputLen bigger than state");
        for (let i = 0; i < outLen; i++)
          oview.setUint32(4 * i, state[i], isLE2);
      }
      digest() {
        const { buffer, outputLen } = this;
        this.digestInto(buffer);
        const res = buffer.slice(0, outputLen);
        this.destroy();
        return res;
      }
      _cloneInto(to) {
        to || (to = new this.constructor());
        to.set(...this.get());
        const { blockLen, buffer, length, finished, destroyed, pos } = this;
        to.length = length;
        to.pos = pos;
        to.finished = finished;
        to.destroyed = destroyed;
        if (length % blockLen)
          to.buffer.set(buffer);
        return to;
      }
    };
    var Chi = (a, b, c) => a & b ^ ~a & c;
    var Maj = (a, b, c) => a & b ^ a & c ^ b & c;
    var SHA256_K = new Uint32Array([
      1116352408,
      1899447441,
      3049323471,
      3921009573,
      961987163,
      1508970993,
      2453635748,
      2870763221,
      3624381080,
      310598401,
      607225278,
      1426881987,
      1925078388,
      2162078206,
      2614888103,
      3248222580,
      3835390401,
      4022224774,
      264347078,
      604807628,
      770255983,
      1249150122,
      1555081692,
      1996064986,
      2554220882,
      2821834349,
      2952996808,
      3210313671,
      3336571891,
      3584528711,
      113926993,
      338241895,
      666307205,
      773529912,
      1294757372,
      1396182291,
      1695183700,
      1986661051,
      2177026350,
      2456956037,
      2730485921,
      2820302411,
      3259730800,
      3345764771,
      3516065817,
      3600352804,
      4094571909,
      275423344,
      430227734,
      506948616,
      659060556,
      883997877,
      958139571,
      1322822218,
      1537002063,
      1747873779,
      1955562222,
      2024104815,
      2227730452,
      2361852424,
      2428436474,
      2756734187,
      3204031479,
      3329325298
    ]);
    var IV = new Uint32Array([
      1779033703,
      3144134277,
      1013904242,
      2773480762,
      1359893119,
      2600822924,
      528734635,
      1541459225
    ]);
    var SHA256_W = new Uint32Array(64);
    var SHA256 = class extends SHA2 {
      constructor() {
        super(64, 32, 8, false);
        this.A = IV[0] | 0;
        this.B = IV[1] | 0;
        this.C = IV[2] | 0;
        this.D = IV[3] | 0;
        this.E = IV[4] | 0;
        this.F = IV[5] | 0;
        this.G = IV[6] | 0;
        this.H = IV[7] | 0;
      }
      get() {
        const { A, B, C, D, E, F, G, H } = this;
        return [A, B, C, D, E, F, G, H];
      }
      // prettier-ignore
      set(A, B, C, D, E, F, G, H) {
        this.A = A | 0;
        this.B = B | 0;
        this.C = C | 0;
        this.D = D | 0;
        this.E = E | 0;
        this.F = F | 0;
        this.G = G | 0;
        this.H = H | 0;
      }
      process(view, offset22) {
        for (let i = 0; i < 16; i++, offset22 += 4)
          SHA256_W[i] = view.getUint32(offset22, false);
        for (let i = 16; i < 64; i++) {
          const W15 = SHA256_W[i - 15];
          const W2 = SHA256_W[i - 2];
          const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ W15 >>> 3;
          const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ W2 >>> 10;
          SHA256_W[i] = s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16] | 0;
        }
        let { A, B, C, D, E, F, G, H } = this;
        for (let i = 0; i < 64; i++) {
          const sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);
          const T1 = H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i] | 0;
          const sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);
          const T2 = sigma0 + Maj(A, B, C) | 0;
          H = G;
          G = F;
          F = E;
          E = D + T1 | 0;
          D = C;
          C = B;
          B = A;
          A = T1 + T2 | 0;
        }
        A = A + this.A | 0;
        B = B + this.B | 0;
        C = C + this.C | 0;
        D = D + this.D | 0;
        E = E + this.E | 0;
        F = F + this.F | 0;
        G = G + this.G | 0;
        H = H + this.H | 0;
        this.set(A, B, C, D, E, F, G, H);
      }
      roundClean() {
        SHA256_W.fill(0);
      }
      destroy() {
        this.set(0, 0, 0, 0, 0, 0, 0, 0);
        this.buffer.fill(0);
      }
    };
    var SHA224 = class extends SHA256 {
      constructor() {
        super();
        this.A = 3238371032 | 0;
        this.B = 914150663 | 0;
        this.C = 812702999 | 0;
        this.D = 4144912697 | 0;
        this.E = 4290775857 | 0;
        this.F = 1750603025 | 0;
        this.G = 1694076839 | 0;
        this.H = 3204075428 | 0;
        this.outputLen = 28;
      }
    };
    var sha256 = wrapConstructor(() => new SHA256());
    var sha224 = wrapConstructor(() => new SHA224());
    var import_spl_token3 = require_cjs5();
    var import_web311 = require("@solana/web3.js");
    var import_big2 = __toESM2(require_big());
    var import_bn5 = __toESM2(require_bn());
    var import_web34 = require("@solana/web3.js");
    var import_bn2 = require_bn();
    var import_web322 = require("@solana/web3.js");
    var import_web35 = require("@solana/web3.js");
    var version = "1.1.0-beta.6";
    var _permanentCensorErrors = false;
    var _censorErrors = false;
    var LogLevels = { debug: 1, default: 2, info: 2, warning: 3, error: 4, off: 5 };
    var _moduleLogLevel = {};
    var _globalLogger;
    function _checkNormalize() {
      try {
        const missing = [];
        ["NFD", "NFC", "NFKD", "NFKC"].forEach((form) => {
          try {
            if ("test".normalize(form) !== "test") {
              throw new Error("bad normalize");
            }
          } catch (error) {
            missing.push(form);
          }
        });
        if (missing.length) {
          throw new Error("missing " + missing.join(", "));
        }
        if (String.fromCharCode(233).normalize("NFD") !== String.fromCharCode(101, 769)) {
          throw new Error("broken implementation");
        }
      } catch (error) {
        if (error instanceof Error) {
          return error.message;
        }
      }
      return "";
    }
    var _normalizeError = _checkNormalize();
    var LogLevel2 = /* @__PURE__ */ ((LogLevel22) => {
      LogLevel22["DEBUG"] = "DEBUG";
      LogLevel22["INFO"] = "INFO";
      LogLevel22["WARNING"] = "WARNING";
      LogLevel22["ERROR"] = "ERROR";
      LogLevel22["OFF"] = "OFF";
      return LogLevel22;
    })(LogLevel2 || {});
    var ErrorCode = /* @__PURE__ */ ((ErrorCode2) => {
      ErrorCode2["UNKNOWN_ERROR"] = "UNKNOWN_ERROR";
      ErrorCode2["NOT_IMPLEMENTED"] = "NOT_IMPLEMENTED";
      ErrorCode2["UNSUPPORTED_OPERATION"] = "UNSUPPORTED_OPERATION";
      ErrorCode2["NETWORK_ERROR"] = "NETWORK_ERROR";
      ErrorCode2["RPC_ERROR"] = "RPC_ERROR";
      ErrorCode2["TIMEOUT"] = "TIMEOUT";
      ErrorCode2["BUFFER_OVERRUN"] = "BUFFER_OVERRUN";
      ErrorCode2["NUMERIC_FAULT"] = "NUMERIC_FAULT";
      ErrorCode2["MISSING_NEW"] = "MISSING_NEW";
      ErrorCode2["INVALID_ARGUMENT"] = "INVALID_ARGUMENT";
      ErrorCode2["MISSING_ARGUMENT"] = "MISSING_ARGUMENT";
      ErrorCode2["UNEXPECTED_ARGUMENT"] = "UNEXPECTED_ARGUMENT";
      ErrorCode2["INSUFFICIENT_FUNDS"] = "INSUFFICIENT_FUNDS";
      return ErrorCode2;
    })(ErrorCode || {});
    var HEX = "0123456789abcdef";
    function perfectDisplay(value, deeping = false) {
      let _value = value;
      try {
        if (value instanceof Uint8Array) {
          let hex = "";
          for (let i = 0; i < value.length; i++) {
            hex += HEX[value[i] >> 4];
            hex += HEX[value[i] & 15];
          }
          _value = `Uint8Array(0x${hex})`;
        } else if (value instanceof import_web35.PublicKey) {
          _value = `PublicKey(${value.toBase58()})`;
        } else if (value instanceof Object && !deeping) {
          const obj = {};
          Object.entries(value).forEach(([k, v]) => {
            obj[k] = perfectDisplay(v, true);
          });
          _value = JSON.stringify(obj);
        } else if (!deeping) {
          _value = JSON.stringify(value);
        }
      } catch (error) {
        _value = JSON.stringify(value.toString());
      }
      return _value;
    }
    var _Logger = class _Logger2 {
      constructor(moduleName) {
        this.version = version;
        this.moduleName = moduleName;
      }
      _log(logLevel, args) {
        const level = logLevel.toLowerCase();
        if (LogLevels[level] == null) {
          this.throwArgumentError("invalid log level name", "logLevel", logLevel);
        }
        const _logLevel = _moduleLogLevel[this.moduleName] || LogLevels["default"];
        if (_logLevel > LogLevels[level]) {
          return;
        }
        console.log(...args);
      }
      debug(...args) {
        this._log(_Logger2.levels.DEBUG, ["[DEBUG]", ...args]);
      }
      info(...args) {
        this._log(_Logger2.levels.INFO, ["[INFO]", ...args]);
      }
      warn(...args) {
        this._log(_Logger2.levels.WARNING, ["[WARN]", ...args]);
      }
      makeError(message, code, params) {
        if (_censorErrors) {
          return this.makeError("censored error", code, {});
        }
        if (!code) {
          code = _Logger2.errors.UNKNOWN_ERROR;
        }
        if (!params) {
          params = {};
        }
        const messageDetails = [];
        Object.entries(params).forEach(([key, value]) => {
          messageDetails.push(`${key}=${perfectDisplay(value)})`);
        });
        messageDetails.push(`code=${code}`);
        messageDetails.push(`module=${this.moduleName}`);
        messageDetails.push(`version=${this.version}`);
        const reason = message;
        if (messageDetails.length) {
          message += " (" + messageDetails.join(", ") + ")";
        }
        const error = new Error(message);
        error.reason = reason;
        error.code = code;
        Object.entries(params).forEach(([key, value]) => {
          error[key] = value;
        });
        return error;
      }
      throwError(message, code, params) {
        throw this.makeError(message, code, params);
      }
      throwArgumentError(message, name, value) {
        return this.throwError(message, _Logger2.errors.INVALID_ARGUMENT, {
          argument: name,
          value
        });
      }
      assert(condition, message, code, params) {
        if (condition) {
          return;
        }
        this.throwError(message, code, params);
      }
      assertArgument(condition, message, name, value) {
        if (condition) {
          return;
        }
        this.throwArgumentError(message, name, value);
      }
      checkNormalize(message) {
        if (message == null) {
          message = "platform missing String.prototype.normalize";
        }
        if (_normalizeError) {
          this.throwError("platform missing String.prototype.normalize", _Logger2.errors.UNSUPPORTED_OPERATION, {
            operation: "String.prototype.normalize",
            form: _normalizeError
          });
        }
      }
      checkSafeUint53(value, message) {
        if (typeof value !== "number") {
          return;
        }
        if (message == null) {
          message = "value not safe";
        }
        if (value < 0 || value >= 9007199254740991) {
          this.throwError(message, _Logger2.errors.NUMERIC_FAULT, {
            operation: "checkSafeInteger",
            fault: "out-of-safe-range",
            value
          });
        }
        if (value % 1) {
          this.throwError(message, _Logger2.errors.NUMERIC_FAULT, {
            operation: "checkSafeInteger",
            fault: "non-integer",
            value
          });
        }
      }
      checkArgumentCount(count, expectedCount, message) {
        if (message) {
          message = ": " + message;
        } else {
          message = "";
        }
        if (count < expectedCount) {
          this.throwError("missing argument" + message, _Logger2.errors.MISSING_ARGUMENT, {
            count,
            expectedCount
          });
        }
        if (count > expectedCount) {
          this.throwError("too many arguments" + message, _Logger2.errors.UNEXPECTED_ARGUMENT, {
            count,
            expectedCount
          });
        }
      }
      checkNew(target, kind) {
        if (target === Object || target == null) {
          this.throwError("missing new", _Logger2.errors.MISSING_NEW, { name: kind.name });
        }
      }
      checkAbstract(target, kind) {
        if (target === kind) {
          this.throwError(
            "cannot instantiate abstract class " + JSON.stringify(kind.name) + " directly; use a sub-class",
            _Logger2.errors.UNSUPPORTED_OPERATION,
            { name: target.name, operation: "new" }
          );
        } else if (target === Object || target == null) {
          this.throwError("missing new", _Logger2.errors.MISSING_NEW, { name: kind.name });
        }
      }
      static globalLogger() {
        if (!_globalLogger) {
          _globalLogger = new _Logger2(version);
        }
        return _globalLogger;
      }
      static setCensorship(censorship, permanent) {
        if (!censorship && permanent) {
          this.globalLogger().throwError("cannot permanently disable censorship", _Logger2.errors.UNSUPPORTED_OPERATION, {
            operation: "setCensorship"
          });
        }
        if (_permanentCensorErrors) {
          if (!censorship) {
            return;
          }
          this.globalLogger().throwError("error censorship permanent", _Logger2.errors.UNSUPPORTED_OPERATION, {
            operation: "setCensorship"
          });
        }
        _censorErrors = !!censorship;
        _permanentCensorErrors = !!permanent;
      }
      static setLogLevel(moduleName, logLevel) {
        const level = LogLevels[logLevel.toLowerCase()];
        if (level == null) {
          _Logger2.globalLogger().warn("invalid log level - " + logLevel);
          return;
        }
        _moduleLogLevel[moduleName] = level;
      }
      static from(version2) {
        return new _Logger2(version2);
      }
    };
    _Logger.errors = ErrorCode;
    _Logger.levels = LogLevel2;
    var Logger2 = _Logger;
    var import_spl_token2 = require_cjs5();
    var import_web332 = require("@solana/web3.js");
    var logger = Logger2.from("common/pubkey");
    var SYSTEM_PROGRAM_ID2 = import_web322.SystemProgram.programId;
    var MEMO_PROGRAM_ID3 = new import_web322.PublicKey("MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr");
    var RENT_PROGRAM_ID2 = new import_web322.PublicKey("SysvarRent111111111111111111111111111111111");
    var METADATA_PROGRAM_ID2 = new import_web322.PublicKey("metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s");
    var INSTRUCTION_PROGRAM_ID2 = new import_web322.PublicKey("Sysvar1nstructions1111111111111111111111111");
    function validateAndParsePublicKey2(publicKey22) {
      if (publicKey22 instanceof import_web322.PublicKey) {
        return publicKey22;
      }
      if (typeof publicKey22 === "string") {
        try {
          const key = new import_web322.PublicKey(publicKey22);
          return key;
        } catch (e) {
          return logger.throwArgumentError("invalid public key", "publicKey", publicKey22);
        }
      }
      return logger.throwArgumentError("invalid public key", "publicKey", publicKey22);
    }
    function findProgramAddress2(seeds, programId) {
      const [publicKey22, nonce] = import_web322.PublicKey.findProgramAddressSync(seeds, programId);
      return { publicKey: publicKey22, nonce };
    }
    function AccountMeta(publicKey22, isSigner) {
      return {
        pubkey: publicKey22,
        isWritable: true,
        isSigner
      };
    }
    function AccountMetaReadonly(publicKey22, isSigner) {
      return {
        pubkey: publicKey22,
        isWritable: false,
        isSigner
      };
    }
    function notInnerObject2(v) {
      return typeof v === "object" && v !== null && ![TokenAmount3, import_web34.PublicKey, Fraction2, import_bn2.BN, Currency2, CurrencyAmount2, Price2, Percent3].some(
        (o) => typeof o === "object" && v instanceof o
      );
    }
    function jsonInfo2PoolKeys2(jsonInfo) {
      return typeof jsonInfo === "string" ? validateAndParsePublicKey2(jsonInfo) : Array.isArray(jsonInfo) ? jsonInfo.map((k) => jsonInfo2PoolKeys2(k)) : notInnerObject2(jsonInfo) ? Object.fromEntries(Object.entries(jsonInfo).map(([k, v]) => [k, jsonInfo2PoolKeys2(v)])) : jsonInfo;
    }
    function poolKeys2JsonInfo(jsonInfo) {
      return jsonInfo instanceof import_web34.PublicKey ? jsonInfo.toBase58() : Array.isArray(jsonInfo) ? jsonInfo.map((k) => poolKeys2JsonInfo(k)) : notInnerObject2(jsonInfo) ? Object.fromEntries(Object.entries(jsonInfo).map(([k, v]) => [k, poolKeys2JsonInfo(v)])) : jsonInfo;
    }
    var import_web352 = require("@solana/web3.js");
    var import_bn22 = __toESM2(require_bn());
    function inspectPublicKey() {
      import_web352.PublicKey.prototype.inspect = function() {
        return `<PublicKey: ${this.toString()}>`;
      };
    }
    function inspectBN() {
      import_bn22.default.prototype.inspect = function() {
        return `<${this.red ? "BN-R" : "BN"}: ${this.toString()}>`;
      };
    }
    function inspectAll() {
      inspectPublicKey();
      inspectBN();
    }
    function chunkArray2(arr, chunkSize = 1, cache = []) {
      const tmp = [...arr];
      if (chunkSize <= 0)
        return cache;
      while (tmp.length)
        cache.push(tmp.splice(0, chunkSize));
      return cache;
    }
    function intersection2(arr, ...args) {
      return arr.filter((item) => args.every((arr2) => arr2.includes(item)));
    }
    function xor2(arr, ...args) {
      return arr.filter((item) => args.every((arr2) => !arr2.includes(item)));
    }
    function uniq2(arr) {
      return [...new Set(arr)];
    }
    var import_web37 = require("@solana/web3.js");
    var import_web36 = require("@solana/web3.js");
    function addComputeBudget2(config2) {
      const ins = [];
      const insTypes = [];
      if (config2.microLamports) {
        ins.push(import_web36.ComputeBudgetProgram.setComputeUnitPrice({ microLamports: config2.microLamports }));
        insTypes.push(
          9
          /* setComputeUnitPrice */
        );
      }
      if (config2.units) {
        ins.push(import_web36.ComputeBudgetProgram.setComputeUnitLimit({ units: config2.units }));
        insTypes.push(
          10
          /* setComputeUnitLimit */
        );
      }
      return {
        address: {},
        innerTransaction: {
          instructions: ins,
          signers: [],
          instructionTypes: insTypes
        }
      };
    }
    var logger2 = Logger2.from("common/web3");
    function getMultipleAccountsInfo2(connection, publicKeys, config2) {
      return __async(this, null, function* () {
        const { batchRequest, commitment } = __spreadValues(__spreadValues({}, {
          batchRequest: false
        }), config2);
        const chunkedKeys = chunkArray2(publicKeys, 100);
        let results = new Array(chunkedKeys.length).fill([]);
        if (batchRequest) {
          const batch = chunkedKeys.map((keys) => {
            const args = connection._buildArgs([keys.map((key) => key.toBase58())], commitment, "base64");
            return {
              methodName: "getMultipleAccounts",
              args
            };
          });
          const _batch = chunkArray2(batch, 10);
          const unsafeResponse = yield (yield Promise.all(
            _batch.map(
              (i) => __async(this, null, function* () {
                return (
                  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                  // @ts-ignore
                  yield connection._rpcBatchRequest(i)
                );
              })
            )
          )).flat();
          results = unsafeResponse.map((unsafeRes) => {
            if (unsafeRes.error) {
              return logger2.throwError("failed to get info for multiple accounts", Logger2.errors.RPC_ERROR, {
                message: unsafeRes.error.message
              });
            }
            return unsafeRes.result.value.map((accountInfo) => {
              if (accountInfo) {
                const { data, executable, lamports, owner, rentEpoch } = accountInfo;
                if (data.length !== 2 && data[1] !== "base64") {
                  return logger2.throwError("info must be base64 encoded", Logger2.errors.RPC_ERROR);
                }
                return {
                  data: Buffer.from(data[0], "base64"),
                  executable,
                  lamports,
                  owner: new import_web37.PublicKey(owner),
                  rentEpoch
                };
              } else {
                return null;
              }
            });
          });
        } else {
          try {
            results = yield Promise.all(
              chunkedKeys.map((keys) => connection.getMultipleAccountsInfo(keys, commitment))
            );
          } catch (error) {
            if (error instanceof Error) {
              return logger2.throwError("failed to get info for multiple accounts", Logger2.errors.RPC_ERROR, {
                message: error.message
              });
            }
          }
        }
        return results.flat();
      });
    }
    function getMultipleAccountsInfoWithCustomFlags2(connection, publicKeysWithCustomFlag, config2) {
      return __async(this, null, function* () {
        const multipleAccountsInfo = yield getMultipleAccountsInfo2(
          connection,
          publicKeysWithCustomFlag.map((o) => o.pubkey),
          config2
        );
        return publicKeysWithCustomFlag.map((o, idx) => __spreadProps(__spreadValues({}, o), { accountInfo: multipleAccountsInfo[idx] }));
      });
    }
    function forecastTransactionSize2(instructions, signers) {
      if (instructions.length < 1) {
        return logger2.throwArgumentError("no instructions provided", "instructions", instructions);
      }
      if (signers.length < 1) {
        return logger2.throwArgumentError("no signers provided", "signers", signers);
      }
      const transaction = new import_web37.Transaction({
        recentBlockhash: "11111111111111111111111111111111",
        feePayer: signers[0]
      });
      transaction.add(...instructions);
      try {
        return Buffer.from(transaction.serialize({ verifySignatures: false })).toString("base64").length < MAX_BASE64_SIZE2;
      } catch (error) {
        return false;
      }
    }
    function simulateMultipleInstruction2(connection, instructions, keyword, batchRequest = true) {
      return __async(this, null, function* () {
        const feePayer = new import_web37.PublicKey("RaydiumSimuLateTransaction11111111111111111");
        const transactions = [];
        let transaction = new import_web37.Transaction();
        transaction.feePayer = feePayer;
        for (const instruction of instructions) {
          if (!forecastTransactionSize2([...transaction.instructions, instruction], [feePayer])) {
            transactions.push(transaction);
            transaction = new import_web37.Transaction();
            transaction.feePayer = feePayer;
          }
          transaction.add(instruction);
        }
        if (transaction.instructions.length > 0) {
          transactions.push(transaction);
        }
        let results = [];
        try {
          results = yield simulateTransaction2(connection, transactions, batchRequest);
          if (results.find((i) => i.err !== null))
            throw Error("rpc simulateTransaction error");
        } catch (error) {
          if (error instanceof Error) {
            return logger2.throwError("failed to simulate for instructions", Logger2.errors.RPC_ERROR, {
              message: error.message
            });
          }
        }
        const logs = [];
        for (const result of results) {
          logger2.debug("simulate result:", result);
          if (result.logs) {
            const filteredLog = result.logs.filter((log3) => log3 && log3.includes(keyword));
            logger2.debug("filteredLog:", logs);
            logger2.assertArgument(filteredLog.length !== 0, "simulate log not match keyword", "keyword", keyword);
            logs.push(...filteredLog);
          }
        }
        return logs;
      });
    }
    function parseSimulateLogToJson2(log3, keyword) {
      const results = log3.match(/{["\w:,]+}/g);
      if (!results || results.length !== 1) {
        return logger2.throwArgumentError("simulate log fail to match json", "keyword", keyword);
      }
      return results[0];
    }
    function parseSimulateValue2(log3, key) {
      const reg = new RegExp(`"${key}":(\\d+)`, "g");
      const results = reg.exec(log3);
      if (!results || results.length !== 2) {
        return logger2.throwArgumentError("simulate log fail to match key", "key", key);
      }
      return results[1];
    }
    function simulateTransaction2(connection, transactions, batchRequest) {
      return __async(this, null, function* () {
        let results = [];
        if (batchRequest) {
          const getLatestBlockhash = yield connection.getLatestBlockhash();
          const encodedTransactions = [];
          for (const transaction of transactions) {
            transaction.recentBlockhash = getLatestBlockhash.blockhash;
            transaction.lastValidBlockHeight = getLatestBlockhash.lastValidBlockHeight;
            const message = transaction._compile();
            const signData = message.serialize();
            const wireTransaction = transaction._serialize(signData);
            const encodedTransaction = wireTransaction.toString("base64");
            encodedTransactions.push(encodedTransaction);
          }
          const batch = encodedTransactions.map((keys) => {
            const args = connection._buildArgs([keys], void 0, "base64");
            return {
              methodName: "simulateTransaction",
              args
            };
          });
          const reqData = [];
          const itemReqIndex = 20;
          for (let i = 0; i < Math.ceil(batch.length / itemReqIndex); i++) {
            reqData.push(batch.slice(i * itemReqIndex, (i + 1) * itemReqIndex));
          }
          results = yield (yield Promise.all(
            reqData.map((i) => __async(this, null, function* () {
              const d = yield connection._rpcBatchRequest(i);
              return d.map((ii) => ii.result.value);
            }))
          )).flat();
        } else {
          try {
            results = yield Promise.all(
              transactions.map((transaction) => __async(this, null, function* () {
                return yield (yield connection.simulateTransaction(transaction)).value;
              }))
            );
          } catch (error) {
            if (error instanceof Error) {
              return logger2.throwError("failed to get info for multiple accounts", Logger2.errors.RPC_ERROR, {
                message: error.message
              });
            }
          }
        }
        return results;
      });
    }
    function splitTxAndSigners(_0) {
      return __async(this, arguments, function* ({
        connection,
        makeTxVersion,
        innerTransaction,
        lookupTableCache,
        computeBudgetConfig,
        payer
      }) {
        const lookupTableAddressAccount = lookupTableCache != null ? lookupTableCache : {};
        const allLTA = [
          ...new Set(innerTransaction.map((i) => {
            var _a;
            return ((_a = i.lookupTableAddress) != null ? _a : []).map((ii) => ii.toString());
          }).flat())
        ];
        const needCacheLTA = [];
        for (const item of allLTA) {
          if (lookupTableAddressAccount[item] === void 0)
            needCacheLTA.push(new import_web37.PublicKey(item));
        }
        const newCacheLTA = yield getMultipleLookupTableInfo2({ connection, address: needCacheLTA });
        for (const [key, value] of Object.entries(newCacheLTA))
          lookupTableAddressAccount[key] = value;
        const addComputeBudgetInnerTx = computeBudgetConfig ? addComputeBudget2(computeBudgetConfig).innerTransaction : void 0;
        const transactions = [];
        let itemIns = [];
        for (const itemInnerTx of innerTransaction) {
          if (itemInnerTx.instructions.length === 0)
            continue;
          const _itemIns = [...itemIns, itemInnerTx];
          const _addComputeBudgetInnerTx = addComputeBudgetInnerTx ? [addComputeBudgetInnerTx, ..._itemIns] : _itemIns;
          if (itemIns.length < 12 && (checkTx({ makeTxVersion, innerIns: _addComputeBudgetInnerTx, payer, lookupTableAddressAccount }) || checkTx({ makeTxVersion, innerIns: _itemIns, payer, lookupTableAddressAccount }))) {
            itemIns.push(itemInnerTx);
          } else {
            if (itemIns.length === 0)
              throw Error(" item ins too big ");
            let lookupTableAddress = void 0;
            if (makeTxVersion === 0) {
              lookupTableAddress = {};
              for (const item of [
                ...new Set(
                  itemIns.map((i) => {
                    var _a;
                    return (_a = i.lookupTableAddress) != null ? _a : [];
                  }).flat().map((i) => i.toString())
                )
              ]) {
                if (lookupTableAddressAccount[item] !== void 0)
                  lookupTableAddress[item] = lookupTableAddressAccount[item];
              }
            }
            if (checkTx({
              makeTxVersion,
              innerIns: addComputeBudgetInnerTx ? [addComputeBudgetInnerTx, ...itemIns] : itemIns,
              payer,
              lookupTableAddressAccount
            })) {
              const _i = addComputeBudgetInnerTx ? [addComputeBudgetInnerTx, ...itemIns] : itemIns;
              transactions.push({
                instructionTypes: _i.map((i) => i.instructionTypes).flat(),
                instructions: _i.map((i) => i.instructions).flat(),
                signers: itemIns.map((i) => i.signers).flat(),
                lookupTableAddress
              });
            } else {
              transactions.push({
                instructionTypes: itemIns.map((i) => i.instructionTypes).flat(),
                instructions: itemIns.map((i) => i.instructions).flat(),
                signers: itemIns.map((i) => i.signers).flat(),
                lookupTableAddress
              });
            }
            itemIns = [itemInnerTx];
          }
        }
        if (itemIns.length > 0) {
          let lookupTableAddress = void 0;
          if (makeTxVersion === 0) {
            lookupTableAddress = {};
            for (const item of [
              ...new Set(
                itemIns.map((i) => {
                  var _a;
                  return (_a = i.lookupTableAddress) != null ? _a : [];
                }).flat().map((i) => i.toString())
              )
            ]) {
              if (lookupTableAddressAccount[item] !== void 0)
                lookupTableAddress[item] = lookupTableAddressAccount[item];
            }
          }
          if (checkTx({
            makeTxVersion,
            innerIns: addComputeBudgetInnerTx ? [addComputeBudgetInnerTx, ...itemIns] : itemIns,
            payer,
            lookupTableAddressAccount
          })) {
            const _i = addComputeBudgetInnerTx ? [addComputeBudgetInnerTx, ...itemIns] : itemIns;
            transactions.push({
              instructionTypes: _i.map((i) => i.instructionTypes).flat(),
              instructions: _i.map((i) => i.instructions).flat(),
              signers: itemIns.map((i) => i.signers).flat(),
              lookupTableAddress
            });
          } else {
            transactions.push({
              instructionTypes: itemIns.map((i) => i.instructionTypes).flat(),
              instructions: itemIns.map((i) => i.instructions).flat(),
              signers: itemIns.map((i) => i.signers).flat(),
              lookupTableAddress
            });
          }
        }
        return transactions;
      });
    }
    function checkTx({
      makeTxVersion,
      innerIns,
      payer,
      lookupTableAddressAccount
    }) {
      const instructions = innerIns.map((i) => i.instructions).flat();
      const signers = [
        ...new Set(
          innerIns.map((i) => i.signers).flat().map((i) => i.publicKey.toString())
        )
      ].map((i) => new import_web37.PublicKey(i));
      const needLTA = innerIns.map((i) => {
        var _a;
        return (_a = i.lookupTableAddress) != null ? _a : [];
      }).flat().map((i) => i.toString());
      const lTaCache = {};
      const _lookupTableAddressAccount = lookupTableAddressAccount != null ? lookupTableAddressAccount : {};
      for (const item of needLTA) {
        if (_lookupTableAddressAccount[item] !== void 0) {
          lTaCache[item] = _lookupTableAddressAccount[item];
        }
      }
      return makeTxVersion === 0 ? _checkV0Tx({ instructions, payer, lookupTableAddressAccount: lTaCache }) : _checkLegacyTx({ instructions, payer, signers });
    }
    var MAX_BASE64_SIZE2 = 1644;
    function _checkLegacyTx({
      instructions,
      payer,
      signers
    }) {
      return forecastTransactionSize2(instructions, [payer, ...signers]);
    }
    function _checkV0Tx({
      instructions,
      payer,
      lookupTableAddressAccount
    }) {
      const transactionMessage = new import_web37.TransactionMessage({
        payerKey: payer,
        recentBlockhash: import_web37.Keypair.generate().publicKey.toString(),
        instructions
      });
      const messageV0 = transactionMessage.compileToV0Message(Object.values(lookupTableAddressAccount != null ? lookupTableAddressAccount : {}));
      try {
        return Buffer.from(messageV0.serialize()).toString("base64").length < MAX_BASE64_SIZE2;
      } catch (error) {
        return false;
      }
    }
    function getMultipleLookupTableInfo2(_0) {
      return __async(this, arguments, function* ({
        connection,
        address
      }) {
        const dataInfos = yield getMultipleAccountsInfo2(
          connection,
          [...new Set(address.map((i) => i.toString()))].map((i) => new import_web37.PublicKey(i))
        );
        const outDict = {};
        for (let i = 0; i < address.length; i++) {
          const info = dataInfos[i];
          const key = address[i];
          if (!info)
            continue;
          outDict[key.toString()] = new import_web37.AddressLookupTableAccount({
            key,
            state: import_web37.AddressLookupTableAccount.deserialize(info.data)
          });
        }
        return outDict;
      });
    }
    var import_bn4 = __toESM2(require_bn());
    var import_bn3 = __toESM2(require_bn());
    var Rounding2 = /* @__PURE__ */ ((Rounding3) => {
      Rounding3[Rounding3["ROUND_DOWN"] = 0] = "ROUND_DOWN";
      Rounding3[Rounding3["ROUND_HALF_UP"] = 1] = "ROUND_HALF_UP";
      Rounding3[Rounding3["ROUND_UP"] = 2] = "ROUND_UP";
      return Rounding3;
    })(Rounding2 || {});
    var ZERO2 = new import_bn3.default(0);
    var ONE2 = new import_bn3.default(1);
    var TWO = new import_bn3.default(2);
    var THREE = new import_bn3.default(3);
    var FIVE = new import_bn3.default(5);
    var TEN = new import_bn3.default(10);
    var _100 = new import_bn3.default(100);
    var _1000 = new import_bn3.default(1e3);
    var _10000 = new import_bn3.default(1e4);
    var logger3 = Logger2.from("entity/bignumber");
    var MAX_SAFE = 9007199254740991;
    function parseBigNumberish2(value) {
      if (value instanceof import_bn4.default) {
        return value;
      }
      if (typeof value === "string") {
        if (value.match(/^-?[0-9]+$/)) {
          return new import_bn4.default(value);
        }
        return logger3.throwArgumentError("invalid BigNumberish string", "value", value);
      }
      if (typeof value === "number") {
        if (value % 1) {
          return logger3.throwArgumentError("BigNumberish number underflow", "value", value);
        }
        if (value >= MAX_SAFE || value <= -MAX_SAFE) {
          return logger3.throwArgumentError("BigNumberish number overflow", "value", value);
        }
        return new import_bn4.default(String(value));
      }
      if (typeof value === "bigint") {
        return new import_bn4.default(value.toString());
      }
      return logger3.throwArgumentError("invalid BigNumberish value", "value", value);
    }
    function tenExponentiate(shift) {
      return TEN.pow(parseBigNumberish2(shift));
    }
    function divCeil2(a, b) {
      const dm = a.divmod(b);
      if (dm.mod.isZero())
        return dm.div;
      return dm.div.isNeg() ? dm.div.isubn(1) : dm.div.iaddn(1);
    }
    var SOL = {
      symbol: "SOL",
      name: "Solana",
      decimals: 9
    };
    var WSOL = {
      symbol: "WSOL",
      name: "Wrapped SOL",
      mint: "So11111111111111111111111111111111111111112",
      decimals: 9,
      extensions: {
        coingeckoId: "solana"
      }
    };
    var DEVNET_SPL_TOKENS = {
      WSOL: __spreadValues({}, WSOL)
    };
    var DEVNET_LP_TOKENS = {};
    var MAINNET_SPL_TOKENS = {
      WSOL: __spreadValues({}, WSOL),
      BTC: {
        symbol: "BTC",
        name: "Bitcoin",
        mint: "9n4nbM75f5Ui33ZbPYXn59EwSgE8CGsHtAeTH5YFeJ9E",
        decimals: 6,
        extensions: {
          coingeckoId: "bitcoin"
        }
      },
      ETH: {
        symbol: "ETH",
        name: "Ethereum",
        mint: "2FPyTwcZLUg1MDrwsyoP4D6s1tM7hAkHYRjkNb5w6Pxk",
        decimals: 6,
        extensions: {
          coingeckoId: "ethereum"
        }
      },
      USDT: {
        symbol: "USDT",
        name: "Tether",
        mint: "Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB",
        decimals: 6,
        extensions: {
          coingeckoId: "tether"
        }
      },
      WUSDT: {
        symbol: "WUSDT",
        name: "Wrapped USDT",
        mint: "BQcdHdAQW1hczDbBi9hiegXAR7A98Q9jx3X3iBBBDiq4",
        decimals: 6,
        extensions: {
          coingeckoId: "tether"
        }
      },
      USDC: {
        symbol: "USDC",
        name: "USD Coin",
        mint: "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v",
        decimals: 6,
        extensions: {
          coingeckoId: "usd-coin"
        }
      },
      WUSDC: {
        symbol: "WUSDC",
        name: "Wrapped USDC",
        mint: "BXXkv6z8ykpG1yuvUDPgh732wzVHB69RnB9YgSYh3itW",
        decimals: 6,
        extensions: {
          coingeckoId: "usd-coin"
        }
      },
      YFI: {
        symbol: "YFI",
        name: "YFI",
        mint: "3JSf5tPeuscJGtaCp5giEiDhv51gQ4v3zWg8DGgyLfAB",
        decimals: 6,
        extensions: {
          coingeckoId: "yearn-finance"
        }
      },
      LINK: {
        symbol: "LINK",
        name: "Chainlink",
        mint: "CWE8jPTUYhdCTZYWPTe1o5DFqfdjzWKc9WKz6rSjQUdG",
        decimals: 6,
        extensions: {
          coingeckoId: "chainlink"
        }
      },
      XRP: {
        symbol: "XRP",
        name: "XRP",
        mint: "Ga2AXHpfAF6mv2ekZwcsJFqu7wB4NV331qNH7fW9Nst8",
        decimals: 6,
        extensions: {
          coingeckoId: "ripple"
        }
      },
      SUSHI: {
        symbol: "SUSHI",
        name: "SUSHI",
        mint: "AR1Mtgh7zAtxuxGd2XPovXPVjcSdY3i4rQYisNadjfKy",
        decimals: 6,
        extensions: {
          coingeckoId: "sushi"
        }
      },
      ALEPH: {
        symbol: "ALEPH",
        name: "ALEPH",
        mint: "CsZ5LZkDS7h9TDKjrbL7VAwQZ9nsRu8vJLhRYfmGaN8K",
        decimals: 6,
        extensions: {
          coingeckoId: "aleph"
        }
      },
      SXP: {
        symbol: "SXP",
        name: "SXP",
        mint: "SF3oTvfWzEP3DTwGSvUXRrGTvr75pdZNnBLAH9bzMuX",
        decimals: 6,
        extensions: {
          coingeckoId: "swipe"
        }
      },
      HGET: {
        symbol: "HGET",
        name: "HGET",
        mint: "BtZQfWqDGbk9Wf2rXEiWyQBdBY1etnUUn6zEphvVS7yN",
        decimals: 6,
        extensions: {
          coingeckoId: "hedget"
        }
      },
      CREAM: {
        symbol: "CREAM",
        name: "CREAM",
        mint: "5Fu5UUgbjpUvdBveb3a1JTNirL8rXtiYeSMWvKjtUNQv",
        decimals: 6,
        extensions: {
          coingeckoId: "cream-2"
        }
      },
      UNI: {
        symbol: "UNI",
        name: "UNI",
        mint: "DEhAasscXF4kEGxFgJ3bq4PpVGp5wyUxMRvn6TzGVHaw",
        decimals: 6,
        extensions: {
          coingeckoId: "uniswap"
        }
      },
      SRM: {
        symbol: "SRM",
        name: "Serum",
        mint: "SRMuApVNdxXokk5GT7XD5cUUgXMBCoAz2LHeuAoKWRt",
        decimals: 6,
        extensions: {
          coingeckoId: "serum"
        }
      },
      FTT: {
        symbol: "FTT",
        name: "FTX Token",
        mint: "AGFEad2et2ZJif9jaGpdMixQqvW5i81aBdvKe7PHNfz3",
        decimals: 6,
        extensions: {
          coingeckoId: "ftx-token"
        }
      },
      MSRM: {
        symbol: "MSRM",
        name: "MegaSerum",
        mint: "MSRMcoVyrFxnSgo5uXwone5SKcGhT1KEJMFEkMEWf9L",
        decimals: 0,
        extensions: {
          coingeckoId: "megaserum"
        }
      },
      TOMO: {
        symbol: "TOMO",
        name: "TOMO",
        mint: "GXMvfY2jpQctDqZ9RoU3oWPhufKiCcFEfchvYumtX7jd",
        decimals: 6,
        extensions: {
          coingeckoId: "tomochain"
        }
      },
      KARMA: {
        symbol: "KARMA",
        name: "KARMA",
        mint: "EcqExpGNFBve2i1cMJUTR4bPXj4ZoqmDD2rTkeCcaTFX",
        decimals: 4,
        extensions: {
          coingeckoId: "karma-dao"
        }
      },
      LUA: {
        symbol: "LUA",
        name: "LUA",
        mint: "EqWCKXfs3x47uVosDpTRgFniThL9Y8iCztJaapxbEaVX",
        decimals: 6,
        extensions: {
          coingeckoId: "lua-token"
        }
      },
      MATH: {
        symbol: "MATH",
        name: "MATH",
        mint: "GeDS162t9yGJuLEHPWXXGrb1zwkzinCgRwnT8vHYjKza",
        decimals: 6,
        extensions: {
          coingeckoId: "math"
        }
      },
      KEEP: {
        symbol: "KEEP",
        name: "KEEP",
        mint: "GUohe4DJUA5FKPWo3joiPgsB7yzer7LpDmt1Vhzy3Zht",
        decimals: 6,
        extensions: {
          coingeckoId: "keep-network"
        }
      },
      SWAG: {
        symbol: "SWAG",
        name: "SWAG",
        mint: "9F9fNTT6qwjsu4X4yWYKZpsbw5qT7o6yR2i57JF2jagy",
        decimals: 6,
        extensions: {
          coingeckoId: "swag-finance"
        }
      },
      FIDA: {
        symbol: "FIDA",
        name: "Bonfida",
        mint: "EchesyfXePKdLtoiZSL8pBe8Myagyy8ZRqsACNCFGnvp",
        decimals: 6,
        extensions: {
          coingeckoId: "bonfida"
        }
      },
      KIN: {
        symbol: "KIN",
        name: "Kin",
        mint: "kinXdEcpDQeHPEuQnqmUgtYykqKGVFq6CeVX5iAHJq6",
        decimals: 5,
        extensions: {
          coingeckoId: "kin"
        }
      },
      MAPS: {
        symbol: "MAPS",
        name: "MAPS",
        mint: "MAPS41MDahZ9QdKXhVa4dWB9RuyfV4XqhyAZ8XcYepb",
        decimals: 6,
        extensions: {
          coingeckoId: "maps"
        }
      },
      OXY: {
        symbol: "OXY",
        name: "Oxygen",
        mint: "z3dn17yLaGMKffVogeFHQ9zWVcXgqgf3PQnDsNs2g6M",
        decimals: 6,
        extensions: {
          coingeckoId: "oxygen"
        }
      },
      RAY: {
        symbol: "RAY",
        name: "Raydium",
        mint: "4k3Dyjzvzp8eMZWUXbBCjEvwSkkk59S5iCNLY3QrkX6R",
        decimals: 6,
        extensions: {
          coingeckoId: "raydium"
        }
      },
      xCOPE: {
        symbol: "xCOPE",
        name: "xCOPE",
        mint: "3K6rftdAaQYMPunrtNRHgnK2UAtjm2JwyT2oCiTDouYE",
        decimals: 0,
        extensions: {
          coingeckoId: "cope"
        }
      },
      COPE: {
        symbol: "COPE",
        name: "Cope",
        mint: "8HGyAAB1yoM1ttS7pXjHMa3dukTFGQggnFFH3hJZgzQh",
        decimals: 6,
        extensions: {
          coingeckoId: "cope"
        }
      },
      STEP: {
        symbol: "STEP",
        name: "Step Finance",
        mint: "StepAscQoEioFxxWGnh2sLBDFp9d8rvKz2Yp39iDpyT",
        decimals: 9,
        extensions: {
          coingeckoId: "step-finance"
        }
      },
      MEDIA: {
        symbol: "MEDIA",
        name: "Media Network",
        mint: "ETAtLmCmsoiEEKfNrHKJ2kYy3MoABhU6NQvpSfij5tDs",
        decimals: 6,
        extensions: {
          coingeckoId: "media-network"
        }
      },
      ROPE: {
        symbol: "ROPE",
        name: "Rope Token",
        mint: "8PMHT4swUMtBzgHnh5U564N5sjPSiUz2cjEQzFnnP1Fo",
        decimals: 9,
        extensions: {
          coingeckoId: "rope-token"
        }
      },
      MER: {
        symbol: "MER",
        name: "Mercurial",
        mint: "MERt85fc5boKw3BW1eYdxonEuJNvXbiMbs6hvheau5K",
        decimals: 6,
        extensions: {
          coingeckoId: "mercurial"
        }
      },
      TULIP: {
        symbol: "TULIP",
        name: "Tulip Protocol",
        mint: "TuLipcqtGVXP9XR62wM8WWCm6a9vhLs7T1uoWBk6FDs",
        decimals: 6,
        extensions: {
          coingeckoId: "solfarm"
        }
      },
      SNY: {
        symbol: "SNY",
        name: "SNY",
        mint: "4dmKkXNHdgYsXqBHCuMikNQWwVomZURhYvkkX5c4pQ7y",
        decimals: 6,
        extensions: {
          coingeckoId: "synthetify-token"
        }
      },
      SLRS: {
        symbol: "SLRS",
        name: "SLRS",
        mint: "SLRSSpSLUTP7okbCUBYStWCo1vUgyt775faPqz8HUMr",
        decimals: 6,
        extensions: {
          coingeckoId: "solrise-finance"
        }
      },
      WOO: {
        symbol: "WOO",
        name: "WOO Network",
        mint: "E5rk3nmgLUuKUiS94gg4bpWwWwyjCMtddsAXkTFLtHEy",
        decimals: 6,
        extensions: {
          coingeckoId: "woo-network"
        }
      },
      BOP: {
        symbol: "BOP",
        name: "Boring Protocol",
        mint: "BLwTnYKqf7u4qjgZrrsKeNs2EzWkMLqVCu6j8iHyrNA3",
        decimals: 8,
        extensions: {
          coingeckoId: "boring-protocol"
        }
      },
      SAMO: {
        symbol: "SAMO",
        name: "Samoyedcoin",
        mint: "7xKXtg2CW87d97TXJSDpbD5jBkheTqA83TZRuJosgAsU",
        decimals: 9,
        extensions: {
          coingeckoId: "samoyedcoin"
        }
      },
      renBTC: {
        symbol: "renBTC",
        name: "renBTC",
        mint: "CDJWUqTcYTVAKXAVXoQZFes5JUFc7owSeq7eMQcDSbo5",
        decimals: 8,
        extensions: {
          coingeckoId: "renbtc"
        }
      },
      renDOGE: {
        symbol: "renDOGE",
        name: "renDOGE",
        mint: "ArUkYE2XDKzqy77PRRGjo4wREWwqk6RXTfM9NeqzPvjU",
        decimals: 8,
        extensions: {
          coingeckoId: "rendoge"
        }
      },
      LIKE: {
        symbol: "LIKE",
        name: "Only1",
        mint: "3bRTivrVsitbmCTGtqwp7hxXPsybkjn4XLNtPsHqa3zR",
        decimals: 9,
        extensions: {
          coingeckoId: "only1"
        }
      },
      DXL: {
        symbol: "DXL",
        name: "Dexlab",
        mint: "GsNzxJfFn6zQdJGeYsupJWzUAm57Ba7335mfhWvFiE9Z",
        decimals: 6,
        extensions: {
          coingeckoId: "dexlab"
        }
      },
      mSOL: {
        symbol: "mSOL",
        name: "Marinade staked SOL",
        mint: "mSoLzYCxHdYgdzU16g5QSh3i5K3z3KZK7ytfqcJm7So",
        decimals: 9,
        extensions: {
          coingeckoId: "msol"
        }
      },
      PAI: {
        symbol: "PAI",
        name: "Parrot USD",
        mint: "Ea5SjE2Y6yvCeW5dYTn7PYMuW5ikXkvbGdcmSnXeaLjS",
        decimals: 6,
        extensions: {
          coingeckoId: "parrot-usd"
        }
      },
      PORT: {
        symbol: "PORT",
        name: "Port Finance",
        mint: "PoRTjZMPXb9T7dyU7tpLEZRQj7e6ssfAE62j2oQuc6y",
        decimals: 6,
        extensions: {
          coingeckoId: "port-finance"
        }
      },
      MNGO: {
        symbol: "MNGO",
        name: "Mango",
        mint: "MangoCzJ36AjZyKwVj3VnYU4GTonjfVEnJmvvWaxLac",
        decimals: 6,
        extensions: {
          coingeckoId: "mango-markets"
        }
      },
      CRP: {
        symbol: "CRP",
        name: "CropperFinance",
        mint: "DubwWZNWiNGMMeeQHPnMATNj77YZPZSAz2WVR5WjLJqz",
        decimals: 9,
        extensions: {
          coingeckoId: "cropperfinance"
        }
      },
      ATLAS: {
        symbol: "ATLAS",
        name: "Star Atlas",
        mint: "ATLASXmbPQxBUYbxPsV97usA3fPQYEqzQBUHgiFCUsXx",
        decimals: 8,
        extensions: {
          coingeckoId: "star-atlas"
        }
      },
      POLIS: {
        symbol: "POLIS",
        name: "Star Atlas DAO",
        mint: "poLisWXnNRwC6oBu1vHiuKQzFjGL4XDSu4g9qjz9qVk",
        decimals: 8,
        extensions: {
          coingeckoId: "star-atlas-dao"
        }
      },
      GRAPE: {
        symbol: "GRAPE",
        name: "Grape Protocol",
        mint: "8upjSpvjcdpuzhfR1zriwg5NXkwDruejqNE9WNbPRtyA",
        decimals: 6,
        extensions: {
          coingeckoId: "grape-2"
        }
      },
      GENE: {
        symbol: "GENE",
        name: "Genopets",
        mint: "GENEtH5amGSi8kHAtQoezp1XEXwZJ8vcuePYnXdKrMYz",
        decimals: 9,
        extensions: {
          coingeckoId: "genopets"
        }
      },
      DFL: {
        symbol: "DFL",
        name: "DeFi Land",
        mint: "DFL1zNkaGPWm1BqAVqRjCZvHmwTFrEaJtbzJWgseoNJh",
        decimals: 9,
        extensions: {
          coingeckoId: "defi-land"
        }
      },
      CHEEMS: {
        symbol: "CHEEMS",
        name: "Cheems",
        mint: "3FoUAsGDbvTD6YZ4wVKJgTB76onJUKz7GPEBNiR5b8wc",
        decimals: 4,
        extensions: {
          coingeckoId: "cheems"
        }
      },
      stSOL: {
        symbol: "stSOL",
        name: "Lido Staked SOL",
        mint: "7dHbWXmci3dT8UFYWYZweBLXgycu7Y3iL6trKn1Y7ARj",
        decimals: 9,
        extensions: {
          coingeckoId: "lido-staked-sol"
        }
      },
      LARIX: {
        symbol: "LARIX",
        name: "Larix",
        mint: "Lrxqnh6ZHKbGy3dcrCED43nsoLkM1LTzU2jRfWe8qUC",
        decimals: 6,
        extensions: {
          coingeckoId: "larix"
        }
      },
      RIN: {
        symbol: "RIN",
        name: "Aldrin",
        mint: "E5ndSkaB17Dm7CsD22dvcjfrYSDLCxFcMd6z8ddCk5wp",
        decimals: 9,
        extensions: {
          coingeckoId: "aldrin"
        }
      },
      APEX: {
        symbol: "APEX",
        name: "ApeXit Finance",
        mint: "51tMb3zBKDiQhNwGqpgwbavaGH54mk8fXFzxTc1xnasg",
        decimals: 9,
        extensions: {
          coingeckoId: "apexit-finance"
        }
      },
      MNDE: {
        symbol: "MNDE",
        name: "Marinade",
        mint: "MNDEFzGvMt87ueuHvVU9VcTqsAP5b3fTGPsHuuPA5ey",
        decimals: 9,
        extensions: {
          coingeckoId: "marinade"
        }
      },
      LIQ: {
        symbol: "LIQ",
        name: "LIQ Protocol",
        mint: "4wjPQJ6PrkC4dHhYghwJzGBVP78DkBzA2U3kHoFNBuhj",
        decimals: 6,
        extensions: {
          coingeckoId: "liq-protocol"
        }
      },
      WAG: {
        symbol: "WAG",
        name: "Waggle Network",
        mint: "5tN42n9vMi6ubp67Uy4NnmM5DMZYN8aS8GeB3bEDHr6E",
        decimals: 9,
        extensions: {
          coingeckoId: "waggle-network"
        }
      },
      wLDO: {
        symbol: "wLDO",
        name: "wLDO",
        mint: "HZRCwxP2Vq9PCpPXooayhJ2bxTpo5xfpQrwB1svh332p",
        decimals: 8,
        extensions: {}
      },
      SLIM: {
        symbol: "SLIM",
        name: "Solanium",
        mint: "xxxxa1sKNGwFtw2kFn8XauW9xq8hBZ5kVtcSesTT9fW",
        decimals: 6,
        extensions: {
          coingeckoId: "solanium"
        }
      },
      PRT: {
        symbol: "PRT",
        name: "Parrot Protocol",
        mint: "PRT88RkA4Kg5z7pKnezeNH4mafTvtQdfFgpQTGRjz44",
        decimals: 6,
        extensions: {
          coingeckoId: "parrot-protocol"
        }
      },
      SBR: {
        symbol: "SBR",
        name: "SBR",
        mint: "Saber2gLauYim4Mvftnrasomsv6NvAuncvMEZwcLpD1",
        decimals: 6,
        extensions: {}
      },
      FAB: {
        symbol: "FAB",
        name: "Fabric",
        mint: "EdAhkbj5nF9sRM7XN7ewuW8C9XEUMs8P7cnoQ57SYE96",
        decimals: 9,
        extensions: {
          coingeckoId: "fabric"
        }
      },
      ABR: {
        symbol: "ABR",
        name: "Allbridge",
        mint: "a11bdAAuV8iB2fu7X6AxAvDTo1QZ8FXB3kk5eecdasp",
        decimals: 9,
        extensions: {
          coingeckoId: "allbridge"
        }
      },
      IVN: {
        symbol: "IVN",
        name: "Investin",
        mint: "iVNcrNE9BRZBC9Aqf753iZiZfbszeAVUoikgT9yvr2a",
        decimals: 6,
        extensions: {
          coingeckoId: "investin"
        }
      },
      CYS: {
        symbol: "CYS",
        name: "Cyclos",
        mint: "BRLsMczKuaR5w9vSubF4j8HwEGGprVAyyVgS4EX7DKEg",
        decimals: 6,
        extensions: {
          coingeckoId: "cyclos"
        }
      },
      FRKT: {
        symbol: "FRKT",
        name: "FRAKT Token",
        mint: "ErGB9xa24Szxbk1M28u2Tx8rKPqzL6BroNkkzk5rG4zj",
        decimals: 8,
        extensions: {
          coingeckoId: "frakt-token"
        }
      },
      AURY: {
        symbol: "AURY",
        name: "Aurory",
        mint: "AURYydfxJib1ZkTir1Jn1J9ECYUtjb6rKQVmtYaixWPP",
        decimals: 9,
        extensions: {
          coingeckoId: "aurory"
        }
      },
      SYP: {
        symbol: "SYP",
        name: "Sypool",
        mint: "FnKE9n6aGjQoNWRBZXy4RW6LZVao7qwBonUbiD7edUmZ",
        decimals: 9,
        extensions: {
          coingeckoId: "sypool"
        }
      },
      WOOF: {
        symbol: "WOOF",
        name: "WOOF",
        mint: "9nEqaUcb16sQ3Tn1psbkWqyhPdLmfHWjKGymREjsAgTE",
        decimals: 6,
        extensions: {
          coingeckoId: "woof-token"
        }
      },
      ORCA: {
        symbol: "ORCA",
        name: "Orca",
        mint: "orcaEKTdK7LKz57vaAYr9QeNsVEPfiu6QeMU1kektZE",
        decimals: 6,
        extensions: {
          coingeckoId: "orca"
        }
      },
      SLND: {
        symbol: "SLND",
        name: "Solend",
        mint: "SLNDpmoWTVADgEdndyvWzroNL7zSi1dF9PC3xHGtPwp",
        decimals: 6,
        extensions: {
          coingeckoId: "solend"
        }
      },
      weWETH: {
        symbol: "weWETH",
        name: "weWETH",
        mint: "7vfCXTUXx5WJV5JADk17DUJ4ksgau7utNKj4b963voxs",
        decimals: 8,
        extensions: {}
      },
      weUNI: {
        symbol: "weUNI",
        name: "weUNI",
        mint: "8FU95xFJhUUkyyCLU13HSzDLs7oC4QZdXQHL6SCeab36",
        decimals: 8,
        extensions: {}
      },
      weSUSHI: {
        symbol: "weSUSHI",
        name: "weSUSHI",
        mint: "ChVzxWRmrTeSgwd3Ui3UumcN8KX7VK3WaD4KGeSKpypj",
        decimals: 8,
        extensions: {}
      },
      GOFX: {
        symbol: "GOFX",
        name: "GooseFX",
        mint: "GFX1ZjR2P15tmrSwow6FjyDYcEkoFb4p4gJCpLBjaxHD",
        decimals: 9,
        extensions: {
          coingeckoId: "goosefx"
        }
      },
      IN: {
        symbol: "IN",
        name: "Invictus",
        mint: "inL8PMVd6iiW3RCBJnr5AsrRN6nqr4BTrcNuQWQSkvY",
        decimals: 9,
        extensions: {
          coingeckoId: "invictus"
        }
      },
      weDYDX: {
        symbol: "weDYDX",
        name: "weDYDX",
        mint: "4Hx6Bj56eGyw8EJrrheM6LBQAvVYRikYCWsALeTrwyRU",
        decimals: 8,
        extensions: {}
      },
      STARS: {
        symbol: "STARS",
        name: "StarLaunch",
        mint: "HCgybxq5Upy8Mccihrp7EsmwwFqYZtrHrsmsKwtGXLgW",
        decimals: 6,
        extensions: {
          coingeckoId: "starlaunch"
        }
      },
      weAXS: {
        symbol: "weAXS",
        name: "weAXS",
        mint: "HysWcbHiYY9888pHbaqhwLYZQeZrcQMXKQWRqS7zcPK5",
        decimals: 8,
        extensions: {}
      },
      weSHIB: {
        symbol: "weSHIB",
        name: "weSHIB",
        mint: "CiKu4eHsVrc1eueVQeHn7qhXTcVu95gSQmBpX4utjL9z",
        decimals: 8,
        extensions: {}
      },
      OXS: {
        symbol: "OXS",
        name: "Oxbull Solana",
        mint: "4TGxgCSJQx2GQk9oHZ8dC5m3JNXTYZHjXumKAW3vLnNx",
        decimals: 9,
        extensions: {
          coingeckoId: "oxbull-solana"
        }
      },
      CWAR: {
        symbol: "CWAR",
        name: "Cryowar",
        mint: "HfYFjMKNZygfMC8LsQ8LtpPsPxEJoXJx4M6tqi75Hajo",
        decimals: 9,
        extensions: {
          coingeckoId: "cryowar-token"
        }
      },
      UPS: {
        symbol: "UPS",
        name: "UPFI Network",
        mint: "EwJN2GqUGXXzYmoAciwuABtorHczTA5LqbukKXV1viH7",
        decimals: 6,
        extensions: {
          coingeckoId: "upfi-network"
        }
      },
      weSAND: {
        symbol: "weSAND",
        name: "weSAND",
        mint: "49c7WuCZkQgc3M4qH8WuEUNXfgwupZf1xqWkDQ7gjRGt",
        decimals: 8,
        extensions: {}
      },
      weMANA: {
        symbol: "weMANA",
        name: "weMANA",
        mint: "7dgHoN8wBZCc5wbnQ2C47TDnBMAxG4Q5L3KjP67z8kNi",
        decimals: 8,
        extensions: {}
      },
      CAVE: {
        symbol: "CAVE",
        name: "Crypto Cavemen",
        mint: "4SZjjNABoqhbd4hnapbvoEPEqT8mnNkfbEoAwALf1V8t",
        decimals: 6,
        extensions: {
          coingeckoId: "cave"
        }
      },
      JSOL: {
        symbol: "JSOL",
        name: "JPool",
        mint: "7Q2afV64in6N6SeZsAAB81TJzwDoD6zpqmHkzi9Dcavn",
        decimals: 9,
        extensions: {
          coingeckoId: "jpool"
        }
      },
      APT: {
        symbol: "APT",
        name: "Apricot",
        mint: "APTtJyaRX5yGTsJU522N4VYWg3vCvSb65eam5GrPT5Rt",
        decimals: 6,
        extensions: {
          coingeckoId: "apricot"
        }
      },
      SONAR: {
        symbol: "SONAR",
        name: "SonarWatch",
        mint: "sonarX4VtVkQemriJeLm6CKeW3GDMyiBnnAEMw1MRAE",
        decimals: 9,
        extensions: {
          coingeckoId: "sonarwatch"
        }
      },
      SHILL: {
        symbol: "SHILL",
        name: "SHILL Token",
        mint: "6cVgJUqo4nmvQpbgrDZwyfd6RwWw5bfnCamS3M9N1fd",
        decimals: 6,
        extensions: {
          coingeckoId: "shill-token"
        }
      },
      TTT: {
        symbol: "TTT",
        name: "TabTrader",
        mint: "FNFKRV3V8DtA3gVJN6UshMiLGYA8izxFwkNWmJbFjmRj",
        decimals: 6,
        extensions: {
          coingeckoId: "tabtrader"
        }
      },
      BOKU: {
        symbol: "BOKU",
        name: "Boryoku Dragonz",
        mint: "CN7qFa5iYkHz99PTctvT4xXUHnxwjQ5MHxCuTJtPN5uS",
        decimals: 9,
        extensions: {
          coingeckoId: "boku"
        }
      },
      MIMO: {
        symbol: "MIMO",
        name: "Million Monke",
        mint: "9TE7ebz1dsFo1uQ2T4oYAKSm39Y6fWuHrd6Uk6XaiD16",
        decimals: 9,
        extensions: {
          coingeckoId: "million-monke"
        }
      },
      wbWBNB: {
        symbol: "wbWBNB",
        name: "wbWBNB",
        mint: "9gP2kCy3wA1ctvYWQk75guqXuHfrEomqydHLtcTCqiLa",
        decimals: 8,
        extensions: {}
      },
      wePEOPLE: {
        symbol: "wePEOPLE",
        name: "wePEOPLE",
        mint: "CobcsUrt3p91FwvULYKorQejgsm5HoQdv5T8RUZ6PnLA",
        decimals: 8,
        extensions: {}
      },
      XTAG: {
        symbol: "XTAG",
        name: "xHashtag",
        mint: "5gs8nf4wojB5EXgDUWNLwXpknzgV2YWDhveAeBZpVLbp",
        decimals: 6,
        extensions: {
          coingeckoId: "xhashtag"
        }
      },
      KKO: {
        symbol: "KKO",
        name: "Kineko",
        mint: "kiNeKo77w1WBEzFFCXrTDRWGRWGP8yHvKC9rX6dqjQh",
        decimals: 9,
        extensions: {
          coingeckoId: "kineko"
        }
      },
      VI: {
        symbol: "VI",
        name: "Vybit",
        mint: "7zBWymxbZt7PVHQzfi3i85frc1YRiQc23K7bh3gos8ZC",
        decimals: 9,
        extensions: {
          coingeckoId: "vybit"
        }
      },
      SOLC: {
        symbol: "SOLC",
        name: "Solcubator",
        mint: "Bx1fDtvTN6NvE4kjdPHQXtmGSg582bZx9fGy4DQNMmAT",
        decimals: 9,
        extensions: {
          coingeckoId: "solcubator"
        }
      },
      STR: {
        symbol: "STR",
        name: "Solster",
        mint: "9zoqdwEBKWEi9G5Ze8BSkdmppxGgVv1Kw4LuigDiNr9m",
        decimals: 9,
        extensions: {
          coingeckoId: "solster"
        }
      },
      SPWN: {
        symbol: "SPWN",
        name: "Bitspawn",
        mint: "5U9QqCPhqXAJcEv9uyzFJd5zhN93vuPk1aNNkXnUfPnt",
        decimals: 9,
        extensions: {
          coingeckoId: "bitspawn"
        }
      },
      ISOLA: {
        symbol: "ISOLA",
        name: "Intersola",
        mint: "333iHoRM2Awhf9uVZtSyTfU8AekdGrgQePZsKMFPgKmS",
        decimals: 6,
        extensions: {
          coingeckoId: "intersola"
        }
      },
      RUN: {
        symbol: "RUN",
        name: "Run",
        mint: "6F9XriABHfWhit6zmMUYAQBSy6XK5VF1cHXuW5LDpRtC",
        decimals: 9,
        extensions: {
          coingeckoId: "run"
        }
      },
      REAL: {
        symbol: "REAL",
        name: "Realy Metaverse",
        mint: "AD27ov5fVU2XzwsbvnFvb1JpCBaCB5dRXrczV9CqSVGb",
        decimals: 9,
        extensions: {
          coingeckoId: "realy-metaverse"
        }
      },
      CRWNY: {
        symbol: "CRWNY",
        name: "CRWNY",
        mint: "CRWNYkqdgvhGGae9CKfNka58j6QQkaD5bLhKXvUYqnc1",
        decimals: 6,
        extensions: {}
      },
      BLOCK: {
        symbol: "BLOCK",
        name: "Blockasset",
        mint: "NFTUkR4u7wKxy9QLaX2TGvd9oZSWoMo4jqSJqdMb7Nk",
        decimals: 6,
        extensions: {
          coingeckoId: "blockasset"
        }
      },
      SOLAR: {
        symbol: "SOLAR",
        name: "Solar",
        mint: "2wmKXX1xsxLfrvjEPrt2UHiqj8Gbzwxvffr9qmNjsw8g",
        decimals: 9,
        extensions: {
          coingeckoId: "solar"
        }
      },
      BASIS: {
        symbol: "BASIS",
        name: "basis.markets",
        mint: "Basis9oJw9j8cw53oMV7iqsgo6ihi9ALw4QR31rcjUJa",
        decimals: 6,
        extensions: {
          coingeckoId: "basis-markets"
        }
      },
      SOLX: {
        symbol: "SOLX",
        name: "Soldex",
        mint: "CH74tuRLTYcxG7qNJCsV9rghfLXJCQJbsu7i52a8F1Gn",
        decimals: 9,
        extensions: {
          coingeckoId: "soldex"
        }
      },
      CHICKS: {
        symbol: "CHICKS",
        name: "SolChicks Token",
        mint: "cxxShYRVcepDudXhe7U62QHvw8uBJoKFifmzggGKVC2",
        decimals: 9,
        extensions: {
          coingeckoId: "solchicks-token"
        }
      },
      GST: {
        symbol: "GST",
        name: "GST",
        mint: "AFbX8oGjGpmVFywbVouvhQSRmiW2aR1mohfahi4Y2AdB",
        decimals: 9,
        extensions: {
          coingeckoId: "gst"
        }
      },
      MBS: {
        symbol: "MBS",
        name: "MonkeyBall",
        mint: "Fm9rHUTF5v3hwMLbStjZXqNBBoZyGriQaFM6sTFz3K8A",
        decimals: 6,
        extensions: {
          coingeckoId: "monkeyball"
        }
      },
      PRISM: {
        symbol: "PRISM",
        name: "Prism",
        mint: "PRSMNsEPqhGVCH1TtWiJqPjJyh2cKrLostPZTNy1o5x",
        decimals: 6,
        extensions: {
          coingeckoId: "prism"
        }
      },
      MEAN: {
        symbol: "MEAN",
        name: "Meanfi",
        mint: "MEANeD3XDdUmNMsRGjASkSWdC8prLYsoRJ61pPeHctD",
        decimals: 6,
        extensions: {
          coingeckoId: "meanfi"
        }
      },
      TINY: {
        symbol: "TINY",
        name: "Tiny Colony",
        mint: "HKfs24UEDQpHS5hUyKYkHd9q7GY5UQ679q2bokeL2whu",
        decimals: 6,
        extensions: {
          coingeckoId: "tiny-colony"
        }
      },
      SHDW: {
        symbol: "SHDW",
        name: "GenesysGo Shadow",
        mint: "SHDWyBxihqiCj6YekG2GUr7wqKLeLAMK1gHZck9pL6y",
        decimals: 9,
        extensions: {
          coingeckoId: "genesysgo-shadow"
        }
      },
      SCY: {
        symbol: "SCY",
        name: "Synchrony",
        mint: "SCYfrGCw8aDiqdgcpdGjV6jp4UVVQLuphxTDLNWu36f",
        decimals: 9,
        extensions: {
          coingeckoId: "synchrony"
        }
      },
      SLC: {
        symbol: "SLC",
        name: "Solice",
        mint: "METAmTMXwdb8gYzyCPfXXFmZZw4rUsXX58PNsDg7zjL",
        decimals: 6,
        extensions: {
          coingeckoId: "solice"
        }
      }
    };
    var MAINNET_LP_TOKENS = {
      FIDA_RAY_V4: {
        symbol: "FIDA-RAY",
        name: "FIDA-RAY V4 LP",
        mint: "DsBuznXRTmzvEdb36Dx3aVLVo1XmH7r1PRZUFugLPTFv",
        base: MAINNET_SPL_TOKENS.FIDA,
        quote: MAINNET_SPL_TOKENS.RAY,
        decimals: MAINNET_SPL_TOKENS.FIDA.decimals,
        version: 4
      },
      OXY_RAY_V4: {
        symbol: "OXY-RAY",
        name: "OXY-RAY V4 LP",
        mint: "FwaX9W7iThTZH5MFeasxdLpxTVxRcM7ZHieTCnYog8Yb",
        base: MAINNET_SPL_TOKENS.OXY,
        quote: MAINNET_SPL_TOKENS.RAY,
        decimals: MAINNET_SPL_TOKENS.OXY.decimals,
        version: 4
      },
      MAPS_RAY_V4: {
        symbol: "MAPS-RAY",
        name: "MAPS-RAY V4 LP",
        mint: "CcKK8srfVdTSsFGV3VLBb2YDbzF4T4NM2C3UEjC39RLP",
        base: MAINNET_SPL_TOKENS.MAPS,
        quote: MAINNET_SPL_TOKENS.RAY,
        decimals: MAINNET_SPL_TOKENS.MAPS.decimals,
        version: 4
      },
      KIN_RAY_V4: {
        symbol: "KIN-RAY",
        name: "KIN-RAY V4 LP",
        mint: "CHT8sft3h3gpLYbCcZ9o27mT5s3Z6VifBVbUiDvprHPW",
        base: MAINNET_SPL_TOKENS.KIN,
        quote: MAINNET_SPL_TOKENS.RAY,
        // mistake, a special one
        decimals: 6,
        version: 4
      },
      RAY_USDT_V4: {
        symbol: "RAY-USDT",
        name: "RAY-USDT V4 LP",
        mint: "C3sT1R3nsw4AVdepvLTLKr5Gvszr7jufyBWUCvy4TUvT",
        base: MAINNET_SPL_TOKENS.RAY,
        quote: MAINNET_SPL_TOKENS.USDT,
        decimals: MAINNET_SPL_TOKENS.RAY.decimals,
        version: 4
      },
      SOL_USDC_V4: {
        symbol: "SOL-USDC",
        name: "SOL-USDC V4 LP",
        mint: "8HoQnePLqPj4M7PUDzfw8e3Ymdwgc7NLGnaTUapubyvu",
        base: MAINNET_SPL_TOKENS.WSOL,
        quote: MAINNET_SPL_TOKENS.USDC,
        decimals: MAINNET_SPL_TOKENS.WSOL.decimals,
        version: 4
      },
      YFI_USDC_V4: {
        symbol: "YFI-USDC",
        name: "YFI-USDC V4 LP",
        mint: "865j7iMmRRycSYUXzJ33ZcvLiX9JHvaLidasCyUyKaRE",
        base: MAINNET_SPL_TOKENS.YFI,
        quote: MAINNET_SPL_TOKENS.USDC,
        decimals: MAINNET_SPL_TOKENS.YFI.decimals,
        version: 4
      },
      SRM_USDC_V4: {
        symbol: "SRM-USDC",
        name: "SRM-USDC V4 LP",
        mint: "9XnZd82j34KxNLgQfz29jGbYdxsYznTWRpvZE3SRE7JG",
        base: MAINNET_SPL_TOKENS.SRM,
        quote: MAINNET_SPL_TOKENS.USDC,
        decimals: MAINNET_SPL_TOKENS.SRM.decimals,
        version: 4
      },
      FTT_USDC_V4: {
        symbol: "FTT-USDC",
        name: "FTT-USDC V4 LP",
        mint: "75dCoKfUHLUuZ4qEh46ovsxfgWhB4icc3SintzWRedT9",
        base: MAINNET_SPL_TOKENS.FTT,
        quote: MAINNET_SPL_TOKENS.USDC,
        decimals: MAINNET_SPL_TOKENS.FTT.decimals,
        version: 4
      },
      BTC_USDC_V4: {
        symbol: "BTC-USDC",
        name: "BTC-USDC V4 LP",
        mint: "2hMdRdVWZqetQsaHG8kQjdZinEMBz75vsoWTCob1ijXu",
        base: MAINNET_SPL_TOKENS.BTC,
        quote: MAINNET_SPL_TOKENS.USDC,
        decimals: MAINNET_SPL_TOKENS.BTC.decimals,
        version: 4
      },
      SUSHI_USDC_V4: {
        symbol: "SUSHI-USDC",
        name: "SUSHI-USDC V4 LP",
        mint: "2QVjeR9d2PbSf8em8NE8zWd8RYHjFtucDUdDgdbDD2h2",
        base: MAINNET_SPL_TOKENS.SUSHI,
        quote: MAINNET_SPL_TOKENS.USDC,
        decimals: MAINNET_SPL_TOKENS.SUSHI.decimals,
        version: 4
      },
      TOMO_USDC_V4: {
        symbol: "TOMO-USDC",
        name: "TOMO-USDC V4 LP",
        mint: "CHyUpQFeW456zcr5XEh4RZiibH8Dzocs6Wbgz9aWpXnQ",
        base: MAINNET_SPL_TOKENS.TOMO,
        quote: MAINNET_SPL_TOKENS.USDC,
        decimals: MAINNET_SPL_TOKENS.TOMO.decimals,
        version: 4
      },
      LINK_USDC_V4: {
        symbol: "LINK-USDC",
        name: "LINK-USDC V4 LP",
        mint: "BqjoYjqKrXtfBKXeaWeAT5sYCy7wsAYf3XjgDWsHSBRs",
        base: MAINNET_SPL_TOKENS.LINK,
        quote: MAINNET_SPL_TOKENS.USDC,
        decimals: MAINNET_SPL_TOKENS.LINK.decimals,
        version: 4
      },
      ETH_USDC_V4: {
        symbol: "ETH-USDC",
        name: "ETH-USDC V4 LP",
        mint: "13PoKid6cZop4sj2GfoBeujnGfthUbTERdE5tpLCDLEY",
        base: MAINNET_SPL_TOKENS.ETH,
        quote: MAINNET_SPL_TOKENS.USDC,
        decimals: MAINNET_SPL_TOKENS.ETH.decimals,
        version: 4
      },
      xCOPE_USDC_V4: {
        symbol: "xCOPE-USDC",
        name: "xCOPE-USDC V4 LP",
        mint: "2Vyyeuyd15Gp8aH6uKE72c4hxc8TVSLibxDP9vzspQWG",
        base: MAINNET_SPL_TOKENS.xCOPE,
        quote: MAINNET_SPL_TOKENS.USDC,
        decimals: MAINNET_SPL_TOKENS.xCOPE.decimals,
        version: 4
      },
      SOL_USDT_V4: {
        symbol: "SOL-USDT",
        name: "SOL-USDT V4 LP",
        mint: "Epm4KfTj4DMrvqn6Bwg2Tr2N8vhQuNbuK8bESFp4k33K",
        base: MAINNET_SPL_TOKENS.WSOL,
        quote: MAINNET_SPL_TOKENS.USDT,
        decimals: MAINNET_SPL_TOKENS.WSOL.decimals,
        version: 4
      },
      YFI_USDT_V4: {
        symbol: "YFI-USDT",
        name: "YFI-USDT V4 LP",
        mint: "FA1i7fej1pAbQbnY8NbyYUsTrWcasTyipKreDgy1Mgku",
        base: MAINNET_SPL_TOKENS.YFI,
        quote: MAINNET_SPL_TOKENS.USDT,
        decimals: MAINNET_SPL_TOKENS.YFI.decimals,
        version: 4
      },
      SRM_USDT_V4: {
        symbol: "SRM-USDT",
        name: "SRM-USDT V4 LP",
        mint: "HYSAu42BFejBS77jZAZdNAWa3iVcbSRJSzp3wtqCbWwv",
        base: MAINNET_SPL_TOKENS.SRM,
        quote: MAINNET_SPL_TOKENS.USDT,
        decimals: MAINNET_SPL_TOKENS.SRM.decimals,
        version: 4
      },
      FTT_USDT_V4: {
        symbol: "FTT-USDT",
        name: "FTT-USDT V4 LP",
        mint: "2cTCiUnect5Lap2sk19xLby7aajNDYseFhC9Pigou11z",
        base: MAINNET_SPL_TOKENS.FTT,
        quote: MAINNET_SPL_TOKENS.USDT,
        decimals: MAINNET_SPL_TOKENS.FTT.decimals,
        version: 4
      },
      BTC_USDT_V4: {
        symbol: "BTC-USDT",
        name: "BTC-USDT V4 LP",
        mint: "DgGuvR9GSHimopo3Gc7gfkbKamLKrdyzWkq5yqA6LqYS",
        base: MAINNET_SPL_TOKENS.BTC,
        quote: MAINNET_SPL_TOKENS.USDT,
        decimals: MAINNET_SPL_TOKENS.BTC.decimals,
        version: 4
      },
      SUSHI_USDT_V4: {
        symbol: "SUSHI-USDT",
        name: "SUSHI-USDT V4 LP",
        mint: "Ba26poEYDy6P2o95AJUsewXgZ8DM9BCsmnU9hmC9i4Ki",
        base: MAINNET_SPL_TOKENS.SUSHI,
        quote: MAINNET_SPL_TOKENS.USDT,
        decimals: MAINNET_SPL_TOKENS.SUSHI.decimals,
        version: 4
      },
      TOMO_USDT_V4: {
        symbol: "TOMO-USDT",
        name: "TOMO-USDT V4 LP",
        mint: "D3iGro1vn6PWJXo9QAPj3dfta6dKkHHnmiiym2EfsAmi",
        base: MAINNET_SPL_TOKENS.TOMO,
        quote: MAINNET_SPL_TOKENS.USDT,
        decimals: MAINNET_SPL_TOKENS.TOMO.decimals,
        version: 4
      },
      LINK_USDT_V4: {
        symbol: "LINK-USDT",
        name: "LINK-USDT V4 LP",
        mint: "Dr12Sgt9gkY8WU5tRkgZf1TkVWJbvjYuPAhR3aDCwiiX",
        base: MAINNET_SPL_TOKENS.LINK,
        quote: MAINNET_SPL_TOKENS.USDT,
        decimals: MAINNET_SPL_TOKENS.LINK.decimals,
        version: 4
      },
      ETH_USDT_V4: {
        symbol: "ETH-USDT",
        name: "ETH-USDT V4 LP",
        mint: "nPrB78ETY8661fUgohpuVusNCZnedYCgghzRJzxWnVb",
        base: MAINNET_SPL_TOKENS.ETH,
        quote: MAINNET_SPL_TOKENS.USDT,
        decimals: MAINNET_SPL_TOKENS.ETH.decimals,
        version: 4
      },
      YFI_SRM_V4: {
        symbol: "YFI-SRM",
        name: "YFI-SRM V4 LP",
        mint: "EGJht91R7dKpCj8wzALkjmNdUUUcQgodqWCYweyKcRcV",
        base: MAINNET_SPL_TOKENS.YFI,
        quote: MAINNET_SPL_TOKENS.SRM,
        decimals: MAINNET_SPL_TOKENS.YFI.decimals,
        version: 4
      },
      FTT_SRM_V4: {
        symbol: "FTT-SRM",
        name: "FTT-SRM V4 LP",
        mint: "AsDuPg9MgPtt3jfoyctUCUgsvwqAN6RZPftqoeiPDefM",
        base: MAINNET_SPL_TOKENS.FTT,
        quote: MAINNET_SPL_TOKENS.SRM,
        decimals: MAINNET_SPL_TOKENS.FTT.decimals,
        version: 4
      },
      BTC_SRM_V4: {
        symbol: "BTC-SRM",
        name: "BTC-SRM V4 LP",
        mint: "AGHQxXb3GSzeiLTcLtXMS2D5GGDZxsB2fZYZxSB5weqB",
        base: MAINNET_SPL_TOKENS.BTC,
        quote: MAINNET_SPL_TOKENS.SRM,
        decimals: MAINNET_SPL_TOKENS.BTC.decimals,
        version: 4
      },
      SUSHI_SRM_V4: {
        symbol: "SUSHI-SRM",
        name: "SUSHI-SRM V4 LP",
        mint: "3HYhUnUdV67j1vn8fu7ExuVGy5dJozHEyWvqEstDbWwE",
        base: MAINNET_SPL_TOKENS.SUSHI,
        quote: MAINNET_SPL_TOKENS.SRM,
        decimals: MAINNET_SPL_TOKENS.SUSHI.decimals,
        version: 4
      },
      TOMO_SRM_V4: {
        symbol: "TOMO-SRM",
        name: "TOMO-SRM V4 LP",
        mint: "GgH9RnKrQpaMQeqmdbMvs5oo1A24hERQ9wuY2pSkeG7x",
        base: MAINNET_SPL_TOKENS.TOMO,
        quote: MAINNET_SPL_TOKENS.SRM,
        decimals: MAINNET_SPL_TOKENS.TOMO.decimals,
        version: 4
      },
      LINK_SRM_V4: {
        symbol: "LINK-SRM",
        name: "LINK-SRM V4 LP",
        mint: "GXN6yJv12o18skTmJXaeFXZVY1iqR18CHsmCT8VVCmDD",
        base: MAINNET_SPL_TOKENS.LINK,
        quote: MAINNET_SPL_TOKENS.SRM,
        decimals: MAINNET_SPL_TOKENS.LINK.decimals,
        version: 4
      },
      ETH_SRM_V4: {
        symbol: "ETH-SRM",
        name: "ETH-SRM V4 LP",
        mint: "9VoY3VERETuc2FoadMSYYizF26mJinY514ZpEzkHMtwG",
        base: MAINNET_SPL_TOKENS.ETH,
        quote: MAINNET_SPL_TOKENS.SRM,
        decimals: MAINNET_SPL_TOKENS.ETH.decimals,
        version: 4
      },
      SRM_SOL_V4: {
        symbol: "SRM-SOL",
        name: "SRM-SOL V4 LP",
        mint: "AKJHspCwDhABucCxNLXUSfEzb7Ny62RqFtC9uNjJi4fq",
        base: MAINNET_SPL_TOKENS.SRM,
        quote: MAINNET_SPL_TOKENS.WSOL,
        decimals: MAINNET_SPL_TOKENS.SRM.decimals,
        version: 4
      },
      STEP_USDC_V4: {
        symbol: "STEP-USDC",
        name: "STEP-USDC V4 LP",
        mint: "3k8BDobgihmk72jVmXYLE168bxxQUhqqyESW4dQVktqC",
        base: MAINNET_SPL_TOKENS.STEP,
        quote: MAINNET_SPL_TOKENS.USDC,
        decimals: MAINNET_SPL_TOKENS.STEP.decimals,
        version: 4
      },
      MEDIA_USDC_V4: {
        symbol: "MEDIA-USDC",
        name: "MEDIA-USDC V4 LP",
        mint: "A5zanvgtioZGiJMdEyaKN4XQmJsp1p7uVxaq2696REvQ",
        base: MAINNET_SPL_TOKENS.MEDIA,
        quote: MAINNET_SPL_TOKENS.USDC,
        decimals: MAINNET_SPL_TOKENS.MEDIA.decimals,
        version: 4
      },
      ROPE_USDC_V4: {
        symbol: "ROPE-USDC",
        name: "ROPE-USDC V4 LP",
        mint: "Cq4HyW5xia37tKejPF2XfZeXQoPYW6KfbPvxvw5eRoUE",
        base: MAINNET_SPL_TOKENS.ROPE,
        quote: MAINNET_SPL_TOKENS.USDC,
        decimals: MAINNET_SPL_TOKENS.ROPE.decimals,
        version: 4
      },
      MER_USDC_V4: {
        symbol: "MER-USDC",
        name: "MER-USDC V4 LP",
        mint: "3H9NxvaZoxMZZDZcbBDdWMKbrfNj7PCF5sbRwDr7SdDW",
        base: MAINNET_SPL_TOKENS.MER,
        quote: MAINNET_SPL_TOKENS.USDC,
        decimals: MAINNET_SPL_TOKENS.MER.decimals,
        version: 4
      },
      COPE_USDC_V4: {
        symbol: "COPE-USDC",
        name: "COPE-USDC V4 LP",
        mint: "Cz1kUvHw98imKkrqqu95GQB9h1frY8RikxPojMwWKGXf",
        base: MAINNET_SPL_TOKENS.COPE,
        quote: MAINNET_SPL_TOKENS.USDC,
        decimals: MAINNET_SPL_TOKENS.COPE.decimals,
        version: 4
      },
      ALEPH_USDC_V4: {
        symbol: "ALEPH-USDC",
        name: "ALEPH-USDC V4 LP",
        mint: "iUDasAP2nXm5wvTukAHEKSdSXn8vQkRtaiShs9ceGB7",
        base: MAINNET_SPL_TOKENS.ALEPH,
        quote: MAINNET_SPL_TOKENS.USDC,
        decimals: MAINNET_SPL_TOKENS.ALEPH.decimals,
        version: 4
      },
      TULIP_USDC_V4: {
        symbol: "TULIP-USDC",
        name: "TULIP-USDC V4 LP",
        mint: "2doeZGLJyACtaG9DCUyqMLtswesfje1hjNA11hMdj6YU",
        base: MAINNET_SPL_TOKENS.TULIP,
        quote: MAINNET_SPL_TOKENS.USDC,
        decimals: MAINNET_SPL_TOKENS.TULIP.decimals,
        version: 4
      },
      WOO_USDC_V4: {
        symbol: "WOO-USDC",
        name: "WOO-USDC V4 LP",
        mint: "7cu42ao8Jgrd5A3y3bNQsCxq5poyGZNmTydkGfJYQfzh",
        base: MAINNET_SPL_TOKENS.WOO,
        quote: MAINNET_SPL_TOKENS.USDC,
        decimals: MAINNET_SPL_TOKENS.WOO.decimals,
        version: 4
      },
      SNY_USDC_V4: {
        symbol: "SNY-USDC",
        name: "SNY-USDC V4 LP",
        mint: "G8qcfeFqxwbCqpxv5LpLWxUCd1PyMB5nWb5e5YyxLMKg",
        base: MAINNET_SPL_TOKENS.SNY,
        quote: MAINNET_SPL_TOKENS.USDC,
        decimals: MAINNET_SPL_TOKENS.SNY.decimals,
        version: 4
      },
      BOP_RAY_V4: {
        symbol: "BOP-RAY",
        name: "BOP-RAY V4 LP",
        mint: "9nQPYJvysyfnXhQ6nkK5V7sZG26hmDgusfdNQijRk5LD",
        base: MAINNET_SPL_TOKENS.BOP,
        quote: MAINNET_SPL_TOKENS.RAY,
        decimals: MAINNET_SPL_TOKENS.BOP.decimals,
        version: 4
      },
      SLRS_USDC_V4: {
        symbol: "SLRS-USDC",
        name: "SLRS-USDC V4 LP",
        mint: "2Xxbm1hdv5wPeen5ponDSMT3VqhGMTQ7mH9stNXm9shU",
        base: MAINNET_SPL_TOKENS.SLRS,
        quote: MAINNET_SPL_TOKENS.USDC,
        decimals: MAINNET_SPL_TOKENS.SLRS.decimals,
        version: 4
      },
      SAMO_RAY_V4: {
        symbol: "SAMO-RAY",
        name: "SAMO-RAY V4 LP",
        mint: "HwzkXyX8B45LsaHXwY8su92NoRBS5GQC32HzjQRDqPnr",
        base: MAINNET_SPL_TOKENS.SAMO,
        quote: MAINNET_SPL_TOKENS.RAY,
        decimals: MAINNET_SPL_TOKENS.SAMO.decimals,
        version: 4
      },
      renBTC_USDC_V4: {
        symbol: "renBTC-USDC",
        name: "renBTC-USDC V4 LP",
        mint: "CTEpsih91ZLo5gunvryLpJ3pzMjmt5jbS6AnSQrzYw7V",
        base: MAINNET_SPL_TOKENS.renBTC,
        quote: MAINNET_SPL_TOKENS.USDC,
        decimals: MAINNET_SPL_TOKENS.renBTC.decimals,
        version: 4
      },
      renDOGE_USDC_V4: {
        symbol: "renDOGE-USDC",
        name: "renDOGE-USDC V4 LP",
        mint: "Hb8KnZNKvRxu7pgMRWJgoMSMcepfvNiBFFDDrdf9o3wA",
        base: MAINNET_SPL_TOKENS.renDOGE,
        quote: MAINNET_SPL_TOKENS.USDC,
        decimals: MAINNET_SPL_TOKENS.renDOGE.decimals,
        version: 4
      },
      RAY_USDC_V4: {
        symbol: "RAY-USDC",
        name: "RAY-USDC V4 LP",
        mint: "FbC6K13MzHvN42bXrtGaWsvZY9fxrackRSZcBGfjPc7m",
        base: MAINNET_SPL_TOKENS.RAY,
        quote: MAINNET_SPL_TOKENS.USDC,
        decimals: MAINNET_SPL_TOKENS.RAY.decimals,
        version: 4
      },
      RAY_SRM_V4: {
        symbol: "RAY-SRM",
        name: "RAY-SRM V4 LP",
        mint: "7P5Thr9Egi2rvMmEuQkLn8x8e8Qro7u2U7yLD2tU2Hbe",
        base: MAINNET_SPL_TOKENS.RAY,
        quote: MAINNET_SPL_TOKENS.SRM,
        decimals: MAINNET_SPL_TOKENS.RAY.decimals,
        version: 4
      },
      RAY_ETH_V4: {
        symbol: "RAY-ETH",
        name: "RAY-ETH V4 LP",
        mint: "mjQH33MqZv5aKAbKHi8dG3g3qXeRQqq1GFcXceZkNSr",
        base: MAINNET_SPL_TOKENS.RAY,
        quote: MAINNET_SPL_TOKENS.ETH,
        decimals: MAINNET_SPL_TOKENS.RAY.decimals,
        version: 4
      },
      RAY_SOL_V4: {
        symbol: "RAY-SOL",
        name: "RAY-SOL V4 LP",
        mint: "89ZKE4aoyfLBe2RuV6jM3JGNhaV18Nxh8eNtjRcndBip",
        base: MAINNET_SPL_TOKENS.RAY,
        quote: MAINNET_SPL_TOKENS.WSOL,
        decimals: MAINNET_SPL_TOKENS.RAY.decimals,
        version: 4
      },
      DXL_USDC_V4: {
        symbol: "DXL-USDC",
        name: "DXL-USDC V4 LP",
        mint: "4HFaSvfgskipvrzT1exoVKsUZ174JyExEsA8bDfsAdY5",
        base: MAINNET_SPL_TOKENS.DXL,
        quote: MAINNET_SPL_TOKENS.USDC,
        decimals: MAINNET_SPL_TOKENS.DXL.decimals,
        version: 4
      },
      LIKE_USDC_V4: {
        symbol: "LIKE-USDC",
        name: "LIKE-USDC V4 LP",
        mint: "cjZmbt8sJgaoyWYUttomAu5LJYU44ZrcKTbzTSEPDVw",
        base: MAINNET_SPL_TOKENS.LIKE,
        quote: MAINNET_SPL_TOKENS.USDC,
        decimals: MAINNET_SPL_TOKENS.LIKE.decimals,
        version: 4
      },
      mSOL_USDC_V4: {
        symbol: "mSOL-USDC",
        name: "mSOL-USDC V4 LP",
        mint: "4xTpJ4p76bAeggXoYywpCCNKfJspbuRzZ79R7pRhbqSf",
        base: MAINNET_SPL_TOKENS.mSOL,
        quote: MAINNET_SPL_TOKENS.USDC,
        decimals: MAINNET_SPL_TOKENS.mSOL.decimals,
        version: 4
      },
      mSOL_SOL_V4: {
        symbol: "mSOL-SOL",
        name: "mSOL-SOL V4 LP",
        mint: "5ijRoAHVgd5T5CNtK5KDRUBZ7Bffb69nktMj5n6ks6m4",
        base: MAINNET_SPL_TOKENS.mSOL,
        quote: MAINNET_SPL_TOKENS.WSOL,
        decimals: MAINNET_SPL_TOKENS.mSOL.decimals,
        version: 4
      },
      MER_PAI_V4: {
        symbol: "MER-PAI",
        name: "MER-PAI V4 LP",
        mint: "DU5RT2D9EviaSmX6Ta8MZwMm85HwSEqGMRdqUiuCGfmD",
        base: MAINNET_SPL_TOKENS.MER,
        quote: MAINNET_SPL_TOKENS.PAI,
        decimals: MAINNET_SPL_TOKENS.MER.decimals,
        version: 4
      },
      PORT_USDC_V4: {
        symbol: "PORT-USDC",
        name: "PORT-USDC V4 LP",
        mint: "9tmNtbUCrLS15qC4tEfr5NNeqcqpZ4uiGgi2vS5CLQBS",
        base: MAINNET_SPL_TOKENS.PORT,
        quote: MAINNET_SPL_TOKENS.USDC,
        decimals: MAINNET_SPL_TOKENS.PORT.decimals,
        version: 4
      },
      MNGO_USDC_V4: {
        symbol: "MNGO-USDC",
        name: "MNGO-USDC V4 LP",
        mint: "DkiqCQ792n743xjWQVCbBUaVtkdiuvQeYndM53ReWnCC",
        base: MAINNET_SPL_TOKENS.MNGO,
        quote: MAINNET_SPL_TOKENS.USDC,
        decimals: MAINNET_SPL_TOKENS.MNGO.decimals,
        version: 4
      },
      ATLAS_USDC_V4: {
        symbol: "ATLAS-USDC",
        name: "ATLAS-USDC V4 LP",
        mint: "9shGU9f1EsxAbiR567MYZ78WUiS6ZNCYbHe53WUULQ7n",
        base: MAINNET_SPL_TOKENS.ATLAS,
        quote: MAINNET_SPL_TOKENS.USDC,
        decimals: MAINNET_SPL_TOKENS.ATLAS.decimals,
        version: 4
      },
      POLIS_USDC_V4: {
        symbol: "POLIS-USDC",
        name: "POLIS-USDC V4 LP",
        mint: "8MbKSBpyXs8fVneKgt71jfHrn5SWtX8n4wMLpiVfF9So",
        base: MAINNET_SPL_TOKENS.POLIS,
        quote: MAINNET_SPL_TOKENS.USDC,
        decimals: MAINNET_SPL_TOKENS.POLIS.decimals,
        version: 4
      },
      ATLAS_RAY_V4: {
        symbol: "ATLAS-RAY",
        name: "ATLAS-RAY V4 LP",
        mint: "418MFhkaYQtbn529wmjLLqL6uKxDz7j4eZBaV1cobkyd",
        base: MAINNET_SPL_TOKENS.ATLAS,
        quote: MAINNET_SPL_TOKENS.RAY,
        decimals: MAINNET_SPL_TOKENS.ATLAS.decimals,
        version: 4
      },
      POLIS_RAY_V4: {
        symbol: "POLIS-RAY",
        name: "POLIS-RAY V4 LP",
        mint: "9ysGKUH6WqzjQEUT4dxqYCUaFNVK9QFEa24pGzjFq8xg",
        base: MAINNET_SPL_TOKENS.POLIS,
        quote: MAINNET_SPL_TOKENS.RAY,
        decimals: MAINNET_SPL_TOKENS.POLIS.decimals,
        version: 4
      },
      ALEPH_RAY_V4: {
        symbol: "ALEPH-RAY",
        name: "ALEPH-RAY V4 LP",
        mint: "n76skjqv4LirhdLok2zJELXNLdRpYDgVJQuQFbamscy",
        base: MAINNET_SPL_TOKENS.ALEPH,
        quote: MAINNET_SPL_TOKENS.RAY,
        decimals: MAINNET_SPL_TOKENS.ALEPH.decimals,
        version: 4
      },
      TULIP_RAY_V4: {
        symbol: "TULIP-RAY",
        name: "TULIP-RAY V4 LP",
        mint: "3AZTviji5qduMG2s4FfWGR3SSQmNUCyx8ao6UKCPg3oJ",
        base: MAINNET_SPL_TOKENS.TULIP,
        quote: MAINNET_SPL_TOKENS.RAY,
        decimals: MAINNET_SPL_TOKENS.TULIP.decimals,
        version: 4
      },
      SLRS_RAY_V4: {
        symbol: "SLRS-RAY",
        name: "SLRS-RAY V4 LP",
        mint: "2pk78vsKT3jfJAcN2zbpMUnrR57SZrxHqaZYyFgp92mM",
        base: MAINNET_SPL_TOKENS.SLRS,
        quote: MAINNET_SPL_TOKENS.RAY,
        decimals: MAINNET_SPL_TOKENS.SLRS.decimals,
        version: 4
      },
      MER_RAY_V4: {
        symbol: "MER-RAY",
        name: "MER-RAY V4 LP",
        mint: "214hxy3AbKoaEKgqcg2aC1cP5R67cGGAyDEg5GDwC7Ub",
        base: MAINNET_SPL_TOKENS.MER,
        quote: MAINNET_SPL_TOKENS.RAY,
        decimals: MAINNET_SPL_TOKENS.MER.decimals,
        version: 4
      },
      MEDIA_RAY_V4: {
        symbol: "MEDIA-RAY",
        name: "MEDIA-RAY V4 LP",
        mint: "9Aseg5A1JD1yCiFFdDaNNxCiJ7XzrpZFmcEmLjXFdPaH",
        base: MAINNET_SPL_TOKENS.MEDIA,
        quote: MAINNET_SPL_TOKENS.RAY,
        decimals: MAINNET_SPL_TOKENS.MEDIA.decimals,
        version: 4
      },
      SNY_RAY_V4: {
        symbol: "SNY-RAY",
        name: "SNY-RAY V4 LP",
        mint: "2k4quTuuLUxrSEhFH99qcoZzvgvVEc3b5sz3xz3qstfS",
        base: MAINNET_SPL_TOKENS.SNY,
        quote: MAINNET_SPL_TOKENS.RAY,
        decimals: MAINNET_SPL_TOKENS.SNY.decimals,
        version: 4
      },
      LIKE_RAY_V4: {
        symbol: "LIKE-RAY",
        name: "LIKE-RAY V4 LP",
        mint: "7xqDycbFSCpUpzkYapFeyPJWPwEpV7zdWbYf2MVHTNjv",
        base: MAINNET_SPL_TOKENS.LIKE,
        quote: MAINNET_SPL_TOKENS.RAY,
        decimals: MAINNET_SPL_TOKENS.LIKE.decimals,
        version: 4
      },
      COPE_RAY_V4: {
        symbol: "COPE-RAY",
        name: "COPE-RAY V4 LP",
        mint: "A7GCVHA8NSsbdFscHdoNU41tL1TRKNmCH4K94CgcLK9F",
        base: MAINNET_SPL_TOKENS.COPE,
        quote: MAINNET_SPL_TOKENS.RAY,
        decimals: MAINNET_SPL_TOKENS.COPE.decimals,
        version: 4
      },
      ETH_SOL_V4: {
        symbol: "ETH-SOL",
        name: "ETH-SOL V4 LP",
        mint: "GKfgC86iJoMjwAtcyiLu6nWnjggqUXsDQihXkP14fDez",
        base: MAINNET_SPL_TOKENS.ETH,
        quote: MAINNET_SPL_TOKENS.WSOL,
        decimals: MAINNET_SPL_TOKENS.ETH.decimals,
        version: 4
      },
      stSOL_USDC_V4: {
        symbol: "stSOL-USDC",
        name: "stSOL-USDC V4 LP",
        mint: "HDUJMwYZkjUZre63xUeDhdCi8c6LgUDiBqxmP3QC3VPX",
        base: MAINNET_SPL_TOKENS.stSOL,
        quote: MAINNET_SPL_TOKENS.USDC,
        decimals: MAINNET_SPL_TOKENS.stSOL.decimals,
        version: 4
      },
      GRAPE_USDC_V4: {
        symbol: "GRAPE-USDC",
        name: "GRAPE-USDC V4 LP",
        mint: "A8ZYmnZ1vwxUa4wpJVUaJgegsuTEz5TKy5CiJXffvmpt",
        base: MAINNET_SPL_TOKENS.GRAPE,
        quote: MAINNET_SPL_TOKENS.USDC,
        decimals: MAINNET_SPL_TOKENS.GRAPE.decimals,
        version: 4
      },
      LARIX_USDC_V4: {
        symbol: "LARIX-USDC",
        name: "LARIX-USDC V4 LP",
        mint: "7yieit4YsNsZ9CAK8H5ZEMvvk35kPEHHeXwp6naoWU9V",
        base: MAINNET_SPL_TOKENS.LARIX,
        quote: MAINNET_SPL_TOKENS.USDC,
        decimals: MAINNET_SPL_TOKENS.LARIX.decimals,
        version: 4
      },
      RIN_USDC_V4: {
        symbol: "RIN-USDC",
        name: "RIN-USDC V4 LP",
        mint: "GfCWfrZez7BDmCSEeMERVDVUaaM2TEreyYUgb2cpuS3w",
        base: MAINNET_SPL_TOKENS.RIN,
        quote: MAINNET_SPL_TOKENS.USDC,
        decimals: MAINNET_SPL_TOKENS.RIN.decimals,
        version: 4
      },
      APEX_USDC_V4: {
        symbol: "APEX-USDC",
        name: "APEX-USDC V4 LP",
        mint: "444cVqYyDxJNo6FqiMb9qQWFUd7tYzFRdDuJRFrSAGnU",
        base: MAINNET_SPL_TOKENS.APEX,
        quote: MAINNET_SPL_TOKENS.USDC,
        decimals: MAINNET_SPL_TOKENS.APEX.decimals,
        version: 4
      },
      mSOL_RAY_V4: {
        symbol: "mSOL-RAY",
        name: "mSOL-RAY V4 LP",
        mint: "De2EHBAdkgfc72DpShqDGG42cV3iDWh8wvvZdPsiEcqP",
        base: MAINNET_SPL_TOKENS.mSOL,
        quote: MAINNET_SPL_TOKENS.RAY,
        decimals: MAINNET_SPL_TOKENS.mSOL.decimals,
        version: 4
      },
      MNDE_mSOL_V4: {
        symbol: "MNDE-mSOL",
        name: "MNDE-mSOL V4 LP",
        mint: "4bh8XCzTHSbqbWN8o1Jn4ueBdz1LvJFoEasN6K6CQ8Ny",
        base: MAINNET_SPL_TOKENS.MNDE,
        quote: MAINNET_SPL_TOKENS.mSOL,
        decimals: MAINNET_SPL_TOKENS.MNDE.decimals,
        version: 4
      },
      LARIX_RAY_V4: {
        symbol: "LARIX-RAY",
        name: "LARIX-RAY V4 LP",
        mint: "ZRDfSLgWGeaYSmhdPvFNKQQhDcYdZQaue2N8YDmHX4q",
        base: MAINNET_SPL_TOKENS.LARIX,
        quote: MAINNET_SPL_TOKENS.RAY,
        decimals: MAINNET_SPL_TOKENS.LARIX.decimals,
        version: 4
      },
      LIQ_USDC_V4: {
        symbol: "LIQ-USDC",
        name: "LIQ-USDC V4 LP",
        mint: "GWpD3eTfhJB5KDCcnE85dBQrjAk2CsrgDF9b52R9CrjV",
        base: MAINNET_SPL_TOKENS.LIQ,
        quote: MAINNET_SPL_TOKENS.USDC,
        decimals: MAINNET_SPL_TOKENS.LIQ.decimals,
        version: 4
      },
      WAG_USDC_V4: {
        symbol: "WAG-USDC",
        name: "WAG-USDC V4 LP",
        mint: "4yykyPugitUVRewNPXXCviRvxGfsfsRMoP32z3b6FmUC",
        base: MAINNET_SPL_TOKENS.WAG,
        quote: MAINNET_SPL_TOKENS.USDC,
        decimals: MAINNET_SPL_TOKENS.WAG.decimals,
        version: 4
      },
      ETH_mSOL_V4: {
        symbol: "ETH-mSOL",
        name: "ETH-mSOL V4 LP",
        mint: "HYv3grQfi8QbV7nG7EFgNK1aJSrsJ7HynXJKJVPLL2Uh",
        base: MAINNET_SPL_TOKENS.ETH,
        quote: MAINNET_SPL_TOKENS.mSOL,
        decimals: MAINNET_SPL_TOKENS.ETH.decimals,
        version: 4
      },
      mSOL_USDT_V4: {
        symbol: "mSOL-USDT",
        name: "mSOL-USDT V4 LP",
        mint: "69NCmEW9mGpiWLjAcAWHq51k4ionJZmzgRfRT3wQaCCf",
        base: MAINNET_SPL_TOKENS.mSOL,
        quote: MAINNET_SPL_TOKENS.USDT,
        decimals: MAINNET_SPL_TOKENS.mSOL.decimals,
        version: 4
      },
      BTC_mSOL_V4: {
        symbol: "BTC-mSOL",
        name: "BTC-mSOL V4 LP",
        mint: "92bcERNtUmuaJ6mwLSxYHZYSph37jdKxRdoYNxpcYNPp",
        base: MAINNET_SPL_TOKENS.BTC,
        quote: MAINNET_SPL_TOKENS.mSOL,
        decimals: MAINNET_SPL_TOKENS.BTC.decimals,
        version: 4
      },
      SLIM_SOL_V4: {
        symbol: "SLIM-SOL",
        name: "SLIM-SOL V4 LP",
        mint: "9X4EK8E59VAVi6ChnNvvd39m6Yg9RtkBbAPq1mDVJT57",
        base: MAINNET_SPL_TOKENS.SLIM,
        quote: MAINNET_SPL_TOKENS.WSOL,
        decimals: MAINNET_SPL_TOKENS.SLIM.decimals,
        version: 4
      },
      AURY_USDC_V4: {
        symbol: "AURY-USDC",
        name: "AURY-USDC V4 LP",
        mint: "Gub5dvTy4nzP82qpmpNkBxmRqjtqRddBTBqHSdNcf2oS",
        base: MAINNET_SPL_TOKENS.AURY,
        quote: MAINNET_SPL_TOKENS.USDC,
        decimals: MAINNET_SPL_TOKENS.AURY.decimals,
        version: 4
      },
      PRT_SOL_V4: {
        symbol: "PRT-SOL",
        name: "PRT-SOL V4 LP",
        mint: "EcJ8Wgwt1AzSPiDpVr6aaSur8TKAsNTPmmzRACeqT68Z",
        base: MAINNET_SPL_TOKENS.PRT,
        quote: MAINNET_SPL_TOKENS.WSOL,
        decimals: MAINNET_SPL_TOKENS.PRT.decimals,
        version: 4
      },
      LIQ_RAY_V4: {
        symbol: "LIQ-RAY",
        name: "LIQ-RAY V4 LP",
        mint: "49YUsDrThJosHSagCn1F59Uc9NRxbr9thVrZikUnQDXy",
        base: MAINNET_SPL_TOKENS.LIQ,
        quote: MAINNET_SPL_TOKENS.RAY,
        decimals: MAINNET_SPL_TOKENS.LIQ.decimals,
        version: 4
      },
      SYP_SOL_V4: {
        symbol: "SYP-SOL",
        name: "SYP-SOL V4 LP",
        mint: "KHV6dfj2bDntzJ9z1S26cDfqWfUZdJRFmteLR6LxHwW",
        base: MAINNET_SPL_TOKENS.SYP,
        quote: MAINNET_SPL_TOKENS.WSOL,
        decimals: MAINNET_SPL_TOKENS.SYP.decimals,
        version: 4
      },
      SYP_RAY_V4: {
        symbol: "SYP-RAY",
        name: "SYP-RAY V4 LP",
        mint: "FT2KZqxxM8F2h9pZtTF4PyjK88bM4YbuBzd7ZPwQ5wMB",
        base: MAINNET_SPL_TOKENS.SYP,
        quote: MAINNET_SPL_TOKENS.RAY,
        decimals: MAINNET_SPL_TOKENS.SYP.decimals,
        version: 4
      },
      SYP_USDC_V4: {
        symbol: "SYP-USDC",
        name: "SYP-USDC V4 LP",
        mint: "2xJGuLAivAR1WkARRA6zP1v4jaA9jV2Qis8JfMNvrVyZ",
        base: MAINNET_SPL_TOKENS.SYP,
        quote: MAINNET_SPL_TOKENS.USDC,
        decimals: MAINNET_SPL_TOKENS.SYP.decimals,
        version: 4
      },
      FAB_USDC_V4: {
        symbol: "FAB-USDC",
        name: "FAB-USDC V4 LP",
        mint: "5rTCvZq6BcApsC3VV1EEUuTJfaVd8uYhcGjwTy1By6P8",
        base: MAINNET_SPL_TOKENS.FAB,
        quote: MAINNET_SPL_TOKENS.USDC,
        decimals: MAINNET_SPL_TOKENS.FAB.decimals,
        version: 4
      },
      WOOF_RAY_V4: {
        symbol: "WOOF-RAY",
        name: "WOOF-RAY V4 LP",
        mint: "H2FAnazDaGFutcmnrwDxhmdncR1Bd7GG4mhPCSUiamDX",
        base: MAINNET_SPL_TOKENS.WOOF,
        quote: MAINNET_SPL_TOKENS.RAY,
        decimals: MAINNET_SPL_TOKENS.WOOF.decimals,
        version: 4
      },
      WOOF_USDC_V4: {
        symbol: "WOOF-USDC",
        name: "WOOF-USDC V4 LP",
        mint: "EFSu5TMc1ijRevaYCxUkS7uGvbhsymDHEaTK3UVdNE3q",
        base: MAINNET_SPL_TOKENS.WOOF,
        quote: MAINNET_SPL_TOKENS.USDC,
        decimals: MAINNET_SPL_TOKENS.WOOF.decimals,
        version: 4
      },
      SLND_USDC_V4: {
        symbol: "SLND-USDC",
        name: "SLND-USDC V4 LP",
        mint: "EunE9uDh2cGsyJcsGuGKc6wte7kBn8iye2gzC4w2ePHn",
        base: MAINNET_SPL_TOKENS.SLND,
        quote: MAINNET_SPL_TOKENS.USDC,
        decimals: MAINNET_SPL_TOKENS.SLND.decimals,
        version: 4
      },
      FRKT_SOL_V4: {
        symbol: "FRKT-SOL",
        name: "FRKT-SOL V4 LP",
        mint: "HYUKXgpjaxMXHttyrFYtv3z2rdhZ1U9QDH8zEc8BooQC",
        base: MAINNET_SPL_TOKENS.FRKT,
        quote: MAINNET_SPL_TOKENS.WSOL,
        decimals: MAINNET_SPL_TOKENS.FRKT.decimals,
        version: 4
      },
      weWETH_SOL_V4: {
        symbol: "weWETH-SOL",
        name: "weWETH-SOL V4 LP",
        mint: "3hbozt2Por7bcrGod8N7kEeJNMocFFjCJrQR16TQGBrE",
        base: MAINNET_SPL_TOKENS.weWETH,
        quote: MAINNET_SPL_TOKENS.WSOL,
        decimals: MAINNET_SPL_TOKENS.weWETH.decimals,
        version: 4
      },
      weWETH_USDC_V4: {
        symbol: "weWETH-USDC",
        name: "weWETH-USDC V4 LP",
        mint: "3529SBnMCDW3S3xQ52aABbRHo7PcHvpQA4no8J12L5eK",
        base: MAINNET_SPL_TOKENS.weWETH,
        quote: MAINNET_SPL_TOKENS.USDC,
        decimals: MAINNET_SPL_TOKENS.weWETH.decimals,
        version: 4
      },
      weUNI_USDC_V4: {
        symbol: "weUNI-USDC",
        name: "weUNI-USDC V4 LP",
        mint: "EEC4QnT41py39QaYnzQnoYQEtDUDNa6Se8SBDgfPSN2a",
        base: MAINNET_SPL_TOKENS.weUNI,
        quote: MAINNET_SPL_TOKENS.USDC,
        decimals: MAINNET_SPL_TOKENS.weUNI.decimals,
        version: 4
      },
      weSUSHI_USDC_V4: {
        symbol: "weSUSHI-USDC",
        name: "weSUSHI-USDC V4 LP",
        mint: "3wVrtQZsiDNp5yTPyfEzQHPU6iuJoMmpnWg6CTt4V8sR",
        base: MAINNET_SPL_TOKENS.weSUSHI,
        quote: MAINNET_SPL_TOKENS.USDC,
        decimals: MAINNET_SPL_TOKENS.weSUSHI.decimals,
        version: 4
      },
      CYS_USDC_V4: {
        symbol: "CYS-USDC",
        name: "CYS-USDC V4 LP",
        mint: "GfV3QDzzdVUwCNSdfn6PjhmyJvjw18tn51RingWZYwk3",
        base: MAINNET_SPL_TOKENS.CYS,
        quote: MAINNET_SPL_TOKENS.USDC,
        decimals: MAINNET_SPL_TOKENS.CYS.decimals,
        version: 4
      },
      SAMO_USDC_V4: {
        symbol: "SAMO-USDC",
        name: "SAMO-USDC V4 LP",
        mint: "B2PjGEP3vPf1999fUD14pYdxvSDRVBk43hxB2rgthwEY",
        base: MAINNET_SPL_TOKENS.SAMO,
        quote: MAINNET_SPL_TOKENS.USDC,
        decimals: MAINNET_SPL_TOKENS.SAMO.decimals,
        version: 4
      },
      ABR_USDC_V4: {
        symbol: "ABR-USDC",
        name: "ABR-USDC V4 LP",
        mint: "ECHfxkf5zjjZFTX95QfFahNyzG7feyEKcfTdjsdrMSGU",
        base: MAINNET_SPL_TOKENS.ABR,
        quote: MAINNET_SPL_TOKENS.USDC,
        decimals: MAINNET_SPL_TOKENS.ABR.decimals,
        version: 4
      },
      IN_USDC_V4: {
        symbol: "IN-USDC",
        name: "IN-USDC V4 LP",
        mint: "GbmJtVgg9fRmmmjKUYGMZeSt8wZ47cDDXasg5Y3iF4kz",
        base: MAINNET_SPL_TOKENS.IN,
        quote: MAINNET_SPL_TOKENS.USDC,
        decimals: MAINNET_SPL_TOKENS.IN.decimals,
        version: 4
      },
      weDYDX_USDC_V4: {
        symbol: "weDYDX-USDC",
        name: "weDYDX-USDC V4 LP",
        mint: "BjkkMZnnzmgLqzGErzDbkk15ozv48iVKQuunpeM2Hqnk",
        base: MAINNET_SPL_TOKENS.weDYDX,
        quote: MAINNET_SPL_TOKENS.USDC,
        decimals: MAINNET_SPL_TOKENS.weDYDX.decimals,
        version: 4
      },
      STARS_USDC_V4: {
        symbol: "STARS-USDC",
        name: "STARS-USDC V4 LP",
        mint: "FJ68q7NChhETcGVdinMbM2FF1Cy79dpmUi6HC83K55Hv",
        base: MAINNET_SPL_TOKENS.STARS,
        quote: MAINNET_SPL_TOKENS.USDC,
        decimals: MAINNET_SPL_TOKENS.STARS.decimals,
        version: 4
      },
      weAXS_USDC_V4: {
        symbol: "weAXS-USDC",
        name: "weAXS-USDC V4 LP",
        mint: "6PSoJQ7myQ1BJtbQC6oiWR8HSecQGyoWsPYTZRJo2ci3",
        base: MAINNET_SPL_TOKENS.weAXS,
        quote: MAINNET_SPL_TOKENS.USDC,
        decimals: MAINNET_SPL_TOKENS.weAXS.decimals,
        version: 4
      },
      weSHIB_USDC_V4: {
        symbol: "weSHIB-USDC",
        name: "weSHIB-USDC V4 LP",
        mint: "AcjX5pmTMGSgxkdxc3r82r6WMKBvS6eQXXFz5ck5KKUa",
        base: MAINNET_SPL_TOKENS.weSHIB,
        quote: MAINNET_SPL_TOKENS.USDC,
        decimals: MAINNET_SPL_TOKENS.weSHIB.decimals,
        version: 4
      },
      SBR_USDC_V4: {
        symbol: "SBR-USDC",
        name: "SBR-USDC V4 LP",
        mint: "9FC8xTFRbgTpuZZYAYnZLxgnQ8r7FwfSBM1SWvGwgF7s",
        base: MAINNET_SPL_TOKENS.SBR,
        quote: MAINNET_SPL_TOKENS.USDC,
        decimals: MAINNET_SPL_TOKENS.SBR.decimals,
        version: 4
      },
      OXS_USDC_V4: {
        symbol: "OXS-USDC",
        name: "OXS-USDC V4 LP",
        mint: "et9pdjWm97rbmsJoN183GkFV5qzTGru79GE1Zhe7NTU",
        base: MAINNET_SPL_TOKENS.OXS,
        quote: MAINNET_SPL_TOKENS.USDC,
        decimals: MAINNET_SPL_TOKENS.OXS.decimals,
        version: 4
      },
      CWAR_USDC_V4: {
        symbol: "CWAR-USDC",
        name: "CWAR-USDC V4 LP",
        mint: "HjR23bxn2gtRDB2P1Tm3DLepAPPZgazsWJpLG9wqjnYR",
        base: MAINNET_SPL_TOKENS.CWAR,
        quote: MAINNET_SPL_TOKENS.USDC,
        decimals: MAINNET_SPL_TOKENS.CWAR.decimals,
        version: 4
      },
      UPS_USDC_V4: {
        symbol: "UPS-USDC",
        name: "UPS-USDC V4 LP",
        mint: "9hSUZdREEsbaYaKY4FouvXr7xyAqtpdHRDoYCb6Mb28a",
        base: MAINNET_SPL_TOKENS.UPS,
        quote: MAINNET_SPL_TOKENS.USDC,
        decimals: MAINNET_SPL_TOKENS.UPS.decimals,
        version: 4
      },
      weSAND_USDC_V4: {
        symbol: "weSAND-USDC",
        name: "weSAND-USDC V4 LP",
        mint: "3dADrQa7utyiCsaFeVk9r7oebW1WheowhKo5soBYKBVT",
        base: MAINNET_SPL_TOKENS.weSAND,
        quote: MAINNET_SPL_TOKENS.USDC,
        decimals: MAINNET_SPL_TOKENS.weSAND.decimals,
        version: 4
      },
      weMANA_USDC_V4: {
        symbol: "weMANA-USDC",
        name: "weMANA-USDC V4 LP",
        mint: "HpUkVAPRJ5zNRuJ1ZwMXEhbMHL3gSuPb2QuSER9YUd3a",
        base: MAINNET_SPL_TOKENS.weMANA,
        quote: MAINNET_SPL_TOKENS.USDC,
        decimals: MAINNET_SPL_TOKENS.weMANA.decimals,
        version: 4
      },
      CAVE_USDC_V4: {
        symbol: "CAVE-USDC",
        name: "CAVE-USDC V4 LP",
        mint: "5Gba1k3fU7Vh7UtAiBmie9vhQNNq1JfEwgn1DPGZ7NKQ",
        base: MAINNET_SPL_TOKENS.CAVE,
        quote: MAINNET_SPL_TOKENS.USDC,
        decimals: MAINNET_SPL_TOKENS.CAVE.decimals,
        version: 4
      },
      GENE_USDC_V4: {
        symbol: "GENE-USDC",
        name: "GENE-USDC V4 LP",
        mint: "7GKvfHEXenNiWYbJBKae89mdaMPr5gGMYwZmyC8gBNVG",
        base: MAINNET_SPL_TOKENS.GENE,
        quote: MAINNET_SPL_TOKENS.USDC,
        decimals: MAINNET_SPL_TOKENS.GENE.decimals,
        version: 4
      },
      GENE_RAY_V4: {
        symbol: "GENE-RAY",
        name: "GENE-RAY V4 LP",
        mint: "3HzXnc1qZ8mGqun18Ck3KA616XnZNqF1RWbgYE2nGRMA",
        base: MAINNET_SPL_TOKENS.GENE,
        quote: MAINNET_SPL_TOKENS.RAY,
        decimals: MAINNET_SPL_TOKENS.GENE.decimals,
        version: 4
      },
      APT_USDC_V4: {
        symbol: "APT-USDC",
        name: "APT-USDC V4 LP",
        mint: "Hk8mDAJFq4E9kF3DtNgPFwzbo5kbeiusNFJgWmo3LoQ5",
        base: MAINNET_SPL_TOKENS.APT,
        quote: MAINNET_SPL_TOKENS.USDC,
        decimals: MAINNET_SPL_TOKENS.APT.decimals,
        version: 4
      },
      GOFX_USDC_V4: {
        symbol: "GOFX-USDC",
        name: "GOFX-USDC V4 LP",
        mint: "4svqAwrLPGRDCQuuieYTmtLXF75wiahjeK2rEN9tY1YL",
        base: MAINNET_SPL_TOKENS.GOFX,
        quote: MAINNET_SPL_TOKENS.USDC,
        decimals: MAINNET_SPL_TOKENS.GOFX.decimals,
        version: 4
      },
      SONAR_USDC_V4: {
        symbol: "SONAR-USDC",
        name: "SONAR-USDC V4 LP",
        mint: "2tAcfqJ1YYjpGLqwh76kyNt9VaNFDd4fJySfH6SmWfKt",
        base: MAINNET_SPL_TOKENS.SONAR,
        quote: MAINNET_SPL_TOKENS.USDC,
        decimals: MAINNET_SPL_TOKENS.SONAR.decimals,
        version: 4
      },
      JSOL_SOL_V4: {
        symbol: "JSOL-SOL",
        name: "JSOL-SOL V4 LP",
        mint: "61z37rpHsU6d3Fq5sUjJ85K6tXGzkoYKDAG3kPJQNDRo",
        base: MAINNET_SPL_TOKENS.JSOL,
        quote: MAINNET_SPL_TOKENS.WSOL,
        decimals: MAINNET_SPL_TOKENS.JSOL.decimals,
        version: 4
      },
      JSOL_USDC_V4: {
        symbol: "JSOL-USDC",
        name: "JSOL-USDC V4 LP",
        mint: "3JZqf2VPNxj1kDZQsfzC7myM6spsGQbGuFv1gVfdYosN",
        base: MAINNET_SPL_TOKENS.JSOL,
        quote: MAINNET_SPL_TOKENS.USDC,
        decimals: MAINNET_SPL_TOKENS.JSOL.decimals,
        version: 4
      },
      SHILL_USDC_V4: {
        symbol: "SHILL-USDC",
        name: "SHILL-USDC V4 LP",
        mint: "CnUhYBtQEbSBZ76bgxAouVCTCb8rofZzwerVF5z5LREJ",
        base: MAINNET_SPL_TOKENS.SHILL,
        quote: MAINNET_SPL_TOKENS.USDC,
        decimals: MAINNET_SPL_TOKENS.SHILL.decimals,
        version: 4
      },
      DFL_USDC_V4: {
        symbol: "DFL-USDC",
        name: "DFL-USDC V4 LP",
        mint: "Fffijd6UVJdQeLVXhenS8YcsnMUdWJqpbBeH42LFkXgS",
        base: MAINNET_SPL_TOKENS.DFL,
        quote: MAINNET_SPL_TOKENS.USDC,
        decimals: MAINNET_SPL_TOKENS.DFL.decimals,
        version: 4
      },
      BOKU_USDC_V4: {
        symbol: "BOKU-USDC",
        name: "BOKU-USDC V4 LP",
        mint: "8jjQn5Yagb6Nm2WGAxPW1bcGqrTWpg5adf6QukXEarcP",
        base: MAINNET_SPL_TOKENS.BOKU,
        quote: MAINNET_SPL_TOKENS.USDC,
        decimals: MAINNET_SPL_TOKENS.BOKU.decimals,
        version: 4
      },
      MIMO_SOL_V4: {
        symbol: "MIMO-SOL",
        name: "MIMO-SOL V4 LP",
        mint: "HUJ1opSk8AiPfDT47r7n4hTiK2EXgrR3Msy7T8q1BywS",
        base: MAINNET_SPL_TOKENS.MIMO,
        quote: MAINNET_SPL_TOKENS.WSOL,
        decimals: MAINNET_SPL_TOKENS.MIMO.decimals,
        version: 4
      },
      wbWBNB_USDC_V4: {
        symbol: "wbWBNB-USDC",
        name: "wbWBNB-USDC V4 LP",
        mint: "FEsEfEJJSfiMQcshUgZ5UigfytfGRQ3z5puyF6DXDp9C",
        base: MAINNET_SPL_TOKENS.wbWBNB,
        quote: MAINNET_SPL_TOKENS.USDC,
        decimals: MAINNET_SPL_TOKENS.wbWBNB.decimals,
        version: 4
      },
      wePEOPLE_USDC_V4: {
        symbol: "wePEOPLE-USDC",
        name: "wePEOPLE-USDC V4 LP",
        mint: "3e5ZCKi4etorpV4pv1fSckP5iJD67xcUkx3RtFCZhbzD",
        base: MAINNET_SPL_TOKENS.wePEOPLE,
        quote: MAINNET_SPL_TOKENS.USDC,
        decimals: MAINNET_SPL_TOKENS.wePEOPLE.decimals,
        version: 4
      },
      ISOLA_USDT_V4: {
        symbol: "ISOLA-USDT",
        name: "ISOLA-USDT V4 LP",
        mint: "H8s1wQsZpRK61pyLF3XwyQc6E8vNUnwRDhy3TBDCDENQ",
        base: MAINNET_SPL_TOKENS.ISOLA,
        quote: MAINNET_SPL_TOKENS.USDT,
        decimals: MAINNET_SPL_TOKENS.ISOLA.decimals,
        version: 4
      },
      SPWN_USDC_V4: {
        symbol: "SPWN-USDC",
        name: "SPWN-USDC V4 LP",
        mint: "B5uyCAQcX6nAjZypLgiivbEKabSptgUb8JK9tkaSnqdW",
        base: MAINNET_SPL_TOKENS.SPWN,
        quote: MAINNET_SPL_TOKENS.USDC,
        decimals: MAINNET_SPL_TOKENS.SPWN.decimals,
        version: 4
      },
      STR_USDC_V4: {
        symbol: "STR-USDC",
        name: "STR-USDC V4 LP",
        mint: "8uDVKmVwNmbXHDB7rNKqtpcT9VAsFHTJ5pPYxjyoBbNg",
        base: MAINNET_SPL_TOKENS.STR,
        quote: MAINNET_SPL_TOKENS.USDC,
        decimals: MAINNET_SPL_TOKENS.STR.decimals,
        version: 4
      },
      SOLC_USDT_V4: {
        symbol: "SOLC-USDT",
        name: "SOLC-USDT V4 LP",
        mint: "2g9JzTWycLzK4KEBBHsponAtZRee2ii63bRrJ8tefEyt",
        base: MAINNET_SPL_TOKENS.SOLC,
        quote: MAINNET_SPL_TOKENS.USDT,
        decimals: MAINNET_SPL_TOKENS.SOLC.decimals,
        version: 4
      },
      VI_USDC_V4: {
        symbol: "VI-USDC",
        name: "VI-USDC V4 LP",
        mint: "3MwHyHCRfVqtH3ABFtdKXdY9dwemr9GGxQFaBkeq6NjY",
        base: MAINNET_SPL_TOKENS.VI,
        quote: MAINNET_SPL_TOKENS.USDC,
        decimals: MAINNET_SPL_TOKENS.VI.decimals,
        version: 4
      },
      KKO_USDC_V4: {
        symbol: "KKO-USDC",
        name: "KKO-USDC V4 LP",
        mint: "7xr1Doc1NiMWbUg99YVFqQSLfYXNzo6YvacXUsSgBMNW",
        base: MAINNET_SPL_TOKENS.KKO,
        quote: MAINNET_SPL_TOKENS.USDC,
        decimals: MAINNET_SPL_TOKENS.KKO.decimals,
        version: 4
      },
      XTAG_USDC_V4: {
        symbol: "XTAG-USDC",
        name: "XTAG-USDC V4 LP",
        mint: "GCEQbLg4ik5YJ4CMcbtuVqEc4sjLdSGy34rFk1CtGjdg",
        base: MAINNET_SPL_TOKENS.XTAG,
        quote: MAINNET_SPL_TOKENS.USDC,
        decimals: MAINNET_SPL_TOKENS.XTAG.decimals,
        version: 4
      },
      TTT_USDC_V4: {
        symbol: "TTT-USDC",
        name: "TTT-USDC V4 LP",
        mint: "84fmrerHGohoRf4iLPDQ1KG4CjSjCRksYWGzjWfCRM8a",
        base: MAINNET_SPL_TOKENS.TTT,
        quote: MAINNET_SPL_TOKENS.USDC,
        decimals: MAINNET_SPL_TOKENS.TTT.decimals,
        version: 4
      },
      RUN_USDC_V4: {
        symbol: "RUN-USDC",
        name: "RUN-USDC V4 LP",
        mint: "CjTLvvKSQdEujcSzeZRYgk4w1DpuXBbMppLHaxZyz11Y",
        base: MAINNET_SPL_TOKENS.RUN,
        quote: MAINNET_SPL_TOKENS.USDC,
        decimals: MAINNET_SPL_TOKENS.RUN.decimals,
        version: 4
      },
      CRWNY_USDC_V4: {
        symbol: "CRWNY-USDC",
        name: "CRWNY-USDC V4 LP",
        mint: "H3D9Gyi4frRLW6bS9vBthDVDJyzyRJ6XhhpP6PJGWaDC",
        base: MAINNET_SPL_TOKENS.CRWNY,
        quote: MAINNET_SPL_TOKENS.USDC,
        decimals: MAINNET_SPL_TOKENS.CRWNY.decimals,
        version: 4
      },
      CRWNY_RAY_V4: {
        symbol: "CRWNY-RAY",
        name: "CRWNY-RAY V4 LP",
        mint: "5Cz9wGStNjiUg81q8t6sJJeckuT2C14CYSfyQbtYirSX",
        base: MAINNET_SPL_TOKENS.CRWNY,
        quote: MAINNET_SPL_TOKENS.RAY,
        decimals: MAINNET_SPL_TOKENS.CRWNY.decimals,
        version: 4
      },
      BLOCK_USDC_V4: {
        symbol: "BLOCK-USDC",
        name: "BLOCK-USDC V4 LP",
        mint: "8i44Y23GkkwDYZ5iSkVEqmrXUfwNmwo9grguTDWKM8wg",
        base: MAINNET_SPL_TOKENS.BLOCK,
        quote: MAINNET_SPL_TOKENS.USDC,
        decimals: MAINNET_SPL_TOKENS.BLOCK.decimals,
        version: 4
      },
      REAL_USDC_V4: {
        symbol: "REAL-USDC",
        name: "REAL-USDC V4 LP",
        mint: "EN43tp8xdkcM8RYSJ4msFHMPTJRXKhUteVYBDJLwTvr3",
        base: MAINNET_SPL_TOKENS.REAL,
        quote: MAINNET_SPL_TOKENS.USDC,
        decimals: MAINNET_SPL_TOKENS.REAL.decimals,
        version: 4
      },
      FRKT_USDC_V4: {
        symbol: "FRKT-USDC",
        name: "FRKT-USDC V4 LP",
        mint: "7MgzqVTGeA4wENme81QPTrPy45NJMKVL9XGwxmNT87cG",
        base: MAINNET_SPL_TOKENS.FRKT,
        quote: MAINNET_SPL_TOKENS.USDC,
        decimals: MAINNET_SPL_TOKENS.FRKT.decimals,
        version: 4
      },
      MBS_USDC_V4: {
        symbol: "MBS-USDC",
        name: "MBS-USDC V4 LP",
        mint: "BAgSWaPZpsQKyZJdvB5KyvmCNj6hzczzentt5FhDCVHb",
        base: MAINNET_SPL_TOKENS.MBS,
        quote: MAINNET_SPL_TOKENS.USDC,
        decimals: MAINNET_SPL_TOKENS.MBS.decimals,
        version: 4
      },
      PRISM_USDC_V4: {
        symbol: "PRISM-USDC",
        name: "PRISM-USDC V4 LP",
        mint: "3baYkTcudvSFMe25UpZcBfdp4FA5kL2E4pfaeJ8AiYJB",
        base: MAINNET_SPL_TOKENS.PRISM,
        quote: MAINNET_SPL_TOKENS.USDC,
        decimals: MAINNET_SPL_TOKENS.PRISM.decimals,
        version: 4
      },
      CHICKS_USDC_V4: {
        symbol: "CHICKS-USDC",
        name: "CHICKS-USDC V4 LP",
        mint: "CPzmcw81a6PDasSXhVLfDRKuTJXZPUqocS9VFf5zCFhs",
        base: MAINNET_SPL_TOKENS.CHICKS,
        quote: MAINNET_SPL_TOKENS.USDC,
        decimals: MAINNET_SPL_TOKENS.CHICKS.decimals,
        version: 4
      },
      MEAN_RAY_V4: {
        symbol: "MEAN-RAY",
        name: "MEAN-RAY V4 LP",
        mint: "H9wUyrxpAErmdNVPitpHSXgwoomoh91ggJKPWtQQoCn1",
        base: MAINNET_SPL_TOKENS.MEAN,
        quote: MAINNET_SPL_TOKENS.RAY,
        decimals: MAINNET_SPL_TOKENS.MEAN.decimals,
        version: 4
      },
      TINY_USDC_V4: {
        symbol: "TINY-USDC",
        name: "TINY-USDC V4 LP",
        mint: "Hho6ZzRDj49L4z6zog8nQZFaxMSz6FX6wNzVpMeAMen",
        base: MAINNET_SPL_TOKENS.TINY,
        quote: MAINNET_SPL_TOKENS.USDC,
        decimals: MAINNET_SPL_TOKENS.TINY.decimals,
        version: 4
      },
      SCY_USDC_V4: {
        symbol: "SCY-USDC",
        name: "SCY-USDC V4 LP",
        mint: "EcYk7t6Vw59HDnY2u6H1KDPkk8juMeA1NpGpHiGk1LDf",
        base: MAINNET_SPL_TOKENS.SCY,
        quote: MAINNET_SPL_TOKENS.USDC,
        decimals: MAINNET_SPL_TOKENS.SCY.decimals,
        version: 4
      }
    };
    var TESTNET_SPL_TOKENS = {
      WSOL: __spreadValues({}, WSOL)
    };
    var TESTNET_LP_TOKENS = {};
    var logger4 = Logger2.from("token/util");
    var TokenList = class {
      constructor(tokenList) {
        this.tokenList = tokenList;
        this.filterByMint = (mint) => {
          return this.tokenList.filter((token) => token.mint === mint);
        };
        this.filterUniqueByMint = (mint, tokenType = "all") => {
          const result = this.tokenList.filter((token2) => token2.mint === mint);
          if (result.length === 0) {
            return logger4.throwArgumentError(`No token found`, "mint", mint);
          } else if (result.length > 1) {
            return logger4.throwArgumentError(`Multiple tokens found: ${result.length}`, "mint", mint);
          }
          const token = result[0];
          if (tokenType === "spl" && "version" in token) {
            return logger4.throwArgumentError("invalid SPL token mint", "mint", mint);
          } else if (tokenType === "lp" && !("version" in token)) {
            return logger4.throwArgumentError("invalid LP token mint", "mint", mint);
          }
          return token;
        };
        this.getList = () => {
          return this.tokenList;
        };
      }
    };
    var _Currency = class _Currency {
      /**
       * Constructs an instance of the base class `Currency`. The only instance of the base class `Currency` is `Currency.SOL`.
       * @param decimals - decimals of the currency
       * @param symbol - symbol of the currency
       * @param name - name of the currency
       */
      constructor(decimals, symbol = "UNKNOWN", name = "UNKNOWN") {
        this.decimals = decimals;
        this.symbol = symbol;
        this.name = name;
      }
    };
    _Currency.SOL = new _Currency(SOL.decimals, SOL.symbol, SOL.name);
    var Currency2 = _Currency;
    function inspectCurrency() {
      Currency2.prototype.inspect = function() {
        return `<Currency: decimals=${this.decimals}, name=${this.name}, symbol=${this.symbol}>`;
      };
    }
    var _Token = class _Token extends Currency2 {
      constructor(programId, mint, decimals, symbol = "UNKNOWN", name = "UNKNOWN") {
        super(decimals, symbol, name);
        this.programId = validateAndParsePublicKey2(programId);
        this.mint = validateAndParsePublicKey2(mint);
      }
      /**
       * Returns true if the two tokens are equivalent, i.e. have the same mint address.
       * @param other - other token to compare
       */
      equals(other) {
        if (this === other) {
          return true;
        }
        return this.mint.equals(other.mint);
      }
    };
    _Token.WSOL = new _Token(import_spl_token2.TOKEN_PROGRAM_ID, WSOL.mint, WSOL.decimals, SOL.symbol, SOL.name);
    var Token3 = _Token;
    function inspectToken() {
      Token3.prototype.inspect = function() {
        return `<Token: mint=${this.mint.toBase58()}, decimals=${this.decimals}, name=${this.name}, symbol=${this.symbol}>`;
      };
    }
    function currencyEquals2(currencyA, currencyB) {
      if (currencyA instanceof Token3 && currencyB instanceof Token3) {
        return currencyA.equals(currencyB);
      } else if (currencyA instanceof Token3 || currencyB instanceof Token3) {
        return false;
      } else {
        return currencyA === currencyB;
      }
    }
    var import_big = __toESM2(require_big());
    var import_decimal2 = __toESM2(require_decimal2());
    var import_toformat = __toESM2(require_toFormat());
    var toFormat = import_toformat.default;
    var to_format_default = toFormat;
    var logger5 = Logger2.from("entity/fraction");
    var Big = to_format_default(import_big.default);
    var Decimal2 = to_format_default(import_decimal2.default);
    var toSignificantRounding = {
      [
        0
        /* ROUND_DOWN */
      ]: Decimal2.ROUND_DOWN,
      [
        1
        /* ROUND_HALF_UP */
      ]: Decimal2.ROUND_HALF_UP,
      [
        2
        /* ROUND_UP */
      ]: Decimal2.ROUND_UP
    };
    var toFixedRounding = {
      [
        0
        /* ROUND_DOWN */
      ]: Big.roundDown,
      [
        1
        /* ROUND_HALF_UP */
      ]: Big.roundHalfUp,
      [
        2
        /* ROUND_UP */
      ]: Big.roundUp
    };
    var Fraction2 = class _Fraction {
      constructor(numerator, denominator = ONE2) {
        this.numerator = parseBigNumberish2(numerator);
        this.denominator = parseBigNumberish2(denominator);
      }
      // performs floor division
      get quotient() {
        return this.numerator.div(this.denominator);
      }
      invert() {
        return new _Fraction(this.denominator, this.numerator);
      }
      // +
      add(other) {
        const otherParsed = other instanceof _Fraction ? other : new _Fraction(parseBigNumberish2(other));
        if (this.denominator.eq(otherParsed.denominator)) {
          return new _Fraction(this.numerator.add(otherParsed.numerator), this.denominator);
        }
        return new _Fraction(
          this.numerator.mul(otherParsed.denominator).add(otherParsed.numerator.mul(this.denominator)),
          this.denominator.mul(otherParsed.denominator)
        );
      }
      // -
      sub(other) {
        const otherParsed = other instanceof _Fraction ? other : new _Fraction(parseBigNumberish2(other));
        if (this.denominator.eq(otherParsed.denominator)) {
          return new _Fraction(this.numerator.sub(otherParsed.numerator), this.denominator);
        }
        return new _Fraction(
          this.numerator.mul(otherParsed.denominator).sub(otherParsed.numerator.mul(this.denominator)),
          this.denominator.mul(otherParsed.denominator)
        );
      }
      // 
      mul(other) {
        const otherParsed = other instanceof _Fraction ? other : new _Fraction(parseBigNumberish2(other));
        return new _Fraction(this.numerator.mul(otherParsed.numerator), this.denominator.mul(otherParsed.denominator));
      }
      // 
      div(other) {
        const otherParsed = other instanceof _Fraction ? other : new _Fraction(parseBigNumberish2(other));
        return new _Fraction(this.numerator.mul(otherParsed.denominator), this.denominator.mul(otherParsed.numerator));
      }
      toSignificant(significantDigits, format = { groupSeparator: "" }, rounding = 1) {
        logger5.assert(Number.isInteger(significantDigits), `${significantDigits} is not an integer.`);
        logger5.assert(significantDigits > 0, `${significantDigits} is not positive.`);
        Decimal2.set({ precision: significantDigits + 1, rounding: toSignificantRounding[rounding] });
        const quotient = new Decimal2(this.numerator.toString()).div(this.denominator.toString()).toSignificantDigits(significantDigits);
        return quotient.toFormat(quotient.decimalPlaces(), format);
      }
      toFixed(decimalPlaces, format = { groupSeparator: "" }, rounding = 1) {
        logger5.assert(Number.isInteger(decimalPlaces), `${decimalPlaces} is not an integer.`);
        logger5.assert(decimalPlaces >= 0, `${decimalPlaces} is negative.`);
        Big.DP = decimalPlaces;
        Big.RM = toFixedRounding[rounding];
        return new Big(this.numerator.toString()).div(this.denominator.toString()).toFormat(decimalPlaces, format);
      }
    };
    var logger6 = Logger2.from("entity/amount");
    var Big2 = to_format_default(import_big2.default);
    function splitNumber2(num, decimals) {
      let integral = "0";
      let fractional = "0";
      if (num.includes(".")) {
        const splited = num.split(".");
        if (splited.length === 2) {
          ;
          [integral, fractional] = splited;
          fractional = fractional.padEnd(decimals, "0");
        } else {
          return logger6.throwArgumentError("invalid number string", "num", num);
        }
      } else {
        integral = num;
      }
      return [integral, fractional.slice(0, decimals) || fractional];
    }
    var CurrencyAmount2 = class _CurrencyAmount extends Fraction2 {
      constructor(currency, amount, isRaw = true) {
        let parsedAmount = new import_bn5.default(0);
        const multiplier = TEN.pow(new import_bn5.default(currency.decimals));
        if (isRaw) {
          parsedAmount = parseBigNumberish2(amount);
        } else {
          let integralAmount = new import_bn5.default(0);
          let fractionalAmount = new import_bn5.default(0);
          if (typeof amount === "string" || typeof amount === "number" || typeof amount === "bigint") {
            const [integral, fractional] = splitNumber2(amount.toString(), currency.decimals);
            integralAmount = parseBigNumberish2(integral);
            fractionalAmount = parseBigNumberish2(fractional);
          }
          integralAmount = integralAmount.mul(multiplier);
          parsedAmount = integralAmount.add(fractionalAmount);
        }
        super(parsedAmount, multiplier);
        this.currency = currency;
      }
      get raw() {
        return this.numerator;
      }
      isZero() {
        return this.raw.isZero();
      }
      /**
       * a greater than b
       */
      gt(other) {
        logger6.assert(currencyEquals2(this.currency, other.currency), "gt currency not equals");
        return this.raw.gt(other.raw);
      }
      /**
       * a less than b
       */
      lt(other) {
        logger6.assert(currencyEquals2(this.currency, other.currency), "lt currency not equals");
        return this.raw.lt(other.raw);
      }
      add(other) {
        logger6.assert(currencyEquals2(this.currency, other.currency), "add currency not equals");
        return new _CurrencyAmount(this.currency, this.raw.add(other.raw));
      }
      sub(other) {
        logger6.assert(currencyEquals2(this.currency, other.currency), "sub currency not equals");
        return new _CurrencyAmount(this.currency, this.raw.sub(other.raw));
      }
      toSignificant(significantDigits = this.currency.decimals, format, rounding = 0) {
        return super.toSignificant(significantDigits, format, rounding);
      }
      /**
       * To fixed
       *
       * @example
       * ```
       * 1 -> 1.000000000
       * 1.234 -> 1.234000000
       * 1.123456789876543 -> 1.123456789
       * ```
       */
      toFixed(decimalPlaces = this.currency.decimals, format, rounding = 0) {
        logger6.assert(decimalPlaces <= this.currency.decimals, "decimals overflow");
        return super.toFixed(decimalPlaces, format, rounding);
      }
      /**
       * To exact
       *
       * @example
       * ```
       * 1 -> 1
       * 1.234 -> 1.234
       * 1.123456789876543 -> 1.123456789
       * ```
       */
      toExact(format = { groupSeparator: "" }) {
        Big2.DP = this.currency.decimals;
        return new Big2(this.numerator.toString()).div(this.denominator.toString()).toFormat(format);
      }
    };
    var TokenAmount3 = class _TokenAmount extends CurrencyAmount2 {
      constructor(token, amount, isRaw = true) {
        super(token, amount, isRaw);
        this.token = token;
      }
      add(other) {
        logger6.assert(currencyEquals2(this.token, other.token), "add token not equals");
        return new _TokenAmount(this.token, this.raw.add(other.raw));
      }
      subtract(other) {
        logger6.assert(currencyEquals2(this.token, other.token), "sub token not equals");
        return new _TokenAmount(this.token, this.raw.sub(other.raw));
      }
    };
    var _100_PERCENT2 = new Fraction2(_100);
    var Percent3 = class extends Fraction2 {
      toSignificant(significantDigits = 5, format, rounding) {
        return this.mul(_100_PERCENT2).toSignificant(significantDigits, format, rounding);
      }
      toFixed(decimalPlaces = 2, format, rounding) {
        return this.mul(_100_PERCENT2).toFixed(decimalPlaces, format, rounding);
      }
    };
    var logger7 = Logger2.from("entity/price");
    var Price2 = class _Price extends Fraction2 {
      // denominator and numerator _must_ be raw, i.e. in the native representation
      constructor(baseCurrency, denominator, quoteCurrency, numerator) {
        super(numerator, denominator);
        this.baseCurrency = baseCurrency;
        this.quoteCurrency = quoteCurrency;
        this.scalar = new Fraction2(tenExponentiate(baseCurrency.decimals), tenExponentiate(quoteCurrency.decimals));
      }
      get raw() {
        return new Fraction2(this.numerator, this.denominator);
      }
      get adjusted() {
        return super.mul(this.scalar);
      }
      invert() {
        return new _Price(this.quoteCurrency, this.numerator, this.baseCurrency, this.denominator);
      }
      mul(other) {
        logger7.assert(currencyEquals2(this.quoteCurrency, other.baseCurrency), "mul currency not equals");
        const fraction = super.mul(other);
        return new _Price(this.baseCurrency, fraction.denominator, other.quoteCurrency, fraction.numerator);
      }
      toSignificant(significantDigits = this.quoteCurrency.decimals, format, rounding) {
        return this.adjusted.toSignificant(significantDigits, format, rounding);
      }
      toFixed(decimalPlaces = this.quoteCurrency.decimals, format, rounding) {
        return this.adjusted.toFixed(decimalPlaces, format, rounding);
      }
    };
    var import_web38 = require("@solana/web3.js");
    var import_bn6 = __toESM2(require_bn());
    var import_buffer_layout5 = require_Layout();
    var Layout2 = import_buffer_layout5.Layout;
    var Structure2 = import_buffer_layout5.Structure;
    var Union2 = import_buffer_layout5.Union;
    var BitStructure2 = import_buffer_layout5.BitStructure;
    var UInt2 = import_buffer_layout5.UInt;
    var Blob2 = import_buffer_layout5.Blob;
    var greedy2 = import_buffer_layout5.greedy;
    var u84 = import_buffer_layout5.u8;
    var u162 = import_buffer_layout5.u16;
    var u242 = import_buffer_layout5.u24;
    var u323 = import_buffer_layout5.u32;
    var u402 = import_buffer_layout5.u40;
    var u482 = import_buffer_layout5.u48;
    var nu642 = import_buffer_layout5.nu64;
    var u16be2 = import_buffer_layout5.u16be;
    var u24be2 = import_buffer_layout5.u24be;
    var u32be2 = import_buffer_layout5.u32be;
    var u40be2 = import_buffer_layout5.u40be;
    var u48be2 = import_buffer_layout5.u48be;
    var nu64be2 = import_buffer_layout5.nu64be;
    var s82 = import_buffer_layout5.s8;
    var s162 = import_buffer_layout5.s16;
    var s242 = import_buffer_layout5.s24;
    var s322 = import_buffer_layout5.s32;
    var s402 = import_buffer_layout5.s40;
    var s482 = import_buffer_layout5.s48;
    var ns642 = import_buffer_layout5.ns64;
    var s16be2 = import_buffer_layout5.s16be;
    var s24be2 = import_buffer_layout5.s24be;
    var s32be2 = import_buffer_layout5.s32be;
    var s40be2 = import_buffer_layout5.s40be;
    var s48be2 = import_buffer_layout5.s48be;
    var ns64be2 = import_buffer_layout5.ns64be;
    var f322 = import_buffer_layout5.f32;
    var f32be2 = import_buffer_layout5.f32be;
    var f642 = import_buffer_layout5.f64;
    var f64be2 = import_buffer_layout5.f64be;
    var seq2 = import_buffer_layout5.seq;
    var union2 = import_buffer_layout5.union;
    var unionLayoutDiscriminator2 = import_buffer_layout5.unionLayoutDiscriminator;
    var blob4 = import_buffer_layout5.blob;
    var cstr2 = import_buffer_layout5.cstr;
    var utf82 = import_buffer_layout5.utf8;
    var bits2 = import_buffer_layout5.bits;
    var offset2 = import_buffer_layout5.offset;
    var BNLayout2 = class extends Layout2 {
      constructor(span, signed, property) {
        super(span, property);
        this.blob = blob4(span);
        this.signed = signed;
      }
      /** @override */
      decode(b, offset22 = 0) {
        const num = new import_bn6.default(this.blob.decode(b, offset22), 10, "le");
        if (this.signed) {
          return num.fromTwos(this.span * 8).clone();
        }
        return num;
      }
      /** @override */
      encode(src, b, offset22 = 0) {
        if (typeof src === "number")
          src = new import_bn6.default(src);
        if (this.signed) {
          src = src.toTwos(this.span * 8);
        }
        return this.blob.encode(src.toArrayLike(Buffer, "le", this.span), b, offset22);
      }
    };
    var WideBits2 = class extends Layout2 {
      // TODO: unknown
      constructor(property) {
        super(8, property);
        this._lower = bits2(u323(), false);
        this._upper = bits2(u323(), false);
      }
      addBoolean(property) {
        if (this._lower.fields.length < 32) {
          this._lower.addBoolean(property);
        } else {
          this._upper.addBoolean(property);
        }
      }
      decode(b, offset22 = 0) {
        const lowerDecoded = this._lower.decode(b, offset22);
        const upperDecoded = this._upper.decode(b, offset22 + this._lower.span);
        return __spreadValues(__spreadValues({}, lowerDecoded), upperDecoded);
      }
      encode(src, b, offset22 = 0) {
        return this._lower.encode(src, b, offset22) + this._upper.encode(src, b, offset22 + this._lower.span);
      }
    };
    function u822(property) {
      return new UInt2(1, property);
    }
    function u3222(property) {
      return new UInt2(4, property);
    }
    function u643(property) {
      return new BNLayout2(8, false, property);
    }
    function u1283(property) {
      return new BNLayout2(16, false, property);
    }
    function i82(property) {
      return new BNLayout2(1, true, property);
    }
    function i642(property) {
      return new BNLayout2(8, true, property);
    }
    function i1282(property) {
      return new BNLayout2(16, true, property);
    }
    var WrappedLayout2 = class extends Layout2 {
      constructor(layout, decoder, encoder, property) {
        super(layout.span, property);
        this.layout = layout;
        this.decoder = decoder;
        this.encoder = encoder;
      }
      decode(b, offset22) {
        return this.decoder(this.layout.decode(b, offset22));
      }
      encode(src, b, offset22) {
        return this.layout.encode(this.encoder(src), b, offset22);
      }
      getSpan(b, offset22) {
        return this.layout.getSpan(b, offset22);
      }
    };
    function publicKey3(property) {
      return new WrappedLayout2(
        blob4(32),
        (b) => new import_web38.PublicKey(b),
        (key) => key.toBuffer(),
        property
      );
    }
    var OptionLayout2 = class extends Layout2 {
      constructor(layout, property) {
        super(-1, property);
        this.layout = layout;
        this.discriminator = u84();
      }
      encode(src, b, offset22 = 0) {
        if (src === null || src === void 0) {
          return this.discriminator.encode(0, b, offset22);
        }
        this.discriminator.encode(1, b, offset22);
        return this.layout.encode(src, b, offset22 + 1) + 1;
      }
      decode(b, offset22 = 0) {
        const discriminator = this.discriminator.decode(b, offset22);
        if (discriminator === 0) {
          return null;
        } else if (discriminator === 1) {
          return this.layout.decode(b, offset22 + 1);
        }
        throw new Error("Invalid option " + this.property);
      }
      getSpan(b, offset22 = 0) {
        const discriminator = this.discriminator.decode(b, offset22);
        if (discriminator === 0) {
          return 1;
        } else if (discriminator === 1) {
          return this.layout.getSpan(b, offset22 + 1) + 1;
        }
        throw new Error("Invalid option " + this.property);
      }
    };
    function option2(layout, property) {
      return new OptionLayout2(layout, property);
    }
    function bool22(property) {
      return new WrappedLayout2(u84(), decodeBool2, encodeBool2, property);
    }
    function decodeBool2(value) {
      if (value === 0) {
        return false;
      } else if (value === 1) {
        return true;
      }
      throw new Error("Invalid bool: " + value);
    }
    function encodeBool2(value) {
      return value ? 1 : 0;
    }
    function vec2(elementLayout, property) {
      const length = u323("length");
      const layout = struct3([
        length,
        seq22(elementLayout, offset2(length, -length.span), "values")
      ]);
      return new WrappedLayout2(
        layout,
        ({ values }) => values,
        (values) => ({ values }),
        property
      );
    }
    function tagged2(tag2, layout, property) {
      const wrappedLayout = struct3([u643("tag"), layout.replicate("data")]);
      function decodeTag({ tag: receivedTag, data }) {
        if (!receivedTag.eq(tag2)) {
          throw new Error("Invalid tag, expected: " + tag2.toString("hex") + ", got: " + receivedTag.toString("hex"));
        }
        return data;
      }
      return new WrappedLayout2(wrappedLayout, decodeTag, (data) => ({ tag: tag2, data }), property);
    }
    function vecU82(property) {
      const length = u323("length");
      const layout = struct3([length, blob4(offset2(length, -length.span), "data")]);
      return new WrappedLayout2(
        layout,
        ({ data }) => data,
        (data) => ({ data }),
        property
      );
    }
    function str2(property) {
      return new WrappedLayout2(
        vecU82(),
        (data) => data.toString("utf-8"),
        (s) => Buffer.from(s, "utf-8"),
        property
      );
    }
    function rustEnum2(variants, property) {
      const unionLayout = union2(u84(), property);
      variants.forEach((variant, index) => unionLayout.addVariant(index, variant, variant.property));
      return unionLayout;
    }
    function array2(elementLayout, length, property) {
      const layout = struct3([seq22(elementLayout, length, "values")]);
      return new WrappedLayout2(
        layout,
        ({ values }) => values,
        (values) => ({ values }),
        property
      );
    }
    var Structure22 = class extends Structure2 {
      /** @override */
      decode(b, offset22) {
        return super.decode(b, offset22);
      }
    };
    function struct3(fields, property, decodePrefixes) {
      return new Structure22(fields, property, decodePrefixes);
    }
    var Union22 = class extends Union2 {
      encodeInstruction(instruction) {
        const instructionMaxSpan = Math.max(...Object.values(this.registry).map((r) => r.span));
        const b = Buffer.alloc(instructionMaxSpan);
        return b.slice(0, this.encode(instruction, b));
      }
      decodeInstruction(instruction) {
        return this.decode(instruction);
      }
    };
    function union22(discr, defaultLayout, property) {
      return new Union22(discr, defaultLayout, property);
    }
    var Zeros = class extends Blob2 {
      decode(b, offset22) {
        const slice = super.decode(b, offset22);
        if (!slice.every((v) => v === 0)) {
          throw new Error("nonzero padding bytes");
        }
        return slice;
      }
    };
    function zeros2(length) {
      return new Zeros(length);
    }
    function seq22(elementLayout, count, property) {
      let parsedCount;
      const superCount = typeof count === "number" ? count : (0, import_bn6.isBN)(count) ? count.toNumber() : new Proxy(count, {
        get(target, property2) {
          if (!parsedCount) {
            const countProperty = Reflect.get(target, "count");
            parsedCount = (0, import_bn6.isBN)(countProperty) ? countProperty.toNumber() : countProperty;
            Reflect.set(target, "count", parsedCount);
          }
          return Reflect.get(target, property2);
        },
        set(target, property2, value) {
          if (property2 === "count") {
            parsedCount = value;
          }
          return Reflect.set(target, property2, value);
        }
      });
      return seq2(elementLayout, superCount, property);
    }
    var SPL_MINT_LAYOUT2 = struct3([
      u3222("mintAuthorityOption"),
      publicKey3("mintAuthority"),
      u643("supply"),
      u822("decimals"),
      u822("isInitialized"),
      u3222("freezeAuthorityOption"),
      publicKey3("freezeAuthority")
    ]);
    var SPL_ACCOUNT_LAYOUT = struct3([
      publicKey3("mint"),
      publicKey3("owner"),
      u643("amount"),
      u3222("delegateOption"),
      publicKey3("delegate"),
      u822("state"),
      u3222("isNativeOption"),
      u643("isNative"),
      u643("delegatedAmount"),
      u3222("closeAuthorityOption"),
      publicKey3("closeAuthority")
    ]);
    var import_spl_token22 = require_cjs5();
    var import_web310 = require("@solana/web3.js");
    var import_bn7 = __toESM2(require_bn());
    var import_web39 = require("@solana/web3.js");
    function getATAAddress2(owner, mint, programId) {
      return findProgramAddress2(
        [owner.toBuffer(), programId.toBuffer(), mint.toBuffer()],
        new import_web39.PublicKey("ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL")
      );
    }
    var Spl = class {
      static getAssociatedTokenAccount({
        mint,
        owner,
        programId
      }) {
        return getATAAddress2(owner, mint, programId).publicKey;
      }
      static makeCreateAssociatedTokenAccountInstruction({
        programId,
        mint,
        associatedAccount,
        owner,
        payer,
        instructionsType
      }) {
        instructionsType.push(
          2
          /* createATA */
        );
        return (0, import_spl_token22.createAssociatedTokenAccountInstruction)(payer, associatedAccount, owner, mint, programId);
      }
      // https://github.com/solana-labs/solana-program-library/blob/master/token/js/client/token.js
      static makeCreateWrappedNativeAccountInstructions(_0) {
        return __async(this, arguments, function* ({
          connection,
          owner,
          payer,
          amount,
          // baseRentExemption,
          commitment
        }) {
          const instructions = [];
          const instructionTypes = [];
          const balanceNeeded = yield connection.getMinimumBalanceForRentExemption(SPL_ACCOUNT_LAYOUT.span, commitment);
          const lamports = parseBigNumberish2(amount).add(new import_bn7.default(balanceNeeded));
          const newAccount = generatePubKey2({ fromPublicKey: payer, programId: import_spl_token2.TOKEN_PROGRAM_ID });
          instructions.push(
            import_web310.SystemProgram.createAccountWithSeed({
              fromPubkey: payer,
              basePubkey: payer,
              seed: newAccount.seed,
              newAccountPubkey: newAccount.publicKey,
              lamports: lamports.toNumber(),
              space: SPL_ACCOUNT_LAYOUT.span,
              programId: import_spl_token2.TOKEN_PROGRAM_ID
            })
          );
          instructionTypes.push(
            0
            /* createAccount */
          );
          instructions.push(
            this.makeInitAccountInstruction({
              programId: import_spl_token2.TOKEN_PROGRAM_ID,
              mint: validateAndParsePublicKey2(WSOL.mint),
              tokenAccount: newAccount.publicKey,
              owner,
              instructionTypes
            })
          );
          return {
            address: { newAccount: newAccount.publicKey },
            innerTransaction: {
              instructions,
              signers: [],
              lookupTableAddress: [],
              instructionTypes
            }
          };
        });
      }
      static insertCreateWrappedNativeAccount(_0) {
        return __async(this, arguments, function* ({
          connection,
          owner,
          payer,
          amount,
          instructions,
          instructionsType,
          signers,
          commitment
        }) {
          const ins = yield this.makeCreateWrappedNativeAccountInstructions({
            connection,
            owner,
            payer,
            amount,
            commitment
          });
          instructions.push(...ins.innerTransaction.instructions);
          signers.push(...ins.innerTransaction.signers);
          instructionsType.push(...ins.innerTransaction.instructionTypes);
          return ins.address.newAccount;
        });
      }
      static makeInitMintInstruction({
        programId,
        mint,
        decimals,
        mintAuthority,
        freezeAuthority = null,
        instructionTypes
      }) {
        instructionTypes.push(
          5
          /* initMint */
        );
        return (0, import_spl_token22.createInitializeMintInstruction)(mint, decimals, mintAuthority, freezeAuthority, programId);
      }
      static makeMintToInstruction({
        programId,
        mint,
        dest,
        authority,
        amount,
        multiSigners = [],
        instructionTypes
      }) {
        instructionTypes.push(
          6
          /* mintTo */
        );
        return (0, import_spl_token22.createMintToInstruction)(mint, dest, authority, BigInt(String(amount)), multiSigners, programId);
      }
      static makeInitAccountInstruction({
        programId,
        mint,
        tokenAccount,
        owner,
        instructionTypes
      }) {
        instructionTypes.push(
          1
          /* initAccount */
        );
        return (0, import_spl_token22.createInitializeAccountInstruction)(tokenAccount, mint, owner, programId);
      }
      static makeTransferInstruction({
        programId,
        source,
        destination,
        owner,
        amount,
        multiSigners = [],
        instructionsType
      }) {
        instructionsType.push(
          4
          /* transferAmount */
        );
        return (0, import_spl_token22.createTransferInstruction)(source, destination, owner, BigInt(String(amount)), multiSigners, programId);
      }
      static makeCloseAccountInstruction({
        programId,
        tokenAccount,
        owner,
        payer,
        multiSigners = [],
        instructionsType
      }) {
        instructionsType.push(
          3
          /* closeAccount */
        );
        return (0, import_spl_token22.createCloseAccountInstruction)(tokenAccount, payer, owner, multiSigners, programId);
      }
      static createInitAccountInstruction(programId, mint, account, owner) {
        const keys = [
          {
            pubkey: account,
            isSigner: false,
            isWritable: true
          },
          {
            pubkey: mint,
            isSigner: false,
            isWritable: false
          },
          {
            pubkey: owner,
            isSigner: false,
            isWritable: false
          },
          {
            pubkey: import_web332.SYSVAR_RENT_PUBKEY,
            isSigner: false,
            isWritable: false
          }
        ];
        const dataLayout = u822("instruction");
        const data = Buffer.alloc(dataLayout.span);
        dataLayout.encode(1, data);
        return new import_web310.TransactionInstruction({
          keys,
          programId,
          data
        });
      }
    };
    var TxVersion3 = /* @__PURE__ */ ((TxVersion8) => {
      TxVersion8[TxVersion8["V0"] = 0] = "V0";
      TxVersion8[TxVersion8["LEGACY"] = 1] = "LEGACY";
      return TxVersion8;
    })(TxVersion3 || {});
    var InstructionType2 = /* @__PURE__ */ ((InstructionType22) => {
      InstructionType22[InstructionType22["createAccount"] = 0] = "createAccount";
      InstructionType22[InstructionType22["initAccount"] = 1] = "initAccount";
      InstructionType22[InstructionType22["createATA"] = 2] = "createATA";
      InstructionType22[InstructionType22["closeAccount"] = 3] = "closeAccount";
      InstructionType22[InstructionType22["transferAmount"] = 4] = "transferAmount";
      InstructionType22[InstructionType22["initMint"] = 5] = "initMint";
      InstructionType22[InstructionType22["mintTo"] = 6] = "mintTo";
      InstructionType22[InstructionType22["initMarket"] = 7] = "initMarket";
      InstructionType22[InstructionType22["util1216OwnerClaim"] = 8] = "util1216OwnerClaim";
      InstructionType22[InstructionType22["setComputeUnitPrice"] = 9] = "setComputeUnitPrice";
      InstructionType22[InstructionType22["setComputeUnitLimit"] = 10] = "setComputeUnitLimit";
      InstructionType22[InstructionType22["clmmCreatePool"] = 11] = "clmmCreatePool";
      InstructionType22[InstructionType22["clmmOpenPosition"] = 12] = "clmmOpenPosition";
      InstructionType22[InstructionType22["clmmIncreasePosition"] = 13] = "clmmIncreasePosition";
      InstructionType22[InstructionType22["clmmDecreasePosition"] = 14] = "clmmDecreasePosition";
      InstructionType22[InstructionType22["clmmClosePosition"] = 15] = "clmmClosePosition";
      InstructionType22[InstructionType22["clmmSwapBaseIn"] = 16] = "clmmSwapBaseIn";
      InstructionType22[InstructionType22["clmmSwapBaseOut"] = 17] = "clmmSwapBaseOut";
      InstructionType22[InstructionType22["clmmInitReward"] = 18] = "clmmInitReward";
      InstructionType22[InstructionType22["clmmSetReward"] = 19] = "clmmSetReward";
      InstructionType22[InstructionType22["clmmCollectReward"] = 20] = "clmmCollectReward";
      InstructionType22[InstructionType22["ammV4Swap"] = 21] = "ammV4Swap";
      InstructionType22[InstructionType22["ammV4AddLiquidity"] = 22] = "ammV4AddLiquidity";
      InstructionType22[InstructionType22["ammV4RemoveLiquidity"] = 23] = "ammV4RemoveLiquidity";
      InstructionType22[InstructionType22["ammV4SimulatePoolInfo"] = 24] = "ammV4SimulatePoolInfo";
      InstructionType22[InstructionType22["ammV4SwapBaseIn"] = 25] = "ammV4SwapBaseIn";
      InstructionType22[InstructionType22["ammV4SwapBaseOut"] = 26] = "ammV4SwapBaseOut";
      InstructionType22[InstructionType22["ammV4CreatePool"] = 27] = "ammV4CreatePool";
      InstructionType22[InstructionType22["ammV4InitPool"] = 28] = "ammV4InitPool";
      InstructionType22[InstructionType22["ammV4CreatePoolV2"] = 29] = "ammV4CreatePoolV2";
      InstructionType22[InstructionType22["ammV5AddLiquidity"] = 30] = "ammV5AddLiquidity";
      InstructionType22[InstructionType22["ammV5RemoveLiquidity"] = 31] = "ammV5RemoveLiquidity";
      InstructionType22[InstructionType22["ammV5SimulatePoolInfo"] = 32] = "ammV5SimulatePoolInfo";
      InstructionType22[InstructionType22["ammV5SwapBaseIn"] = 33] = "ammV5SwapBaseIn";
      InstructionType22[InstructionType22["ammV5SwapBaseOut"] = 34] = "ammV5SwapBaseOut";
      InstructionType22[InstructionType22["routeSwap"] = 35] = "routeSwap";
      InstructionType22[InstructionType22["routeSwap1"] = 36] = "routeSwap1";
      InstructionType22[InstructionType22["routeSwap2"] = 37] = "routeSwap2";
      InstructionType22[InstructionType22["farmV3Deposit"] = 38] = "farmV3Deposit";
      InstructionType22[InstructionType22["farmV3Withdraw"] = 39] = "farmV3Withdraw";
      InstructionType22[InstructionType22["farmV3CreateLedger"] = 40] = "farmV3CreateLedger";
      InstructionType22[InstructionType22["farmV5Deposit"] = 41] = "farmV5Deposit";
      InstructionType22[InstructionType22["farmV5Withdraw"] = 42] = "farmV5Withdraw";
      InstructionType22[InstructionType22["farmV5CreateLedger"] = 43] = "farmV5CreateLedger";
      InstructionType22[InstructionType22["farmV6Deposit"] = 44] = "farmV6Deposit";
      InstructionType22[InstructionType22["farmV6Withdraw"] = 45] = "farmV6Withdraw";
      InstructionType22[InstructionType22["farmV6Create"] = 46] = "farmV6Create";
      InstructionType22[InstructionType22["farmV6Restart"] = 47] = "farmV6Restart";
      InstructionType22[InstructionType22["farmV6CreatorAddReward"] = 48] = "farmV6CreatorAddReward";
      InstructionType22[InstructionType22["farmV6CreatorWithdraw"] = 49] = "farmV6CreatorWithdraw";
      InstructionType22[InstructionType22["test"] = 50] = "test";
      return InstructionType22;
    })(InstructionType2 || {});
    var Base = class {
      static _selectTokenAccount(params) {
        const { tokenAccounts, programId, mint, owner, config: config2 } = params;
        const { associatedOnly } = __spreadValues(__spreadValues({}, { associatedOnly: true }), config2);
        const _tokenAccounts = tokenAccounts.filter(({ accountInfo }) => accountInfo.mint.equals(mint)).sort((a, b) => a.accountInfo.amount.lt(b.accountInfo.amount) ? 1 : -1);
        const ata = Spl.getAssociatedTokenAccount({ mint, owner, programId });
        for (const tokenAccount of _tokenAccounts) {
          const { pubkey } = tokenAccount;
          if (associatedOnly) {
            if (ata.equals(pubkey))
              return pubkey;
          } else {
            return pubkey;
          }
        }
        return null;
      }
      static _handleTokenAccount(params) {
        return __async(this, null, function* () {
          const {
            connection,
            side,
            amount,
            programId,
            mint,
            tokenAccount,
            owner,
            payer = owner,
            frontInstructions,
            endInstructions,
            signers,
            bypassAssociatedCheck,
            frontInstructionsType,
            endInstructionsType,
            checkCreateATAOwner
          } = params;
          const ata = Spl.getAssociatedTokenAccount({ mint, owner, programId });
          if (Token3.WSOL.mint.equals(mint)) {
            const newTokenAccount = yield Spl.insertCreateWrappedNativeAccount({
              connection,
              owner,
              payer,
              instructions: frontInstructions,
              instructionsType: frontInstructionsType,
              signers,
              amount
            });
            if (endInstructions) {
              endInstructions.push(
                Spl.makeCloseAccountInstruction({
                  programId: import_spl_token3.TOKEN_PROGRAM_ID,
                  tokenAccount: newTokenAccount,
                  owner,
                  payer,
                  instructionsType: endInstructionsType != null ? endInstructionsType : []
                })
              );
            }
            return newTokenAccount;
          } else if (!tokenAccount || side === "out" && !ata.equals(tokenAccount) && !bypassAssociatedCheck) {
            const _createATAIns = Spl.makeCreateAssociatedTokenAccountInstruction({
              programId,
              mint,
              associatedAccount: ata,
              owner,
              payer,
              instructionsType: frontInstructionsType
            });
            if (checkCreateATAOwner) {
              const ataInfo = yield connection.getAccountInfo(ata);
              if (ataInfo === null) {
                frontInstructions.push(_createATAIns);
              } else if (ataInfo.owner.equals(import_spl_token3.TOKEN_PROGRAM_ID) && import_spl_token3.AccountLayout.decode(ataInfo.data).mint.equals(mint) && import_spl_token3.AccountLayout.decode(ataInfo.data).owner.equals(owner)) {
              } else {
                throw Error(`create ata check error -> mint: ${mint.toString()}, ata: ${ata.toString()}`);
              }
            } else {
              frontInstructions.push(_createATAIns);
            }
            return ata;
          }
          return tokenAccount;
        });
      }
      static _selectOrCreateTokenAccount(params) {
        return __async(this, null, function* () {
          var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j;
          const { mint, tokenAccounts, createInfo, associatedOnly, owner, checkCreateATAOwner, programId } = params;
          const ata = Spl.getAssociatedTokenAccount({ mint, owner, programId });
          const accounts = tokenAccounts.filter((i) => i.accountInfo.mint.equals(mint) && (!associatedOnly || i.pubkey.equals(ata))).sort((a, b) => a.accountInfo.amount.lt(b.accountInfo.amount) ? 1 : -1);
          if (createInfo === void 0 || accounts.length > 0) {
            return accounts.length > 0 ? accounts[0].pubkey : void 0;
          }
          if (associatedOnly) {
            const _createATAIns = Spl.makeCreateAssociatedTokenAccountInstruction({
              programId,
              mint,
              associatedAccount: ata,
              owner,
              payer: createInfo.payer,
              instructionsType: createInfo.frontInstructionsType
            });
            if (checkCreateATAOwner) {
              const ataInfo = yield createInfo.connection.getAccountInfo(ata);
              if (ataInfo === null) {
                createInfo.frontInstructions.push(_createATAIns);
              } else if (ataInfo.owner.equals(programId) && import_spl_token3.AccountLayout.decode(ataInfo.data).mint.equals(mint) && import_spl_token3.AccountLayout.decode(ataInfo.data).owner.equals(owner)) {
              } else {
                throw Error(`create ata check error -> mint: ${mint.toString()}, ata: ${ata.toString()}`);
              }
            } else {
              createInfo.frontInstructions.push(_createATAIns);
            }
            if (mint.equals(Token3.WSOL.mint) && createInfo.amount) {
              const newTokenAccount = yield Spl.insertCreateWrappedNativeAccount({
                connection: createInfo.connection,
                owner,
                payer: createInfo.payer,
                instructions: createInfo.frontInstructions,
                instructionsType: createInfo.frontInstructionsType,
                signers: createInfo.signers,
                amount: (_a = createInfo.amount) != null ? _a : 0
              });
              ((_b = createInfo.endInstructions) != null ? _b : []).push(
                Spl.makeCloseAccountInstruction({
                  programId: import_spl_token3.TOKEN_PROGRAM_ID,
                  tokenAccount: newTokenAccount,
                  owner,
                  payer: createInfo.payer,
                  instructionsType: (_c = createInfo.endInstructionsType) != null ? _c : []
                })
              );
              if (createInfo.amount) {
                createInfo.frontInstructions.push(
                  Spl.makeTransferInstruction({
                    programId: import_spl_token3.TOKEN_PROGRAM_ID,
                    source: newTokenAccount,
                    destination: ata,
                    owner,
                    amount: createInfo.amount,
                    instructionsType: createInfo.frontInstructionsType
                  })
                );
              }
            }
            ;
            ((_d = createInfo.endInstructions) != null ? _d : []).push(
              Spl.makeCloseAccountInstruction({
                programId,
                tokenAccount: ata,
                owner,
                payer: createInfo.payer,
                instructionsType: (_e = createInfo.endInstructionsType) != null ? _e : []
              })
            );
            return ata;
          } else {
            if (mint.equals(Token3.WSOL.mint)) {
              const newTokenAccount = yield Spl.insertCreateWrappedNativeAccount({
                connection: createInfo.connection,
                owner,
                payer: createInfo.payer,
                instructions: createInfo.frontInstructions,
                instructionsType: createInfo.frontInstructionsType,
                signers: createInfo.signers,
                amount: (_f = createInfo.amount) != null ? _f : 0
              });
              ((_g = createInfo.endInstructions) != null ? _g : []).push(
                Spl.makeCloseAccountInstruction({
                  programId: import_spl_token3.TOKEN_PROGRAM_ID,
                  tokenAccount: newTokenAccount,
                  owner,
                  payer: createInfo.payer,
                  instructionsType: (_h = createInfo.endInstructionsType) != null ? _h : []
                })
              );
              return newTokenAccount;
            } else {
              const newTokenAccount = generatePubKey2({ fromPublicKey: owner, programId });
              const balanceNeeded = yield createInfo.connection.getMinimumBalanceForRentExemption(import_spl_token3.AccountLayout.span);
              const createAccountIns = import_web311.SystemProgram.createAccountWithSeed({
                fromPubkey: owner,
                basePubkey: owner,
                seed: newTokenAccount.seed,
                newAccountPubkey: newTokenAccount.publicKey,
                lamports: balanceNeeded,
                space: import_spl_token3.AccountLayout.span,
                programId
              });
              const initAccountIns = Spl.createInitAccountInstruction(programId, mint, newTokenAccount.publicKey, owner);
              createInfo.frontInstructions.push(createAccountIns, initAccountIns);
              createInfo.frontInstructionsType.push(
                0,
                1
                /* initAccount */
              );
              ((_i = createInfo.endInstructions) != null ? _i : []).push(
                Spl.makeCloseAccountInstruction({
                  programId,
                  tokenAccount: newTokenAccount.publicKey,
                  owner,
                  payer: createInfo.payer,
                  instructionsType: (_j = createInfo.endInstructionsType) != null ? _j : []
                })
              );
              return newTokenAccount.publicKey;
            }
          }
        });
      }
    };
    function generatePubKey2({
      fromPublicKey,
      programId = import_spl_token3.TOKEN_PROGRAM_ID
    }) {
      const seed = import_web311.Keypair.generate().publicKey.toBase58().slice(0, 32);
      const publicKey22 = createWithSeed(fromPublicKey, seed, programId);
      return { publicKey: publicKey22, seed };
    }
    function createWithSeed(fromPublicKey, seed, programId) {
      const buffer = Buffer.concat([fromPublicKey.toBuffer(), Buffer.from(seed), programId.toBuffer()]);
      const publicKeyBytes = sha256(buffer);
      return new import_web311.PublicKey(publicKeyBytes);
    }
    var import_web312 = require("@solana/web3.js");
    var LOOKUP_TABLE_CACHE2 = {
      "2immgwYNHBbyVQKVGCEkgWpi53bLwWNRMB5G2nbgYV17": new import_web312.AddressLookupTableAccount({
        key: new import_web312.PublicKey("2immgwYNHBbyVQKVGCEkgWpi53bLwWNRMB5G2nbgYV17"),
        state: import_web312.AddressLookupTableAccount.deserialize(
          Buffer.from(
            "AQAAAP//////////d49+DAAAAAAAAQZMWvw7GUNJdaccNBVnb57OKakxL2BHLYvhRwVILRsgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMGRm/lIRcy/+ytunLDm+e8jOW7xfcSayxDmzpAAAAABt324ddloZPZy+FGzut5rBy0he1fWzeROoz1hX7/AKkG3fbh7nWP3hhCXbzkbM3athr8TYO5DSf+vfko2KGL/AVKU1D4XciC1hSlVnJ4iilt3x6rq9CmBniISTL07vagBqfVFxksXFEhjMlMPUrxf1ja7gibof1E49vZigAAAAAGp9UXGMd0yShWY5hpHV62i164o5tLbVxzVVshAAAAAIyXJY9OJInxuz0QKRSODYMLWhOZ2v8QhASOe9jb6fhZC3BlsePRfEU4nVJ/awTDzVi4bHMaoP21SbbRvAP4KUbIScv+6Yw2LHF/6K0ZjUPibbSWXCirYPGuuVl7zT789IUPLW4CpHr4JNCatp3ELXDLKMv6JJ+37le50lbBJ2LvDQdRqCgtphMF/imcN7mY5YRx2xE1A3MQ+L4QRaYK9u4GRfZP3LsAd00a+IkCpA22UNQMKdq5BFbJuwuOLqc8zxCTDlqxBG8J0HcxtfogQHDK06ukzfaXiNDKAob1MqBHS9lJxDYCwz8gd5DtFqNSTKG5l1zxIaKpDP/sffi2is1H9aKveyXSu5StXElYRl9SD5As0DHE4N0GLnf84/siiKXVyp4Ez121kLcUui/jLLFZEz/BwZK3Ilf9B9OcsEAeDMKAy2vjGSxQODgBz0QwGA+eP4ZjIjrIAQaXENv31QfLlOdXSRCkaybRniDHF4C8YcwhcvsqrOVuTP4B2Na+9wLdtrB31uz2rtlFI5kahdsnp/d1SrASDInYCtTYtdoke4kX+hoKWcEWM4Tle8pTUkUVv4BxS6fje/EzKBE4Qu9N9LMnrw/JNO0hqMVB4rk/2ou4AB1loQ7FZoPwut2o4KZB+0p9xnbrQKw038qjpHar+PyDwvxBRcu5hpHw3dguezeWv+IwvgW5icu8EGkhGa9AkFPPJT7VMSFb8xowveU=",
            "base64"
          )
        )
      })
    };
    var import_spl_token4 = require_cjs5();
    var import_web313 = require("@solana/web3.js");
    var import_bn8 = __toESM2(require_bn());
    function getWSOLAmount({ tokenAccounts }) {
      const WSOL_MINT = new import_web313.PublicKey(WSOL.mint);
      const amounts = tokenAccounts.filter((i) => i.accountInfo.mint.equals(WSOL_MINT)).map((i) => i.accountInfo.amount);
      const amount = amounts.reduce((a, b) => a.add(b), new import_bn8.default(0));
      return amount;
    }
    function unwarpSol(_0) {
      return __async(this, arguments, function* ({
        ownerInfo,
        tokenAccounts,
        makeTxVersion,
        connection
      }) {
        const WSOL_MINT = new import_web313.PublicKey(WSOL.mint);
        const instructionsInfo = tokenAccounts.filter((i) => i.accountInfo.mint.equals(WSOL_MINT)).map((i) => ({
          amount: i.accountInfo.amount,
          tx: Spl.makeCloseAccountInstruction({
            programId: import_spl_token2.TOKEN_PROGRAM_ID,
            tokenAccount: i.pubkey,
            owner: ownerInfo.wallet,
            payer: ownerInfo.payer,
            instructionsType: []
          })
        }));
        return {
          address: {},
          innerTransactions: yield splitTxAndSigners({
            connection,
            makeTxVersion,
            payer: ownerInfo.payer,
            innerTransaction: instructionsInfo.map((i) => ({
              instructionTypes: [
                3
                /* closeAccount */
              ],
              instructions: [i.tx],
              signers: []
            }))
          })
        };
      });
    }
    function buildSimpleTransaction(_0) {
      return __async(this, arguments, function* ({
        connection,
        makeTxVersion,
        payer,
        innerTransactions,
        recentBlockhash,
        addLookupTableInfo
      }) {
        var _a;
        if (makeTxVersion !== 0 && makeTxVersion !== 1)
          throw Error(" make tx version args error");
        const _recentBlockhash = recentBlockhash != null ? recentBlockhash : (yield connection.getLatestBlockhash()).blockhash;
        const txList = [];
        for (const itemIx of innerTransactions) {
          txList.push(
            _makeTransaction({
              makeTxVersion,
              instructions: itemIx.instructions,
              payer,
              recentBlockhash: _recentBlockhash,
              signers: itemIx.signers,
              lookupTableInfos: Object.values(__spreadValues(__spreadValues({}, addLookupTableInfo != null ? addLookupTableInfo : {}), (_a = itemIx.lookupTableAddress) != null ? _a : {}))
            })
          );
        }
        return txList;
      });
    }
    function buildTransaction(_0) {
      return __async(this, arguments, function* ({
        connection,
        makeTxVersion,
        payer,
        innerTransactions,
        recentBlockhash,
        lookupTableCache
      }) {
        var _a;
        if (makeTxVersion !== 0 && makeTxVersion !== 1)
          throw Error(" make tx version args error");
        const _recentBlockhash = recentBlockhash != null ? recentBlockhash : (yield connection.getLatestBlockhash()).blockhash;
        const _lookupTableCache = lookupTableCache != null ? lookupTableCache : {};
        const lta = [
          .../* @__PURE__ */ new Set([
            ...innerTransactions.map((i) => {
              var _a2;
              return (_a2 = i.lookupTableAddress) != null ? _a2 : [];
            }).flat().map((i) => i.toString())
          ])
        ];
        const needCacheLTA = [];
        for (const item of lta) {
          if (_lookupTableCache[item] === void 0) {
            needCacheLTA.push(new import_web313.PublicKey(item));
          }
        }
        const lookupTableAccountsCache = needCacheLTA.length > 0 ? yield getMultipleLookupTableInfo2({ connection, address: needCacheLTA }) : {};
        for (const [key, value] of Object.entries(lookupTableAccountsCache)) {
          _lookupTableCache[key] = value;
        }
        const txList = [];
        for (const itemIx of innerTransactions) {
          const _itemLTA = {};
          if (makeTxVersion === 0) {
            for (const item of (_a = itemIx.lookupTableAddress) != null ? _a : []) {
              _itemLTA[item.toString()] = _lookupTableCache[item.toString()];
            }
          }
          txList.push(
            _makeTransaction({
              makeTxVersion,
              instructions: itemIx.instructions,
              payer,
              recentBlockhash: _recentBlockhash,
              signers: itemIx.signers,
              lookupTableInfos: Object.values(_itemLTA)
            })
          );
        }
        return txList;
      });
    }
    function _makeTransaction({
      makeTxVersion,
      instructions,
      payer,
      recentBlockhash,
      signers,
      lookupTableInfos
    }) {
      if (makeTxVersion === 1) {
        const tx = new import_web313.Transaction();
        tx.add(...instructions);
        tx.feePayer = payer;
        tx.recentBlockhash = recentBlockhash;
        if (signers.length > 0)
          tx.sign(...signers);
        return tx;
      } else if (makeTxVersion === 0) {
        const transactionMessage = new import_web313.TransactionMessage({
          payerKey: payer,
          recentBlockhash,
          instructions
        });
        const itemV = new import_web313.VersionedTransaction(transactionMessage.compileToV0Message(lookupTableInfos));
        itemV.sign(signers);
        return itemV;
      } else {
        throw Error(" make tx version check error ");
      }
    }
    var POINT = 1e4;
    function getTransferAmountFee2(amount, feeConfig, epochInfo, addFee) {
      if (feeConfig === void 0) {
        return {
          amount,
          fee: void 0,
          expirationTime: void 0
        };
      }
      const nowFeeConfig = epochInfo.epoch < feeConfig.newerTransferFee.epoch ? feeConfig.olderTransferFee : feeConfig.newerTransferFee;
      const maxFee = new import_bn8.default(nowFeeConfig.maximumFee.toString());
      const expirationTime = epochInfo.epoch < feeConfig.newerTransferFee.epoch ? (Number(feeConfig.newerTransferFee.epoch) * epochInfo.slotsInEpoch - epochInfo.absoluteSlot) * 400 / 1e3 : void 0;
      if (addFee) {
        if (nowFeeConfig.transferFeeBasisPoints === POINT) {
          const nowMaxFee = new import_bn8.default(nowFeeConfig.maximumFee.toString());
          return {
            amount: amount.add(nowMaxFee),
            fee: nowMaxFee,
            expirationTime
          };
        } else {
          const _TAmount = BNDivCeil2(amount.mul(new import_bn8.default(POINT)), new import_bn8.default(POINT - nowFeeConfig.transferFeeBasisPoints));
          const nowMaxFee = new import_bn8.default(nowFeeConfig.maximumFee.toString());
          const TAmount = _TAmount.sub(amount).gt(nowMaxFee) ? amount.add(nowMaxFee) : _TAmount;
          const _fee = BNDivCeil2(TAmount.mul(new import_bn8.default(nowFeeConfig.transferFeeBasisPoints)), new import_bn8.default(POINT));
          const fee = _fee.gt(maxFee) ? maxFee : _fee;
          return {
            amount: TAmount,
            fee,
            expirationTime
          };
        }
      } else {
        const _fee = BNDivCeil2(amount.mul(new import_bn8.default(nowFeeConfig.transferFeeBasisPoints)), new import_bn8.default(POINT));
        const fee = _fee.gt(maxFee) ? maxFee : _fee;
        return {
          amount,
          fee,
          expirationTime
        };
      }
    }
    function minExpirationTime2(expirationTime1, expirationTime2) {
      if (expirationTime1 === void 0)
        return expirationTime2;
      if (expirationTime2 === void 0)
        return expirationTime1;
      return Math.min(expirationTime1, expirationTime2);
    }
    function fetchMultipleMintInfos2(_0) {
      return __async(this, arguments, function* ({ connection, mints }) {
        var _a, _b;
        if (mints.length === 0)
          return {};
        const mintInfos = yield getMultipleAccountsInfoWithCustomFlags2(
          connection,
          mints.map((i) => ({ pubkey: i }))
        );
        const mintK = {};
        for (const i of mintInfos) {
          const t = (0, import_spl_token4.unpackMint)(i.pubkey, i.accountInfo, (_a = i.accountInfo) == null ? void 0 : _a.owner);
          mintK[i.pubkey.toString()] = __spreadProps(__spreadValues({}, t), {
            feeConfig: (_b = (0, import_spl_token4.getTransferFeeConfig)(t)) != null ? _b : void 0
          });
        }
        return mintK;
      });
    }
    function BNDivCeil2(bn1, bn2) {
      const { div: div3, mod: mod2 } = bn1.divmod(bn2);
      if (mod2.gt(ZERO2)) {
        return div3.add(ONE2);
      } else {
        return div3;
      }
    }
    var import_web315 = require("@solana/web3.js");
    var import_bn9 = __toESM2(require_bn());
    var import_web314 = require("@solana/web3.js");
    var anchorDataBuf2 = {
      voterStakeRegistryCreateVoter: Buffer.from([6, 24, 245, 52, 243, 255, 148, 25]),
      // CreateVoter
      voterStakeRegistryCreateDepositEntry: Buffer.from([185, 131, 167, 186, 159, 125, 19, 67]),
      // CreateDepositEntry
      voterStakeRegistryDeposit: Buffer.from([242, 35, 198, 137, 82, 225, 242, 182]),
      // Deposit
      voterStakeRegistryWithdraw: Buffer.from([183, 18, 70, 156, 148, 109, 161, 34]),
      // Withdraw
      voterStakeRegistryUpdateVoterWeightRecord: Buffer.from([45, 185, 3, 36, 109, 190, 115, 169])
      // UpdateVoterWeightRecord
    };
    function governanceCreateTokenOwnerRecord2(programId, realm, governingTokenOwner, governingTokenMint, payer, tokenOwnerRecordAddress) {
      const dataLayout = struct3([u822("ins")]);
      const keys = [
        AccountMetaReadonly(realm, false),
        AccountMetaReadonly(governingTokenOwner, false),
        AccountMeta(tokenOwnerRecordAddress, false),
        AccountMetaReadonly(governingTokenMint, false),
        AccountMeta(payer, true),
        AccountMetaReadonly(SYSTEM_PROGRAM_ID2, false)
      ];
      const data = Buffer.alloc(dataLayout.span);
      dataLayout.encode({ ins: 23 }, data);
      return new import_web314.TransactionInstruction({
        keys,
        programId,
        data
      });
    }
    function voterStakeRegistryCreateVoter2(programId, registrar, voter, voterWeightRecord, voterAuthority, payer, voterBump, voterWeightRecordBump) {
      const dataLayout = struct3([u822("voterBump"), u822("voterWeightRecordBump")]);
      const keys = [
        AccountMetaReadonly(registrar, false),
        AccountMeta(voter, false),
        AccountMetaReadonly(voterAuthority, true),
        AccountMeta(voterWeightRecord, false),
        AccountMeta(payer, true),
        AccountMetaReadonly(SYSTEM_PROGRAM_ID2, false),
        AccountMetaReadonly(RENT_PROGRAM_ID2, false),
        AccountMetaReadonly(INSTRUCTION_PROGRAM_ID2, false)
      ];
      const data = Buffer.alloc(dataLayout.span);
      dataLayout.encode({ voterBump, voterWeightRecordBump }, data);
      const aData = Buffer.from([...anchorDataBuf2.voterStakeRegistryCreateVoter, ...data]);
      return new import_web314.TransactionInstruction({
        keys,
        programId,
        data: aData
      });
    }
    function voterStakeRegistryCreateDepositEntry2(programId, registrar, voter, voterVault, voterAuthority, payer, depositMint, depositEntryIndex, kind, startTs, periods, allowClawback) {
      const dataLayout = struct3([
        u822("depositEntryIndex"),
        u822("kind"),
        u822("option"),
        u643("startTs"),
        u3222("periods"),
        bool22("allowClawback")
      ]);
      const keys = [
        AccountMetaReadonly(registrar, false),
        AccountMeta(voter, false),
        AccountMeta(voterVault, false),
        AccountMetaReadonly(voterAuthority, true),
        AccountMeta(payer, true),
        AccountMetaReadonly(depositMint, false),
        AccountMetaReadonly(SYSTEM_PROGRAM_ID2, false),
        AccountMetaReadonly(import_spl_token2.TOKEN_PROGRAM_ID, false),
        AccountMetaReadonly(import_spl_token2.ASSOCIATED_TOKEN_PROGRAM_ID, false),
        AccountMetaReadonly(RENT_PROGRAM_ID2, false)
      ];
      const data = Buffer.alloc(dataLayout.span);
      dataLayout.encode(
        {
          depositEntryIndex,
          kind,
          option: startTs === void 0 ? 0 : 1,
          startTs: startTs != null ? startTs : ZERO2,
          periods,
          allowClawback
        },
        data
      );
      const aData = Buffer.from([...anchorDataBuf2.voterStakeRegistryCreateDepositEntry, ...data]);
      return new import_web314.TransactionInstruction({
        keys,
        programId,
        data: aData
      });
    }
    function voterStakeRegistryDeposit2(programId, registrar, voter, voterVault, depositToken, depositAuthority, userStakerInfoV2, pool, votingMint, votingMintAuthority, stakeProgramId, depositEntryIndex, amount) {
      const dataLayout = struct3([u822("depositEntryIndex"), u643("amount")]);
      const keys = [
        AccountMetaReadonly(registrar, false),
        AccountMeta(voter, false),
        AccountMeta(voterVault, false),
        AccountMeta(depositToken, false),
        AccountMetaReadonly(depositAuthority, true),
        AccountMetaReadonly(import_spl_token2.TOKEN_PROGRAM_ID, false),
        AccountMeta(userStakerInfoV2, false),
        AccountMetaReadonly(pool, false),
        AccountMeta(votingMint, false),
        AccountMetaReadonly(votingMintAuthority, false),
        AccountMetaReadonly(stakeProgramId, false),
        AccountMetaReadonly(INSTRUCTION_PROGRAM_ID2, false)
      ];
      const data = Buffer.alloc(dataLayout.span);
      dataLayout.encode(
        {
          depositEntryIndex,
          amount
        },
        data
      );
      const aData = Buffer.from([...anchorDataBuf2.voterStakeRegistryDeposit, ...data]);
      return new import_web314.TransactionInstruction({
        keys,
        programId,
        data: aData
      });
    }
    function voterStakeRegistryUpdateVoterWeightRecord2(programId, registrar, voter, voterWeightRecord) {
      const dataLayout = struct3([]);
      const keys = [
        AccountMetaReadonly(registrar, false),
        AccountMetaReadonly(voter, false),
        AccountMeta(voterWeightRecord, false),
        AccountMetaReadonly(SYSTEM_PROGRAM_ID2, false)
      ];
      const data = Buffer.alloc(dataLayout.span);
      dataLayout.encode({}, data);
      const aData = Buffer.from([...anchorDataBuf2.voterStakeRegistryUpdateVoterWeightRecord, ...data]);
      return new import_web314.TransactionInstruction({
        keys,
        programId,
        data: aData
      });
    }
    function voterStakeRegistryWithdraw2(programId, registrar, voter, voterAuthority, tokenOwnerRecord, voterWeightRecord, vault, destination, userStakerInfoV2, pool, votingMint, votingMintAuthority, stakeProgramId, depositEntryIndex, amount) {
      const dataLayout = struct3([u822("depositEntryIndex"), u643("amount")]);
      const keys = [
        AccountMetaReadonly(registrar, false),
        AccountMeta(voter, false),
        AccountMetaReadonly(voterAuthority, true),
        AccountMetaReadonly(tokenOwnerRecord, false),
        AccountMeta(voterWeightRecord, false),
        AccountMeta(vault, false),
        AccountMeta(destination, false),
        AccountMetaReadonly(import_spl_token2.TOKEN_PROGRAM_ID, false),
        AccountMeta(userStakerInfoV2, false),
        AccountMetaReadonly(pool, false),
        AccountMeta(votingMint, false),
        AccountMetaReadonly(votingMintAuthority, false),
        AccountMetaReadonly(stakeProgramId, false),
        AccountMetaReadonly(INSTRUCTION_PROGRAM_ID2, false)
      ];
      const data = Buffer.alloc(dataLayout.span);
      dataLayout.encode(
        {
          depositEntryIndex,
          amount
        },
        data
      );
      const aData = Buffer.from([...anchorDataBuf2.voterStakeRegistryWithdraw, ...data]);
      return new import_web314.TransactionInstruction({
        keys,
        programId,
        data: aData
      });
    }
    var REAL_FARM_STATE_LAYOUT_V3 = struct3([
      u643("state"),
      u643("nonce"),
      publicKey3("lpVault"),
      publicKey3("rewardVault"),
      publicKey3(),
      publicKey3(),
      u643(),
      u643(),
      u643("totalReward"),
      u1283("perShareReward"),
      u643("lastSlot"),
      u643("perSlotReward")
    ]);
    var REAL_FARM_STATE_LAYOUT_V5 = struct3([
      u643("state"),
      u643("nonce"),
      publicKey3("lpVault"),
      publicKey3("rewardVaultA"),
      u643("totalRewardA"),
      u1283("perShareRewardA"),
      u643("perSlotRewardA"),
      u822("option"),
      publicKey3("rewardVaultB"),
      blob4(7),
      u643("totalRewardB"),
      u1283("perShareRewardB"),
      u643("perSlotRewardB"),
      u643("lastSlot"),
      publicKey3()
    ]);
    var FARM_STATE_LAYOUT_V6_REWARD_INFO = struct3([
      u643("rewardState"),
      u643("rewardOpenTime"),
      u643("rewardEndTime"),
      u643("rewardLastUpdateTime"),
      u643("totalReward"),
      u643("totalRewardEmissioned"),
      u643("rewardClaimed"),
      u643("rewardPerSecond"),
      u1283("accRewardPerShare"),
      publicKey3("rewardVault"),
      publicKey3("rewardMint"),
      publicKey3("rewardSender"),
      u643("rewardType"),
      seq22(u643(), 15, "padding")
    ]);
    var REAL_FARM_STATE_LAYOUT_V6 = struct3([
      u643(),
      u643("state"),
      u643("nonce"),
      u643("validRewardTokenNum"),
      u1283("rewardMultiplier"),
      u643("rewardPeriodMax"),
      u643("rewardPeriodMin"),
      u643("rewardPeriodExtend"),
      publicKey3("lpMint"),
      publicKey3("lpVault"),
      seq22(FARM_STATE_LAYOUT_V6_REWARD_INFO, 5, "rewardInfos"),
      publicKey3("creator"),
      publicKey3(),
      seq22(u643(), 32, "padding")
    ]);
    var FARM_STATE_LAYOUT_V3 = new Proxy(
      REAL_FARM_STATE_LAYOUT_V3,
      {
        get(target, p, receiver) {
          if (p === "decode")
            return (...decodeParams) => {
              const originalResult = target.decode(...decodeParams);
              return __spreadProps(__spreadValues({}, originalResult), {
                version: 3,
                rewardInfos: [
                  {
                    rewardVault: originalResult.rewardVault,
                    totalReward: originalResult.totalReward,
                    perSlotReward: originalResult.perSlotReward,
                    perShareReward: originalResult.perShareReward
                  }
                ]
              });
            };
          else
            return Reflect.get(target, p, receiver);
        }
      }
    );
    var FARM_STATE_LAYOUT_V5 = new Proxy(
      REAL_FARM_STATE_LAYOUT_V5,
      {
        get(target, p, receiver) {
          if (p === "decode")
            return (...decodeParams) => {
              const originalResult = target.decode(...decodeParams);
              return __spreadProps(__spreadValues({}, originalResult), {
                version: 5,
                rewardInfos: [
                  {
                    rewardVault: originalResult.rewardVaultA,
                    totalReward: originalResult.totalRewardA,
                    perSlotReward: originalResult.perSlotRewardA,
                    perShareReward: originalResult.perShareRewardA
                  },
                  {
                    rewardVault: originalResult.rewardVaultB,
                    totalReward: originalResult.totalRewardB,
                    perSlotReward: originalResult.perSlotRewardB,
                    perShareReward: originalResult.perShareRewardB
                  }
                ]
              });
            };
          else
            return Reflect.get(target, p, receiver);
        }
      }
    );
    var FARM_STATE_LAYOUT_V6 = new Proxy(
      REAL_FARM_STATE_LAYOUT_V6,
      {
        get(target, p, receiver) {
          if (p === "decode")
            return (...decodeParams) => {
              const originalResult = target.decode(...decodeParams);
              return __spreadProps(__spreadValues({}, originalResult), {
                version: 6,
                rewardInfos: originalResult.rewardInfos.map((item) => {
                  var _a;
                  return __spreadProps(__spreadValues({}, item), {
                    rewardType: ((_a = Object.entries(poolTypeV62).find((i) => String(i[1]) === item.rewardType.toString())) != null ? _a : [
                      "Standard SPL"
                    ])[0]
                  });
                })
              });
            };
          else
            return Reflect.get(target, p, receiver);
        }
      }
    );
    var FARM_LEDGER_LAYOUT_V3_1 = struct3([
      u643("state"),
      publicKey3("id"),
      publicKey3("owner"),
      u643("deposited"),
      seq22(u643(), 1, "rewardDebts")
    ]);
    var FARM_LEDGER_LAYOUT_V3_2 = struct3([
      u643("state"),
      publicKey3("id"),
      publicKey3("owner"),
      u643("deposited"),
      seq22(u1283(), 1, "rewardDebts"),
      u643(""),
      u643("voteLockedBalance"),
      seq22(u643(), 15)
    ]);
    var FARM_LEDGER_LAYOUT_V5_1 = struct3([
      u643("state"),
      publicKey3("id"),
      publicKey3("owner"),
      u643("deposited"),
      seq22(u643(), 2, "rewardDebts")
    ]);
    var FARM_LEDGER_LAYOUT_V5_2 = struct3([
      u643("state"),
      publicKey3("id"),
      publicKey3("owner"),
      u643("deposited"),
      seq22(u1283(), 2, "rewardDebts"),
      seq22(u643(), 17)
    ]);
    var FARM_LEDGER_LAYOUT_V6_1 = struct3([
      u643(),
      u643("state"),
      publicKey3("id"),
      publicKey3("owner"),
      u643("deposited"),
      seq22(u1283(), 5, "rewardDebts"),
      seq22(u643(), 16)
    ]);
    var FARM_VERSION_TO_STATE_LAYOUT2 = {
      3: FARM_STATE_LAYOUT_V3,
      5: FARM_STATE_LAYOUT_V5,
      6: FARM_STATE_LAYOUT_V6
    };
    var FARM_VERSION_TO_LEDGER_LAYOUT2 = {
      3: FARM_LEDGER_LAYOUT_V3_2,
      5: FARM_LEDGER_LAYOUT_V5_2,
      6: FARM_LEDGER_LAYOUT_V6_1
    };
    var VoterVotingMintConfig2 = struct3([
      publicKey3("mint"),
      publicKey3("grantAuthority"),
      u643("baselineVoteWeightScaledFactor"),
      u643("maxExtraLockupVoteWeightScaledFactor"),
      u643("lockupSaturationSecs"),
      i82("digitShift"),
      // TODO
      seq22(u822(), 7, "reserved1"),
      seq22(u643(), 7, "reserved2")
    ]);
    var VoterRegistrar2 = struct3([
      blob4(8),
      publicKey3("governanceProgramId"),
      publicKey3("realm"),
      publicKey3("realmGoverningTokenMint"),
      publicKey3("realmAuthority"),
      seq22(u822(), 32, "reserved1"),
      seq22(VoterVotingMintConfig2, 4, "votingMints"),
      i642("timeOffset"),
      u822("bump"),
      seq22(u822(), 7, "reserved2"),
      seq22(u643(), 11, "reserved3")
    ]);
    var VoterLockup2 = struct3([i642("startTime"), i642("endTime"), u822("kind"), seq22(u822(), 15, "reserved")]);
    var VoterDepositEntry2 = struct3([
      seq22(VoterLockup2, 1, "lockup"),
      u643("amountDeposited_native"),
      u643("amountInitiallyLockedNative"),
      bool22("isUsed"),
      bool22("allowClawback"),
      u822("votingMintConfigIdx"),
      seq22(u822(), 29, "reserved")
    ]);
    var Voter2 = struct3([
      blob4(8),
      publicKey3("voterAuthority"),
      publicKey3("registrar"),
      seq22(VoterDepositEntry2, 32, "deposits"),
      u822("voterBump"),
      u822("voterWweightRecordBump"),
      seq22(u822(), 94, "reserved")
    ]);
    function getRegistrarAddress2(programId, realm, communityTokenMint) {
      return findProgramAddress2(
        [realm.toBuffer(), Buffer.from("registrar", "utf8"), communityTokenMint.toBuffer()],
        programId
      );
    }
    function getVotingTokenMint2(programId, poolId) {
      return findProgramAddress2([poolId.toBuffer(), Buffer.from("voting_mint_seed", "utf8")], programId);
    }
    function getVotingMintAuthority2(programId, poolId) {
      return findProgramAddress2([poolId.toBuffer()], programId);
    }
    function getVoterAddress2(programId, registrar, authority) {
      return findProgramAddress2([registrar.toBuffer(), Buffer.from("voter", "utf8"), authority.toBuffer()], programId);
    }
    function getVoterWeightRecordAddress2(programId, registrar, authority) {
      return findProgramAddress2(
        [registrar.toBuffer(), Buffer.from("voter-weight-record", "utf8"), authority.toBuffer()],
        programId
      );
    }
    function getTokenOwnerRecordAddress2(programId, realm, governingTokenMint, governingTokenOwner) {
      return findProgramAddress2(
        [
          Buffer.from("governance", "utf8"),
          realm.toBuffer(),
          governingTokenMint.toBuffer(),
          governingTokenOwner.toBuffer()
        ],
        programId
      );
    }
    var logger8 = Logger2.from("Farm");
    var poolTypeV62 = { "Standard SPL": 0, "Option tokens": 1 };
    var Farm = class _Farm extends Base {
      /* ================= get layout ================= */
      static getStateLayout(version2) {
        const STATE_LAYOUT = FARM_VERSION_TO_STATE_LAYOUT2[version2];
        logger8.assertArgument(!!STATE_LAYOUT, "invalid version", "version", version2);
        return STATE_LAYOUT;
      }
      static getLedgerLayout(version2) {
        const LEDGER_LAYOUT = FARM_VERSION_TO_LEDGER_LAYOUT2[version2];
        logger8.assertArgument(!!LEDGER_LAYOUT, "invalid version", "version", version2);
        return LEDGER_LAYOUT;
      }
      static getLayouts(version2) {
        return { state: this.getStateLayout(version2), ledger: this.getLedgerLayout(version2) };
      }
      /* ================= get key ================= */
      static getAssociatedAuthority({ programId, poolId }) {
        return findProgramAddress2([poolId.toBuffer()], programId);
      }
      static getAssociatedLedgerAccount({
        programId,
        poolId,
        owner,
        version: version2
      }) {
        const { publicKey: publicKey22 } = findProgramAddress2(
          [
            poolId.toBuffer(),
            owner.toBuffer(),
            Buffer.from(version2 === 6 ? "farmer_info_associated_seed" : "staker_info_v2_associated_seed", "utf-8")
          ],
          programId
        );
        return publicKey22;
      }
      static getAssociatedLedgerPoolAccount({
        programId,
        poolId,
        mint,
        type
      }) {
        const { publicKey: publicKey22 } = findProgramAddress2(
          [
            poolId.toBuffer(),
            mint.toBuffer(),
            Buffer.from(
              type === "lpVault" ? "lp_vault_associated_seed" : type === "rewardVault" ? "reward_vault_associated_seed" : "",
              "utf-8"
            )
          ],
          programId
        );
        return publicKey22;
      }
      /* ================= make instruction and transaction ================= */
      static makeDepositInstruction(params) {
        const { poolKeys } = params;
        const { version: version2 } = poolKeys;
        if (version2 === 3) {
          return this.makeDepositInstructionV3(params);
        } else if (version2 === 5) {
          return this.makeDepositInstructionV5(params);
        } else if (version2 === 6) {
          return this.makeDepositInstructionV6(params);
        }
        return logger8.throwArgumentError("invalid version", "poolKeys.version", version2);
      }
      static makeDepositInstructionV3({ poolKeys, userKeys, amount }) {
        logger8.assertArgument(
          poolKeys.rewardInfos.length === 1,
          "lengths not equal 1",
          "poolKeys.rewardInfos",
          poolKeys.rewardInfos
        );
        logger8.assertArgument(
          userKeys.rewardTokenAccounts.length === 1,
          "lengths not equal 1",
          "userKeys.rewardTokenAccounts",
          userKeys.rewardTokenAccounts
        );
        const LAYOUT = struct3([u822("instruction"), u643("amount")]);
        const data = Buffer.alloc(LAYOUT.span);
        LAYOUT.encode(
          {
            instruction: 10,
            amount: parseBigNumberish2(amount)
          },
          data
        );
        const keys = [
          AccountMeta(poolKeys.id, false),
          AccountMetaReadonly(poolKeys.authority, false),
          AccountMeta(userKeys.ledger, false),
          AccountMetaReadonly(userKeys.owner, true),
          AccountMeta(userKeys.lpTokenAccount, false),
          AccountMeta(poolKeys.lpVault, false),
          AccountMeta(userKeys.rewardTokenAccounts[0], false),
          AccountMeta(poolKeys.rewardInfos[0].rewardVault, false),
          // system
          AccountMetaReadonly(import_web332.SYSVAR_CLOCK_PUBKEY, false),
          AccountMetaReadonly(import_spl_token2.TOKEN_PROGRAM_ID, false)
        ];
        if (userKeys.auxiliaryLedgers) {
          for (const auxiliaryLedger of userKeys.auxiliaryLedgers) {
            keys.push(AccountMeta(auxiliaryLedger, false));
          }
        }
        return {
          address: {},
          innerTransaction: {
            instructions: [
              new import_web315.TransactionInstruction({
                programId: poolKeys.programId,
                keys,
                data
              })
            ],
            signers: [],
            lookupTableAddress: [],
            instructionTypes: [
              38
              /* farmV3Deposit */
            ]
          }
        };
      }
      static makeDepositInstructionV5({ poolKeys, userKeys, amount }) {
        logger8.assertArgument(
          userKeys.rewardTokenAccounts.length === poolKeys.rewardInfos.length,
          "lengths not equal with poolKeys.rewardInfos",
          "userKeys.rewardTokenAccounts",
          userKeys.rewardTokenAccounts
        );
        const LAYOUT = struct3([u822("instruction"), u643("amount")]);
        const data = Buffer.alloc(LAYOUT.span);
        LAYOUT.encode(
          {
            instruction: 11,
            amount: parseBigNumberish2(amount)
          },
          data
        );
        const keys = [
          AccountMeta(poolKeys.id, false),
          AccountMetaReadonly(poolKeys.authority, false),
          AccountMeta(userKeys.ledger, false),
          AccountMetaReadonly(userKeys.owner, true),
          AccountMeta(userKeys.lpTokenAccount, false),
          AccountMeta(poolKeys.lpVault, false),
          AccountMeta(userKeys.rewardTokenAccounts[0], false),
          AccountMeta(poolKeys.rewardInfos[0].rewardVault, false),
          // system
          AccountMetaReadonly(import_web332.SYSVAR_CLOCK_PUBKEY, false),
          AccountMetaReadonly(import_spl_token2.TOKEN_PROGRAM_ID, false)
        ];
        for (let index = 1; index < poolKeys.rewardInfos.length; index++) {
          keys.push(AccountMeta(userKeys.rewardTokenAccounts[index], false));
          keys.push(AccountMeta(poolKeys.rewardInfos[index].rewardVault, false));
        }
        if (userKeys.auxiliaryLedgers) {
          for (const auxiliaryLedger of userKeys.auxiliaryLedgers) {
            keys.push(AccountMeta(auxiliaryLedger, false));
          }
        }
        return {
          address: {},
          innerTransaction: {
            instructions: [
              new import_web315.TransactionInstruction({
                programId: poolKeys.programId,
                keys,
                data
              })
            ],
            signers: [],
            lookupTableAddress: [],
            instructionTypes: [
              41
              /* farmV5Deposit */
            ]
          }
        };
      }
      static makeDepositInstructionV6({ poolKeys, userKeys, amount }) {
        logger8.assertArgument(
          userKeys.rewardTokenAccounts.length !== 0,
          "lengths equal zero",
          "userKeys.rewardTokenAccounts",
          userKeys.rewardTokenAccounts
        );
        logger8.assertArgument(
          userKeys.rewardTokenAccounts.length === poolKeys.rewardInfos.length,
          "lengths not equal with poolKeys.rewardInfos",
          "userKeys.rewardTokenAccounts",
          userKeys.rewardTokenAccounts
        );
        const LAYOUT = struct3([u822("instruction"), u643("amount")]);
        const data = Buffer.alloc(LAYOUT.span);
        LAYOUT.encode(
          {
            instruction: 1,
            amount: parseBigNumberish2(amount)
          },
          data
        );
        const keys = [
          AccountMetaReadonly(import_spl_token2.TOKEN_PROGRAM_ID, false),
          AccountMetaReadonly(SYSTEM_PROGRAM_ID2, false),
          AccountMeta(poolKeys.id, false),
          AccountMetaReadonly(poolKeys.authority, false),
          AccountMeta(poolKeys.lpVault, false),
          AccountMeta(userKeys.ledger, false),
          AccountMetaReadonly(userKeys.owner, true),
          AccountMeta(userKeys.lpTokenAccount, false)
        ];
        for (let index = 0; index < poolKeys.rewardInfos.length; index++) {
          keys.push(AccountMeta(poolKeys.rewardInfos[index].rewardVault, false));
          keys.push(AccountMeta(userKeys.rewardTokenAccounts[index], false));
        }
        return {
          address: {},
          innerTransaction: {
            instructions: [
              new import_web315.TransactionInstruction({
                programId: poolKeys.programId,
                keys,
                data
              })
            ],
            signers: [],
            lookupTableAddress: [],
            instructionTypes: [
              44
              /* farmV6Deposit */
            ]
          }
        };
      }
      static makeWithdrawInstruction(params) {
        const { poolKeys } = params;
        const { version: version2 } = poolKeys;
        if (version2 === 3) {
          return this.makeWithdrawInstructionV3(params);
        } else if (version2 === 5) {
          return this.makeWithdrawInstructionV5(params);
        } else if (version2 === 6) {
          return this.makeWithdrawInstructionV6(params);
        }
        return logger8.throwArgumentError("invalid version", "poolKeys.version", version2);
      }
      static makeWithdrawInstructionV3({ poolKeys, userKeys, amount }) {
        logger8.assertArgument(
          poolKeys.rewardInfos.length === 1,
          "lengths not equal 1",
          "poolKeys.rewardInfos",
          poolKeys.rewardInfos
        );
        logger8.assertArgument(
          userKeys.rewardTokenAccounts.length === 1,
          "lengths not equal 1",
          "userKeys.rewardTokenAccounts",
          userKeys.rewardTokenAccounts
        );
        const LAYOUT = struct3([u822("instruction"), u643("amount")]);
        const data = Buffer.alloc(LAYOUT.span);
        LAYOUT.encode(
          {
            instruction: 11,
            amount: parseBigNumberish2(amount)
          },
          data
        );
        const keys = [
          AccountMeta(poolKeys.id, false),
          AccountMetaReadonly(poolKeys.authority, false),
          AccountMeta(userKeys.ledger, false),
          AccountMetaReadonly(userKeys.owner, true),
          AccountMeta(userKeys.lpTokenAccount, false),
          AccountMeta(poolKeys.lpVault, false),
          AccountMeta(userKeys.rewardTokenAccounts[0], false),
          AccountMeta(poolKeys.rewardInfos[0].rewardVault, false),
          // system
          AccountMetaReadonly(import_web332.SYSVAR_CLOCK_PUBKEY, false),
          AccountMetaReadonly(import_spl_token2.TOKEN_PROGRAM_ID, false)
        ];
        if (userKeys.auxiliaryLedgers) {
          for (const auxiliaryLedger of userKeys.auxiliaryLedgers) {
            keys.push(AccountMeta(auxiliaryLedger, false));
          }
        }
        return {
          address: {},
          innerTransaction: {
            instructions: [
              new import_web315.TransactionInstruction({
                programId: poolKeys.programId,
                keys,
                data
              })
            ],
            signers: [],
            lookupTableAddress: [],
            instructionTypes: [
              41
              /* farmV5Deposit */
            ]
          }
        };
      }
      static makeWithdrawInstructionV5({ poolKeys, userKeys, amount }) {
        logger8.assertArgument(
          userKeys.rewardTokenAccounts.length === poolKeys.rewardInfos.length,
          "lengths not equal with params.poolKeys.rewardInfos",
          "userKeys.rewardTokenAccounts",
          userKeys.rewardTokenAccounts
        );
        const LAYOUT = struct3([u822("instruction"), u643("amount")]);
        const data = Buffer.alloc(LAYOUT.span);
        LAYOUT.encode(
          {
            instruction: 12,
            amount: parseBigNumberish2(amount)
          },
          data
        );
        const keys = [
          AccountMeta(poolKeys.id, false),
          AccountMetaReadonly(poolKeys.authority, false),
          AccountMeta(userKeys.ledger, false),
          AccountMetaReadonly(userKeys.owner, true),
          AccountMeta(userKeys.lpTokenAccount, false),
          AccountMeta(poolKeys.lpVault, false),
          AccountMeta(userKeys.rewardTokenAccounts[0], false),
          AccountMeta(poolKeys.rewardInfos[0].rewardVault, false),
          // system
          AccountMetaReadonly(import_web332.SYSVAR_CLOCK_PUBKEY, false),
          AccountMetaReadonly(import_spl_token2.TOKEN_PROGRAM_ID, false)
        ];
        for (let index = 1; index < poolKeys.rewardInfos.length; index++) {
          keys.push(AccountMeta(userKeys.rewardTokenAccounts[index], false));
          keys.push(AccountMeta(poolKeys.rewardInfos[index].rewardVault, false));
        }
        if (userKeys.auxiliaryLedgers) {
          for (const auxiliaryLedger of userKeys.auxiliaryLedgers) {
            keys.push(AccountMeta(auxiliaryLedger, false));
          }
        }
        return {
          address: {},
          innerTransaction: {
            instructions: [
              new import_web315.TransactionInstruction({
                programId: poolKeys.programId,
                keys,
                data
              })
            ],
            signers: [],
            lookupTableAddress: [],
            instructionTypes: [
              42
              /* farmV5Withdraw */
            ]
          }
        };
      }
      static makeWithdrawInstructionV6({ poolKeys, userKeys, amount }) {
        logger8.assertArgument(
          userKeys.rewardTokenAccounts.length !== 0,
          "lengths equal zero",
          "userKeys.rewardTokenAccounts",
          userKeys.rewardTokenAccounts
        );
        logger8.assertArgument(
          userKeys.rewardTokenAccounts.length === poolKeys.rewardInfos.length,
          "lengths not equal with params.poolKeys.rewardInfos",
          "userKeys.rewardTokenAccounts",
          userKeys.rewardTokenAccounts
        );
        const LAYOUT = struct3([u822("instruction"), u643("amount")]);
        const data = Buffer.alloc(LAYOUT.span);
        LAYOUT.encode(
          {
            instruction: 2,
            amount: parseBigNumberish2(amount)
          },
          data
        );
        const keys = [
          AccountMetaReadonly(import_spl_token2.TOKEN_PROGRAM_ID, false),
          AccountMeta(poolKeys.id, false),
          AccountMetaReadonly(poolKeys.authority, false),
          AccountMeta(poolKeys.lpVault, false),
          AccountMeta(userKeys.ledger, false),
          AccountMetaReadonly(userKeys.owner, true),
          AccountMeta(userKeys.lpTokenAccount, false)
        ];
        for (let index = 0; index < poolKeys.rewardInfos.length; index++) {
          keys.push(AccountMeta(poolKeys.rewardInfos[index].rewardVault, false));
          keys.push(AccountMeta(userKeys.rewardTokenAccounts[index], false));
        }
        return {
          address: {},
          innerTransaction: {
            instructions: [
              new import_web315.TransactionInstruction({
                programId: poolKeys.programId,
                keys,
                data
              })
            ],
            signers: [],
            lookupTableAddress: [],
            instructionTypes: [
              45
              /* farmV6Withdraw */
            ]
          }
        };
      }
      static makeCreateAssociatedLedgerAccountInstruction(params) {
        const { poolKeys } = params;
        const { version: version2 } = poolKeys;
        if (version2 === 3) {
          return this.makeCreateAssociatedLedgerAccountInstructionV3(params);
        } else if (version2 === 5) {
          return this.makeCreateAssociatedLedgerAccountInstructionV5(params);
        }
        return logger8.throwArgumentError("invalid version", "poolKeys.version", version2);
      }
      static makeCreateAssociatedLedgerAccountInstructionV3({
        poolKeys,
        userKeys
      }) {
        const LAYOUT = struct3([u822("instruction")]);
        const data = Buffer.alloc(LAYOUT.span);
        LAYOUT.encode(
          {
            instruction: 9
          },
          data
        );
        const keys = [
          AccountMeta(poolKeys.id, false),
          AccountMeta(userKeys.ledger, false),
          AccountMetaReadonly(userKeys.owner, true),
          // system
          AccountMetaReadonly(SYSTEM_PROGRAM_ID2, false),
          AccountMetaReadonly(import_web332.SYSVAR_RENT_PUBKEY, false)
        ];
        return {
          address: {},
          innerTransaction: {
            instructions: [
              new import_web315.TransactionInstruction({
                programId: poolKeys.programId,
                keys,
                data
              })
            ],
            signers: [],
            lookupTableAddress: [],
            instructionTypes: [
              40
              /* farmV3CreateLedger */
            ]
          }
        };
      }
      static makeCreateAssociatedLedgerAccountInstructionV5({
        poolKeys,
        userKeys
      }) {
        const LAYOUT = struct3([u822("instruction")]);
        const data = Buffer.alloc(LAYOUT.span);
        LAYOUT.encode(
          {
            instruction: 10
          },
          data
        );
        const keys = [
          AccountMeta(poolKeys.id, false),
          AccountMeta(userKeys.ledger, false),
          AccountMetaReadonly(userKeys.owner, true),
          // system
          AccountMetaReadonly(SYSTEM_PROGRAM_ID2, false),
          AccountMetaReadonly(import_web332.SYSVAR_RENT_PUBKEY, false)
        ];
        return {
          address: {},
          innerTransaction: {
            instructions: [
              new import_web315.TransactionInstruction({
                programId: poolKeys.programId,
                keys,
                data
              })
            ],
            signers: [],
            lookupTableAddress: [],
            instructionTypes: [
              43
              /* farmV5CreateLedger */
            ]
          }
        };
      }
      static makeCreateFarmInstruction({ connection, userKeys, poolInfo }) {
        const { version: version2 } = poolInfo;
        if (version2 === 6) {
          return this.makeCreateFarmInstructionV6({
            connection,
            userKeys,
            poolInfo
          });
        }
        return logger8.throwArgumentError("invalid version", "version", version2);
      }
      static makeCreateFarmInstructionV6(_0) {
        return __async(this, arguments, function* ({ connection, userKeys, poolInfo }) {
          var _a, _b, _c;
          const payer = (_a = userKeys.payer) != null ? _a : userKeys.owner;
          const farmId = generatePubKey2({ fromPublicKey: payer, programId: poolInfo.programId });
          const lamports = yield connection.getMinimumBalanceForRentExemption(FARM_STATE_LAYOUT_V6.span);
          const frontInstructions = [];
          const endInstructions = [];
          const frontInstructionsType = [];
          const endInstructionsType = [];
          const signers = [];
          frontInstructions.push(
            import_web315.SystemProgram.createAccountWithSeed({
              fromPubkey: payer,
              basePubkey: payer,
              seed: farmId.seed,
              newAccountPubkey: farmId.publicKey,
              lamports,
              space: FARM_STATE_LAYOUT_V6.span,
              programId: poolInfo.programId
            })
          );
          const { publicKey: authority, nonce } = _Farm.getAssociatedAuthority({
            programId: poolInfo.programId,
            poolId: farmId.publicKey
          });
          const lpVault = _Farm.getAssociatedLedgerPoolAccount({
            programId: poolInfo.programId,
            poolId: farmId.publicKey,
            mint: poolInfo.lpMint,
            type: "lpVault"
          });
          const rewardInfoConfig = [];
          const rewardInfoKey = [];
          for (const rewardInfo of poolInfo.rewardInfos) {
            logger8.assertArgument(
              rewardInfo.rewardOpenTime < rewardInfo.rewardEndTime,
              "start time error",
              "rewardInfo.rewardOpenTime",
              rewardInfo.rewardOpenTime
            );
            logger8.assertArgument(
              poolTypeV62[rewardInfo.rewardType] !== void 0,
              "reward type error",
              "rewardInfo.rewardType",
              rewardInfo.rewardType
            );
            logger8.assertArgument(
              parseBigNumberish2(rewardInfo.rewardPerSecond).gt(ZERO2),
              "rewardPerSecond error",
              "rewardInfo.rewardPerSecond",
              rewardInfo.rewardPerSecond
            );
            rewardInfoConfig.push({
              isSet: new import_bn9.default(1),
              rewardPerSecond: parseBigNumberish2(rewardInfo.rewardPerSecond),
              rewardOpenTime: parseBigNumberish2(rewardInfo.rewardOpenTime),
              rewardEndTime: parseBigNumberish2(rewardInfo.rewardEndTime),
              rewardType: parseBigNumberish2(poolTypeV62[rewardInfo.rewardType])
            });
            let userRewardToken;
            if (rewardInfo.rewardMint.equals(import_web315.PublicKey.default)) {
              userRewardToken = yield Spl.insertCreateWrappedNativeAccount({
                connection,
                owner: userKeys.owner,
                payer: (_b = userKeys.payer) != null ? _b : userKeys.owner,
                instructions: frontInstructions,
                signers,
                amount: parseBigNumberish2(rewardInfo.rewardEndTime).sub(parseBigNumberish2(rewardInfo.rewardOpenTime)).mul(parseBigNumberish2(rewardInfo.rewardPerSecond)),
                instructionsType: frontInstructionsType
              });
              endInstructions.push(
                Spl.makeCloseAccountInstruction({
                  programId: import_spl_token2.TOKEN_PROGRAM_ID,
                  tokenAccount: userRewardToken,
                  owner: userKeys.owner,
                  payer: (_c = userKeys.payer) != null ? _c : userKeys.owner,
                  instructionsType: endInstructionsType
                })
              );
            } else {
              userRewardToken = this._selectTokenAccount({
                programId: import_spl_token2.TOKEN_PROGRAM_ID,
                tokenAccounts: userKeys.tokenAccounts,
                mint: rewardInfo.rewardMint,
                owner: userKeys.owner,
                config: { associatedOnly: false }
              });
            }
            logger8.assertArgument(
              userRewardToken !== null,
              "cannot found target token accounts",
              "tokenAccounts",
              userKeys.tokenAccounts
            );
            const rewardMint = rewardInfo.rewardMint.equals(import_web315.PublicKey.default) ? Token3.WSOL.mint : rewardInfo.rewardMint;
            rewardInfoKey.push({
              rewardMint,
              rewardVault: _Farm.getAssociatedLedgerPoolAccount({
                programId: poolInfo.programId,
                poolId: farmId.publicKey,
                mint: rewardMint,
                type: "rewardVault"
              }),
              userRewardToken
            });
          }
          const lockUserAccount = this._selectTokenAccount({
            programId: import_spl_token2.TOKEN_PROGRAM_ID,
            tokenAccounts: userKeys.tokenAccounts,
            mint: poolInfo.lockInfo.lockMint,
            owner: userKeys.owner,
            config: { associatedOnly: false }
          });
          logger8.assertArgument(lockUserAccount !== null, "cannot found lock vault", "tokenAccounts", userKeys.tokenAccounts);
          const rewardTimeInfo = struct3([
            u643("isSet"),
            u643("rewardPerSecond"),
            u643("rewardOpenTime"),
            u643("rewardEndTime"),
            u643("rewardType")
          ]);
          const LAYOUT = struct3([u822("instruction"), u643("nonce"), seq22(rewardTimeInfo, 5, "rewardTimeInfo")]);
          const data = Buffer.alloc(LAYOUT.span);
          LAYOUT.encode(
            {
              instruction: 0,
              nonce: new import_bn9.default(nonce),
              rewardTimeInfo: rewardInfoConfig
            },
            data
          );
          const keys = [
            AccountMetaReadonly(import_spl_token2.TOKEN_PROGRAM_ID, false),
            AccountMetaReadonly(SYSTEM_PROGRAM_ID2, false),
            AccountMetaReadonly(import_web332.SYSVAR_RENT_PUBKEY, false),
            AccountMeta(farmId.publicKey, false),
            AccountMetaReadonly(authority, false),
            AccountMeta(lpVault, false),
            AccountMetaReadonly(poolInfo.lpMint, false),
            AccountMeta(poolInfo.lockInfo.lockVault, false),
            AccountMetaReadonly(poolInfo.lockInfo.lockMint, false),
            AccountMeta(lockUserAccount != null ? lockUserAccount : import_web315.PublicKey.default, false),
            AccountMetaReadonly(userKeys.owner, true)
          ];
          for (const item of rewardInfoKey) {
            keys.push(
              ...[
                { pubkey: item.rewardMint, isSigner: false, isWritable: false },
                { pubkey: item.rewardVault, isSigner: false, isWritable: true },
                { pubkey: item.userRewardToken, isSigner: false, isWritable: true }
              ]
            );
          }
          const ins = new import_web315.TransactionInstruction({
            programId: poolInfo.programId,
            keys,
            data
          });
          return {
            address: { farmId: farmId.publicKey },
            innerTransaction: {
              instructions: [...frontInstructions, ins, ...endInstructions],
              signers,
              lookupTableAddress: [],
              instructionTypes: [...frontInstructionsType, 46, ...endInstructionsType]
            }
          };
        });
      }
      static makeCreatorWithdrawFarmRewardInstruction(params) {
        const { poolKeys } = params;
        const { version: version2 } = poolKeys;
        if (version2 === 6) {
          return this.makeCreatorWithdrawFarmRewardInstructionV6(params);
        }
        return logger8.throwArgumentError("invalid version", "version", version2);
      }
      static makeCreatorWithdrawFarmRewardInstructionV6({
        poolKeys,
        userKeys,
        withdrawMint
      }) {
        var _a;
        const rewardInfo = poolKeys.rewardInfos.find(
          (item) => item.rewardMint.equals(withdrawMint.equals(import_web315.PublicKey.default) ? Token3.WSOL.mint : withdrawMint)
        );
        logger8.assertArgument(rewardInfo !== void 0, "withdraw mint error", "poolKeys.rewardInfos", poolKeys.rewardInfos);
        const rewardVault = (_a = rewardInfo == null ? void 0 : rewardInfo.rewardVault) != null ? _a : import_web315.PublicKey.default;
        const LAYOUT = struct3([u822("instruction")]);
        const data = Buffer.alloc(LAYOUT.span);
        LAYOUT.encode({ instruction: 5 }, data);
        const keys = [
          AccountMetaReadonly(import_spl_token2.TOKEN_PROGRAM_ID, false),
          AccountMeta(poolKeys.id, false),
          AccountMetaReadonly(poolKeys.authority, false),
          AccountMetaReadonly(poolKeys.lpVault, false),
          AccountMeta(rewardVault, false),
          AccountMeta(userKeys.userRewardToken, false),
          AccountMetaReadonly(userKeys.owner, true)
        ];
        const ins = new import_web315.TransactionInstruction({
          programId: poolKeys.programId,
          keys,
          data
        });
        return {
          address: {},
          innerTransaction: {
            instructions: [ins],
            signers: [],
            lookupTableAddress: [],
            instructionTypes: [
              49
              /* farmV6CreatorWithdraw */
            ]
          }
        };
      }
      /* ================= fetch data ================= */
      static fetchMultipleInfoAndUpdate(_0) {
        return __async(this, arguments, function* ({
          connection,
          pools,
          owner,
          config: config2,
          chainTime
        }) {
          let hasNotV6Pool = false;
          let hasV6Pool = false;
          const publicKeys = [];
          const apiPoolInfo = {};
          for (const pool of pools) {
            apiPoolInfo[pool.id.toString()] = pool;
            if (pool.version === 6)
              hasV6Pool = true;
            else
              hasNotV6Pool = true;
            publicKeys.push({
              pubkey: pool.id,
              version: pool.version,
              key: "state",
              poolId: pool.id
            });
            publicKeys.push({
              pubkey: pool.lpVault,
              version: pool.version,
              key: "lpVault",
              poolId: pool.id
            });
            if (owner) {
              publicKeys.push({
                pubkey: this.getAssociatedLedgerAccount({
                  programId: pool.programId,
                  poolId: pool.id,
                  owner,
                  version: pool.version
                }),
                version: pool.version,
                key: "ledger",
                poolId: pool.id
              });
            }
          }
          const poolsInfo = {};
          const accountsInfo = yield getMultipleAccountsInfoWithCustomFlags2(connection, publicKeys, config2);
          for (const { pubkey, version: version2, key, poolId, accountInfo } of accountsInfo) {
            const _poolId = poolId.toBase58();
            if (key === "state") {
              const STATE_LAYOUT = this.getStateLayout(version2);
              if (!accountInfo || !accountInfo.data || accountInfo.data.length !== STATE_LAYOUT.span) {
                return logger8.throwArgumentError("invalid farm state account info", "pools.id", pubkey);
              }
              poolsInfo[_poolId] = __spreadValues(__spreadValues(__spreadValues({}, poolsInfo[_poolId]), { apiPoolInfo: apiPoolInfo[_poolId] }), { state: STATE_LAYOUT.decode(accountInfo.data) });
            } else if (key === "lpVault") {
              if (!accountInfo || !accountInfo.data || accountInfo.data.length !== SPL_ACCOUNT_LAYOUT.span) {
                return logger8.throwArgumentError("invalid farm lp vault account info", "pools.lpVault", pubkey);
              }
              poolsInfo[_poolId] = __spreadValues(__spreadValues({}, poolsInfo[_poolId]), { lpVault: SPL_ACCOUNT_LAYOUT.decode(accountInfo.data) });
            } else if (key === "ledger") {
              const LEDGER_LAYOUT = this.getLedgerLayout(version2);
              if (accountInfo && accountInfo.data) {
                logger8.assertArgument(
                  accountInfo.data.length === LEDGER_LAYOUT.span,
                  "invalid farm ledger account info",
                  "ledger",
                  pubkey
                );
                poolsInfo[_poolId] = __spreadValues(__spreadValues({}, poolsInfo[_poolId]), { ledger: LEDGER_LAYOUT.decode(accountInfo.data) });
              }
            }
          }
          const slot = hasV6Pool || hasNotV6Pool ? yield connection.getSlot() : 0;
          for (const poolId of Object.keys(poolsInfo)) {
            if (poolsInfo[poolId] === void 0)
              continue;
            poolsInfo[poolId].state = _Farm.updatePoolInfo(poolsInfo[poolId].state, poolsInfo[poolId].lpVault, slot, chainTime);
          }
          for (const [poolId, { state, ledger }] of Object.entries(poolsInfo)) {
            if (ledger) {
              let multiplier;
              if (state.version === 6) {
                multiplier = state.rewardMultiplier;
              } else {
                multiplier = state.rewardInfos.length === 1 ? TEN.pow(new import_bn9.default(9)) : TEN.pow(new import_bn9.default(15));
              }
              const pendingRewards = state.rewardInfos.map((rewardInfo, index) => {
                const rewardDebt = ledger.rewardDebts[index];
                const pendingReward = ledger.deposited.mul(state.version === 6 ? rewardInfo.accRewardPerShare : rewardInfo.perShareReward).div(multiplier).sub(rewardDebt);
                return pendingReward;
              });
              poolsInfo[poolId].wrapped = __spreadProps(__spreadValues({}, poolsInfo[poolId].wrapped), {
                pendingRewards
              });
            }
          }
          return poolsInfo;
        });
      }
      static updatePoolInfo(poolInfo, lpVault, slot, chainTime) {
        if (poolInfo.version === 3 || poolInfo.version === 5) {
          if (poolInfo.lastSlot.gte(new import_bn9.default(slot)))
            return poolInfo;
          const spread = new import_bn9.default(slot).sub(poolInfo.lastSlot);
          poolInfo.lastSlot = new import_bn9.default(slot);
          for (const itemRewardInfo of poolInfo.rewardInfos) {
            if (lpVault.amount.eq(new import_bn9.default(0)))
              continue;
            const reward = itemRewardInfo.perSlotReward.mul(spread);
            itemRewardInfo.perShareReward = itemRewardInfo.perShareReward.add(
              reward.mul(new import_bn9.default(10).pow(new import_bn9.default(poolInfo.version === 3 ? 9 : 15))).div(lpVault.amount)
            );
            itemRewardInfo.totalReward = itemRewardInfo.totalReward.add(reward);
          }
        } else if (poolInfo.version === 6) {
          for (const itemRewardInfo of poolInfo.rewardInfos) {
            if (itemRewardInfo.rewardState.eq(new import_bn9.default(0)))
              continue;
            const updateTime = import_bn9.default.min(new import_bn9.default(chainTime), itemRewardInfo.rewardEndTime);
            if (itemRewardInfo.rewardOpenTime.gte(updateTime))
              continue;
            const spread = updateTime.sub(itemRewardInfo.rewardLastUpdateTime);
            let reward = spread.mul(itemRewardInfo.rewardPerSecond);
            const leftReward = itemRewardInfo.totalReward.sub(itemRewardInfo.totalRewardEmissioned);
            if (leftReward.lt(reward)) {
              reward = leftReward;
              itemRewardInfo.rewardLastUpdateTime = itemRewardInfo.rewardLastUpdateTime.add(
                leftReward.div(itemRewardInfo.rewardPerSecond)
              );
            } else {
              itemRewardInfo.rewardLastUpdateTime = updateTime;
            }
            if (lpVault.amount.eq(new import_bn9.default(0)))
              continue;
            itemRewardInfo.accRewardPerShare = itemRewardInfo.accRewardPerShare.add(
              reward.mul(poolInfo.rewardMultiplier).div(lpVault.amount)
            );
            itemRewardInfo.totalRewardEmissioned = itemRewardInfo.totalRewardEmissioned.add(reward);
          }
        }
        return poolInfo;
      }
      /* ================= make instruction simple ================= */
      static makeCreatorWithdrawFarmRewardInstructionSimple(params) {
        const { poolKeys } = params;
        const { version: version2 } = poolKeys;
        if (version2 === 6) {
          return this.makeCreatorWithdrawFarmRewardInstructionV6Simple(params);
        }
        return logger8.throwArgumentError("invalid version", "version", version2);
      }
      static makeCreatorWithdrawFarmRewardInstructionV6Simple(_0) {
        return __async(this, arguments, function* ({
          connection,
          poolKeys,
          userKeys,
          withdrawMint,
          makeTxVersion,
          lookupTableCache,
          computeBudgetConfig
        }) {
          var _a, _b, _c, _d;
          const frontInstructions = [];
          const endInstructions = [];
          const frontInstructionsType = [];
          const endInstructionsType = [];
          const signers = [];
          let userRewardToken;
          if (withdrawMint.equals(import_web315.PublicKey.default)) {
            userRewardToken = yield Spl.insertCreateWrappedNativeAccount({
              connection,
              owner: userKeys.owner,
              payer: (_a = userKeys.payer) != null ? _a : userKeys.owner,
              instructions: frontInstructions,
              signers,
              amount: 0,
              instructionsType: frontInstructionsType
            });
            endInstructions.push(
              Spl.makeCloseAccountInstruction({
                programId: import_spl_token2.TOKEN_PROGRAM_ID,
                tokenAccount: userRewardToken,
                owner: userKeys.owner,
                payer: (_b = userKeys.payer) != null ? _b : userKeys.owner,
                instructionsType: endInstructionsType
              })
            );
          } else {
            const selectUserRewardToken = this._selectTokenAccount({
              programId: import_spl_token2.TOKEN_PROGRAM_ID,
              tokenAccounts: userKeys.tokenAccounts,
              mint: withdrawMint,
              owner: userKeys.owner
            });
            if (selectUserRewardToken === null) {
              userRewardToken = getATAAddress2(userKeys.owner, withdrawMint, import_spl_token2.TOKEN_PROGRAM_ID).publicKey;
              frontInstructions.push(
                Spl.makeCreateAssociatedTokenAccountInstruction({
                  programId: import_spl_token2.TOKEN_PROGRAM_ID,
                  mint: withdrawMint,
                  associatedAccount: userRewardToken,
                  owner: userKeys.owner,
                  payer: (_c = userKeys.payer) != null ? _c : userKeys.owner,
                  instructionsType: frontInstructionsType
                })
              );
            } else {
              userRewardToken = selectUserRewardToken;
            }
          }
          const ins = this.makeCreatorWithdrawFarmRewardInstructionV6({
            poolKeys,
            userKeys: { userRewardToken, owner: userKeys.owner, payer: userKeys.payer },
            withdrawMint
          });
          return {
            address: {},
            innerTransactions: yield splitTxAndSigners({
              connection,
              makeTxVersion,
              computeBudgetConfig,
              payer: (_d = userKeys.payer) != null ? _d : userKeys.owner,
              innerTransaction: [
                { instructionTypes: frontInstructionsType, instructions: frontInstructions, signers },
                ins.innerTransaction,
                { instructionTypes: endInstructionsType, instructions: endInstructions, signers: [] }
              ],
              lookupTableCache
            })
          };
        });
      }
      static makeCreateFarmInstructionSimple(params) {
        const { version: version2 } = params.poolInfo;
        if (version2 === 6) {
          return this.makeCreateFarmInstructionV6Simple(params);
        }
        return logger8.throwArgumentError("invalid version", "version", version2);
      }
      static makeCreateFarmInstructionV6Simple(_0) {
        return __async(this, arguments, function* ({
          connection,
          userKeys,
          poolInfo,
          makeTxVersion,
          lookupTableCache,
          computeBudgetConfig
        }) {
          var _a, _b, _c, _d;
          const payer = (_a = userKeys.payer) != null ? _a : userKeys.owner;
          const farmId = generatePubKey2({ fromPublicKey: payer, programId: poolInfo.programId });
          const lamports = yield connection.getMinimumBalanceForRentExemption(FARM_STATE_LAYOUT_V6.span);
          const frontInstructions = [];
          const endInstructions = [];
          const frontInstructionsType = [];
          const endInstructionsType = [];
          const signers = [];
          frontInstructions.push(
            import_web315.SystemProgram.createAccountWithSeed({
              fromPubkey: payer,
              basePubkey: payer,
              seed: farmId.seed,
              newAccountPubkey: farmId.publicKey,
              lamports,
              space: FARM_STATE_LAYOUT_V6.span,
              programId: poolInfo.programId
            })
          );
          const { publicKey: authority, nonce } = _Farm.getAssociatedAuthority({
            programId: poolInfo.programId,
            poolId: farmId.publicKey
          });
          const lpVault = _Farm.getAssociatedLedgerPoolAccount({
            programId: poolInfo.programId,
            poolId: farmId.publicKey,
            mint: poolInfo.lpMint,
            type: "lpVault"
          });
          const rewardInfoConfig = [];
          const rewardInfoKey = [];
          for (const rewardInfo of poolInfo.rewardInfos) {
            logger8.assertArgument(
              rewardInfo.rewardOpenTime < rewardInfo.rewardEndTime,
              "start time error",
              "rewardInfo.rewardOpenTime",
              rewardInfo.rewardOpenTime
            );
            logger8.assertArgument(
              poolTypeV62[rewardInfo.rewardType] !== void 0,
              "reward type error",
              "rewardInfo.rewardType",
              rewardInfo.rewardType
            );
            logger8.assertArgument(
              parseBigNumberish2(rewardInfo.rewardPerSecond).gt(ZERO2),
              "rewardPerSecond error",
              "rewardInfo.rewardPerSecond",
              rewardInfo.rewardPerSecond
            );
            rewardInfoConfig.push({
              isSet: new import_bn9.default(1),
              rewardPerSecond: parseBigNumberish2(rewardInfo.rewardPerSecond),
              rewardOpenTime: parseBigNumberish2(rewardInfo.rewardOpenTime),
              rewardEndTime: parseBigNumberish2(rewardInfo.rewardEndTime),
              rewardType: parseBigNumberish2(poolTypeV62[rewardInfo.rewardType])
            });
            let userRewardToken;
            if (rewardInfo.rewardMint.equals(import_web315.PublicKey.default)) {
              userRewardToken = yield Spl.insertCreateWrappedNativeAccount({
                connection,
                owner: userKeys.owner,
                payer: (_b = userKeys.payer) != null ? _b : userKeys.owner,
                instructions: frontInstructions,
                signers,
                amount: parseBigNumberish2(rewardInfo.rewardEndTime).sub(parseBigNumberish2(rewardInfo.rewardOpenTime)).mul(parseBigNumberish2(rewardInfo.rewardPerSecond)),
                instructionsType: frontInstructionsType
              });
              endInstructions.push(
                Spl.makeCloseAccountInstruction({
                  programId: import_spl_token2.TOKEN_PROGRAM_ID,
                  tokenAccount: userRewardToken,
                  owner: userKeys.owner,
                  payer: (_c = userKeys.payer) != null ? _c : userKeys.owner,
                  instructionsType: endInstructionsType
                })
              );
            } else {
              userRewardToken = this._selectTokenAccount({
                programId: import_spl_token2.TOKEN_PROGRAM_ID,
                tokenAccounts: userKeys.tokenAccounts,
                mint: rewardInfo.rewardMint,
                owner: userKeys.owner,
                config: { associatedOnly: false }
              });
            }
            logger8.assertArgument(
              userRewardToken !== null,
              "cannot found target token accounts",
              "tokenAccounts",
              userKeys.tokenAccounts
            );
            if (userRewardToken === null)
              throw Error("cannot found target token accounts");
            const rewardMint = rewardInfo.rewardMint.equals(import_web315.PublicKey.default) ? Token3.WSOL.mint : rewardInfo.rewardMint;
            rewardInfoKey.push({
              rewardMint,
              rewardVault: _Farm.getAssociatedLedgerPoolAccount({
                programId: poolInfo.programId,
                poolId: farmId.publicKey,
                mint: rewardMint,
                type: "rewardVault"
              }),
              userRewardToken
            });
          }
          const lockUserAccount = this._selectTokenAccount({
            programId: import_spl_token2.TOKEN_PROGRAM_ID,
            tokenAccounts: userKeys.tokenAccounts,
            mint: poolInfo.lockInfo.lockMint,
            owner: userKeys.owner,
            config: { associatedOnly: false }
          });
          logger8.assertArgument(lockUserAccount !== null, "cannot found lock vault", "tokenAccounts", userKeys.tokenAccounts);
          const rewardTimeInfo = struct3([
            u643("isSet"),
            u643("rewardPerSecond"),
            u643("rewardOpenTime"),
            u643("rewardEndTime"),
            u643("rewardType")
          ]);
          const LAYOUT = struct3([u822("instruction"), u643("nonce"), seq22(rewardTimeInfo, 5, "rewardTimeInfo")]);
          const data = Buffer.alloc(LAYOUT.span);
          LAYOUT.encode(
            {
              instruction: 0,
              nonce: new import_bn9.default(nonce),
              rewardTimeInfo: rewardInfoConfig
            },
            data
          );
          const keys = [
            AccountMetaReadonly(import_spl_token2.TOKEN_PROGRAM_ID, false),
            AccountMetaReadonly(SYSTEM_PROGRAM_ID2, false),
            AccountMetaReadonly(import_web332.SYSVAR_RENT_PUBKEY, false),
            AccountMeta(farmId.publicKey, false),
            AccountMetaReadonly(authority, false),
            AccountMeta(lpVault, false),
            AccountMetaReadonly(poolInfo.lpMint, false),
            AccountMeta(poolInfo.lockInfo.lockVault, false),
            AccountMetaReadonly(poolInfo.lockInfo.lockMint, false),
            AccountMeta(lockUserAccount != null ? lockUserAccount : import_web315.PublicKey.default, false),
            AccountMetaReadonly(userKeys.owner, true)
          ];
          for (const item of rewardInfoKey) {
            keys.push(
              ...[
                { pubkey: item.rewardMint, isSigner: false, isWritable: false },
                { pubkey: item.rewardVault, isSigner: false, isWritable: true },
                { pubkey: item.userRewardToken, isSigner: false, isWritable: true }
              ]
            );
          }
          const ins = new import_web315.TransactionInstruction({
            programId: poolInfo.programId,
            keys,
            data
          });
          return {
            address: { farmId: farmId.publicKey },
            innerTransactions: yield splitTxAndSigners({
              connection,
              makeTxVersion,
              computeBudgetConfig,
              payer: (_d = userKeys.payer) != null ? _d : userKeys.owner,
              innerTransaction: [
                { instructionTypes: frontInstructionsType, instructions: frontInstructions, signers },
                { instructionTypes: [
                  46
                  /* farmV6Create */
                ], instructions: [ins], signers: [] },
                { instructionTypes: endInstructionsType, instructions: endInstructions, signers: [] }
              ],
              lookupTableCache
            })
          };
        });
      }
      static makeRestartFarmInstructionSimple(params) {
        const { poolKeys } = params;
        const { version: version2 } = poolKeys;
        if (version2 === 6) {
          return this.makeRestartFarmInstructionV6Simple(params);
        }
        return logger8.throwArgumentError("invalid version", "version", version2);
      }
      static makeRestartFarmInstructionV6Simple(_0) {
        return __async(this, arguments, function* ({
          connection,
          poolKeys,
          userKeys,
          newRewardInfo,
          makeTxVersion,
          lookupTableCache,
          computeBudgetConfig
        }) {
          var _a, _b, _c, _d;
          logger8.assertArgument(
            newRewardInfo.rewardOpenTime < newRewardInfo.rewardEndTime,
            "start time error",
            "newRewardInfo",
            newRewardInfo
          );
          const rewardMint = newRewardInfo.rewardMint.equals(import_web315.PublicKey.default) ? Token3.WSOL.mint : newRewardInfo.rewardMint;
          const rewardInfo = poolKeys.rewardInfos.find((item) => item.rewardMint.equals(rewardMint));
          logger8.assertArgument(rewardInfo, "configuration does not exist", "rewardInfo", rewardInfo);
          const rewardVault = (_a = rewardInfo == null ? void 0 : rewardInfo.rewardVault) != null ? _a : import_web315.PublicKey.default;
          const frontInstructions = [];
          const endInstructions = [];
          const frontInstructionsType = [];
          const endInstructionsType = [];
          const signers = [];
          let userRewardToken;
          if (newRewardInfo.rewardMint.equals(import_web315.PublicKey.default)) {
            userRewardToken = yield Spl.insertCreateWrappedNativeAccount({
              connection,
              owner: userKeys.owner,
              payer: (_b = userKeys.payer) != null ? _b : userKeys.owner,
              instructions: frontInstructions,
              signers,
              amount: parseBigNumberish2(newRewardInfo.rewardEndTime).sub(parseBigNumberish2(newRewardInfo.rewardOpenTime)).mul(parseBigNumberish2(newRewardInfo.rewardPerSecond)),
              instructionsType: frontInstructionsType
            });
            endInstructions.push(
              Spl.makeCloseAccountInstruction({
                programId: import_spl_token2.TOKEN_PROGRAM_ID,
                tokenAccount: userRewardToken,
                owner: userKeys.owner,
                payer: (_c = userKeys.payer) != null ? _c : userKeys.owner,
                instructionsType: endInstructionsType
              })
            );
          } else {
            userRewardToken = this._selectTokenAccount({
              programId: import_spl_token2.TOKEN_PROGRAM_ID,
              tokenAccounts: userKeys.tokenAccounts,
              mint: newRewardInfo.rewardMint,
              owner: userKeys.owner,
              config: { associatedOnly: false }
            });
          }
          logger8.assertArgument(
            userRewardToken !== null,
            "cannot found target token accounts",
            "tokenAccounts",
            userKeys.tokenAccounts
          );
          if (userRewardToken === null)
            throw Error("cannot found target token accounts");
          const LAYOUT = struct3([u822("instruction"), u643("rewardReopenTime"), u643("rewardEndTime"), u643("rewardPerSecond")]);
          const data = Buffer.alloc(LAYOUT.span);
          LAYOUT.encode(
            {
              instruction: 3,
              rewardReopenTime: parseBigNumberish2(newRewardInfo.rewardOpenTime),
              rewardEndTime: parseBigNumberish2(newRewardInfo.rewardEndTime),
              rewardPerSecond: parseBigNumberish2(newRewardInfo.rewardPerSecond)
            },
            data
          );
          const keys = [
            AccountMetaReadonly(import_spl_token2.TOKEN_PROGRAM_ID, false),
            AccountMeta(poolKeys.id, false),
            AccountMetaReadonly(poolKeys.lpVault, false),
            AccountMeta(rewardVault, false),
            AccountMeta(userRewardToken, false),
            AccountMetaReadonly(userKeys.owner, true)
          ];
          const ins = new import_web315.TransactionInstruction({
            programId: poolKeys.programId,
            keys,
            data
          });
          return {
            address: {},
            innerTransactions: yield splitTxAndSigners({
              connection,
              makeTxVersion,
              computeBudgetConfig,
              payer: (_d = userKeys.payer) != null ? _d : userKeys.owner,
              innerTransaction: [
                { instructionTypes: frontInstructionsType, instructions: frontInstructions, signers },
                { instructionTypes: [
                  47
                  /* farmV6Restart */
                ], instructions: [ins], signers: [] },
                { instructionTypes: endInstructionsType, instructions: endInstructions, signers: [] }
              ],
              lookupTableCache
            })
          };
        });
      }
      static makeFarmCreatorAddRewardTokenInstructionSimple(params) {
        const { poolKeys } = params;
        const { version: version2 } = poolKeys;
        if (version2 === 6) {
          return this.makeFarmCreatorAddRewardTokenInstructionV6Simple(params);
        }
        return logger8.throwArgumentError("invalid version", "version", version2);
      }
      static makeFarmCreatorAddRewardTokenInstructionV6Simple(_0) {
        return __async(this, arguments, function* ({
          connection,
          poolKeys,
          userKeys,
          newRewardInfo,
          makeTxVersion,
          lookupTableCache,
          computeBudgetConfig
        }) {
          var _a, _b, _c;
          const rewardVault = _Farm.getAssociatedLedgerPoolAccount({
            programId: poolKeys.programId,
            poolId: poolKeys.id,
            mint: newRewardInfo.rewardMint.equals(import_web315.PublicKey.default) ? Token3.WSOL.mint : newRewardInfo.rewardMint,
            type: "rewardVault"
          });
          const frontInstructions = [];
          const endInstructions = [];
          const frontInstructionsType = [];
          const endInstructionsType = [];
          const signers = [];
          let userRewardToken;
          if (newRewardInfo.rewardMint.equals(import_web315.PublicKey.default)) {
            userRewardToken = yield Spl.insertCreateWrappedNativeAccount({
              connection,
              owner: userKeys.owner,
              payer: (_a = userKeys.payer) != null ? _a : userKeys.owner,
              instructions: frontInstructions,
              signers,
              amount: parseBigNumberish2(newRewardInfo.rewardEndTime).sub(parseBigNumberish2(newRewardInfo.rewardOpenTime)).mul(parseBigNumberish2(newRewardInfo.rewardPerSecond)),
              instructionsType: frontInstructionsType
            });
            endInstructions.push(
              Spl.makeCloseAccountInstruction({
                programId: import_spl_token2.TOKEN_PROGRAM_ID,
                tokenAccount: userRewardToken,
                owner: userKeys.owner,
                payer: (_b = userKeys.payer) != null ? _b : userKeys.owner,
                instructionsType: endInstructionsType
              })
            );
          } else {
            userRewardToken = this._selectTokenAccount({
              programId: import_spl_token2.TOKEN_PROGRAM_ID,
              tokenAccounts: userKeys.tokenAccounts,
              mint: newRewardInfo.rewardMint,
              owner: userKeys.owner,
              config: { associatedOnly: false }
            });
          }
          logger8.assertArgument(
            userRewardToken !== null,
            "cannot found target token accounts",
            "tokenAccounts",
            userKeys.tokenAccounts
          );
          if (userRewardToken === null)
            throw Error("cannot found target token accounts");
          const rewardMint = newRewardInfo.rewardMint.equals(import_web315.PublicKey.default) ? Token3.WSOL.mint : newRewardInfo.rewardMint;
          const LAYOUT = struct3([
            u822("instruction"),
            u643("isSet"),
            u643("rewardPerSecond"),
            u643("rewardOpenTime"),
            u643("rewardEndTime"),
            u643("rewardType")
          ]);
          const data = Buffer.alloc(LAYOUT.span);
          LAYOUT.encode(
            {
              instruction: 4,
              isSet: new import_bn9.default(1),
              rewardPerSecond: parseBigNumberish2(newRewardInfo.rewardPerSecond),
              rewardOpenTime: parseBigNumberish2(newRewardInfo.rewardOpenTime),
              rewardEndTime: parseBigNumberish2(newRewardInfo.rewardEndTime),
              rewardType: parseBigNumberish2(poolTypeV62[newRewardInfo.rewardType])
            },
            data
          );
          const keys = [
            AccountMetaReadonly(import_spl_token2.TOKEN_PROGRAM_ID, false),
            AccountMetaReadonly(SYSTEM_PROGRAM_ID2, false),
            AccountMetaReadonly(import_web332.SYSVAR_RENT_PUBKEY, false),
            AccountMeta(poolKeys.id, false),
            AccountMetaReadonly(poolKeys.authority, false),
            AccountMetaReadonly(rewardMint, false),
            AccountMeta(rewardVault, false),
            AccountMeta(userRewardToken, false),
            AccountMetaReadonly(userKeys.owner, true)
          ];
          const ins = new import_web315.TransactionInstruction({
            programId: poolKeys.programId,
            keys,
            data
          });
          return {
            address: {},
            innerTransactions: yield splitTxAndSigners({
              connection,
              makeTxVersion,
              computeBudgetConfig,
              payer: (_c = userKeys.payer) != null ? _c : userKeys.owner,
              innerTransaction: [
                { instructionTypes: frontInstructionsType, instructions: frontInstructions, signers },
                { instructionTypes: [
                  48
                  /* farmV6CreatorAddReward */
                ], instructions: [ins], signers: [] },
                { instructionTypes: endInstructionsType, instructions: endInstructions, signers: [] }
              ],
              lookupTableCache
            })
          };
        });
      }
      static makeDepositInstructionSimple(_0) {
        return __async(this, arguments, function* ({
          connection,
          poolKeys,
          fetchPoolInfo,
          ownerInfo,
          amount,
          associatedOnly = true,
          checkCreateATAOwner = false,
          makeTxVersion,
          lookupTableCache,
          computeBudgetConfig
        }) {
          var _a;
          const ownerMintToAccount = {};
          for (const item of ownerInfo.tokenAccounts) {
            if (associatedOnly) {
              const ata = getATAAddress2(ownerInfo.wallet, item.accountInfo.mint, item.programId).publicKey;
              if (ata.equals(item.pubkey))
                ownerMintToAccount[item.accountInfo.mint.toString()] = item.pubkey;
            } else {
              ownerMintToAccount[item.accountInfo.mint.toString()] = item.pubkey;
            }
          }
          const frontInstructions = [];
          const endInstructions = [];
          const frontInstructionsType = [];
          const endInstructionsType = [];
          const signers = [];
          const { lpVault, apiPoolInfo, ledger } = fetchPoolInfo;
          const lpMint = lpVault.mint;
          const ownerLpTokenAccount = ownerMintToAccount[lpMint.toString()];
          logger8.assertArgument(ownerLpTokenAccount, "you don't have any lp", "lp zero", ownerMintToAccount);
          const rewardAccounts = [];
          for (const itemReward of apiPoolInfo.rewardInfos) {
            const rewardUseSOLBalance = ownerInfo.useSOLBalance && itemReward.rewardMint.equals(Token3.WSOL.mint);
            const ownerRewardAccount = (_a = ownerMintToAccount[itemReward.rewardMint.toString()]) != null ? _a : yield this._selectOrCreateTokenAccount({
              programId: import_spl_token2.TOKEN_PROGRAM_ID,
              mint: itemReward.rewardMint,
              tokenAccounts: rewardUseSOLBalance ? [] : ownerInfo.tokenAccounts,
              owner: ownerInfo.wallet,
              createInfo: {
                connection,
                payer: ownerInfo.feePayer,
                amount: 0,
                frontInstructions,
                frontInstructionsType,
                endInstructions: rewardUseSOLBalance ? endInstructions : [],
                endInstructionsType: rewardUseSOLBalance ? endInstructionsType : [],
                signers
              },
              associatedOnly: rewardUseSOLBalance ? false : associatedOnly,
              checkCreateATAOwner
            });
            ownerMintToAccount[itemReward.rewardMint.toString()] = ownerRewardAccount;
            rewardAccounts.push(ownerRewardAccount);
          }
          const ledgerAddress = yield _Farm.getAssociatedLedgerAccount({
            programId: new import_web315.PublicKey(apiPoolInfo.programId),
            poolId: new import_web315.PublicKey(apiPoolInfo.id),
            owner: ownerInfo.wallet,
            version: apiPoolInfo.version
          });
          if (apiPoolInfo.version < 6 && !ledger) {
            const ins = _Farm.makeCreateAssociatedLedgerAccountInstruction({
              poolKeys,
              userKeys: {
                owner: ownerInfo.wallet,
                ledger: ledgerAddress
              }
            });
            frontInstructions.push(...ins.innerTransaction.instructions);
            frontInstructionsType.push(...ins.innerTransaction.instructionTypes);
          }
          const depositInstruction = _Farm.makeDepositInstruction({
            poolKeys,
            userKeys: {
              ledger: ledgerAddress,
              lpTokenAccount: ownerLpTokenAccount,
              owner: ownerInfo.wallet,
              rewardTokenAccounts: rewardAccounts
            },
            amount
          });
          return {
            address: depositInstruction.address,
            innerTransactions: yield splitTxAndSigners({
              connection,
              makeTxVersion,
              computeBudgetConfig,
              payer: ownerInfo.feePayer,
              innerTransaction: [
                { instructionTypes: frontInstructionsType, instructions: frontInstructions, signers },
                depositInstruction.innerTransaction,
                { instructionTypes: endInstructionsType, instructions: endInstructions, signers: [] }
              ],
              lookupTableCache
            })
          };
        });
      }
      static makeWithdrawInstructionSimple(_0) {
        return __async(this, arguments, function* ({
          connection,
          fetchPoolInfo,
          ownerInfo,
          amount,
          associatedOnly = true,
          checkCreateATAOwner = false,
          makeTxVersion,
          lookupTableCache,
          computeBudgetConfig
        }) {
          var _a, _b;
          const ownerMintToAccount = {};
          for (const item of ownerInfo.tokenAccounts) {
            if (associatedOnly) {
              const ata = getATAAddress2(ownerInfo.wallet, item.accountInfo.mint, item.programId).publicKey;
              if (ata.equals(item.pubkey))
                ownerMintToAccount[item.accountInfo.mint.toString()] = item.pubkey;
            } else {
              ownerMintToAccount[item.accountInfo.mint.toString()] = item.pubkey;
            }
          }
          const frontInstructions = [];
          const endInstructions = [];
          const frontInstructionsType = [];
          const endInstructionsType = [];
          const withdrawInstructions = [];
          const withdrawInstructionsType = [];
          const signers = [];
          const { lpVault, wrapped, apiPoolInfo } = fetchPoolInfo;
          if (wrapped === void 0)
            throw Error("no lp");
          const lpMint = lpVault.mint;
          const lpMintUseSOLBalance = ownerInfo.useSOLBalance && lpMint.equals(Token3.WSOL.mint);
          const ownerLpTokenAccount = (_a = ownerMintToAccount[lpMint.toString()]) != null ? _a : yield this._selectOrCreateTokenAccount({
            programId: import_spl_token2.TOKEN_PROGRAM_ID,
            mint: lpMint,
            tokenAccounts: lpMintUseSOLBalance ? [] : ownerInfo.tokenAccounts,
            owner: ownerInfo.wallet,
            createInfo: {
              connection,
              payer: ownerInfo.feePayer,
              amount: 0,
              frontInstructions,
              frontInstructionsType,
              signers
            },
            associatedOnly: lpMintUseSOLBalance ? false : associatedOnly,
            checkCreateATAOwner
          });
          ownerMintToAccount[lpMint.toString()] = ownerLpTokenAccount;
          const rewardAccounts = [];
          for (const itemReward of apiPoolInfo.rewardInfos) {
            const rewardUseSOLBalance = ownerInfo.useSOLBalance && itemReward.rewardMint.equals(Token3.WSOL.mint);
            const ownerRewardAccount = (_b = ownerMintToAccount[itemReward.rewardMint.toString()]) != null ? _b : yield this._selectOrCreateTokenAccount({
              programId: import_spl_token2.TOKEN_PROGRAM_ID,
              mint: itemReward.rewardMint,
              tokenAccounts: rewardUseSOLBalance ? [] : ownerInfo.tokenAccounts,
              owner: ownerInfo.wallet,
              createInfo: {
                connection,
                payer: ownerInfo.feePayer,
                amount: 0,
                frontInstructions,
                frontInstructionsType,
                endInstructions: rewardUseSOLBalance ? endInstructions : [],
                endInstructionsType: rewardUseSOLBalance ? endInstructionsType : [],
                signers
              },
              associatedOnly: rewardUseSOLBalance ? false : associatedOnly,
              checkCreateATAOwner
            });
            ownerMintToAccount[itemReward.rewardMint.toString()] = ownerRewardAccount;
            rewardAccounts.push(ownerRewardAccount);
          }
          const ins = this.makeWithdrawInstruction({
            poolKeys: apiPoolInfo,
            userKeys: {
              ledger: this.getAssociatedLedgerAccount({
                programId: apiPoolInfo.programId,
                poolId: apiPoolInfo.id,
                owner: ownerInfo.wallet,
                version: apiPoolInfo.version
              }),
              lpTokenAccount: ownerLpTokenAccount,
              rewardTokenAccounts: rewardAccounts,
              owner: ownerInfo.wallet
            },
            amount
          });
          withdrawInstructions.push(...ins.innerTransaction.instructions);
          withdrawInstructionsType.push(...ins.innerTransaction.instructionTypes);
          return {
            address: {},
            innerTransactions: yield splitTxAndSigners({
              connection,
              makeTxVersion,
              computeBudgetConfig,
              payer: ownerInfo.feePayer,
              innerTransaction: [
                { instructionTypes: frontInstructionsType, instructions: frontInstructions, signers },
                { instructionTypes: withdrawInstructionsType, instructions: withdrawInstructions, signers: [] },
                { instructionTypes: endInstructionsType, instructions: endInstructions, signers: [] }
              ],
              lookupTableCache
            })
          };
        });
      }
      static makeHarvestAllRewardInstructionSimple(_0) {
        return __async(this, arguments, function* ({
          connection,
          fetchPoolInfos,
          ownerInfo,
          associatedOnly = true,
          checkCreateATAOwner = false,
          makeTxVersion,
          lookupTableCache,
          computeBudgetConfig
        }) {
          var _a, _b;
          const ownerMintToAccount = {};
          for (const item of ownerInfo.tokenAccounts) {
            if (associatedOnly) {
              const ata = getATAAddress2(ownerInfo.wallet, item.accountInfo.mint, item.programId).publicKey;
              if (ata.equals(item.pubkey))
                ownerMintToAccount[item.accountInfo.mint.toString()] = item.pubkey;
            } else {
              ownerMintToAccount[item.accountInfo.mint.toString()] = item.pubkey;
            }
          }
          const frontInstructions = [];
          const endInstructions = [];
          const frontInstructionsType = [];
          const endInstructionsType = [];
          const harvestInstructions = [];
          const signers = [];
          for (const { lpVault, wrapped, apiPoolInfo, ledger } of Object.values(fetchPoolInfos)) {
            if (wrapped === void 0 || ledger === void 0 || !(wrapped.pendingRewards.find((i) => i.gt(ZERO2)) !== void 0 || ledger.deposited.isZero()))
              continue;
            const lpMint = lpVault.mint;
            const lpMintUseSOLBalance = ownerInfo.useSOLBalance && lpMint.equals(Token3.WSOL.mint);
            const ownerLpTokenAccount = (_a = ownerMintToAccount[lpMint.toString()]) != null ? _a : yield this._selectOrCreateTokenAccount({
              programId: import_spl_token2.TOKEN_PROGRAM_ID,
              mint: lpMint,
              tokenAccounts: lpMintUseSOLBalance ? [] : ownerInfo.tokenAccounts,
              owner: ownerInfo.wallet,
              createInfo: {
                connection,
                payer: ownerInfo.feePayer,
                amount: 0,
                frontInstructions,
                frontInstructionsType,
                signers
              },
              associatedOnly: lpMintUseSOLBalance ? false : associatedOnly,
              checkCreateATAOwner
            });
            ownerMintToAccount[lpMint.toString()] = ownerLpTokenAccount;
            const rewardAccounts = [];
            for (const itemReward of apiPoolInfo.rewardInfos) {
              const rewardUseSOLBalance = ownerInfo.useSOLBalance && itemReward.rewardMint.equals(Token3.WSOL.mint);
              const ownerRewardAccount = (_b = ownerMintToAccount[itemReward.rewardMint.toString()]) != null ? _b : yield this._selectOrCreateTokenAccount({
                programId: import_spl_token2.TOKEN_PROGRAM_ID,
                mint: itemReward.rewardMint,
                tokenAccounts: rewardUseSOLBalance ? [] : ownerInfo.tokenAccounts,
                owner: ownerInfo.wallet,
                createInfo: {
                  connection,
                  payer: ownerInfo.feePayer,
                  amount: 0,
                  frontInstructions,
                  frontInstructionsType,
                  endInstructions: rewardUseSOLBalance ? endInstructions : [],
                  endInstructionsType: rewardUseSOLBalance ? endInstructionsType : [],
                  signers
                },
                associatedOnly: rewardUseSOLBalance ? false : associatedOnly,
                checkCreateATAOwner
              });
              ownerMintToAccount[itemReward.rewardMint.toString()] = ownerRewardAccount;
              rewardAccounts.push(ownerRewardAccount);
            }
            const ins = this.makeWithdrawInstruction({
              poolKeys: apiPoolInfo,
              userKeys: {
                ledger: this.getAssociatedLedgerAccount({
                  programId: apiPoolInfo.programId,
                  poolId: apiPoolInfo.id,
                  owner: ownerInfo.wallet,
                  version: apiPoolInfo.version
                }),
                lpTokenAccount: ownerLpTokenAccount,
                rewardTokenAccounts: rewardAccounts,
                owner: ownerInfo.wallet
              },
              amount: 0
            });
            harvestInstructions.push(ins.innerTransaction);
          }
          return {
            address: {},
            innerTransactions: yield splitTxAndSigners({
              connection,
              makeTxVersion,
              computeBudgetConfig,
              payer: ownerInfo.feePayer,
              innerTransaction: [
                { instructionTypes: frontInstructionsType, instructions: frontInstructions, signers },
                ...harvestInstructions,
                { instructionTypes: endInstructionsType, instructions: endInstructions, signers: [] }
              ],
              lookupTableCache
            })
          };
        });
      }
      /**
       * @deprecated the method is **DANGEROUS**, please don't use
       */
      static makeV1InfoToV2PdaAndHarvestSimple(_0) {
        return __async(this, arguments, function* ({
          connection,
          wallet,
          tokenAccounts,
          programIdV3,
          programIdV5,
          makeTxVersion,
          lookupTableCache,
          computeBudgetConfig
        }) {
          const mintToAccount = {};
          for (const item of tokenAccounts) {
            const mint = item.accountInfo.mint;
            const ata = getATAAddress2(wallet, mint, item.programId).publicKey;
            if (ata.equals(item.pubkey))
              mintToAccount[mint.toString()] = ata;
            if (mintToAccount[mint.toString()] === void 0)
              mintToAccount[mint.toString()] = item.pubkey;
          }
          const dataInfoV3 = yield connection.getProgramAccounts(programIdV3, {
            filters: [{ memcmp: { offset: 40, bytes: wallet.toString() } }]
          });
          const dataInfoV5 = yield connection.getProgramAccounts(programIdV5, {
            filters: [{ memcmp: { offset: 40, bytes: wallet.toString() } }]
          });
          const poolIdToAccountV3 = {};
          const poolIdToAccountV5 = {};
          for (const item of dataInfoV3) {
            const layout = item.account.data.length === FARM_LEDGER_LAYOUT_V3_1.span ? FARM_LEDGER_LAYOUT_V3_1 : FARM_LEDGER_LAYOUT_V3_2;
            const info = layout.decode(item.account.data);
            const poolId = info.id.toString();
            const pda = this.getAssociatedLedgerAccount({
              programId: programIdV3,
              poolId: info.id,
              owner: wallet,
              version: 3
            });
            if (poolIdToAccountV3[poolId] === void 0) {
              poolIdToAccountV3[poolId] = { pda: void 0, other: [] };
            }
            if (pda.equals(item.pubkey)) {
              poolIdToAccountV3[poolId].pda = item.pubkey;
            } else {
              poolIdToAccountV3[poolId].other.push(item.pubkey);
            }
          }
          for (const item of dataInfoV5) {
            const layout = item.account.data.length === FARM_LEDGER_LAYOUT_V5_1.span ? FARM_LEDGER_LAYOUT_V5_1 : FARM_LEDGER_LAYOUT_V5_2;
            const info = layout.decode(item.account.data);
            const poolId = info.id.toString();
            const pda = this.getAssociatedLedgerAccount({
              programId: programIdV5,
              poolId: info.id,
              owner: wallet,
              version: 5
            });
            if (poolIdToAccountV5[poolId] === void 0) {
              poolIdToAccountV5[poolId] = { pda: void 0, other: [] };
            }
            if (pda.equals(item.pubkey)) {
              poolIdToAccountV5[poolId].pda = item.pubkey;
            } else {
              poolIdToAccountV5[poolId].other.push(item.pubkey);
            }
          }
          const needCheckPoolId = [
            ...Object.entries(poolIdToAccountV3).filter((i) => i[1].other.length > 0).map((i) => i[0]),
            ...Object.entries(poolIdToAccountV5).filter((i) => i[1].other.length > 0).map((i) => i[0])
          ];
          const allPoolInfo = yield connection.getMultipleAccountsInfo(needCheckPoolId.map((i) => new import_web315.PublicKey(i)));
          const poolIdToInfo = {};
          for (let i = 0; i < needCheckPoolId.length; i++) {
            const id = needCheckPoolId[i];
            const info = allPoolInfo[i];
            if (info === null)
              continue;
            poolIdToInfo[id] = info.data;
          }
          const frontInstructions = [];
          const frontInstructionsType = [];
          const instructions = [];
          const endInstructions = [];
          const endInstructionsType = [];
          for (const [poolId, info] of Object.entries(poolIdToAccountV3)) {
            if (info.other.length === 0)
              continue;
            if (poolIdToInfo[poolId] === void 0)
              continue;
            const poolInfo = REAL_FARM_STATE_LAYOUT_V3.decode(poolIdToInfo[poolId]);
            const [_lpInfo, _rewardInfo] = yield connection.getMultipleAccountsInfo([poolInfo.lpVault, poolInfo.rewardVault]);
            if (_lpInfo === null || _rewardInfo === null)
              throw Error("get lp and reward info error");
            const lpInfo = SPL_ACCOUNT_LAYOUT.decode(_lpInfo.data);
            const rewardInfo = SPL_ACCOUNT_LAYOUT.decode(_rewardInfo.data);
            let lpAccount = mintToAccount[lpInfo.mint.toString()];
            if (lpAccount === void 0) {
              lpAccount = yield this._selectOrCreateTokenAccount({
                programId: _lpInfo.owner,
                mint: lpInfo.mint,
                tokenAccounts: [],
                owner: wallet,
                createInfo: {
                  connection,
                  payer: wallet,
                  amount: 0,
                  frontInstructions,
                  frontInstructionsType,
                  endInstructions: [],
                  endInstructionsType: [],
                  signers: []
                },
                associatedOnly: true,
                checkCreateATAOwner: true
              });
              mintToAccount[lpInfo.mint.toString()] = lpAccount;
            }
            let rewardAccount = mintToAccount[rewardInfo.mint.toString()];
            if (rewardAccount === void 0) {
              rewardAccount = yield this._selectOrCreateTokenAccount({
                programId: _rewardInfo.owner,
                mint: rewardInfo.mint,
                tokenAccounts: [],
                owner: wallet,
                createInfo: {
                  connection,
                  payer: wallet,
                  amount: 0,
                  frontInstructions,
                  frontInstructionsType,
                  endInstructions: rewardInfo.mint.toString() === WSOL.mint ? endInstructions : [],
                  endInstructionsType: rewardInfo.mint.toString() === WSOL.mint ? endInstructionsType : [],
                  signers: []
                },
                associatedOnly: true,
                checkCreateATAOwner: true
              });
              mintToAccount[rewardInfo.mint.toString()] = rewardAccount;
            }
            if (info.pda === void 0) {
              const _i2 = this.makeCreateAssociatedLedgerAccountInstructionV3({
                // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                // @ts-ignore
                poolKeys: { programId: programIdV3, id: new import_web315.PublicKey(poolId) },
                userKeys: {
                  ledger: this.getAssociatedLedgerAccount({
                    programId: programIdV3,
                    poolId: new import_web315.PublicKey(poolId),
                    owner: wallet,
                    version: 3
                  }),
                  owner: wallet
                }
              });
              instructions.push(_i2.innerTransaction);
            }
            const _i = this.makeDepositInstructionV3({
              amount: 0,
              userKeys: {
                ledger: this.getAssociatedLedgerAccount({
                  programId: programIdV3,
                  poolId: new import_web315.PublicKey(poolId),
                  owner: wallet,
                  version: 3
                }),
                owner: wallet,
                lpTokenAccount: lpAccount,
                rewardTokenAccounts: [rewardAccount],
                auxiliaryLedgers: info.other
              },
              poolKeys: {
                programId: programIdV3,
                id: new import_web315.PublicKey(poolId),
                authority: this.getAssociatedAuthority({ programId: programIdV3, poolId: new import_web315.PublicKey(poolId) }).publicKey,
                lpVault: poolInfo.lpVault,
                // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                // @ts-ignore
                rewardInfos: [{ rewardVault: poolInfo.rewardVault }]
              }
            });
            instructions.push(_i.innerTransaction);
          }
          for (const [poolId, info] of Object.entries(poolIdToAccountV5)) {
            if (info.other.length === 0)
              continue;
            if (poolIdToInfo[poolId] === void 0)
              continue;
            const poolInfo = REAL_FARM_STATE_LAYOUT_V5.decode(poolIdToInfo[poolId]);
            const [_lpInfo, _rewardInfoA, _rewardInfoB] = yield connection.getMultipleAccountsInfo([
              poolInfo.lpVault,
              poolInfo.rewardVaultA,
              poolInfo.rewardVaultB
            ]);
            if (_lpInfo === null || _rewardInfoA === null || _rewardInfoB === null)
              throw Error("get lp and reward A / B info error");
            const lpInfo = SPL_ACCOUNT_LAYOUT.decode(_lpInfo.data);
            const rewardInfoA = SPL_ACCOUNT_LAYOUT.decode(_rewardInfoA.data);
            const rewardInfoB = SPL_ACCOUNT_LAYOUT.decode(_rewardInfoB.data);
            let lpAccount = mintToAccount[lpInfo.mint.toString()];
            if (lpAccount === void 0) {
              lpAccount = yield this._selectOrCreateTokenAccount({
                programId: _lpInfo.owner,
                mint: lpInfo.mint,
                tokenAccounts: [],
                owner: wallet,
                createInfo: {
                  connection,
                  payer: wallet,
                  amount: 0,
                  frontInstructions,
                  frontInstructionsType,
                  endInstructions: [],
                  endInstructionsType: [],
                  signers: []
                },
                associatedOnly: true,
                checkCreateATAOwner: true
              });
              mintToAccount[lpInfo.mint.toString()] = lpAccount;
            }
            let rewardAccountA = mintToAccount[rewardInfoA.mint.toString()];
            if (rewardAccountA === void 0) {
              rewardAccountA = yield this._selectOrCreateTokenAccount({
                programId: _rewardInfoA.owner,
                mint: rewardInfoA.mint,
                tokenAccounts: [],
                owner: wallet,
                createInfo: {
                  connection,
                  payer: wallet,
                  amount: 0,
                  frontInstructions,
                  frontInstructionsType,
                  endInstructions: rewardInfoA.mint.toString() === WSOL.mint ? endInstructions : [],
                  endInstructionsType: rewardInfoA.mint.toString() === WSOL.mint ? endInstructionsType : [],
                  signers: []
                },
                associatedOnly: true,
                checkCreateATAOwner: true
              });
              mintToAccount[rewardInfoA.mint.toString()] = rewardAccountA;
            }
            let rewardAccountB = mintToAccount[rewardInfoB.mint.toString()];
            if (rewardAccountB === void 0) {
              rewardAccountB = yield this._selectOrCreateTokenAccount({
                programId: _rewardInfoB.owner,
                mint: rewardInfoB.mint,
                tokenAccounts: [],
                owner: wallet,
                createInfo: {
                  connection,
                  payer: wallet,
                  amount: 0,
                  frontInstructions,
                  frontInstructionsType,
                  endInstructions: rewardInfoB.mint.toString() === WSOL.mint ? endInstructions : [],
                  endInstructionsType: rewardInfoB.mint.toString() === WSOL.mint ? endInstructionsType : [],
                  signers: []
                },
                associatedOnly: true,
                checkCreateATAOwner: true
              });
              mintToAccount[rewardInfoB.mint.toString()] = rewardAccountB;
            }
            if (info.pda === void 0) {
              const _i2 = this.makeCreateAssociatedLedgerAccountInstructionV5({
                // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                // @ts-ignore
                poolKeys: { programId: programIdV5, id: new import_web315.PublicKey(poolId) },
                userKeys: {
                  ledger: this.getAssociatedLedgerAccount({
                    programId: programIdV5,
                    poolId: new import_web315.PublicKey(poolId),
                    owner: wallet,
                    version: 5
                  }),
                  owner: wallet
                }
              });
              instructions.push(_i2.innerTransaction);
            }
            const _i = this.makeDepositInstructionV5({
              amount: 0,
              userKeys: {
                ledger: this.getAssociatedLedgerAccount({
                  programId: programIdV5,
                  poolId: new import_web315.PublicKey(poolId),
                  owner: wallet,
                  version: 5
                }),
                owner: wallet,
                lpTokenAccount: lpAccount,
                rewardTokenAccounts: [rewardAccountA, rewardAccountB],
                auxiliaryLedgers: info.other
              },
              poolKeys: {
                programId: programIdV5,
                id: new import_web315.PublicKey(poolId),
                authority: this.getAssociatedAuthority({ programId: programIdV5, poolId: new import_web315.PublicKey(poolId) }).publicKey,
                lpVault: poolInfo.lpVault,
                // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                // @ts-ignore
                rewardInfos: [{ rewardVault: poolInfo.rewardVaultA }, { rewardVault: poolInfo.rewardVaultB }]
              }
            });
            instructions.push(_i.innerTransaction);
          }
          return {
            address: {},
            innerTransactions: yield splitTxAndSigners({
              connection,
              makeTxVersion,
              computeBudgetConfig,
              payer: wallet,
              innerTransaction: [
                {
                  instructionTypes: frontInstructionsType.slice(0, 10),
                  instructions: frontInstructions.slice(0, 10),
                  signers: []
                },
                ...frontInstructions.length > 10 ? [
                  {
                    instructionTypes: frontInstructionsType.slice(10),
                    instructions: frontInstructions.slice(10),
                    signers: []
                  }
                ] : [],
                ...instructions,
                { instructionTypes: endInstructionsType, instructions: endInstructions, signers: [] }
              ],
              lookupTableCache
            })
          };
        });
      }
      static makeDepositTokenInstruction(_0) {
        return __async(this, arguments, function* ({
          connection,
          programId,
          governanceProgramId,
          voteWeightAddinProgramId,
          realm,
          communityTokenMint,
          owner,
          poolId
        }) {
          const registrar = getRegistrarAddress2(voteWeightAddinProgramId, realm, communityTokenMint).publicKey;
          const ownerPda = this.getAssociatedLedgerAccount({ programId, poolId, owner, version: 3 });
          const ownerAccountInfo = yield connection.getAccountInfo(ownerPda);
          if (ownerAccountInfo === null) {
            throw Error("user is not staker");
          }
          const ownerInfo = FARM_LEDGER_LAYOUT_V3_2.decode(ownerAccountInfo.data);
          const mintAmount = ownerInfo.deposited.sub(ownerInfo.voteLockedBalance);
          if (mintAmount.eq(ZERO2)) {
            throw Error("user do not has new stake amount");
          }
          const votingMint = getVotingTokenMint2(programId, poolId).publicKey;
          const votingMintAuthority = getVotingMintAuthority2(programId, poolId).publicKey;
          const { publicKey: voter, nonce: voterBump } = getVoterAddress2(voteWeightAddinProgramId, registrar, owner);
          const voterVault = getATAAddress2(voter, votingMint, import_spl_token2.TOKEN_PROGRAM_ID).publicKey;
          const { publicKey: voterWeightRecord, nonce: voterWeightRecordBump } = getVoterWeightRecordAddress2(
            voteWeightAddinProgramId,
            registrar,
            owner
          );
          const tokenOwnerRecordAddress = getTokenOwnerRecordAddress2(
            governanceProgramId,
            realm,
            communityTokenMint,
            owner
          ).publicKey;
          const instructions = [];
          const depositToken = getATAAddress2(owner, votingMint, import_spl_token2.TOKEN_PROGRAM_ID).publicKey;
          const depositTokenAccountInfo = yield connection.getAccountInfo(depositToken);
          if (depositTokenAccountInfo === null) {
            instructions.push(
              Spl.makeCreateAssociatedTokenAccountInstruction({
                programId: import_spl_token2.TOKEN_PROGRAM_ID,
                mint: votingMint,
                associatedAccount: depositToken,
                owner,
                payer: owner,
                instructionsType: []
              })
            );
          }
          const voterAccountInfo = yield connection.getAccountInfo(voter);
          if (voterAccountInfo === null) {
            const createTokenOwnerRecodeIns = governanceCreateTokenOwnerRecord2(
              governanceProgramId,
              realm,
              owner,
              communityTokenMint,
              owner,
              tokenOwnerRecordAddress
            );
            instructions.push(
              createTokenOwnerRecodeIns,
              voterStakeRegistryCreateVoter2(
                voteWeightAddinProgramId,
                registrar,
                voter,
                voterWeightRecord,
                owner,
                owner,
                voterBump,
                voterWeightRecordBump
              )
            );
          }
          const { index: depositEntryIndex, isInit: depositEntryInit } = yield getDepositEntryIndex2(
            connection,
            registrar,
            voter,
            votingMint
          );
          if (!depositEntryInit) {
            instructions.push(
              voterStakeRegistryCreateDepositEntry2(
                voteWeightAddinProgramId,
                registrar,
                voter,
                voterVault,
                owner,
                owner,
                votingMint,
                depositEntryIndex,
                0,
                void 0,
                0,
                false
              )
            );
          }
          instructions.push(
            voterStakeRegistryDeposit2(
              voteWeightAddinProgramId,
              registrar,
              voter,
              voterVault,
              depositToken,
              owner,
              ownerPda,
              poolId,
              votingMint,
              votingMintAuthority,
              programId,
              depositEntryIndex,
              mintAmount
            ),
            voterStakeRegistryUpdateVoterWeightRecord2(voteWeightAddinProgramId, registrar, voter, voterWeightRecord)
          );
          return {
            address: {},
            innerTransaction: {
              instructions,
              signers: [],
              lookupTableAddress: [],
              instructionTypes: Array(instructions.length).fill(
                50
                /* test */
              )
            }
          };
        });
      }
      static makeWithdrawTokenInstruction(_0) {
        return __async(this, arguments, function* ({
          connection,
          programId,
          governanceProgramId,
          voteWeightAddinProgramId,
          realm,
          communityTokenMint,
          owner,
          poolId
        }) {
          const registrar = getRegistrarAddress2(voteWeightAddinProgramId, realm, communityTokenMint).publicKey;
          const ownerPda = this.getAssociatedLedgerAccount({ programId, poolId, owner, version: 3 });
          const ownerAccountInfo = yield connection.getAccountInfo(ownerPda);
          if (ownerAccountInfo === null) {
            throw Error("user is not staker");
          }
          const ownerInfo = FARM_LEDGER_LAYOUT_V3_2.decode(ownerAccountInfo.data);
          if (ownerInfo.voteLockedBalance.eq(ZERO2)) {
            throw Error("user has vote locked balance = 0");
          }
          const votingMint = getVotingTokenMint2(programId, poolId).publicKey;
          const votingMintAuthority = getVotingMintAuthority2(programId, poolId).publicKey;
          const { publicKey: voter } = getVoterAddress2(voteWeightAddinProgramId, registrar, owner);
          const voterVault = getATAAddress2(voter, votingMint, import_spl_token2.TOKEN_PROGRAM_ID).publicKey;
          const { publicKey: voterWeightRecord } = getVoterWeightRecordAddress2(voteWeightAddinProgramId, registrar, owner);
          const tokenOwnerRecordAddress = getTokenOwnerRecordAddress2(
            governanceProgramId,
            realm,
            communityTokenMint,
            owner
          ).publicKey;
          const instructions = [];
          const { index: depositEntryIndex, isInit: depositEntryInit } = yield getDepositEntryIndex2(
            connection,
            registrar,
            voter,
            votingMint
          );
          if (!depositEntryInit)
            throw Error("deposit entry index check error");
          instructions.push(
            voterStakeRegistryWithdraw2(
              voteWeightAddinProgramId,
              registrar,
              voter,
              owner,
              tokenOwnerRecordAddress,
              voterWeightRecord,
              voterVault,
              getATAAddress2(owner, votingMint, import_spl_token2.TOKEN_PROGRAM_ID).publicKey,
              ownerPda,
              poolId,
              votingMint,
              votingMintAuthority,
              programId,
              depositEntryIndex,
              ownerInfo.voteLockedBalance
            )
          );
          return {
            address: {},
            innerTransaction: {
              instructions,
              signers: [],
              lookupTableAddress: [],
              instructionTypes: Array(instructions.length).fill(
                50
                /* test */
              )
            }
          };
        });
      }
    };
    function getDepositEntryIndex2(connection, registrar, voter, voterMint) {
      return __async(this, null, function* () {
        const registrarAccountData = yield connection.getAccountInfo(registrar);
        if (registrarAccountData === null)
          throw Error("registrar info check error");
        const registrarData = VoterRegistrar2.decode(registrarAccountData.data);
        const votingMintConfigIndex = registrarData.votingMints.findIndex((i) => i.mint.equals(voterMint));
        if (votingMintConfigIndex === -1)
          throw Error("find voter mint error");
        const voterAccountData = yield connection.getAccountInfo(voter);
        if (voterAccountData === null)
          return { index: votingMintConfigIndex, isInit: false };
        const voterData = Voter2.decode(voterAccountData.data);
        const depositEntryIndex = voterData.deposits.findIndex(
          (i) => i.isUsed && i.votingMintConfigIdx === votingMintConfigIndex
        );
        if (depositEntryIndex === -1)
          return { index: votingMintConfigIndex, isInit: false };
        else
          return { index: depositEntryIndex, isInit: true };
      });
    }
    var MAINNET_FARM_POOLS = [
      {
        id: "AvbVWpBi2e4C9HPmZgShGdPoNydG4Yw8GJvG9HUcLgce",
        lp: MAINNET_LP_TOKENS.RAY_USDT_V4,
        version: 3
      },
      {
        id: "4EwbZo8BZXP5313z5A2H11MRBP15M5n6YxfmkjXESKAW",
        lp: MAINNET_SPL_TOKENS.RAY,
        version: 3
      },
      {
        id: "XnRBbNMf6YcWvC1u2vBXXuMcagmRBRLu1y84mpqnKwW",
        lp: MAINNET_LP_TOKENS.xCOPE_USDC_V4,
        version: 5
      },
      {
        id: "8xhjCzfzVcP79jE7jXR2xtNaSL6aJYoDRLVT9FMjpRTC",
        lp: MAINNET_LP_TOKENS.STEP_USDC_V4,
        version: 5
      },
      {
        id: "Ef1gD9JMzWF6PNw2uc4744zouh57GyWAeVTjHHbQ2nsu",
        lp: MAINNET_LP_TOKENS.MEDIA_USDC_V4,
        version: 5
      },
      {
        id: "AxVvbT9fDFEkmdLwKUJRY5HsG2RXAZbe1dRAgJ2bDDwg",
        lp: MAINNET_LP_TOKENS.COPE_USDC_V4,
        version: 5
      },
      {
        id: "D4pYuD4tbir9KBsb7Kr63v9e86JY2UoUZeFK9eHKQFZM",
        lp: MAINNET_LP_TOKENS.MER_USDC_V4,
        version: 5
      },
      {
        id: "BLy8KuRck5bcJkQdMDLSZnL1Ka4heAZSGiwTJfEfY727",
        lp: MAINNET_LP_TOKENS.ROPE_USDC_V4,
        version: 5
      },
      {
        id: "JAP8SFagJBm6vt2LoFGNeSJ1hKDZ2p3yXb3CvBx11How",
        lp: MAINNET_LP_TOKENS.ALEPH_USDC_V4,
        version: 5
      },
      {
        id: "7U8Z6TWQMtsMcHV2htALnF9VQonnD1MrVm17YtmGEGEw",
        lp: MAINNET_LP_TOKENS.TULIP_USDC_V4,
        version: 5
      },
      {
        id: "31QSh1TwgoA9GbvkgfEEwKEm11t8CR4KiQr6WCyJr7EN",
        lp: MAINNET_LP_TOKENS.SNY_USDC_V4,
        version: 5
      },
      {
        id: "EEe8b72w5q6T86nYRNJdFcY25tznPzrd1jGjuxZ7f9mX",
        lp: MAINNET_LP_TOKENS.BOP_RAY_V4,
        version: 5
      },
      {
        id: "5PVVwSqwzkCvuiKEZwWkM35ApBnoWqF8XopsVZjPwA8z",
        lp: MAINNET_LP_TOKENS.SLRS_USDC_V4,
        version: 5
      },
      {
        id: "Bw932pURVJRYjEJwRZGWjfUNpeyz18kjMNdb833eMxoj",
        lp: MAINNET_LP_TOKENS.SAMO_RAY_V4,
        version: 5
      },
      {
        id: "BRM5bdX2mjmFGg2RAent1Whd61o9asQD16BXsC6QvEni",
        lp: MAINNET_LP_TOKENS.LIKE_USDC_V4,
        version: 5
      },
      {
        id: "HUDr9BDaAGqi37xbQHzxCyXvfMCKPTPNF8g9c9bPu1Fu",
        lp: MAINNET_LP_TOKENS.RAY_SOL_V4,
        version: 3
      },
      {
        id: "CHYrUBX2RKX8iBg7gYTkccoGNBzP44LdaazMHCLcdEgS",
        lp: MAINNET_LP_TOKENS.RAY_USDC_V4,
        version: 3
      },
      {
        id: "B6fbnZZ7sbKHR18ffEDD5Nncgp54iKN1GbCgjTRdqhS1",
        lp: MAINNET_LP_TOKENS.RAY_ETH_V4,
        version: 3
      },
      {
        id: "5DFbcYNLLy5SJiBpCCDzNSs7cWCsUbYnCkLXzcPQiKnR",
        lp: MAINNET_LP_TOKENS.RAY_SRM_V4,
        version: 3
      },
      {
        id: "GzEDEkHSFFfxKMu3Toww1nrEjtbQGJKRPNRK1Pfd59Zn",
        lp: MAINNET_LP_TOKENS.MNGO_USDC_V4,
        version: 5
      },
      {
        id: "CM9XTJfXEHceGPXhmXxheR87Ng9CZ4jiBoTVQHhs9DVN",
        lp: MAINNET_LP_TOKENS.COPE_RAY_V4,
        version: 5
      },
      {
        id: "AMcVWK66iexwwCHn8drxywdNr2UgH3vmRzLXQFdErGmL",
        lp: MAINNET_LP_TOKENS.LIKE_RAY_V4,
        version: 5
      },
      {
        id: "DJfvL6srBht8XFMWYuuKHYGainqvwXyA5icVsDne3pwN",
        lp: MAINNET_LP_TOKENS.MEDIA_RAY_V4,
        version: 5
      },
      {
        id: "21xhrT4j8QnaBvj3QjhP5kZu8sXJMCE7hzHKGtWEkdKr",
        lp: MAINNET_LP_TOKENS.MER_RAY_V4,
        version: 5
      },
      {
        id: "J61AnYYSwjtJ4wDqEqqWSBuZbiR2SDDrtF7FFobutM6a",
        lp: MAINNET_LP_TOKENS.SLRS_RAY_V4,
        version: 5
      },
      {
        id: "JEC3P83x2GEijYDwXiksuh5H6YrQt5xW6MC2GDKkMoe",
        lp: MAINNET_LP_TOKENS.SNY_RAY_V4,
        version: 5
      },
      {
        id: "BmbG9hv5PazcW3rYWvatA6HpNPkozEdkWBiU64pZxuwr",
        lp: MAINNET_LP_TOKENS.TULIP_RAY_V4,
        version: 5
      },
      {
        id: "4wvZ9SwWaHKTpshQbCSKQoPosZp9KGwUzuQdESi39qPn",
        lp: MAINNET_LP_TOKENS.ALEPH_RAY_V4,
        version: 5
      },
      {
        id: "BnYoq5y2MoH4TsBHeEZrEPowhwebHxQq7nJW1vTjPTWu",
        lp: MAINNET_LP_TOKENS.RAY_SRM_V4,
        version: 5
      },
      {
        id: "93wRz2LeQ3TJoair827VTng62MjCzYDgJjG9Q5GmQ3Pd",
        lp: MAINNET_LP_TOKENS.ATLAS_USDC_V4,
        version: 5
      },
      {
        id: "7qcihXTsRW5wS5BgK7iuD84W43ECByoJP45R3hu2r6mF",
        lp: MAINNET_LP_TOKENS.POLIS_USDC_V4,
        version: 5
      },
      {
        id: "BHHhNLdJn69K1XPJcpcw4MBY3TPetpLxhj8s4K4ydsDV",
        lp: MAINNET_LP_TOKENS.ATLAS_RAY_V4,
        version: 5
      },
      {
        id: "HHm8Pgnzc56fTUYkicPv4DqGYp5fcPZFV1V1uhixSrMk",
        lp: MAINNET_LP_TOKENS.POLIS_RAY_V4,
        version: 5
      },
      {
        id: "8GBa1cK1NxevoxiRNK6YW9tWuo2xftcA3as9Cu4nhFL7",
        lp: MAINNET_LP_TOKENS.GRAPE_USDC_V4,
        version: 5
      },
      {
        id: "HzxveT6pUMwYByqnScvTbpUv4avzkUDrDpS9D7DToEry",
        lp: MAINNET_LP_TOKENS.LARIX_USDC_V4,
        version: 5
      },
      {
        id: "Fbwy4XWMjXuP1nXg4xph4RJ9E9twVXeknXokF38PVgG1",
        lp: MAINNET_LP_TOKENS.LARIX_RAY_V4,
        version: 5
      },
      {
        id: "5gzQgxaKAU13SZeffmjjE2y9HwMJ42FxQkqJhJ5nqHeh",
        lp: MAINNET_LP_TOKENS.stSOL_USDC_V4,
        version: 5
      },
      {
        id: "914jyHBQFiroKFVCpKkzjGSaZyr4gMwgxE7snbNfGjnL",
        lp: MAINNET_LP_TOKENS.BTC_mSOL_V4,
        version: 5
      },
      {
        id: "54vUWjEmg9wfCsZF7wwq2HJu5BU3cfDFAQQQgXPECcwE",
        lp: MAINNET_LP_TOKENS.ETH_mSOL_V4,
        version: 5
      },
      {
        id: "HxhxYASqdLcR6yehT9hB9HUpgcF1R2t9HtkHdngGZ2Dh",
        lp: MAINNET_LP_TOKENS.mSOL_USDT_V4,
        version: 5
      },
      {
        id: "97N6tPMVCrAunC9embwTcffye9xC95fA5y3LauhNZ444",
        lp: MAINNET_LP_TOKENS.MNDE_mSOL_V4,
        version: 5
      },
      {
        id: "DjtZxyFBgifzpaZEzfsWXogNX5zUCnTRXJqarGe9CiSv",
        lp: MAINNET_LP_TOKENS.mSOL_USDC_V4,
        version: 5
      },
      {
        id: "7wNhbTS6XQczXs52wcVmfiodRMPfycB3YaG52dWWY6SD",
        lp: MAINNET_LP_TOKENS.mSOL_RAY_V4,
        version: 5
      },
      {
        id: "CzKUrVbP7hH8EjcHNc55ZFW33rJyLQ2r52bxCzaGTpz",
        lp: MAINNET_LP_TOKENS.LIQ_USDC_V4,
        version: 5
      },
      {
        id: "5XdeFdcJoCAPMfgYndMPcsijFBKFp2cPSCjrCZzmpTE5",
        lp: MAINNET_LP_TOKENS.LIQ_RAY_V4,
        version: 5
      },
      {
        id: "Gf3qFzKnGvMCVMQZERW2Qso5uEYxd9B9kWZZHsrMmmHj",
        lp: MAINNET_LP_TOKENS.SYP_RAY_V4,
        version: 5
      },
      {
        id: "2pQQnoNpm5LoG6sZs5toNBXi4m1Pj3ExXdggPQYyiP2x",
        lp: MAINNET_LP_TOKENS.SYP_SOL_V4,
        version: 5
      },
      {
        id: "Byt2kL5qi45pMpdAsNNciKZ8HLp7oU5jizCbyARLtQJy",
        lp: MAINNET_LP_TOKENS.SYP_USDC_V4,
        version: 5
      },
      {
        id: "8W2TqGCiFiqR1JD4sbW8uTRjV2HvFjLhkZ2tAQTYE4Gc",
        lp: MAINNET_LP_TOKENS.WOOF_RAY_V4,
        version: 5
      },
      {
        id: "FgApVk6mASrkuWNxmsFvsaAYkFKqdiwMTvYZK36A2DaC",
        lp: MAINNET_LP_TOKENS.KIN_RAY_V4,
        version: 5
      },
      {
        id: "AwUDfg4NYbLQRAcFipoJwyZTpqNvw5v6C7EypryL12Y6",
        lp: MAINNET_LP_TOKENS.STARS_USDC_V4,
        version: 5
      },
      {
        id: "Gi3Z6TXeH1ZhCCbwg6oJL8SE4LcmxmGRNhhfA6NZhwTK",
        lp: MAINNET_LP_TOKENS.weWETH_SOL_V4,
        version: 5
      },
      {
        id: "8JJSdD1ca5SDtGCEm3yBbQKek2FvJ1EbNt9q2ET3E9Jt",
        lp: MAINNET_LP_TOKENS.weWETH_USDC_V4,
        version: 5
      },
      {
        id: "6X495xkPWkw9SQFYf7yL1K8QooZyaeEQ6u7yMWNNZxNV",
        lp: MAINNET_LP_TOKENS.weUNI_USDC_V4,
        version: 5
      },
      {
        id: "AuyqPBiY6sNUpH6jx415NGcdvNdYbkbYsyVabUqEVdkj",
        lp: MAINNET_LP_TOKENS.weSUSHI_USDC_V4,
        version: 5
      },
      {
        id: "7fe8QcJ6W2kHKL1h1HMYYJoGXz2LUcwCjkxX6MX35orK",
        lp: MAINNET_LP_TOKENS.weAXS_USDC_V4,
        version: 5
      },
      {
        id: "C8BjS9DGDvC2zS3n6fTvm1rjPbA33uZ7CAvEUZ3tg7aM",
        lp: MAINNET_LP_TOKENS.weDYDX_USDC_V4,
        version: 5
      },
      {
        id: "CZZnmfvSgNVUiDBG4wN2NNcaYbsKDN4kLsc3SN8DMw6i",
        lp: MAINNET_LP_TOKENS.weSHIB_USDC_V4,
        version: 5
      },
      {
        id: "FAKzZoGVCEBDRuHN4gDswAx7PsocCorDqH6dQaxnyorT",
        lp: MAINNET_LP_TOKENS.weSAND_USDC_V4,
        version: 5
      },
      {
        id: "EBS8tc4proQE2Fj6HxU4piiZP8oiDrvyJUijDCX7P7QN",
        lp: MAINNET_LP_TOKENS.weMANA_USDC_V4,
        version: 5
      },
      {
        id: "6AxxjJhAz6APspTQM4vVCHgfzEyZgBTCogJLdai7bXYE",
        lp: MAINNET_LP_TOKENS.wbWBNB_USDC_V4,
        version: 5
      },
      {
        id: "3HGPRHH3XFFu972MR1EdS65qc1nN9sM7miZtFTi6QcEd",
        lp: MAINNET_LP_TOKENS.wePEOPLE_USDC_V4,
        version: 5
      },
      {
        id: "27bysJaX5eu5Urb5kftR66otiVc6DKK7TnifKwnpNzYu",
        lp: MAINNET_LP_TOKENS.SRM_USDC_V4,
        version: 5
      },
      {
        id: "FDnxy4NkJVG3GNMMrtUZmUmoYeYE34YRDwCYTi1yBTM",
        lp: MAINNET_LP_TOKENS.CAVE_USDC_V4,
        version: 5
      },
      {
        id: "DDRNVVJBEXEemcprVVUcrTbYnR88JyN6jjT2ypgAQHC8",
        lp: MAINNET_LP_TOKENS.GENE_USDC_V4,
        version: 5
      },
      {
        id: "GVfLbXA3dpEHPvc4do9HvMZ8TACxm3x54BVrHPMEixcr",
        lp: MAINNET_LP_TOKENS.GENE_RAY_V4,
        version: 5
      },
      {
        id: "7NZ18KhsSdJBQkJEJwhEHfdaPRNdbMd17CMoxsKxavEo",
        lp: MAINNET_LP_TOKENS.CWAR_USDC_V4,
        version: 5
      },
      {
        id: "5Mdq5o3KKPyeVVBsbnivVk9qCATjfEQ22oysXVsd2DvJ",
        lp: MAINNET_LP_TOKENS.SONAR_USDC_V4,
        version: 5
      },
      {
        id: "7W8BKbMgcVpGYvTgEK758pJgDRZJ9WafKfgkV1XCkP33",
        lp: MAINNET_LP_TOKENS.APT_USDC_V4,
        version: 5
      },
      {
        id: "CgokwBwwdYsgo8hbUMtJ3GoNM3bVjvMcmaPrVvCw4sBi",
        lp: MAINNET_LP_TOKENS.SHILL_USDC_V4,
        version: 5
      },
      {
        id: "AWbmotuJS7NLBmra9ctbfVR1BnoHmiG1HGW6hm49TuRZ",
        lp: MAINNET_LP_TOKENS.DFL_USDC_V4,
        version: 5
      },
      {
        id: "665VvECKsLpXN4fLy8GYbyQpGJRNkxRx56X93U9FVSbv",
        lp: MAINNET_LP_TOKENS.BOKU_USDC_V4,
        version: 5
      },
      {
        id: "7yk1XUWmZpWMCoFpUT985z61UNTypyBGgZF3JpKgcwmL",
        lp: MAINNET_LP_TOKENS.MIMO_SOL_V4,
        version: 5
      },
      {
        id: "E5L4Bx3Lsif7bDb9XMWi5guHUt4kkYpbqQ4CbmnRjHs1",
        lp: MAINNET_LP_TOKENS.XTAG_USDC_V4,
        version: 5
      },
      {
        id: "HtvQ5AEvu8sDM7C1oB4r5fJ5E2Q1wsJ4TADwNMqR9ccF",
        lp: MAINNET_LP_TOKENS.TTT_USDC_V4,
        version: 5
      },
      {
        id: "GUzaohfNuFbBqQTnPgPSNciv3aUvriXYjQduRE3ZkqFw",
        lp: MAINNET_LP_TOKENS.SOL_USDC_V4,
        version: 5
      },
      {
        id: "5r878BSWPtoXgnqaeFJi7BCycKZ5CodBB2vS9SeiV8q",
        lp: MAINNET_LP_TOKENS.SOL_USDT_V4,
        version: 5
      },
      {
        id: "3J3SYLeFZWKnUCsrPzikw9bcD9vRs7YNGfmg7ZSg3tsK",
        lp: MAINNET_LP_TOKENS.RUN_USDC_V4,
        version: 5
      },
      {
        id: "BYmeWrwA4ixvJhNrxWzQsA3Fsz6EtUDJTo39WYZ6o1FS",
        lp: MAINNET_LP_TOKENS.CRWNY_RAY_V4,
        version: 5
      },
      {
        id: "6VNF4rF7ESUohzNeRf3aTg61dyFjbab749RGUHCTDFQL",
        lp: MAINNET_LP_TOKENS.CRWNY_USDC_V4,
        version: 5
      },
      {
        id: "7RQDGZ1cvHcREu211R35WSKHFjTxM5dmJHeFAWag29BA",
        lp: MAINNET_LP_TOKENS.REAL_USDC_V4,
        version: 5
      },
      {
        id: "ELovJ3jDKMiWhCUCdZzPfTeVmQwhj4cvYuGwS8FfhEtJ",
        lp: MAINNET_LP_TOKENS.BLOCK_USDC_V4,
        version: 5
      },
      {
        id: "36Rf8dzq5gy4Ew2bLQEgKoCKVTku4EJPLqFYG6mzFrkr",
        lp: MAINNET_LP_TOKENS.FRKT_SOL_V4,
        version: 5
      },
      {
        id: "HXpQJeAcBCKfGY6YhZgBocZGgV4xApPVK7r8CPXfvCin",
        lp: MAINNET_LP_TOKENS.FRKT_USDC_V4,
        version: 5
      },
      {
        id: "Eqn7unnxmneDuTuXQ7EAN1wBkHMFD4LgCCAkCdPA9KbV",
        lp: MAINNET_LP_TOKENS.MBS_USDC_V4,
        version: 5
      },
      {
        id: "DtU5pZB99rVtxe5qe5hQa2rRpw7poFiqaHvMAbPgT2TM",
        lp: MAINNET_LP_TOKENS.PRISM_USDC_V4,
        version: 5
      },
      {
        id: "Gue2c9J2aRtY3aJ1HEwabQznwg2MUt9d9kUyr6otujR",
        lp: MAINNET_LP_TOKENS.CHICKS_USDC_V4,
        version: 5
      },
      {
        id: "Ej7iBkW79EdF26RxaRQfGo58PqRdzHzRmE4C2e3z3dPY",
        lp: MAINNET_LP_TOKENS.MEAN_RAY_V4,
        version: 5
      },
      {
        id: "Bd1hAsMAghtCjK38Ut4m938Ep7zyEp2TydQ7G35nPvUj",
        lp: MAINNET_LP_TOKENS.TINY_USDC_V4,
        version: 5
      },
      {
        id: "2G7qTQzw3KXm7WEMJf2izqFQWh8CLZ1wFbQVP5qo3ME9",
        lp: MAINNET_LP_TOKENS.SCY_USDC_V4,
        version: 5
      }
    ];
    var TESTNET_FARM_POOLS = [];
    var DEVNET_FARM_POOLS = [];
    var LIQUIDITY_STATE_LAYOUT_V4 = struct3([
      u643("status"),
      u643("nonce"),
      u643("maxOrder"),
      u643("depth"),
      u643("baseDecimal"),
      u643("quoteDecimal"),
      u643("state"),
      u643("resetFlag"),
      u643("minSize"),
      u643("volMaxCutRatio"),
      u643("amountWaveRatio"),
      u643("baseLotSize"),
      u643("quoteLotSize"),
      u643("minPriceMultiplier"),
      u643("maxPriceMultiplier"),
      u643("systemDecimalValue"),
      u643("minSeparateNumerator"),
      u643("minSeparateDenominator"),
      u643("tradeFeeNumerator"),
      u643("tradeFeeDenominator"),
      u643("pnlNumerator"),
      u643("pnlDenominator"),
      u643("swapFeeNumerator"),
      u643("swapFeeDenominator"),
      u643("baseNeedTakePnl"),
      u643("quoteNeedTakePnl"),
      u643("quoteTotalPnl"),
      u643("baseTotalPnl"),
      u643("poolOpenTime"),
      u643("punishPcAmount"),
      u643("punishCoinAmount"),
      u643("orderbookToInitTime"),
      // u128('poolTotalDepositPc'),
      // u128('poolTotalDepositCoin'),
      u1283("swapBaseInAmount"),
      u1283("swapQuoteOutAmount"),
      u643("swapBase2QuoteFee"),
      u1283("swapQuoteInAmount"),
      u1283("swapBaseOutAmount"),
      u643("swapQuote2BaseFee"),
      // amm vault
      publicKey3("baseVault"),
      publicKey3("quoteVault"),
      // mint
      publicKey3("baseMint"),
      publicKey3("quoteMint"),
      publicKey3("lpMint"),
      // market
      publicKey3("openOrders"),
      publicKey3("marketId"),
      publicKey3("marketProgramId"),
      publicKey3("targetOrders"),
      publicKey3("withdrawQueue"),
      publicKey3("lpVault"),
      publicKey3("owner"),
      // true circulating supply without lock up
      u643("lpReserve"),
      seq22(u643(), 3, "padding")
    ]);
    var LIQUIDITY_STATE_LAYOUT_V5 = struct3([
      u643("accountType"),
      u643("status"),
      u643("nonce"),
      u643("maxOrder"),
      u643("depth"),
      u643("baseDecimal"),
      u643("quoteDecimal"),
      u643("state"),
      u643("resetFlag"),
      u643("minSize"),
      u643("volMaxCutRatio"),
      u643("amountWaveRatio"),
      u643("baseLotSize"),
      u643("quoteLotSize"),
      u643("minPriceMultiplier"),
      u643("maxPriceMultiplier"),
      u643("systemDecimalsValue"),
      u643("abortTradeFactor"),
      u643("priceTickMultiplier"),
      u643("priceTick"),
      // Fees
      u643("minSeparateNumerator"),
      u643("minSeparateDenominator"),
      u643("tradeFeeNumerator"),
      u643("tradeFeeDenominator"),
      u643("pnlNumerator"),
      u643("pnlDenominator"),
      u643("swapFeeNumerator"),
      u643("swapFeeDenominator"),
      // OutPutData
      u643("baseNeedTakePnl"),
      u643("quoteNeedTakePnl"),
      u643("quoteTotalPnl"),
      u643("baseTotalPnl"),
      u643("poolOpenTime"),
      u643("punishPcAmount"),
      u643("punishCoinAmount"),
      u643("orderbookToInitTime"),
      u1283("swapBaseInAmount"),
      u1283("swapQuoteOutAmount"),
      u1283("swapQuoteInAmount"),
      u1283("swapBaseOutAmount"),
      u643("swapQuote2BaseFee"),
      u643("swapBase2QuoteFee"),
      publicKey3("baseVault"),
      publicKey3("quoteVault"),
      publicKey3("baseMint"),
      publicKey3("quoteMint"),
      publicKey3("lpMint"),
      publicKey3("modelDataAccount"),
      publicKey3("openOrders"),
      publicKey3("marketId"),
      publicKey3("marketProgramId"),
      publicKey3("targetOrders"),
      publicKey3("owner"),
      seq22(u643(), 64, "padding")
    ]);
    var LIQUIDITY_VERSION_TO_STATE_LAYOUT2 = {
      4: LIQUIDITY_STATE_LAYOUT_V4,
      5: LIQUIDITY_STATE_LAYOUT_V5
    };
    var import_web3222 = require("@solana/web3.js");
    var import_bn16 = __toESM2(require_bn());
    var import_spl_token6 = require_cjs5();
    var import_web318 = require("@solana/web3.js");
    var import_bn15 = __toESM2(require_bn());
    var import_decimal3 = __toESM2(require_decimal3());
    var import_spl_token5 = require_cjs5();
    var import_web316 = require("@solana/web3.js");
    var anchorDataBuf22 = {
      createPool: [233, 146, 209, 142, 207, 104, 64, 188],
      initReward: [95, 135, 192, 196, 242, 129, 230, 68],
      setRewardEmissions: [112, 52, 167, 75, 32, 201, 211, 137],
      openPosition: [77, 184, 74, 214, 112, 86, 241, 199],
      closePosition: [123, 134, 81, 0, 49, 68, 98, 98],
      increaseLiquidity: [133, 29, 89, 223, 69, 238, 176, 10],
      decreaseLiquidity: [58, 127, 188, 62, 79, 82, 196, 96],
      swap: [43, 4, 237, 11, 26, 201, 30, 98],
      // [248, 198, 158, 145, 225, 117, 135, 200],
      collectReward: [18, 237, 166, 197, 34, 16, 213, 144]
    };
    function createPoolInstruction(programId, poolId, poolCreator, ammConfigId, observationId, mintA, mintVaultA, mintProgramIdA, mintB, mintVaultB, mintProgramIdB, exTickArrayBitmap, sqrtPriceX64, startTime) {
      const dataLayout = struct3([u1283("sqrtPriceX64"), u643("startTime")]);
      const keys = [
        { pubkey: poolCreator, isSigner: true, isWritable: true },
        { pubkey: ammConfigId, isSigner: false, isWritable: false },
        { pubkey: poolId, isSigner: false, isWritable: true },
        { pubkey: mintA, isSigner: false, isWritable: false },
        { pubkey: mintB, isSigner: false, isWritable: false },
        { pubkey: mintVaultA, isSigner: false, isWritable: true },
        { pubkey: mintVaultB, isSigner: false, isWritable: true },
        { pubkey: observationId, isSigner: false, isWritable: false },
        { pubkey: exTickArrayBitmap, isSigner: false, isWritable: true },
        { pubkey: mintProgramIdA, isSigner: false, isWritable: false },
        { pubkey: mintProgramIdB, isSigner: false, isWritable: false },
        { pubkey: SYSTEM_PROGRAM_ID2, isSigner: false, isWritable: false },
        { pubkey: RENT_PROGRAM_ID2, isSigner: false, isWritable: false }
      ];
      const data = Buffer.alloc(dataLayout.span);
      dataLayout.encode(
        {
          sqrtPriceX64,
          startTime
        },
        data
      );
      const aData = Buffer.from([...anchorDataBuf22.createPool, ...data]);
      return new import_web316.TransactionInstruction({
        keys,
        programId,
        data: aData
      });
    }
    function openPositionFromLiquidityInstruction(programId, payer, poolId, positionNftOwner, positionNftMint, positionNftAccount, metadataAccount, protocolPosition, tickArrayLower, tickArrayUpper, personalPosition, ownerTokenAccountA, ownerTokenAccountB, tokenVaultA, tokenVaultB, tokenMintA, tokenMintB, tickLowerIndex, tickUpperIndex, tickArrayLowerStartIndex, tickArrayUpperStartIndex, liquidity, amountMaxA, amountMaxB, withMetadata, exTickArrayBitmap) {
      const dataLayout = struct3([
        s322("tickLowerIndex"),
        s322("tickUpperIndex"),
        s322("tickArrayLowerStartIndex"),
        s322("tickArrayUpperStartIndex"),
        u1283("liquidity"),
        u643("amountMaxA"),
        u643("amountMaxB"),
        bool22("withMetadata"),
        u822("optionBaseFlag"),
        bool22("baseFlag")
      ]);
      const remainingAccounts = [
        ...exTickArrayBitmap ? [{ pubkey: exTickArrayBitmap, isSigner: false, isWritable: true }] : []
      ];
      const keys = [
        { pubkey: payer, isSigner: true, isWritable: true },
        { pubkey: positionNftOwner, isSigner: false, isWritable: false },
        { pubkey: positionNftMint, isSigner: true, isWritable: true },
        { pubkey: positionNftAccount, isSigner: false, isWritable: true },
        { pubkey: metadataAccount, isSigner: false, isWritable: true },
        { pubkey: poolId, isSigner: false, isWritable: true },
        { pubkey: protocolPosition, isSigner: false, isWritable: true },
        { pubkey: tickArrayLower, isSigner: false, isWritable: true },
        { pubkey: tickArrayUpper, isSigner: false, isWritable: true },
        { pubkey: personalPosition, isSigner: false, isWritable: true },
        { pubkey: ownerTokenAccountA, isSigner: false, isWritable: true },
        { pubkey: ownerTokenAccountB, isSigner: false, isWritable: true },
        { pubkey: tokenVaultA, isSigner: false, isWritable: true },
        { pubkey: tokenVaultB, isSigner: false, isWritable: true },
        { pubkey: RENT_PROGRAM_ID2, isSigner: false, isWritable: false },
        { pubkey: SYSTEM_PROGRAM_ID2, isSigner: false, isWritable: false },
        { pubkey: import_spl_token2.TOKEN_PROGRAM_ID, isSigner: false, isWritable: false },
        { pubkey: import_spl_token2.ASSOCIATED_TOKEN_PROGRAM_ID, isSigner: false, isWritable: false },
        { pubkey: METADATA_PROGRAM_ID2, isSigner: false, isWritable: false },
        { pubkey: import_spl_token5.TOKEN_2022_PROGRAM_ID, isSigner: false, isWritable: false },
        { pubkey: tokenMintA, isSigner: false, isWritable: false },
        { pubkey: tokenMintB, isSigner: false, isWritable: false },
        ...remainingAccounts
      ];
      const data = Buffer.alloc(dataLayout.span);
      dataLayout.encode(
        {
          tickLowerIndex,
          tickUpperIndex,
          tickArrayLowerStartIndex,
          tickArrayUpperStartIndex,
          liquidity,
          amountMaxA,
          amountMaxB,
          withMetadata: withMetadata === "create",
          baseFlag: false,
          optionBaseFlag: 0
        },
        data
      );
      const aData = Buffer.from([...anchorDataBuf22.openPosition, ...data]);
      return new import_web316.TransactionInstruction({
        keys,
        programId,
        data: aData
      });
    }
    function openPositionFromBaseInstruction(programId, payer, poolId, positionNftOwner, positionNftMint, positionNftAccount, metadataAccount, protocolPosition, tickArrayLower, tickArrayUpper, personalPosition, ownerTokenAccountA, ownerTokenAccountB, tokenVaultA, tokenVaultB, tokenMintA, tokenMintB, tickLowerIndex, tickUpperIndex, tickArrayLowerStartIndex, tickArrayUpperStartIndex, withMetadata, base, baseAmount, otherAmountMax, exTickArrayBitmap) {
      const dataLayout = struct3([
        s322("tickLowerIndex"),
        s322("tickUpperIndex"),
        s322("tickArrayLowerStartIndex"),
        s322("tickArrayUpperStartIndex"),
        u1283("liquidity"),
        u643("amountMaxA"),
        u643("amountMaxB"),
        bool22("withMetadata"),
        u822("optionBaseFlag"),
        bool22("baseFlag")
      ]);
      const remainingAccounts = [
        ...exTickArrayBitmap ? [{ pubkey: exTickArrayBitmap, isSigner: false, isWritable: true }] : []
      ];
      const keys = [
        { pubkey: payer, isSigner: true, isWritable: true },
        { pubkey: positionNftOwner, isSigner: false, isWritable: false },
        { pubkey: positionNftMint, isSigner: true, isWritable: true },
        { pubkey: positionNftAccount, isSigner: false, isWritable: true },
        { pubkey: metadataAccount, isSigner: false, isWritable: true },
        { pubkey: poolId, isSigner: false, isWritable: true },
        { pubkey: protocolPosition, isSigner: false, isWritable: true },
        { pubkey: tickArrayLower, isSigner: false, isWritable: true },
        { pubkey: tickArrayUpper, isSigner: false, isWritable: true },
        { pubkey: personalPosition, isSigner: false, isWritable: true },
        { pubkey: ownerTokenAccountA, isSigner: false, isWritable: true },
        { pubkey: ownerTokenAccountB, isSigner: false, isWritable: true },
        { pubkey: tokenVaultA, isSigner: false, isWritable: true },
        { pubkey: tokenVaultB, isSigner: false, isWritable: true },
        { pubkey: RENT_PROGRAM_ID2, isSigner: false, isWritable: false },
        { pubkey: SYSTEM_PROGRAM_ID2, isSigner: false, isWritable: false },
        { pubkey: import_spl_token2.TOKEN_PROGRAM_ID, isSigner: false, isWritable: false },
        { pubkey: import_spl_token2.ASSOCIATED_TOKEN_PROGRAM_ID, isSigner: false, isWritable: false },
        { pubkey: METADATA_PROGRAM_ID2, isSigner: false, isWritable: false },
        { pubkey: import_spl_token5.TOKEN_2022_PROGRAM_ID, isSigner: false, isWritable: false },
        { pubkey: tokenMintA, isSigner: false, isWritable: false },
        { pubkey: tokenMintB, isSigner: false, isWritable: false },
        ...remainingAccounts
      ];
      const data = Buffer.alloc(dataLayout.span);
      dataLayout.encode(
        {
          tickLowerIndex,
          tickUpperIndex,
          tickArrayLowerStartIndex,
          tickArrayUpperStartIndex,
          liquidity: ZERO2,
          amountMaxA: base === "MintA" ? baseAmount : otherAmountMax,
          amountMaxB: base === "MintA" ? otherAmountMax : baseAmount,
          withMetadata: withMetadata === "create",
          baseFlag: base === "MintA",
          optionBaseFlag: 1
        },
        data
      );
      const aData = Buffer.from([...anchorDataBuf22.openPosition, ...data]);
      return new import_web316.TransactionInstruction({
        keys,
        programId,
        data: aData
      });
    }
    function closePositionInstruction(programId, positionNftOwner, positionNftMint, positionNftAccount, personalPosition) {
      const dataLayout = struct3([]);
      const keys = [
        { pubkey: positionNftOwner, isSigner: true, isWritable: true },
        { pubkey: positionNftMint, isSigner: false, isWritable: true },
        { pubkey: positionNftAccount, isSigner: false, isWritable: true },
        { pubkey: personalPosition, isSigner: false, isWritable: true },
        { pubkey: SYSTEM_PROGRAM_ID2, isSigner: false, isWritable: false },
        { pubkey: import_spl_token2.TOKEN_PROGRAM_ID, isSigner: false, isWritable: false }
      ];
      const data = Buffer.alloc(dataLayout.span);
      dataLayout.encode({}, data);
      const aData = Buffer.from([...anchorDataBuf22.closePosition, ...data]);
      return new import_web316.TransactionInstruction({
        keys,
        programId,
        data: aData
      });
    }
    function increasePositionFromLiquidityInstruction(programId, positionNftOwner, positionNftAccount, personalPosition, poolId, protocolPosition, tickArrayLower, tickArrayUpper, ownerTokenAccountA, ownerTokenAccountB, mintVaultA, mintVaultB, mintMintA, mintMintB, liquidity, amountMaxA, amountMaxB, exTickArrayBitmap) {
      const dataLayout = struct3([
        u1283("liquidity"),
        u643("amountMaxA"),
        u643("amountMaxB"),
        u822("optionBaseFlag"),
        bool22("baseFlag")
      ]);
      const remainingAccounts = [
        ...exTickArrayBitmap ? [{ pubkey: exTickArrayBitmap, isSigner: false, isWritable: true }] : []
      ];
      const keys = [
        { pubkey: positionNftOwner, isSigner: true, isWritable: false },
        { pubkey: positionNftAccount, isSigner: false, isWritable: false },
        { pubkey: poolId, isSigner: false, isWritable: true },
        { pubkey: protocolPosition, isSigner: false, isWritable: true },
        { pubkey: personalPosition, isSigner: false, isWritable: true },
        { pubkey: tickArrayLower, isSigner: false, isWritable: true },
        { pubkey: tickArrayUpper, isSigner: false, isWritable: true },
        { pubkey: ownerTokenAccountA, isSigner: false, isWritable: true },
        { pubkey: ownerTokenAccountB, isSigner: false, isWritable: true },
        { pubkey: mintVaultA, isSigner: false, isWritable: true },
        { pubkey: mintVaultB, isSigner: false, isWritable: true },
        { pubkey: import_spl_token2.TOKEN_PROGRAM_ID, isSigner: false, isWritable: false },
        { pubkey: import_spl_token5.TOKEN_2022_PROGRAM_ID, isSigner: false, isWritable: false },
        { pubkey: mintMintA, isSigner: false, isWritable: false },
        { pubkey: mintMintB, isSigner: false, isWritable: false },
        ...remainingAccounts
      ];
      const data = Buffer.alloc(dataLayout.span);
      dataLayout.encode(
        {
          liquidity,
          amountMaxA,
          amountMaxB,
          optionBaseFlag: 0,
          baseFlag: false
        },
        data
      );
      const aData = Buffer.from([...anchorDataBuf22.increaseLiquidity, ...data]);
      return new import_web316.TransactionInstruction({
        keys,
        programId,
        data: aData
      });
    }
    function increasePositionFromBaseInstruction(programId, positionNftOwner, positionNftAccount, personalPosition, poolId, protocolPosition, tickArrayLower, tickArrayUpper, ownerTokenAccountA, ownerTokenAccountB, mintVaultA, mintVaultB, mintMintA, mintMintB, base, baseAmount, otherAmountMax, exTickArrayBitmap) {
      const dataLayout = struct3([
        u1283("liquidity"),
        u643("amountMaxA"),
        u643("amountMaxB"),
        u822("optionBaseFlag"),
        bool22("baseFlag")
      ]);
      const remainingAccounts = [
        ...exTickArrayBitmap ? [{ pubkey: exTickArrayBitmap, isSigner: false, isWritable: true }] : []
      ];
      const keys = [
        { pubkey: positionNftOwner, isSigner: true, isWritable: false },
        { pubkey: positionNftAccount, isSigner: false, isWritable: false },
        { pubkey: poolId, isSigner: false, isWritable: true },
        { pubkey: protocolPosition, isSigner: false, isWritable: true },
        { pubkey: personalPosition, isSigner: false, isWritable: true },
        { pubkey: tickArrayLower, isSigner: false, isWritable: true },
        { pubkey: tickArrayUpper, isSigner: false, isWritable: true },
        { pubkey: ownerTokenAccountA, isSigner: false, isWritable: true },
        { pubkey: ownerTokenAccountB, isSigner: false, isWritable: true },
        { pubkey: mintVaultA, isSigner: false, isWritable: true },
        { pubkey: mintVaultB, isSigner: false, isWritable: true },
        { pubkey: import_spl_token2.TOKEN_PROGRAM_ID, isSigner: false, isWritable: false },
        { pubkey: import_spl_token5.TOKEN_2022_PROGRAM_ID, isSigner: false, isWritable: false },
        { pubkey: mintMintA, isSigner: false, isWritable: false },
        { pubkey: mintMintB, isSigner: false, isWritable: false },
        ...remainingAccounts
      ];
      const data = Buffer.alloc(dataLayout.span);
      dataLayout.encode(
        {
          liquidity: ZERO2,
          amountMaxA: base === "MintA" ? baseAmount : otherAmountMax,
          amountMaxB: base === "MintA" ? otherAmountMax : baseAmount,
          baseFlag: base === "MintA",
          optionBaseFlag: 1
        },
        data
      );
      const aData = Buffer.from([...anchorDataBuf22.increaseLiquidity, ...data]);
      return new import_web316.TransactionInstruction({
        keys,
        programId,
        data: aData
      });
    }
    function decreaseLiquidityInstruction(programId, positionNftOwner, positionNftAccount, personalPosition, poolId, protocolPosition, tickArrayLower, tickArrayUpper, ownerTokenAccountA, ownerTokenAccountB, mintVaultA, mintVaultB, mintMintA, mintMintB, rewardAccounts, liquidity, amountMinA, amountMinB, exTickArrayBitmap) {
      const dataLayout = struct3([u1283("liquidity"), u643("amountMinA"), u643("amountMinB")]);
      const remainingAccounts = [
        ...exTickArrayBitmap ? [{ pubkey: exTickArrayBitmap, isSigner: false, isWritable: true }] : [],
        ...rewardAccounts.map((i) => [
          { pubkey: i.poolRewardVault, isSigner: false, isWritable: true },
          { pubkey: i.ownerRewardVault, isSigner: false, isWritable: true },
          { pubkey: i.rewardMint, isSigner: false, isWritable: false }
        ]).flat()
      ];
      const keys = [
        { pubkey: positionNftOwner, isSigner: true, isWritable: false },
        { pubkey: positionNftAccount, isSigner: false, isWritable: false },
        { pubkey: personalPosition, isSigner: false, isWritable: true },
        { pubkey: poolId, isSigner: false, isWritable: true },
        { pubkey: protocolPosition, isSigner: false, isWritable: true },
        { pubkey: mintVaultA, isSigner: false, isWritable: true },
        { pubkey: mintVaultB, isSigner: false, isWritable: true },
        { pubkey: tickArrayLower, isSigner: false, isWritable: true },
        { pubkey: tickArrayUpper, isSigner: false, isWritable: true },
        { pubkey: ownerTokenAccountA, isSigner: false, isWritable: true },
        { pubkey: ownerTokenAccountB, isSigner: false, isWritable: true },
        { pubkey: import_spl_token2.TOKEN_PROGRAM_ID, isSigner: false, isWritable: false },
        { pubkey: import_spl_token5.TOKEN_2022_PROGRAM_ID, isSigner: false, isWritable: false },
        { pubkey: MEMO_PROGRAM_ID3, isSigner: false, isWritable: false },
        { pubkey: mintMintA, isSigner: false, isWritable: false },
        { pubkey: mintMintB, isSigner: false, isWritable: false },
        ...remainingAccounts
      ];
      const data = Buffer.alloc(dataLayout.span);
      dataLayout.encode(
        {
          liquidity,
          amountMinA,
          amountMinB
        },
        data
      );
      const aData = Buffer.from([...anchorDataBuf22.decreaseLiquidity, ...data]);
      return new import_web316.TransactionInstruction({
        keys,
        programId,
        data: aData
      });
    }
    function swapInstruction(programId, payer, poolId, ammConfigId, inputTokenAccount, outputTokenAccount, inputVault, outputVault, inputMint, outputMint, tickArray, observationId, amount, otherAmountThreshold, sqrtPriceLimitX64, isBaseInput, exTickArrayBitmap) {
      const dataLayout = struct3([
        u643("amount"),
        u643("otherAmountThreshold"),
        u1283("sqrtPriceLimitX64"),
        bool22("isBaseInput")
      ]);
      const remainingAccounts = [
        ...exTickArrayBitmap ? [{ pubkey: exTickArrayBitmap, isSigner: false, isWritable: true }] : [],
        ...tickArray.map((i) => ({ pubkey: i, isSigner: false, isWritable: true }))
      ];
      const keys = [
        { pubkey: payer, isSigner: true, isWritable: false },
        { pubkey: ammConfigId, isSigner: false, isWritable: false },
        { pubkey: poolId, isSigner: false, isWritable: true },
        { pubkey: inputTokenAccount, isSigner: false, isWritable: true },
        { pubkey: outputTokenAccount, isSigner: false, isWritable: true },
        { pubkey: inputVault, isSigner: false, isWritable: true },
        { pubkey: outputVault, isSigner: false, isWritable: true },
        { pubkey: observationId, isSigner: false, isWritable: true },
        { pubkey: import_spl_token2.TOKEN_PROGRAM_ID, isSigner: false, isWritable: false },
        { pubkey: import_spl_token5.TOKEN_2022_PROGRAM_ID, isSigner: false, isWritable: false },
        { pubkey: MEMO_PROGRAM_ID3, isSigner: false, isWritable: false },
        { pubkey: inputMint, isSigner: false, isWritable: false },
        { pubkey: outputMint, isSigner: false, isWritable: false },
        ...remainingAccounts
      ];
      const data = Buffer.alloc(dataLayout.span);
      dataLayout.encode(
        {
          amount,
          otherAmountThreshold,
          sqrtPriceLimitX64,
          isBaseInput
        },
        data
      );
      const aData = Buffer.from([...anchorDataBuf22.swap, ...data]);
      return new import_web316.TransactionInstruction({
        keys,
        programId,
        data: aData
      });
    }
    function initRewardInstruction(programId, payer, poolId, operationId, ammConfigId, ownerTokenAccount, rewardProgramId, rewardMint, rewardVault, openTime, endTime, emissionsPerSecondX64) {
      const dataLayout = struct3([u643("openTime"), u643("endTime"), u1283("emissionsPerSecondX64")]);
      const keys = [
        { pubkey: payer, isSigner: true, isWritable: true },
        { pubkey: ownerTokenAccount, isSigner: false, isWritable: true },
        { pubkey: ammConfigId, isSigner: false, isWritable: false },
        { pubkey: poolId, isSigner: false, isWritable: true },
        { pubkey: operationId, isSigner: false, isWritable: true },
        { pubkey: rewardMint, isSigner: false, isWritable: false },
        { pubkey: rewardVault, isSigner: false, isWritable: true },
        { pubkey: rewardProgramId, isSigner: false, isWritable: false },
        { pubkey: SYSTEM_PROGRAM_ID2, isSigner: false, isWritable: false },
        { pubkey: RENT_PROGRAM_ID2, isSigner: false, isWritable: false }
      ];
      const data = Buffer.alloc(dataLayout.span);
      dataLayout.encode(
        {
          openTime: parseBigNumberish2(openTime),
          endTime: parseBigNumberish2(endTime),
          emissionsPerSecondX64
        },
        data
      );
      const aData = Buffer.from([...anchorDataBuf22.initReward, ...data]);
      return new import_web316.TransactionInstruction({
        keys,
        programId,
        data: aData
      });
    }
    function setRewardInstruction(programId, payer, poolId, operationId, ammConfigId, ownerTokenAccount, rewardVault, rewardMint, rewardIndex, openTime, endTime, emissionsPerSecondX64) {
      const dataLayout = struct3([u822("rewardIndex"), u1283("emissionsPerSecondX64"), u643("openTime"), u643("endTime")]);
      const keys = [
        { pubkey: payer, isSigner: true, isWritable: true },
        { pubkey: ammConfigId, isSigner: false, isWritable: false },
        { pubkey: poolId, isSigner: false, isWritable: true },
        { pubkey: operationId, isSigner: false, isWritable: true },
        { pubkey: import_spl_token2.TOKEN_PROGRAM_ID, isSigner: false, isWritable: false },
        { pubkey: import_spl_token5.TOKEN_2022_PROGRAM_ID, isSigner: false, isWritable: false },
        { pubkey: rewardVault, isSigner: false, isWritable: true },
        { pubkey: ownerTokenAccount, isSigner: false, isWritable: true },
        { pubkey: rewardMint, isSigner: false, isWritable: true }
      ];
      const data = Buffer.alloc(dataLayout.span);
      dataLayout.encode(
        {
          rewardIndex,
          emissionsPerSecondX64,
          openTime: parseBigNumberish2(openTime),
          endTime: parseBigNumberish2(endTime)
        },
        data
      );
      const aData = Buffer.from([...anchorDataBuf22.setRewardEmissions, ...data]);
      return new import_web316.TransactionInstruction({
        keys,
        programId,
        data: aData
      });
    }
    function collectRewardInstruction(programId, payer, poolId, ownerTokenAccount, rewardVault, rewardMint, rewardIndex) {
      const dataLayout = struct3([u822("rewardIndex")]);
      const keys = [
        { pubkey: payer, isSigner: true, isWritable: true },
        { pubkey: ownerTokenAccount, isSigner: false, isWritable: true },
        { pubkey: poolId, isSigner: false, isWritable: true },
        { pubkey: rewardVault, isSigner: false, isWritable: true },
        { pubkey: rewardMint, isSigner: false, isWritable: false },
        { pubkey: import_spl_token2.TOKEN_PROGRAM_ID, isSigner: false, isWritable: false },
        { pubkey: import_spl_token5.TOKEN_2022_PROGRAM_ID, isSigner: false, isWritable: false },
        { pubkey: MEMO_PROGRAM_ID3, isSigner: false, isWritable: false }
      ];
      const data = Buffer.alloc(dataLayout.span);
      dataLayout.encode(
        {
          rewardIndex
        },
        data
      );
      const aData = Buffer.from([...anchorDataBuf22.collectReward, ...data]);
      return new import_web316.TransactionInstruction({
        keys,
        programId,
        data: aData
      });
    }
    var import_bn11 = __toESM2(require_bn());
    var import_bn10 = __toESM2(require_bn());
    var NEGATIVE_ONE2 = new import_bn10.default(-1);
    var Q642 = new import_bn10.default(1).shln(64);
    var Q1282 = new import_bn10.default(1).shln(128);
    var MaxU642 = Q642.sub(ONE2);
    var U64Resolution2 = 64;
    var MaxUint1282 = Q1282.subn(1);
    var MIN_TICK2 = -443636;
    var MAX_TICK2 = -MIN_TICK2;
    var MIN_SQRT_PRICE_X642 = new import_bn10.default("4295048016");
    var MAX_SQRT_PRICE_X642 = new import_bn10.default("79226673521066979257578248091");
    var BIT_PRECISION2 = 16;
    var LOG_B_2_X322 = "59543866431248";
    var LOG_B_P_ERR_MARGIN_LOWER_X642 = "184467440737095516";
    var LOG_B_P_ERR_MARGIN_UPPER_X642 = "15793534762490258745";
    var FEE_RATE_DENOMINATOR2 = new import_bn10.default(10).pow(new import_bn10.default(6));
    var Fee2 = /* @__PURE__ */ ((Fee3) => {
      Fee3[Fee3["rate_500"] = 500] = "rate_500";
      Fee3[Fee3["rate_3000"] = 3e3] = "rate_3000";
      Fee3[Fee3["rate_10000"] = 1e4] = "rate_10000";
      return Fee3;
    })(Fee2 || {});
    var TICK_SPACINGS2 = {
      [
        500
        /* rate_500 */
      ]: 10,
      [
        3e3
        /* rate_3000 */
      ]: 60,
      [
        1e4
        /* rate_10000 */
      ]: 200
    };
    var U64_IGNORE_RANGE2 = new import_bn10.default("18446744073700000000");
    function u16ToBytes2(num) {
      const arr = new ArrayBuffer(2);
      const view = new DataView(arr);
      view.setUint16(0, num, false);
      return new Uint8Array(arr);
    }
    function i16ToBytes2(num) {
      const arr = new ArrayBuffer(2);
      const view = new DataView(arr);
      view.setInt16(0, num, false);
      return new Uint8Array(arr);
    }
    function u32ToBytes2(num) {
      const arr = new ArrayBuffer(4);
      const view = new DataView(arr);
      view.setUint32(0, num, false);
      return new Uint8Array(arr);
    }
    function i32ToBytes2(num) {
      const arr = new ArrayBuffer(4);
      const view = new DataView(arr);
      view.setInt32(0, num, false);
      return new Uint8Array(arr);
    }
    function leadingZeros2(bitNum, data) {
      let i = 0;
      for (let j = bitNum - 1; j >= 0; j--) {
        if (!data.testn(j)) {
          i++;
        } else {
          break;
        }
      }
      return i;
    }
    function trailingZeros2(bitNum, data) {
      let i = 0;
      for (let j = 0; j < bitNum; j++) {
        if (!data.testn(j)) {
          i++;
        } else {
          break;
        }
      }
      return i;
    }
    function isZero2(bitNum, data) {
      for (let i = 0; i < bitNum; i++) {
        if (data.testn(i))
          return false;
      }
      return true;
    }
    function mostSignificantBit2(bitNum, data) {
      if (isZero2(bitNum, data))
        return null;
      else
        return leadingZeros2(bitNum, data);
    }
    function leastSignificantBit2(bitNum, data) {
      if (isZero2(bitNum, data))
        return null;
      else
        return trailingZeros2(bitNum, data);
    }
    var AMM_CONFIG_SEED2 = Buffer.from("amm_config", "utf8");
    var POOL_SEED2 = Buffer.from("pool", "utf8");
    var POOL_VAULT_SEED2 = Buffer.from("pool_vault", "utf8");
    var POOL_REWARD_VAULT_SEED2 = Buffer.from("pool_reward_vault", "utf8");
    var POSITION_SEED2 = Buffer.from("position", "utf8");
    var TICK_ARRAY_SEED2 = Buffer.from("tick_array", "utf8");
    var OPERATION_SEED2 = Buffer.from("operation", "utf8");
    var POOL_TICK_ARRAY_BITMAP_SEED2 = Buffer.from("pool_tick_array_bitmap_extension", "utf8");
    function getPdaAmmConfigId2(programId, index) {
      return findProgramAddress2([AMM_CONFIG_SEED2, u16ToBytes2(index)], programId);
    }
    function getPdaPoolId2(programId, ammConfigId, mintA, mintB) {
      return findProgramAddress2([POOL_SEED2, ammConfigId.toBuffer(), mintA.toBuffer(), mintB.toBuffer()], programId);
    }
    function getPdaPoolVaultId2(programId, poolId, vaultMint) {
      return findProgramAddress2([POOL_VAULT_SEED2, poolId.toBuffer(), vaultMint.toBuffer()], programId);
    }
    function getPdaPoolRewardVaulId2(programId, poolId, rewardMint) {
      return findProgramAddress2([POOL_REWARD_VAULT_SEED2, poolId.toBuffer(), rewardMint.toBuffer()], programId);
    }
    function getPdaTickArrayAddress2(programId, poolId, startIndex) {
      return findProgramAddress2([TICK_ARRAY_SEED2, poolId.toBuffer(), i32ToBytes2(startIndex)], programId);
    }
    function getPdaProtocolPositionAddress2(programId, poolId, tickLower, tickUpper) {
      return findProgramAddress2([POSITION_SEED2, poolId.toBuffer(), i32ToBytes2(tickLower), i32ToBytes2(tickUpper)], programId);
    }
    function getPdaPersonalPositionAddress2(programId, nftMint) {
      return findProgramAddress2([POSITION_SEED2, nftMint.toBuffer()], programId);
    }
    function getPdaMetadataKey2(mint) {
      return findProgramAddress2(
        [Buffer.from("metadata", "utf8"), METADATA_PROGRAM_ID2.toBuffer(), mint.toBuffer()],
        METADATA_PROGRAM_ID2
      );
    }
    function getPdaOperationAccount2(programId) {
      return findProgramAddress2([OPERATION_SEED2], programId);
    }
    function getPdaExBitmapAccount2(programId, poolId) {
      return findProgramAddress2([POOL_TICK_ARRAY_BITMAP_SEED2, poolId.toBuffer()], programId);
    }
    var FETCH_TICKARRAY_COUNT2 = 15;
    var TickQuery2 = class _TickQuery {
      static getTickArrays(connection, programId, poolId, tickCurrent, tickSpacing, tickArrayBitmapArray, exTickArrayBitmap) {
        return __async(this, null, function* () {
          const tickArraysToFetch = [];
          const currentTickArrayStartIndex = TickUtils2.getTickArrayStartIndexByTick(tickCurrent, tickSpacing);
          const startIndexArray = TickUtils2.getInitializedTickArrayInRange(
            tickArrayBitmapArray,
            exTickArrayBitmap,
            tickSpacing,
            currentTickArrayStartIndex,
            Math.floor(FETCH_TICKARRAY_COUNT2 / 2)
          );
          for (let i = 0; i < startIndexArray.length; i++) {
            const { publicKey: tickArrayAddress } = getPdaTickArrayAddress2(programId, poolId, startIndexArray[i]);
            tickArraysToFetch.push(tickArrayAddress);
          }
          const fetchedTickArrays = (yield getMultipleAccountsInfo2(connection, tickArraysToFetch)).map(
            (i) => i !== null ? TickArrayLayout2.decode(i.data) : null
          );
          const tickArrayCache = {};
          for (let i = 0; i < tickArraysToFetch.length; i++) {
            const _info = fetchedTickArrays[i];
            if (_info === null)
              continue;
            tickArrayCache[_info.startTickIndex] = __spreadProps(__spreadValues({}, _info), {
              address: tickArraysToFetch[i]
            });
          }
          return tickArrayCache;
        });
      }
      static nextInitializedTick(programId, poolId, tickArrayCache, tickIndex, tickSpacing, zeroForOne) {
        let {
          initializedTick: nextTick,
          tickArrayAddress,
          tickArrayStartTickIndex
        } = this.nextInitializedTickInOneArray(programId, poolId, tickArrayCache, tickIndex, tickSpacing, zeroForOne);
        while (nextTick == void 0 || nextTick.liquidityGross.lten(0)) {
          tickArrayStartTickIndex = TickUtils2.getNextTickArrayStartIndex(tickArrayStartTickIndex, tickSpacing, zeroForOne);
          if (this.checkIsValidStartIndex(tickArrayStartTickIndex, tickSpacing)) {
            throw new Error("No enough initialized tickArray");
          }
          const cachedTickArray = tickArrayCache[tickArrayStartTickIndex];
          if (cachedTickArray === void 0)
            continue;
          const {
            nextTick: _nextTick,
            tickArrayAddress: _tickArrayAddress,
            tickArrayStartTickIndex: _tickArrayStartTickIndex
          } = this.firstInitializedTickInOneArray(programId, poolId, cachedTickArray, zeroForOne);
          [nextTick, tickArrayAddress, tickArrayStartTickIndex] = [_nextTick, _tickArrayAddress, _tickArrayStartTickIndex];
        }
        if (nextTick == void 0) {
          throw new Error("No invaild tickArray cache");
        }
        return { nextTick, tickArrayAddress, tickArrayStartTickIndex };
      }
      static nextInitializedTickArray(tickIndex, tickSpacing, zeroForOne, tickArrayBitmap, exBitmapInfo) {
        const currentOffset = Math.floor(tickIndex / _TickQuery.tickCount(tickSpacing));
        const result = zeroForOne ? TickUtils2.searchLowBitFromStart(tickArrayBitmap, exBitmapInfo, currentOffset - 1, 1, tickSpacing) : TickUtils2.searchHightBitFromStart(tickArrayBitmap, exBitmapInfo, currentOffset + 1, 1, tickSpacing);
        return result.length > 0 ? { isExist: true, nextStartIndex: result[0] } : { isExist: false, nextStartIndex: 0 };
      }
      static firstInitializedTickInOneArray(programId, poolId, tickArray, zeroForOne) {
        let nextInitializedTick = void 0;
        if (zeroForOne) {
          let i = TICK_ARRAY_SIZE2 - 1;
          while (i >= 0) {
            const tickInArray = tickArray.ticks[i];
            if (tickInArray.liquidityGross.gtn(0)) {
              nextInitializedTick = tickInArray;
              break;
            }
            i = i - 1;
          }
        } else {
          let i = 0;
          while (i < TICK_ARRAY_SIZE2) {
            const tickInArray = tickArray.ticks[i];
            if (tickInArray.liquidityGross.gtn(0)) {
              nextInitializedTick = tickInArray;
              break;
            }
            i = i + 1;
          }
        }
        const { publicKey: tickArrayAddress } = getPdaTickArrayAddress2(programId, poolId, tickArray.startTickIndex);
        return { nextTick: nextInitializedTick, tickArrayAddress, tickArrayStartTickIndex: tickArray.startTickIndex };
      }
      static nextInitializedTickInOneArray(programId, poolId, tickArrayCache, tickIndex, tickSpacing, zeroForOne) {
        const startIndex = TickUtils2.getTickArrayStartIndexByTick(tickIndex, tickSpacing);
        let tickPositionInArray = Math.floor((tickIndex - startIndex) / tickSpacing);
        const cachedTickArray = tickArrayCache[startIndex];
        if (cachedTickArray == void 0) {
          return {
            initializedTick: void 0,
            tickArrayAddress: void 0,
            tickArrayStartTickIndex: startIndex
          };
        }
        let nextInitializedTick = void 0;
        if (zeroForOne) {
          while (tickPositionInArray >= 0) {
            const tickInArray = cachedTickArray.ticks[tickPositionInArray];
            if (tickInArray.liquidityGross.gtn(0)) {
              nextInitializedTick = tickInArray;
              break;
            }
            tickPositionInArray = tickPositionInArray - 1;
          }
        } else {
          tickPositionInArray = tickPositionInArray + 1;
          while (tickPositionInArray < TICK_ARRAY_SIZE2) {
            const tickInArray = cachedTickArray.ticks[tickPositionInArray];
            if (tickInArray.liquidityGross.gtn(0)) {
              nextInitializedTick = tickInArray;
              break;
            }
            tickPositionInArray = tickPositionInArray + 1;
          }
        }
        const { publicKey: tickArrayAddress } = getPdaTickArrayAddress2(programId, poolId, startIndex);
        return {
          initializedTick: nextInitializedTick,
          tickArrayAddress,
          tickArrayStartTickIndex: cachedTickArray.startTickIndex
        };
      }
      static getArrayStartIndex(tickIndex, tickSpacing) {
        const ticksInArray = this.tickCount(tickSpacing);
        const start = Math.floor(tickIndex / ticksInArray);
        return start * ticksInArray;
      }
      static checkIsValidStartIndex(tickIndex, tickSpacing) {
        if (TickUtils2.checkIsOutOfBoundary(tickIndex)) {
          if (tickIndex > MAX_TICK2) {
            return false;
          }
          const minStartIndex = TickUtils2.getTickArrayStartIndexByTick(MIN_TICK2, tickSpacing);
          return tickIndex == minStartIndex;
        }
        return tickIndex % this.tickCount(tickSpacing) == 0;
      }
      static tickCount(tickSpacing) {
        return TICK_ARRAY_SIZE2 * tickSpacing;
      }
    };
    var TICK_ARRAY_SIZE2 = 60;
    var TICK_ARRAY_BITMAP_SIZE2 = 512;
    var TickUtils2 = class _TickUtils {
      static getTickArrayAddressByTick(programId, poolId, tickIndex, tickSpacing) {
        const startIndex = _TickUtils.getTickArrayStartIndexByTick(tickIndex, tickSpacing);
        const { publicKey: tickArrayAddress } = getPdaTickArrayAddress2(programId, poolId, startIndex);
        return tickArrayAddress;
      }
      static getTickOffsetInArray(tickIndex, tickSpacing) {
        if (tickIndex % tickSpacing != 0) {
          throw new Error("tickIndex % tickSpacing not equal 0");
        }
        const startTickIndex = _TickUtils.getTickArrayStartIndexByTick(tickIndex, tickSpacing);
        const offsetInArray = Math.floor((tickIndex - startTickIndex) / tickSpacing);
        if (offsetInArray < 0 || offsetInArray >= TICK_ARRAY_SIZE2) {
          throw new Error("tick offset in array overflow");
        }
        return offsetInArray;
      }
      static getTickArrayBitIndex(tickIndex, tickSpacing) {
        const ticksInArray = TickQuery2.tickCount(tickSpacing);
        let startIndex = tickIndex / ticksInArray;
        if (tickIndex < 0 && tickIndex % ticksInArray != 0) {
          startIndex = Math.ceil(startIndex) - 1;
        } else {
          startIndex = Math.floor(startIndex);
        }
        return startIndex;
      }
      static getTickArrayStartIndexByTick(tickIndex, tickSpacing) {
        return this.getTickArrayBitIndex(tickIndex, tickSpacing) * TickQuery2.tickCount(tickSpacing);
      }
      static getTickArrayOffsetInBitmapByTick(tick, tickSpacing) {
        const multiplier = tickSpacing * TICK_ARRAY_SIZE2;
        const compressed = Math.floor(tick / multiplier) + 512;
        return Math.abs(compressed);
      }
      static checkTickArrayIsInitialized(bitmap, tick, tickSpacing) {
        const multiplier = tickSpacing * TICK_ARRAY_SIZE2;
        const compressed = Math.floor(tick / multiplier) + 512;
        const bitPos = Math.abs(compressed);
        return {
          isInitialized: bitmap.testn(bitPos),
          startIndex: (bitPos - 512) * multiplier
        };
      }
      static getNextTickArrayStartIndex(lastTickArrayStartIndex, tickSpacing, zeroForOne) {
        return zeroForOne ? lastTickArrayStartIndex - tickSpacing * TICK_ARRAY_SIZE2 : lastTickArrayStartIndex + tickSpacing * TICK_ARRAY_SIZE2;
      }
      static mergeTickArrayBitmap(bns) {
        let b = new import_bn11.default(0);
        for (let i = 0; i < bns.length; i++) {
          b = b.add(bns[i].shln(64 * i));
        }
        return b;
      }
      static getInitializedTickArrayInRange(tickArrayBitmap, exTickArrayBitmap, tickSpacing, tickArrayStartIndex, expectedCount) {
        const tickArrayOffset = Math.floor(tickArrayStartIndex / (tickSpacing * TICK_ARRAY_SIZE2));
        return [
          // find right of currenct offset
          ..._TickUtils.searchLowBitFromStart(
            tickArrayBitmap,
            exTickArrayBitmap,
            tickArrayOffset - 1,
            expectedCount,
            tickSpacing
          ),
          // find left of current offset
          ..._TickUtils.searchHightBitFromStart(
            tickArrayBitmap,
            exTickArrayBitmap,
            tickArrayOffset,
            expectedCount,
            tickSpacing
          )
        ];
      }
      static getAllInitializedTickArrayStartIndex(tickArrayBitmap, exTickArrayBitmap, tickSpacing) {
        return _TickUtils.searchHightBitFromStart(tickArrayBitmap, exTickArrayBitmap, 0, TICK_ARRAY_BITMAP_SIZE2, tickSpacing);
      }
      static getAllInitializedTickArrayInfo(programId, poolId, tickArrayBitmap, exTickArrayBitmap, tickSpacing) {
        const result = [];
        const allInitializedTickArrayIndex = _TickUtils.getAllInitializedTickArrayStartIndex(
          tickArrayBitmap,
          exTickArrayBitmap,
          tickSpacing
        );
        for (const startIndex of allInitializedTickArrayIndex) {
          const { publicKey: address } = getPdaTickArrayAddress2(programId, poolId, startIndex);
          result.push({
            tickArrayStartIndex: startIndex,
            tickArrayAddress: address
          });
        }
        return result;
      }
      static getAllInitializedTickInTickArray(tickArray) {
        return tickArray.ticks.filter((i) => i.liquidityGross.gtn(0));
      }
      static searchLowBitFromStart(tickArrayBitmap, exTickArrayBitmap, currentTickArrayBitStartIndex, expectedCount, tickSpacing) {
        const tickArrayBitmaps = [
          ...[...exTickArrayBitmap.negativeTickArrayBitmap].reverse(),
          tickArrayBitmap.slice(0, 8),
          tickArrayBitmap.slice(8, 16),
          ...exTickArrayBitmap.positiveTickArrayBitmap
        ].map((i) => _TickUtils.mergeTickArrayBitmap(i));
        const result = [];
        while (currentTickArrayBitStartIndex >= -7680) {
          const arrayIndex = Math.floor((currentTickArrayBitStartIndex + 7680) / 512);
          const searchIndex = (currentTickArrayBitStartIndex + 7680) % 512;
          if (tickArrayBitmaps[arrayIndex].testn(searchIndex))
            result.push(currentTickArrayBitStartIndex);
          currentTickArrayBitStartIndex--;
          if (result.length === expectedCount)
            break;
        }
        const tickCount = TickQuery2.tickCount(tickSpacing);
        return result.map((i) => i * tickCount);
      }
      static searchHightBitFromStart(tickArrayBitmap, exTickArrayBitmap, currentTickArrayBitStartIndex, expectedCount, tickSpacing) {
        const tickArrayBitmaps = [
          ...[...exTickArrayBitmap.negativeTickArrayBitmap].reverse(),
          tickArrayBitmap.slice(0, 8),
          tickArrayBitmap.slice(8, 16),
          ...exTickArrayBitmap.positiveTickArrayBitmap
        ].map((i) => _TickUtils.mergeTickArrayBitmap(i));
        const result = [];
        while (currentTickArrayBitStartIndex < 7680) {
          const arrayIndex = Math.floor((currentTickArrayBitStartIndex + 7680) / 512);
          const searchIndex = (currentTickArrayBitStartIndex + 7680) % 512;
          if (tickArrayBitmaps[arrayIndex].testn(searchIndex))
            result.push(currentTickArrayBitStartIndex);
          currentTickArrayBitStartIndex++;
          if (result.length === expectedCount)
            break;
        }
        const tickCount = TickQuery2.tickCount(tickSpacing);
        return result.map((i) => i * tickCount);
      }
      static checkIsOutOfBoundary(tick) {
        return tick < MIN_TICK2 || tick > MAX_TICK2;
      }
      static nextInitTick(tickArrayCurrent, currentTickIndex, tickSpacing, zeroForOne, t) {
        const currentTickArrayStartIndex = TickQuery2.getArrayStartIndex(currentTickIndex, tickSpacing);
        if (currentTickArrayStartIndex != tickArrayCurrent.startTickIndex) {
          return null;
        }
        let offsetInArray = Math.floor((currentTickIndex - tickArrayCurrent.startTickIndex) / tickSpacing);
        if (zeroForOne) {
          while (offsetInArray >= 0) {
            if (tickArrayCurrent.ticks[offsetInArray].liquidityGross.gtn(0)) {
              return tickArrayCurrent.ticks[offsetInArray];
            }
            offsetInArray = offsetInArray - 1;
          }
        } else {
          if (!t)
            offsetInArray = offsetInArray + 1;
          while (offsetInArray < TICK_ARRAY_SIZE2) {
            if (tickArrayCurrent.ticks[offsetInArray].liquidityGross.gtn(0)) {
              return tickArrayCurrent.ticks[offsetInArray];
            }
            offsetInArray = offsetInArray + 1;
          }
        }
        return null;
      }
      static firstInitializedTick(tickArrayCurrent, zeroForOne) {
        if (zeroForOne) {
          let i = TICK_ARRAY_SIZE2 - 1;
          while (i >= 0) {
            if (tickArrayCurrent.ticks[i].liquidityGross.gtn(0)) {
              return tickArrayCurrent.ticks[i];
            }
            i = i - 1;
          }
        } else {
          let i = 0;
          while (i < TICK_ARRAY_SIZE2) {
            if (tickArrayCurrent.ticks[i].liquidityGross.gtn(0)) {
              return tickArrayCurrent.ticks[i];
            }
            i = i + 1;
          }
        }
        throw Error(`firstInitializedTick check error: ${tickArrayCurrent} - ${zeroForOne}`);
      }
    };
    var EXTENSION_TICKARRAY_BITMAP_SIZE2 = 14;
    var TickArrayBitmap2 = class {
      static maxTickInTickarrayBitmap(tickSpacing) {
        return tickSpacing * TICK_ARRAY_SIZE2 * TICK_ARRAY_BITMAP_SIZE2;
      }
      static getBitmapTickBoundary(tickarrayStartIndex, tickSpacing) {
        const ticksInOneBitmap = this.maxTickInTickarrayBitmap(tickSpacing);
        let m = Math.floor(Math.abs(tickarrayStartIndex) / ticksInOneBitmap);
        if (tickarrayStartIndex < 0 && Math.abs(tickarrayStartIndex) % ticksInOneBitmap != 0)
          m += 1;
        const minValue = ticksInOneBitmap * m;
        return tickarrayStartIndex < 0 ? { minValue: -minValue, maxValue: -minValue + ticksInOneBitmap } : { minValue, maxValue: minValue + ticksInOneBitmap };
      }
      static nextInitializedTickArrayStartIndex(bitMap, lastTickArrayStartIndex, tickSpacing, zeroForOne) {
        if (!TickQuery2.checkIsValidStartIndex(lastTickArrayStartIndex, tickSpacing))
          throw Error("nextInitializedTickArrayStartIndex check error");
        const tickBoundary = this.maxTickInTickarrayBitmap(tickSpacing);
        const nextTickArrayStartIndex = zeroForOne ? lastTickArrayStartIndex - TickQuery2.tickCount(tickSpacing) : lastTickArrayStartIndex + TickQuery2.tickCount(tickSpacing);
        if (nextTickArrayStartIndex < -tickBoundary || nextTickArrayStartIndex >= tickBoundary) {
          return { isInit: false, tickIndex: lastTickArrayStartIndex };
        }
        const multiplier = tickSpacing * TICK_ARRAY_SIZE2;
        let compressed = nextTickArrayStartIndex / multiplier + 512;
        if (nextTickArrayStartIndex < 0 && nextTickArrayStartIndex % multiplier != 0) {
          compressed--;
        }
        const bitPos = Math.abs(compressed);
        if (zeroForOne) {
          const offsetBitMap = bitMap.shln(1024 - bitPos - 1);
          const nextBit = mostSignificantBit2(1024, offsetBitMap);
          if (nextBit !== null) {
            const nextArrayStartIndex = (bitPos - nextBit - 512) * multiplier;
            return { isInit: true, tickIndex: nextArrayStartIndex };
          } else {
            return { isInit: false, tickIndex: -tickBoundary };
          }
        } else {
          const offsetBitMap = bitMap.shrn(bitPos);
          const nextBit = leastSignificantBit2(1024, offsetBitMap);
          if (nextBit !== null) {
            const nextArrayStartIndex = (bitPos + nextBit - 512) * multiplier;
            return { isInit: true, tickIndex: nextArrayStartIndex };
          } else {
            return { isInit: false, tickIndex: tickBoundary - TickQuery2.tickCount(tickSpacing) };
          }
        }
      }
    };
    var TickArrayBitmapExtension = class {
      static getBitmapOffset(tickIndex, tickSpacing) {
        if (!TickQuery2.checkIsValidStartIndex(tickIndex, tickSpacing)) {
          throw new Error("No enough initialized tickArray");
        }
        this.checkExtensionBoundary(tickIndex, tickSpacing);
        const ticksInOneBitmap = TickArrayBitmap2.maxTickInTickarrayBitmap(tickSpacing);
        let offset22 = Math.floor(Math.abs(tickIndex) / ticksInOneBitmap) - 1;
        if (tickIndex < 0 && Math.abs(tickIndex) % ticksInOneBitmap === 0)
          offset22--;
        return offset22;
      }
      static getBitmap(tickIndex, tickSpacing, tickArrayBitmapExtension) {
        const offset22 = this.getBitmapOffset(tickIndex, tickSpacing);
        if (tickIndex < 0) {
          return { offset: offset22, tickarrayBitmap: tickArrayBitmapExtension.negativeTickArrayBitmap[offset22] };
        } else {
          return { offset: offset22, tickarrayBitmap: tickArrayBitmapExtension.positiveTickArrayBitmap[offset22] };
        }
      }
      static checkExtensionBoundary(tickIndex, tickSpacing) {
        const { positiveTickBoundary, negativeTickBoundary } = this.extensionTickBoundary(tickSpacing);
        if (tickIndex >= negativeTickBoundary && tickIndex < positiveTickBoundary) {
          throw Error("checkExtensionBoundary -> InvalidTickArrayBoundary");
        }
      }
      static extensionTickBoundary(tickSpacing) {
        const positiveTickBoundary = TickArrayBitmap2.maxTickInTickarrayBitmap(tickSpacing);
        const negativeTickBoundary = -positiveTickBoundary;
        if (MAX_TICK2 <= positiveTickBoundary)
          throw Error(`extensionTickBoundary check error: ${MAX_TICK2}, ${positiveTickBoundary}`);
        if (negativeTickBoundary <= MIN_TICK2)
          throw Error(`extensionTickBoundary check error: ${negativeTickBoundary}, ${MIN_TICK2}`);
        return { positiveTickBoundary, negativeTickBoundary };
      }
      static checkTickArrayIsInit(tickArrayStartIndex, tickSpacing, tickArrayBitmapExtension) {
        const { tickarrayBitmap } = this.getBitmap(tickArrayStartIndex, tickSpacing, tickArrayBitmapExtension);
        const tickArrayOffsetInBitmap = this.tickArrayOffsetInBitmap(tickArrayStartIndex, tickSpacing);
        return {
          isInitialized: TickUtils2.mergeTickArrayBitmap(tickarrayBitmap).testn(tickArrayOffsetInBitmap),
          startIndex: tickArrayStartIndex
        };
      }
      static nextInitializedTickArrayFromOneBitmap(lastTickArrayStartIndex, tickSpacing, zeroForOne, tickArrayBitmapExtension) {
        const multiplier = TickQuery2.tickCount(tickSpacing);
        const nextTickArrayStartIndex = zeroForOne ? lastTickArrayStartIndex - multiplier : lastTickArrayStartIndex + multiplier;
        const minTickArrayStartIndex = TickQuery2.getArrayStartIndex(MIN_TICK2, tickSpacing);
        const maxTickArrayStartIndex = TickQuery2.getArrayStartIndex(MAX_TICK2, tickSpacing);
        if (nextTickArrayStartIndex < minTickArrayStartIndex || nextTickArrayStartIndex > maxTickArrayStartIndex) {
          return {
            isInit: false,
            tickIndex: nextTickArrayStartIndex
          };
        }
        const { tickarrayBitmap } = this.getBitmap(nextTickArrayStartIndex, tickSpacing, tickArrayBitmapExtension);
        return this.nextInitializedTickArrayInBitmap(tickarrayBitmap, nextTickArrayStartIndex, tickSpacing, zeroForOne);
      }
      static nextInitializedTickArrayInBitmap(tickarrayBitmap, nextTickArrayStartIndex, tickSpacing, zeroForOne) {
        const { minValue: bitmapMinTickBoundary, maxValue: bitmapMaxTickBoundary } = TickArrayBitmap2.getBitmapTickBoundary(
          nextTickArrayStartIndex,
          tickSpacing
        );
        const tickArrayOffsetInBitmap = this.tickArrayOffsetInBitmap(nextTickArrayStartIndex, tickSpacing);
        if (zeroForOne) {
          const offsetBitMap = TickUtils2.mergeTickArrayBitmap(tickarrayBitmap).shln(
            TICK_ARRAY_BITMAP_SIZE2 - 1 - tickArrayOffsetInBitmap
          );
          const nextBit = isZero2(512, offsetBitMap) ? null : leadingZeros2(512, offsetBitMap);
          if (nextBit !== null) {
            const nextArrayStartIndex = nextTickArrayStartIndex - nextBit * TickQuery2.tickCount(tickSpacing);
            return { isInit: true, tickIndex: nextArrayStartIndex };
          } else {
            return { isInit: false, tickIndex: bitmapMinTickBoundary };
          }
        } else {
          const offsetBitMap = TickUtils2.mergeTickArrayBitmap(tickarrayBitmap).shrn(tickArrayOffsetInBitmap);
          const nextBit = isZero2(512, offsetBitMap) ? null : trailingZeros2(512, offsetBitMap);
          if (nextBit !== null) {
            const nextArrayStartIndex = nextTickArrayStartIndex + nextBit * TickQuery2.tickCount(tickSpacing);
            return { isInit: true, tickIndex: nextArrayStartIndex };
          } else {
            return { isInit: false, tickIndex: bitmapMaxTickBoundary - TickQuery2.tickCount(tickSpacing) };
          }
        }
      }
      static tickArrayOffsetInBitmap(tickArrayStartIndex, tickSpacing) {
        const m = Math.abs(tickArrayStartIndex) % TickArrayBitmap2.maxTickInTickarrayBitmap(tickSpacing);
        let tickArrayOffsetInBitmap = Math.floor(m / TickQuery2.tickCount(tickSpacing));
        if (tickArrayStartIndex < 0 && m != 0) {
          tickArrayOffsetInBitmap = TICK_ARRAY_BITMAP_SIZE2 - tickArrayOffsetInBitmap;
        }
        return tickArrayOffsetInBitmap;
      }
    };
    var AmmConfigLayout = struct3([
      blob4(8),
      u822("bump"),
      u162("index"),
      publicKey3(""),
      u3222("protocolFeeRate"),
      u3222("tradeFeeRate"),
      u162("tickSpacing"),
      u3222("fundFeeRate"),
      seq22(u3222(), 1, "padding"),
      publicKey3("fundOwner"),
      seq22(u643(), 3, "padding")
    ]);
    var ObservationLayout2 = struct3([
      u3222("blockTimestamp"),
      u1283("sqrtPriceX64"),
      u1283("cumulativeTimePriceX64"),
      seq22(u1283(), 1, "")
    ]);
    var ObservationInfoLayout2 = struct3([
      blob4(8),
      bool22("initialized"),
      publicKey3("poolId"),
      seq22(ObservationLayout2, 1e3, "observations"),
      seq22(u1283(), 5, "")
    ]);
    var RewardInfo2 = struct3([
      u822("rewardState"),
      u643("openTime"),
      u643("endTime"),
      u643("lastUpdateTime"),
      u1283("emissionsPerSecondX64"),
      u643("rewardTotalEmissioned"),
      u643("rewardClaimed"),
      publicKey3("tokenMint"),
      publicKey3("tokenVault"),
      publicKey3("creator"),
      u1283("rewardGrowthGlobalX64")
    ]);
    var PoolInfoLayout2 = struct3([
      blob4(8),
      u822("bump"),
      publicKey3("ammConfig"),
      publicKey3("creator"),
      publicKey3("mintA"),
      publicKey3("mintB"),
      publicKey3("vaultA"),
      publicKey3("vaultB"),
      publicKey3("observationId"),
      u822("mintDecimalsA"),
      u822("mintDecimalsB"),
      u162("tickSpacing"),
      u1283("liquidity"),
      u1283("sqrtPriceX64"),
      s322("tickCurrent"),
      u162("observationIndex"),
      u162("observationUpdateDuration"),
      u1283("feeGrowthGlobalX64A"),
      u1283("feeGrowthGlobalX64B"),
      u643("protocolFeesTokenA"),
      u643("protocolFeesTokenB"),
      u1283("swapInAmountTokenA"),
      u1283("swapOutAmountTokenB"),
      u1283("swapInAmountTokenB"),
      u1283("swapOutAmountTokenA"),
      u822("status"),
      seq22(u822(), 7, ""),
      seq22(RewardInfo2, 3, "rewardInfos"),
      seq22(u643(), 16, "tickArrayBitmap"),
      u643("totalFeesTokenA"),
      u643("totalFeesClaimedTokenA"),
      u643("totalFeesTokenB"),
      u643("totalFeesClaimedTokenB"),
      u643("fundFeesTokenA"),
      u643("fundFeesTokenB"),
      u643("startTime"),
      seq22(u643(), 15 * 4 - 3, "padding")
    ]);
    var PositionRewardInfoLayout2 = struct3([u1283("growthInsideLastX64"), u643("rewardAmountOwed")]);
    var PositionInfoLayout2 = struct3([
      blob4(8),
      u822("bump"),
      publicKey3("nftMint"),
      publicKey3("poolId"),
      s322("tickLower"),
      s322("tickUpper"),
      u1283("liquidity"),
      u1283("feeGrowthInsideLastX64A"),
      u1283("feeGrowthInsideLastX64B"),
      u643("tokenFeesOwedA"),
      u643("tokenFeesOwedB"),
      seq22(PositionRewardInfoLayout2, 3, "rewardInfos"),
      seq22(u643(), 8, "")
    ]);
    var ProtocolPositionLayout2 = struct3([
      blob4(8),
      u822("bump"),
      publicKey3("poolId"),
      s322("tickLowerIndex"),
      s322("tickUpperIndex"),
      u1283("liquidity"),
      u1283("feeGrowthInsideLastX64A"),
      u1283("feeGrowthInsideLastX64B"),
      u643("tokenFeesOwedA"),
      u643("tokenFeesOwedB"),
      seq22(u1283(), 3, "rewardGrowthInside"),
      seq22(u643(), 8, "")
    ]);
    var TickLayout2 = struct3([
      s322("tick"),
      i1282("liquidityNet"),
      u1283("liquidityGross"),
      u1283("feeGrowthOutsideX64A"),
      u1283("feeGrowthOutsideX64B"),
      seq22(u1283(), 3, "rewardGrowthsOutsideX64"),
      seq22(u3222(), 13, "")
    ]);
    var TickArrayLayout2 = struct3([
      blob4(8),
      publicKey3("poolId"),
      s322("startTickIndex"),
      seq22(TickLayout2, TICK_ARRAY_SIZE2, "ticks"),
      u822("initializedTickCount"),
      seq22(u822(), 115, "")
    ]);
    var OperationLayout2 = struct3([blob4(329), seq22(publicKey3(), 100, "whitelistMints")]);
    var TickArrayBitmapExtensionLayout2 = struct3([
      blob4(8),
      publicKey3("poolId"),
      seq22(seq22(u643(), 8), EXTENSION_TICKARRAY_BITMAP_SIZE2, "positiveTickArrayBitmap"),
      seq22(seq22(u643(), 8), EXTENSION_TICKARRAY_BITMAP_SIZE2, "negativeTickArrayBitmap")
    ]);
    var import_bn13 = __toESM2(require_bn());
    var import_decimal22 = __toESM2(require_decimal3());
    var import_web317 = require("@solana/web3.js");
    var import_bn12 = __toESM2(require_bn());
    var PoolUtils3 = class _PoolUtils {
      static getOutputAmountAndRemainAccounts(poolInfo, tickArrayCache, inputTokenMint, inputAmount, sqrtPriceLimitX64, catchLiquidityInsufficient = false) {
        const zeroForOne = inputTokenMint.equals(poolInfo.mintA.mint);
        const allNeededAccounts = [];
        const {
          isExist,
          startIndex: firstTickArrayStartIndex,
          nextAccountMeta
        } = this.getFirstInitializedTickArray(poolInfo, zeroForOne);
        if (!isExist || firstTickArrayStartIndex === void 0 || !nextAccountMeta)
          throw new Error("Invalid tick array");
        try {
          const preTick = this.preInitializedTickArrayStartIndex(poolInfo, zeroForOne);
          if (preTick.isExist) {
            const { publicKey: address } = getPdaTickArrayAddress2(poolInfo.programId, poolInfo.id, preTick.nextStartIndex);
            allNeededAccounts.push(address);
          }
        } catch (e) {
        }
        allNeededAccounts.push(nextAccountMeta);
        const {
          allTrade,
          amountSpecifiedRemaining,
          amountCalculated: outputAmount,
          accounts: reaminAccounts,
          sqrtPriceX64: executionPrice,
          feeAmount
        } = SwapMath2.swapCompute(
          poolInfo.programId,
          poolInfo.id,
          tickArrayCache,
          poolInfo.tickArrayBitmap,
          poolInfo.exBitmapInfo,
          zeroForOne,
          poolInfo.ammConfig.tradeFeeRate,
          poolInfo.liquidity,
          poolInfo.tickCurrent,
          poolInfo.tickSpacing,
          poolInfo.sqrtPriceX64,
          inputAmount,
          firstTickArrayStartIndex,
          sqrtPriceLimitX64,
          catchLiquidityInsufficient
        );
        allNeededAccounts.push(...reaminAccounts);
        return {
          allTrade,
          realTradeAmountIn: inputAmount.sub(amountSpecifiedRemaining),
          expectedAmountOut: outputAmount.mul(NEGATIVE_ONE2),
          remainingAccounts: allNeededAccounts,
          executionPrice,
          feeAmount
        };
      }
      static getInputAmountAndRemainAccounts(poolInfo, tickArrayCache, outputTokenMint, outputAmount, sqrtPriceLimitX64) {
        const zeroForOne = outputTokenMint.equals(poolInfo.mintB.mint);
        const allNeededAccounts = [];
        const {
          isExist,
          startIndex: firstTickArrayStartIndex,
          nextAccountMeta
        } = this.getFirstInitializedTickArray(poolInfo, zeroForOne);
        if (!isExist || firstTickArrayStartIndex === void 0 || !nextAccountMeta)
          throw new Error("Invalid tick array");
        try {
          const preTick = this.preInitializedTickArrayStartIndex(poolInfo, zeroForOne);
          if (preTick.isExist) {
            const { publicKey: address } = getPdaTickArrayAddress2(poolInfo.programId, poolInfo.id, preTick.nextStartIndex);
            allNeededAccounts.push(address);
          }
        } catch (e) {
        }
        allNeededAccounts.push(nextAccountMeta);
        const {
          amountCalculated: inputAmount,
          accounts: reaminAccounts,
          sqrtPriceX64: executionPrice,
          feeAmount
        } = SwapMath2.swapCompute(
          poolInfo.programId,
          poolInfo.id,
          tickArrayCache,
          poolInfo.tickArrayBitmap,
          poolInfo.exBitmapInfo,
          zeroForOne,
          poolInfo.ammConfig.tradeFeeRate,
          poolInfo.liquidity,
          poolInfo.tickCurrent,
          poolInfo.tickSpacing,
          poolInfo.sqrtPriceX64,
          outputAmount.mul(NEGATIVE_ONE2),
          firstTickArrayStartIndex,
          sqrtPriceLimitX64
        );
        allNeededAccounts.push(...reaminAccounts);
        return { expectedAmountIn: inputAmount, remainingAccounts: allNeededAccounts, executionPrice, feeAmount };
      }
      static getFirstInitializedTickArray(poolInfo, zeroForOne) {
        const { isInitialized, startIndex } = _PoolUtils.isOverflowDefaultTickarrayBitmap(poolInfo.tickSpacing, [
          poolInfo.tickCurrent
        ]) ? TickArrayBitmapExtension.checkTickArrayIsInit(
          TickQuery2.getArrayStartIndex(poolInfo.tickCurrent, poolInfo.tickSpacing),
          poolInfo.tickSpacing,
          poolInfo.exBitmapInfo
        ) : TickUtils2.checkTickArrayIsInitialized(
          TickUtils2.mergeTickArrayBitmap(poolInfo.tickArrayBitmap),
          poolInfo.tickCurrent,
          poolInfo.tickSpacing
        );
        if (isInitialized) {
          const { publicKey: address } = getPdaTickArrayAddress2(poolInfo.programId, poolInfo.id, startIndex);
          return {
            isExist: true,
            startIndex,
            nextAccountMeta: address
          };
        }
        const { isExist, nextStartIndex } = this.nextInitializedTickArrayStartIndex(
          poolInfo,
          TickQuery2.getArrayStartIndex(poolInfo.tickCurrent, poolInfo.tickSpacing),
          zeroForOne
        );
        if (isExist) {
          const { publicKey: address } = getPdaTickArrayAddress2(poolInfo.programId, poolInfo.id, nextStartIndex);
          return {
            isExist: true,
            startIndex: nextStartIndex,
            nextAccountMeta: address
          };
        }
        return { isExist: false, nextAccountMeta: void 0, startIndex: void 0 };
      }
      static preInitializedTickArrayStartIndex(poolInfo, zeroForOne) {
        const currentOffset = Math.floor(poolInfo.tickCurrent / TickQuery2.tickCount(poolInfo.tickSpacing));
        const result = !zeroForOne ? TickUtils2.searchLowBitFromStart(
          poolInfo.tickArrayBitmap,
          poolInfo.exBitmapInfo,
          currentOffset - 1,
          1,
          poolInfo.tickSpacing
        ) : TickUtils2.searchHightBitFromStart(
          poolInfo.tickArrayBitmap,
          poolInfo.exBitmapInfo,
          currentOffset + 1,
          1,
          poolInfo.tickSpacing
        );
        return result.length > 0 ? { isExist: true, nextStartIndex: result[0] } : { isExist: false, nextStartIndex: 0 };
      }
      static nextInitializedTickArrayStartIndex(poolInfo, lastTickArrayStartIndex, zeroForOne) {
        lastTickArrayStartIndex = TickQuery2.getArrayStartIndex(lastTickArrayStartIndex, poolInfo.tickSpacing);
        while (true) {
          const { isInit: startIsInit, tickIndex: startIndex } = TickArrayBitmap2.nextInitializedTickArrayStartIndex(
            TickUtils2.mergeTickArrayBitmap(poolInfo.tickArrayBitmap),
            lastTickArrayStartIndex,
            poolInfo.tickSpacing,
            zeroForOne
          );
          if (startIsInit) {
            return { isExist: true, nextStartIndex: startIndex };
          }
          lastTickArrayStartIndex = startIndex;
          const { isInit, tickIndex } = TickArrayBitmapExtension.nextInitializedTickArrayFromOneBitmap(
            lastTickArrayStartIndex,
            poolInfo.tickSpacing,
            zeroForOne,
            poolInfo.exBitmapInfo
          );
          if (isInit)
            return { isExist: true, nextStartIndex: tickIndex };
          lastTickArrayStartIndex = tickIndex;
          if (lastTickArrayStartIndex < MIN_TICK2 || lastTickArrayStartIndex > MAX_TICK2)
            return { isExist: false, nextStartIndex: 0 };
        }
      }
      static updatePoolRewardInfos(_0) {
        return __async(this, arguments, function* ({
          connection,
          apiPoolInfo,
          chainTime,
          poolLiquidity,
          rewardInfos
        }) {
          var _a, _b, _c;
          const nRewardInfo = [];
          for (let i = 0; i < rewardInfos.length; i++) {
            const _itemReward = rewardInfos[i];
            const apiRewardProgram = (_c = (_a = apiPoolInfo.rewardInfos[i]) == null ? void 0 : _a.programId) != null ? _c : (_b = yield connection.getAccountInfo(_itemReward.tokenMint)) == null ? void 0 : _b.owner;
            if (apiRewardProgram === void 0)
              throw Error("get new reward mint info error");
            const itemReward = __spreadProps(__spreadValues({}, _itemReward), {
              perSecond: MathUtil2.x64ToDecimal(_itemReward.emissionsPerSecondX64),
              remainingRewards: void 0,
              tokenProgramId: new import_web317.PublicKey(apiRewardProgram)
            });
            if (itemReward.tokenMint.equals(import_web317.PublicKey.default))
              continue;
            if (chainTime <= itemReward.openTime.toNumber() || poolLiquidity.eq(ZERO2)) {
              nRewardInfo.push(itemReward);
              continue;
            }
            const latestUpdateTime = new import_bn12.default(Math.min(itemReward.endTime.toNumber(), chainTime));
            const timeDelta = latestUpdateTime.sub(itemReward.lastUpdateTime);
            const rewardGrowthDeltaX64 = MathUtil2.mulDivFloor(timeDelta, itemReward.emissionsPerSecondX64, poolLiquidity);
            const rewardGrowthGlobalX64 = itemReward.rewardGrowthGlobalX64.add(rewardGrowthDeltaX64);
            const rewardEmissionedDelta = MathUtil2.mulDivFloor(timeDelta, itemReward.emissionsPerSecondX64, Q642);
            const rewardTotalEmissioned = itemReward.rewardTotalEmissioned.add(rewardEmissionedDelta);
            nRewardInfo.push(__spreadProps(__spreadValues({}, itemReward), {
              rewardGrowthGlobalX64,
              rewardTotalEmissioned,
              lastUpdateTime: latestUpdateTime
            }));
          }
          return nRewardInfo;
        });
      }
      static isOverflowDefaultTickarrayBitmap(tickSpacing, tickarrayStartIndexs) {
        const { maxTickBoundary, minTickBoundary } = this.tickRange(tickSpacing);
        for (const tickIndex of tickarrayStartIndexs) {
          const tickarrayStartIndex = TickUtils2.getTickArrayStartIndexByTick(tickIndex, tickSpacing);
          if (tickarrayStartIndex >= maxTickBoundary || tickarrayStartIndex < minTickBoundary) {
            return true;
          }
        }
        return false;
      }
      static tickRange(tickSpacing) {
        let maxTickBoundary = TickArrayBitmap2.maxTickInTickarrayBitmap(tickSpacing);
        let minTickBoundary = -maxTickBoundary;
        if (maxTickBoundary > MAX_TICK2) {
          maxTickBoundary = TickQuery2.getArrayStartIndex(MAX_TICK2, tickSpacing) + TickQuery2.tickCount(tickSpacing);
        }
        if (minTickBoundary < MIN_TICK2) {
          minTickBoundary = TickQuery2.getArrayStartIndex(MIN_TICK2, tickSpacing);
        }
        return { maxTickBoundary, minTickBoundary };
      }
      static get_tick_array_offset(tickarrayStartIndex, tickSpacing) {
        if (!TickQuery2.checkIsValidStartIndex(tickarrayStartIndex, tickSpacing)) {
          throw new Error("No enough initialized tickArray");
        }
        return tickarrayStartIndex / TickQuery2.tickCount(tickSpacing) * TICK_ARRAY_BITMAP_SIZE2;
      }
    };
    var MathUtil2 = class {
      static mulDivRoundingUp(a, b, denominator) {
        const numerator = a.mul(b);
        let result = numerator.div(denominator);
        if (!numerator.mod(denominator).eq(ZERO2)) {
          result = result.add(ONE2);
        }
        return result;
      }
      static mulDivFloor(a, b, denominator) {
        if (denominator.eq(ZERO2)) {
          throw new Error("division by 0");
        }
        return a.mul(b).div(denominator);
      }
      static mulDivCeil(a, b, denominator) {
        if (denominator.eq(ZERO2)) {
          throw new Error("division by 0");
        }
        const numerator = a.mul(b).add(denominator.sub(ONE2));
        return numerator.div(denominator);
      }
      static x64ToDecimal(num, decimalPlaces) {
        return new import_decimal22.default(num.toString()).div(import_decimal22.default.pow(2, 64)).toDecimalPlaces(decimalPlaces);
      }
      static decimalToX64(num) {
        return new import_bn13.default(num.mul(import_decimal22.default.pow(2, 64)).floor().toFixed());
      }
      static wrappingSubU128(n0, n1) {
        return n0.add(Q1282).sub(n1).mod(Q1282);
      }
    };
    function mulRightShift(val, mulBy) {
      return signedRightShift(val.mul(mulBy), 64, 256);
    }
    function signedLeftShift(n0, shiftBy, bitWidth) {
      const twosN0 = n0.toTwos(bitWidth).shln(shiftBy);
      twosN0.imaskn(bitWidth + 1);
      return twosN0.fromTwos(bitWidth);
    }
    function signedRightShift(n0, shiftBy, bitWidth) {
      const twoN0 = n0.toTwos(bitWidth).shrn(shiftBy);
      twoN0.imaskn(bitWidth - shiftBy + 1);
      return twoN0.fromTwos(bitWidth - shiftBy);
    }
    var SqrtPriceMath2 = class _SqrtPriceMath {
      static sqrtPriceX64ToPrice(sqrtPriceX64, decimalsA, decimalsB) {
        return MathUtil2.x64ToDecimal(sqrtPriceX64).pow(2).mul(import_decimal22.default.pow(10, decimalsA - decimalsB));
      }
      static priceToSqrtPriceX64(price, decimalsA, decimalsB) {
        return MathUtil2.decimalToX64(price.mul(import_decimal22.default.pow(10, decimalsB - decimalsA)).sqrt());
      }
      static getNextSqrtPriceX64FromInput(sqrtPriceX64, liquidity, amountIn, zeroForOne) {
        if (!sqrtPriceX64.gt(ZERO2)) {
          throw new Error("sqrtPriceX64 must greater than 0");
        }
        if (!liquidity.gt(ZERO2)) {
          throw new Error("liquidity must greater than 0");
        }
        return zeroForOne ? this.getNextSqrtPriceFromTokenAmountARoundingUp(sqrtPriceX64, liquidity, amountIn, true) : this.getNextSqrtPriceFromTokenAmountBRoundingDown(sqrtPriceX64, liquidity, amountIn, true);
      }
      static getNextSqrtPriceX64FromOutput(sqrtPriceX64, liquidity, amountOut, zeroForOne) {
        if (!sqrtPriceX64.gt(ZERO2)) {
          throw new Error("sqrtPriceX64 must greater than 0");
        }
        if (!liquidity.gt(ZERO2)) {
          throw new Error("liquidity must greater than 0");
        }
        return zeroForOne ? this.getNextSqrtPriceFromTokenAmountBRoundingDown(sqrtPriceX64, liquidity, amountOut, false) : this.getNextSqrtPriceFromTokenAmountARoundingUp(sqrtPriceX64, liquidity, amountOut, false);
      }
      static getNextSqrtPriceFromTokenAmountARoundingUp(sqrtPriceX64, liquidity, amount, add3) {
        if (amount.eq(ZERO2))
          return sqrtPriceX64;
        const liquidityLeftShift = liquidity.shln(U64Resolution2);
        if (add3) {
          const numerator1 = liquidityLeftShift;
          const denominator = liquidityLeftShift.add(amount.mul(sqrtPriceX64));
          if (denominator.gte(numerator1)) {
            return MathUtil2.mulDivCeil(numerator1, sqrtPriceX64, denominator);
          }
          return MathUtil2.mulDivRoundingUp(numerator1, ONE2, numerator1.div(sqrtPriceX64).add(amount));
        } else {
          const amountMulSqrtPrice = amount.mul(sqrtPriceX64);
          if (!liquidityLeftShift.gt(amountMulSqrtPrice)) {
            throw new Error("getNextSqrtPriceFromTokenAmountARoundingUp,liquidityLeftShift must gt amountMulSqrtPrice");
          }
          const denominator = liquidityLeftShift.sub(amountMulSqrtPrice);
          return MathUtil2.mulDivCeil(liquidityLeftShift, sqrtPriceX64, denominator);
        }
      }
      static getNextSqrtPriceFromTokenAmountBRoundingDown(sqrtPriceX64, liquidity, amount, add3) {
        const deltaY = amount.shln(U64Resolution2);
        if (add3) {
          return sqrtPriceX64.add(deltaY.div(liquidity));
        } else {
          const amountDivLiquidity = MathUtil2.mulDivRoundingUp(deltaY, ONE2, liquidity);
          if (!sqrtPriceX64.gt(amountDivLiquidity)) {
            throw new Error("getNextSqrtPriceFromTokenAmountBRoundingDown sqrtPriceX64 must gt amountDivLiquidity");
          }
          return sqrtPriceX64.sub(amountDivLiquidity);
        }
      }
      static getSqrtPriceX64FromTick(tick) {
        if (!Number.isInteger(tick)) {
          throw new Error("tick must be integer");
        }
        if (tick < MIN_TICK2 || tick > MAX_TICK2) {
          throw new Error("tick must be in MIN_TICK and MAX_TICK");
        }
        const tickAbs = tick < 0 ? tick * -1 : tick;
        let ratio = (tickAbs & 1) != 0 ? new import_bn13.default("18445821805675395072") : new import_bn13.default("18446744073709551616");
        if ((tickAbs & 2) != 0)
          ratio = mulRightShift(ratio, new import_bn13.default("18444899583751176192"));
        if ((tickAbs & 4) != 0)
          ratio = mulRightShift(ratio, new import_bn13.default("18443055278223355904"));
        if ((tickAbs & 8) != 0)
          ratio = mulRightShift(ratio, new import_bn13.default("18439367220385607680"));
        if ((tickAbs & 16) != 0)
          ratio = mulRightShift(ratio, new import_bn13.default("18431993317065453568"));
        if ((tickAbs & 32) != 0)
          ratio = mulRightShift(ratio, new import_bn13.default("18417254355718170624"));
        if ((tickAbs & 64) != 0)
          ratio = mulRightShift(ratio, new import_bn13.default("18387811781193609216"));
        if ((tickAbs & 128) != 0)
          ratio = mulRightShift(ratio, new import_bn13.default("18329067761203558400"));
        if ((tickAbs & 256) != 0)
          ratio = mulRightShift(ratio, new import_bn13.default("18212142134806163456"));
        if ((tickAbs & 512) != 0)
          ratio = mulRightShift(ratio, new import_bn13.default("17980523815641700352"));
        if ((tickAbs & 1024) != 0)
          ratio = mulRightShift(ratio, new import_bn13.default("17526086738831433728"));
        if ((tickAbs & 2048) != 0)
          ratio = mulRightShift(ratio, new import_bn13.default("16651378430235570176"));
        if ((tickAbs & 4096) != 0)
          ratio = mulRightShift(ratio, new import_bn13.default("15030750278694412288"));
        if ((tickAbs & 8192) != 0)
          ratio = mulRightShift(ratio, new import_bn13.default("12247334978884435968"));
        if ((tickAbs & 16384) != 0)
          ratio = mulRightShift(ratio, new import_bn13.default("8131365268886854656"));
        if ((tickAbs & 32768) != 0)
          ratio = mulRightShift(ratio, new import_bn13.default("3584323654725218816"));
        if ((tickAbs & 65536) != 0)
          ratio = mulRightShift(ratio, new import_bn13.default("696457651848324352"));
        if ((tickAbs & 131072) != 0)
          ratio = mulRightShift(ratio, new import_bn13.default("26294789957507116"));
        if ((tickAbs & 262144) != 0)
          ratio = mulRightShift(ratio, new import_bn13.default("37481735321082"));
        if (tick > 0)
          ratio = MaxUint1282.div(ratio);
        return ratio;
      }
      static getTickFromPrice(price, decimalsA, decimalsB) {
        return _SqrtPriceMath.getTickFromSqrtPriceX64(_SqrtPriceMath.priceToSqrtPriceX64(price, decimalsA, decimalsB));
      }
      static getTickFromSqrtPriceX64(sqrtPriceX64) {
        if (sqrtPriceX64.gt(MAX_SQRT_PRICE_X642) || sqrtPriceX64.lt(MIN_SQRT_PRICE_X642)) {
          throw new Error("Provided sqrtPrice is not within the supported sqrtPrice range.");
        }
        const msb = sqrtPriceX64.bitLength() - 1;
        const adjustedMsb = new import_bn13.default(msb - 64);
        const log2pIntegerX32 = signedLeftShift(adjustedMsb, 32, 128);
        let bit = new import_bn13.default("8000000000000000", "hex");
        let precision = 0;
        let log2pFractionX64 = new import_bn13.default(0);
        let r = msb >= 64 ? sqrtPriceX64.shrn(msb - 63) : sqrtPriceX64.shln(63 - msb);
        while (bit.gt(new import_bn13.default(0)) && precision < BIT_PRECISION2) {
          r = r.mul(r);
          const rMoreThanTwo = r.shrn(127);
          r = r.shrn(63 + rMoreThanTwo.toNumber());
          log2pFractionX64 = log2pFractionX64.add(bit.mul(rMoreThanTwo));
          bit = bit.shrn(1);
          precision += 1;
        }
        const log2pFractionX32 = log2pFractionX64.shrn(32);
        const log2pX32 = log2pIntegerX32.add(log2pFractionX32);
        const logbpX64 = log2pX32.mul(new import_bn13.default(LOG_B_2_X322));
        const tickLow = signedRightShift(logbpX64.sub(new import_bn13.default(LOG_B_P_ERR_MARGIN_LOWER_X642)), 64, 128).toNumber();
        const tickHigh = signedRightShift(logbpX64.add(new import_bn13.default(LOG_B_P_ERR_MARGIN_UPPER_X642)), 64, 128).toNumber();
        if (tickLow == tickHigh) {
          return tickLow;
        } else {
          const derivedTickHighSqrtPriceX64 = _SqrtPriceMath.getSqrtPriceX64FromTick(tickHigh);
          return derivedTickHighSqrtPriceX64.lte(sqrtPriceX64) ? tickHigh : tickLow;
        }
      }
    };
    var TickMath2 = class _TickMath {
      static getTickWithPriceAndTickspacing(price, tickSpacing, mintDecimalsA, mintDecimalsB) {
        const tick = SqrtPriceMath2.getTickFromSqrtPriceX64(
          SqrtPriceMath2.priceToSqrtPriceX64(price, mintDecimalsA, mintDecimalsB)
        );
        let result = tick / tickSpacing;
        if (result < 0) {
          result = Math.floor(result);
        } else {
          result = Math.ceil(result);
        }
        return result * tickSpacing;
      }
      static roundPriceWithTickspacing(price, tickSpacing, mintDecimalsA, mintDecimalsB) {
        const tick = _TickMath.getTickWithPriceAndTickspacing(price, tickSpacing, mintDecimalsA, mintDecimalsB);
        const sqrtPriceX64 = SqrtPriceMath2.getSqrtPriceX64FromTick(tick);
        return SqrtPriceMath2.sqrtPriceX64ToPrice(sqrtPriceX64, mintDecimalsA, mintDecimalsB);
      }
    };
    var LiquidityMath2 = class _LiquidityMath {
      static addDelta(x, y) {
        return x.add(y);
      }
      static getTokenAmountAFromLiquidity(sqrtPriceX64A, sqrtPriceX64B, liquidity, roundUp) {
        if (sqrtPriceX64A.gt(sqrtPriceX64B)) {
          ;
          [sqrtPriceX64A, sqrtPriceX64B] = [sqrtPriceX64B, sqrtPriceX64A];
        }
        if (!sqrtPriceX64A.gt(ZERO2)) {
          throw new Error("sqrtPriceX64A must greater than 0");
        }
        const numerator1 = liquidity.ushln(U64Resolution2);
        const numerator2 = sqrtPriceX64B.sub(sqrtPriceX64A);
        return roundUp ? MathUtil2.mulDivRoundingUp(MathUtil2.mulDivCeil(numerator1, numerator2, sqrtPriceX64B), ONE2, sqrtPriceX64A) : MathUtil2.mulDivFloor(numerator1, numerator2, sqrtPriceX64B).div(sqrtPriceX64A);
      }
      static getTokenAmountBFromLiquidity(sqrtPriceX64A, sqrtPriceX64B, liquidity, roundUp) {
        if (sqrtPriceX64A.gt(sqrtPriceX64B)) {
          ;
          [sqrtPriceX64A, sqrtPriceX64B] = [sqrtPriceX64B, sqrtPriceX64A];
        }
        if (!sqrtPriceX64A.gt(ZERO2)) {
          throw new Error("sqrtPriceX64A must greater than 0");
        }
        return roundUp ? MathUtil2.mulDivCeil(liquidity, sqrtPriceX64B.sub(sqrtPriceX64A), Q642) : MathUtil2.mulDivFloor(liquidity, sqrtPriceX64B.sub(sqrtPriceX64A), Q642);
      }
      static getLiquidityFromTokenAmountA(sqrtPriceX64A, sqrtPriceX64B, amountA, roundUp) {
        if (sqrtPriceX64A.gt(sqrtPriceX64B)) {
          ;
          [sqrtPriceX64A, sqrtPriceX64B] = [sqrtPriceX64B, sqrtPriceX64A];
        }
        const numerator = amountA.mul(sqrtPriceX64A).mul(sqrtPriceX64B);
        const denominator = sqrtPriceX64B.sub(sqrtPriceX64A);
        const result = numerator.div(denominator);
        if (roundUp) {
          return MathUtil2.mulDivRoundingUp(result, ONE2, MaxU642);
        } else {
          return result.shrn(U64Resolution2);
        }
      }
      static getLiquidityFromTokenAmountB(sqrtPriceX64A, sqrtPriceX64B, amountB) {
        if (sqrtPriceX64A.gt(sqrtPriceX64B)) {
          ;
          [sqrtPriceX64A, sqrtPriceX64B] = [sqrtPriceX64B, sqrtPriceX64A];
        }
        return MathUtil2.mulDivFloor(amountB, MaxU642, sqrtPriceX64B.sub(sqrtPriceX64A));
      }
      static getLiquidityFromTokenAmounts(sqrtPriceCurrentX64, sqrtPriceX64A, sqrtPriceX64B, amountA, amountB) {
        if (sqrtPriceX64A.gt(sqrtPriceX64B)) {
          ;
          [sqrtPriceX64A, sqrtPriceX64B] = [sqrtPriceX64B, sqrtPriceX64A];
        }
        if (sqrtPriceCurrentX64.lte(sqrtPriceX64A)) {
          return _LiquidityMath.getLiquidityFromTokenAmountA(sqrtPriceX64A, sqrtPriceX64B, amountA, false);
        } else if (sqrtPriceCurrentX64.lt(sqrtPriceX64B)) {
          const liquidity0 = _LiquidityMath.getLiquidityFromTokenAmountA(sqrtPriceCurrentX64, sqrtPriceX64B, amountA, false);
          const liquidity1 = _LiquidityMath.getLiquidityFromTokenAmountB(sqrtPriceX64A, sqrtPriceCurrentX64, amountB);
          return liquidity0.lt(liquidity1) ? liquidity0 : liquidity1;
        } else {
          return _LiquidityMath.getLiquidityFromTokenAmountB(sqrtPriceX64A, sqrtPriceX64B, amountB);
        }
      }
      static getAmountsFromLiquidity(sqrtPriceCurrentX64, sqrtPriceX64A, sqrtPriceX64B, liquidity, roundUp) {
        if (sqrtPriceX64A.gt(sqrtPriceX64B)) {
          ;
          [sqrtPriceX64A, sqrtPriceX64B] = [sqrtPriceX64B, sqrtPriceX64A];
        }
        if (sqrtPriceCurrentX64.lte(sqrtPriceX64A)) {
          return {
            amountA: _LiquidityMath.getTokenAmountAFromLiquidity(sqrtPriceX64A, sqrtPriceX64B, liquidity, roundUp),
            amountB: new import_bn13.default(0)
          };
        } else if (sqrtPriceCurrentX64.lt(sqrtPriceX64B)) {
          const amountA = _LiquidityMath.getTokenAmountAFromLiquidity(sqrtPriceCurrentX64, sqrtPriceX64B, liquidity, roundUp);
          const amountB = _LiquidityMath.getTokenAmountBFromLiquidity(sqrtPriceX64A, sqrtPriceCurrentX64, liquidity, roundUp);
          return { amountA, amountB };
        } else {
          return {
            amountA: new import_bn13.default(0),
            amountB: _LiquidityMath.getTokenAmountBFromLiquidity(sqrtPriceX64A, sqrtPriceX64B, liquidity, roundUp)
          };
        }
      }
      static getAmountsFromLiquidityWithSlippage(sqrtPriceCurrentX64, sqrtPriceX64A, sqrtPriceX64B, liquidity, amountMax, roundUp, amountSlippage) {
        const { amountA, amountB } = _LiquidityMath.getAmountsFromLiquidity(
          sqrtPriceCurrentX64,
          sqrtPriceX64A,
          sqrtPriceX64B,
          liquidity,
          roundUp
        );
        const coefficient = amountMax ? 1 + amountSlippage : 1 - amountSlippage;
        const amount0Slippage = new import_bn13.default(new import_decimal22.default(amountA.toString()).mul(coefficient).toFixed(0));
        const amount1Slippage = new import_bn13.default(new import_decimal22.default(amountB.toString()).mul(coefficient).toFixed(0));
        return {
          amountSlippageA: amount0Slippage,
          amountSlippageB: amount1Slippage
        };
      }
    };
    var SwapMath2 = class _SwapMath {
      static swapCompute(programId, poolId, tickArrayCache, tickArrayBitmap, tickarrayBitmapExtension, zeroForOne, fee, liquidity, currentTick, tickSpacing, currentSqrtPriceX64, amountSpecified, lastSavedTickArrayStartIndex, sqrtPriceLimitX64, catchLiquidityInsufficient = false) {
        if (amountSpecified.eq(ZERO2)) {
          throw new Error("amountSpecified must not be 0");
        }
        if (!sqrtPriceLimitX64)
          sqrtPriceLimitX64 = zeroForOne ? MIN_SQRT_PRICE_X642.add(ONE2) : MAX_SQRT_PRICE_X642.sub(ONE2);
        if (zeroForOne) {
          if (sqrtPriceLimitX64.lt(MIN_SQRT_PRICE_X642)) {
            throw new Error("sqrtPriceX64 must greater than MIN_SQRT_PRICE_X64");
          }
          if (sqrtPriceLimitX64.gte(currentSqrtPriceX64)) {
            throw new Error("sqrtPriceX64 must smaller than current");
          }
        } else {
          if (sqrtPriceLimitX64.gt(MAX_SQRT_PRICE_X642)) {
            throw new Error("sqrtPriceX64 must smaller than MAX_SQRT_PRICE_X64");
          }
          if (sqrtPriceLimitX64.lte(currentSqrtPriceX64)) {
            throw new Error("sqrtPriceX64 must greater than current");
          }
        }
        const baseInput = amountSpecified.gt(ZERO2);
        const state = {
          amountSpecifiedRemaining: amountSpecified,
          amountCalculated: ZERO2,
          sqrtPriceX64: currentSqrtPriceX64,
          tick: currentTick > lastSavedTickArrayStartIndex ? Math.min(lastSavedTickArrayStartIndex + TickQuery2.tickCount(tickSpacing) - 1, currentTick) : lastSavedTickArrayStartIndex,
          accounts: [],
          liquidity,
          feeAmount: new import_bn13.default(0)
        };
        let tickAarrayStartIndex = lastSavedTickArrayStartIndex;
        let tickArrayCurrent = tickArrayCache[lastSavedTickArrayStartIndex];
        let loopCount = 0;
        let t = !zeroForOne && tickArrayCurrent.startTickIndex === state.tick;
        while (!state.amountSpecifiedRemaining.eq(ZERO2) && !state.sqrtPriceX64.eq(sqrtPriceLimitX64)) {
          if (loopCount > 10) {
          }
          const step = {};
          step.sqrtPriceStartX64 = state.sqrtPriceX64;
          const tickState = TickUtils2.nextInitTick(tickArrayCurrent, state.tick, tickSpacing, zeroForOne, t);
          let nextInitTick = tickState ? tickState : null;
          let tickArrayAddress = null;
          if (!(nextInitTick == null ? void 0 : nextInitTick.liquidityGross.gtn(0))) {
            const nextInitTickArrayIndex = PoolUtils3.nextInitializedTickArrayStartIndex(
              {
                tickCurrent: state.tick,
                tickSpacing,
                tickArrayBitmap,
                exBitmapInfo: tickarrayBitmapExtension
              },
              tickAarrayStartIndex,
              zeroForOne
            );
            if (!nextInitTickArrayIndex.isExist) {
              if (catchLiquidityInsufficient) {
                return {
                  allTrade: false,
                  amountSpecifiedRemaining: state.amountSpecifiedRemaining,
                  amountCalculated: state.amountCalculated,
                  feeAmount: state.feeAmount,
                  sqrtPriceX64: state.sqrtPriceX64,
                  liquidity: state.liquidity,
                  tickCurrent: state.tick,
                  accounts: state.accounts
                };
              }
              throw Error("swapCompute LiquidityInsufficient");
            }
            tickAarrayStartIndex = nextInitTickArrayIndex.nextStartIndex;
            const { publicKey: expectedNextTickArrayAddress } = getPdaTickArrayAddress2(
              programId,
              poolId,
              tickAarrayStartIndex
            );
            tickArrayAddress = expectedNextTickArrayAddress;
            tickArrayCurrent = tickArrayCache[tickAarrayStartIndex];
            try {
              nextInitTick = TickUtils2.firstInitializedTick(tickArrayCurrent, zeroForOne);
            } catch (e) {
              throw Error("not found next tick info");
            }
          }
          step.tickNext = nextInitTick.tick;
          step.initialized = nextInitTick.liquidityGross.gtn(0);
          if (lastSavedTickArrayStartIndex !== tickAarrayStartIndex && tickArrayAddress) {
            state.accounts.push(tickArrayAddress);
            lastSavedTickArrayStartIndex = tickAarrayStartIndex;
          }
          if (step.tickNext < MIN_TICK2) {
            step.tickNext = MIN_TICK2;
          } else if (step.tickNext > MAX_TICK2) {
            step.tickNext = MAX_TICK2;
          }
          step.sqrtPriceNextX64 = SqrtPriceMath2.getSqrtPriceX64FromTick(step.tickNext);
          let targetPrice;
          if (zeroForOne && step.sqrtPriceNextX64.lt(sqrtPriceLimitX64) || !zeroForOne && step.sqrtPriceNextX64.gt(sqrtPriceLimitX64)) {
            targetPrice = sqrtPriceLimitX64;
          } else {
            targetPrice = step.sqrtPriceNextX64;
          }
          ;
          [state.sqrtPriceX64, step.amountIn, step.amountOut, step.feeAmount] = _SwapMath.swapStepCompute(
            state.sqrtPriceX64,
            targetPrice,
            state.liquidity,
            state.amountSpecifiedRemaining,
            fee
          );
          state.feeAmount = state.feeAmount.add(step.feeAmount);
          if (baseInput) {
            state.amountSpecifiedRemaining = state.amountSpecifiedRemaining.sub(step.amountIn.add(step.feeAmount));
            state.amountCalculated = state.amountCalculated.sub(step.amountOut);
          } else {
            state.amountSpecifiedRemaining = state.amountSpecifiedRemaining.add(step.amountOut);
            state.amountCalculated = state.amountCalculated.add(step.amountIn.add(step.feeAmount));
          }
          if (state.sqrtPriceX64.eq(step.sqrtPriceNextX64)) {
            if (step.initialized) {
              let liquidityNet = nextInitTick.liquidityNet;
              if (zeroForOne)
                liquidityNet = liquidityNet.mul(NEGATIVE_ONE2);
              state.liquidity = LiquidityMath2.addDelta(state.liquidity, liquidityNet);
            }
            t = step.tickNext != state.tick && !zeroForOne && tickArrayCurrent.startTickIndex === step.tickNext;
            state.tick = zeroForOne ? step.tickNext - 1 : step.tickNext;
          } else if (state.sqrtPriceX64 != step.sqrtPriceStartX64) {
            const _T = SqrtPriceMath2.getTickFromSqrtPriceX64(state.sqrtPriceX64);
            t = _T != state.tick && !zeroForOne && tickArrayCurrent.startTickIndex === _T;
            state.tick = _T;
          }
          ++loopCount;
        }
        try {
          const { nextStartIndex: tickAarrayStartIndex2, isExist } = TickQuery2.nextInitializedTickArray(
            state.tick,
            tickSpacing,
            zeroForOne,
            tickArrayBitmap,
            tickarrayBitmapExtension
          );
          if (isExist && lastSavedTickArrayStartIndex !== tickAarrayStartIndex2) {
            state.accounts.push(getPdaTickArrayAddress2(programId, poolId, tickAarrayStartIndex2).publicKey);
            lastSavedTickArrayStartIndex = tickAarrayStartIndex2;
          }
        } catch (e) {
        }
        return {
          allTrade: true,
          amountSpecifiedRemaining: ZERO2,
          amountCalculated: state.amountCalculated,
          feeAmount: state.feeAmount,
          sqrtPriceX64: state.sqrtPriceX64,
          liquidity: state.liquidity,
          tickCurrent: state.tick,
          accounts: state.accounts
        };
      }
      static swapStepCompute(sqrtPriceX64Current, sqrtPriceX64Target, liquidity, amountRemaining, feeRate) {
        const swapStep = {
          sqrtPriceX64Next: new import_bn13.default(0),
          amountIn: new import_bn13.default(0),
          amountOut: new import_bn13.default(0),
          feeAmount: new import_bn13.default(0)
        };
        const zeroForOne = sqrtPriceX64Current.gte(sqrtPriceX64Target);
        const baseInput = amountRemaining.gte(ZERO2);
        if (baseInput) {
          const amountRemainingSubtractFee = MathUtil2.mulDivFloor(
            amountRemaining,
            FEE_RATE_DENOMINATOR2.sub(new import_bn13.default(feeRate.toString())),
            FEE_RATE_DENOMINATOR2
          );
          swapStep.amountIn = zeroForOne ? LiquidityMath2.getTokenAmountAFromLiquidity(sqrtPriceX64Target, sqrtPriceX64Current, liquidity, true) : LiquidityMath2.getTokenAmountBFromLiquidity(sqrtPriceX64Current, sqrtPriceX64Target, liquidity, true);
          if (amountRemainingSubtractFee.gte(swapStep.amountIn)) {
            swapStep.sqrtPriceX64Next = sqrtPriceX64Target;
          } else {
            swapStep.sqrtPriceX64Next = SqrtPriceMath2.getNextSqrtPriceX64FromInput(
              sqrtPriceX64Current,
              liquidity,
              amountRemainingSubtractFee,
              zeroForOne
            );
          }
        } else {
          swapStep.amountOut = zeroForOne ? LiquidityMath2.getTokenAmountBFromLiquidity(sqrtPriceX64Target, sqrtPriceX64Current, liquidity, false) : LiquidityMath2.getTokenAmountAFromLiquidity(sqrtPriceX64Current, sqrtPriceX64Target, liquidity, false);
          if (amountRemaining.mul(NEGATIVE_ONE2).gte(swapStep.amountOut)) {
            swapStep.sqrtPriceX64Next = sqrtPriceX64Target;
          } else {
            swapStep.sqrtPriceX64Next = SqrtPriceMath2.getNextSqrtPriceX64FromOutput(
              sqrtPriceX64Current,
              liquidity,
              amountRemaining.mul(NEGATIVE_ONE2),
              zeroForOne
            );
          }
        }
        const reachTargetPrice = sqrtPriceX64Target.eq(swapStep.sqrtPriceX64Next);
        if (zeroForOne) {
          if (!(reachTargetPrice && baseInput)) {
            swapStep.amountIn = LiquidityMath2.getTokenAmountAFromLiquidity(
              swapStep.sqrtPriceX64Next,
              sqrtPriceX64Current,
              liquidity,
              true
            );
          }
          if (!(reachTargetPrice && !baseInput)) {
            swapStep.amountOut = LiquidityMath2.getTokenAmountBFromLiquidity(
              swapStep.sqrtPriceX64Next,
              sqrtPriceX64Current,
              liquidity,
              false
            );
          }
        } else {
          swapStep.amountIn = reachTargetPrice && baseInput ? swapStep.amountIn : LiquidityMath2.getTokenAmountBFromLiquidity(sqrtPriceX64Current, swapStep.sqrtPriceX64Next, liquidity, true);
          swapStep.amountOut = reachTargetPrice && !baseInput ? swapStep.amountOut : LiquidityMath2.getTokenAmountAFromLiquidity(sqrtPriceX64Current, swapStep.sqrtPriceX64Next, liquidity, false);
        }
        if (!baseInput && swapStep.amountOut.gt(amountRemaining.mul(NEGATIVE_ONE2))) {
          swapStep.amountOut = amountRemaining.mul(NEGATIVE_ONE2);
        }
        if (baseInput && !swapStep.sqrtPriceX64Next.eq(sqrtPriceX64Target)) {
          swapStep.feeAmount = amountRemaining.sub(swapStep.amountIn);
        } else {
          swapStep.feeAmount = MathUtil2.mulDivCeil(
            swapStep.amountIn,
            new import_bn13.default(feeRate),
            FEE_RATE_DENOMINATOR2.sub(new import_bn13.default(feeRate))
          );
        }
        return [swapStep.sqrtPriceX64Next, swapStep.amountIn, swapStep.amountOut, swapStep.feeAmount];
      }
    };
    var import_bn14 = __toESM2(require_bn());
    var PositionUtils2 = class {
      static getfeeGrowthInside(poolState, tickLowerState, tickUpperState) {
        let feeGrowthBelowX64A = new import_bn14.default(0);
        let feeGrowthBelowX64B = new import_bn14.default(0);
        if (poolState.tickCurrent >= tickLowerState.tick) {
          feeGrowthBelowX64A = tickLowerState.feeGrowthOutsideX64A;
          feeGrowthBelowX64B = tickLowerState.feeGrowthOutsideX64B;
        } else {
          feeGrowthBelowX64A = poolState.feeGrowthGlobalX64A.sub(tickLowerState.feeGrowthOutsideX64A);
          feeGrowthBelowX64B = poolState.feeGrowthGlobalX64B.sub(tickLowerState.feeGrowthOutsideX64B);
        }
        let feeGrowthAboveX64A = new import_bn14.default(0);
        let feeGrowthAboveX64B = new import_bn14.default(0);
        if (poolState.tickCurrent < tickUpperState.tick) {
          feeGrowthAboveX64A = tickUpperState.feeGrowthOutsideX64A;
          feeGrowthAboveX64B = tickUpperState.feeGrowthOutsideX64B;
        } else {
          feeGrowthAboveX64A = poolState.feeGrowthGlobalX64A.sub(tickUpperState.feeGrowthOutsideX64A);
          feeGrowthAboveX64B = poolState.feeGrowthGlobalX64B.sub(tickUpperState.feeGrowthOutsideX64B);
        }
        const feeGrowthInsideX64A = MathUtil2.wrappingSubU128(
          MathUtil2.wrappingSubU128(poolState.feeGrowthGlobalX64A, feeGrowthBelowX64A),
          feeGrowthAboveX64A
        );
        const feeGrowthInsideBX64 = MathUtil2.wrappingSubU128(
          MathUtil2.wrappingSubU128(poolState.feeGrowthGlobalX64B, feeGrowthBelowX64B),
          feeGrowthAboveX64B
        );
        return { feeGrowthInsideX64A, feeGrowthInsideBX64 };
      }
      static GetPositionFees(ammPool, positionState, tickLowerState, tickUpperState) {
        const { feeGrowthInsideX64A, feeGrowthInsideBX64 } = this.getfeeGrowthInside(
          ammPool,
          tickLowerState,
          tickUpperState
        );
        const feeGrowthdeltaA = MathUtil2.mulDivFloor(
          MathUtil2.wrappingSubU128(feeGrowthInsideX64A, positionState.feeGrowthInsideLastX64A),
          positionState.liquidity,
          Q642
        );
        const tokenFeeAmountA = positionState.tokenFeesOwedA.add(feeGrowthdeltaA);
        const feeGrowthdelta1 = MathUtil2.mulDivFloor(
          MathUtil2.wrappingSubU128(feeGrowthInsideBX64, positionState.feeGrowthInsideLastX64B),
          positionState.liquidity,
          Q642
        );
        const tokenFeeAmountB = positionState.tokenFeesOwedB.add(feeGrowthdelta1);
        return { tokenFeeAmountA, tokenFeeAmountB };
      }
      static GetPositionRewards(ammPool, positionState, tickLowerState, tickUpperState) {
        const rewards = [];
        const rewardGrowthsInside = this.getRewardGrowthInside(
          ammPool.tickCurrent,
          tickLowerState,
          tickUpperState,
          ammPool.rewardInfos
        );
        for (let i = 0; i < rewardGrowthsInside.length; i++) {
          const rewardGrowthInside = rewardGrowthsInside[i];
          const currRewardInfo = positionState.rewardInfos[i];
          const rewardGrowthDelta = MathUtil2.wrappingSubU128(rewardGrowthInside, currRewardInfo.growthInsideLastX64);
          const amountOwedDelta = MathUtil2.mulDivFloor(rewardGrowthDelta, positionState.liquidity, Q642);
          const rewardAmountOwed = currRewardInfo.rewardAmountOwed.add(amountOwedDelta);
          rewards.push(rewardAmountOwed);
        }
        return rewards;
      }
      static getRewardGrowthInside(tickCurrentIndex, tickLowerState, tickUpperState, rewardInfos) {
        const rewardGrowthsInside = [];
        for (let i = 0; i < rewardInfos.length; i++) {
          let rewardGrowthsBelow = new import_bn14.default(0);
          if (tickLowerState.liquidityGross.eqn(0)) {
            rewardGrowthsBelow = rewardInfos[i].rewardGrowthGlobalX64;
          } else if (tickCurrentIndex < tickLowerState.tick) {
            rewardGrowthsBelow = rewardInfos[i].rewardGrowthGlobalX64.sub(tickLowerState.rewardGrowthsOutsideX64[i]);
          } else {
            rewardGrowthsBelow = tickLowerState.rewardGrowthsOutsideX64[i];
          }
          let rewardGrowthsAbove = new import_bn14.default(0);
          if (tickUpperState.liquidityGross.eqn(0)) {
          } else if (tickCurrentIndex < tickUpperState.tick) {
            rewardGrowthsAbove = tickUpperState.rewardGrowthsOutsideX64[i];
          } else {
            rewardGrowthsAbove = rewardInfos[i].rewardGrowthGlobalX64.sub(tickUpperState.rewardGrowthsOutsideX64[i]);
          }
          rewardGrowthsInside.push(
            MathUtil2.wrappingSubU128(
              MathUtil2.wrappingSubU128(rewardInfos[i].rewardGrowthGlobalX64, rewardGrowthsBelow),
              rewardGrowthsAbove
            )
          );
        }
        return rewardGrowthsInside;
      }
    };
    var logger9 = Logger2.from("Clmm");
    var Clmm2 = class extends Base {
      static makeMockPoolInfo({
        programId,
        mint1,
        mint2,
        ammConfig,
        createPoolInstructionSimpleAddress,
        initialPrice,
        startTime,
        owner
      }) {
        const [mintA, mintB, initPrice] = new import_bn15.default(mint1.mint.toBuffer()).gt(new import_bn15.default(mint2.mint.toBuffer())) ? [mint2, mint1, new import_decimal3.default(1).div(initialPrice)] : [mint1, mint2, initialPrice];
        const initialPriceX64 = SqrtPriceMath2.priceToSqrtPriceX64(initPrice, mintA.decimals, mintB.decimals);
        return {
          id: createPoolInstructionSimpleAddress.poolId,
          mintA: {
            programId: createPoolInstructionSimpleAddress.mintProgramIdA,
            mint: createPoolInstructionSimpleAddress.mintA,
            vault: createPoolInstructionSimpleAddress.mintAVault,
            decimals: mintA.decimals
          },
          mintB: {
            programId: createPoolInstructionSimpleAddress.mintProgramIdB,
            mint: createPoolInstructionSimpleAddress.mintB,
            vault: createPoolInstructionSimpleAddress.mintBVault,
            decimals: mintB.decimals
          },
          ammConfig,
          observationId: createPoolInstructionSimpleAddress.observationId,
          creator: owner,
          programId,
          version: 6,
          tickSpacing: ammConfig.tickSpacing,
          liquidity: ZERO2,
          sqrtPriceX64: initialPriceX64,
          currentPrice: initPrice,
          tickCurrent: 0,
          observationIndex: 0,
          observationUpdateDuration: 0,
          feeGrowthGlobalX64A: ZERO2,
          feeGrowthGlobalX64B: ZERO2,
          protocolFeesTokenA: ZERO2,
          protocolFeesTokenB: ZERO2,
          swapInAmountTokenA: ZERO2,
          swapOutAmountTokenB: ZERO2,
          swapInAmountTokenB: ZERO2,
          swapOutAmountTokenA: ZERO2,
          tickArrayBitmap: [],
          rewardInfos: [],
          day: {
            volume: 0,
            volumeFee: 0,
            feeA: 0,
            feeB: 0,
            feeApr: 0,
            rewardApr: { A: 0, B: 0, C: 0 },
            apr: 0,
            priceMax: 0,
            priceMin: 0
          },
          week: {
            volume: 0,
            volumeFee: 0,
            feeA: 0,
            feeB: 0,
            feeApr: 0,
            rewardApr: { A: 0, B: 0, C: 0 },
            apr: 0,
            priceMax: 0,
            priceMin: 0
          },
          month: {
            volume: 0,
            volumeFee: 0,
            feeA: 0,
            feeB: 0,
            feeApr: 0,
            rewardApr: { A: 0, B: 0, C: 0 },
            apr: 0,
            priceMax: 0,
            priceMin: 0
          },
          tvl: 0,
          lookupTableAccount: import_web318.PublicKey.default,
          startTime: startTime.toNumber(),
          exBitmapInfo: {
            poolId: createPoolInstructionSimpleAddress.poolId,
            positiveTickArrayBitmap: Array.from(
              { length: EXTENSION_TICKARRAY_BITMAP_SIZE2 },
              () => Array.from({ length: 8 }, () => new import_bn15.default(0))
            ),
            negativeTickArrayBitmap: Array.from(
              { length: EXTENSION_TICKARRAY_BITMAP_SIZE2 },
              () => Array.from({ length: 8 }, () => new import_bn15.default(0))
            )
          }
        };
      }
      // transaction
      static makeCreatePoolInstructionSimple(_0) {
        return __async(this, arguments, function* ({
          makeTxVersion,
          connection,
          programId,
          owner,
          payer,
          mint1,
          mint2,
          ammConfig,
          initialPrice,
          startTime,
          computeBudgetConfig,
          lookupTableCache
        }) {
          const [mintA, mintB, initPrice] = new import_bn15.default(mint1.mint.toBuffer()).gt(new import_bn15.default(mint2.mint.toBuffer())) ? [mint2, mint1, new import_decimal3.default(1).div(initialPrice)] : [mint1, mint2, initialPrice];
          const initialPriceX64 = SqrtPriceMath2.priceToSqrtPriceX64(initPrice, mintA.decimals, mintB.decimals);
          const makeCreatePoolInstructions = yield this.makeCreatePoolInstructions({
            connection,
            programId,
            owner,
            mintA,
            mintB,
            ammConfigId: ammConfig.id,
            initialPriceX64,
            startTime
          });
          return {
            address: __spreadProps(__spreadValues({}, makeCreatePoolInstructions.address), {
              mintA: mintA.mint,
              mintB: mintB.mint,
              mintProgramIdA: mintA.programId,
              mintProgramIdB: mintB.programId
            }),
            innerTransactions: yield splitTxAndSigners({
              connection,
              makeTxVersion,
              computeBudgetConfig,
              payer,
              innerTransaction: [makeCreatePoolInstructions.innerTransaction],
              lookupTableCache
            })
          };
        });
      }
      static makeOpenPositionFromLiquidityInstructionSimple(_0) {
        return __async(this, arguments, function* ({
          makeTxVersion,
          connection,
          poolInfo,
          ownerInfo,
          amountMaxA,
          amountMaxB,
          tickLower,
          tickUpper,
          liquidity,
          associatedOnly = true,
          checkCreateATAOwner = false,
          withMetadata = "create",
          getEphemeralSigners,
          computeBudgetConfig,
          lookupTableCache
        }) {
          const frontInstructions = [];
          const endInstructions = [];
          const frontInstructionsType = [];
          const endInstructionsType = [];
          const signers = [];
          const mintAUseSOLBalance = ownerInfo.useSOLBalance && poolInfo.mintA.mint.equals(Token3.WSOL.mint);
          const mintBUseSOLBalance = ownerInfo.useSOLBalance && poolInfo.mintB.mint.equals(Token3.WSOL.mint);
          const ownerTokenAccountA = yield this._selectOrCreateTokenAccount({
            programId: poolInfo.mintA.programId,
            mint: poolInfo.mintA.mint,
            tokenAccounts: mintAUseSOLBalance ? [] : ownerInfo.tokenAccounts,
            owner: ownerInfo.wallet,
            createInfo: mintAUseSOLBalance || amountMaxA.eq(ZERO2) ? {
              connection,
              payer: ownerInfo.feePayer,
              amount: amountMaxA,
              frontInstructions,
              endInstructions,
              frontInstructionsType,
              endInstructionsType,
              signers
            } : void 0,
            associatedOnly: mintAUseSOLBalance ? false : associatedOnly,
            checkCreateATAOwner
          });
          const ownerTokenAccountB = yield this._selectOrCreateTokenAccount({
            programId: poolInfo.mintB.programId,
            mint: poolInfo.mintB.mint,
            tokenAccounts: mintBUseSOLBalance ? [] : ownerInfo.tokenAccounts,
            owner: ownerInfo.wallet,
            createInfo: mintBUseSOLBalance || amountMaxB.eq(ZERO2) ? {
              connection,
              payer: ownerInfo.feePayer,
              amount: amountMaxB,
              frontInstructions,
              endInstructions,
              frontInstructionsType,
              endInstructionsType,
              signers
            } : void 0,
            associatedOnly: mintBUseSOLBalance ? false : associatedOnly,
            checkCreateATAOwner
          });
          logger9.assertArgument(
            ownerTokenAccountA !== void 0 && ownerTokenAccountB !== void 0,
            "cannot found target token accounts",
            "tokenAccounts",
            ownerInfo.tokenAccounts
          );
          const makeOpenPositionInstructions = yield this.makeOpenPositionFromLiquidityInstructions({
            poolInfo,
            ownerInfo: __spreadProps(__spreadValues({}, ownerInfo), {
              tokenAccountA: ownerTokenAccountA,
              tokenAccountB: ownerTokenAccountB
            }),
            tickLower,
            tickUpper,
            liquidity,
            amountMaxA,
            amountMaxB,
            withMetadata,
            getEphemeralSigners
          });
          return {
            address: makeOpenPositionInstructions.address,
            innerTransactions: yield splitTxAndSigners({
              connection,
              makeTxVersion,
              computeBudgetConfig,
              payer: ownerInfo.feePayer,
              innerTransaction: [
                { instructionTypes: frontInstructionsType, instructions: frontInstructions, signers },
                makeOpenPositionInstructions.innerTransaction,
                { instructionTypes: endInstructionsType, instructions: endInstructions, signers: [] }
              ],
              lookupTableCache
            })
          };
        });
      }
      static makeOpenPositionFromBaseInstructionSimple(_0) {
        return __async(this, arguments, function* ({
          connection,
          poolInfo,
          ownerInfo,
          tickLower,
          tickUpper,
          base,
          baseAmount,
          otherAmountMax,
          associatedOnly = true,
          checkCreateATAOwner = false,
          computeBudgetConfig,
          withMetadata = "create",
          makeTxVersion,
          lookupTableCache,
          getEphemeralSigners
        }) {
          const frontInstructions = [];
          const endInstructions = [];
          const frontInstructionsType = [];
          const endInstructionsType = [];
          const signers = [];
          const mintAUseSOLBalance = ownerInfo.useSOLBalance && poolInfo.mintA.mint.equals(Token3.WSOL.mint);
          const mintBUseSOLBalance = ownerInfo.useSOLBalance && poolInfo.mintB.mint.equals(Token3.WSOL.mint);
          const ownerTokenAccountA = yield this._selectOrCreateTokenAccount({
            programId: poolInfo.mintA.programId,
            mint: poolInfo.mintA.mint,
            tokenAccounts: mintAUseSOLBalance ? [] : ownerInfo.tokenAccounts,
            owner: ownerInfo.wallet,
            createInfo: mintAUseSOLBalance ? {
              connection,
              payer: ownerInfo.feePayer,
              amount: base === "MintA" ? baseAmount : otherAmountMax,
              frontInstructions,
              endInstructions,
              frontInstructionsType,
              endInstructionsType,
              signers
            } : void 0,
            associatedOnly: mintAUseSOLBalance ? false : associatedOnly,
            checkCreateATAOwner
          });
          const ownerTokenAccountB = yield this._selectOrCreateTokenAccount({
            programId: poolInfo.mintB.programId,
            mint: poolInfo.mintB.mint,
            tokenAccounts: mintBUseSOLBalance ? [] : ownerInfo.tokenAccounts,
            owner: ownerInfo.wallet,
            createInfo: mintBUseSOLBalance ? {
              connection,
              payer: ownerInfo.feePayer,
              amount: base === "MintA" ? otherAmountMax : baseAmount,
              frontInstructions,
              endInstructions,
              frontInstructionsType,
              endInstructionsType,
              signers
            } : void 0,
            associatedOnly: mintBUseSOLBalance ? false : associatedOnly,
            checkCreateATAOwner
          });
          logger9.assertArgument(
            ownerTokenAccountA !== void 0 && ownerTokenAccountB !== void 0,
            "cannot found target token accounts",
            "tokenAccounts",
            ownerInfo.tokenAccounts
          );
          const makeOpenPositionInstructions = yield this.makeOpenPositionFromBaseInstructions({
            poolInfo,
            ownerInfo: __spreadProps(__spreadValues({}, ownerInfo), {
              tokenAccountA: ownerTokenAccountA,
              tokenAccountB: ownerTokenAccountB
            }),
            tickLower,
            tickUpper,
            base,
            baseAmount,
            otherAmountMax,
            withMetadata,
            getEphemeralSigners
          });
          return {
            address: makeOpenPositionInstructions.address,
            innerTransactions: yield splitTxAndSigners({
              connection,
              makeTxVersion,
              computeBudgetConfig,
              payer: ownerInfo.feePayer,
              innerTransaction: [
                { instructionTypes: frontInstructionsType, instructions: frontInstructions, signers },
                makeOpenPositionInstructions.innerTransaction,
                { instructionTypes: endInstructionsType, instructions: endInstructions, signers: [] }
              ],
              lookupTableCache
            })
          };
        });
      }
      static makeIncreasePositionFromLiquidityInstructionSimple(_0) {
        return __async(this, arguments, function* ({
          connection,
          poolInfo,
          ownerPosition,
          ownerInfo,
          amountMaxA,
          amountMaxB,
          liquidity,
          associatedOnly = true,
          checkCreateATAOwner = false,
          computeBudgetConfig,
          makeTxVersion,
          lookupTableCache
        }) {
          const frontInstructions = [];
          const endInstructions = [];
          const frontInstructionsType = [];
          const endInstructionsType = [];
          const signers = [];
          const mintAUseSOLBalance = ownerInfo.useSOLBalance && poolInfo.mintA.mint.equals(Token3.WSOL.mint);
          const mintBUseSOLBalance = ownerInfo.useSOLBalance && poolInfo.mintB.mint.equals(Token3.WSOL.mint);
          const ownerTokenAccountA = yield this._selectOrCreateTokenAccount({
            programId: poolInfo.mintA.programId,
            mint: poolInfo.mintA.mint,
            tokenAccounts: mintAUseSOLBalance ? [] : ownerInfo.tokenAccounts,
            owner: ownerInfo.wallet,
            createInfo: mintAUseSOLBalance ? {
              connection,
              payer: ownerInfo.feePayer,
              amount: amountMaxA,
              frontInstructions,
              endInstructions,
              frontInstructionsType,
              endInstructionsType,
              signers
            } : void 0,
            associatedOnly: mintAUseSOLBalance ? false : associatedOnly,
            checkCreateATAOwner
          });
          const ownerTokenAccountB = yield this._selectOrCreateTokenAccount({
            programId: poolInfo.mintB.programId,
            mint: poolInfo.mintB.mint,
            tokenAccounts: mintBUseSOLBalance ? [] : ownerInfo.tokenAccounts,
            owner: ownerInfo.wallet,
            createInfo: mintBUseSOLBalance ? {
              connection,
              payer: ownerInfo.feePayer,
              amount: amountMaxB,
              frontInstructions,
              endInstructions,
              frontInstructionsType,
              endInstructionsType,
              signers
            } : void 0,
            associatedOnly: mintBUseSOLBalance ? false : associatedOnly,
            checkCreateATAOwner
          });
          logger9.assertArgument(
            !!ownerTokenAccountA || !!ownerTokenAccountB,
            "cannot found target token accounts",
            "tokenAccounts",
            ownerInfo.tokenAccounts
          );
          const makeIncreaseLiquidityInstructions = this.makeIncreasePositionFromLiquidityInstructions({
            poolInfo,
            ownerPosition,
            ownerInfo: {
              wallet: ownerInfo.wallet,
              tokenAccountA: ownerTokenAccountA,
              tokenAccountB: ownerTokenAccountB
            },
            liquidity,
            amountMaxA,
            amountMaxB
          });
          return {
            address: makeIncreaseLiquidityInstructions.address,
            innerTransactions: yield splitTxAndSigners({
              connection,
              makeTxVersion,
              computeBudgetConfig,
              payer: ownerInfo.feePayer,
              innerTransaction: [
                { instructionTypes: frontInstructionsType, instructions: frontInstructions, signers },
                makeIncreaseLiquidityInstructions.innerTransaction,
                { instructionTypes: endInstructionsType, instructions: endInstructions, signers: [] }
              ],
              lookupTableCache
            })
          };
        });
      }
      static makeIncreasePositionFromBaseInstructionSimple(_0) {
        return __async(this, arguments, function* ({
          connection,
          poolInfo,
          ownerPosition,
          ownerInfo,
          base,
          baseAmount,
          otherAmountMax,
          associatedOnly = true,
          checkCreateATAOwner = false,
          computeBudgetConfig,
          makeTxVersion,
          lookupTableCache
        }) {
          const frontInstructions = [];
          const endInstructions = [];
          const frontInstructionsType = [];
          const endInstructionsType = [];
          const signers = [];
          const mintAUseSOLBalance = ownerInfo.useSOLBalance && poolInfo.mintA.mint.equals(Token3.WSOL.mint);
          const mintBUseSOLBalance = ownerInfo.useSOLBalance && poolInfo.mintB.mint.equals(Token3.WSOL.mint);
          const ownerTokenAccountA = yield this._selectOrCreateTokenAccount({
            programId: poolInfo.mintA.programId,
            mint: poolInfo.mintA.mint,
            tokenAccounts: mintAUseSOLBalance ? [] : ownerInfo.tokenAccounts,
            owner: ownerInfo.wallet,
            createInfo: mintAUseSOLBalance ? {
              connection,
              payer: ownerInfo.feePayer,
              amount: base === "MintA" ? baseAmount : otherAmountMax,
              frontInstructions,
              endInstructions,
              frontInstructionsType,
              endInstructionsType,
              signers
            } : void 0,
            associatedOnly: mintAUseSOLBalance ? false : associatedOnly,
            checkCreateATAOwner
          });
          const ownerTokenAccountB = yield this._selectOrCreateTokenAccount({
            programId: poolInfo.mintB.programId,
            mint: poolInfo.mintB.mint,
            tokenAccounts: mintBUseSOLBalance ? [] : ownerInfo.tokenAccounts,
            owner: ownerInfo.wallet,
            createInfo: mintBUseSOLBalance ? {
              connection,
              payer: ownerInfo.feePayer,
              amount: base === "MintA" ? otherAmountMax : baseAmount,
              frontInstructions,
              endInstructions,
              frontInstructionsType,
              endInstructionsType,
              signers
            } : void 0,
            associatedOnly: mintBUseSOLBalance ? false : associatedOnly,
            checkCreateATAOwner
          });
          logger9.assertArgument(
            !!ownerTokenAccountA || !!ownerTokenAccountB,
            "cannot found target token accounts",
            "tokenAccounts",
            ownerInfo.tokenAccounts
          );
          const makeIncreaseLiquidityInstructions = this.makeIncreasePositionFromBaseInstructions({
            poolInfo,
            ownerPosition,
            ownerInfo: {
              wallet: ownerInfo.wallet,
              tokenAccountA: ownerTokenAccountA,
              tokenAccountB: ownerTokenAccountB
            },
            base,
            baseAmount,
            otherAmountMax
          });
          return {
            address: makeIncreaseLiquidityInstructions.address,
            innerTransactions: yield splitTxAndSigners({
              connection,
              makeTxVersion,
              computeBudgetConfig,
              payer: ownerInfo.feePayer,
              innerTransaction: [
                { instructionTypes: frontInstructionsType, instructions: frontInstructions, signers },
                makeIncreaseLiquidityInstructions.innerTransaction,
                { instructionTypes: endInstructionsType, instructions: endInstructions, signers: [] }
              ],
              lookupTableCache
            })
          };
        });
      }
      static makeDecreaseLiquidityInstructionSimple(_0) {
        return __async(this, arguments, function* ({
          connection,
          poolInfo,
          ownerPosition,
          ownerInfo,
          liquidity,
          amountMinA,
          amountMinB,
          associatedOnly = true,
          checkCreateATAOwner = false,
          computeBudgetConfig,
          makeTxVersion,
          lookupTableCache
        }) {
          const frontInstructions = [];
          const endInstructions = [];
          const frontInstructionsType = [];
          const endInstructionsType = [];
          const signers = [];
          const mintAUseSOLBalance = ownerInfo.useSOLBalance && poolInfo.mintA.mint.equals(Token3.WSOL.mint);
          const mintBUseSOLBalance = ownerInfo.useSOLBalance && poolInfo.mintB.mint.equals(Token3.WSOL.mint);
          const ownerTokenAccountA = yield this._selectOrCreateTokenAccount({
            programId: poolInfo.mintA.programId,
            mint: poolInfo.mintA.mint,
            tokenAccounts: mintAUseSOLBalance ? [] : ownerInfo.tokenAccounts,
            owner: ownerInfo.wallet,
            createInfo: {
              connection,
              payer: ownerInfo.feePayer,
              amount: 0,
              frontInstructions,
              frontInstructionsType,
              endInstructions: mintAUseSOLBalance ? endInstructions : [],
              endInstructionsType: mintAUseSOLBalance ? endInstructionsType : [],
              signers
            },
            associatedOnly: mintAUseSOLBalance ? false : associatedOnly,
            checkCreateATAOwner
          });
          const ownerTokenAccountB = yield this._selectOrCreateTokenAccount({
            programId: poolInfo.mintB.programId,
            mint: poolInfo.mintB.mint,
            tokenAccounts: mintBUseSOLBalance ? [] : ownerInfo.tokenAccounts,
            owner: ownerInfo.wallet,
            createInfo: {
              connection,
              payer: ownerInfo.feePayer,
              amount: 0,
              frontInstructions,
              frontInstructionsType,
              endInstructions: mintBUseSOLBalance ? endInstructions : [],
              endInstructionsType: mintBUseSOLBalance ? endInstructionsType : [],
              signers
            },
            associatedOnly: mintBUseSOLBalance ? false : associatedOnly,
            checkCreateATAOwner
          });
          const rewardAccounts = [];
          for (const itemReward of poolInfo.rewardInfos) {
            const rewardUseSOLBalance = ownerInfo.useSOLBalance && itemReward.tokenMint.equals(Token3.WSOL.mint);
            const ownerRewardAccount = itemReward.tokenMint.equals(poolInfo.mintA.mint) ? ownerTokenAccountA : itemReward.tokenMint.equals(poolInfo.mintB.mint) ? ownerTokenAccountB : yield this._selectOrCreateTokenAccount({
              programId: itemReward.tokenProgramId,
              mint: itemReward.tokenMint,
              tokenAccounts: rewardUseSOLBalance ? [] : ownerInfo.tokenAccounts,
              owner: ownerInfo.wallet,
              createInfo: {
                connection,
                payer: ownerInfo.feePayer,
                amount: 0,
                frontInstructions,
                frontInstructionsType,
                endInstructions: rewardUseSOLBalance ? endInstructions : [],
                endInstructionsType: rewardUseSOLBalance ? endInstructionsType : [],
                signers
              },
              associatedOnly: rewardUseSOLBalance ? false : associatedOnly,
              checkCreateATAOwner
            });
            rewardAccounts.push(ownerRewardAccount);
          }
          logger9.assertArgument(
            !!ownerTokenAccountA || !!ownerTokenAccountB,
            "cannot found target token accounts",
            "tokenAccounts",
            ownerInfo.tokenAccounts
          );
          const makeDecreaseLiquidityInstructions = this.makeDecreaseLiquidityInstructions({
            poolInfo,
            ownerPosition,
            ownerInfo: {
              wallet: ownerInfo.wallet,
              tokenAccountA: ownerTokenAccountA,
              tokenAccountB: ownerTokenAccountB,
              rewardAccounts
            },
            liquidity,
            amountMinA,
            amountMinB
          });
          const makeClosePositionInstructions = ownerInfo.closePosition ? this.makeClosePositionInstructions({
            poolInfo,
            ownerInfo,
            ownerPosition
          }) : { address: {}, innerTransaction: { instructions: [], signers: [], instructionTypes: [] } };
          return {
            address: makeDecreaseLiquidityInstructions.address,
            innerTransactions: yield splitTxAndSigners({
              connection,
              makeTxVersion,
              computeBudgetConfig,
              payer: ownerInfo.feePayer,
              innerTransaction: [
                { instructionTypes: frontInstructionsType, instructions: frontInstructions, signers },
                makeDecreaseLiquidityInstructions.innerTransaction,
                { instructionTypes: endInstructionsType, instructions: endInstructions, signers: [] },
                makeClosePositionInstructions.innerTransaction
              ],
              lookupTableCache
            })
          };
        });
      }
      static makeSwapBaseInInstructionSimple(_0) {
        return __async(this, arguments, function* ({
          connection,
          poolInfo,
          ownerInfo,
          inputMint,
          amountIn,
          amountOutMin,
          priceLimit,
          remainingAccounts,
          associatedOnly = true,
          checkCreateATAOwner = false,
          computeBudgetConfig,
          makeTxVersion,
          lookupTableCache
        }) {
          const frontInstructions = [];
          const endInstructions = [];
          const frontInstructionsType = [];
          const endInstructionsType = [];
          const signers = [];
          let sqrtPriceLimitX64;
          if (!priceLimit || priceLimit.equals(new import_decimal3.default(0))) {
            sqrtPriceLimitX64 = inputMint.equals(poolInfo.mintA.mint) ? MIN_SQRT_PRICE_X642.add(ONE2) : MAX_SQRT_PRICE_X642.sub(ONE2);
          } else {
            sqrtPriceLimitX64 = SqrtPriceMath2.priceToSqrtPriceX64(
              priceLimit,
              poolInfo.mintA.decimals,
              poolInfo.mintB.decimals
            );
          }
          const isInputMintA = poolInfo.mintA.mint.equals(inputMint);
          const mintAUseSOLBalance = ownerInfo.useSOLBalance && poolInfo.mintA.mint.equals(Token3.WSOL.mint);
          const mintBUseSOLBalance = ownerInfo.useSOLBalance && poolInfo.mintB.mint.equals(Token3.WSOL.mint);
          const ownerTokenAccountA = yield this._selectOrCreateTokenAccount({
            programId: poolInfo.mintA.programId,
            mint: poolInfo.mintA.mint,
            tokenAccounts: mintAUseSOLBalance ? [] : ownerInfo.tokenAccounts,
            owner: ownerInfo.wallet,
            createInfo: mintAUseSOLBalance || !isInputMintA ? {
              connection,
              payer: ownerInfo.feePayer,
              amount: isInputMintA ? amountIn : 0,
              frontInstructions,
              endInstructions,
              frontInstructionsType,
              endInstructionsType,
              signers
            } : void 0,
            associatedOnly: mintAUseSOLBalance ? false : associatedOnly,
            checkCreateATAOwner
          });
          const ownerTokenAccountB = yield this._selectOrCreateTokenAccount({
            programId: poolInfo.mintB.programId,
            mint: poolInfo.mintB.mint,
            tokenAccounts: mintBUseSOLBalance ? [] : ownerInfo.tokenAccounts,
            owner: ownerInfo.wallet,
            createInfo: mintBUseSOLBalance || isInputMintA ? {
              connection,
              payer: ownerInfo.feePayer,
              amount: isInputMintA ? 0 : amountIn,
              frontInstructions,
              endInstructions,
              frontInstructionsType,
              endInstructionsType,
              signers
            } : void 0,
            associatedOnly: mintBUseSOLBalance ? false : associatedOnly,
            checkCreateATAOwner
          });
          logger9.assertArgument(
            !!ownerTokenAccountA || !!ownerTokenAccountB,
            "cannot found target token accounts",
            "tokenAccounts",
            ownerInfo.tokenAccounts
          );
          const makeSwapBaseInInstructions = this.makeSwapBaseInInstructions({
            poolInfo,
            ownerInfo: {
              wallet: ownerInfo.wallet,
              tokenAccountA: ownerTokenAccountA,
              tokenAccountB: ownerTokenAccountB
            },
            inputMint,
            amountIn,
            amountOutMin,
            sqrtPriceLimitX64,
            remainingAccounts
          });
          return {
            address: makeSwapBaseInInstructions.address,
            innerTransactions: yield splitTxAndSigners({
              connection,
              makeTxVersion,
              computeBudgetConfig,
              payer: ownerInfo.feePayer,
              innerTransaction: [
                { instructionTypes: frontInstructionsType, instructions: frontInstructions, signers },
                makeSwapBaseInInstructions.innerTransaction,
                { instructionTypes: endInstructionsType, instructions: endInstructions, signers: [] }
              ],
              lookupTableCache
            })
          };
        });
      }
      static makeSwapBaseOutInstructionSimple(_0) {
        return __async(this, arguments, function* ({
          connection,
          poolInfo,
          ownerInfo,
          outputMint,
          amountOut,
          amountInMax,
          priceLimit,
          remainingAccounts,
          associatedOnly = true,
          checkCreateATAOwner = false,
          computeBudgetConfig,
          makeTxVersion,
          lookupTableCache
        }) {
          const frontInstructions = [];
          const endInstructions = [];
          const frontInstructionsType = [];
          const endInstructionsType = [];
          const signers = [];
          let sqrtPriceLimitX64;
          if (!priceLimit || priceLimit.equals(new import_decimal3.default(0))) {
            sqrtPriceLimitX64 = outputMint.equals(poolInfo.mintB.mint) ? MIN_SQRT_PRICE_X642.add(ONE2) : MAX_SQRT_PRICE_X642.sub(ONE2);
          } else {
            sqrtPriceLimitX64 = SqrtPriceMath2.priceToSqrtPriceX64(
              priceLimit,
              poolInfo.mintA.decimals,
              poolInfo.mintB.decimals
            );
          }
          const isInputMintA = poolInfo.mintA.mint.equals(outputMint);
          const mintAUseSOLBalance = ownerInfo.useSOLBalance && poolInfo.mintA.mint.equals(Token3.WSOL.mint);
          const mintBUseSOLBalance = ownerInfo.useSOLBalance && poolInfo.mintB.mint.equals(Token3.WSOL.mint);
          const ownerTokenAccountA = yield this._selectOrCreateTokenAccount({
            programId: poolInfo.mintA.programId,
            mint: poolInfo.mintA.mint,
            tokenAccounts: mintAUseSOLBalance ? [] : ownerInfo.tokenAccounts,
            owner: ownerInfo.wallet,
            createInfo: mintAUseSOLBalance || !isInputMintA ? {
              connection,
              payer: ownerInfo.feePayer,
              amount: isInputMintA ? amountInMax : 0,
              frontInstructions,
              endInstructions,
              frontInstructionsType,
              endInstructionsType,
              signers
            } : void 0,
            associatedOnly: mintAUseSOLBalance ? false : associatedOnly,
            checkCreateATAOwner
          });
          const ownerTokenAccountB = yield this._selectOrCreateTokenAccount({
            programId: poolInfo.mintB.programId,
            mint: poolInfo.mintB.mint,
            tokenAccounts: mintBUseSOLBalance ? [] : ownerInfo.tokenAccounts,
            owner: ownerInfo.wallet,
            createInfo: mintBUseSOLBalance || isInputMintA ? {
              connection,
              payer: ownerInfo.feePayer,
              amount: isInputMintA ? 0 : amountInMax,
              frontInstructions,
              endInstructions,
              frontInstructionsType,
              endInstructionsType,
              signers
            } : void 0,
            associatedOnly: mintBUseSOLBalance ? false : associatedOnly,
            checkCreateATAOwner
          });
          logger9.assertArgument(
            !!ownerTokenAccountA || !!ownerTokenAccountB,
            "cannot found target token accounts",
            "tokenAccounts",
            ownerInfo.tokenAccounts
          );
          const makeSwapBaseOutInstructions = this.makeSwapBaseOutInstructions({
            poolInfo,
            ownerInfo: {
              wallet: ownerInfo.wallet,
              tokenAccountA: ownerTokenAccountA,
              tokenAccountB: ownerTokenAccountB
            },
            outputMint,
            amountOut,
            amountInMax,
            sqrtPriceLimitX64,
            remainingAccounts
          });
          return {
            address: makeSwapBaseOutInstructions.address,
            innerTransactions: yield splitTxAndSigners({
              connection,
              makeTxVersion,
              computeBudgetConfig,
              payer: ownerInfo.feePayer,
              innerTransaction: [
                { instructionTypes: frontInstructionsType, instructions: frontInstructions, signers },
                makeSwapBaseOutInstructions.innerTransaction,
                { instructionTypes: endInstructionsType, instructions: endInstructions, signers: [] }
              ],
              lookupTableCache
            })
          };
        });
      }
      static makeCLosePositionInstructionSimple(_0) {
        return __async(this, arguments, function* ({
          poolInfo,
          ownerPosition,
          ownerInfo,
          makeTxVersion,
          lookupTableCache,
          connection
        }) {
          const data = this.makeClosePositionInstructions({ poolInfo, ownerInfo, ownerPosition });
          return {
            address: data.address,
            innerTransactions: yield splitTxAndSigners({
              connection,
              makeTxVersion,
              computeBudgetConfig: void 0,
              payer: ownerInfo.feePayer,
              innerTransaction: [data.innerTransaction],
              lookupTableCache
            })
          };
        });
      }
      static makeInitRewardInstructionSimple(_0) {
        return __async(this, arguments, function* ({
          connection,
          poolInfo,
          ownerInfo,
          rewardInfo,
          chainTime,
          associatedOnly = true,
          checkCreateATAOwner = false,
          makeTxVersion,
          lookupTableCache
        }) {
          logger9.assertArgument(rewardInfo.endTime > rewardInfo.openTime, "reward time error", "rewardInfo", rewardInfo);
          logger9.assertArgument(rewardInfo.openTime > chainTime, "reward must be paid later", "rewardInfo", rewardInfo);
          const frontInstructions = [];
          const endInstructions = [];
          const frontInstructionsType = [];
          const endInstructionsType = [];
          const signers = [];
          const rewardMintUseSOLBalance = ownerInfo.useSOLBalance && rewardInfo.mint.equals(Token3.WSOL.mint);
          const _baseRewardAmount = rewardInfo.perSecond.mul(rewardInfo.endTime - rewardInfo.openTime);
          const ownerRewardAccount = yield this._selectOrCreateTokenAccount({
            programId: rewardInfo.programId,
            mint: rewardInfo.mint,
            tokenAccounts: rewardMintUseSOLBalance ? [] : ownerInfo.tokenAccounts,
            owner: ownerInfo.wallet,
            createInfo: rewardMintUseSOLBalance ? {
              connection,
              payer: ownerInfo.feePayer,
              amount: new import_bn15.default(
                new import_decimal3.default(_baseRewardAmount.toFixed(0)).gte(_baseRewardAmount) ? _baseRewardAmount.toFixed(0) : _baseRewardAmount.add(1).toFixed(0)
              ),
              frontInstructions,
              endInstructions,
              frontInstructionsType,
              endInstructionsType,
              signers
            } : void 0,
            associatedOnly: rewardMintUseSOLBalance ? false : associatedOnly,
            checkCreateATAOwner
          });
          logger9.assertArgument(ownerRewardAccount, "no money", "ownerRewardAccount", ownerInfo.tokenAccounts);
          const makeInitRewardInstructions = this.makeInitRewardInstructions({
            poolInfo,
            ownerInfo: {
              wallet: ownerInfo.wallet,
              tokenAccount: ownerRewardAccount
            },
            rewardInfo: {
              programId: rewardInfo.programId,
              mint: rewardInfo.mint,
              openTime: rewardInfo.openTime,
              endTime: rewardInfo.endTime,
              emissionsPerSecondX64: MathUtil2.decimalToX64(rewardInfo.perSecond)
            }
          });
          return {
            address: makeInitRewardInstructions.address,
            innerTransactions: yield splitTxAndSigners({
              connection,
              makeTxVersion,
              computeBudgetConfig: void 0,
              payer: ownerInfo.feePayer,
              innerTransaction: [
                { instructionTypes: frontInstructionsType, instructions: frontInstructions, signers },
                makeInitRewardInstructions.innerTransaction,
                { instructionTypes: endInstructionsType, instructions: endInstructions, signers: [] }
              ],
              lookupTableCache
            })
          };
        });
      }
      static makeInitRewardsInstructionSimple(_0) {
        return __async(this, arguments, function* ({
          connection,
          poolInfo,
          ownerInfo,
          rewardInfos,
          associatedOnly = true,
          checkCreateATAOwner = false,
          computeBudgetConfig,
          makeTxVersion,
          lookupTableCache
        }) {
          for (const rewardInfo of rewardInfos)
            logger9.assertArgument(rewardInfo.endTime > rewardInfo.openTime, "reward time error", "rewardInfo", rewardInfo);
          const frontInstructions = [];
          const endInstructions = [];
          const frontInstructionsType = [];
          const endInstructionsType = [];
          const makeInitRewardInstructions = [];
          const signers = [];
          for (const rewardInfo of rewardInfos) {
            const rewardMintUseSOLBalance = ownerInfo.useSOLBalance && rewardInfo.mint.equals(Token3.WSOL.mint);
            const _baseRewardAmount = rewardInfo.perSecond.mul(rewardInfo.endTime - rewardInfo.openTime);
            const ownerRewardAccount = yield this._selectOrCreateTokenAccount({
              programId: rewardInfo.programId,
              mint: rewardInfo.mint,
              tokenAccounts: rewardMintUseSOLBalance ? [] : ownerInfo.tokenAccounts,
              owner: ownerInfo.wallet,
              createInfo: rewardMintUseSOLBalance ? {
                connection,
                payer: ownerInfo.feePayer,
                amount: new import_bn15.default(
                  new import_decimal3.default(_baseRewardAmount.toFixed(0)).gte(_baseRewardAmount) ? _baseRewardAmount.toFixed(0) : _baseRewardAmount.add(1).toFixed(0)
                ),
                frontInstructions,
                endInstructions,
                frontInstructionsType,
                endInstructionsType,
                signers
              } : void 0,
              associatedOnly: rewardMintUseSOLBalance ? false : associatedOnly,
              checkCreateATAOwner
            });
            logger9.assertArgument(ownerRewardAccount, "no money", "ownerRewardAccount", ownerInfo.tokenAccounts);
            makeInitRewardInstructions.push(
              this.makeInitRewardInstructions({
                poolInfo,
                ownerInfo: {
                  wallet: ownerInfo.wallet,
                  tokenAccount: ownerRewardAccount
                },
                rewardInfo: {
                  programId: rewardInfo.programId,
                  mint: rewardInfo.mint,
                  openTime: rewardInfo.openTime,
                  endTime: rewardInfo.endTime,
                  emissionsPerSecondX64: MathUtil2.decimalToX64(rewardInfo.perSecond)
                }
              })
            );
          }
          let address = {};
          for (const item of makeInitRewardInstructions) {
            address = __spreadValues(__spreadValues({}, address), item.address);
          }
          return {
            address,
            innerTransactions: yield splitTxAndSigners({
              connection,
              makeTxVersion,
              computeBudgetConfig,
              payer: ownerInfo.feePayer,
              innerTransaction: [
                { instructionTypes: frontInstructionsType, instructions: frontInstructions, signers },
                ...makeInitRewardInstructions.map((i) => i.innerTransaction),
                { instructionTypes: endInstructionsType, instructions: endInstructions, signers: [] }
              ],
              lookupTableCache
            })
          };
        });
      }
      static makeSetRewardInstructionSimple(_0) {
        return __async(this, arguments, function* ({
          connection,
          poolInfo,
          ownerInfo,
          rewardInfo,
          chainTime,
          associatedOnly = true,
          checkCreateATAOwner = false,
          makeTxVersion,
          lookupTableCache
        }) {
          logger9.assertArgument(rewardInfo.endTime > rewardInfo.openTime, "reward time error", "rewardInfo", rewardInfo);
          logger9.assertArgument(rewardInfo.openTime > chainTime, "reward must be paid later", "rewardInfo", rewardInfo);
          const frontInstructions = [];
          const endInstructions = [];
          const frontInstructionsType = [];
          const endInstructionsType = [];
          const signers = [];
          const rewardMintUseSOLBalance = ownerInfo.useSOLBalance && rewardInfo.mint.equals(Token3.WSOL.mint);
          const ownerRewardAccount = yield this._selectOrCreateTokenAccount({
            programId: rewardInfo.programId,
            mint: rewardInfo.mint,
            tokenAccounts: rewardMintUseSOLBalance ? [] : ownerInfo.tokenAccounts,
            owner: ownerInfo.wallet,
            createInfo: rewardMintUseSOLBalance ? {
              connection,
              payer: ownerInfo.feePayer,
              amount: new import_bn15.default(
                new import_decimal3.default(rewardInfo.perSecond.sub(rewardInfo.endTime - rewardInfo.openTime).toFixed(0)).gte(
                  rewardInfo.perSecond.sub(rewardInfo.endTime - rewardInfo.openTime)
                ) ? rewardInfo.perSecond.sub(rewardInfo.endTime - rewardInfo.openTime).toFixed(0) : rewardInfo.perSecond.sub(rewardInfo.endTime - rewardInfo.openTime).add(1).toFixed(0)
              ),
              frontInstructions,
              endInstructions,
              frontInstructionsType,
              endInstructionsType,
              signers
            } : void 0,
            associatedOnly: rewardMintUseSOLBalance ? false : associatedOnly,
            checkCreateATAOwner
          });
          logger9.assertArgument(ownerRewardAccount, "no money", "ownerRewardAccount", ownerInfo.tokenAccounts);
          const makeSetRewardInstructions = this.makeSetRewardInstructions({
            poolInfo,
            ownerInfo: {
              wallet: ownerInfo.wallet,
              tokenAccount: ownerRewardAccount
            },
            rewardInfo: {
              mint: rewardInfo.mint,
              openTime: rewardInfo.openTime,
              endTime: rewardInfo.endTime,
              emissionsPerSecondX64: MathUtil2.decimalToX64(rewardInfo.perSecond)
            }
          });
          return {
            address: makeSetRewardInstructions.address,
            innerTransactions: yield splitTxAndSigners({
              connection,
              makeTxVersion,
              computeBudgetConfig: void 0,
              payer: ownerInfo.feePayer,
              innerTransaction: [
                { instructionTypes: frontInstructionsType, instructions: frontInstructions, signers },
                makeSetRewardInstructions.innerTransaction,
                { instructionTypes: endInstructionsType, instructions: endInstructions, signers: [] }
              ],
              lookupTableCache
            })
          };
        });
      }
      static makeSetRewardsInstructionSimple(_0) {
        return __async(this, arguments, function* ({
          connection,
          poolInfo,
          ownerInfo,
          rewardInfos,
          chainTime,
          associatedOnly = true,
          checkCreateATAOwner = false,
          computeBudgetConfig,
          makeTxVersion,
          lookupTableCache
        }) {
          const frontInstructions = [];
          const endInstructions = [];
          const frontInstructionsType = [];
          const endInstructionsType = [];
          const makeSetRewardInstructions = [];
          const signers = [];
          for (const rewardInfo of rewardInfos) {
            logger9.assertArgument(rewardInfo.endTime > rewardInfo.openTime, "reward time error", "rewardInfo", rewardInfo);
            logger9.assertArgument(rewardInfo.openTime > chainTime, "reward must be paid later", "rewardInfo", rewardInfo);
            const rewardMintUseSOLBalance = ownerInfo.useSOLBalance && rewardInfo.mint.equals(Token3.WSOL.mint);
            const ownerRewardAccount = yield this._selectOrCreateTokenAccount({
              programId: rewardInfo.programId,
              mint: rewardInfo.mint,
              tokenAccounts: rewardMintUseSOLBalance ? [] : ownerInfo.tokenAccounts,
              owner: ownerInfo.wallet,
              createInfo: rewardMintUseSOLBalance ? {
                connection,
                payer: ownerInfo.feePayer,
                amount: new import_bn15.default(
                  new import_decimal3.default(rewardInfo.perSecond.sub(rewardInfo.endTime - rewardInfo.openTime).toFixed(0)).gte(
                    rewardInfo.perSecond.sub(rewardInfo.endTime - rewardInfo.openTime)
                  ) ? rewardInfo.perSecond.sub(rewardInfo.endTime - rewardInfo.openTime).toFixed(0) : rewardInfo.perSecond.sub(rewardInfo.endTime - rewardInfo.openTime).add(1).toFixed(0)
                ),
                frontInstructions,
                endInstructions,
                frontInstructionsType,
                endInstructionsType,
                signers
              } : void 0,
              associatedOnly: rewardMintUseSOLBalance ? false : associatedOnly,
              checkCreateATAOwner
            });
            logger9.assertArgument(ownerRewardAccount, "no money", "ownerRewardAccount", ownerInfo.tokenAccounts);
            makeSetRewardInstructions.push(
              this.makeSetRewardInstructions({
                poolInfo,
                ownerInfo: {
                  wallet: ownerInfo.wallet,
                  tokenAccount: ownerRewardAccount
                },
                rewardInfo: {
                  mint: rewardInfo.mint,
                  openTime: rewardInfo.openTime,
                  endTime: rewardInfo.endTime,
                  emissionsPerSecondX64: MathUtil2.decimalToX64(rewardInfo.perSecond)
                }
              })
            );
          }
          let address = {};
          for (const item of makeSetRewardInstructions) {
            address = __spreadValues(__spreadValues({}, address), item.address);
          }
          return {
            address,
            innerTransactions: yield splitTxAndSigners({
              connection,
              makeTxVersion,
              computeBudgetConfig,
              payer: ownerInfo.feePayer,
              innerTransaction: [
                { instructionTypes: frontInstructionsType, instructions: frontInstructions, signers },
                ...makeSetRewardInstructions.map((i) => i.innerTransaction),
                { instructionTypes: endInstructionsType, instructions: endInstructions, signers: [] }
              ],
              lookupTableCache
            })
          };
        });
      }
      static makeCollectRewardInstructionSimple(_0) {
        return __async(this, arguments, function* ({
          connection,
          poolInfo,
          ownerInfo,
          rewardMint,
          associatedOnly = true,
          checkCreateATAOwner = false,
          computeBudgetConfig,
          makeTxVersion,
          lookupTableCache
        }) {
          const frontInstructions = [];
          const endInstructions = [];
          const frontInstructionsType = [];
          const endInstructionsType = [];
          const signers = [];
          const rewardInfo = poolInfo.rewardInfos.find((i) => i.tokenMint.equals(rewardMint));
          logger9.assertArgument(rewardInfo !== void 0, "reward mint error", "not found reward mint", rewardMint);
          if (rewardInfo === void 0)
            throw Error("reward mint error");
          const rewardMintUseSOLBalance = ownerInfo.useSOLBalance && rewardMint.equals(Token3.WSOL.mint);
          const ownerRewardAccount = yield this._selectOrCreateTokenAccount({
            programId: rewardInfo.tokenProgramId,
            mint: rewardMint,
            tokenAccounts: rewardMintUseSOLBalance ? [] : ownerInfo.tokenAccounts,
            owner: ownerInfo.wallet,
            createInfo: {
              connection,
              payer: ownerInfo.feePayer,
              amount: 0,
              frontInstructions,
              endInstructions: rewardMintUseSOLBalance ? endInstructions : [],
              frontInstructionsType,
              endInstructionsType,
              signers
            },
            associatedOnly: rewardMintUseSOLBalance ? false : associatedOnly,
            checkCreateATAOwner
          });
          logger9.assertArgument(ownerRewardAccount, "no money", "ownerRewardAccount", ownerInfo.tokenAccounts);
          const makeCollectRewardInstructions = this.makeCollectRewardInstructions({
            poolInfo,
            ownerInfo: {
              wallet: ownerInfo.wallet,
              tokenAccount: ownerRewardAccount
            },
            rewardMint
          });
          return {
            address: makeCollectRewardInstructions.address,
            innerTransactions: yield splitTxAndSigners({
              connection,
              makeTxVersion,
              computeBudgetConfig,
              payer: ownerInfo.feePayer,
              innerTransaction: [
                { instructionTypes: frontInstructionsType, instructions: frontInstructions, signers },
                makeCollectRewardInstructions.innerTransaction,
                { instructionTypes: endInstructionsType, instructions: endInstructions, signers: [] }
              ],
              lookupTableCache
            })
          };
        });
      }
      static makeCollectRewardsInstructionSimple(_0) {
        return __async(this, arguments, function* ({
          connection,
          poolInfo,
          ownerInfo,
          rewardMints,
          associatedOnly = true,
          checkCreateATAOwner = false,
          computeBudgetConfig,
          makeTxVersion,
          lookupTableCache
        }) {
          const frontInstructions = [];
          const endInstructions = [];
          const frontInstructionsType = [];
          const endInstructionsType = [];
          const makeCollectRewardInstructions = [];
          const signers = [];
          for (const rewardMint of rewardMints) {
            const rewardInfo = poolInfo.rewardInfos.find((i) => i.tokenMint.equals(rewardMint));
            logger9.assertArgument(rewardInfo !== void 0, "reward mint error", "not found reward mint", rewardMint);
            if (rewardInfo === void 0)
              throw Error("reward mint error");
            const rewardMintUseSOLBalance = ownerInfo.useSOLBalance && rewardMint.equals(Token3.WSOL.mint);
            const ownerRewardAccount = yield this._selectOrCreateTokenAccount({
              programId: rewardInfo.tokenProgramId,
              mint: rewardMint,
              tokenAccounts: rewardMintUseSOLBalance ? [] : ownerInfo.tokenAccounts,
              owner: ownerInfo.wallet,
              createInfo: {
                connection,
                payer: ownerInfo.feePayer,
                amount: 0,
                frontInstructions,
                endInstructions: rewardMintUseSOLBalance ? endInstructions : [],
                signers,
                frontInstructionsType,
                endInstructionsType
              },
              associatedOnly: rewardMintUseSOLBalance ? false : associatedOnly,
              checkCreateATAOwner
            });
            logger9.assertArgument(ownerRewardAccount, "no money", "ownerRewardAccount", ownerInfo.tokenAccounts);
            makeCollectRewardInstructions.push(
              this.makeCollectRewardInstructions({
                poolInfo,
                ownerInfo: {
                  wallet: ownerInfo.wallet,
                  tokenAccount: ownerRewardAccount
                },
                rewardMint
              })
            );
          }
          let address = {};
          for (const item of makeCollectRewardInstructions) {
            address = __spreadValues(__spreadValues({}, address), item.address);
          }
          return {
            address,
            innerTransactions: yield splitTxAndSigners({
              connection,
              makeTxVersion,
              computeBudgetConfig,
              payer: ownerInfo.feePayer,
              innerTransaction: [
                { instructionTypes: frontInstructionsType, instructions: frontInstructions, signers },
                ...makeCollectRewardInstructions.map((i) => i.innerTransaction),
                { instructionTypes: endInstructionsType, instructions: endInstructions, signers: [] }
              ],
              lookupTableCache
            })
          };
        });
      }
      static makeHarvestAllRewardInstructionSimple(_0) {
        return __async(this, arguments, function* ({
          connection,
          fetchPoolInfos,
          ownerInfo,
          associatedOnly = true,
          checkCreateATAOwner = false,
          makeTxVersion,
          lookupTableCache
        }) {
          var _a, _b, _c;
          const ownerMintToAccount = {};
          for (const item of ownerInfo.tokenAccounts) {
            if (associatedOnly) {
              const ata = getATAAddress2(ownerInfo.wallet, item.accountInfo.mint, item.programId).publicKey;
              if (ata.equals(item.pubkey))
                ownerMintToAccount[item.accountInfo.mint.toString()] = item.pubkey;
            } else {
              ownerMintToAccount[item.accountInfo.mint.toString()] = item.pubkey;
            }
          }
          const frontInstructions = [];
          const endInstructions = [];
          const frontInstructionsType = [];
          const endInstructionsType = [];
          const makeDecreaseLiquidityInstructions = [];
          const signers = [];
          for (const itemInfo of Object.values(fetchPoolInfos)) {
            if (itemInfo.positionAccount === void 0)
              continue;
            if (!itemInfo.positionAccount.find(
              (i) => !i.tokenFeeAmountA.isZero() || !i.tokenFeeAmountB.isZero() || i.rewardInfos.find((ii) => !ii.pendingReward.isZero())
            ))
              continue;
            const poolInfo = itemInfo.state;
            const mintAUseSOLBalance = ownerInfo.useSOLBalance && poolInfo.mintA.mint.equals(Token3.WSOL.mint);
            const mintBUseSOLBalance = ownerInfo.useSOLBalance && poolInfo.mintB.mint.equals(Token3.WSOL.mint);
            const ownerTokenAccountA = (_a = ownerMintToAccount[poolInfo.mintA.mint.toString()]) != null ? _a : yield this._selectOrCreateTokenAccount({
              programId: poolInfo.mintA.programId,
              mint: poolInfo.mintA.mint,
              tokenAccounts: mintAUseSOLBalance ? [] : ownerInfo.tokenAccounts,
              owner: ownerInfo.wallet,
              createInfo: {
                connection,
                payer: ownerInfo.feePayer,
                amount: 0,
                frontInstructions,
                frontInstructionsType,
                endInstructions: mintAUseSOLBalance ? endInstructions : [],
                endInstructionsType: mintAUseSOLBalance ? endInstructionsType : [],
                signers
              },
              associatedOnly: mintAUseSOLBalance ? false : associatedOnly,
              checkCreateATAOwner
            });
            const ownerTokenAccountB = (_b = ownerMintToAccount[poolInfo.mintB.mint.toString()]) != null ? _b : yield this._selectOrCreateTokenAccount({
              programId: poolInfo.mintB.programId,
              mint: poolInfo.mintB.mint,
              tokenAccounts: mintBUseSOLBalance ? [] : ownerInfo.tokenAccounts,
              owner: ownerInfo.wallet,
              createInfo: {
                connection,
                payer: ownerInfo.feePayer,
                amount: 0,
                frontInstructions,
                frontInstructionsType,
                endInstructions: mintBUseSOLBalance ? endInstructions : [],
                endInstructionsType: mintBUseSOLBalance ? endInstructionsType : [],
                signers
              },
              associatedOnly: mintBUseSOLBalance ? false : associatedOnly,
              checkCreateATAOwner
            });
            ownerMintToAccount[poolInfo.mintA.mint.toString()] = ownerTokenAccountA;
            ownerMintToAccount[poolInfo.mintB.mint.toString()] = ownerTokenAccountB;
            const rewardAccounts = [];
            for (const itemReward of poolInfo.rewardInfos) {
              const rewardUseSOLBalance = ownerInfo.useSOLBalance && itemReward.tokenMint.equals(Token3.WSOL.mint);
              const ownerRewardAccount = (_c = ownerMintToAccount[itemReward.tokenMint.toString()]) != null ? _c : yield this._selectOrCreateTokenAccount({
                programId: itemReward.tokenProgramId,
                mint: itemReward.tokenMint,
                tokenAccounts: rewardUseSOLBalance ? [] : ownerInfo.tokenAccounts,
                owner: ownerInfo.wallet,
                createInfo: {
                  connection,
                  payer: ownerInfo.feePayer,
                  amount: 0,
                  frontInstructions,
                  endInstructions: rewardUseSOLBalance ? endInstructions : [],
                  frontInstructionsType,
                  endInstructionsType,
                  signers
                },
                associatedOnly: rewardUseSOLBalance ? false : associatedOnly,
                checkCreateATAOwner
              });
              ownerMintToAccount[itemReward.tokenMint.toString()] = ownerRewardAccount;
              rewardAccounts.push(ownerRewardAccount);
            }
            for (const itemPosition of itemInfo.positionAccount) {
              makeDecreaseLiquidityInstructions.push(
                this.makeDecreaseLiquidityInstructions({
                  poolInfo,
                  ownerPosition: itemPosition,
                  ownerInfo: {
                    wallet: ownerInfo.wallet,
                    tokenAccountA: ownerTokenAccountA,
                    tokenAccountB: ownerTokenAccountB,
                    rewardAccounts
                  },
                  liquidity: ZERO2,
                  amountMinA: ZERO2,
                  amountMinB: ZERO2
                })
              );
            }
          }
          return {
            address: {},
            innerTransactions: yield splitTxAndSigners({
              connection,
              makeTxVersion,
              computeBudgetConfig: void 0,
              payer: ownerInfo.feePayer,
              innerTransaction: [
                { instructionTypes: frontInstructionsType, instructions: frontInstructions, signers },
                ...makeDecreaseLiquidityInstructions.map((i) => i.innerTransaction),
                { instructionTypes: endInstructionsType, instructions: endInstructions, signers: [] }
              ],
              lookupTableCache
            })
          };
        });
      }
      // instrument
      static makeCreatePoolInstructions(_0) {
        return __async(this, arguments, function* ({
          connection,
          programId,
          owner,
          mintA,
          mintB,
          ammConfigId,
          initialPriceX64,
          startTime
        }) {
          const observationId = generatePubKey2({ fromPublicKey: owner, programId });
          const poolId = getPdaPoolId2(programId, ammConfigId, mintA.mint, mintB.mint).publicKey;
          const mintAVault = getPdaPoolVaultId2(programId, poolId, mintA.mint).publicKey;
          const mintBVault = getPdaPoolVaultId2(programId, poolId, mintB.mint).publicKey;
          const instructions = [
            import_web318.SystemProgram.createAccountWithSeed({
              fromPubkey: owner,
              basePubkey: owner,
              seed: observationId.seed,
              newAccountPubkey: observationId.publicKey,
              lamports: yield connection.getMinimumBalanceForRentExemption(ObservationInfoLayout2.span),
              space: ObservationInfoLayout2.span,
              programId
            }),
            createPoolInstruction(
              programId,
              poolId,
              owner,
              ammConfigId,
              observationId.publicKey,
              mintA.mint,
              mintAVault,
              mintA.programId,
              mintB.mint,
              mintBVault,
              mintB.programId,
              getPdaExBitmapAccount2(programId, poolId).publicKey,
              initialPriceX64,
              startTime
            )
          ];
          return {
            address: {
              observationId: observationId.publicKey,
              poolId,
              mintAVault,
              mintBVault
            },
            innerTransaction: {
              instructions,
              signers: [],
              instructionTypes: [
                0,
                11
                /* clmmCreatePool */
              ],
              lookupTableAddress: []
            }
          };
        });
      }
      static makeOpenPositionFromLiquidityInstructions(_0) {
        return __async(this, arguments, function* ({
          poolInfo,
          ownerInfo,
          tickLower,
          tickUpper,
          liquidity,
          amountMaxA,
          amountMaxB,
          withMetadata,
          getEphemeralSigners
        }) {
          const signers = [];
          let nftMintAccount;
          if (getEphemeralSigners) {
            nftMintAccount = new import_web318.PublicKey((yield getEphemeralSigners(1))[0]);
          } else {
            const _k = import_web318.Keypair.generate();
            signers.push(_k);
            nftMintAccount = _k.publicKey;
          }
          const tickArrayLowerStartIndex = TickUtils2.getTickArrayStartIndexByTick(tickLower, poolInfo.ammConfig.tickSpacing);
          const tickArrayUpperStartIndex = TickUtils2.getTickArrayStartIndexByTick(tickUpper, poolInfo.ammConfig.tickSpacing);
          const { publicKey: tickArrayLower } = getPdaTickArrayAddress2(
            poolInfo.programId,
            poolInfo.id,
            tickArrayLowerStartIndex
          );
          const { publicKey: tickArrayUpper } = getPdaTickArrayAddress2(
            poolInfo.programId,
            poolInfo.id,
            tickArrayUpperStartIndex
          );
          const { publicKey: positionNftAccount } = getATAAddress2(ownerInfo.wallet, nftMintAccount, import_spl_token2.TOKEN_PROGRAM_ID);
          const { publicKey: metadataAccount } = getPdaMetadataKey2(nftMintAccount);
          const { publicKey: personalPosition } = getPdaPersonalPositionAddress2(poolInfo.programId, nftMintAccount);
          const { publicKey: protocolPosition } = getPdaProtocolPositionAddress2(
            poolInfo.programId,
            poolInfo.id,
            tickLower,
            tickUpper
          );
          const ins = openPositionFromLiquidityInstruction(
            poolInfo.programId,
            ownerInfo.feePayer,
            poolInfo.id,
            ownerInfo.wallet,
            nftMintAccount,
            positionNftAccount,
            metadataAccount,
            protocolPosition,
            tickArrayLower,
            tickArrayUpper,
            personalPosition,
            ownerInfo.tokenAccountA,
            ownerInfo.tokenAccountB,
            poolInfo.mintA.vault,
            poolInfo.mintB.vault,
            poolInfo.mintA.mint,
            poolInfo.mintB.mint,
            tickLower,
            tickUpper,
            tickArrayLowerStartIndex,
            tickArrayUpperStartIndex,
            liquidity,
            amountMaxA,
            amountMaxB,
            withMetadata,
            PoolUtils3.isOverflowDefaultTickarrayBitmap(poolInfo.tickSpacing, [
              tickArrayLowerStartIndex,
              tickArrayUpperStartIndex
            ]) ? getPdaExBitmapAccount2(poolInfo.programId, poolInfo.id).publicKey : void 0
          );
          return {
            address: {
              nftMint: nftMintAccount,
              tickArrayLower,
              tickArrayUpper,
              positionNftAccount,
              metadataAccount,
              personalPosition,
              protocolPosition
            },
            innerTransaction: {
              instructions: [ins],
              signers,
              instructionTypes: [
                12
                /* clmmOpenPosition */
              ],
              lookupTableAddress: [poolInfo.lookupTableAccount].filter((i) => i && !i.equals(import_web318.PublicKey.default))
            }
          };
        });
      }
      static makeOpenPositionFromBaseInstructions(_0) {
        return __async(this, arguments, function* ({
          poolInfo,
          ownerInfo,
          tickLower,
          tickUpper,
          base,
          baseAmount,
          otherAmountMax,
          withMetadata,
          getEphemeralSigners
        }) {
          const signers = [];
          let nftMintAccount;
          if (getEphemeralSigners) {
            nftMintAccount = new import_web318.PublicKey((yield getEphemeralSigners(1))[0]);
          } else {
            const _k = import_web318.Keypair.generate();
            signers.push(_k);
            nftMintAccount = _k.publicKey;
          }
          const tickArrayLowerStartIndex = TickUtils2.getTickArrayStartIndexByTick(tickLower, poolInfo.ammConfig.tickSpacing);
          const tickArrayUpperStartIndex = TickUtils2.getTickArrayStartIndexByTick(tickUpper, poolInfo.ammConfig.tickSpacing);
          const { publicKey: tickArrayLower } = getPdaTickArrayAddress2(
            poolInfo.programId,
            poolInfo.id,
            tickArrayLowerStartIndex
          );
          const { publicKey: tickArrayUpper } = getPdaTickArrayAddress2(
            poolInfo.programId,
            poolInfo.id,
            tickArrayUpperStartIndex
          );
          const { publicKey: positionNftAccount } = getATAAddress2(ownerInfo.wallet, nftMintAccount, import_spl_token2.TOKEN_PROGRAM_ID);
          const { publicKey: metadataAccount } = getPdaMetadataKey2(nftMintAccount);
          const { publicKey: personalPosition } = getPdaPersonalPositionAddress2(poolInfo.programId, nftMintAccount);
          const { publicKey: protocolPosition } = getPdaProtocolPositionAddress2(
            poolInfo.programId,
            poolInfo.id,
            tickLower,
            tickUpper
          );
          const ins = openPositionFromBaseInstruction(
            poolInfo.programId,
            ownerInfo.feePayer,
            poolInfo.id,
            ownerInfo.wallet,
            nftMintAccount,
            positionNftAccount,
            metadataAccount,
            protocolPosition,
            tickArrayLower,
            tickArrayUpper,
            personalPosition,
            ownerInfo.tokenAccountA,
            ownerInfo.tokenAccountB,
            poolInfo.mintA.vault,
            poolInfo.mintB.vault,
            poolInfo.mintA.mint,
            poolInfo.mintB.mint,
            tickLower,
            tickUpper,
            tickArrayLowerStartIndex,
            tickArrayUpperStartIndex,
            withMetadata,
            base,
            baseAmount,
            otherAmountMax,
            PoolUtils3.isOverflowDefaultTickarrayBitmap(poolInfo.tickSpacing, [
              tickArrayLowerStartIndex,
              tickArrayUpperStartIndex
            ]) ? getPdaExBitmapAccount2(poolInfo.programId, poolInfo.id).publicKey : void 0
          );
          return {
            address: {
              nftMint: nftMintAccount,
              tickArrayLower,
              tickArrayUpper,
              positionNftAccount,
              metadataAccount,
              personalPosition,
              protocolPosition
            },
            innerTransaction: {
              instructions: [ins],
              signers,
              instructionTypes: [
                12
                /* clmmOpenPosition */
              ],
              lookupTableAddress: [poolInfo.lookupTableAccount].filter((i) => i && !i.equals(import_web318.PublicKey.default))
            }
          };
        });
      }
      static makeIncreasePositionFromLiquidityInstructions({
        poolInfo,
        ownerPosition,
        ownerInfo,
        liquidity,
        amountMaxA,
        amountMaxB
      }) {
        const tickArrayLowerStartIndex = TickUtils2.getTickArrayStartIndexByTick(
          ownerPosition.tickLower,
          poolInfo.ammConfig.tickSpacing
        );
        const tickArrayUpperStartIndex = TickUtils2.getTickArrayStartIndexByTick(
          ownerPosition.tickUpper,
          poolInfo.ammConfig.tickSpacing
        );
        const { publicKey: tickArrayLower } = getPdaTickArrayAddress2(
          poolInfo.programId,
          poolInfo.id,
          tickArrayLowerStartIndex
        );
        const { publicKey: tickArrayUpper } = getPdaTickArrayAddress2(
          poolInfo.programId,
          poolInfo.id,
          tickArrayUpperStartIndex
        );
        const { publicKey: positionNftAccount } = getATAAddress2(ownerInfo.wallet, ownerPosition.nftMint, import_spl_token2.TOKEN_PROGRAM_ID);
        const { publicKey: personalPosition } = getPdaPersonalPositionAddress2(poolInfo.programId, ownerPosition.nftMint);
        const { publicKey: protocolPosition } = getPdaProtocolPositionAddress2(
          poolInfo.programId,
          poolInfo.id,
          ownerPosition.tickLower,
          ownerPosition.tickUpper
        );
        return {
          address: {
            tickArrayLower,
            tickArrayUpper,
            positionNftAccount,
            personalPosition,
            protocolPosition
          },
          innerTransaction: {
            instructions: [
              increasePositionFromLiquidityInstruction(
                poolInfo.programId,
                ownerInfo.wallet,
                positionNftAccount,
                personalPosition,
                poolInfo.id,
                protocolPosition,
                tickArrayLower,
                tickArrayUpper,
                ownerInfo.tokenAccountA,
                ownerInfo.tokenAccountB,
                poolInfo.mintA.vault,
                poolInfo.mintB.vault,
                poolInfo.mintA.mint,
                poolInfo.mintB.mint,
                liquidity,
                amountMaxA,
                amountMaxB,
                PoolUtils3.isOverflowDefaultTickarrayBitmap(poolInfo.tickSpacing, [
                  tickArrayLowerStartIndex,
                  tickArrayUpperStartIndex
                ]) ? getPdaExBitmapAccount2(poolInfo.programId, poolInfo.id).publicKey : void 0
              )
            ],
            signers: [],
            instructionTypes: [
              13
              /* clmmIncreasePosition */
            ],
            lookupTableAddress: [poolInfo.lookupTableAccount].filter((i) => i && !i.equals(import_web318.PublicKey.default))
          }
        };
      }
      static makeIncreasePositionFromBaseInstructions({
        poolInfo,
        ownerPosition,
        ownerInfo,
        base,
        baseAmount,
        otherAmountMax
      }) {
        const tickArrayLowerStartIndex = TickUtils2.getTickArrayStartIndexByTick(
          ownerPosition.tickLower,
          poolInfo.ammConfig.tickSpacing
        );
        const tickArrayUpperStartIndex = TickUtils2.getTickArrayStartIndexByTick(
          ownerPosition.tickUpper,
          poolInfo.ammConfig.tickSpacing
        );
        const { publicKey: tickArrayLower } = getPdaTickArrayAddress2(
          poolInfo.programId,
          poolInfo.id,
          tickArrayLowerStartIndex
        );
        const { publicKey: tickArrayUpper } = getPdaTickArrayAddress2(
          poolInfo.programId,
          poolInfo.id,
          tickArrayUpperStartIndex
        );
        const { publicKey: positionNftAccount } = getATAAddress2(ownerInfo.wallet, ownerPosition.nftMint, import_spl_token2.TOKEN_PROGRAM_ID);
        const { publicKey: personalPosition } = getPdaPersonalPositionAddress2(poolInfo.programId, ownerPosition.nftMint);
        const { publicKey: protocolPosition } = getPdaProtocolPositionAddress2(
          poolInfo.programId,
          poolInfo.id,
          ownerPosition.tickLower,
          ownerPosition.tickUpper
        );
        return {
          address: {
            tickArrayLower,
            tickArrayUpper,
            positionNftAccount,
            personalPosition,
            protocolPosition
          },
          innerTransaction: {
            instructions: [
              increasePositionFromBaseInstruction(
                poolInfo.programId,
                ownerInfo.wallet,
                positionNftAccount,
                personalPosition,
                poolInfo.id,
                protocolPosition,
                tickArrayLower,
                tickArrayUpper,
                ownerInfo.tokenAccountA,
                ownerInfo.tokenAccountB,
                poolInfo.mintA.vault,
                poolInfo.mintB.vault,
                poolInfo.mintA.mint,
                poolInfo.mintB.mint,
                base,
                baseAmount,
                otherAmountMax,
                PoolUtils3.isOverflowDefaultTickarrayBitmap(poolInfo.tickSpacing, [
                  tickArrayLowerStartIndex,
                  tickArrayUpperStartIndex
                ]) ? getPdaExBitmapAccount2(poolInfo.programId, poolInfo.id).publicKey : void 0
              )
            ],
            signers: [],
            instructionTypes: [
              13
              /* clmmIncreasePosition */
            ],
            lookupTableAddress: [poolInfo.lookupTableAccount].filter((i) => i && !i.equals(import_web318.PublicKey.default))
          }
        };
      }
      static makeDecreaseLiquidityInstructions({
        poolInfo,
        ownerPosition,
        ownerInfo,
        liquidity,
        amountMinA,
        amountMinB
      }) {
        const tickArrayLowerStartIndex = TickUtils2.getTickArrayStartIndexByTick(
          ownerPosition.tickLower,
          poolInfo.ammConfig.tickSpacing
        );
        const tickArrayUpperStartIndex = TickUtils2.getTickArrayStartIndexByTick(
          ownerPosition.tickUpper,
          poolInfo.ammConfig.tickSpacing
        );
        const { publicKey: tickArrayLower } = getPdaTickArrayAddress2(
          poolInfo.programId,
          poolInfo.id,
          tickArrayLowerStartIndex
        );
        const { publicKey: tickArrayUpper } = getPdaTickArrayAddress2(
          poolInfo.programId,
          poolInfo.id,
          tickArrayUpperStartIndex
        );
        const { publicKey: positionNftAccount } = getATAAddress2(ownerInfo.wallet, ownerPosition.nftMint, import_spl_token2.TOKEN_PROGRAM_ID);
        const { publicKey: personalPosition } = getPdaPersonalPositionAddress2(poolInfo.programId, ownerPosition.nftMint);
        const { publicKey: protocolPosition } = getPdaProtocolPositionAddress2(
          poolInfo.programId,
          poolInfo.id,
          ownerPosition.tickLower,
          ownerPosition.tickUpper
        );
        const rewardAccounts = [];
        for (let i = 0; i < poolInfo.rewardInfos.length; i++) {
          rewardAccounts.push({
            poolRewardVault: poolInfo.rewardInfos[i].tokenVault,
            ownerRewardVault: ownerInfo.rewardAccounts[i],
            rewardMint: poolInfo.rewardInfos[i].tokenMint
          });
        }
        return {
          address: {
            tickArrayLower,
            tickArrayUpper,
            positionNftAccount,
            personalPosition,
            protocolPosition
          },
          innerTransaction: {
            instructions: [
              decreaseLiquidityInstruction(
                poolInfo.programId,
                ownerInfo.wallet,
                positionNftAccount,
                personalPosition,
                poolInfo.id,
                protocolPosition,
                tickArrayLower,
                tickArrayUpper,
                ownerInfo.tokenAccountA,
                ownerInfo.tokenAccountB,
                poolInfo.mintA.vault,
                poolInfo.mintB.vault,
                poolInfo.mintA.mint,
                poolInfo.mintB.mint,
                rewardAccounts,
                liquidity,
                amountMinA,
                amountMinB,
                PoolUtils3.isOverflowDefaultTickarrayBitmap(poolInfo.tickSpacing, [
                  tickArrayLowerStartIndex,
                  tickArrayUpperStartIndex
                ]) ? getPdaExBitmapAccount2(poolInfo.programId, poolInfo.id).publicKey : void 0
              )
            ],
            signers: [],
            instructionTypes: [
              14
              /* clmmDecreasePosition */
            ],
            lookupTableAddress: [poolInfo.lookupTableAccount].filter((i) => i && !i.equals(import_web318.PublicKey.default))
          }
        };
      }
      static makeClosePositionInstructions({
        poolInfo,
        ownerInfo,
        ownerPosition
      }) {
        const { publicKey: positionNftAccount } = getATAAddress2(ownerInfo.wallet, ownerPosition.nftMint, import_spl_token2.TOKEN_PROGRAM_ID);
        const { publicKey: personalPosition } = getPdaPersonalPositionAddress2(poolInfo.programId, ownerPosition.nftMint);
        return {
          address: {
            positionNftAccount,
            personalPosition
          },
          innerTransaction: {
            instructions: [
              closePositionInstruction(
                poolInfo.programId,
                ownerInfo.wallet,
                ownerPosition.nftMint,
                positionNftAccount,
                personalPosition
              )
            ],
            signers: [],
            instructionTypes: [
              15
              /* clmmClosePosition */
            ],
            lookupTableAddress: [poolInfo.lookupTableAccount].filter((i) => i && !i.equals(import_web318.PublicKey.default))
          }
        };
      }
      static makeSwapBaseInInstructions({
        poolInfo,
        ownerInfo,
        inputMint,
        amountIn,
        amountOutMin,
        sqrtPriceLimitX64,
        remainingAccounts
      }) {
        const isInputMintA = poolInfo.mintA.mint.equals(inputMint);
        return {
          address: {},
          innerTransaction: {
            instructions: [
              swapInstruction(
                poolInfo.programId,
                ownerInfo.wallet,
                poolInfo.id,
                poolInfo.ammConfig.id,
                isInputMintA ? ownerInfo.tokenAccountA : ownerInfo.tokenAccountB,
                isInputMintA ? ownerInfo.tokenAccountB : ownerInfo.tokenAccountA,
                isInputMintA ? poolInfo.mintA.vault : poolInfo.mintB.vault,
                isInputMintA ? poolInfo.mintB.vault : poolInfo.mintA.vault,
                isInputMintA ? poolInfo.mintA.mint : poolInfo.mintB.mint,
                isInputMintA ? poolInfo.mintB.mint : poolInfo.mintA.mint,
                remainingAccounts,
                poolInfo.observationId,
                amountIn,
                amountOutMin,
                sqrtPriceLimitX64,
                true,
                getPdaExBitmapAccount2(poolInfo.programId, poolInfo.id).publicKey
              )
            ],
            signers: [],
            lookupTableAddress: [poolInfo.lookupTableAccount].filter((i) => i && !i.equals(import_web318.PublicKey.default)),
            instructionTypes: [
              16
              /* clmmSwapBaseIn */
            ]
          }
        };
      }
      static makeSwapBaseOutInstructions({
        poolInfo,
        ownerInfo,
        outputMint,
        amountOut,
        amountInMax,
        sqrtPriceLimitX64,
        remainingAccounts
      }) {
        const isInputMintA = poolInfo.mintA.mint.equals(outputMint);
        return {
          address: {},
          innerTransaction: {
            instructions: [
              swapInstruction(
                poolInfo.programId,
                ownerInfo.wallet,
                poolInfo.id,
                poolInfo.ammConfig.id,
                isInputMintA ? ownerInfo.tokenAccountB : ownerInfo.tokenAccountA,
                isInputMintA ? ownerInfo.tokenAccountA : ownerInfo.tokenAccountB,
                isInputMintA ? poolInfo.mintB.vault : poolInfo.mintA.vault,
                isInputMintA ? poolInfo.mintA.vault : poolInfo.mintB.vault,
                isInputMintA ? poolInfo.mintB.mint : poolInfo.mintA.mint,
                isInputMintA ? poolInfo.mintA.mint : poolInfo.mintB.mint,
                remainingAccounts,
                poolInfo.observationId,
                amountOut,
                amountInMax,
                sqrtPriceLimitX64,
                false,
                getPdaExBitmapAccount2(poolInfo.programId, poolInfo.id).publicKey
              )
            ],
            signers: [],
            lookupTableAddress: [poolInfo.lookupTableAccount].filter((i) => i && !i.equals(import_web318.PublicKey.default)),
            instructionTypes: [
              17
              /* clmmSwapBaseOut */
            ]
          }
        };
      }
      static makeInitRewardInstructions({
        poolInfo,
        ownerInfo,
        rewardInfo
      }) {
        const poolRewardVault = getPdaPoolRewardVaulId2(poolInfo.programId, poolInfo.id, rewardInfo.mint).publicKey;
        const operationId = getPdaOperationAccount2(poolInfo.programId).publicKey;
        return {
          address: { poolRewardVault, operationId },
          innerTransaction: {
            instructions: [
              initRewardInstruction(
                poolInfo.programId,
                ownerInfo.wallet,
                poolInfo.id,
                operationId,
                poolInfo.ammConfig.id,
                ownerInfo.tokenAccount,
                rewardInfo.programId,
                rewardInfo.mint,
                poolRewardVault,
                rewardInfo.openTime,
                rewardInfo.endTime,
                rewardInfo.emissionsPerSecondX64
              )
            ],
            signers: [],
            instructionTypes: [
              18
              /* clmmInitReward */
            ],
            lookupTableAddress: [poolInfo.lookupTableAccount].filter((i) => i && !i.equals(import_web318.PublicKey.default))
          }
        };
      }
      static makeSetRewardInstructions({
        poolInfo,
        ownerInfo,
        rewardInfo
      }) {
        let rewardIndex;
        let rewardVault;
        let rewardMint;
        for (let index = 0; index < poolInfo.rewardInfos.length; index++)
          if (poolInfo.rewardInfos[index].tokenMint.equals(rewardInfo.mint)) {
            rewardIndex = index;
            rewardVault = poolInfo.rewardInfos[index].tokenVault;
            rewardMint = poolInfo.rewardInfos[index].tokenMint;
          }
        if (rewardIndex === void 0 || rewardVault === void 0 || rewardMint === void 0)
          throw Error("reward mint check error");
        const operationId = getPdaOperationAccount2(poolInfo.programId).publicKey;
        return {
          address: { rewardVault, operationId },
          innerTransaction: {
            instructions: [
              setRewardInstruction(
                poolInfo.programId,
                ownerInfo.wallet,
                poolInfo.id,
                operationId,
                poolInfo.ammConfig.id,
                ownerInfo.tokenAccount,
                rewardVault,
                rewardMint,
                rewardIndex,
                rewardInfo.openTime,
                rewardInfo.endTime,
                rewardInfo.emissionsPerSecondX64
              )
            ],
            signers: [],
            instructionTypes: [
              18
              /* clmmInitReward */
            ],
            lookupTableAddress: [poolInfo.lookupTableAccount].filter((i) => i && !i.equals(import_web318.PublicKey.default))
          }
        };
      }
      static makeCollectRewardInstructions({
        poolInfo,
        ownerInfo,
        rewardMint
      }) {
        let rewardIndex;
        let rewardVault;
        for (let index = 0; index < poolInfo.rewardInfos.length; index++)
          if (poolInfo.rewardInfos[index].tokenMint.equals(rewardMint)) {
            rewardIndex = index;
            rewardVault = poolInfo.rewardInfos[index].tokenVault;
          }
        if (rewardIndex === void 0 || rewardVault === void 0)
          throw Error("reward mint check error");
        return {
          address: { rewardVault },
          innerTransaction: {
            instructions: [
              collectRewardInstruction(
                poolInfo.programId,
                ownerInfo.wallet,
                poolInfo.id,
                ownerInfo.tokenAccount,
                rewardVault,
                rewardMint,
                rewardIndex
              )
            ],
            signers: [],
            instructionTypes: [
              18
              /* clmmInitReward */
            ],
            lookupTableAddress: [poolInfo.lookupTableAccount].filter((i) => i && !i.equals(import_web318.PublicKey.default))
          }
        };
      }
      // calculate
      static getLiquidityAmountOutFromAmountIn({
        poolInfo,
        inputA,
        tickLower,
        tickUpper,
        amount,
        slippage,
        add: add3,
        token2022Infos,
        epochInfo,
        amountHasFee
      }) {
        var _a, _b;
        const sqrtPriceX64 = poolInfo.sqrtPriceX64;
        const sqrtPriceX64A = SqrtPriceMath2.getSqrtPriceX64FromTick(tickLower);
        const sqrtPriceX64B = SqrtPriceMath2.getSqrtPriceX64FromTick(tickUpper);
        const coefficient = add3 ? 1 - slippage : 1 + slippage;
        const addFeeAmount = getTransferAmountFee2(
          amount,
          (_a = token2022Infos[inputA ? poolInfo.mintA.mint.toString() : poolInfo.mintB.mint.toString()]) == null ? void 0 : _a.feeConfig,
          epochInfo,
          !amountHasFee
        );
        const _amount = new import_bn15.default(
          new import_decimal3.default(addFeeAmount.amount.sub((_b = addFeeAmount.fee) != null ? _b : ZERO2).toString()).mul(coefficient).toFixed(0)
        );
        let liquidity;
        if (sqrtPriceX64.lte(sqrtPriceX64A)) {
          liquidity = inputA ? LiquidityMath2.getLiquidityFromTokenAmountA(sqrtPriceX64A, sqrtPriceX64B, _amount, !add3) : new import_bn15.default(0);
        } else if (sqrtPriceX64.lte(sqrtPriceX64B)) {
          const liquidity0 = LiquidityMath2.getLiquidityFromTokenAmountA(sqrtPriceX64, sqrtPriceX64B, _amount, !add3);
          const liquidity1 = LiquidityMath2.getLiquidityFromTokenAmountB(sqrtPriceX64A, sqrtPriceX64, _amount);
          liquidity = inputA ? liquidity0 : liquidity1;
        } else {
          liquidity = inputA ? new import_bn15.default(0) : LiquidityMath2.getLiquidityFromTokenAmountB(sqrtPriceX64A, sqrtPriceX64B, _amount);
        }
        return this.getAmountsFromLiquidity({
          poolInfo,
          tickLower,
          tickUpper,
          liquidity,
          slippage,
          add: add3,
          token2022Infos,
          epochInfo,
          amountAddFee: amountHasFee
        });
      }
      static getLiquidityFromAmounts({
        poolInfo,
        tickLower,
        tickUpper,
        amountA,
        amountB,
        slippage,
        add: add3,
        token2022Infos,
        epochInfo,
        amountHasFee
      }) {
        var _a, _b, _c, _d;
        const [_tickLower, _tickUpper, _amountA, _amountB] = tickLower < tickUpper ? [tickLower, tickUpper, amountA, amountB] : [tickUpper, tickLower, amountB, amountA];
        const sqrtPriceX64 = poolInfo.sqrtPriceX64;
        const sqrtPriceX64A = SqrtPriceMath2.getSqrtPriceX64FromTick(_tickLower);
        const sqrtPriceX64B = SqrtPriceMath2.getSqrtPriceX64FromTick(_tickUpper);
        const [amountFeeA, amountFeeB] = [
          getTransferAmountFee2(
            _amountA,
            (_a = token2022Infos[poolInfo.mintA.mint.toString()]) == null ? void 0 : _a.feeConfig,
            epochInfo,
            !amountHasFee
          ),
          getTransferAmountFee2(
            _amountB,
            (_b = token2022Infos[poolInfo.mintB.mint.toString()]) == null ? void 0 : _b.feeConfig,
            epochInfo,
            !amountHasFee
          )
        ];
        const liquidity = LiquidityMath2.getLiquidityFromTokenAmounts(
          sqrtPriceX64,
          sqrtPriceX64A,
          sqrtPriceX64B,
          amountFeeA.amount.sub((_c = amountFeeA.fee) != null ? _c : ZERO2),
          amountFeeB.amount.sub((_d = amountFeeB.fee) != null ? _d : ZERO2)
        );
        return this.getAmountsFromLiquidity({
          poolInfo,
          tickLower,
          tickUpper,
          liquidity,
          slippage,
          add: add3,
          token2022Infos,
          epochInfo,
          amountAddFee: !amountHasFee
        });
      }
      static getAmountsFromLiquidity({
        poolInfo,
        tickLower,
        tickUpper,
        liquidity,
        slippage,
        add: add3,
        token2022Infos,
        epochInfo,
        amountAddFee
      }) {
        var _a, _b, _c, _d;
        const sqrtPriceX64A = SqrtPriceMath2.getSqrtPriceX64FromTick(tickLower);
        const sqrtPriceX64B = SqrtPriceMath2.getSqrtPriceX64FromTick(tickUpper);
        const coefficientRe = add3 ? 1 + slippage : 1 - slippage;
        const amounts = LiquidityMath2.getAmountsFromLiquidity(
          poolInfo.sqrtPriceX64,
          sqrtPriceX64A,
          sqrtPriceX64B,
          liquidity,
          add3
        );
        const [amountA, amountB] = [
          getTransferAmountFee2(
            amounts.amountA,
            (_a = token2022Infos[poolInfo.mintA.mint.toString()]) == null ? void 0 : _a.feeConfig,
            epochInfo,
            amountAddFee
          ),
          getTransferAmountFee2(
            amounts.amountB,
            (_b = token2022Infos[poolInfo.mintB.mint.toString()]) == null ? void 0 : _b.feeConfig,
            epochInfo,
            amountAddFee
          )
        ];
        const [amountSlippageA, amountSlippageB] = [
          getTransferAmountFee2(
            new import_bn15.default(new import_decimal3.default(amounts.amountA.toString()).mul(coefficientRe).toFixed(0)),
            (_c = token2022Infos[poolInfo.mintA.mint.toString()]) == null ? void 0 : _c.feeConfig,
            epochInfo,
            amountAddFee
          ),
          getTransferAmountFee2(
            new import_bn15.default(new import_decimal3.default(amounts.amountB.toString()).mul(coefficientRe).toFixed(0)),
            (_d = token2022Infos[poolInfo.mintB.mint.toString()]) == null ? void 0 : _d.feeConfig,
            epochInfo,
            amountAddFee
          )
        ];
        return {
          liquidity,
          amountA,
          amountB,
          amountSlippageA,
          amountSlippageB,
          expirationTime: minExpirationTime2(amountA.expirationTime, amountB.expirationTime)
        };
      }
      static getPriceAndTick({
        poolInfo,
        price,
        baseIn
      }) {
        const _price = baseIn ? price : new import_decimal3.default(1).div(price);
        const tick = TickMath2.getTickWithPriceAndTickspacing(
          _price,
          poolInfo.ammConfig.tickSpacing,
          poolInfo.mintA.decimals,
          poolInfo.mintB.decimals
        );
        const tickSqrtPriceX64 = SqrtPriceMath2.getSqrtPriceX64FromTick(tick);
        const tickPrice = SqrtPriceMath2.sqrtPriceX64ToPrice(
          tickSqrtPriceX64,
          poolInfo.mintA.decimals,
          poolInfo.mintB.decimals
        );
        return baseIn ? { tick, price: tickPrice } : { tick, price: new import_decimal3.default(1).div(tickPrice) };
      }
      static getTickPrice({
        poolInfo,
        tick,
        baseIn
      }) {
        const tickSqrtPriceX64 = SqrtPriceMath2.getSqrtPriceX64FromTick(tick);
        const tickPrice = SqrtPriceMath2.sqrtPriceX64ToPrice(
          tickSqrtPriceX64,
          poolInfo.mintA.decimals,
          poolInfo.mintB.decimals
        );
        return baseIn ? { tick, price: tickPrice, tickSqrtPriceX64 } : { tick, price: new import_decimal3.default(1).div(tickPrice), tickSqrtPriceX64 };
      }
      static computeAmountOutFormat({
        poolInfo,
        tickArrayCache,
        token2022Infos,
        epochInfo,
        amountIn,
        currencyOut,
        slippage,
        catchLiquidityInsufficient = false
      }) {
        const amountInIsTokenAmount = amountIn instanceof TokenAmount3;
        const inputMint = (amountInIsTokenAmount ? amountIn.token : Token3.WSOL).mint;
        const _amountIn = amountIn.raw;
        const _slippage = slippage.numerator.toNumber() / slippage.denominator.toNumber();
        const {
          allTrade,
          realAmountIn: _realAmountIn,
          amountOut: _amountOut,
          minAmountOut: _minAmountOut,
          expirationTime,
          currentPrice,
          executionPrice,
          priceImpact,
          fee,
          remainingAccounts,
          executionPriceX64
        } = this.computeAmountOut({
          poolInfo,
          tickArrayCache,
          baseMint: inputMint,
          amountIn: _amountIn,
          slippage: _slippage,
          token2022Infos,
          epochInfo,
          catchLiquidityInsufficient
        });
        const realAmountIn = __spreadProps(__spreadValues({}, _realAmountIn), {
          amount: amountInIsTokenAmount ? new TokenAmount3(amountIn.token, _realAmountIn.amount) : new CurrencyAmount2(Currency2.SOL, _realAmountIn.amount),
          fee: _realAmountIn.fee === void 0 ? void 0 : amountInIsTokenAmount ? new TokenAmount3(amountIn.token, _realAmountIn.fee) : new CurrencyAmount2(Currency2.SOL, _realAmountIn.fee)
        });
        const amountOut = __spreadProps(__spreadValues({}, _amountOut), {
          amount: currencyOut instanceof Token3 ? new TokenAmount3(currencyOut, _amountOut.amount) : new CurrencyAmount2(currencyOut, _amountOut.amount),
          fee: _amountOut.fee === void 0 ? void 0 : currencyOut instanceof Token3 ? new TokenAmount3(currencyOut, _amountOut.fee) : new CurrencyAmount2(currencyOut, _amountOut.fee)
        });
        const minAmountOut = __spreadProps(__spreadValues({}, _minAmountOut), {
          amount: currencyOut instanceof Token3 ? new TokenAmount3(currencyOut, _minAmountOut.amount) : new CurrencyAmount2(currencyOut, _minAmountOut.amount),
          fee: _minAmountOut.fee === void 0 ? void 0 : currencyOut instanceof Token3 ? new TokenAmount3(currencyOut, _minAmountOut.fee) : new CurrencyAmount2(currencyOut, _minAmountOut.fee)
        });
        const _currentPrice = new Price2(
          amountInIsTokenAmount ? amountIn.token : amountIn.currency,
          new import_bn15.default(10).pow(new import_bn15.default(20 + (amountInIsTokenAmount ? amountIn.token : amountIn.currency).decimals)),
          currencyOut instanceof Token3 ? currencyOut : Token3.WSOL,
          currentPrice.mul(new import_decimal3.default(__pow(10, 20 + (currencyOut instanceof Token3 ? currencyOut : Token3.WSOL).decimals))).toFixed(0)
        );
        const _executionPrice = new Price2(
          amountInIsTokenAmount ? amountIn.token : amountIn.currency,
          new import_bn15.default(10).pow(new import_bn15.default(20 + (amountInIsTokenAmount ? amountIn.token : amountIn.currency).decimals)),
          currencyOut instanceof Token3 ? currencyOut : Token3.WSOL,
          executionPrice.mul(new import_decimal3.default(__pow(10, 20 + (currencyOut instanceof Token3 ? currencyOut : Token3.WSOL).decimals))).toFixed(0)
        );
        const _fee = amountInIsTokenAmount ? new TokenAmount3(amountIn.token, fee) : new CurrencyAmount2(amountIn.currency, fee);
        return {
          allTrade,
          realAmountIn,
          amountOut,
          minAmountOut,
          expirationTime,
          currentPrice: _currentPrice,
          executionPrice: _executionPrice,
          priceImpact,
          fee: _fee,
          remainingAccounts,
          executionPriceX64
        };
      }
      static computeAmountOutAndCheckToken(_0) {
        return __async(this, arguments, function* ({
          connection,
          poolInfo,
          tickArrayCache,
          baseMint,
          amountIn,
          slippage,
          priceLimit = new import_decimal3.default(0),
          catchLiquidityInsufficient = false
        }) {
          const epochInfo = yield connection.getEpochInfo();
          const token2022Infos = yield fetchMultipleMintInfos2({
            connection,
            mints: [poolInfo.mintA, poolInfo.mintB].filter((i) => i.programId.equals(import_spl_token6.TOKEN_2022_PROGRAM_ID)).map((i) => i.mint)
          });
          return this.computeAmountOut({
            poolInfo,
            tickArrayCache,
            baseMint,
            amountIn,
            slippage,
            priceLimit,
            token2022Infos,
            epochInfo,
            catchLiquidityInsufficient
          });
        });
      }
      static computeAmountOut({
        poolInfo,
        tickArrayCache,
        baseMint,
        token2022Infos,
        epochInfo,
        amountIn,
        slippage,
        priceLimit = new import_decimal3.default(0),
        catchLiquidityInsufficient = false
      }) {
        var _a, _b, _c, _d, _e;
        let sqrtPriceLimitX64;
        if (priceLimit.equals(new import_decimal3.default(0))) {
          sqrtPriceLimitX64 = baseMint.equals(poolInfo.mintA.mint) ? MIN_SQRT_PRICE_X642.add(ONE2) : MAX_SQRT_PRICE_X642.sub(ONE2);
        } else {
          sqrtPriceLimitX64 = SqrtPriceMath2.priceToSqrtPriceX64(
            priceLimit,
            poolInfo.mintA.decimals,
            poolInfo.mintB.decimals
          );
        }
        const _inputRealAmountIn = getTransferAmountFee2(
          amountIn,
          (_a = token2022Infos[baseMint.toString()]) == null ? void 0 : _a.feeConfig,
          epochInfo,
          false
        );
        const {
          allTrade,
          realTradeAmountIn,
          expectedAmountOut: _expectedAmountOut,
          remainingAccounts,
          executionPrice: _executionPriceX64,
          feeAmount
        } = PoolUtils3.getOutputAmountAndRemainAccounts(
          poolInfo,
          tickArrayCache,
          baseMint,
          _inputRealAmountIn.amount.sub((_b = _inputRealAmountIn.fee) != null ? _b : ZERO2),
          sqrtPriceLimitX64,
          catchLiquidityInsufficient
        );
        const realAmountIn = getTransferAmountFee2(
          realTradeAmountIn,
          (_c = token2022Infos[baseMint.toString()]) == null ? void 0 : _c.feeConfig,
          epochInfo,
          true
        );
        const outMint = poolInfo.mintA.mint.equals(baseMint) ? poolInfo.mintB.mint : poolInfo.mintA.mint;
        const amountOut = getTransferAmountFee2(
          _expectedAmountOut,
          (_d = token2022Infos[outMint.toString()]) == null ? void 0 : _d.feeConfig,
          epochInfo,
          false
        );
        const _executionPrice = SqrtPriceMath2.sqrtPriceX64ToPrice(
          _executionPriceX64,
          poolInfo.mintA.decimals,
          poolInfo.mintB.decimals
        );
        const executionPrice = baseMint.equals(poolInfo.mintA.mint) ? _executionPrice : new import_decimal3.default(1).div(_executionPrice);
        const _minAmountOut = _expectedAmountOut.mul(new import_bn15.default(Math.floor((1 - slippage) * 1e10))).div(new import_bn15.default(1e10));
        const minAmountOut = getTransferAmountFee2(
          _minAmountOut,
          (_e = token2022Infos[outMint.toString()]) == null ? void 0 : _e.feeConfig,
          epochInfo,
          false
        );
        const poolPrice = poolInfo.mintA.mint.equals(baseMint) ? poolInfo.currentPrice : new import_decimal3.default(1).div(poolInfo.currentPrice);
        const _numerator = new import_decimal3.default(executionPrice).sub(poolPrice).abs();
        const _denominator = poolPrice;
        const priceImpact = new Percent3(
          new import_decimal3.default(_numerator).mul(__pow(10, 15)).toFixed(0),
          new import_decimal3.default(_denominator).mul(__pow(10, 15)).toFixed(0)
        );
        return {
          allTrade,
          realAmountIn,
          amountOut,
          minAmountOut,
          expirationTime: minExpirationTime2(realAmountIn.expirationTime, amountOut.expirationTime),
          currentPrice: poolInfo.currentPrice,
          executionPrice,
          priceImpact,
          fee: feeAmount,
          remainingAccounts,
          executionPriceX64: _executionPriceX64
        };
      }
      static computeAmountInAndCheckToken(_0) {
        return __async(this, arguments, function* ({
          connection,
          poolInfo,
          tickArrayCache,
          baseMint,
          amountOut,
          slippage,
          priceLimit = new import_decimal3.default(0)
        }) {
          const epochInfo = yield connection.getEpochInfo();
          const token2022Infos = yield fetchMultipleMintInfos2({
            connection,
            mints: [poolInfo.mintA, poolInfo.mintB].filter((i) => i.programId.equals(import_spl_token6.TOKEN_2022_PROGRAM_ID)).map((i) => i.mint)
          });
          return this.computeAmountIn({
            poolInfo,
            tickArrayCache,
            baseMint,
            amountOut,
            slippage,
            priceLimit,
            token2022Infos,
            epochInfo
          });
        });
      }
      static computeAmountIn({
        poolInfo,
        tickArrayCache,
        baseMint,
        token2022Infos,
        epochInfo,
        amountOut,
        slippage,
        priceLimit = new import_decimal3.default(0)
      }) {
        var _a, _b, _c, _d;
        let sqrtPriceLimitX64;
        if (priceLimit.equals(new import_decimal3.default(0))) {
          sqrtPriceLimitX64 = baseMint.equals(poolInfo.mintB.mint) ? MIN_SQRT_PRICE_X642.add(ONE2) : MAX_SQRT_PRICE_X642.sub(ONE2);
        } else {
          sqrtPriceLimitX64 = SqrtPriceMath2.priceToSqrtPriceX64(
            priceLimit,
            poolInfo.mintA.decimals,
            poolInfo.mintB.decimals
          );
        }
        const realAmountOut = getTransferAmountFee2(
          amountOut,
          (_a = token2022Infos[baseMint.toString()]) == null ? void 0 : _a.feeConfig,
          epochInfo,
          true
        );
        const {
          expectedAmountIn: _expectedAmountIn,
          remainingAccounts,
          executionPrice: _executionPriceX64,
          feeAmount
        } = PoolUtils3.getInputAmountAndRemainAccounts(
          poolInfo,
          tickArrayCache,
          baseMint,
          realAmountOut.amount.sub((_b = realAmountOut.fee) != null ? _b : ZERO2),
          sqrtPriceLimitX64
        );
        const inMint = poolInfo.mintA.mint.equals(baseMint) ? poolInfo.mintB.mint : poolInfo.mintA.mint;
        const amountIn = getTransferAmountFee2(
          _expectedAmountIn,
          (_c = token2022Infos[inMint.toString()]) == null ? void 0 : _c.feeConfig,
          epochInfo,
          true
        );
        const _executionPrice = SqrtPriceMath2.sqrtPriceX64ToPrice(
          _executionPriceX64,
          poolInfo.mintA.decimals,
          poolInfo.mintB.decimals
        );
        const executionPrice = baseMint.equals(poolInfo.mintA.mint) ? _executionPrice : new import_decimal3.default(1).div(_executionPrice);
        const _maxAmountIn = _expectedAmountIn.mul(new import_bn15.default(Math.floor((1 + slippage) * 1e10))).div(new import_bn15.default(1e10));
        const maxAmountIn = getTransferAmountFee2(
          _maxAmountIn,
          (_d = token2022Infos[inMint.toString()]) == null ? void 0 : _d.feeConfig,
          epochInfo,
          true
        );
        const poolPrice = poolInfo.mintA.mint.equals(baseMint) ? poolInfo.currentPrice : new import_decimal3.default(1).div(poolInfo.currentPrice);
        const _numerator = new import_decimal3.default(executionPrice).sub(poolPrice).abs();
        const _denominator = poolPrice;
        const priceImpact = new Percent3(
          new import_decimal3.default(_numerator).mul(__pow(10, 15)).toFixed(0),
          new import_decimal3.default(_denominator).mul(__pow(10, 15)).toFixed(0)
        );
        return {
          amountIn,
          maxAmountIn,
          realAmountOut,
          expirationTime: minExpirationTime2(amountIn.expirationTime, realAmountOut.expirationTime),
          currentPrice: poolInfo.currentPrice,
          executionPrice,
          priceImpact,
          fee: feeAmount,
          remainingAccounts
        };
      }
      static estimateAprsForPriceRangeMultiplier({
        poolInfo,
        aprType,
        positionTickLowerIndex,
        positionTickUpperIndex
      }) {
        const aprInfo = poolInfo[aprType];
        const priceLower = this.getTickPrice({ poolInfo, tick: positionTickLowerIndex, baseIn: true }).price.toNumber();
        const priceUpper = this.getTickPrice({ poolInfo, tick: positionTickUpperIndex, baseIn: true }).price.toNumber();
        const _minPrice = Math.max(priceLower, aprInfo.priceMin);
        const _maxPrice = Math.min(priceUpper, aprInfo.priceMax);
        const sub3 = _maxPrice - _minPrice;
        const userRange = priceUpper - priceLower;
        const tradeRange = aprInfo.priceMax - aprInfo.priceMin;
        let p;
        if (sub3 <= 0)
          p = 0;
        else if (userRange === sub3)
          p = tradeRange / sub3;
        else if (tradeRange === sub3)
          p = sub3 / userRange;
        else
          p = sub3 / tradeRange * (sub3 / userRange);
        return {
          feeApr: aprInfo.feeApr * p,
          rewardsApr: [aprInfo.rewardApr.A * p, aprInfo.rewardApr.B * p, aprInfo.rewardApr.C * p],
          apr: aprInfo.apr * p
        };
      }
      static estimateAprsForPriceRangeDelta({
        poolInfo,
        aprType,
        mintPrice,
        rewardMintDecimals,
        liquidity,
        positionTickLowerIndex,
        positionTickUpperIndex,
        chainTime
      }) {
        const aprTypeDay = aprType === "day" ? 1 : aprType === "week" ? 7 : aprType === "month" ? 30 : 0;
        const aprInfo = poolInfo[aprType];
        const mintPriceA = mintPrice[poolInfo.mintA.mint.toString()];
        const mintPriceB = mintPrice[poolInfo.mintB.mint.toString()];
        const mintDecimalsA = poolInfo.mintA.decimals;
        const mintDecimalsB = poolInfo.mintB.decimals;
        if (!aprInfo || !mintPriceA || !mintPriceB)
          return { feeApr: 0, rewardsApr: [0, 0, 0], apr: 0 };
        const sqrtPriceX64A = SqrtPriceMath2.getSqrtPriceX64FromTick(positionTickLowerIndex);
        const sqrtPriceX64B = SqrtPriceMath2.getSqrtPriceX64FromTick(positionTickUpperIndex);
        const { amountSlippageA: poolLiquidityA, amountSlippageB: poolLiquidityB } = LiquidityMath2.getAmountsFromLiquidityWithSlippage(
          poolInfo.sqrtPriceX64,
          sqrtPriceX64A,
          sqrtPriceX64B,
          poolInfo.liquidity,
          false,
          false,
          0
        );
        const { amountSlippageA: userLiquidityA, amountSlippageB: userLiquidityB } = LiquidityMath2.getAmountsFromLiquidityWithSlippage(
          poolInfo.sqrtPriceX64,
          sqrtPriceX64A,
          sqrtPriceX64B,
          liquidity,
          false,
          false,
          0
        );
        const poolTvl = new import_decimal3.default(poolLiquidityA.toString()).div(new import_decimal3.default(10).pow(mintDecimalsA)).mul(mintPriceA.toFixed(mintDecimalsA)).add(
          new import_decimal3.default(poolLiquidityB.toString()).div(new import_decimal3.default(10).pow(mintDecimalsB)).mul(mintPriceB.toFixed(mintDecimalsB))
        );
        const userTvl = new import_decimal3.default(userLiquidityA.toString()).div(new import_decimal3.default(10).pow(mintDecimalsA)).mul(mintPriceA.toFixed(mintDecimalsA)).add(
          new import_decimal3.default(userLiquidityB.toString()).div(new import_decimal3.default(10).pow(mintDecimalsB)).mul(mintPriceB.toFixed(mintDecimalsB))
        );
        const p = new import_decimal3.default(1).div(poolTvl.add(userTvl));
        const feesPerYear = new import_decimal3.default(aprInfo.volumeFee).mul(365).div(aprTypeDay);
        const feeApr = feesPerYear.mul(p).mul(100).toNumber();
        const SECONDS_PER_YEAR = 3600 * 24 * 365;
        const rewardsApr = poolInfo.rewardInfos.map((i) => {
          const iDecimal = rewardMintDecimals[i.tokenMint.toString()];
          const iPrice = mintPrice[i.tokenMint.toString()];
          if (chainTime < i.openTime.toNumber() || chainTime > i.endTime.toNumber() || i.perSecond.equals(0) || !iPrice || iDecimal === void 0)
            return 0;
          return new import_decimal3.default(iPrice.toFixed(iDecimal)).mul(i.perSecond.mul(SECONDS_PER_YEAR)).div(new import_decimal3.default(10).pow(iDecimal)).mul(p).mul(100).toNumber();
        });
        return {
          feeApr,
          rewardsApr,
          apr: feeApr + rewardsApr.reduce((a, b) => a + b, 0)
        };
      }
      // fetch data
      static fetchMultiplePoolInfos(_0) {
        return __async(this, arguments, function* ({
          connection,
          poolKeys,
          ownerInfo,
          chainTime,
          batchRequest = false,
          updateOwnerRewardAndFee = true
        }) {
          var _a;
          const poolAccountInfos = yield getMultipleAccountsInfo2(
            connection,
            poolKeys.map((i) => new import_web318.PublicKey(i.id)),
            { batchRequest }
          );
          const exBitmapAddress = {};
          for (let index = 0; index < poolKeys.length; index++) {
            const apiPoolInfo = poolKeys[index];
            const accountInfo = poolAccountInfos[index];
            if (accountInfo === null)
              continue;
            exBitmapAddress[apiPoolInfo.id] = getPdaExBitmapAccount2(
              accountInfo.owner,
              new import_web318.PublicKey(apiPoolInfo.id)
            ).publicKey;
          }
          const exBitmapAccountInfos = yield this.fetchExBitmaps({
            connection,
            exBitmapAddress: Object.values(exBitmapAddress),
            batchRequest
          });
          const programIds = [];
          const poolsInfo = {};
          const updateRewardInfos = [];
          for (let index = 0; index < poolKeys.length; index++) {
            const apiPoolInfo = poolKeys[index];
            const accountInfo = poolAccountInfos[index];
            const exBitmapInfo = exBitmapAccountInfos[exBitmapAddress[apiPoolInfo.id].toString()];
            if (accountInfo === null)
              continue;
            const layoutAccountInfo = PoolInfoLayout2.decode(accountInfo.data);
            poolsInfo[apiPoolInfo.id] = {
              state: {
                id: new import_web318.PublicKey(apiPoolInfo.id),
                mintA: {
                  programId: new import_web318.PublicKey(apiPoolInfo.mintProgramIdA),
                  mint: layoutAccountInfo.mintA,
                  vault: layoutAccountInfo.vaultA,
                  decimals: layoutAccountInfo.mintDecimalsA
                },
                mintB: {
                  programId: new import_web318.PublicKey(apiPoolInfo.mintProgramIdB),
                  mint: layoutAccountInfo.mintB,
                  vault: layoutAccountInfo.vaultB,
                  decimals: layoutAccountInfo.mintDecimalsB
                },
                observationId: layoutAccountInfo.observationId,
                ammConfig: __spreadProps(__spreadValues({}, apiPoolInfo.ammConfig), {
                  id: new import_web318.PublicKey(apiPoolInfo.ammConfig.id)
                }),
                creator: layoutAccountInfo.creator,
                programId: accountInfo.owner,
                version: 6,
                tickSpacing: layoutAccountInfo.tickSpacing,
                liquidity: layoutAccountInfo.liquidity,
                sqrtPriceX64: layoutAccountInfo.sqrtPriceX64,
                currentPrice: SqrtPriceMath2.sqrtPriceX64ToPrice(
                  layoutAccountInfo.sqrtPriceX64,
                  layoutAccountInfo.mintDecimalsA,
                  layoutAccountInfo.mintDecimalsB
                ),
                tickCurrent: layoutAccountInfo.tickCurrent,
                observationIndex: layoutAccountInfo.observationIndex,
                observationUpdateDuration: layoutAccountInfo.observationUpdateDuration,
                feeGrowthGlobalX64A: layoutAccountInfo.feeGrowthGlobalX64A,
                feeGrowthGlobalX64B: layoutAccountInfo.feeGrowthGlobalX64B,
                protocolFeesTokenA: layoutAccountInfo.protocolFeesTokenA,
                protocolFeesTokenB: layoutAccountInfo.protocolFeesTokenB,
                swapInAmountTokenA: layoutAccountInfo.swapInAmountTokenA,
                swapOutAmountTokenB: layoutAccountInfo.swapOutAmountTokenB,
                swapInAmountTokenB: layoutAccountInfo.swapInAmountTokenB,
                swapOutAmountTokenA: layoutAccountInfo.swapOutAmountTokenA,
                tickArrayBitmap: layoutAccountInfo.tickArrayBitmap,
                rewardInfos: yield PoolUtils3.updatePoolRewardInfos({
                  connection,
                  apiPoolInfo,
                  chainTime,
                  poolLiquidity: layoutAccountInfo.liquidity,
                  rewardInfos: layoutAccountInfo.rewardInfos.filter((i) => !i.tokenMint.equals(import_web318.PublicKey.default))
                }),
                day: apiPoolInfo.day,
                week: apiPoolInfo.week,
                month: apiPoolInfo.month,
                tvl: apiPoolInfo.tvl,
                lookupTableAccount: apiPoolInfo.lookupTableAccount ? new import_web318.PublicKey(apiPoolInfo.lookupTableAccount) : import_web318.PublicKey.default,
                startTime: layoutAccountInfo.startTime.toNumber(),
                exBitmapInfo
              }
            };
            if (ownerInfo) {
              updateRewardInfos.push(
                ...poolsInfo[apiPoolInfo.id].state.rewardInfos.filter((i) => i.creator.equals(ownerInfo.wallet))
              );
            }
            if (!programIds.find((i) => i.equals(accountInfo.owner)))
              programIds.push(accountInfo.owner);
          }
          if (ownerInfo) {
            const allMint = ownerInfo.tokenAccounts.filter((i) => i.accountInfo.amount.eq(new import_bn15.default(1))).map((i) => i.accountInfo.mint);
            const allPositionKey = [];
            for (const itemMint of allMint) {
              for (const itemProgramId of programIds) {
                allPositionKey.push(getPdaPersonalPositionAddress2(itemProgramId, itemMint).publicKey);
              }
            }
            const positionAccountInfos = yield getMultipleAccountsInfo2(connection, allPositionKey, { batchRequest });
            const keyToTickArrayAddress = {};
            for (const itemAccountInfo of positionAccountInfos) {
              if (itemAccountInfo === null)
                continue;
              const position = PositionInfoLayout2.decode(itemAccountInfo.data);
              const itemPoolId = position.poolId.toString();
              const poolInfoA = poolsInfo[itemPoolId];
              if (poolInfoA === void 0)
                continue;
              const poolInfo = poolInfoA.state;
              const priceLower = this.getTickPrice({
                poolInfo,
                tick: position.tickLower,
                baseIn: true
              });
              const priceUpper = this.getTickPrice({
                poolInfo,
                tick: position.tickUpper,
                baseIn: true
              });
              const { amountA, amountB } = LiquidityMath2.getAmountsFromLiquidity(
                poolInfo.sqrtPriceX64,
                priceLower.tickSqrtPriceX64,
                priceUpper.tickSqrtPriceX64,
                position.liquidity,
                false
              );
              const leverage = 1 / (1 - Math.sqrt(Math.sqrt(priceLower.price.div(priceUpper.price).toNumber())));
              poolsInfo[itemPoolId].positionAccount = [
                ...(_a = poolsInfo[itemPoolId].positionAccount) != null ? _a : [],
                {
                  poolId: position.poolId,
                  nftMint: position.nftMint,
                  priceLower: priceLower.price,
                  priceUpper: priceUpper.price,
                  amountA,
                  amountB,
                  tickLower: position.tickLower,
                  tickUpper: position.tickUpper,
                  liquidity: position.liquidity,
                  feeGrowthInsideLastX64A: position.feeGrowthInsideLastX64A,
                  feeGrowthInsideLastX64B: position.feeGrowthInsideLastX64B,
                  tokenFeesOwedA: position.tokenFeesOwedA,
                  tokenFeesOwedB: position.tokenFeesOwedB,
                  rewardInfos: position.rewardInfos.map((i) => __spreadProps(__spreadValues({}, i), {
                    pendingReward: new import_bn15.default(0)
                  })),
                  leverage,
                  tokenFeeAmountA: new import_bn15.default(0),
                  tokenFeeAmountB: new import_bn15.default(0)
                }
              ];
              const tickArrayLowerAddress = TickUtils2.getTickArrayAddressByTick(
                poolsInfo[itemPoolId].state.programId,
                position.poolId,
                position.tickLower,
                poolsInfo[itemPoolId].state.tickSpacing
              );
              const tickArrayUpperAddress = TickUtils2.getTickArrayAddressByTick(
                poolsInfo[itemPoolId].state.programId,
                position.poolId,
                position.tickUpper,
                poolsInfo[itemPoolId].state.tickSpacing
              );
              keyToTickArrayAddress[`${poolsInfo[itemPoolId].state.programId.toString()}-${position.poolId.toString()}-${position.tickLower}`] = tickArrayLowerAddress;
              keyToTickArrayAddress[`${poolsInfo[itemPoolId].state.programId.toString()}-${position.poolId.toString()}-${position.tickUpper}`] = tickArrayUpperAddress;
            }
            if (updateOwnerRewardAndFee) {
              const tickArrayKeys = Object.values(keyToTickArrayAddress);
              const tickArrayDatas = yield getMultipleAccountsInfo2(connection, tickArrayKeys, { batchRequest });
              const tickArrayLayout = {};
              for (let index = 0; index < tickArrayKeys.length; index++) {
                const tickArrayData = tickArrayDatas[index];
                if (tickArrayData === null)
                  continue;
                const key = tickArrayKeys[index];
                tickArrayLayout[key.toString()] = __spreadValues({
                  address: key
                }, TickArrayLayout2.decode(tickArrayData.data));
              }
              for (const { state, positionAccount } of Object.values(poolsInfo)) {
                if (!positionAccount)
                  continue;
                for (const itemPA of positionAccount) {
                  const keyLower = `${state.programId.toString()}-${state.id.toString()}-${itemPA.tickLower}`;
                  const keyUpper = `${state.programId.toString()}-${state.id.toString()}-${itemPA.tickUpper}`;
                  const tickArrayLower = tickArrayLayout[keyToTickArrayAddress[keyLower].toString()];
                  const tickArrayUpper = tickArrayLayout[keyToTickArrayAddress[keyUpper].toString()];
                  const tickLowerState = tickArrayLower.ticks[TickUtils2.getTickOffsetInArray(itemPA.tickLower, state.tickSpacing)];
                  const tickUpperState = tickArrayUpper.ticks[TickUtils2.getTickOffsetInArray(itemPA.tickUpper, state.tickSpacing)];
                  const { tokenFeeAmountA, tokenFeeAmountB } = PositionUtils2.GetPositionFees(
                    state,
                    itemPA,
                    tickLowerState,
                    tickUpperState
                  );
                  const rewardInfos = PositionUtils2.GetPositionRewards(state, itemPA, tickLowerState, tickUpperState);
                  itemPA.tokenFeeAmountA = tokenFeeAmountA.gte(ZERO2) && tokenFeeAmountA.lt(U64_IGNORE_RANGE2) ? tokenFeeAmountA : ZERO2;
                  itemPA.tokenFeeAmountB = tokenFeeAmountB.gte(ZERO2) && tokenFeeAmountA.lt(U64_IGNORE_RANGE2) ? tokenFeeAmountB : ZERO2;
                  for (let i = 0; i < rewardInfos.length; i++) {
                    itemPA.rewardInfos[i].pendingReward = rewardInfos[i].gte(ZERO2) && rewardInfos[i].lt(U64_IGNORE_RANGE2) ? rewardInfos[i] : ZERO2;
                  }
                }
              }
            }
          }
          if (updateRewardInfos.length > 0) {
            const vaults = updateRewardInfos.map((i) => i.tokenVault);
            const rewardVaultInfos = yield getMultipleAccountsInfo2(connection, vaults, { batchRequest });
            const rewardVaultAmount = {};
            for (let index = 0; index < vaults.length; index++) {
              const valutKey = vaults[index].toString();
              const itemRewardVaultInfo = rewardVaultInfos[index];
              if (itemRewardVaultInfo === null)
                continue;
              const info = SPL_ACCOUNT_LAYOUT.decode(itemRewardVaultInfo.data);
              rewardVaultAmount[valutKey] = info.amount;
            }
            for (const item of updateRewardInfos) {
              const vaultAmount = rewardVaultAmount[item.tokenVault.toString()];
              item.remainingRewards = vaultAmount !== void 0 ? vaultAmount.sub(item.rewardTotalEmissioned.sub(item.rewardClaimed)) : ZERO2;
            }
          }
          return poolsInfo;
        });
      }
      static fetchMultiplePoolTickArrays(_0) {
        return __async(this, arguments, function* ({
          connection,
          poolKeys,
          batchRequest
        }) {
          const tickArraysToPoolId = {};
          const tickArrays = [];
          for (const itemPoolInfo of poolKeys) {
            const currentTickArrayStartIndex = TickUtils2.getTickArrayStartIndexByTick(
              itemPoolInfo.tickCurrent,
              itemPoolInfo.tickSpacing
            );
            const startIndexArray = TickUtils2.getInitializedTickArrayInRange(
              itemPoolInfo.tickArrayBitmap,
              itemPoolInfo.exBitmapInfo,
              itemPoolInfo.tickSpacing,
              currentTickArrayStartIndex,
              7
            );
            for (const itemIndex of startIndexArray) {
              const { publicKey: tickArrayAddress } = getPdaTickArrayAddress2(
                itemPoolInfo.programId,
                itemPoolInfo.id,
                itemIndex
              );
              tickArrays.push({ pubkey: tickArrayAddress });
              tickArraysToPoolId[tickArrayAddress.toString()] = itemPoolInfo.id;
            }
          }
          const fetchedTickArrays = yield getMultipleAccountsInfoWithCustomFlags2(connection, tickArrays, { batchRequest });
          const tickArrayCache = {};
          for (const itemAccountInfo of fetchedTickArrays) {
            if (!itemAccountInfo.accountInfo)
              continue;
            const poolId = tickArraysToPoolId[itemAccountInfo.pubkey.toString()];
            if (!poolId)
              continue;
            if (tickArrayCache[poolId.toString()] === void 0)
              tickArrayCache[poolId.toString()] = {};
            const accountLayoutData = TickArrayLayout2.decode(itemAccountInfo.accountInfo.data);
            tickArrayCache[poolId.toString()][accountLayoutData.startTickIndex] = __spreadProps(__spreadValues({}, accountLayoutData), {
              address: itemAccountInfo.pubkey
            });
          }
          return tickArrayCache;
        });
      }
      static fetchExBitmaps(_0) {
        return __async(this, arguments, function* ({
          connection,
          exBitmapAddress,
          batchRequest
        }) {
          const fetchedBitmapAccount = yield getMultipleAccountsInfoWithCustomFlags2(
            connection,
            exBitmapAddress.map((i) => ({ pubkey: i })),
            { batchRequest }
          );
          const returnTypeFetchExBitmaps = {};
          for (const item of fetchedBitmapAccount) {
            if (item.accountInfo === null)
              continue;
            returnTypeFetchExBitmaps[item.pubkey.toString()] = TickArrayBitmapExtensionLayout2.decode(item.accountInfo.data);
          }
          return returnTypeFetchExBitmaps;
        });
      }
      static getWhiteListMint(_0) {
        return __async(this, arguments, function* ({ connection, programId }) {
          const accountInfo = yield connection.getAccountInfo(getPdaOperationAccount2(programId).publicKey);
          if (!accountInfo)
            return [];
          const whitelistMintsInfo = OperationLayout2.decode(accountInfo.data);
          return whitelistMintsInfo.whitelistMints.filter((i) => !i.equals(import_web318.PublicKey.default));
        });
      }
    };
    var import_web319 = require("@solana/web3.js");
    var _SERUM_PROGRAM_ID_V3 = "9xQeWvG816bUx9EPjHmaT23yvVM2ZWbrrpZb9PusVFin";
    var SERUM_PROGRAM_ID_V32 = new import_web319.PublicKey(_SERUM_PROGRAM_ID_V3);
    var SERUM_PROGRAMID_TO_VERSION2 = {
      [_SERUM_PROGRAM_ID_V3]: 3
    };
    var SERUM_VERSION_TO_PROGRAMID2 = {
      3: SERUM_PROGRAM_ID_V32
    };
    var MARKET_STATE_LAYOUT_V32 = struct3([
      blob4(5),
      blob4(8),
      // accountFlagsLayout('accountFlags'),
      publicKey3("ownAddress"),
      u643("vaultSignerNonce"),
      publicKey3("baseMint"),
      publicKey3("quoteMint"),
      publicKey3("baseVault"),
      u643("baseDepositsTotal"),
      u643("baseFeesAccrued"),
      publicKey3("quoteVault"),
      u643("quoteDepositsTotal"),
      u643("quoteFeesAccrued"),
      u643("quoteDustThreshold"),
      publicKey3("requestQueue"),
      publicKey3("eventQueue"),
      publicKey3("bids"),
      publicKey3("asks"),
      u643("baseLotSize"),
      u643("quoteLotSize"),
      u643("feeRateBps"),
      u643("referrerRebatesAccrued"),
      blob4(7)
    ]);
    var MARKET_VERSION_TO_STATE_LAYOUT2 = {
      3: MARKET_STATE_LAYOUT_V32
    };
    var import_web320 = require("@solana/web3.js");
    var logger10 = Logger2.from("Serum");
    var Market2 = class {
      /* ================= get version and program id ================= */
      static getProgramId(version2) {
        const programId = SERUM_VERSION_TO_PROGRAMID2[version2];
        logger10.assertArgument(!!programId, "invalid version", "version", version2);
        return programId;
      }
      static getVersion(programId) {
        const programIdString = programId.toBase58();
        const version2 = SERUM_PROGRAMID_TO_VERSION2[programIdString];
        logger10.assertArgument(!!version2, "invalid program id", "programId", programIdString);
        return version2;
      }
      /* ================= get layout ================= */
      static getStateLayout(version2) {
        const STATE_LAYOUT = MARKET_VERSION_TO_STATE_LAYOUT2[version2];
        logger10.assertArgument(!!STATE_LAYOUT, "invalid version", "version", version2);
        return STATE_LAYOUT;
      }
      static getLayouts(version2) {
        return { state: this.getStateLayout(version2) };
      }
      /* ================= get key ================= */
      static getAssociatedAuthority({ programId, marketId }) {
        const seeds = [marketId.toBuffer()];
        let nonce = 0;
        let publicKey22;
        while (nonce < 100) {
          try {
            const seedsWithNonce = seeds.concat(Buffer.from([nonce]), Buffer.alloc(7));
            publicKey22 = import_web320.PublicKey.createProgramAddressSync(seedsWithNonce, programId);
          } catch (err) {
            if (err instanceof TypeError) {
              throw err;
            }
            nonce++;
            continue;
          }
          return { publicKey: publicKey22, nonce };
        }
        return logger10.throwArgumentError("unable to find a viable program address nonce", "params", {
          programId,
          marketId
        });
      }
    };
    var import_web321 = require("@solana/web3.js");
    var ModelDataPubkey = new import_web321.PublicKey("CDSr3ssLcRB6XYPJwAfFt18MZvEZp4LjHcvzBVZ45duo");
    var ELEMENT_SIZE = 5e4;
    var DataElement2 = struct3([u643("x"), u643("y"), u643("price")]);
    var ModelDataInfo = struct3([
      u643("accountType"),
      u643("status"),
      u643("multiplier"),
      u643("validDataCount"),
      seq22(DataElement2, ELEMENT_SIZE, "DataElement")
    ]);
    function estimateRangeByXyReal(_xReal, _yReal) {
      return [0, ELEMENT_SIZE - 2];
    }
    function estimateRangeByX(_x) {
      return [0, ELEMENT_SIZE - 2];
    }
    function estimateRangeByY(_y) {
      return [0, ELEMENT_SIZE - 2];
    }
    function getMininumRangeByXyReal(layoutData, xReal, yReal) {
      const [min2, max2] = estimateRangeByXyReal(xReal, yReal);
      let minRangeIdx = min2;
      let maxRangeIdx = max2;
      let mid = 0;
      const target = xReal * layoutData.multiplier / yReal;
      while (minRangeIdx <= maxRangeIdx) {
        mid = Math.floor((maxRangeIdx + minRangeIdx) / 2);
        if (mid === 0 || mid >= ELEMENT_SIZE - 2) {
          return [mid, mid, false];
        }
        const cur = layoutData.DataElement[mid].x * layoutData.multiplier / layoutData.DataElement[mid].y;
        const left = layoutData.DataElement[mid - 1].x * layoutData.multiplier / layoutData.DataElement[mid - 1].y;
        const right = layoutData.DataElement[mid + 1].x * layoutData.multiplier / layoutData.DataElement[mid + 1].y;
        if (target === cur) {
          return [mid, mid, true];
        } else if (target === left) {
          return [mid - 1, mid - 1, true];
        } else if (target === right) {
          return [mid + 1, mid + 1, true];
        } else if (target < left) {
          maxRangeIdx = mid - 1;
        } else if (target > left && target < cur) {
          return [mid - 1, mid, true];
        } else if (target > cur && target < right) {
          return [mid, mid + 1, true];
        } else {
          minRangeIdx = mid + 1;
        }
      }
      return [mid, mid, false];
    }
    function getRatio(layoutData, xReal, yReal) {
      const [minRangeIdx, maxRangeIdx, find] = getMininumRangeByXyReal(layoutData, xReal, yReal);
      if (!find) {
        return 0;
      }
      if (minRangeIdx === maxRangeIdx) {
        const x = layoutData.DataElement[minRangeIdx].x;
        const ratio = xReal * layoutData.multiplier / x;
        return ratio;
      } else {
        const x1 = layoutData.DataElement[minRangeIdx].x;
        const y1 = layoutData.DataElement[minRangeIdx].y;
        const x2 = layoutData.DataElement[maxRangeIdx].x;
        const y2 = layoutData.DataElement[maxRangeIdx].y;
        const xDenominator = yReal * (x2 * y1 - x1 * y2);
        const xNumerator1 = x1 * xDenominator;
        const xNumerator2 = (x2 - x1) * (xReal * y1 - x1 * yReal) * y2;
        const xNumerator = xNumerator1 + xNumerator2;
        const ratio = xReal * layoutData.multiplier * xDenominator / xNumerator;
        return ratio;
      }
    }
    function realToTable(layoutData, realValue, ratio) {
      return realValue * layoutData.multiplier / ratio;
    }
    function tableToReal(layoutData, tableValue, ratio) {
      return tableValue * ratio / layoutData.multiplier;
    }
    function getMinimumRangeByX(layoutData, x) {
      const [min2, max2] = estimateRangeByX(x);
      let minRangeIdx = min2;
      let maxRangeIdx = max2;
      let mid = 0;
      const target = x;
      while (minRangeIdx < maxRangeIdx) {
        mid = Math.floor((maxRangeIdx + minRangeIdx) / 2);
        if (mid <= 0 || mid > ELEMENT_SIZE - 2) {
          return [mid, mid, false];
        }
        const cur = layoutData.DataElement[mid].x;
        const left = layoutData.DataElement[mid - 1].x;
        const right = layoutData.DataElement[mid + 1].x;
        if (target === cur)
          return [mid, mid, true];
        else if (target === left)
          return [mid - 1, mid - 1, true];
        else if (target === right)
          return [mid + 1, mid + 1, true];
        else if (target < left)
          maxRangeIdx = mid - 1;
        else if (target > left && target < cur)
          return [mid - 1, mid, true];
        else if (target > cur && target < right)
          return [mid, mid + 1, true];
        else
          minRangeIdx = mid + 1;
      }
      return [mid, mid, false];
    }
    function getMinimumRangeByY(layoutData, y) {
      const [min2, max2] = estimateRangeByY(y);
      let minRangeIdx = min2;
      let maxRangeIdx = max2;
      let mid = 0;
      const target = y;
      while (minRangeIdx <= maxRangeIdx) {
        mid = Math.floor((maxRangeIdx + minRangeIdx) / 2);
        if (mid <= 0 || mid >= ELEMENT_SIZE - 2) {
          return [mid, mid, false];
        }
        const cur = layoutData.DataElement[mid].y;
        const left = layoutData.DataElement[mid - 1].y;
        const right = layoutData.DataElement[mid + 1].y;
        if (target === cur)
          return [mid, mid, true];
        else if (target === left)
          return [mid - 1, mid - 1, true];
        else if (target === right)
          return [mid + 1, mid + 1, true];
        else if (target < right) {
          minRangeIdx = mid + 1;
        } else if (target < left && target > cur)
          return [mid - 1, mid, true];
        else if (target < cur && target > right)
          return [mid, mid + 1, true];
        else
          maxRangeIdx = mid - 1;
      }
      return [mid, mid, false];
    }
    function getDataByX(layoutData, x, dx, priceUp) {
      const xWithDx = priceUp ? x + dx : x - dx;
      const [minIdx, maxIdx, find] = getMinimumRangeByX(layoutData, xWithDx);
      if (!find)
        return [0, 0, false, find];
      if (minIdx === maxIdx)
        return [layoutData.DataElement[maxIdx].price, layoutData.DataElement[maxIdx].y, false, find];
      else {
        const x1 = layoutData.DataElement[minIdx].x;
        const x2 = layoutData.DataElement[maxIdx].x;
        const p1 = layoutData.DataElement[minIdx].price;
        const p2 = layoutData.DataElement[maxIdx].price;
        const y1 = layoutData.DataElement[minIdx].y;
        const y2 = layoutData.DataElement[maxIdx].y;
        if (x >= x1 && x <= x2) {
          if (priceUp)
            return [p2, y2, true, find];
          else
            return [p1, y1, true, find];
        } else {
          let p, y;
          if (priceUp) {
            p = p1 + (p2 - p1) * (x - x1) / (x2 - x1);
            y = y1 - (xWithDx - x1) * layoutData.multiplier / p2;
          } else {
            p = p1 + (p2 - p1) * (x - x1) / (x2 - x1);
            y = y2 + (x2 - xWithDx) * layoutData.multiplier / p1;
          }
          return [p, y, false, find];
        }
      }
    }
    function getDataByY(layoutData, y, dy, priceUp) {
      const yWithDy = priceUp ? y - dy : y + dy;
      const [minIdx, maxIdx, find] = getMinimumRangeByY(layoutData, yWithDy);
      if (!find)
        return [0, 0, false, find];
      if (minIdx === maxIdx)
        return [layoutData.DataElement[maxIdx].price, layoutData.DataElement[maxIdx].x, false, find];
      else {
        const x1 = layoutData.DataElement[minIdx].x;
        const x2 = layoutData.DataElement[maxIdx].x;
        const p1 = layoutData.DataElement[minIdx].price;
        const p2 = layoutData.DataElement[maxIdx].price;
        const y1 = layoutData.DataElement[minIdx].y;
        const y2 = layoutData.DataElement[maxIdx].y;
        if (y >= y2 && y <= y1) {
          return priceUp ? [p2, x2, true, find] : [p1, x1, true, find];
        } else {
          let p, x;
          if (priceUp) {
            p = p1 + (p2 - p1) * (y1 - y) / (y1 - y2);
            x = x1 + p2 * (y1 - yWithDy) / layoutData.multiplier;
          } else {
            p = p1 + (p2 - p1) * (y1 - y) / (y1 - y2);
            x = x2 - p1 * (yWithDy - y2) / layoutData.multiplier;
          }
          return [p, x, false, find];
        }
      }
    }
    function getMidPrice(layoutData, x) {
      const ret = getDataByX(layoutData, x, 0, false);
      if (ret[3])
        return ret[0];
      else
        return 0;
    }
    function getDyByDxBaseIn2(layoutData, xReal, yReal, dxReal) {
      const ratio = getRatio(layoutData, xReal, yReal);
      const x = realToTable(layoutData, xReal, ratio);
      const y = realToTable(layoutData, yReal, ratio);
      const dx = realToTable(layoutData, dxReal, ratio);
      const priceUp = true;
      const [p, y2, lessTrade, find] = getDataByX(layoutData, x, dx, priceUp);
      if (!find)
        return 0;
      if (lessTrade) {
        const dyReal = dxReal * layoutData.multiplier / p;
        return dyReal;
      } else {
        const dy = y - y2;
        const dyReal = tableToReal(layoutData, dy, ratio);
        return dyReal;
      }
    }
    function getDxByDyBaseIn2(layoutData, xReal, yReal, dyReal) {
      const ratio = getRatio(layoutData, xReal, yReal);
      const x = realToTable(layoutData, xReal, ratio);
      const y = realToTable(layoutData, yReal, ratio);
      const dy = realToTable(layoutData, dyReal, ratio);
      const priceUp = false;
      const [p, x2, lessTrade, find] = getDataByY(layoutData, y, dy, priceUp);
      if (!find)
        return 0;
      if (lessTrade) {
        const dxReal = dyReal * p / layoutData.multiplier;
        return dxReal;
      } else {
        const dx = x - x2;
        const dxReal = tableToReal(layoutData, dx, ratio);
        return dxReal;
      }
    }
    function formatLayout2(buffer) {
      const layoutInfo = ModelDataInfo.decode(buffer);
      return {
        accountType: layoutInfo.accountType.toNumber(),
        status: layoutInfo.status.toNumber(),
        multiplier: layoutInfo.multiplier.toNumber(),
        validDataCount: layoutInfo.validDataCount.toNumber(),
        DataElement: layoutInfo.DataElement.map((item) => ({
          x: item.x.toNumber(),
          y: item.y.toNumber(),
          price: item.price.toNumber()
        }))
      };
    }
    function getStablePrice2(layoutData, coinReal, pcReal, baseCoin) {
      const price = getMidPrice(layoutData, realToTable(layoutData, coinReal, getRatio(layoutData, coinReal, pcReal))) / layoutData.multiplier;
      return baseCoin ? price : 1 / price;
    }
    var logger11 = Logger2.from("Liquidity");
    var modelData = {
      accountType: 0,
      status: 0,
      multiplier: 0,
      validDataCount: 0,
      DataElement: []
    };
    function initStableModelLayout(connection) {
      return __async(this, null, function* () {
        if (modelData.validDataCount === 0) {
          if (connection) {
            const acc = yield connection.getAccountInfo(ModelDataPubkey);
            if (acc)
              modelData = formatLayout2(acc == null ? void 0 : acc.data);
          }
        }
      });
    }
    var LiquidityPoolStatus = /* @__PURE__ */ ((LiquidityPoolStatus2) => {
      LiquidityPoolStatus2[LiquidityPoolStatus2["Uninitialized"] = 0] = "Uninitialized";
      LiquidityPoolStatus2[LiquidityPoolStatus2["Initialized"] = 1] = "Initialized";
      LiquidityPoolStatus2[LiquidityPoolStatus2["Disabled"] = 2] = "Disabled";
      LiquidityPoolStatus2[LiquidityPoolStatus2["RemoveLiquidityOnly"] = 3] = "RemoveLiquidityOnly";
      LiquidityPoolStatus2[LiquidityPoolStatus2["LiquidityOnly"] = 4] = "LiquidityOnly";
      LiquidityPoolStatus2[LiquidityPoolStatus2["OrderBook"] = 5] = "OrderBook";
      LiquidityPoolStatus2[LiquidityPoolStatus2["Swap"] = 6] = "Swap";
      LiquidityPoolStatus2[LiquidityPoolStatus2["WaitingForStart"] = 7] = "WaitingForStart";
      return LiquidityPoolStatus2;
    })(LiquidityPoolStatus || {});
    var LIQUIDITY_FEES_NUMERATOR2 = new import_bn16.default(25);
    var LIQUIDITY_FEES_DENOMINATOR2 = new import_bn16.default(1e4);
    var _Liquidity = class _Liquidity2 extends Base {
      // public connection: Connection;
      // public poolKeys: LiquidityPoolKeys;
      // public poolInfo: LiquidityPoolInfo;
      // constructor({ connection, poolKeys, poolInfo }: LiquidityConstructParams) {
      //   this.connection = connection;
      //   this.poolKeys = poolKeys;
      //   this.poolInfo = poolInfo;
      // }
      // static async load({ connection, poolKeys, poolInfo }: LiquidityLoadParams) {
      //   const _poolInfo = poolInfo || (await this.fetchInfo({ connection, poolKeys }));
      //   return new Liquidity({ connection, poolKeys, poolInfo: _poolInfo });
      // }
      /* ================= get version and program id ================= */
      // static getProgramId(version: number) {
      //   const programId = LIQUIDITY_VERSION_TO_PROGRAMID[version];
      //   logger.assertArgument(!!programId, "invalid version", "version", version);
      //   return programId;
      // }
      // static getVersion(programId: PublicKey) {
      //   const programIdString = programId.toBase58();
      //   const version = LIQUIDITY_PROGRAMID_TO_VERSION[programIdString];
      //   logger.assertArgument(!!version, "invalid program id", "programId", programIdString);
      //   return version;
      // }
      // static getSerumVersion(version: number) {
      //   const serumVersion = LIQUIDITY_VERSION_TO_SERUM_VERSION[version];
      //   logger.assertArgument(!!serumVersion, "invalid version", "version", version);
      //   return serumVersion;
      // }
      /* ================= get layout ================= */
      static getStateLayout(version2) {
        const STATE_LAYOUT = LIQUIDITY_VERSION_TO_STATE_LAYOUT2[version2];
        logger11.assertArgument(!!STATE_LAYOUT, "invalid version", "version", version2);
        return STATE_LAYOUT;
      }
      static getLayouts(version2) {
        return { state: this.getStateLayout(version2) };
      }
      /* ================= get key ================= */
      static getAssociatedId({ programId, marketId }) {
        const { publicKey: publicKey22 } = findProgramAddress2(
          [programId.toBuffer(), marketId.toBuffer(), Buffer.from("amm_associated_seed", "utf-8")],
          programId
        );
        return publicKey22;
      }
      static getAssociatedAuthority({ programId }) {
        return findProgramAddress2(
          // new Uint8Array(Buffer.from('amm authority'.replace('\u00A0', ' '), 'utf-8'))
          [Buffer.from([97, 109, 109, 32, 97, 117, 116, 104, 111, 114, 105, 116, 121])],
          programId
        );
      }
      static getAssociatedBaseVault({ programId, marketId }) {
        const { publicKey: publicKey22 } = findProgramAddress2(
          [programId.toBuffer(), marketId.toBuffer(), Buffer.from("coin_vault_associated_seed", "utf-8")],
          programId
        );
        return publicKey22;
      }
      static getAssociatedQuoteVault({ programId, marketId }) {
        const { publicKey: publicKey22 } = findProgramAddress2(
          [programId.toBuffer(), marketId.toBuffer(), Buffer.from("pc_vault_associated_seed", "utf-8")],
          programId
        );
        return publicKey22;
      }
      static getAssociatedLpMint({ programId, marketId }) {
        const { publicKey: publicKey22 } = findProgramAddress2(
          [programId.toBuffer(), marketId.toBuffer(), Buffer.from("lp_mint_associated_seed", "utf-8")],
          programId
        );
        return publicKey22;
      }
      static getAssociatedLpVault({ programId, marketId }) {
        const { publicKey: publicKey22 } = findProgramAddress2(
          [programId.toBuffer(), marketId.toBuffer(), Buffer.from("temp_lp_token_associated_seed", "utf-8")],
          programId
        );
        return publicKey22;
      }
      static getAssociatedTargetOrders({ programId, marketId }) {
        const { publicKey: publicKey22 } = findProgramAddress2(
          [programId.toBuffer(), marketId.toBuffer(), Buffer.from("target_associated_seed", "utf-8")],
          programId
        );
        return publicKey22;
      }
      static getAssociatedWithdrawQueue({ programId, marketId }) {
        const { publicKey: publicKey22 } = findProgramAddress2(
          [programId.toBuffer(), marketId.toBuffer(), Buffer.from("withdraw_associated_seed", "utf-8")],
          programId
        );
        return publicKey22;
      }
      static getAssociatedOpenOrders({ programId, marketId }) {
        const { publicKey: publicKey22 } = findProgramAddress2(
          [programId.toBuffer(), marketId.toBuffer(), Buffer.from("open_order_associated_seed", "utf-8")],
          programId
        );
        return publicKey22;
      }
      static getAssociatedConfigId({ programId }) {
        const { publicKey: publicKey22 } = findProgramAddress2([Buffer.from("amm_config_account_seed", "utf-8")], programId);
        return publicKey22;
      }
      static getAssociatedPoolKeys({
        version: version2,
        marketVersion,
        marketId,
        baseMint,
        quoteMint,
        baseDecimals,
        quoteDecimals,
        programId,
        marketProgramId
      }) {
        const id = this.getAssociatedId({ programId, marketId });
        const lpMint = this.getAssociatedLpMint({ programId, marketId });
        const { publicKey: authority, nonce } = this.getAssociatedAuthority({ programId });
        const baseVault = this.getAssociatedBaseVault({ programId, marketId });
        const quoteVault = this.getAssociatedQuoteVault({ programId, marketId });
        const lpVault = this.getAssociatedLpVault({ programId, marketId });
        const openOrders = this.getAssociatedOpenOrders({ programId, marketId });
        const targetOrders = this.getAssociatedTargetOrders({ programId, marketId });
        const withdrawQueue = this.getAssociatedWithdrawQueue({ programId, marketId });
        const { publicKey: marketAuthority } = Market2.getAssociatedAuthority({
          programId: marketProgramId,
          marketId
        });
        return {
          // base
          id,
          baseMint,
          quoteMint,
          lpMint,
          baseDecimals,
          quoteDecimals,
          lpDecimals: baseDecimals,
          // version
          version: version2,
          programId,
          // keys
          authority,
          nonce,
          baseVault,
          quoteVault,
          lpVault,
          openOrders,
          targetOrders,
          withdrawQueue,
          // market version
          marketVersion,
          marketProgramId,
          // market keys
          marketId,
          marketAuthority,
          lookupTableAccount: import_web3222.PublicKey.default,
          configId: this.getAssociatedConfigId({ programId })
        };
      }
      static getCreatePoolFee(_0) {
        return __async(this, arguments, function* ({ connection, programId }) {
          const configId = this.getAssociatedConfigId({ programId });
          const layout = struct3([u643("fee")]);
          const account = yield connection.getAccountInfo(configId, { dataSlice: { offset: 536, length: 8 } });
          if (account === null)
            throw Error("get config account error");
          return layout.decode(account.data).fee;
        });
      }
      /* ================= make instruction and transaction ================= */
      static makeAddLiquidityInstruction(params) {
        const { poolKeys, userKeys, baseAmountIn, quoteAmountIn, fixedSide } = params;
        const { version: version2 } = poolKeys;
        if (version2 === 4 || version2 === 5) {
          const LAYOUT = struct3([u822("instruction"), u643("baseAmountIn"), u643("quoteAmountIn"), u643("fixedSide")]);
          const data = Buffer.alloc(LAYOUT.span);
          LAYOUT.encode(
            {
              instruction: 3,
              baseAmountIn: parseBigNumberish2(baseAmountIn),
              quoteAmountIn: parseBigNumberish2(quoteAmountIn),
              fixedSide: parseBigNumberish2(fixedSide === "base" ? 0 : 1)
            },
            data
          );
          const keys = [
            // system
            AccountMetaReadonly(import_spl_token2.TOKEN_PROGRAM_ID, false),
            // amm
            AccountMeta(poolKeys.id, false),
            AccountMetaReadonly(poolKeys.authority, false),
            AccountMetaReadonly(poolKeys.openOrders, false),
            AccountMeta(poolKeys.targetOrders, false),
            AccountMeta(poolKeys.lpMint, false),
            AccountMeta(poolKeys.baseVault, false),
            AccountMeta(poolKeys.quoteVault, false)
          ];
          if (version2 === 5) {
            keys.push(AccountMeta(ModelDataPubkey, false));
          }
          keys.push(
            // serum
            AccountMetaReadonly(poolKeys.marketId, false),
            // user
            AccountMeta(userKeys.baseTokenAccount, false),
            AccountMeta(userKeys.quoteTokenAccount, false),
            AccountMeta(userKeys.lpTokenAccount, false),
            AccountMetaReadonly(userKeys.owner, true),
            AccountMetaReadonly(poolKeys.marketEventQueue, false)
          );
          return {
            address: {},
            innerTransaction: {
              instructions: [
                new import_web3222.TransactionInstruction({
                  programId: poolKeys.programId,
                  keys,
                  data
                })
              ],
              signers: [],
              lookupTableAddress: [poolKeys.lookupTableAccount].filter((i) => i && !i.equals(import_web3222.PublicKey.default)),
              instructionTypes: [
                version2 === 4 ? 22 : 30
                /* ammV5AddLiquidity */
              ]
            }
          };
        }
        return logger11.throwArgumentError("invalid version", "poolKeys.version", version2);
      }
      static makeAddLiquidityInstructionSimple(params) {
        return __async(this, null, function* () {
          const {
            connection,
            poolKeys,
            userKeys,
            amountInA,
            amountInB,
            fixedSide,
            config: config2,
            makeTxVersion,
            lookupTableCache,
            computeBudgetConfig
          } = params;
          const { lpMint } = poolKeys;
          const { tokenAccounts, owner, payer = owner } = userKeys;
          logger11.debug("amountInA:", amountInA);
          logger11.debug("amountInB:", amountInB);
          logger11.assertArgument(
            !amountInA.isZero() && !amountInB.isZero(),
            "amounts must greater than zero",
            "amountInA & amountInB",
            {
              amountInA: amountInA.toFixed(),
              amountInB: amountInB.toFixed()
            }
          );
          const { bypassAssociatedCheck, checkCreateATAOwner } = __spreadValues(__spreadValues({}, { bypassAssociatedCheck: false, checkCreateATAOwner: false }), config2);
          const tokenA = amountInA instanceof TokenAmount3 ? amountInA.token : Token3.WSOL;
          const tokenB = amountInB instanceof TokenAmount3 ? amountInB.token : Token3.WSOL;
          const tokenAccountA = this._selectTokenAccount({
            programId: import_spl_token2.TOKEN_PROGRAM_ID,
            tokenAccounts,
            mint: tokenA.mint,
            owner,
            config: { associatedOnly: false }
          });
          const tokenAccountB = this._selectTokenAccount({
            programId: import_spl_token2.TOKEN_PROGRAM_ID,
            tokenAccounts,
            mint: tokenB.mint,
            owner,
            config: { associatedOnly: false }
          });
          logger11.assertArgument(
            !!tokenAccountA || !!tokenAccountB,
            "cannot found target token accounts",
            "tokenAccounts",
            tokenAccounts
          );
          const lpTokenAccount = this._selectTokenAccount({
            programId: import_spl_token2.TOKEN_PROGRAM_ID,
            tokenAccounts,
            mint: lpMint,
            owner
          });
          const tokens = [tokenA, tokenB];
          const _tokenAccounts = [tokenAccountA, tokenAccountB];
          const rawAmounts = [amountInA.raw, amountInB.raw];
          const [sideA] = this._getAmountsSide(amountInA, amountInB, poolKeys);
          let _fixedSide = "base";
          if (sideA === "quote") {
            tokens.reverse();
            _tokenAccounts.reverse();
            rawAmounts.reverse();
            if (fixedSide === "a")
              _fixedSide = "quote";
            else if (fixedSide === "b")
              _fixedSide = "base";
            else
              return logger11.throwArgumentError("invalid fixedSide", "fixedSide", fixedSide);
          } else if (sideA === "base") {
            if (fixedSide === "a")
              _fixedSide = "base";
            else if (fixedSide === "b")
              _fixedSide = "quote";
            else
              return logger11.throwArgumentError("invalid fixedSide", "fixedSide", fixedSide);
          } else
            return logger11.throwArgumentError("invalid fixedSide", "fixedSide", fixedSide);
          const [baseToken, quoteToken] = tokens;
          const [baseTokenAccount, quoteTokenAccount] = _tokenAccounts;
          const [baseAmountRaw, quoteAmountRaw] = rawAmounts;
          const frontInstructions = [];
          const endInstructions = [];
          const frontInstructionsType = [];
          const endInstructionsType = [];
          const signers = [];
          const _baseTokenAccount = yield this._handleTokenAccount({
            programId: import_spl_token2.TOKEN_PROGRAM_ID,
            connection,
            side: "in",
            amount: baseAmountRaw,
            mint: baseToken.mint,
            tokenAccount: baseTokenAccount,
            owner,
            payer,
            frontInstructions,
            endInstructions,
            signers,
            bypassAssociatedCheck,
            frontInstructionsType,
            endInstructionsType,
            checkCreateATAOwner
          });
          const _quoteTokenAccount = yield this._handleTokenAccount({
            programId: import_spl_token2.TOKEN_PROGRAM_ID,
            connection,
            side: "in",
            amount: quoteAmountRaw,
            mint: quoteToken.mint,
            tokenAccount: quoteTokenAccount,
            owner,
            payer,
            frontInstructions,
            endInstructions,
            signers,
            bypassAssociatedCheck,
            frontInstructionsType,
            endInstructionsType,
            checkCreateATAOwner
          });
          const _lpTokenAccount = yield this._handleTokenAccount({
            programId: import_spl_token2.TOKEN_PROGRAM_ID,
            connection,
            side: "out",
            amount: 0,
            mint: lpMint,
            tokenAccount: lpTokenAccount,
            owner,
            payer,
            frontInstructions,
            endInstructions,
            signers,
            bypassAssociatedCheck,
            frontInstructionsType,
            endInstructionsType,
            checkCreateATAOwner
          });
          const ins = this.makeAddLiquidityInstruction({
            poolKeys,
            userKeys: {
              baseTokenAccount: _baseTokenAccount,
              quoteTokenAccount: _quoteTokenAccount,
              lpTokenAccount: _lpTokenAccount,
              owner
            },
            baseAmountIn: baseAmountRaw,
            quoteAmountIn: quoteAmountRaw,
            fixedSide: _fixedSide
          });
          return {
            address: {
              lpTokenAccount: _lpTokenAccount
            },
            innerTransactions: yield splitTxAndSigners({
              connection,
              makeTxVersion,
              computeBudgetConfig,
              payer,
              innerTransaction: [
                { instructionTypes: frontInstructionsType, instructions: frontInstructions, signers },
                ins.innerTransaction,
                { instructionTypes: endInstructionsType, instructions: endInstructions, signers: [] }
              ],
              lookupTableCache
            })
          };
        });
      }
      static makeRemoveLiquidityInstruction(params) {
        const { poolKeys, userKeys, amountIn } = params;
        const { version: version2 } = poolKeys;
        if (version2 === 4 || version2 === 5) {
          const LAYOUT = struct3([u822("instruction"), u643("amountIn")]);
          const data = Buffer.alloc(LAYOUT.span);
          LAYOUT.encode(
            {
              instruction: 4,
              amountIn: parseBigNumberish2(amountIn)
            },
            data
          );
          const keys = [
            // system
            AccountMetaReadonly(import_spl_token2.TOKEN_PROGRAM_ID, false),
            // amm
            AccountMeta(poolKeys.id, false),
            AccountMetaReadonly(poolKeys.authority, false),
            AccountMeta(poolKeys.openOrders, false),
            AccountMeta(poolKeys.targetOrders, false),
            AccountMeta(poolKeys.lpMint, false),
            AccountMeta(poolKeys.baseVault, false),
            AccountMeta(poolKeys.quoteVault, false)
          ];
          if (version2 === 5) {
            keys.push(AccountMeta(ModelDataPubkey, false));
          } else {
            keys.push(AccountMeta(poolKeys.withdrawQueue, false));
            keys.push(AccountMeta(poolKeys.lpVault, false));
          }
          keys.push(
            // serum
            AccountMetaReadonly(poolKeys.marketProgramId, false),
            AccountMeta(poolKeys.marketId, false),
            AccountMeta(poolKeys.marketBaseVault, false),
            AccountMeta(poolKeys.marketQuoteVault, false),
            AccountMetaReadonly(poolKeys.marketAuthority, false),
            // user
            AccountMeta(userKeys.lpTokenAccount, false),
            AccountMeta(userKeys.baseTokenAccount, false),
            AccountMeta(userKeys.quoteTokenAccount, false),
            AccountMetaReadonly(userKeys.owner, true),
            // serum orderbook
            AccountMeta(poolKeys.marketEventQueue, false),
            AccountMeta(poolKeys.marketBids, false),
            AccountMeta(poolKeys.marketAsks, false)
          );
          return {
            address: {},
            innerTransaction: {
              instructions: [
                new import_web3222.TransactionInstruction({
                  programId: poolKeys.programId,
                  keys,
                  data
                })
              ],
              signers: [],
              lookupTableAddress: [poolKeys.lookupTableAccount].filter((i) => i && !i.equals(import_web3222.PublicKey.default)),
              instructionTypes: [
                version2 === 4 ? 23 : 31
                /* ammV5RemoveLiquidity */
              ]
            }
          };
        }
        return logger11.throwArgumentError("invalid version", "poolKeys.version", version2);
      }
      static makeRemoveLiquidityInstructionSimple(params) {
        return __async(this, null, function* () {
          const { connection, poolKeys, userKeys, amountIn, config: config2, makeTxVersion, lookupTableCache, computeBudgetConfig } = params;
          const { baseMint, quoteMint, lpMint } = poolKeys;
          const { tokenAccounts, owner, payer = owner } = userKeys;
          logger11.debug("amountIn:", amountIn);
          logger11.assertArgument(!amountIn.isZero(), "amount must greater than zero", "amountIn", amountIn.toFixed());
          logger11.assertArgument(
            amountIn instanceof TokenAmount3 && amountIn.token.mint.equals(lpMint),
            "amountIn's token not match lpMint",
            "amountIn",
            amountIn
          );
          const lpTokenAccount = this._selectTokenAccount({
            programId: import_spl_token2.TOKEN_PROGRAM_ID,
            tokenAccounts,
            mint: lpMint,
            owner,
            config: { associatedOnly: false }
          });
          if (!lpTokenAccount)
            return logger11.throwArgumentError("cannot found lpTokenAccount", "tokenAccounts", tokenAccounts);
          const baseTokenAccount = this._selectTokenAccount({
            programId: import_spl_token2.TOKEN_PROGRAM_ID,
            tokenAccounts,
            mint: baseMint,
            owner
          });
          const quoteTokenAccount = this._selectTokenAccount({
            programId: import_spl_token2.TOKEN_PROGRAM_ID,
            tokenAccounts,
            mint: quoteMint,
            owner
          });
          const { bypassAssociatedCheck, checkCreateATAOwner } = __spreadValues(__spreadValues({}, { bypassAssociatedCheck: false, checkCreateATAOwner: false }), config2);
          const frontInstructions = [];
          const endInstructions = [];
          const frontInstructionsType = [];
          const endInstructionsType = [];
          const signers = [];
          const _lpTokenAccount = lpTokenAccount;
          const _baseTokenAccount = yield this._handleTokenAccount({
            programId: import_spl_token2.TOKEN_PROGRAM_ID,
            connection,
            side: "out",
            amount: 0,
            mint: baseMint,
            tokenAccount: baseTokenAccount,
            owner,
            payer,
            frontInstructions,
            endInstructions,
            signers,
            bypassAssociatedCheck,
            frontInstructionsType,
            checkCreateATAOwner
          });
          const _quoteTokenAccount = yield this._handleTokenAccount({
            programId: import_spl_token2.TOKEN_PROGRAM_ID,
            connection,
            side: "out",
            amount: 0,
            mint: quoteMint,
            tokenAccount: quoteTokenAccount,
            owner,
            payer,
            frontInstructions,
            endInstructions,
            signers,
            bypassAssociatedCheck,
            frontInstructionsType,
            checkCreateATAOwner
          });
          const ins = this.makeRemoveLiquidityInstruction({
            poolKeys,
            userKeys: {
              lpTokenAccount: _lpTokenAccount,
              baseTokenAccount: _baseTokenAccount,
              quoteTokenAccount: _quoteTokenAccount,
              owner
            },
            amountIn: amountIn.raw
          });
          return {
            address: {
              lpTokenAccount: _lpTokenAccount
            },
            innerTransactions: yield splitTxAndSigners({
              connection,
              makeTxVersion,
              computeBudgetConfig,
              payer,
              innerTransaction: [
                { instructionTypes: frontInstructionsType, instructions: frontInstructions, signers },
                ins.innerTransaction,
                { instructionTypes: endInstructionsType, instructions: endInstructions, signers: [] }
              ],
              lookupTableCache
            })
          };
        });
      }
      static makeSwapInstruction(params) {
        const { poolKeys, userKeys, amountIn, amountOut, fixedSide } = params;
        const { version: version2 } = poolKeys;
        if (version2 === 4 || version2 === 5) {
          if (fixedSide === "in") {
            return this.makeSwapFixedInInstruction(
              {
                poolKeys,
                userKeys,
                amountIn,
                minAmountOut: amountOut
              },
              version2
            );
          } else if (fixedSide === "out") {
            return this.makeSwapFixedOutInstruction(
              {
                poolKeys,
                userKeys,
                maxAmountIn: amountIn,
                amountOut
              },
              version2
            );
          }
          return logger11.throwArgumentError("invalid params", "params", params);
        }
        return logger11.throwArgumentError("invalid version", "poolKeys.version", version2);
      }
      static makeSwapFixedInInstruction({ poolKeys, userKeys, amountIn, minAmountOut }, version2) {
        const LAYOUT = struct3([u822("instruction"), u643("amountIn"), u643("minAmountOut")]);
        const data = Buffer.alloc(LAYOUT.span);
        LAYOUT.encode(
          {
            instruction: 9,
            amountIn: parseBigNumberish2(amountIn),
            minAmountOut: parseBigNumberish2(minAmountOut)
          },
          data
        );
        const keys = [
          // system
          AccountMetaReadonly(import_spl_token2.TOKEN_PROGRAM_ID, false),
          // amm
          AccountMeta(poolKeys.id, false),
          AccountMetaReadonly(poolKeys.authority, false),
          AccountMeta(poolKeys.openOrders, false)
        ];
        if (version2 === 4) {
          keys.push(AccountMeta(poolKeys.targetOrders, false));
        }
        keys.push(AccountMeta(poolKeys.baseVault, false), AccountMeta(poolKeys.quoteVault, false));
        if (version2 === 5) {
          keys.push(AccountMeta(ModelDataPubkey, false));
        }
        keys.push(
          // serum
          AccountMetaReadonly(poolKeys.marketProgramId, false),
          AccountMeta(poolKeys.marketId, false),
          AccountMeta(poolKeys.marketBids, false),
          AccountMeta(poolKeys.marketAsks, false),
          AccountMeta(poolKeys.marketEventQueue, false),
          AccountMeta(poolKeys.marketBaseVault, false),
          AccountMeta(poolKeys.marketQuoteVault, false),
          AccountMetaReadonly(poolKeys.marketAuthority, false),
          // user
          AccountMeta(userKeys.tokenAccountIn, false),
          AccountMeta(userKeys.tokenAccountOut, false),
          AccountMetaReadonly(userKeys.owner, true)
        );
        return {
          address: {},
          innerTransaction: {
            instructions: [
              new import_web3222.TransactionInstruction({
                programId: poolKeys.programId,
                keys,
                data
              })
            ],
            signers: [],
            lookupTableAddress: [poolKeys.lookupTableAccount].filter((i) => i && !i.equals(import_web3222.PublicKey.default)),
            instructionTypes: [
              version2 === 4 ? 25 : 33
              /* ammV5SwapBaseIn */
            ]
          }
        };
      }
      static makeSwapFixedOutInstruction({ poolKeys, userKeys, maxAmountIn, amountOut }, version2) {
        const LAYOUT = struct3([u822("instruction"), u643("maxAmountIn"), u643("amountOut")]);
        const data = Buffer.alloc(LAYOUT.span);
        LAYOUT.encode(
          {
            instruction: 11,
            maxAmountIn: parseBigNumberish2(maxAmountIn),
            amountOut: parseBigNumberish2(amountOut)
          },
          data
        );
        const keys = [
          // system
          AccountMetaReadonly(import_spl_token2.TOKEN_PROGRAM_ID, false),
          // amm
          AccountMeta(poolKeys.id, false),
          AccountMetaReadonly(poolKeys.authority, false),
          AccountMeta(poolKeys.openOrders, false),
          AccountMeta(poolKeys.targetOrders, false),
          AccountMeta(poolKeys.baseVault, false),
          AccountMeta(poolKeys.quoteVault, false)
        ];
        if (version2 === 5) {
          keys.push(AccountMeta(ModelDataPubkey, false));
        }
        keys.push(
          // serum
          AccountMetaReadonly(poolKeys.marketProgramId, false),
          AccountMeta(poolKeys.marketId, false),
          AccountMeta(poolKeys.marketBids, false),
          AccountMeta(poolKeys.marketAsks, false),
          AccountMeta(poolKeys.marketEventQueue, false),
          AccountMeta(poolKeys.marketBaseVault, false),
          AccountMeta(poolKeys.marketQuoteVault, false),
          AccountMetaReadonly(poolKeys.marketAuthority, false),
          // user
          AccountMeta(userKeys.tokenAccountIn, false),
          AccountMeta(userKeys.tokenAccountOut, false),
          AccountMetaReadonly(userKeys.owner, true)
        );
        return {
          address: {},
          innerTransaction: {
            instructions: [
              new import_web3222.TransactionInstruction({
                programId: poolKeys.programId,
                keys,
                data
              })
            ],
            signers: [],
            lookupTableAddress: [poolKeys.lookupTableAccount].filter((i) => i && !i.equals(import_web3222.PublicKey.default)),
            instructionTypes: [
              version2 === 4 ? 26 : 34
              /* ammV5SwapBaseOut */
            ]
          }
        };
      }
      static makeSwapInstructionSimple(params) {
        return __async(this, null, function* () {
          const {
            connection,
            poolKeys,
            userKeys,
            amountIn,
            amountOut,
            fixedSide,
            config: config2,
            makeTxVersion,
            lookupTableCache,
            computeBudgetConfig
          } = params;
          const { tokenAccounts, owner, payer = owner } = userKeys;
          logger11.debug("amountIn:", amountIn);
          logger11.debug("amountOut:", amountOut);
          logger11.assertArgument(
            !amountIn.isZero() && !amountOut.isZero(),
            "amounts must greater than zero",
            "currencyAmounts",
            {
              amountIn: amountIn.toFixed(),
              amountOut: amountOut.toFixed()
            }
          );
          const { bypassAssociatedCheck, checkCreateATAOwner } = __spreadValues(__spreadValues({}, { bypassAssociatedCheck: false, checkCreateATAOwner: false }), config2);
          const tokenIn = amountIn instanceof TokenAmount3 ? amountIn.token : Token3.WSOL;
          const tokenOut = amountOut instanceof TokenAmount3 ? amountOut.token : Token3.WSOL;
          const tokenAccountIn = this._selectTokenAccount({
            programId: import_spl_token2.TOKEN_PROGRAM_ID,
            tokenAccounts,
            mint: tokenIn.mint,
            owner,
            config: { associatedOnly: false }
          });
          const tokenAccountOut = this._selectTokenAccount({
            programId: import_spl_token2.TOKEN_PROGRAM_ID,
            tokenAccounts,
            mint: tokenOut.mint,
            owner
          });
          const [amountInRaw, amountOutRaw] = [amountIn.raw, amountOut.raw];
          const frontInstructions = [];
          const endInstructions = [];
          const frontInstructionsType = [];
          const endInstructionsType = [];
          const signers = [];
          const _tokenAccountIn = yield this._handleTokenAccount({
            programId: import_spl_token2.TOKEN_PROGRAM_ID,
            connection,
            side: "in",
            amount: amountInRaw,
            mint: tokenIn.mint,
            tokenAccount: tokenAccountIn,
            owner,
            payer,
            frontInstructions,
            endInstructions,
            signers,
            bypassAssociatedCheck,
            frontInstructionsType,
            checkCreateATAOwner
          });
          const _tokenAccountOut = yield this._handleTokenAccount({
            programId: import_spl_token2.TOKEN_PROGRAM_ID,
            connection,
            side: "out",
            amount: 0,
            mint: tokenOut.mint,
            tokenAccount: tokenAccountOut,
            owner,
            payer,
            frontInstructions,
            endInstructions,
            signers,
            bypassAssociatedCheck,
            frontInstructionsType,
            checkCreateATAOwner
          });
          const ins = this.makeSwapInstruction({
            poolKeys,
            userKeys: {
              tokenAccountIn: _tokenAccountIn,
              tokenAccountOut: _tokenAccountOut,
              owner
            },
            amountIn: amountInRaw,
            amountOut: amountOutRaw,
            fixedSide
          });
          return {
            address: {},
            innerTransactions: yield splitTxAndSigners({
              connection,
              makeTxVersion,
              computeBudgetConfig,
              payer,
              innerTransaction: [
                { instructionTypes: frontInstructionsType, instructions: frontInstructions, signers },
                ins.innerTransaction,
                { instructionTypes: endInstructionsType, instructions: endInstructions, signers: [] }
              ],
              lookupTableCache
            })
          };
        });
      }
      static makeSimulatePoolInfoInstruction({ poolKeys }) {
        const LAYOUT = struct3([u822("instruction"), u822("simulateType")]);
        const data = Buffer.alloc(LAYOUT.span);
        LAYOUT.encode(
          {
            instruction: 12,
            simulateType: 0
          },
          data
        );
        const keys = [
          // amm
          AccountMetaReadonly(poolKeys.id, false),
          AccountMetaReadonly(poolKeys.authority, false),
          AccountMetaReadonly(poolKeys.openOrders, false),
          AccountMetaReadonly(poolKeys.baseVault, false),
          AccountMetaReadonly(poolKeys.quoteVault, false),
          AccountMetaReadonly(poolKeys.lpMint, false),
          // serum
          AccountMetaReadonly(poolKeys.marketId, false),
          AccountMetaReadonly(poolKeys.marketEventQueue, false)
        ];
        return {
          address: {},
          innerTransaction: {
            instructions: [
              new import_web3222.TransactionInstruction({
                programId: poolKeys.programId,
                keys,
                data
              })
            ],
            signers: [],
            lookupTableAddress: [poolKeys.lookupTableAccount].filter((i) => i && !i.equals(import_web3222.PublicKey.default)),
            instructionTypes: [
              poolKeys.version === 4 ? 24 : 32
              /* ammV5SimulatePoolInfo */
            ]
          }
        };
      }
      static isV4(lsl) {
        return lsl.withdrawQueue !== void 0;
      }
      static makeCreatePoolV4InstructionV2Simple(_0) {
        return __async(this, arguments, function* ({
          connection,
          programId,
          marketInfo,
          baseMintInfo,
          quoteMintInfo,
          baseAmount,
          quoteAmount,
          startTime,
          ownerInfo,
          associatedOnly = false,
          computeBudgetConfig,
          checkCreateATAOwner = false,
          makeTxVersion,
          lookupTableCache,
          feeDestinationId
        }) {
          const frontInstructions = [];
          const endInstructions = [];
          const frontInstructionsType = [];
          const endInstructionsType = [];
          const signers = [];
          const mintAUseSOLBalance = ownerInfo.useSOLBalance && baseMintInfo.mint.equals(Token3.WSOL.mint);
          const mintBUseSOLBalance = ownerInfo.useSOLBalance && quoteMintInfo.mint.equals(Token3.WSOL.mint);
          const ownerTokenAccountBase = yield this._selectOrCreateTokenAccount({
            programId: import_spl_token2.TOKEN_PROGRAM_ID,
            mint: baseMintInfo.mint,
            tokenAccounts: mintAUseSOLBalance ? [] : ownerInfo.tokenAccounts,
            owner: ownerInfo.wallet,
            createInfo: mintAUseSOLBalance ? {
              connection,
              payer: ownerInfo.feePayer,
              amount: baseAmount,
              frontInstructions,
              frontInstructionsType,
              endInstructions: mintAUseSOLBalance ? endInstructions : [],
              endInstructionsType: mintAUseSOLBalance ? endInstructionsType : [],
              signers
            } : void 0,
            associatedOnly: mintAUseSOLBalance ? false : associatedOnly,
            checkCreateATAOwner
          });
          const ownerTokenAccountQuote = yield this._selectOrCreateTokenAccount({
            programId: import_spl_token2.TOKEN_PROGRAM_ID,
            mint: quoteMintInfo.mint,
            tokenAccounts: mintBUseSOLBalance ? [] : ownerInfo.tokenAccounts,
            owner: ownerInfo.wallet,
            createInfo: mintBUseSOLBalance ? {
              connection,
              payer: ownerInfo.feePayer,
              amount: quoteAmount,
              frontInstructions,
              frontInstructionsType,
              endInstructions: mintBUseSOLBalance ? endInstructions : [],
              endInstructionsType: mintBUseSOLBalance ? endInstructionsType : [],
              signers
            } : void 0,
            associatedOnly: mintBUseSOLBalance ? false : associatedOnly,
            checkCreateATAOwner
          });
          if (ownerTokenAccountBase === void 0 || ownerTokenAccountQuote === void 0)
            throw Error("you don't has some token account");
          const poolInfo = _Liquidity2.getAssociatedPoolKeys({
            version: 4,
            marketVersion: 3,
            marketId: marketInfo.marketId,
            baseMint: baseMintInfo.mint,
            quoteMint: quoteMintInfo.mint,
            baseDecimals: baseMintInfo.decimals,
            quoteDecimals: quoteMintInfo.decimals,
            programId,
            marketProgramId: marketInfo.programId
          });
          const ins = this.makeCreatePoolV4InstructionV2({
            programId,
            ammId: poolInfo.id,
            ammAuthority: poolInfo.authority,
            ammOpenOrders: poolInfo.openOrders,
            lpMint: poolInfo.lpMint,
            coinMint: poolInfo.baseMint,
            pcMint: poolInfo.quoteMint,
            coinVault: poolInfo.baseVault,
            pcVault: poolInfo.quoteVault,
            ammTargetOrders: poolInfo.targetOrders,
            marketProgramId: poolInfo.marketProgramId,
            marketId: poolInfo.marketId,
            userWallet: ownerInfo.wallet,
            userCoinVault: ownerTokenAccountBase,
            userPcVault: ownerTokenAccountQuote,
            userLpVault: getATAAddress2(ownerInfo.wallet, poolInfo.lpMint, import_spl_token2.TOKEN_PROGRAM_ID).publicKey,
            ammConfigId: poolInfo.configId,
            feeDestinationId,
            nonce: poolInfo.nonce,
            openTime: startTime,
            coinAmount: baseAmount,
            pcAmount: quoteAmount
          }).innerTransaction;
          return {
            address: {
              programId,
              ammId: poolInfo.id,
              ammAuthority: poolInfo.authority,
              ammOpenOrders: poolInfo.openOrders,
              lpMint: poolInfo.lpMint,
              coinMint: poolInfo.baseMint,
              pcMint: poolInfo.quoteMint,
              coinVault: poolInfo.baseVault,
              pcVault: poolInfo.quoteVault,
              withdrawQueue: poolInfo.withdrawQueue,
              ammTargetOrders: poolInfo.targetOrders,
              poolTempLp: poolInfo.lpVault,
              marketProgramId: poolInfo.marketProgramId,
              marketId: poolInfo.marketId
            },
            innerTransactions: yield splitTxAndSigners({
              connection,
              makeTxVersion,
              computeBudgetConfig,
              payer: ownerInfo.feePayer,
              innerTransaction: [
                { instructionTypes: frontInstructionsType, instructions: frontInstructions, signers },
                ins,
                { instructionTypes: endInstructionsType, instructions: endInstructions, signers: [] }
              ],
              lookupTableCache
            })
          };
        });
      }
      static makeCreatePoolV4InstructionV2({
        programId,
        ammId,
        ammAuthority,
        ammOpenOrders,
        lpMint,
        coinMint,
        pcMint,
        coinVault,
        pcVault,
        ammTargetOrders,
        marketProgramId,
        marketId,
        userWallet,
        userCoinVault,
        userPcVault,
        userLpVault,
        nonce,
        openTime,
        coinAmount,
        pcAmount,
        lookupTableAddress,
        ammConfigId,
        feeDestinationId
      }) {
        const dataLayout = struct3([u822("instruction"), u822("nonce"), u643("openTime"), u643("pcAmount"), u643("coinAmount")]);
        const keys = [
          { pubkey: import_spl_token2.TOKEN_PROGRAM_ID, isSigner: false, isWritable: false },
          { pubkey: import_spl_token2.ASSOCIATED_TOKEN_PROGRAM_ID, isSigner: false, isWritable: false },
          { pubkey: SYSTEM_PROGRAM_ID2, isSigner: false, isWritable: false },
          { pubkey: RENT_PROGRAM_ID2, isSigner: false, isWritable: false },
          { pubkey: ammId, isSigner: false, isWritable: true },
          { pubkey: ammAuthority, isSigner: false, isWritable: false },
          { pubkey: ammOpenOrders, isSigner: false, isWritable: true },
          { pubkey: lpMint, isSigner: false, isWritable: true },
          { pubkey: coinMint, isSigner: false, isWritable: false },
          { pubkey: pcMint, isSigner: false, isWritable: false },
          { pubkey: coinVault, isSigner: false, isWritable: true },
          { pubkey: pcVault, isSigner: false, isWritable: true },
          { pubkey: ammTargetOrders, isSigner: false, isWritable: true },
          { pubkey: ammConfigId, isSigner: false, isWritable: false },
          { pubkey: feeDestinationId, isSigner: false, isWritable: true },
          { pubkey: marketProgramId, isSigner: false, isWritable: false },
          { pubkey: marketId, isSigner: false, isWritable: false },
          { pubkey: userWallet, isSigner: true, isWritable: true },
          { pubkey: userCoinVault, isSigner: false, isWritable: true },
          { pubkey: userPcVault, isSigner: false, isWritable: true },
          { pubkey: userLpVault, isSigner: false, isWritable: true }
        ];
        const data = Buffer.alloc(dataLayout.span);
        dataLayout.encode({ instruction: 1, nonce, openTime, coinAmount, pcAmount }, data);
        const ins = new import_web3222.TransactionInstruction({
          keys,
          programId,
          data
        });
        return {
          address: {},
          innerTransaction: {
            instructions: [ins],
            signers: [],
            lookupTableAddress: lookupTableAddress ? [lookupTableAddress] : void 0,
            instructionTypes: [
              29
              /* ammV4CreatePoolV2 */
            ]
          }
        };
      }
      static makeRemoveAllLpAndCreateClmmPosition(_0) {
        return __async(this, arguments, function* ({
          connection,
          poolKeys,
          removeLpAmount,
          userKeys,
          clmmPoolKeys,
          createPositionInfo,
          farmInfo,
          computeBudgetConfig,
          checkCreateATAOwner = false,
          getEphemeralSigners,
          makeTxVersion,
          lookupTableCache
        }) {
          var _a, _b, _c, _d, _e, _f, _g;
          if (!(poolKeys.baseMint.equals(clmmPoolKeys.mintA.mint) || poolKeys.baseMint.equals(clmmPoolKeys.mintB.mint)))
            throw Error("mint check error");
          if (!(poolKeys.quoteMint.equals(clmmPoolKeys.mintA.mint) || poolKeys.quoteMint.equals(clmmPoolKeys.mintB.mint)))
            throw Error("mint check error");
          const frontInstructions = [];
          const endInstructions = [];
          const frontInstructionsType = [];
          const endInstructionsType = [];
          const signers = [];
          const mintToAccount = {};
          for (const item of userKeys.tokenAccounts) {
            if (mintToAccount[item.accountInfo.mint.toString()] === void 0 || getATAAddress2(userKeys.owner, item.accountInfo.mint, import_spl_token2.TOKEN_PROGRAM_ID).publicKey.equals(item.pubkey)) {
              mintToAccount[item.accountInfo.mint.toString()] = item.pubkey;
            }
          }
          const lpTokenAccount = mintToAccount[poolKeys.lpMint.toString()];
          if (lpTokenAccount === void 0)
            throw Error("find lp account error in trade accounts");
          const amountIn = removeLpAmount.add((_a = farmInfo == null ? void 0 : farmInfo.amount) != null ? _a : new import_bn16.default(0));
          const mintBaseUseSOLBalance = poolKeys.baseMint.equals(Token3.WSOL.mint);
          const mintQuoteUseSOLBalance = poolKeys.quoteMint.equals(Token3.WSOL.mint);
          const baseTokenAccount = yield this._selectOrCreateTokenAccount({
            programId: import_spl_token2.TOKEN_PROGRAM_ID,
            mint: poolKeys.baseMint,
            tokenAccounts: userKeys.tokenAccounts,
            owner: userKeys.owner,
            createInfo: {
              connection,
              payer: (_b = userKeys.payer) != null ? _b : userKeys.owner,
              frontInstructions,
              frontInstructionsType,
              endInstructions: mintBaseUseSOLBalance ? endInstructions : [],
              endInstructionsType: mintBaseUseSOLBalance ? endInstructionsType : [],
              signers
            },
            associatedOnly: true,
            checkCreateATAOwner
          });
          const quoteTokenAccount = yield this._selectOrCreateTokenAccount({
            programId: import_spl_token2.TOKEN_PROGRAM_ID,
            mint: poolKeys.quoteMint,
            tokenAccounts: userKeys.tokenAccounts,
            owner: userKeys.owner,
            createInfo: {
              connection,
              payer: (_c = userKeys.payer) != null ? _c : userKeys.owner,
              amount: 0,
              frontInstructions,
              frontInstructionsType,
              endInstructions: mintQuoteUseSOLBalance ? endInstructions : [],
              endInstructionsType: mintQuoteUseSOLBalance ? endInstructionsType : [],
              signers
            },
            associatedOnly: true,
            checkCreateATAOwner
          });
          mintToAccount[poolKeys.baseMint.toString()] = baseTokenAccount;
          mintToAccount[poolKeys.quoteMint.toString()] = quoteTokenAccount;
          const removeIns = this.makeRemoveLiquidityInstruction({
            poolKeys,
            userKeys: {
              lpTokenAccount,
              baseTokenAccount,
              quoteTokenAccount,
              owner: userKeys.owner
            },
            amountIn
          });
          const [tokenAccountA, tokenAccountB] = poolKeys.baseMint.equals(clmmPoolKeys.mintA.mint) ? [baseTokenAccount, quoteTokenAccount] : [quoteTokenAccount, baseTokenAccount];
          const createPositionIns = yield Clmm2.makeOpenPositionFromLiquidityInstructions(__spreadProps(__spreadValues({
            poolInfo: clmmPoolKeys,
            ownerInfo: {
              feePayer: (_d = userKeys.payer) != null ? _d : userKeys.owner,
              wallet: userKeys.owner,
              tokenAccountA,
              tokenAccountB
            },
            withMetadata: "create"
          }, createPositionInfo), {
            getEphemeralSigners
          }));
          let withdrawFarmIns = {
            instructions: [],
            signers: [],
            instructionTypes: []
          };
          if (farmInfo !== void 0) {
            const rewardTokenAccounts = [];
            for (const item of farmInfo.poolKeys.rewardInfos) {
              const rewardIsWsol = item.rewardMint.equals(Token3.WSOL.mint);
              rewardTokenAccounts.push(
                (_f = mintToAccount[item.rewardMint.toString()]) != null ? _f : yield this._selectOrCreateTokenAccount({
                  programId: import_spl_token2.TOKEN_PROGRAM_ID,
                  mint: item.rewardMint,
                  tokenAccounts: userKeys.tokenAccounts,
                  owner: userKeys.owner,
                  createInfo: {
                    connection,
                    payer: (_e = userKeys.payer) != null ? _e : userKeys.owner,
                    frontInstructions,
                    frontInstructionsType,
                    endInstructions: rewardIsWsol ? endInstructions : [],
                    endInstructionsType: rewardIsWsol ? endInstructionsType : [],
                    signers
                  },
                  associatedOnly: true,
                  checkCreateATAOwner
                })
              );
            }
            withdrawFarmIns = Farm.makeWithdrawInstruction({
              poolKeys: farmInfo.poolKeys,
              amount: farmInfo.amount,
              userKeys: {
                ledger: Farm.getAssociatedLedgerAccount({
                  programId: farmInfo.poolKeys.programId,
                  poolId: farmInfo.poolKeys.id,
                  owner: userKeys.owner,
                  version: farmInfo.poolKeys.version
                }),
                lpTokenAccount,
                rewardTokenAccounts,
                owner: userKeys.owner
              }
            }).innerTransaction;
          }
          return {
            address: __spreadValues(__spreadValues({}, removeIns.address), createPositionIns.address),
            innerTransactions: yield splitTxAndSigners({
              connection,
              makeTxVersion,
              computeBudgetConfig,
              payer: (_g = userKeys.payer) != null ? _g : userKeys.owner,
              innerTransaction: [
                { instructionTypes: frontInstructionsType, instructions: frontInstructions, signers },
                withdrawFarmIns,
                removeIns.innerTransaction,
                createPositionIns.innerTransaction,
                { instructionTypes: endInstructionsType, instructions: endInstructions, signers: [] }
              ],
              lookupTableCache
            })
          };
        });
      }
      /* ================= fetch data ================= */
      /**
       * Fetch all pools keys from on-chain data
       */
      static fetchAllPoolKeys(connection, programId, config2) {
        return __async(this, null, function* () {
          const allPools = (yield Promise.all(
            Object.entries(LIQUIDITY_VERSION_TO_STATE_LAYOUT2).map(([version2, layout]) => {
              try {
                return connection.getProgramAccounts(programId[Number(version2)], {
                  filters: [{ dataSize: layout.span }]
                }).then((accounts) => {
                  return accounts.map((info) => {
                    return __spreadValues({
                      id: info.pubkey,
                      version: Number(version2),
                      programId: programId[Number(version2)]
                    }, layout.decode(info.account.data));
                  });
                });
              } catch (error) {
                if (error instanceof Error) {
                  return logger11.throwError("failed to fetch pool info", Logger2.errors.RPC_ERROR, {
                    message: error.message
                  });
                }
              }
            })
          )).flat();
          const allMarketIds = allPools.map((i) => i.marketId);
          const marketsInfo = {};
          try {
            const _marketsInfo = yield getMultipleAccountsInfo2(connection, allMarketIds, config2);
            for (const item of _marketsInfo) {
              if (item === null)
                continue;
              const _i = __spreadValues({ programId: item.owner }, MARKET_STATE_LAYOUT_V32.decode(item.data));
              marketsInfo[_i.ownAddress.toString()] = _i;
            }
          } catch (error) {
            if (error instanceof Error) {
              return logger11.throwError("failed to fetch markets", Logger2.errors.RPC_ERROR, {
                message: error.message
              });
            }
          }
          const authority = {};
          for (const [version2, _programId] of Object.entries(programId))
            authority[version2] = this.getAssociatedAuthority({ programId: _programId }).publicKey;
          const formatPoolInfos = [];
          for (const pool of allPools) {
            if (pool === void 0)
              continue;
            if (pool.baseMint.equals(import_web3222.PublicKey.default))
              continue;
            const market = marketsInfo[pool.marketId.toString()];
            const marketProgramId = market.programId;
            formatPoolInfos.push(__spreadProps(__spreadValues({
              id: pool.id,
              baseMint: pool.baseMint,
              quoteMint: pool.quoteMint,
              lpMint: pool.lpMint,
              baseDecimals: pool.baseDecimal.toNumber(),
              quoteDecimals: pool.quoteDecimal.toNumber(),
              lpDecimals: pool.id.toString() === "6kmMMacvoCKBkBrqssLEdFuEZu2wqtLdNQxh9VjtzfwT" ? 5 : pool.baseDecimal.toNumber(),
              version: pool.version,
              programId: pool.programId,
              authority: authority[pool.version],
              openOrders: pool.openOrders,
              targetOrders: pool.targetOrders,
              baseVault: pool.baseVault,
              quoteVault: pool.quoteVault,
              marketVersion: 3,
              marketProgramId,
              marketId: market.ownAddress,
              marketAuthority: Market2.getAssociatedAuthority({
                programId: marketProgramId,
                marketId: market.ownAddress
              }).publicKey,
              marketBaseVault: market.baseVault,
              marketQuoteVault: market.quoteVault,
              marketBids: market.bids,
              marketAsks: market.asks,
              marketEventQueue: market.eventQueue
            }, pool.version === 5 ? {
              modelDataAccount: pool.modelDataAccount,
              withdrawQueue: import_web3222.PublicKey.default,
              lpVault: import_web3222.PublicKey.default
            } : {
              withdrawQueue: pool.withdrawQueue,
              lpVault: pool.lpVault
            }), {
              lookupTableAccount: import_web3222.PublicKey.default
            }));
          }
          return formatPoolInfos;
        });
      }
      /**
       * Fetch liquidity pool's info
       */
      static fetchInfo(_0) {
        return __async(this, arguments, function* ({ connection, poolKeys }) {
          const info = yield this.fetchMultipleInfo({ connection, pools: [poolKeys] });
          logger11.assertArgument(info.length === 1, `fetchInfo failed, ${info.length} pools found`, "poolKeys.id", poolKeys.id);
          return info[0];
        });
      }
      /**
       * Fetch multiple info of liquidity pools
       */
      static fetchMultipleInfo(_0) {
        return __async(this, arguments, function* ({
          connection,
          pools,
          // eslint-disable-next-line @typescript-eslint/no-unused-vars
          config: config2
        }) {
          yield initStableModelLayout(connection);
          const instructions = pools.map((pool) => this.makeSimulatePoolInfoInstruction({ poolKeys: pool }));
          const logs = yield simulateMultipleInstruction2(
            connection,
            instructions.map((i) => i.innerTransaction.instructions).flat(),
            "GetPoolData"
          );
          const poolsInfo = logs.map((log3) => {
            const json = parseSimulateLogToJson2(log3, "GetPoolData");
            const status = new import_bn16.default(parseSimulateValue2(json, "status"));
            const baseDecimals = Number(parseSimulateValue2(json, "coin_decimals"));
            const quoteDecimals = Number(parseSimulateValue2(json, "pc_decimals"));
            const lpDecimals = Number(parseSimulateValue2(json, "lp_decimals"));
            const baseReserve = new import_bn16.default(parseSimulateValue2(json, "pool_coin_amount"));
            const quoteReserve = new import_bn16.default(parseSimulateValue2(json, "pool_pc_amount"));
            const lpSupply = new import_bn16.default(parseSimulateValue2(json, "pool_lp_supply"));
            let startTime = "0";
            try {
              startTime = parseSimulateValue2(json, "pool_open_time");
            } catch (error) {
            }
            return {
              status,
              baseDecimals,
              quoteDecimals,
              lpDecimals,
              baseReserve,
              quoteReserve,
              lpSupply,
              startTime: new import_bn16.default(startTime)
            };
          });
          return poolsInfo;
        });
      }
      /* ================= compute data ================= */
      static getEnabledFeatures(poolInfo) {
        const { status } = poolInfo;
        const _status = status.toNumber();
        if (_status === 0)
          return {
            swap: false,
            addLiquidity: false,
            removeLiquidity: false
          };
        else if (_status === 1)
          return {
            swap: true,
            addLiquidity: true,
            removeLiquidity: true
          };
        else if (_status === 2)
          return {
            swap: false,
            addLiquidity: false,
            removeLiquidity: false
          };
        else if (_status === 3)
          return {
            swap: false,
            addLiquidity: false,
            removeLiquidity: true
          };
        else if (_status === 4)
          return {
            swap: false,
            addLiquidity: true,
            removeLiquidity: true
          };
        else if (_status === 5)
          return {
            swap: false,
            addLiquidity: true,
            removeLiquidity: true
          };
        else if (_status === 6)
          return {
            swap: true,
            addLiquidity: true,
            removeLiquidity: true
          };
        else if (_status === 7) {
          const { startTime } = poolInfo;
          if (Date.now() / 1e3 < startTime.toNumber())
            return {
              swap: false,
              addLiquidity: true,
              removeLiquidity: true
            };
          return {
            swap: true,
            addLiquidity: true,
            removeLiquidity: true
          };
        } else
          return {
            swap: false,
            addLiquidity: false,
            removeLiquidity: false
          };
      }
      static includesToken(token, poolKeys) {
        const { baseMint, quoteMint } = poolKeys;
        return token.mint.equals(baseMint) || token.mint.equals(quoteMint);
      }
      /**
       * Get token side of liquidity pool
       * @param token - the token provided
       * @param poolKeys - the pool keys
       * @returns token side is `base` or `quote`
       */
      static _getTokenSide(token, poolKeys) {
        const { baseMint, quoteMint } = poolKeys;
        if (token.mint.equals(baseMint))
          return "base";
        else if (token.mint.equals(quoteMint))
          return "quote";
        else
          return logger11.throwArgumentError("token not match with pool", "params", {
            token: token.mint,
            baseMint,
            quoteMint
          });
      }
      /**
       * Get tokens side of liquidity pool
       * @param tokenA - the token provided
       * @param tokenB - the token provided
       * @param poolKeys - the pool keys
       * @returns tokens side array
       */
      static _getTokensSide(tokenA, tokenB, poolKeys) {
        const { baseMint, quoteMint } = poolKeys;
        const sideA = this._getTokenSide(tokenA, poolKeys);
        const sideB = this._getTokenSide(tokenB, poolKeys);
        logger11.assertArgument(sideA !== sideB, "tokens not match with pool", "params", {
          tokenA: tokenA.mint,
          tokenB: tokenB.mint,
          baseMint,
          quoteMint
        });
        return [sideA, sideB];
      }
      /**
       * Get currency amount side of liquidity pool
       * @param amount - the currency amount provided
       * @param poolKeys - the pool keys
       * @returns currency amount side is `base` or `quote`
       */
      static _getAmountSide(amount, poolKeys) {
        const token = amount instanceof TokenAmount3 ? amount.token : Token3.WSOL;
        return this._getTokenSide(token, poolKeys);
      }
      /**
       * Get currencies amount side of liquidity pool
       * @param amountA - the currency amount provided
       * @param amountB - the currency amount provided
       * @param poolKeys - the pool keys
       * @returns currencies amount side array
       */
      static _getAmountsSide(amountA, amountB, poolKeys) {
        const tokenA = amountA instanceof TokenAmount3 ? amountA.token : Token3.WSOL;
        const tokenB = amountB instanceof TokenAmount3 ? amountB.token : Token3.WSOL;
        return this._getTokensSide(tokenA, tokenB, poolKeys);
      }
      /**
       * Compute the another currency amount of add liquidity
       *
       * @param params - {@link LiquidityComputeAnotherAmountParams}
       *
       * @returns
       * anotherCurrencyAmount - currency amount without slippage
       * @returns
       * maxAnotherCurrencyAmount - currency amount with slippage
       *
       * @returns {@link CurrencyAmount}
       *
       * @example
       * ```
       * Liquidity.computeAnotherAmount({
       *   // 1%
       *   slippage: new Percent(1, 100)
       * })
       * ```
       */
      static computeAnotherAmount({
        poolKeys,
        poolInfo,
        amount,
        anotherCurrency,
        slippage
      }) {
        const { baseReserve, quoteReserve } = poolInfo;
        logger11.debug("baseReserve:", baseReserve.toString());
        logger11.debug("quoteReserve:", quoteReserve.toString());
        const currencyIn = amount instanceof TokenAmount3 ? amount.token : amount.currency;
        logger11.debug("currencyIn:", currencyIn);
        logger11.debug("amount:", amount.toFixed());
        logger11.debug("anotherCurrency:", anotherCurrency);
        logger11.debug("slippage:", `${slippage.toSignificant()}%`);
        const input = this._getAmountSide(amount, poolKeys);
        logger11.debug("input side:", input);
        let amountRaw = ZERO2;
        if (!amount.isZero()) {
          amountRaw = input === "base" ? divCeil2(amount.raw.mul(quoteReserve), baseReserve) : divCeil2(amount.raw.mul(baseReserve), quoteReserve);
        }
        const liquidity = divCeil2(
          amount.raw.mul(poolInfo.lpSupply),
          input === "base" ? poolInfo.baseReserve : poolInfo.quoteReserve
        );
        const _slippage = new Percent3(ONE2).add(slippage);
        const slippageAdjustedAmount = _slippage.mul(amountRaw).quotient;
        const _anotherAmount = anotherCurrency instanceof Token3 ? new TokenAmount3(anotherCurrency, amountRaw) : new CurrencyAmount2(anotherCurrency, amountRaw);
        const _maxAnotherAmount = anotherCurrency instanceof Token3 ? new TokenAmount3(anotherCurrency, slippageAdjustedAmount) : new CurrencyAmount2(anotherCurrency, slippageAdjustedAmount);
        logger11.debug("anotheAmount:", _anotherAmount.toFixed());
        logger11.debug("maxAnotheAmount:", _maxAnotherAmount.toFixed());
        return {
          anotherAmount: _anotherAmount,
          maxAnotherAmount: _maxAnotherAmount,
          liquidity
        };
      }
      static _computePriceImpact(currentPrice, amountIn, amountOut) {
        const exactQuote = currentPrice.raw.mul(amountIn);
        const slippage = exactQuote.sub(amountOut).div(exactQuote);
        return new Percent3(slippage.numerator, slippage.denominator);
      }
      static getRate(poolInfo) {
        const { baseReserve, quoteReserve, baseDecimals, quoteDecimals } = poolInfo;
        const price = new Price2(new Currency2(baseDecimals), baseReserve, new Currency2(quoteDecimals), quoteReserve);
        return price;
      }
      /**
       * Compute input currency amount of swap
       *
       * @param params - {@link ComputeCurrencyAmountInParams}
       *
       * @returns
       * amountIn - currency amount without slippage
       * @returns
       * maxAmountIn - currency amount with slippage
       */
      static computeAmountIn({ poolKeys, poolInfo, amountOut, currencyIn, slippage }) {
        const { baseReserve, quoteReserve } = poolInfo;
        logger11.debug("baseReserve:", baseReserve.toString());
        logger11.debug("quoteReserve:", quoteReserve.toString());
        const currencyOut = amountOut instanceof TokenAmount3 ? amountOut.token : amountOut.currency;
        logger11.debug("currencyOut:", currencyOut);
        logger11.debug("amountOut:", amountOut.toFixed());
        logger11.debug("currencyIn:", currencyIn);
        logger11.debug("slippage:", `${slippage.toSignificant()}%`);
        const reserves = [baseReserve, quoteReserve];
        const output2 = this._getAmountSide(amountOut, poolKeys);
        if (output2 === "base") {
          reserves.reverse();
        }
        logger11.debug("output side:", output2);
        const [reserveIn, reserveOut] = reserves;
        const currentPrice = new Price2(currencyIn, reserveIn, currencyOut, reserveOut);
        logger11.debug("currentPrice:", `1 ${currencyIn.symbol} \u2248 ${currentPrice.toFixed()} ${currencyOut.symbol}`);
        logger11.debug(
          "currentPrice invert:",
          `1 ${currencyOut.symbol} \u2248 ${currentPrice.invert().toFixed()} ${currencyIn.symbol}`
        );
        let amountInRaw = ZERO2;
        let amountOutRaw = amountOut.raw;
        if (!amountOutRaw.isZero()) {
          if (amountOutRaw.gt(reserveOut)) {
            amountOutRaw = reserveOut.sub(ONE2);
          }
          const denominator = reserveOut.sub(amountOutRaw);
          const amountInWithoutFee = reserveIn.mul(amountOutRaw).div(denominator);
          amountInRaw = amountInWithoutFee.mul(LIQUIDITY_FEES_DENOMINATOR2).div(LIQUIDITY_FEES_DENOMINATOR2.sub(LIQUIDITY_FEES_NUMERATOR2));
        }
        const _slippage = new Percent3(ONE2).add(slippage);
        const maxAmountInRaw = _slippage.mul(amountInRaw).quotient;
        const amountIn = currencyIn instanceof Token3 ? new TokenAmount3(currencyIn, amountInRaw) : new CurrencyAmount2(currencyIn, amountInRaw);
        const maxAmountIn = currencyIn instanceof Token3 ? new TokenAmount3(currencyIn, maxAmountInRaw) : new CurrencyAmount2(currencyIn, maxAmountInRaw);
        logger11.debug("amountIn:", amountIn.toFixed());
        logger11.debug("maxAmountIn:", maxAmountIn.toFixed());
        let executionPrice = null;
        if (!amountInRaw.isZero() && !amountOutRaw.isZero()) {
          executionPrice = new Price2(currencyIn, amountInRaw, currencyOut, amountOutRaw);
          logger11.debug("executionPrice:", `1 ${currencyIn.symbol} \u2248 ${executionPrice.toFixed()} ${currencyOut.symbol}`);
          logger11.debug(
            "executionPrice invert:",
            `1 ${currencyOut.symbol} \u2248 ${executionPrice.invert().toFixed()} ${currencyIn.symbol}`
          );
        }
        const priceImpact = this._computePriceImpact(currentPrice, amountInRaw, amountOutRaw);
        logger11.debug("priceImpact:", `${priceImpact.toSignificant()}%`);
        return {
          amountIn,
          maxAmountIn,
          currentPrice,
          executionPrice,
          priceImpact
        };
      }
    };
    _Liquidity.computeAmountOut = ({
      poolKeys,
      poolInfo,
      amountIn,
      currencyOut,
      slippage
    }) => {
      const tokenIn = amountIn instanceof TokenAmount3 ? amountIn.token : Token3.WSOL;
      const tokenOut = currencyOut instanceof Token3 ? currencyOut : Token3.WSOL;
      logger11.assertArgument(
        _Liquidity.includesToken(tokenIn, poolKeys) && _Liquidity.includesToken(tokenOut, poolKeys),
        "token not match with pool",
        "poolKeys",
        { poolKeys, tokenIn, tokenOut }
      );
      const { baseReserve, quoteReserve } = poolInfo;
      logger11.debug("baseReserve:", baseReserve.toString());
      logger11.debug("quoteReserve:", quoteReserve.toString());
      const currencyIn = amountIn instanceof TokenAmount3 ? amountIn.token : amountIn.currency;
      logger11.debug("currencyIn:", currencyIn);
      logger11.debug("amountIn:", amountIn.toFixed());
      logger11.debug("currencyOut:", currencyOut);
      logger11.debug("slippage:", `${slippage.toSignificant()}%`);
      const reserves = [baseReserve, quoteReserve];
      const input = _Liquidity._getAmountSide(amountIn, poolKeys);
      if (input === "quote") {
        reserves.reverse();
      }
      logger11.debug("input side:", input);
      const [reserveIn, reserveOut] = reserves;
      let currentPrice;
      if (poolKeys.version === 4) {
        currentPrice = new Price2(currencyIn, reserveIn, currencyOut, reserveOut);
      } else {
        const p = getStablePrice2(modelData, baseReserve.toNumber(), quoteReserve.toNumber(), false);
        if (input === "quote")
          currentPrice = new Price2(currencyIn, new import_bn16.default(p * 1e6), currencyOut, new import_bn16.default(1e6));
        else
          currentPrice = new Price2(currencyIn, new import_bn16.default(1e6), currencyOut, new import_bn16.default(p * 1e6));
      }
      logger11.debug("currentPrice:", `1 ${currencyIn.symbol} \u2248 ${currentPrice.toFixed()} ${currencyOut.symbol}`);
      logger11.debug(
        "currentPrice invert:",
        `1 ${currencyOut.symbol} \u2248 ${currentPrice.invert().toFixed()} ${currencyIn.symbol}`
      );
      const amountInRaw = amountIn.raw;
      let amountOutRaw = ZERO2;
      let feeRaw = ZERO2;
      if (!amountInRaw.isZero()) {
        if (poolKeys.version === 4) {
          feeRaw = BNDivCeil2(amountInRaw.mul(LIQUIDITY_FEES_NUMERATOR2), LIQUIDITY_FEES_DENOMINATOR2);
          const amountInWithFee = amountInRaw.sub(feeRaw);
          const denominator = reserveIn.add(amountInWithFee);
          amountOutRaw = reserveOut.mul(amountInWithFee).div(denominator);
        } else {
          feeRaw = amountInRaw.mul(new import_bn16.default(2)).div(new import_bn16.default(1e4));
          const amountInWithFee = amountInRaw.sub(feeRaw);
          if (input === "quote")
            amountOutRaw = new import_bn16.default(
              getDyByDxBaseIn2(modelData, quoteReserve.toNumber(), baseReserve.toNumber(), amountInWithFee.toNumber())
            );
          else {
            amountOutRaw = new import_bn16.default(
              getDxByDyBaseIn2(modelData, quoteReserve.toNumber(), baseReserve.toNumber(), amountInWithFee.toNumber())
            );
          }
        }
      }
      const _slippage = new Percent3(ONE2).add(slippage);
      const minAmountOutRaw = _slippage.invert().mul(amountOutRaw).quotient;
      const amountOut = currencyOut instanceof Token3 ? new TokenAmount3(currencyOut, amountOutRaw) : new CurrencyAmount2(currencyOut, amountOutRaw);
      const minAmountOut = currencyOut instanceof Token3 ? new TokenAmount3(currencyOut, minAmountOutRaw) : new CurrencyAmount2(currencyOut, minAmountOutRaw);
      logger11.debug("amountOut:", amountOut.toFixed());
      logger11.debug("minAmountOut:", minAmountOut.toFixed());
      let executionPrice = new Price2(currencyIn, amountInRaw.sub(feeRaw), currencyOut, amountOutRaw);
      if (!amountInRaw.isZero() && !amountOutRaw.isZero()) {
        executionPrice = new Price2(currencyIn, amountInRaw.sub(feeRaw), currencyOut, amountOutRaw);
        logger11.debug("executionPrice:", `1 ${currencyIn.symbol} \u2248 ${executionPrice.toFixed()} ${currencyOut.symbol}`);
        logger11.debug(
          "executionPrice invert:",
          `1 ${currencyOut.symbol} \u2248 ${executionPrice.invert().toFixed()} ${currencyIn.symbol}`
        );
      }
      const priceImpactDenominator = executionPrice.denominator.mul(currentPrice.numerator);
      const priceImpactNumerator = executionPrice.numerator.mul(currentPrice.denominator).sub(priceImpactDenominator).abs();
      const priceImpact = new Percent3(priceImpactNumerator, priceImpactDenominator);
      logger11.debug("priceImpact:", `${priceImpact.toSignificant()}%`);
      const fee = currencyIn instanceof Token3 ? new TokenAmount3(currencyIn, feeRaw) : new CurrencyAmount2(currencyIn, feeRaw);
      return {
        amountOut,
        minAmountOut,
        currentPrice,
        executionPrice,
        priceImpact,
        fee
      };
    };
    var Liquidity2 = _Liquidity;
    var MAINNET_OFFICIAL_LIQUIDITY_POOLS = [
      /* ================= v4 ================= */
      // FIDA-RAY
      "2dRNngAm729NzLbb1pzgHtfHvPqR4XHFmFyYK78EfEeX",
      // OXY-RAY
      "B5ZguAWAGC3GXVtJZVfoMtzvEvDnDKBPCevsUKMy4DTZ",
      // MAPS-RAY
      "5VyLSjUvaRxsubirbvbfJMbrKZRx1b7JZzuCAfyqgimf",
      // KIN-RAY
      "6kmMMacvoCKBkBrqssLEdFuEZu2wqtLdNQxh9VjtzfwT",
      // RAY-USDT
      "DVa7Qmb5ct9RCpaU7UTpSaf3GVMYz17vNVU67XpdCRut",
      // SOL-USDC
      "58oQChx4yWmvKdwLLZzBi4ChoCc2fqCUWBkwMihLYQo2",
      // YFI-USDC
      "83xxjVczDseaCzd7D61BRo7LcP7cMXut5n7thhB4rL4d",
      // SRM-USDC
      "8tzS7SkUZyHPQY7gLqsMCXZ5EDCgjESUHcB17tiR1h3Z",
      // FTT-USDC
      "4C2Mz1bVqe42QDDTyJ4HFCFFGsH5YDzo91Cen5w5NGun",
      // BTC-USDC
      "6kbC5epG18DF2DwPEW34tBy5pGFS7pEGALR3v5MGxgc5",
      // SUSHI-USDC
      "5dHEPTgvscKkAc54R77xUeGdgShdG9Mf6gJ9bwBqyb3V",
      // TOMO-USDC
      "8mBJC9qdPNDyrpAbrdwGbBpEAjPqwtvZQVmbnKFXXY2P",
      // LINK-USDC
      "Hr8i6MAm4W5Lwb2fB2CD44A2t3Ag3gGc1rmd6amrWsWC",
      // ETH-USDC
      "AoPebtuJC4f2RweZSxcVCcdeTgaEXY64Uho8b5HdPxAR",
      // xCOPE-USDC
      "3mYsmBQLB8EZSjRwtWjPbbE8LiM1oCCtNZZKiVBKsePa",
      // SOL-USDT
      "7XawhbbxtsRcQA8KTkHT9f9nc6d69UwqCDh6U5EEbEmX",
      // YFI-USDT
      "81PmLJ8j2P8CC5EJAAhWGYA4HgJvoKs4Y94ALZF2uKKG",
      // SRM-USDT
      "af8HJg2ffWoKJ6vKvkWJUJ9iWbRR83WgXs8HPs26WGr",
      // FTT-USDT
      "4fgubfZVL6L8tc5x1j65S14P2Tnxr1YayKtKavQV5MBo",
      // BTC-USDT
      "AMMwkf57c7ZsbbDCXvBit9zFehMr1xRn8ZzaT1iDF18o",
      // SUSHI-USDT
      "DWvhPYVogsEKEsehHApUtjhP1UFtApkAPFJqFh2HPmWz",
      // TOMO-USDT
      "GjrXcSvwzGrz1RwKYGVWdbZyXzyotgichSHB95moDmf8",
      // LINK-USDT
      "E9EvurfzdSQaqCFBUaD4MgV93htuRQ93sghm922Pik88",
      // ETH-USDT
      "He3iAEV5rYjv6Xf7PxKro19eVrC3QAcdic5CF2D2obPt",
      // YFI-SRM
      "GDVhJmDTdSExwHeMT5RvUBUNKLwwXNKhH8ndm1tpTv6B",
      // FTT-SRM
      "21r2zeCacmm5YvbGoPZh9ZoGREuodhcbQHaP5tZmzY14",
      // BTC-SRM
      "DvxLb4NnQUYq1gErk35HVt9g8kxjNbviJfiZX1wqraMv",
      // SUSHI-SRM
      "BLVjPTgzyfiKSgDujTNKKNzW2GXx7HhdMxgr2LQ2g83s",
      // TOMO-SRM
      "DkMAuUCQHC6BNgVnjtM5ZTKm1T8MsriQ6bL3Umi6NBtG",
      // LINK-SRM
      "796pvggjoDCPUtUSVFSCLqPRyes5YPvRiu4zFWX582wf",
      // ETH-SRM
      "3XwxHcbyqcd1xkdczaPv3TNCZsevELD4Zux3pu4sF2D8",
      // SRM-SOL
      "EvWJC2mnmu9C9aQrsJLXw8FhUcwBzFEUQsP1E5Y6a5N7",
      // STEP-USDC
      "4Sx1NLrQiK4b9FdLKe2DhQ9FHvRzJhzKN3LoD6BrEPnf",
      // MEDIA-USDC
      "94CQopiGxxUXf2avyMZhAFaBdNatd62ttYGoTVQBRGdi",
      // ROPE-USDC
      "BuS4ScFcZjEBixF1ceCTiXs4rqt4WDfXLoth7VcM2Eoj",
      // MER-USDC
      "BkfGDk676QFtTiGxn7TtEpHayJZRr6LgNk9uTV2MH4bR",
      // COPE-USDC
      "DiWxV1SPXPNJRCt5Ao1mJRAxjw97hJVyj8qGzZwFbAFb",
      // ALEPH-USDC
      "GDHXjn9wF2zxW35DBkCegWQdoTfFBC9LXt7D5ovJxQ5B",
      // TULIP-USDC
      "96hPvuJ3SRT82m7BAc7G1AUVPVcoj8DABAa5gT7wjgzX",
      // WOO-USDC
      "DSkXJYPZqJ3yHQECyVyh3xiE3HBrt7ARmepwNDA9rREn",
      // SNY-USDC
      "5TgJXpv6H3KJhHCuP7KoDLSCmi8sM8nABizP7CmYAKm1",
      // BOP-RAY
      "SJmR8rJgzzCi4sPjGnrNsqY4akQb3jn5nsxZBhyEifC",
      // SLRS-USDC
      "7XXKU8oGDbeGrkPyK5yHKzdsrMJtB7J2TMugjbrXEhB5",
      // SAMO-RAY
      "EyDgEU9BdG7m6ZK4bYERxbN4NCJ129WzPtv23dBkfsLg",
      // renBTC-USDC
      "61JtCkTQKSeBU8ztEScByZiBhS6KAHSXfQduVyA4s1h7",
      // renDOGE-USDC
      "34oD4akb2DeNcCw1smKHPsD3iqQQQWmNy3cY81nz7HP8",
      // RAY-USDC
      "6UmmUiYoBjSrhakAobJw8BvkmJtDVxaeBtbt7rxWo1mg",
      // RAY-SRM
      "GaqgfieVmnmY4ZsZHHA6L5RSVzCGL3sKx4UgHBaYNy8m",
      // RAY-ETH
      "8iQFhWyceGREsWnLM8NkG9GC8DvZunGZyMzuyUScgkMK",
      // RAY-SOL
      "AVs9TA4nWDzfPJE9gGVNJMVhcQy3V9PGazuz33BfG2RA",
      // DXL-USDC
      "asdEJnE7osjgnSyQkSZJ3e5YezbmXuDQPiyeyiBxoUm",
      // LIKE-USDC
      "GmaDNMWsTYWjaXVBjJTHNmCWAKU6cn5hhtWWYEZt4odo",
      // mSOL-USDC
      "ZfvDXXUhZDzDVsapffUyXHj9ByCoPjP4thL6YXcZ9ix",
      // mSOL-SOL
      "EGyhb2uLAsRUbRx9dNFBjMVYnFaASWMvD6RE1aEf2LxL",
      // MER-PAI
      "6GUF8Qb5FWmifzYpRdKomFNbSQAsLShhT45GbTGg34VJ",
      // PORT-USDC
      "6nJes56KF999Q8VtQTrgWEHJGAfGMuJktGb8x2uWff2u",
      // MNGO-USDC
      "34tFULRrRwh4bMcBLPtJaNqqe5pVgGZACi5sR8Xz95KC",
      // ATLAS-USDC
      "2bnZ1edbvK3CK3LTNZ5jH9anvXYCmzPR4W2HQ6Ngsv5K",
      // POLIS-USDC
      "9xyCzsHi1wUWva7t5Z8eAvZDRmUCVhRrbaFfm3VbU4Mf",
      // ATLAS-RAY
      "F73euqPynBwrgcZn3fNSEneSnYasDQohPM5aZazW9hp2",
      // POLIS-RAY
      "5tho4By9RsqTF1rbm9Akiepik3kZBT7ffUzGg8bL1mD",
      // ALEPH-RAY
      "8Fr3wxZXLtiSozqms5nF4XXGHNSNqcMC6K6MvRqEfk4a",
      // TULIP-RAY
      "Dm1Q15216uRARmQTbo6VfnyEGVzRvLTm4TfCWWX4MF3F",
      // SLRS-RAY
      "J3CoGcJqHquUdSgS7qAwdGbp3so4EpLX8eVDdGuauvi",
      // MER-RAY
      "BKLCqnuk4qc5iHWuJuewMxuvsNZXuTBSUyRT5ftnRb6H",
      // MEDIA-RAY
      "5ZPBHzMr19iQjBaDgFDYGAx2bxaQ3TzWmSS7zAGrHtQJ",
      // SNY-RAY
      "Am9FpX73ctZ3HzohcRdyCCv84iT7nugevqLjY5yTSUQP",
      // LIKE-RAY
      "DGSnfcE1kw4uDC6jgrsZ3s5CMfsWKN7JNjDNasHdvKfq",
      // COPE-RAY
      "8hvVAhShYLPThcxrxwMNAWmgRCSjtxygj11EGHp2WHz8",
      // ETH-SOL
      "9Hm8QX7ZhE9uB8L2arChmmagZZBtBmnzBbpfxzkQp85D",
      // stSOL-USDC
      "6a1CsrpeZubDjEJE9s1CMVheB6HWM5d7m1cj2jkhyXhj",
      // GRAPE-USDC
      "vVXfY15WdPsCmLvbiP4hWWECPFeAvPTuPNq3Q4BXfhy",
      // LARIX-USDC
      "A21ui9aYTSs3CbkscaY6irEMQx3Z59dLrRuZQTt2hJwQ",
      // RIN-USDC
      "7qZJTK5NatxQJRTxZvHi3gRu4cZZsKr8ZPzs7BA5JMTC",
      // APEX-USDC
      "43UHp4TuwQ7BYsaULN1qfpktmg7GWs9GpR8TDb8ovu9c",
      // mSOL-RAY
      "6gpZ9JkLoYvpA5cwdyPZFsDw6tkbPyyXM5FqRqHxMCny",
      // MNDE-mSOL
      "2kPA9XUuHUifcCYTnjSuN7ZrC3ma8EKPrtzUhC86zj3m",
      // LARIX-RAY
      "EBqQdu9rGe6j3WGJQSyTvDjUMWcRd6uLcxSS4TbFT31t",
      // LIQ-USDC
      "33dWwj33J3NUzoTmkMAUq1VdXZL89qezxkdaHdN88vK2",
      // WAG-USDC
      "FEFzBbbEK8yDigqyJPgJKMR5X1xZARC25QTCskvudjuK",
      // ETH-mSOL
      "Ghj3v2qYbSp6XqmH4NV4KRu4Rrgqoh2Ra7L9jEdsbNzF",
      // mSOL-USDT
      "BhuMVCzwFVZMSuc1kBbdcAnXwFg9p4HJp7A9ddwYjsaF",
      // BTC-mSOL
      "ynV2H2b7FcRBho2TvE25Zc4gDeuu2N45rUw9DuJYjJ9",
      // SLIM-SOL
      "8idN93ZBpdtMp4672aS4GGMDy7LdVWCCXH7FKFdMw9P4",
      // AURY-USDC
      "Ek8uoHjADzbNk2yr2HysybwFk1h2j9XXDsWAjAJN38n1",
      // PRT-SOL
      "7rVAbPFzqaBmydukTDFAuBiuyBrTVhpa5LpfDRrjX9mr",
      // LIQ-RAY
      "HuMDhYhW1BmBjXoJZBdjqaqoD3ehQeCUMbDSiZsaXSDU",
      // SYP-SOL
      "D95EzH4ZsGLikvYzp7kmz1RM1xNMo1MXXiXaedQesA2m",
      // SYP-RAY
      "3hhSfFhbk7Kd8XrRYKCcGAyUVYRaW9MLhcqAaU9kx6SA",
      // SYP-USDC
      "2Tv6eMih3iqxHrLAWn372Nba4A8FT8AxFSbowBmmTuAd",
      // FAB-USDC
      "7eM9KWYiJmNfDfeztMoEZE1KPyWD54LRxM9GmRY9ske6",
      // WOOF-RAY
      "3HYhQC6ne6SAPVT5sPTKawRUxv9ZpYyLuk1ifrw8baov",
      // WOOF-USDC
      "EZRHhpvAP4zEX1wZtTQcf6NP4FLWjs9c6tMRBqfrXgFD",
      // SLND-USDC
      "GRM4jGMtx64sEocBFz6ZgdogF2fyTWiixht8thZoHjkK",
      // FRKT-SOL
      "H3dhkXcC5MRN7VRXNbWVSvogH8mUQPzpn8PYQL7HfBVg",
      // weWETH-SOL
      "4yrHms7ekgTBgJg77zJ33TsWrraqHsCXDtuSZqUsuGHb",
      // weWETH-USDC
      "EoNrn8iUhwgJySD1pHu8Qxm5gSQqLK3za4m8xzD2RuEb",
      // weUNI-USDC
      "8J5fa8WBGaDSv8AUpgtqdh9HM5AZuSf2ijvSkKoaCXCi",
      // weSUSHI-USDC
      "9SWy6nbSVZ44XuixEvHpona663pZPpVgzXQ3N7muG4ou",
      // CYS-USDC
      "661trVCzDWp114gy4PEK4etbjb3u3RNaP4aENa5uN8Vp",
      // SAMO-USDC
      "7oYaghDwJ6ZbZwzdzcPqQtW6r4cojSLJDKB6U7tqAK1x",
      // ABR-USDC
      "GQJjrG6f8HbxkE3ZVSRpzoyWhQ2RiivT68BybVK9DxME",
      // IN-USDC
      "5DECiJuqwmeCptoBEpyJtXKrVfiUrG9nBbBGkxGkPYyF",
      // weDYDX-USDC
      "CbGQojcizFEHn3woL7NPu3P9BLL1SWz5a8zkL9gks24q",
      // STARS-USDC
      "CWQVga1qUbpZXjrWQRj6U6tmL3HhrFiAT11VYnB8d3CF",
      // weAXS-USDC
      "HopVRTvFvRe1ED3dRCQrt1h5onkMvY3tKUHRVQMc7MMH",
      // weSHIB-USDC
      "SU7vPveBjEuR5tgQwidRqqTxn1WwraHpydHHBpM2W96",
      // SBR-USDC
      "5cmAS6Mj4pG2Vp9hhyu3kpK9yvC7P6ejh9HiobpTE6Jc",
      // OXS-USDC
      "8ekXiGjEjtWzd2us3rAsusKv7kKEhPENV7nvzS7RGRYY",
      // CWAR-USDC
      "13uCPybNakXHGVd2DDVB7o2uwXuf9GqPFkvJMVgKy6UJ",
      // UPS-USDC
      "FSSRqrGrDjDXnojhSDrDBknJeQ83pyACemnaMLaZDD1U",
      // weSAND-USDC
      "3cmPpX8kKzEra2umtLCDxMfjma82ELtAMaSYVmdaNLxi",
      // weMANA-USDC
      "7Z1c6GHutf3q2MNheyFE8KMNVEALuiPaqoEMyjbCbuku",
      // CAVE-USDC
      "2PfKnjEfoUoVDbDS1YwvZ8HuPGBCpN831mnTuqTAJZjH",
      // GENE-USDC
      "Enq8vJucRbkzKA1i1PahJNhMyUTzoVL5Cs8n5rC3NLGn",
      // GENE-RAY
      "8FrCybrh7UFznP1hVHg8kXZ8bhii37c7BGzmjkdcsGJp",
      // APT-USDC
      "4crhN3D8R5rnZd66q9b32P7K649e5XdzCfPMPiTzBceH",
      // GOFX-USDC
      "zoouer92idprkptX76yvhp4stK2keTzJpMNkeLqtxAx",
      // SONAR-USDC
      "CrWbfKwyAaUfYctXWF9iaDUP4AH5t6k6bbaWnXBL8nHm",
      // JSOL-SOL
      "D8pasgJWjP9wy39fzeD8BUjQMvYCZxABzPcnuoDSLHBB",
      // JSOL-USDC
      "7e8GrkwsRm5sS5UaKobLJUNu9esmrzg37dqX6aQyuver",
      // SHILL-USDC
      "FTyJCLwQ3YvVfanJp8mtC2eqmvZPpzSpmNLqWpaPaXbC",
      // DFL-USDC
      "8GJdzPuEBPP3BHJpcspBcfpRZV4moZMFwhTAuXebaPL8",
      // BOKU-USDC
      "FsERtRjCEQNyND3ccnMGrd61ntPmJ3tbZs4vvcCzMr1L",
      // MIMO-SOL
      "DqYSvijBXydSx9GfvVDjEzUg5StLLrkqZVPzsU2FeVZ2",
      // wbWBNB-USDC
      "Fb1WR1kYvG1tHu4pwAxXQpdKT8Grh9i7ES9rZusLg7D6",
      // wePEOPLE-USDC
      "GfvqUB36CPfqZDz5ntQ2YsoKRwg1MCewmurhc7jw3P5s",
      // XTAG-USDC
      "Hv1BFhyADPjYXTqEeMgwzoybnNwYrHXNv7U2VjcAuEDr",
      // KKO-USDC
      "FvN7dJz7GX1XB1BTk6jD5rEKRxQc3ZwNkWJKai5sBJWS",
      // VI-USDC
      "MphbxYtji1FSkm7G2FNGpUUz5AWn7iRPNFAvEqD4mzE",
      // SOLC-USDT
      "783kPvwHwDXaU32kV8NK5dB4JVeMWQwe8a3WUNZFpupr",
      // STR-USDC
      "E9Z2JeEKS2WGGyA18mGU33rnQskK9moPhM4tdzrv24fh",
      // SPWN-USDC
      "Bhw7DbVwWMcTBXoKaWgsCaofL6QqmQQ65FCSGfgCEawm",
      // ISOLA-USDT
      "69Mo81rUPDgru4UbigPQovx7cYBxpEm44qQok8wcut4M",
      // TTT-USDC
      "HcqHvH27wk42L1ND5YPhLDJu7oGsU7HGSreMiXdq5LNK",
      // RUN-USDC
      "zuivKkgkNFFkV9jfNpsU1p5tWNbDWUEx5XX16m4k2Ej",
      // CRWNY-USDC
      "4ELBQuq3ivhLamfCT36As5sXLkQDWRJw1pJ9JVFLp6gK",
      // CRWNY-RAY
      "HARRXESCwid3xMi2qThag1PXzmp6rDhAzMR9THhFRQGf",
      // BLOCK-USDC
      "CfBSfVTcYFJsD8vZ2fTiMGkUYFim2rv8weAoqHxUU2pn",
      // REAL-USDC
      "A7ZxDrK9LSkVXhfRTu2pRCinwYfdxW2kK6DaJk12jRWw",
      // PRISM-USDC
      "4ZYiiVakejxGyJ3tuBzYWoHyEV1rk7Hm7viydG6DNaUN",
      // MBS-USDC
      "6eRECBcCVP82AvAd6Di4rZApa2btLf8RDUqrTigt4hS4"
    ];
    var TESTNET_OFFICIAL_LIQUIDITY_POOLS = [];
    var DEVNET_OFFICIAL_LIQUIDITY_POOLS = [];
    var ENDPOINT = "https://api.raydium.io";
    var RAYDIUM_MAINNET = {
      time: "/v2/main/chain/time",
      info: "/v2/main/info",
      pairs: "/v2/main/pairs",
      price: "/v2/main/price",
      rpcs: "/v2/main/rpcs",
      version: "/v2/main/version",
      farmApr: "/v2/main/farm/info",
      farmAprLine: "/v2/main/farm-apr-tv",
      tokenInfo: "/v2/sdk/token/raydium.mainnet.json",
      poolInfo: "/v2/sdk/liquidity/mainnet.json",
      dailyPoolInfo: "/v2/sdk/liquidity/date",
      uiPoolInfo: "/v2/sdk/liquidity/mainnet.ui.json",
      searchPool: "/v2/sdk/liquidity/mint/",
      farmInfo: "/v2/sdk/farm-v2/mainnet.json",
      idoInfo: "/v2/main/ido/pools",
      idoProjectInfo: "/v2/main/ido/project/<id>",
      // CLMM
      clmmPools: "/v2/ammV3/ammPools",
      clmmConfigs: "/v2/ammV3/ammConfigs",
      clmmPositionLine: "/v2/ammV3/positionLine/<poolId>"
    };
    var import_web323 = require("@solana/web3.js");
    var MAINNET_PROGRAM_ID = {
      SERUM_MARKET: new import_web323.PublicKey("9xQeWvG816bUx9EPjHmaT23yvVM2ZWbrrpZb9PusVFin"),
      OPENBOOK_MARKET: new import_web323.PublicKey("srmqPvymJeFKQ4zGQed1GFppgkRHL9kaELCbyksJtPX"),
      UTIL1216: new import_web323.PublicKey("CLaimxFqjHzgTJtAGHU47NPhg6qrc5sCnpC4tBLyABQS"),
      FarmV3: new import_web323.PublicKey("EhhTKczWMGQt46ynNeRX1WfeagwwJd7ufHvCDjRxjo5Q"),
      FarmV5: new import_web323.PublicKey("9KEPoZmtHUrBbhWN1v1KWLMkkvwY6WLtAVUCPRtRjP4z"),
      FarmV6: new import_web323.PublicKey("FarmqiPv5eAj3j1GMdMCMUGXqPUvmquZtMy86QH6rzhG"),
      AmmV4: new import_web323.PublicKey("675kPX9MHTjS2zt1qfr1NYHuzeLXfQM9H24wFSUt1Mp8"),
      AmmStable: new import_web323.PublicKey("5quBtoiQqxF9Jv6KYKctB59NT3gtJD2Y65kdnB1Uev3h"),
      CLMM: new import_web323.PublicKey("CAMMCzo5YL8w4VFF8KVHrK22GGUsp5VTaW7grrKgrWqK"),
      Router: new import_web323.PublicKey("routeUGWgWzqBWFcrCfv8tritsqukccJPu3q5GPP3xS")
    };
    var DEVNET_PROGRAM_ID2 = {
      SERUM_MARKET: import_web323.PublicKey.default,
      OPENBOOK_MARKET: new import_web323.PublicKey("EoTcMgcDRTJVZDMZWBoU6rhYHZfkNTVEAfz3uUJRcYGj"),
      UTIL1216: import_web323.PublicKey.default,
      FarmV3: new import_web323.PublicKey("85BFyr98MbCUU9MVTEgzx1nbhWACbJqLzho6zd6DZcWL"),
      FarmV5: new import_web323.PublicKey("EcLzTrNg9V7qhcdyXDe2qjtPkiGzDM2UbdRaeaadU5r2"),
      FarmV6: new import_web323.PublicKey("Farm2hJLcqPtPg8M4rR6DMrsRNc5TPm5Cs4bVQrMe2T7"),
      AmmV4: new import_web323.PublicKey("HWy1jotHpo6UqeQxx49dpYYdQB8wj9Qk9MdxwjLvDHB8"),
      AmmStable: new import_web323.PublicKey("DDg4VmQaJV9ogWce7LpcjBA9bv22wRp5uaTPa5pGjijF"),
      CLMM: new import_web323.PublicKey("devi51mZmdwUJGU9hjN27vEz64Gps7uUefqxg27EAtH"),
      Router: new import_web323.PublicKey("BVChZ3XFEwTMUk1o9i3HAf91H6mFxSwa5X2wFAWhYPhU")
    };
    var import_spl_token8 = require_cjs5();
    var import_web325 = require("@solana/web3.js");
    var import_bn17 = __toESM2(require_bn());
    var import_spl_token7 = require_cjs5();
    var import_web324 = require("@solana/web3.js");
    function routeInstruction2(programId, wallet, userSourceToken, userRouteToken, userDestinationToken, inputMint, routeMint, poolKeyA, poolKeyB, amountIn, amountOut, remainingAccounts) {
      const dataLayout = struct3([u822("instruction"), u643("amountIn"), u643("amountOut")]);
      const keys = [
        { pubkey: wallet, isSigner: true, isWritable: false },
        { pubkey: import_spl_token7.TOKEN_PROGRAM_ID, isSigner: false, isWritable: false }
      ];
      keys.push(...makeInnerInsKey(poolKeyA, inputMint, userSourceToken, userRouteToken, remainingAccounts[0]));
      keys.push(...makeInnerInsKey(poolKeyB, routeMint, userRouteToken, userDestinationToken, remainingAccounts[1]));
      const data = Buffer.alloc(dataLayout.span);
      dataLayout.encode(
        {
          instruction: 8,
          amountIn,
          amountOut
        },
        data
      );
      return new import_web324.TransactionInstruction({
        keys,
        programId,
        data
      });
    }
    function makeInnerInsKey(itemPool, inMint, userInAccount, userOutAccount, remainingAccount) {
      if (itemPool.version === 4) {
        const poolKey = jsonInfo2PoolKeys2(itemPool);
        return [
          { pubkey: poolKey.programId, isSigner: false, isWritable: false },
          { pubkey: userInAccount, isSigner: false, isWritable: true },
          { pubkey: userOutAccount, isSigner: false, isWritable: true },
          { pubkey: poolKey.id, isSigner: false, isWritable: true },
          { pubkey: poolKey.authority, isSigner: false, isWritable: false },
          { pubkey: poolKey.marketProgramId, isSigner: false, isWritable: false },
          { pubkey: poolKey.marketAuthority, isSigner: false, isWritable: false },
          { pubkey: poolKey.openOrders, isSigner: false, isWritable: true },
          { pubkey: poolKey.baseVault, isSigner: false, isWritable: true },
          { pubkey: poolKey.quoteVault, isSigner: false, isWritable: true },
          { pubkey: poolKey.marketId, isSigner: false, isWritable: true },
          { pubkey: poolKey.marketBids, isSigner: false, isWritable: true },
          { pubkey: poolKey.marketAsks, isSigner: false, isWritable: true },
          { pubkey: poolKey.marketEventQueue, isSigner: false, isWritable: true },
          ...poolKey.marketProgramId.toString() === "srmqPvymJeFKQ4zGQed1GFppgkRHL9kaELCbyksJtPX" ? [
            { pubkey: poolKey.marketBaseVault, isSigner: false, isWritable: true },
            { pubkey: poolKey.marketQuoteVault, isSigner: false, isWritable: true }
          ] : [
            { pubkey: poolKey.id, isSigner: false, isWritable: true },
            { pubkey: poolKey.id, isSigner: false, isWritable: true }
          ]
        ];
      } else if (itemPool.version === 5) {
        const poolKey = jsonInfo2PoolKeys2(itemPool);
        return [
          { pubkey: poolKey.programId, isSigner: false, isWritable: false },
          { pubkey: userInAccount, isSigner: false, isWritable: true },
          { pubkey: userOutAccount, isSigner: false, isWritable: true },
          { pubkey: poolKey.id, isSigner: false, isWritable: true },
          { pubkey: poolKey.authority, isSigner: false, isWritable: false },
          { pubkey: poolKey.marketProgramId, isSigner: false, isWritable: false },
          { pubkey: poolKey.id, isSigner: false, isWritable: true },
          { pubkey: new import_web324.PublicKey("CDSr3ssLcRB6XYPJwAfFt18MZvEZp4LjHcvzBVZ45duo"), isSigner: false, isWritable: false },
          { pubkey: poolKey.openOrders, isSigner: false, isWritable: true },
          { pubkey: poolKey.baseVault, isSigner: false, isWritable: true },
          { pubkey: poolKey.quoteVault, isSigner: false, isWritable: true },
          { pubkey: poolKey.marketId, isSigner: false, isWritable: true },
          { pubkey: poolKey.marketBids, isSigner: false, isWritable: true },
          { pubkey: poolKey.marketAsks, isSigner: false, isWritable: true },
          { pubkey: poolKey.marketEventQueue, isSigner: false, isWritable: true },
          { pubkey: poolKey.id, isSigner: false, isWritable: true },
          { pubkey: poolKey.id, isSigner: false, isWritable: true }
        ];
      } else if (itemPool.version === 6) {
        const baseIn = itemPool.mintA.mint.toString() === inMint;
        return [
          { pubkey: new import_web324.PublicKey(String(itemPool.programId)), isSigner: false, isWritable: false },
          { pubkey: userInAccount, isSigner: false, isWritable: true },
          { pubkey: userOutAccount, isSigner: false, isWritable: true },
          { pubkey: itemPool.ammConfig.id, isSigner: false, isWritable: false },
          { pubkey: itemPool.id, isSigner: false, isWritable: true },
          { pubkey: baseIn ? itemPool.mintA.vault : itemPool.mintB.vault, isSigner: false, isWritable: true },
          { pubkey: baseIn ? itemPool.mintB.vault : itemPool.mintA.vault, isSigner: false, isWritable: true },
          { pubkey: itemPool.observationId, isSigner: false, isWritable: true },
          ...itemPool.mintA.programId.equals(import_spl_token7.TOKEN_2022_PROGRAM_ID) || itemPool.mintB.programId.equals(import_spl_token7.TOKEN_2022_PROGRAM_ID) ? [
            { pubkey: import_spl_token7.TOKEN_2022_PROGRAM_ID, isSigner: false, isWritable: false },
            { pubkey: MEMO_PROGRAM_ID3, isSigner: false, isWritable: false },
            { pubkey: baseIn ? itemPool.mintA.mint : itemPool.mintB.mint, isSigner: false, isWritable: false },
            { pubkey: baseIn ? itemPool.mintB.mint : itemPool.mintA.mint, isSigner: false, isWritable: false }
          ] : [],
          ...(remainingAccount != null ? remainingAccount : []).map((i) => ({ pubkey: i, isSigner: false, isWritable: true })),
          {
            pubkey: getPdaExBitmapAccount2(new import_web324.PublicKey(String(itemPool.programId)), itemPool.id).publicKey,
            isSigner: false,
            isWritable: true
          }
        ];
      } else {
        throw Error("make swap ins error");
      }
    }
    var TradeV2 = class extends Base {
      static getAllRoute({
        inputMint,
        outputMint,
        apiPoolList,
        clmmList,
        allowedRouteToken2022 = false
      }) {
        var _a, _b;
        inputMint = inputMint.toString() === import_web325.PublicKey.default.toString() ? new import_web325.PublicKey(WSOL.mint) : inputMint;
        outputMint = outputMint.toString() === import_web325.PublicKey.default.toString() ? new import_web325.PublicKey(WSOL.mint) : outputMint;
        const needSimulate = {};
        const needTickArray = {};
        const needCheckToken = /* @__PURE__ */ new Set();
        const directPath = [];
        const routePathDict = {};
        for (const itemAmmPool of clmmList != null ? clmmList : []) {
          if (itemAmmPool.mintA.mint.equals(inputMint) && itemAmmPool.mintB.mint.equals(outputMint) || itemAmmPool.mintA.mint.equals(outputMint) && itemAmmPool.mintB.mint.equals(inputMint)) {
            directPath.push(itemAmmPool);
            needTickArray[itemAmmPool.id.toString()] = itemAmmPool;
          }
          if (itemAmmPool.mintA.mint.equals(inputMint) && (itemAmmPool.mintB.programId.equals(import_spl_token8.TOKEN_PROGRAM_ID) || allowedRouteToken2022)) {
            const t = itemAmmPool.mintB.mint.toString();
            if (routePathDict[t] === void 0)
              routePathDict[t] = {
                mintProgram: itemAmmPool.mintB.programId,
                in: [],
                out: [],
                mDecimals: itemAmmPool.mintB.decimals
              };
            routePathDict[t].in.push(itemAmmPool);
          }
          if (itemAmmPool.mintB.mint.equals(inputMint) && (itemAmmPool.mintA.programId.equals(import_spl_token8.TOKEN_PROGRAM_ID) || allowedRouteToken2022)) {
            const t = itemAmmPool.mintA.mint.toString();
            if (routePathDict[t] === void 0)
              routePathDict[t] = {
                mintProgram: itemAmmPool.mintA.programId,
                in: [],
                out: [],
                mDecimals: itemAmmPool.mintA.decimals
              };
            routePathDict[t].in.push(itemAmmPool);
          }
          if (itemAmmPool.mintA.mint.equals(outputMint) && (itemAmmPool.mintB.programId.equals(import_spl_token8.TOKEN_PROGRAM_ID) || allowedRouteToken2022)) {
            const t = itemAmmPool.mintB.mint.toString();
            if (routePathDict[t] === void 0)
              routePathDict[t] = {
                mintProgram: itemAmmPool.mintB.programId,
                in: [],
                out: [],
                mDecimals: itemAmmPool.mintB.decimals
              };
            routePathDict[t].out.push(itemAmmPool);
          }
          if (itemAmmPool.mintB.mint.equals(outputMint) && (itemAmmPool.mintA.programId.equals(import_spl_token8.TOKEN_PROGRAM_ID) || allowedRouteToken2022)) {
            const t = itemAmmPool.mintA.mint.toString();
            if (routePathDict[t] === void 0)
              routePathDict[t] = {
                mintProgram: itemAmmPool.mintA.programId,
                in: [],
                out: [],
                mDecimals: itemAmmPool.mintA.decimals
              };
            routePathDict[t].out.push(itemAmmPool);
          }
        }
        const addLiquidityPools = [];
        const _inputMint = inputMint.toString();
        const _outputMint = outputMint.toString();
        for (const itemAmmPool of (_a = (apiPoolList != null ? apiPoolList : {}).official) != null ? _a : []) {
          if (itemAmmPool.baseMint === _inputMint && itemAmmPool.quoteMint === _outputMint || itemAmmPool.baseMint === _outputMint && itemAmmPool.quoteMint === _inputMint) {
            directPath.push(itemAmmPool);
            needSimulate[itemAmmPool.id] = itemAmmPool;
            addLiquidityPools.push(itemAmmPool);
          }
          if (itemAmmPool.baseMint === _inputMint) {
            if (routePathDict[itemAmmPool.quoteMint] === void 0)
              routePathDict[itemAmmPool.quoteMint] = {
                mintProgram: import_spl_token8.TOKEN_PROGRAM_ID,
                in: [],
                out: [],
                mDecimals: itemAmmPool.quoteDecimals
              };
            routePathDict[itemAmmPool.quoteMint].in.push(itemAmmPool);
          }
          if (itemAmmPool.quoteMint === _inputMint) {
            if (routePathDict[itemAmmPool.baseMint] === void 0)
              routePathDict[itemAmmPool.baseMint] = {
                mintProgram: import_spl_token8.TOKEN_PROGRAM_ID,
                in: [],
                out: [],
                mDecimals: itemAmmPool.baseDecimals
              };
            routePathDict[itemAmmPool.baseMint].in.push(itemAmmPool);
          }
          if (itemAmmPool.baseMint === _outputMint) {
            if (routePathDict[itemAmmPool.quoteMint] === void 0)
              routePathDict[itemAmmPool.quoteMint] = {
                mintProgram: import_spl_token8.TOKEN_PROGRAM_ID,
                in: [],
                out: [],
                mDecimals: itemAmmPool.quoteDecimals
              };
            routePathDict[itemAmmPool.quoteMint].out.push(itemAmmPool);
          }
          if (itemAmmPool.quoteMint === _outputMint) {
            if (routePathDict[itemAmmPool.baseMint] === void 0)
              routePathDict[itemAmmPool.baseMint] = {
                mintProgram: import_spl_token8.TOKEN_PROGRAM_ID,
                in: [],
                out: [],
                mDecimals: itemAmmPool.baseDecimals
              };
            routePathDict[itemAmmPool.baseMint].out.push(itemAmmPool);
          }
        }
        const _insertAddLiquidityPool = addLiquidityPools.length === 0;
        for (const itemAmmPool of (_b = (apiPoolList != null ? apiPoolList : {}).unOfficial) != null ? _b : []) {
          if (itemAmmPool.baseMint === _inputMint && itemAmmPool.quoteMint === _outputMint || itemAmmPool.baseMint === _outputMint && itemAmmPool.quoteMint === _inputMint) {
            directPath.push(itemAmmPool);
            needSimulate[itemAmmPool.id] = itemAmmPool;
            if (_insertAddLiquidityPool)
              addLiquidityPools.push(itemAmmPool);
          }
          if (itemAmmPool.baseMint === _inputMint) {
            if (routePathDict[itemAmmPool.quoteMint] === void 0)
              routePathDict[itemAmmPool.quoteMint] = {
                mintProgram: import_spl_token8.TOKEN_PROGRAM_ID,
                in: [],
                out: [],
                mDecimals: itemAmmPool.quoteDecimals
              };
            routePathDict[itemAmmPool.quoteMint].in.push(itemAmmPool);
          }
          if (itemAmmPool.quoteMint === _inputMint) {
            if (routePathDict[itemAmmPool.baseMint] === void 0)
              routePathDict[itemAmmPool.baseMint] = {
                mintProgram: import_spl_token8.TOKEN_PROGRAM_ID,
                in: [],
                out: [],
                mDecimals: itemAmmPool.baseDecimals
              };
            routePathDict[itemAmmPool.baseMint].in.push(itemAmmPool);
          }
          if (itemAmmPool.baseMint === _outputMint) {
            if (routePathDict[itemAmmPool.quoteMint] === void 0)
              routePathDict[itemAmmPool.quoteMint] = {
                mintProgram: import_spl_token8.TOKEN_PROGRAM_ID,
                in: [],
                out: [],
                mDecimals: itemAmmPool.quoteDecimals
              };
            routePathDict[itemAmmPool.quoteMint].out.push(itemAmmPool);
          }
          if (itemAmmPool.quoteMint === _outputMint) {
            if (routePathDict[itemAmmPool.baseMint] === void 0)
              routePathDict[itemAmmPool.baseMint] = {
                mintProgram: import_spl_token8.TOKEN_PROGRAM_ID,
                in: [],
                out: [],
                mDecimals: itemAmmPool.baseDecimals
              };
            routePathDict[itemAmmPool.baseMint].out.push(itemAmmPool);
          }
        }
        for (const t of Object.keys(routePathDict)) {
          if (routePathDict[t].in.length === 1 && routePathDict[t].out.length === 1 && String(routePathDict[t].in[0].id) === String(routePathDict[t].out[0].id)) {
            delete routePathDict[t];
            continue;
          }
          if (routePathDict[t].in.length === 0 || routePathDict[t].out.length === 0) {
            delete routePathDict[t];
            continue;
          }
          const info = routePathDict[t];
          for (const infoIn of info.in) {
            for (const infoOut of info.out) {
              if (infoIn.version === 6 && needTickArray[infoIn.id.toString()] === void 0) {
                needTickArray[infoIn.id.toString()] = infoIn;
                if (infoIn.mintA.programId.equals(import_spl_token8.TOKEN_2022_PROGRAM_ID))
                  needCheckToken.add(infoIn.mintA.mint.toString());
                if (infoIn.mintB.programId.equals(import_spl_token8.TOKEN_2022_PROGRAM_ID))
                  needCheckToken.add(infoIn.mintB.mint.toString());
              } else if (infoIn.version !== 6 && needSimulate[infoIn.id] === void 0) {
                needSimulate[infoIn.id] = infoIn;
              }
              if (infoOut.version === 6 && needTickArray[infoOut.id.toString()] === void 0) {
                needTickArray[infoOut.id.toString()] = infoOut;
                if (infoOut.mintA.programId.equals(import_spl_token8.TOKEN_2022_PROGRAM_ID))
                  needCheckToken.add(infoOut.mintA.mint.toString());
                if (infoOut.mintB.programId.equals(import_spl_token8.TOKEN_2022_PROGRAM_ID))
                  needCheckToken.add(infoOut.mintB.mint.toString());
              } else if (infoOut.version !== 6 && needSimulate[infoOut.id] === void 0) {
                needSimulate[infoOut.id] = infoOut;
              }
            }
          }
        }
        for (const item of directPath) {
          if (item.version === 6) {
            if (item.mintA.programId.equals(import_spl_token8.TOKEN_2022_PROGRAM_ID))
              needCheckToken.add(item.mintA.mint.toString());
            if (item.mintB.programId.equals(import_spl_token8.TOKEN_2022_PROGRAM_ID))
              needCheckToken.add(item.mintB.mint.toString());
          }
        }
        return {
          directPath,
          addLiquidityPools,
          routePathDict,
          needSimulate: Object.values(needSimulate),
          needTickArray: Object.values(needTickArray),
          needCheckToken: [...needCheckToken]
        };
      }
      static fetchMultipleInfo(_0) {
        return __async(this, arguments, function* ({
          connection,
          pools,
          batchRequest = true
        }) {
          if (pools.find((i) => i.version === 5))
            yield initStableModelLayout(connection);
          const instructions = pools.map(
            (pool) => Liquidity2.makeSimulatePoolInfoInstruction({ poolKeys: jsonInfo2PoolKeys2(pool) })
          );
          const logs = yield simulateMultipleInstruction2(
            connection,
            instructions.map((i) => i.innerTransaction.instructions).flat(),
            "GetPoolData",
            batchRequest
          );
          const poolsInfo = {};
          for (const log3 of logs) {
            const json = parseSimulateLogToJson2(log3, "GetPoolData");
            const ammId = JSON.parse(json)["amm_id"];
            const status = new import_bn17.default(parseSimulateValue2(json, "status"));
            const baseDecimals = Number(parseSimulateValue2(json, "coin_decimals"));
            const quoteDecimals = Number(parseSimulateValue2(json, "pc_decimals"));
            const lpDecimals = Number(parseSimulateValue2(json, "lp_decimals"));
            const baseReserve = new import_bn17.default(parseSimulateValue2(json, "pool_coin_amount"));
            const quoteReserve = new import_bn17.default(parseSimulateValue2(json, "pool_pc_amount"));
            const lpSupply = new import_bn17.default(parseSimulateValue2(json, "pool_lp_supply"));
            let startTime = "0";
            try {
              startTime = parseSimulateValue2(json, "pool_open_time");
            } catch (error) {
            }
            poolsInfo[ammId] = {
              ammId,
              status,
              baseDecimals,
              quoteDecimals,
              lpDecimals,
              baseReserve,
              quoteReserve,
              lpSupply,
              startTime: new import_bn17.default(startTime)
            };
          }
          return poolsInfo;
        });
      }
      static getAddLiquidityDefaultPool({
        addLiquidityPools,
        poolInfosCache
      }) {
        if (addLiquidityPools.length === 0)
          return void 0;
        if (addLiquidityPools.length === 1)
          return addLiquidityPools[0];
        addLiquidityPools.sort((a, b) => b.version - a.version);
        if (addLiquidityPools[0].version !== addLiquidityPools[1].version)
          return addLiquidityPools[0];
        const _addLiquidityPools = addLiquidityPools.filter((i) => i.version === addLiquidityPools[0].version);
        _addLiquidityPools.sort((a, b) => this.ComparePoolSize(a, b, poolInfosCache));
        return _addLiquidityPools[0];
      }
      static ComparePoolSize(a, b, ammIdToPoolInfo) {
        const aInfo = ammIdToPoolInfo[a.id];
        const bInfo = ammIdToPoolInfo[b.id];
        if (aInfo === void 0)
          return 1;
        if (bInfo === void 0)
          return -1;
        if (a.baseMint === b.baseMint) {
          const sub3 = aInfo.baseReserve.sub(bInfo.baseReserve);
          return sub3.gte(ZERO2) ? -1 : 1;
        } else {
          const sub3 = aInfo.baseReserve.sub(bInfo.quoteReserve);
          return sub3.gte(ZERO2) ? -1 : 1;
        }
      }
      static getAllRouteComputeAmountOut({
        inputTokenAmount,
        outputToken,
        directPath,
        routePathDict,
        simulateCache,
        tickCache,
        mintInfos,
        slippage,
        chainTime,
        epochInfo,
        feeConfig
      }) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l;
        const _amountInFee = feeConfig === void 0 ? new import_bn17.default(0) : inputTokenAmount.raw.mul(new import_bn17.default(feeConfig.feeBps.toNumber())).div(new import_bn17.default(1e4));
        const _amoutIn = inputTokenAmount.raw.sub(_amountInFee);
        const amountIn = inputTokenAmount instanceof TokenAmount3 ? new TokenAmount3(inputTokenAmount.token, _amoutIn) : new CurrencyAmount2(inputTokenAmount.currency, _amoutIn);
        const _inFeeConfig = feeConfig === void 0 ? void 0 : {
          feeAmount: _amountInFee,
          feeAccount: feeConfig.feeAccount
        };
        const outRoute = [];
        for (const itemPool of directPath) {
          try {
            outRoute.push(__spreadProps(__spreadValues({}, this.computeAmountOut({
              itemPool,
              tickCache,
              simulateCache,
              chainTime,
              epochInfo,
              mintInfos,
              slippage,
              outputToken,
              amountIn
            })), {
              feeConfig: _inFeeConfig
            }));
          } catch (e) {
          }
        }
        for (const [routeMint, info] of Object.entries(routePathDict)) {
          const routeToken = new Token3(info.mintProgram, routeMint, info.mDecimals);
          const maxFirstIn = info.in.map((i) => {
            try {
              return {
                pool: i,
                data: this.computeAmountOut({
                  itemPool: i,
                  tickCache,
                  simulateCache,
                  chainTime,
                  epochInfo,
                  mintInfos,
                  slippage,
                  outputToken: routeToken,
                  amountIn
                })
              };
            } catch (e) {
              return void 0;
            }
          }).sort((_a2, _b2) => {
            var _a3, _b3, _c2, _d2;
            const a = _a2 === void 0 ? ZERO2 : _a2.data.amountOut.amount.raw.sub((_b3 = (_a3 = _a2.data.amountOut.fee) == null ? void 0 : _a3.raw) != null ? _b3 : ZERO2);
            const b = _b2 === void 0 ? ZERO2 : _b2.data.amountOut.amount.raw.sub((_d2 = (_c2 = _b2.data.amountOut.fee) == null ? void 0 : _c2.raw) != null ? _d2 : ZERO2);
            return a.lt(b) ? 1 : -1;
          })[0];
          if (maxFirstIn === void 0)
            continue;
          const routeAmountIn = new TokenAmount3(
            routeToken,
            maxFirstIn.data.amountOut.amount.raw.sub((_b = (_a = maxFirstIn.data.amountOut.fee) == null ? void 0 : _a.raw) != null ? _b : ZERO2)
          );
          for (const iOutPool of info.out) {
            try {
              const outC = this.computeAmountOut({
                itemPool: iOutPool,
                tickCache,
                simulateCache,
                chainTime,
                epochInfo,
                mintInfos,
                slippage,
                outputToken,
                amountIn: routeAmountIn
              });
              outRoute.push({
                allTrade: maxFirstIn.data.allTrade && outC.allTrade ? true : false,
                amountIn: maxFirstIn.data.amountIn,
                amountOut: outC.amountOut,
                minAmountOut: outC.minAmountOut,
                currentPrice: void 0,
                executionPrice: new Price2(
                  (_c = maxFirstIn.data.amountIn.amount.token) != null ? _c : maxFirstIn.data.amountIn.amount.currency,
                  maxFirstIn.data.amountIn.amount.raw,
                  (_d = outC.amountOut.amount.token) != null ? _d : outC.amountOut.amount.currency,
                  outC.amountOut.amount.raw.sub((_f = (_e = outC.amountOut.fee) == null ? void 0 : _e.raw) != null ? _f : ZERO2)
                ),
                priceImpact: maxFirstIn.data.priceImpact.add(outC.priceImpact),
                fee: [maxFirstIn.data.fee[0], outC.fee[0]],
                routeType: "route",
                poolKey: [maxFirstIn.pool, iOutPool],
                remainingAccounts: [maxFirstIn.data.remainingAccounts[0], outC.remainingAccounts[0]],
                minMiddleAmountFee: ((_g = outC.amountOut.fee) == null ? void 0 : _g.raw) ? new TokenAmount3(
                  (_h = maxFirstIn.data.amountOut.amount.token) != null ? _h : maxFirstIn.data.amountOut.amount.currency,
                  ((_j = (_i = maxFirstIn.data.amountOut.fee) == null ? void 0 : _i.raw) != null ? _j : ZERO2).add((_l = (_k = outC.amountOut.fee) == null ? void 0 : _k.raw) != null ? _l : ZERO2)
                ) : void 0,
                middleToken: maxFirstIn.data.amountOut.amount.token,
                poolReady: maxFirstIn.data.poolReady && outC.poolReady,
                poolType: [maxFirstIn.data.poolType, outC.poolType],
                feeConfig: _inFeeConfig,
                expirationTime: minExpirationTime2(maxFirstIn.data.expirationTime, outC.expirationTime),
                slippage: outC.slippage,
                clmmExPriceX64: [maxFirstIn.data.clmmExPriceX64[0], outC.clmmExPriceX64[0]]
              });
            } catch (e) {
            }
          }
        }
        return outRoute.filter((i) => i.allTrade).sort((a, b) => a.amountOut.amount.raw.sub(b.amountOut.amount.raw).gt(ZERO2) ? -1 : 1);
      }
      static computeAmountOut({
        itemPool,
        tickCache,
        simulateCache,
        chainTime,
        epochInfo,
        mintInfos,
        slippage,
        outputToken,
        amountIn
      }) {
        if (itemPool.version === 6) {
          const {
            allTrade,
            realAmountIn,
            amountOut,
            minAmountOut,
            expirationTime,
            currentPrice,
            executionPrice,
            priceImpact,
            fee,
            remainingAccounts,
            executionPriceX64
          } = Clmm2.computeAmountOutFormat({
            poolInfo: itemPool,
            tickArrayCache: tickCache[itemPool.id.toString()],
            amountIn,
            currencyOut: outputToken,
            slippage,
            token2022Infos: mintInfos,
            epochInfo,
            catchLiquidityInsufficient: true
          });
          return {
            allTrade,
            amountIn: realAmountIn,
            amountOut,
            minAmountOut,
            currentPrice,
            executionPrice,
            priceImpact,
            fee: [fee],
            remainingAccounts: [remainingAccounts],
            routeType: "amm",
            poolKey: [itemPool],
            poolReady: itemPool.startTime < chainTime,
            poolType: "CLMM",
            expirationTime: minExpirationTime2(realAmountIn.expirationTime, expirationTime),
            slippage,
            clmmExPriceX64: [executionPriceX64]
          };
        } else {
          if (![1, 6, 7].includes(simulateCache[itemPool.id].status.toNumber()))
            throw Error("swap error");
          const { amountOut, minAmountOut, currentPrice, executionPrice, priceImpact, fee } = Liquidity2.computeAmountOut({
            poolKeys: jsonInfo2PoolKeys2(itemPool),
            poolInfo: simulateCache[itemPool.id],
            amountIn,
            currencyOut: outputToken,
            slippage
          });
          return {
            amountIn: { amount: amountIn, fee: void 0, expirationTime: void 0 },
            amountOut: { amount: amountOut, fee: void 0, expirationTime: void 0 },
            minAmountOut: { amount: minAmountOut, fee: void 0, expirationTime: void 0 },
            currentPrice,
            executionPrice,
            priceImpact,
            fee: [fee],
            routeType: "amm",
            poolKey: [itemPool],
            remainingAccounts: [],
            poolReady: simulateCache[itemPool.id].startTime.toNumber() < chainTime,
            poolType: itemPool.version === 5 ? "STABLE" : void 0,
            expirationTime: void 0,
            allTrade: true,
            slippage,
            clmmExPriceX64: [void 0]
          };
        }
      }
      static makeSwapInstruction({ routeProgram, ownerInfo, inputMint, swapInfo }) {
        var _a, _b, _c, _d, _e, _f;
        const slippage = swapInfo.slippage.numerator.toNumber() / swapInfo.slippage.denominator.toNumber();
        if (swapInfo.routeType === "amm") {
          if (swapInfo.poolKey[0].version === 6) {
            const _poolKey = swapInfo.poolKey[0];
            const sqrtPriceLimitX64 = inputMint.equals(_poolKey.mintA.mint) ? slippage > 0.5 || MIN_SQRT_PRICE_X642.add(ONE2).gt(swapInfo.clmmExPriceX64[0].div(new import_bn17.default(10))) ? MIN_SQRT_PRICE_X642.add(ONE2) : swapInfo.clmmExPriceX64[0].div(new import_bn17.default(10)) : slippage > 0.5 || MAX_SQRT_PRICE_X642.sub(ONE2).lt(swapInfo.clmmExPriceX64[0].mul(new import_bn17.default(10))) ? MAX_SQRT_PRICE_X642.sub(ONE2) : swapInfo.clmmExPriceX64[0].mul(new import_bn17.default(10));
            return Clmm2.makeSwapBaseInInstructions({
              poolInfo: _poolKey,
              ownerInfo: {
                wallet: ownerInfo.wallet,
                tokenAccountA: _poolKey.mintA.mint.equals(inputMint) ? ownerInfo.sourceToken : ownerInfo.destinationToken,
                tokenAccountB: _poolKey.mintA.mint.equals(inputMint) ? ownerInfo.destinationToken : ownerInfo.sourceToken
              },
              inputMint,
              amountIn: swapInfo.amountIn.amount.raw,
              amountOutMin: swapInfo.minAmountOut.amount.raw.sub((_b = (_a = swapInfo.minAmountOut.fee) == null ? void 0 : _a.raw) != null ? _b : ZERO2),
              sqrtPriceLimitX64,
              remainingAccounts: swapInfo.remainingAccounts[0]
            });
          } else {
            const _poolKey = swapInfo.poolKey[0];
            return Liquidity2.makeSwapInstruction({
              poolKeys: jsonInfo2PoolKeys2(_poolKey),
              userKeys: {
                tokenAccountIn: ownerInfo.sourceToken,
                tokenAccountOut: ownerInfo.destinationToken,
                owner: ownerInfo.wallet
              },
              amountIn: swapInfo.amountIn.amount.raw,
              amountOut: swapInfo.minAmountOut.amount.raw.sub((_d = (_c = swapInfo.minAmountOut.fee) == null ? void 0 : _c.raw) != null ? _d : ZERO2),
              fixedSide: "in"
            });
          }
        } else if (swapInfo.routeType === "route") {
          const poolKey1 = swapInfo.poolKey[0];
          const poolKey2 = swapInfo.poolKey[1];
          if (ownerInfo.routeToken === void 0)
            throw Error("owner route token account check error");
          return {
            address: {},
            innerTransaction: {
              instructions: [
                routeInstruction2(
                  routeProgram,
                  ownerInfo.wallet,
                  ownerInfo.sourceToken,
                  ownerInfo.routeToken,
                  ownerInfo.destinationToken,
                  inputMint.toString(),
                  swapInfo.middleToken.mint.toString(),
                  poolKey1,
                  poolKey2,
                  swapInfo.amountIn.amount.raw,
                  swapInfo.minAmountOut.amount.raw.sub((_f = (_e = swapInfo.minAmountOut.fee) == null ? void 0 : _e.raw) != null ? _f : ZERO2),
                  swapInfo.remainingAccounts
                )
              ],
              signers: [],
              lookupTableAddress: [
                poolKey1.lookupTableAccount ? new import_web325.PublicKey(poolKey1.lookupTableAccount) : import_web325.PublicKey.default,
                poolKey2.lookupTableAccount ? new import_web325.PublicKey(poolKey2.lookupTableAccount) : import_web325.PublicKey.default
              ].filter((i) => i && !i.equals(import_web325.PublicKey.default)),
              instructionTypes: [
                35
                /* routeSwap */
              ]
            }
          };
        } else {
          throw Error("route type error");
        }
      }
      static makeSwapInstructionSimple(_0) {
        return __async(this, arguments, function* ({
          connection,
          swapInfo,
          ownerInfo,
          computeBudgetConfig,
          routeProgram,
          makeTxVersion,
          lookupTableCache
        }) {
          const frontInstructions = [];
          const endInstructions = [];
          const frontInstructionsType = [];
          const endInstructionsType = [];
          const signers = [];
          const amountIn = swapInfo.amountIn;
          const amountOut = swapInfo.amountOut;
          const useSolBalance = !(amountIn.amount instanceof TokenAmount3);
          const outSolBalance = !(amountOut.amount instanceof TokenAmount3);
          const inputMint = amountIn.amount instanceof TokenAmount3 ? amountIn.amount.token.mint : Token3.WSOL.mint;
          const inputProgramId = amountIn.amount instanceof TokenAmount3 ? amountIn.amount.token.programId : Token3.WSOL.programId;
          const outputMint = amountOut.amount instanceof TokenAmount3 ? amountOut.amount.token.mint : Token3.WSOL.mint;
          const outputProgramId = amountOut.amount instanceof TokenAmount3 ? amountOut.amount.token.programId : Token3.WSOL.programId;
          const sourceToken = yield this._selectOrCreateTokenAccount({
            programId: inputProgramId,
            mint: inputMint,
            tokenAccounts: useSolBalance ? [] : ownerInfo.tokenAccounts,
            createInfo: useSolBalance ? {
              connection,
              payer: ownerInfo.wallet,
              amount: amountIn.amount.raw,
              frontInstructions,
              endInstructions,
              signers,
              frontInstructionsType,
              endInstructionsType
            } : void 0,
            owner: ownerInfo.wallet,
            associatedOnly: useSolBalance ? false : ownerInfo.associatedOnly,
            checkCreateATAOwner: ownerInfo.checkCreateATAOwner
          });
          if (sourceToken === void 0) {
            throw Error("input account check error");
          }
          const destinationToken = yield this._selectOrCreateTokenAccount({
            programId: outputProgramId,
            mint: outputMint,
            tokenAccounts: ownerInfo.tokenAccounts,
            createInfo: {
              connection,
              payer: ownerInfo.wallet,
              amount: 0,
              frontInstructions,
              endInstructions: outSolBalance ? endInstructions : void 0,
              signers,
              frontInstructionsType,
              endInstructionsType
            },
            owner: ownerInfo.wallet,
            associatedOnly: ownerInfo.associatedOnly,
            checkCreateATAOwner: ownerInfo.checkCreateATAOwner
          });
          let routeToken = void 0;
          if (swapInfo.routeType === "route") {
            const middleMint = swapInfo.middleToken;
            routeToken = yield this._selectOrCreateTokenAccount({
              programId: middleMint.programId,
              mint: middleMint.mint,
              tokenAccounts: ownerInfo.tokenAccounts,
              createInfo: {
                connection,
                payer: ownerInfo.wallet,
                amount: 0,
                frontInstructions,
                endInstructions,
                signers,
                frontInstructionsType,
                endInstructionsType
              },
              owner: ownerInfo.wallet,
              associatedOnly: false,
              checkCreateATAOwner: ownerInfo.checkCreateATAOwner
            });
          }
          const ins = this.makeSwapInstruction({
            routeProgram,
            inputMint,
            swapInfo,
            ownerInfo: {
              wallet: ownerInfo.wallet,
              sourceToken,
              routeToken,
              destinationToken
            }
          });
          const transferIns = [];
          const transferInsType = [];
          if (swapInfo.feeConfig !== void 0) {
            transferIns.push(
              (0, import_spl_token8.createTransferInstruction)(
                sourceToken,
                swapInfo.feeConfig.feeAccount,
                ownerInfo.wallet,
                swapInfo.feeConfig.feeAmount.toNumber()
              )
            );
            transferInsType.push(
              4
              /* transferAmount */
            );
          }
          const transferAddCheck = yield splitTxAndSigners({
            connection,
            makeTxVersion,
            computeBudgetConfig,
            payer: ownerInfo.wallet,
            innerTransaction: [
              { instructionTypes: transferInsType, instructions: transferIns, signers: [] },
              ins.innerTransaction
            ],
            lookupTableCache
          });
          return {
            address: ins.address,
            innerTransactions: yield splitTxAndSigners({
              connection,
              makeTxVersion,
              computeBudgetConfig,
              payer: ownerInfo.wallet,
              innerTransaction: [
                { instructionTypes: frontInstructionsType, instructions: frontInstructions, signers },
                ...transferAddCheck.length > 1 ? [] : [{ instructionTypes: transferInsType, instructions: transferIns, signers: [] }],
                ins.innerTransaction,
                { instructionTypes: endInstructionsType, instructions: endInstructions, signers: [] }
              ],
              lookupTableCache
            })
          };
        });
      }
    };
    var import_spl_token9 = require_cjs5();
    var import_web326 = require("@solana/web3.js");
    var import_bn18 = __toESM2(require_bn());
    function accountFlagsLayout(property = "accountFlags") {
      const ACCOUNT_FLAGS_LAYOUT = new WideBits2(property);
      ACCOUNT_FLAGS_LAYOUT.addBoolean("initialized");
      ACCOUNT_FLAGS_LAYOUT.addBoolean("market");
      ACCOUNT_FLAGS_LAYOUT.addBoolean("openOrders");
      ACCOUNT_FLAGS_LAYOUT.addBoolean("requestQueue");
      ACCOUNT_FLAGS_LAYOUT.addBoolean("eventQueue");
      ACCOUNT_FLAGS_LAYOUT.addBoolean("bids");
      ACCOUNT_FLAGS_LAYOUT.addBoolean("asks");
      return ACCOUNT_FLAGS_LAYOUT;
    }
    var MARKET_STATE_LAYOUT_V22 = struct3([
      blob4(5),
      accountFlagsLayout("accountFlags"),
      publicKey3("ownAddress"),
      u643("vaultSignerNonce"),
      publicKey3("baseMint"),
      publicKey3("quoteMint"),
      publicKey3("baseVault"),
      u643("baseDepositsTotal"),
      u643("baseFeesAccrued"),
      publicKey3("quoteVault"),
      u643("quoteDepositsTotal"),
      u643("quoteFeesAccrued"),
      u643("quoteDustThreshold"),
      publicKey3("requestQueue"),
      publicKey3("eventQueue"),
      publicKey3("bids"),
      publicKey3("asks"),
      u643("baseLotSize"),
      u643("quoteLotSize"),
      u643("feeRateBps"),
      u643("referrerRebatesAccrued"),
      blob4(7)
    ]);
    var MarketV2 = class extends Base {
      static makeCreateMarketInstructionSimple(_0) {
        return __async(this, arguments, function* ({
          connection,
          wallet,
          baseInfo,
          quoteInfo,
          lotSize,
          // 1
          tickSize,
          // 0.01
          dexProgramId,
          makeTxVersion,
          lookupTableCache,
          requestQueueSpacce,
          eventQueueSpacce,
          orderbookQueueSpacce
        }) {
          const market = generatePubKey2({ fromPublicKey: wallet, programId: dexProgramId });
          const requestQueue = generatePubKey2({ fromPublicKey: wallet, programId: dexProgramId });
          const eventQueue = generatePubKey2({ fromPublicKey: wallet, programId: dexProgramId });
          const bids = generatePubKey2({ fromPublicKey: wallet, programId: dexProgramId });
          const asks = generatePubKey2({ fromPublicKey: wallet, programId: dexProgramId });
          const baseVault = generatePubKey2({ fromPublicKey: wallet, programId: import_spl_token2.TOKEN_PROGRAM_ID });
          const quoteVault = generatePubKey2({ fromPublicKey: wallet, programId: import_spl_token2.TOKEN_PROGRAM_ID });
          const feeRateBps = 0;
          const quoteDustThreshold = new import_bn18.default(100);
          function getVaultOwnerAndNonce() {
            const vaultSignerNonce2 = new import_bn18.default(0);
            while (true) {
              try {
                const vaultOwner2 = import_web326.PublicKey.createProgramAddressSync(
                  [market.publicKey.toBuffer(), vaultSignerNonce2.toArrayLike(Buffer, "le", 8)],
                  dexProgramId
                );
                return { vaultOwner: vaultOwner2, vaultSignerNonce: vaultSignerNonce2 };
              } catch (e) {
                vaultSignerNonce2.iaddn(1);
                if (vaultSignerNonce2.gt(new import_bn18.default(25555)))
                  throw Error("find vault owner error");
              }
            }
          }
          const { vaultOwner, vaultSignerNonce } = getVaultOwnerAndNonce();
          const baseLotSize = new import_bn18.default(Math.round(__pow(10, baseInfo.decimals) * lotSize));
          const quoteLotSize = new import_bn18.default(Math.round(lotSize * __pow(10, quoteInfo.decimals) * tickSize));
          if (baseLotSize.eq(ZERO2))
            throw Error("lot size is too small");
          if (quoteLotSize.eq(ZERO2))
            throw Error("tick size or lot size is too small");
          const ins = yield this.makeCreateMarketInstruction({
            connection,
            wallet,
            marketInfo: {
              programId: dexProgramId,
              id: market,
              baseMint: baseInfo.mint,
              quoteMint: quoteInfo.mint,
              baseVault,
              quoteVault,
              vaultOwner,
              requestQueue,
              eventQueue,
              bids,
              asks,
              feeRateBps,
              quoteDustThreshold,
              vaultSignerNonce,
              baseLotSize,
              quoteLotSize,
              requestQueueSpacce,
              eventQueueSpacce,
              orderbookQueueSpacce
            }
          });
          return {
            address: ins.address,
            innerTransactions: yield splitTxAndSigners({
              connection,
              makeTxVersion,
              computeBudgetConfig: void 0,
              payer: wallet,
              innerTransaction: ins.innerTransactions,
              lookupTableCache
            })
          };
        });
      }
      static makeCreateMarketInstruction(_0) {
        return __async(this, arguments, function* ({
          connection,
          wallet,
          marketInfo
        }) {
          var _a, _b, _c, _d, _e, _f, _g, _h;
          const ins1 = [];
          const accountLamports = yield connection.getMinimumBalanceForRentExemption(165);
          ins1.push(
            import_web326.SystemProgram.createAccountWithSeed({
              fromPubkey: wallet,
              basePubkey: wallet,
              seed: marketInfo.baseVault.seed,
              newAccountPubkey: marketInfo.baseVault.publicKey,
              lamports: accountLamports,
              space: 165,
              programId: import_spl_token2.TOKEN_PROGRAM_ID
            }),
            import_web326.SystemProgram.createAccountWithSeed({
              fromPubkey: wallet,
              basePubkey: wallet,
              seed: marketInfo.quoteVault.seed,
              newAccountPubkey: marketInfo.quoteVault.publicKey,
              lamports: accountLamports,
              space: 165,
              programId: import_spl_token2.TOKEN_PROGRAM_ID
            }),
            (0, import_spl_token9.createInitializeAccountInstruction)(marketInfo.baseVault.publicKey, marketInfo.baseMint, marketInfo.vaultOwner),
            (0, import_spl_token9.createInitializeAccountInstruction)(marketInfo.quoteVault.publicKey, marketInfo.quoteMint, marketInfo.vaultOwner)
          );
          const ins2 = [];
          ins2.push(
            import_web326.SystemProgram.createAccountWithSeed({
              fromPubkey: wallet,
              basePubkey: wallet,
              seed: marketInfo.id.seed,
              newAccountPubkey: marketInfo.id.publicKey,
              lamports: yield connection.getMinimumBalanceForRentExemption(MARKET_STATE_LAYOUT_V22.span),
              space: MARKET_STATE_LAYOUT_V22.span,
              programId: marketInfo.programId
            }),
            import_web326.SystemProgram.createAccountWithSeed({
              fromPubkey: wallet,
              basePubkey: wallet,
              seed: marketInfo.requestQueue.seed,
              newAccountPubkey: marketInfo.requestQueue.publicKey,
              lamports: yield connection.getMinimumBalanceForRentExemption((_a = marketInfo.requestQueueSpacce) != null ? _a : 5120 + 12),
              space: (_b = marketInfo.requestQueueSpacce) != null ? _b : 5120 + 12,
              programId: marketInfo.programId
            }),
            import_web326.SystemProgram.createAccountWithSeed({
              fromPubkey: wallet,
              basePubkey: wallet,
              seed: marketInfo.eventQueue.seed,
              newAccountPubkey: marketInfo.eventQueue.publicKey,
              lamports: yield connection.getMinimumBalanceForRentExemption((_c = marketInfo.eventQueueSpacce) != null ? _c : 262144 + 12),
              space: (_d = marketInfo.eventQueueSpacce) != null ? _d : 262144 + 12,
              programId: marketInfo.programId
            }),
            import_web326.SystemProgram.createAccountWithSeed({
              fromPubkey: wallet,
              basePubkey: wallet,
              seed: marketInfo.bids.seed,
              newAccountPubkey: marketInfo.bids.publicKey,
              lamports: yield connection.getMinimumBalanceForRentExemption((_e = marketInfo.orderbookQueueSpacce) != null ? _e : 65536 + 12),
              space: (_f = marketInfo.orderbookQueueSpacce) != null ? _f : 65536 + 12,
              programId: marketInfo.programId
            }),
            import_web326.SystemProgram.createAccountWithSeed({
              fromPubkey: wallet,
              basePubkey: wallet,
              seed: marketInfo.asks.seed,
              newAccountPubkey: marketInfo.asks.publicKey,
              lamports: yield connection.getMinimumBalanceForRentExemption((_g = marketInfo.orderbookQueueSpacce) != null ? _g : 65536 + 12),
              space: (_h = marketInfo.orderbookQueueSpacce) != null ? _h : 65536 + 12,
              programId: marketInfo.programId
            }),
            this.initializeMarketInstruction({
              programId: marketInfo.programId,
              marketInfo: {
                id: marketInfo.id.publicKey,
                requestQueue: marketInfo.requestQueue.publicKey,
                eventQueue: marketInfo.eventQueue.publicKey,
                bids: marketInfo.bids.publicKey,
                asks: marketInfo.asks.publicKey,
                baseVault: marketInfo.baseVault.publicKey,
                quoteVault: marketInfo.quoteVault.publicKey,
                baseMint: marketInfo.baseMint,
                quoteMint: marketInfo.quoteMint,
                baseLotSize: marketInfo.baseLotSize,
                quoteLotSize: marketInfo.quoteLotSize,
                feeRateBps: marketInfo.feeRateBps,
                vaultSignerNonce: marketInfo.vaultSignerNonce,
                quoteDustThreshold: marketInfo.quoteDustThreshold
              }
            })
          );
          return {
            address: {
              marketId: marketInfo.id.publicKey,
              requestQueue: marketInfo.requestQueue.publicKey,
              eventQueue: marketInfo.eventQueue.publicKey,
              bids: marketInfo.bids.publicKey,
              asks: marketInfo.asks.publicKey,
              baseVault: marketInfo.baseVault.publicKey,
              quoteVault: marketInfo.quoteVault.publicKey,
              baseMint: marketInfo.baseMint,
              quoteMint: marketInfo.quoteMint
            },
            innerTransactions: [
              {
                instructions: ins1,
                signers: [],
                instructionTypes: [
                  0,
                  0,
                  1,
                  1
                  /* initAccount */
                ]
              },
              {
                instructions: ins2,
                signers: [],
                instructionTypes: [
                  0,
                  0,
                  0,
                  0,
                  0,
                  7
                  /* initMarket */
                ]
              }
            ]
          };
        });
      }
      static initializeMarketInstruction({
        programId,
        marketInfo
      }) {
        const dataLayout = struct3([
          u822("version"),
          u3222("instruction"),
          u643("baseLotSize"),
          u643("quoteLotSize"),
          u162("feeRateBps"),
          u643("vaultSignerNonce"),
          u643("quoteDustThreshold")
        ]);
        const keys = [
          { pubkey: marketInfo.id, isSigner: false, isWritable: true },
          { pubkey: marketInfo.requestQueue, isSigner: false, isWritable: true },
          { pubkey: marketInfo.eventQueue, isSigner: false, isWritable: true },
          { pubkey: marketInfo.bids, isSigner: false, isWritable: true },
          { pubkey: marketInfo.asks, isSigner: false, isWritable: true },
          { pubkey: marketInfo.baseVault, isSigner: false, isWritable: true },
          { pubkey: marketInfo.quoteVault, isSigner: false, isWritable: true },
          { pubkey: marketInfo.baseMint, isSigner: false, isWritable: false },
          { pubkey: marketInfo.quoteMint, isSigner: false, isWritable: false },
          // Use a dummy address if using the new dex upgrade to save tx space.
          {
            pubkey: marketInfo.authority ? marketInfo.quoteMint : import_web332.SYSVAR_RENT_PUBKEY,
            isSigner: false,
            isWritable: false
          }
        ].concat(marketInfo.authority ? { pubkey: marketInfo.authority, isSigner: false, isWritable: false } : []).concat(
          marketInfo.authority && marketInfo.pruneAuthority ? { pubkey: marketInfo.pruneAuthority, isSigner: false, isWritable: false } : []
        );
        const data = Buffer.alloc(dataLayout.span);
        dataLayout.encode(
          {
            version: 0,
            instruction: 0,
            baseLotSize: marketInfo.baseLotSize,
            quoteLotSize: marketInfo.quoteLotSize,
            feeRateBps: marketInfo.feeRateBps,
            vaultSignerNonce: marketInfo.vaultSignerNonce,
            quoteDustThreshold: marketInfo.quoteDustThreshold
          },
          data
        );
        return new import_web326.TransactionInstruction({
          keys,
          programId,
          data
        });
      }
    };
    var import_web327 = require("@solana/web3.js");
    var import_bn19 = __toESM2(require_bn());
    var _Utils1216 = class _Utils1216 extends Base {
      // pda
      static getPdaPoolId(programId, ammId) {
        return findProgramAddress2([this.SEED_CONFIG.pool.id, ammId.toBuffer()], programId);
      }
      static getPdaOwnerId(programId, poolId, owner, version2) {
        return findProgramAddress2(
          [
            this.SEED_CONFIG.owner.id,
            poolId.toBuffer(),
            owner.toBuffer(),
            // new BN(version).toBuffer()
            Buffer.from(new import_bn19.default(version2).toArray())
          ],
          programId
        );
      }
      static getAllInfo(_0) {
        return __async(this, arguments, function* ({
          connection,
          programId,
          poolIds,
          wallet,
          chainTime
        }) {
          if (poolIds.length === 0)
            return [];
          const allPoolPda = poolIds.map((id) => this.getPdaPoolId(programId, id).publicKey);
          const allOwnerPda = [];
          for (let itemVersion = 0; itemVersion < this.VERSION_PROJECT.length; itemVersion++) {
            allOwnerPda.push(...allPoolPda.map((id) => this.getPdaOwnerId(programId, id, wallet, itemVersion).publicKey));
          }
          const pdaInfo = yield getMultipleAccountsInfo2(connection, [...allPoolPda, ...allOwnerPda]);
          const info = [];
          for (let index = 0; index < pdaInfo.length; index++) {
            const version2 = Math.floor(index / poolIds.length);
            const i = index % poolIds.length;
            const itemPoolId = allPoolPda[i];
            const itemOwnerId = allOwnerPda[index];
            const itemPoolInfoS = pdaInfo[i];
            const itemOwnerInfoS = pdaInfo[poolIds.length + index];
            if (!(itemPoolInfoS && itemOwnerInfoS))
              continue;
            if (itemPoolInfoS.data.length !== this.POOL_LAYOUT.span || itemOwnerInfoS.data.length !== this.OWNER_LAYOUT.span)
              continue;
            const itemPoolInfo = this.POOL_LAYOUT.decode(itemPoolInfoS.data);
            const itemOwnerInfo = this.OWNER_LAYOUT.decode(itemOwnerInfoS.data);
            const openTime = itemPoolInfo.openTime.toNumber();
            const endTime = itemPoolInfo.endTime.toNumber();
            const hasCanClaimToken = itemOwnerInfo.tokenInfo.map((i2) => i2.debtAmount.gt(new import_bn19.default(0))).filter((i2) => !i2).length !== 3;
            const inCanClaimTime = chainTime > openTime && chainTime < endTime && itemPoolInfo.status === 1;
            const canClaim = hasCanClaimToken && inCanClaimTime;
            info.push({
              programId,
              poolId: itemPoolId,
              ammId: itemPoolInfo.ammId,
              ownerAccountId: itemOwnerId,
              snapshotLpAmount: itemOwnerInfo.lpAmount,
              project: this.VERSION_PROJECT[version2],
              openTime,
              endTime,
              canClaim,
              canClaimErrorType: !hasCanClaimToken ? "alreadyClaimIt" : !inCanClaimTime ? "outOfOperationalTime" : void 0,
              tokenInfo: itemPoolInfo.tokenInfo.map((itemPoolToken, i2) => ({
                programId: import_spl_token2.TOKEN_PROGRAM_ID,
                mintAddress: itemPoolToken.mintAddress,
                mintVault: itemPoolToken.mintVault,
                mintDecimals: itemPoolToken.mintDecimals,
                perLpLoss: itemPoolToken.perLpLoss,
                debtAmount: itemOwnerInfo.tokenInfo[i2].debtAmount.add(itemOwnerInfo.tokenInfo[i2].claimedAmount)
              }))
            });
          }
          return info;
        });
      }
      static makeClaimInstructionSimple(_0) {
        return __async(this, arguments, function* ({
          connection,
          poolInfo,
          ownerInfo,
          makeTxVersion,
          lookupTableCache
        }) {
          const frontInstructions = [];
          const frontInstructionsType = [];
          const endInstructions = [];
          const endInstructionsType = [];
          const instructions = [];
          const instructionsType = [];
          const signers = [];
          const ownerVaultList = [];
          for (const itemToken of poolInfo.tokenInfo) {
            ownerVaultList.push(
              yield this._selectOrCreateTokenAccount({
                programId: itemToken.programId,
                mint: itemToken.mintAddress,
                tokenAccounts: itemToken.mintAddress.equals(Token3.WSOL.mint) ? [] : ownerInfo.tokenAccounts,
                owner: ownerInfo.wallet,
                createInfo: {
                  connection,
                  payer: ownerInfo.wallet,
                  amount: 0,
                  frontInstructions,
                  endInstructions: itemToken.mintAddress.equals(Token3.WSOL.mint) ? endInstructions : [],
                  frontInstructionsType,
                  endInstructionsType,
                  signers
                },
                associatedOnly: itemToken.mintAddress.equals(Token3.WSOL.mint) ? false : ownerInfo.associatedOnly,
                checkCreateATAOwner: ownerInfo.checkCreateATAOwner
              })
            );
          }
          instructions.push(
            this.makeClaimInstruction({
              programId: poolInfo.programId,
              poolInfo,
              ownerInfo: {
                wallet: ownerInfo.wallet,
                ownerPda: poolInfo.ownerAccountId,
                claimAddress: ownerVaultList
              }
            })
          );
          instructionsType.push(
            8
            /* util1216OwnerClaim */
          );
          return {
            address: {},
            innerTransactions: yield splitTxAndSigners({
              connection,
              makeTxVersion,
              computeBudgetConfig: void 0,
              payer: ownerInfo.wallet,
              innerTransaction: [
                { instructionTypes: frontInstructionsType, instructions: frontInstructions, signers },
                { instructionTypes: instructionsType, instructions, signers: [] },
                { instructionTypes: endInstructionsType, instructions: endInstructions, signers: [] }
              ],
              lookupTableCache
            })
          };
        });
      }
      static makeClaimAllInstructionSimple(_0) {
        return __async(this, arguments, function* ({
          connection,
          poolInfos,
          ownerInfo,
          makeTxVersion,
          lookupTableCache
        }) {
          var _a;
          const frontInstructions = [];
          const frontInstructionsType = [];
          const endInstructions = [];
          const endInstructionsType = [];
          const instructions = [];
          const instructionsType = [];
          const signers = [];
          const tempNewVault = {};
          for (const poolInfo of poolInfos) {
            const ownerVaultList = [];
            for (const itemToken of poolInfo.tokenInfo) {
              const tempVault = (_a = tempNewVault[itemToken.mintAddress.toString()]) != null ? _a : yield this._selectOrCreateTokenAccount({
                programId: itemToken.programId,
                mint: itemToken.mintAddress,
                tokenAccounts: itemToken.mintAddress.equals(Token3.WSOL.mint) ? [] : ownerInfo.tokenAccounts,
                owner: ownerInfo.wallet,
                createInfo: {
                  connection,
                  payer: ownerInfo.wallet,
                  amount: 0,
                  frontInstructions,
                  endInstructions: itemToken.mintAddress.equals(Token3.WSOL.mint) ? endInstructions : [],
                  frontInstructionsType,
                  endInstructionsType,
                  signers
                },
                associatedOnly: itemToken.mintAddress.equals(Token3.WSOL.mint) ? false : ownerInfo.associatedOnly,
                checkCreateATAOwner: ownerInfo.checkCreateATAOwner
              });
              tempNewVault[itemToken.mintAddress.toString()] = tempVault;
              ownerVaultList.push(tempVault);
            }
            instructions.push(
              this.makeClaimInstruction({
                programId: poolInfo.programId,
                poolInfo,
                ownerInfo: {
                  wallet: ownerInfo.wallet,
                  ownerPda: poolInfo.ownerAccountId,
                  claimAddress: ownerVaultList
                }
              })
            );
            instructionsType.push(
              8
              /* util1216OwnerClaim */
            );
          }
          return {
            address: {},
            innerTransactions: yield splitTxAndSigners({
              connection,
              makeTxVersion,
              computeBudgetConfig: void 0,
              payer: ownerInfo.wallet,
              innerTransaction: [
                { instructionTypes: frontInstructionsType, instructions: frontInstructions, signers },
                { instructionTypes: instructionsType, instructions, signers: [] },
                { instructionTypes: endInstructionsType, instructions: endInstructions, signers: [] }
              ],
              lookupTableCache
            })
          };
        });
      }
      static makeClaimInstruction({
        programId,
        poolInfo,
        ownerInfo
      }) {
        const dataLayout = struct3([]);
        const keys = [
          { pubkey: ownerInfo.wallet, isSigner: true, isWritable: true },
          { pubkey: poolInfo.poolId, isSigner: false, isWritable: true },
          { pubkey: ownerInfo.ownerPda, isSigner: false, isWritable: true },
          ...ownerInfo.claimAddress.map((i) => ({ pubkey: i, isSigner: false, isWritable: true })),
          ...poolInfo.tokenInfo.map(({ mintVault }) => ({ pubkey: mintVault, isSigner: false, isWritable: true })),
          { pubkey: import_spl_token2.TOKEN_PROGRAM_ID, isSigner: false, isWritable: false }
        ];
        const data = Buffer.alloc(dataLayout.span);
        dataLayout.encode({}, data);
        const aData = Buffer.from([...[10, 66, 208, 184, 161, 6, 191, 98], ...data]);
        return new import_web327.TransactionInstruction({
          keys,
          programId,
          data: aData
        });
      }
    };
    _Utils1216.CLAIMED_NUM = 3;
    _Utils1216.POOL_LAYOUT = struct3([
      blob4(8),
      u822("bump"),
      u822("status"),
      u643("openTime"),
      u643("endTime"),
      publicKey3("ammId"),
      seq22(
        struct3([
          u822("mintDecimals"),
          publicKey3("mintAddress"),
          publicKey3("mintVault"),
          u643("perLpLoss"),
          u643("totalClaimedAmount")
        ]),
        _Utils1216.CLAIMED_NUM,
        "tokenInfo"
      ),
      seq22(u643(), 10, "padding")
    ]);
    _Utils1216.OWNER_LAYOUT = struct3([
      blob4(8),
      u822("bump"),
      u822("version"),
      publicKey3("poolId"),
      publicKey3("owner"),
      u643("lpAmount"),
      seq22(struct3([publicKey3("mintAddress"), u643("debtAmount"), u643("claimedAmount")]), _Utils1216.CLAIMED_NUM, "tokenInfo"),
      seq22(u643(), 4, "padding")
    ]);
    _Utils1216.DEFAULT_POOL_ID = [
      "58oQChx4yWmvKdwLLZzBi4ChoCc2fqCUWBkwMihLYQo2",
      "6UmmUiYoBjSrhakAobJw8BvkmJtDVxaeBtbt7rxWo1mg",
      "AVs9TA4nWDzfPJE9gGVNJMVhcQy3V9PGazuz33BfG2RA",
      "DVa7Qmb5ct9RCpaU7UTpSaf3GVMYz17vNVU67XpdCRut",
      "7XawhbbxtsRcQA8KTkHT9f9nc6d69UwqCDh6U5EEbEmX",
      "6a1CsrpeZubDjEJE9s1CMVheB6HWM5d7m1cj2jkhyXhj",
      "EoNrn8iUhwgJySD1pHu8Qxm5gSQqLK3za4m8xzD2RuEb",
      "AceAyRTWt4PyB2pHqf2qhDgNZDtKVNaxgL8Ru3V4aN1P",
      "6tmFJbMk5yVHFcFy7X2K8RwHjKLr6KVFLYXpgpBNeAxB"
    ].map((i) => new import_web327.PublicKey(i));
    _Utils1216.SEED_CONFIG = {
      pool: {
        id: Buffer.from("pool_seed", "utf8")
      },
      owner: {
        id: Buffer.from("user_claim_seed", "utf8")
      }
    };
    _Utils1216.VERSION_PROJECT = [void 0, "Francium", "Tulip", "Larix"];
    var Utils1216 = _Utils1216;
  }
});

// node_modules/base-x/src/index.js
var require_src2 = __commonJS({
  "node_modules/base-x/src/index.js"(exports2, module2) {
    "use strict";
    function base(ALPHABET) {
      if (ALPHABET.length >= 255) {
        throw new TypeError("Alphabet too long");
      }
      var BASE_MAP = new Uint8Array(256);
      for (var j = 0; j < BASE_MAP.length; j++) {
        BASE_MAP[j] = 255;
      }
      for (var i = 0; i < ALPHABET.length; i++) {
        var x = ALPHABET.charAt(i);
        var xc = x.charCodeAt(0);
        if (BASE_MAP[xc] !== 255) {
          throw new TypeError(x + " is ambiguous");
        }
        BASE_MAP[xc] = i;
      }
      var BASE3 = ALPHABET.length;
      var LEADER = ALPHABET.charAt(0);
      var FACTOR = Math.log(BASE3) / Math.log(256);
      var iFACTOR = Math.log(256) / Math.log(BASE3);
      function encode(source) {
        if (source instanceof Uint8Array) {
        } else if (ArrayBuffer.isView(source)) {
          source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
        } else if (Array.isArray(source)) {
          source = Uint8Array.from(source);
        }
        if (!(source instanceof Uint8Array)) {
          throw new TypeError("Expected Uint8Array");
        }
        if (source.length === 0) {
          return "";
        }
        var zeroes = 0;
        var length = 0;
        var pbegin = 0;
        var pend = source.length;
        while (pbegin !== pend && source[pbegin] === 0) {
          pbegin++;
          zeroes++;
        }
        var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
        var b58 = new Uint8Array(size);
        while (pbegin !== pend) {
          var carry = source[pbegin];
          var i2 = 0;
          for (var it1 = size - 1; (carry !== 0 || i2 < length) && it1 !== -1; it1--, i2++) {
            carry += 256 * b58[it1] >>> 0;
            b58[it1] = carry % BASE3 >>> 0;
            carry = carry / BASE3 >>> 0;
          }
          if (carry !== 0) {
            throw new Error("Non-zero carry");
          }
          length = i2;
          pbegin++;
        }
        var it2 = size - length;
        while (it2 !== size && b58[it2] === 0) {
          it2++;
        }
        var str2 = LEADER.repeat(zeroes);
        for (; it2 < size; ++it2) {
          str2 += ALPHABET.charAt(b58[it2]);
        }
        return str2;
      }
      function decodeUnsafe(source) {
        if (typeof source !== "string") {
          throw new TypeError("Expected String");
        }
        if (source.length === 0) {
          return new Uint8Array();
        }
        var psz = 0;
        var zeroes = 0;
        var length = 0;
        while (source[psz] === LEADER) {
          zeroes++;
          psz++;
        }
        var size = (source.length - psz) * FACTOR + 1 >>> 0;
        var b256 = new Uint8Array(size);
        while (source[psz]) {
          var charCode = source.charCodeAt(psz);
          if (charCode > 255) {
            return;
          }
          var carry = BASE_MAP[charCode];
          if (carry === 255) {
            return;
          }
          var i2 = 0;
          for (var it3 = size - 1; (carry !== 0 || i2 < length) && it3 !== -1; it3--, i2++) {
            carry += BASE3 * b256[it3] >>> 0;
            b256[it3] = carry % 256 >>> 0;
            carry = carry / 256 >>> 0;
          }
          if (carry !== 0) {
            throw new Error("Non-zero carry");
          }
          length = i2;
          psz++;
        }
        var it4 = size - length;
        while (it4 !== size && b256[it4] === 0) {
          it4++;
        }
        var vch = new Uint8Array(zeroes + (size - it4));
        var j2 = zeroes;
        while (it4 !== size) {
          vch[j2++] = b256[it4++];
        }
        return vch;
      }
      function decode(string) {
        var buffer = decodeUnsafe(string);
        if (buffer) {
          return buffer;
        }
        throw new Error("Non-base" + BASE3 + " character");
      }
      return {
        encode,
        decodeUnsafe,
        decode
      };
    }
    module2.exports = base;
  }
});

// node_modules/bs58/index.js
var require_bs58 = __commonJS({
  "node_modules/bs58/index.js"(exports2, module2) {
    var basex = require_src2();
    var ALPHABET = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
    module2.exports = basex(ALPHABET);
  }
});

// raydium_daemon.ts
var import_web33 = require("@solana/web3.js");
var import_raydium_sdk_v2 = __toESM(require_lib());
var import_raydium_sdk = __toESM(require_dist());

// node_modules/@solana/spl-token/lib/esm/constants.js
var import_web3 = require("@solana/web3.js");
var TOKEN_PROGRAM_ID2 = new import_web3.PublicKey("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA");
var TOKEN_2022_PROGRAM_ID = new import_web3.PublicKey("TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb");
var ASSOCIATED_TOKEN_PROGRAM_ID2 = new import_web3.PublicKey("ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL");
var NATIVE_MINT = new import_web3.PublicKey("So11111111111111111111111111111111111111112");
var NATIVE_MINT_2022 = new import_web3.PublicKey("9pan9bMn5HatX4EJdBwg9VgCa7Uz5HL8N1m5D3NdXejP");

// node_modules/@solana/buffer-layout-utils/lib/esm/base.mjs
var encodeDecode = (layout) => {
  const decode = layout.decode.bind(layout);
  const encode = layout.encode.bind(layout);
  return { decode, encode };
};

// node_modules/@solana/buffer-layout-utils/lib/esm/bigint.mjs
var import_buffer_layout = __toESM(require_Layout(), 1);
var import_bigint_buffer = __toESM(require_node2(), 1);
var bigInt = (length) => (property) => {
  const layout = (0, import_buffer_layout.blob)(length, property);
  const { encode, decode } = encodeDecode(layout);
  const bigIntLayout = layout;
  bigIntLayout.decode = (buffer, offset2) => {
    const src = decode(buffer, offset2);
    return (0, import_bigint_buffer.toBigIntLE)(Buffer.from(src));
  };
  bigIntLayout.encode = (bigInt2, buffer, offset2) => {
    const src = (0, import_bigint_buffer.toBufferLE)(bigInt2, length);
    return encode(src, buffer, offset2);
  };
  return bigIntLayout;
};
var bigIntBE = (length) => (property) => {
  const layout = (0, import_buffer_layout.blob)(length, property);
  const { encode, decode } = encodeDecode(layout);
  const bigIntLayout = layout;
  bigIntLayout.decode = (buffer, offset2) => {
    const src = decode(buffer, offset2);
    return (0, import_bigint_buffer.toBigIntBE)(Buffer.from(src));
  };
  bigIntLayout.encode = (bigInt2, buffer, offset2) => {
    const src = (0, import_bigint_buffer.toBufferBE)(bigInt2, length);
    return encode(src, buffer, offset2);
  };
  return bigIntLayout;
};
var u642 = bigInt(8);
var u64be = bigIntBE(8);
var u1282 = bigInt(16);
var u128be = bigIntBE(16);
var u192 = bigInt(24);
var u192be = bigIntBE(24);
var u256 = bigInt(32);
var u256be = bigIntBE(32);

// node_modules/bignumber.js/bignumber.mjs
var isNumeric = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i;
var mathceil = Math.ceil;
var mathfloor = Math.floor;
var bignumberError = "[BigNumber Error] ";
var tooManyDigits = bignumberError + "Number primitive has more than 15 significant digits: ";
var BASE = 1e14;
var LOG_BASE = 14;
var MAX_SAFE_INTEGER = 9007199254740991;
var POWS_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13];
var SQRT_BASE = 1e7;
var MAX = 1e9;
function clone(configObject) {
  var div3, convertBase2, parseNumeric, P2 = BigNumber2.prototype = { constructor: BigNumber2, toString: null, valueOf: null }, ONE2 = new BigNumber2(1), DECIMAL_PLACES = 20, ROUNDING_MODE = 4, TO_EXP_NEG = -7, TO_EXP_POS = 21, MIN_EXP = -1e7, MAX_EXP = 1e7, CRYPTO = false, MODULO_MODE = 1, POW_PRECISION = 0, FORMAT = {
    prefix: "",
    groupSize: 3,
    secondaryGroupSize: 0,
    groupSeparator: ",",
    decimalSeparator: ".",
    fractionGroupSize: 0,
    fractionGroupSeparator: "\xA0",
    // non-breaking space
    suffix: ""
  }, ALPHABET = "0123456789abcdefghijklmnopqrstuvwxyz", alphabetHasNormalDecimalDigits = true;
  function BigNumber2(v, b) {
    var alphabet, c, caseChanged, e, i, isNum, len, str2, x = this;
    if (!(x instanceof BigNumber2))
      return new BigNumber2(v, b);
    if (b == null) {
      if (v && v._isBigNumber === true) {
        x.s = v.s;
        if (!v.c || v.e > MAX_EXP) {
          x.c = x.e = null;
        } else if (v.e < MIN_EXP) {
          x.c = [x.e = 0];
        } else {
          x.e = v.e;
          x.c = v.c.slice();
        }
        return;
      }
      if ((isNum = typeof v == "number") && v * 0 == 0) {
        x.s = 1 / v < 0 ? (v = -v, -1) : 1;
        if (v === ~~v) {
          for (e = 0, i = v; i >= 10; i /= 10, e++)
            ;
          if (e > MAX_EXP) {
            x.c = x.e = null;
          } else {
            x.e = e;
            x.c = [v];
          }
          return;
        }
        str2 = String(v);
      } else {
        if (!isNumeric.test(str2 = String(v)))
          return parseNumeric(x, str2, isNum);
        x.s = str2.charCodeAt(0) == 45 ? (str2 = str2.slice(1), -1) : 1;
      }
      if ((e = str2.indexOf(".")) > -1)
        str2 = str2.replace(".", "");
      if ((i = str2.search(/e/i)) > 0) {
        if (e < 0)
          e = i;
        e += +str2.slice(i + 1);
        str2 = str2.substring(0, i);
      } else if (e < 0) {
        e = str2.length;
      }
    } else {
      intCheck(b, 2, ALPHABET.length, "Base");
      if (b == 10 && alphabetHasNormalDecimalDigits) {
        x = new BigNumber2(v);
        return round2(x, DECIMAL_PLACES + x.e + 1, ROUNDING_MODE);
      }
      str2 = String(v);
      if (isNum = typeof v == "number") {
        if (v * 0 != 0)
          return parseNumeric(x, str2, isNum, b);
        x.s = 1 / v < 0 ? (str2 = str2.slice(1), -1) : 1;
        if (BigNumber2.DEBUG && str2.replace(/^0\.0*|\./, "").length > 15) {
          throw Error(tooManyDigits + v);
        }
      } else {
        x.s = str2.charCodeAt(0) === 45 ? (str2 = str2.slice(1), -1) : 1;
      }
      alphabet = ALPHABET.slice(0, b);
      e = i = 0;
      for (len = str2.length; i < len; i++) {
        if (alphabet.indexOf(c = str2.charAt(i)) < 0) {
          if (c == ".") {
            if (i > e) {
              e = len;
              continue;
            }
          } else if (!caseChanged) {
            if (str2 == str2.toUpperCase() && (str2 = str2.toLowerCase()) || str2 == str2.toLowerCase() && (str2 = str2.toUpperCase())) {
              caseChanged = true;
              i = -1;
              e = 0;
              continue;
            }
          }
          return parseNumeric(x, String(v), isNum, b);
        }
      }
      isNum = false;
      str2 = convertBase2(str2, b, 10, x.s);
      if ((e = str2.indexOf(".")) > -1)
        str2 = str2.replace(".", "");
      else
        e = str2.length;
    }
    for (i = 0; str2.charCodeAt(i) === 48; i++)
      ;
    for (len = str2.length; str2.charCodeAt(--len) === 48; )
      ;
    if (str2 = str2.slice(i, ++len)) {
      len -= i;
      if (isNum && BigNumber2.DEBUG && len > 15 && (v > MAX_SAFE_INTEGER || v !== mathfloor(v))) {
        throw Error(tooManyDigits + x.s * v);
      }
      if ((e = e - i - 1) > MAX_EXP) {
        x.c = x.e = null;
      } else if (e < MIN_EXP) {
        x.c = [x.e = 0];
      } else {
        x.e = e;
        x.c = [];
        i = (e + 1) % LOG_BASE;
        if (e < 0)
          i += LOG_BASE;
        if (i < len) {
          if (i)
            x.c.push(+str2.slice(0, i));
          for (len -= LOG_BASE; i < len; ) {
            x.c.push(+str2.slice(i, i += LOG_BASE));
          }
          i = LOG_BASE - (str2 = str2.slice(i)).length;
        } else {
          i -= len;
        }
        for (; i--; str2 += "0")
          ;
        x.c.push(+str2);
      }
    } else {
      x.c = [x.e = 0];
    }
  }
  BigNumber2.clone = clone;
  BigNumber2.ROUND_UP = 0;
  BigNumber2.ROUND_DOWN = 1;
  BigNumber2.ROUND_CEIL = 2;
  BigNumber2.ROUND_FLOOR = 3;
  BigNumber2.ROUND_HALF_UP = 4;
  BigNumber2.ROUND_HALF_DOWN = 5;
  BigNumber2.ROUND_HALF_EVEN = 6;
  BigNumber2.ROUND_HALF_CEIL = 7;
  BigNumber2.ROUND_HALF_FLOOR = 8;
  BigNumber2.EUCLID = 9;
  BigNumber2.config = BigNumber2.set = function(obj) {
    var p, v;
    if (obj != null) {
      if (typeof obj == "object") {
        if (obj.hasOwnProperty(p = "DECIMAL_PLACES")) {
          v = obj[p];
          intCheck(v, 0, MAX, p);
          DECIMAL_PLACES = v;
        }
        if (obj.hasOwnProperty(p = "ROUNDING_MODE")) {
          v = obj[p];
          intCheck(v, 0, 8, p);
          ROUNDING_MODE = v;
        }
        if (obj.hasOwnProperty(p = "EXPONENTIAL_AT")) {
          v = obj[p];
          if (v && v.pop) {
            intCheck(v[0], -MAX, 0, p);
            intCheck(v[1], 0, MAX, p);
            TO_EXP_NEG = v[0];
            TO_EXP_POS = v[1];
          } else {
            intCheck(v, -MAX, MAX, p);
            TO_EXP_NEG = -(TO_EXP_POS = v < 0 ? -v : v);
          }
        }
        if (obj.hasOwnProperty(p = "RANGE")) {
          v = obj[p];
          if (v && v.pop) {
            intCheck(v[0], -MAX, -1, p);
            intCheck(v[1], 1, MAX, p);
            MIN_EXP = v[0];
            MAX_EXP = v[1];
          } else {
            intCheck(v, -MAX, MAX, p);
            if (v) {
              MIN_EXP = -(MAX_EXP = v < 0 ? -v : v);
            } else {
              throw Error(bignumberError + p + " cannot be zero: " + v);
            }
          }
        }
        if (obj.hasOwnProperty(p = "CRYPTO")) {
          v = obj[p];
          if (v === !!v) {
            if (v) {
              if (typeof crypto != "undefined" && crypto && (crypto.getRandomValues || crypto.randomBytes)) {
                CRYPTO = v;
              } else {
                CRYPTO = !v;
                throw Error(bignumberError + "crypto unavailable");
              }
            } else {
              CRYPTO = v;
            }
          } else {
            throw Error(bignumberError + p + " not true or false: " + v);
          }
        }
        if (obj.hasOwnProperty(p = "MODULO_MODE")) {
          v = obj[p];
          intCheck(v, 0, 9, p);
          MODULO_MODE = v;
        }
        if (obj.hasOwnProperty(p = "POW_PRECISION")) {
          v = obj[p];
          intCheck(v, 0, MAX, p);
          POW_PRECISION = v;
        }
        if (obj.hasOwnProperty(p = "FORMAT")) {
          v = obj[p];
          if (typeof v == "object")
            FORMAT = v;
          else
            throw Error(bignumberError + p + " not an object: " + v);
        }
        if (obj.hasOwnProperty(p = "ALPHABET")) {
          v = obj[p];
          if (typeof v == "string" && !/^.?$|[+\-.\s]|(.).*\1/.test(v)) {
            alphabetHasNormalDecimalDigits = v.slice(0, 10) == "0123456789";
            ALPHABET = v;
          } else {
            throw Error(bignumberError + p + " invalid: " + v);
          }
        }
      } else {
        throw Error(bignumberError + "Object expected: " + obj);
      }
    }
    return {
      DECIMAL_PLACES,
      ROUNDING_MODE,
      EXPONENTIAL_AT: [TO_EXP_NEG, TO_EXP_POS],
      RANGE: [MIN_EXP, MAX_EXP],
      CRYPTO,
      MODULO_MODE,
      POW_PRECISION,
      FORMAT,
      ALPHABET
    };
  };
  BigNumber2.isBigNumber = function(v) {
    if (!v || v._isBigNumber !== true)
      return false;
    if (!BigNumber2.DEBUG)
      return true;
    var i, n, c = v.c, e = v.e, s = v.s;
    out:
      if ({}.toString.call(c) == "[object Array]") {
        if ((s === 1 || s === -1) && e >= -MAX && e <= MAX && e === mathfloor(e)) {
          if (c[0] === 0) {
            if (e === 0 && c.length === 1)
              return true;
            break out;
          }
          i = (e + 1) % LOG_BASE;
          if (i < 1)
            i += LOG_BASE;
          if (String(c[0]).length == i) {
            for (i = 0; i < c.length; i++) {
              n = c[i];
              if (n < 0 || n >= BASE || n !== mathfloor(n))
                break out;
            }
            if (n !== 0)
              return true;
          }
        }
      } else if (c === null && e === null && (s === null || s === 1 || s === -1)) {
        return true;
      }
    throw Error(bignumberError + "Invalid BigNumber: " + v);
  };
  BigNumber2.maximum = BigNumber2.max = function() {
    return maxOrMin2(arguments, -1);
  };
  BigNumber2.minimum = BigNumber2.min = function() {
    return maxOrMin2(arguments, 1);
  };
  BigNumber2.random = function() {
    var pow2_53 = 9007199254740992;
    var random53bitInt = Math.random() * pow2_53 & 2097151 ? function() {
      return mathfloor(Math.random() * pow2_53);
    } : function() {
      return (Math.random() * 1073741824 | 0) * 8388608 + (Math.random() * 8388608 | 0);
    };
    return function(dp) {
      var a, b, e, k, v, i = 0, c = [], rand = new BigNumber2(ONE2);
      if (dp == null)
        dp = DECIMAL_PLACES;
      else
        intCheck(dp, 0, MAX);
      k = mathceil(dp / LOG_BASE);
      if (CRYPTO) {
        if (crypto.getRandomValues) {
          a = crypto.getRandomValues(new Uint32Array(k *= 2));
          for (; i < k; ) {
            v = a[i] * 131072 + (a[i + 1] >>> 11);
            if (v >= 9e15) {
              b = crypto.getRandomValues(new Uint32Array(2));
              a[i] = b[0];
              a[i + 1] = b[1];
            } else {
              c.push(v % 1e14);
              i += 2;
            }
          }
          i = k / 2;
        } else if (crypto.randomBytes) {
          a = crypto.randomBytes(k *= 7);
          for (; i < k; ) {
            v = (a[i] & 31) * 281474976710656 + a[i + 1] * 1099511627776 + a[i + 2] * 4294967296 + a[i + 3] * 16777216 + (a[i + 4] << 16) + (a[i + 5] << 8) + a[i + 6];
            if (v >= 9e15) {
              crypto.randomBytes(7).copy(a, i);
            } else {
              c.push(v % 1e14);
              i += 7;
            }
          }
          i = k / 7;
        } else {
          CRYPTO = false;
          throw Error(bignumberError + "crypto unavailable");
        }
      }
      if (!CRYPTO) {
        for (; i < k; ) {
          v = random53bitInt();
          if (v < 9e15)
            c[i++] = v % 1e14;
        }
      }
      k = c[--i];
      dp %= LOG_BASE;
      if (k && dp) {
        v = POWS_TEN[LOG_BASE - dp];
        c[i] = mathfloor(k / v) * v;
      }
      for (; c[i] === 0; c.pop(), i--)
        ;
      if (i < 0) {
        c = [e = 0];
      } else {
        for (e = -1; c[0] === 0; c.splice(0, 1), e -= LOG_BASE)
          ;
        for (i = 1, v = c[0]; v >= 10; v /= 10, i++)
          ;
        if (i < LOG_BASE)
          e -= LOG_BASE - i;
      }
      rand.e = e;
      rand.c = c;
      return rand;
    };
  }();
  BigNumber2.sum = function() {
    var i = 1, args = arguments, sum2 = new BigNumber2(args[0]);
    for (; i < args.length; )
      sum2 = sum2.plus(args[i++]);
    return sum2;
  };
  convertBase2 = /* @__PURE__ */ function() {
    var decimal = "0123456789";
    function toBaseOut(str2, baseIn, baseOut, alphabet) {
      var j, arr = [0], arrL, i = 0, len = str2.length;
      for (; i < len; ) {
        for (arrL = arr.length; arrL--; arr[arrL] *= baseIn)
          ;
        arr[0] += alphabet.indexOf(str2.charAt(i++));
        for (j = 0; j < arr.length; j++) {
          if (arr[j] > baseOut - 1) {
            if (arr[j + 1] == null)
              arr[j + 1] = 0;
            arr[j + 1] += arr[j] / baseOut | 0;
            arr[j] %= baseOut;
          }
        }
      }
      return arr.reverse();
    }
    return function(str2, baseIn, baseOut, sign2, callerIsToString) {
      var alphabet, d, e, k, r, x, xc, y, i = str2.indexOf("."), dp = DECIMAL_PLACES, rm = ROUNDING_MODE;
      if (i >= 0) {
        k = POW_PRECISION;
        POW_PRECISION = 0;
        str2 = str2.replace(".", "");
        y = new BigNumber2(baseIn);
        x = y.pow(str2.length - i);
        POW_PRECISION = k;
        y.c = toBaseOut(
          toFixedPoint(coeffToString(x.c), x.e, "0"),
          10,
          baseOut,
          decimal
        );
        y.e = y.c.length;
      }
      xc = toBaseOut(str2, baseIn, baseOut, callerIsToString ? (alphabet = ALPHABET, decimal) : (alphabet = decimal, ALPHABET));
      e = k = xc.length;
      for (; xc[--k] == 0; xc.pop())
        ;
      if (!xc[0])
        return alphabet.charAt(0);
      if (i < 0) {
        --e;
      } else {
        x.c = xc;
        x.e = e;
        x.s = sign2;
        x = div3(x, y, dp, rm, baseOut);
        xc = x.c;
        r = x.r;
        e = x.e;
      }
      d = e + dp + 1;
      i = xc[d];
      k = baseOut / 2;
      r = r || d < 0 || xc[d + 1] != null;
      r = rm < 4 ? (i != null || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : i > k || i == k && (rm == 4 || r || rm == 6 && xc[d - 1] & 1 || rm == (x.s < 0 ? 8 : 7));
      if (d < 1 || !xc[0]) {
        str2 = r ? toFixedPoint(alphabet.charAt(1), -dp, alphabet.charAt(0)) : alphabet.charAt(0);
      } else {
        xc.length = d;
        if (r) {
          for (--baseOut; ++xc[--d] > baseOut; ) {
            xc[d] = 0;
            if (!d) {
              ++e;
              xc = [1].concat(xc);
            }
          }
        }
        for (k = xc.length; !xc[--k]; )
          ;
        for (i = 0, str2 = ""; i <= k; str2 += alphabet.charAt(xc[i++]))
          ;
        str2 = toFixedPoint(str2, e, alphabet.charAt(0));
      }
      return str2;
    };
  }();
  div3 = /* @__PURE__ */ function() {
    function multiply(x, k, base) {
      var m, temp, xlo, xhi, carry = 0, i = x.length, klo = k % SQRT_BASE, khi = k / SQRT_BASE | 0;
      for (x = x.slice(); i--; ) {
        xlo = x[i] % SQRT_BASE;
        xhi = x[i] / SQRT_BASE | 0;
        m = khi * xlo + xhi * klo;
        temp = klo * xlo + m % SQRT_BASE * SQRT_BASE + carry;
        carry = (temp / base | 0) + (m / SQRT_BASE | 0) + khi * xhi;
        x[i] = temp % base;
      }
      if (carry)
        x = [carry].concat(x);
      return x;
    }
    function compare2(a, b, aL, bL) {
      var i, cmp;
      if (aL != bL) {
        cmp = aL > bL ? 1 : -1;
      } else {
        for (i = cmp = 0; i < aL; i++) {
          if (a[i] != b[i]) {
            cmp = a[i] > b[i] ? 1 : -1;
            break;
          }
        }
      }
      return cmp;
    }
    function subtract(a, b, aL, base) {
      var i = 0;
      for (; aL--; ) {
        a[aL] -= i;
        i = a[aL] < b[aL] ? 1 : 0;
        a[aL] = i * base + a[aL] - b[aL];
      }
      for (; !a[0] && a.length > 1; a.splice(0, 1))
        ;
    }
    return function(x, y, dp, rm, base) {
      var cmp, e, i, more, n, prod, prodL, q, qc, rem, remL, rem0, xi, xL, yc0, yL, yz, s = x.s == y.s ? 1 : -1, xc = x.c, yc = y.c;
      if (!xc || !xc[0] || !yc || !yc[0]) {
        return new BigNumber2(
          // Return NaN if either NaN, or both Infinity or 0.
          !x.s || !y.s || (xc ? yc && xc[0] == yc[0] : !yc) ? NaN : (
            // Return 0 if x is 0 or y is Infinity, or return Infinity as y is 0.
            xc && xc[0] == 0 || !yc ? s * 0 : s / 0
          )
        );
      }
      q = new BigNumber2(s);
      qc = q.c = [];
      e = x.e - y.e;
      s = dp + e + 1;
      if (!base) {
        base = BASE;
        e = bitFloor(x.e / LOG_BASE) - bitFloor(y.e / LOG_BASE);
        s = s / LOG_BASE | 0;
      }
      for (i = 0; yc[i] == (xc[i] || 0); i++)
        ;
      if (yc[i] > (xc[i] || 0))
        e--;
      if (s < 0) {
        qc.push(1);
        more = true;
      } else {
        xL = xc.length;
        yL = yc.length;
        i = 0;
        s += 2;
        n = mathfloor(base / (yc[0] + 1));
        if (n > 1) {
          yc = multiply(yc, n, base);
          xc = multiply(xc, n, base);
          yL = yc.length;
          xL = xc.length;
        }
        xi = yL;
        rem = xc.slice(0, yL);
        remL = rem.length;
        for (; remL < yL; rem[remL++] = 0)
          ;
        yz = yc.slice();
        yz = [0].concat(yz);
        yc0 = yc[0];
        if (yc[1] >= base / 2)
          yc0++;
        do {
          n = 0;
          cmp = compare2(yc, rem, yL, remL);
          if (cmp < 0) {
            rem0 = rem[0];
            if (yL != remL)
              rem0 = rem0 * base + (rem[1] || 0);
            n = mathfloor(rem0 / yc0);
            if (n > 1) {
              if (n >= base)
                n = base - 1;
              prod = multiply(yc, n, base);
              prodL = prod.length;
              remL = rem.length;
              while (compare2(prod, rem, prodL, remL) == 1) {
                n--;
                subtract(prod, yL < prodL ? yz : yc, prodL, base);
                prodL = prod.length;
                cmp = 1;
              }
            } else {
              if (n == 0) {
                cmp = n = 1;
              }
              prod = yc.slice();
              prodL = prod.length;
            }
            if (prodL < remL)
              prod = [0].concat(prod);
            subtract(rem, prod, remL, base);
            remL = rem.length;
            if (cmp == -1) {
              while (compare2(yc, rem, yL, remL) < 1) {
                n++;
                subtract(rem, yL < remL ? yz : yc, remL, base);
                remL = rem.length;
              }
            }
          } else if (cmp === 0) {
            n++;
            rem = [0];
          }
          qc[i++] = n;
          if (rem[0]) {
            rem[remL++] = xc[xi] || 0;
          } else {
            rem = [xc[xi]];
            remL = 1;
          }
        } while ((xi++ < xL || rem[0] != null) && s--);
        more = rem[0] != null;
        if (!qc[0])
          qc.splice(0, 1);
      }
      if (base == BASE) {
        for (i = 1, s = qc[0]; s >= 10; s /= 10, i++)
          ;
        round2(q, dp + (q.e = i + e * LOG_BASE - 1) + 1, rm, more);
      } else {
        q.e = e;
        q.r = +more;
      }
      return q;
    };
  }();
  function format(n, i, rm, id) {
    var c0, e, ne, len, str2;
    if (rm == null)
      rm = ROUNDING_MODE;
    else
      intCheck(rm, 0, 8);
    if (!n.c)
      return n.toString();
    c0 = n.c[0];
    ne = n.e;
    if (i == null) {
      str2 = coeffToString(n.c);
      str2 = id == 1 || id == 2 && (ne <= TO_EXP_NEG || ne >= TO_EXP_POS) ? toExponential(str2, ne) : toFixedPoint(str2, ne, "0");
    } else {
      n = round2(new BigNumber2(n), i, rm);
      e = n.e;
      str2 = coeffToString(n.c);
      len = str2.length;
      if (id == 1 || id == 2 && (i <= e || e <= TO_EXP_NEG)) {
        for (; len < i; str2 += "0", len++)
          ;
        str2 = toExponential(str2, e);
      } else {
        i -= ne + (id === 2 && e > ne);
        str2 = toFixedPoint(str2, e, "0");
        if (e + 1 > len) {
          if (--i > 0)
            for (str2 += "."; i--; str2 += "0")
              ;
        } else {
          i += e - len;
          if (i > 0) {
            if (e + 1 == len)
              str2 += ".";
            for (; i--; str2 += "0")
              ;
          }
        }
      }
    }
    return n.s < 0 && c0 ? "-" + str2 : str2;
  }
  function maxOrMin2(args, n) {
    var k, y, i = 1, x = new BigNumber2(args[0]);
    for (; i < args.length; i++) {
      y = new BigNumber2(args[i]);
      if (!y.s || (k = compare(x, y)) === n || k === 0 && x.s === n) {
        x = y;
      }
    }
    return x;
  }
  function normalise(n, c, e) {
    var i = 1, j = c.length;
    for (; !c[--j]; c.pop())
      ;
    for (j = c[0]; j >= 10; j /= 10, i++)
      ;
    if ((e = i + e * LOG_BASE - 1) > MAX_EXP) {
      n.c = n.e = null;
    } else if (e < MIN_EXP) {
      n.c = [n.e = 0];
    } else {
      n.e = e;
      n.c = c;
    }
    return n;
  }
  parseNumeric = /* @__PURE__ */ function() {
    var basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i, dotAfter = /^([^.]+)\.$/, dotBefore = /^\.([^.]+)$/, isInfinityOrNaN = /^-?(Infinity|NaN)$/, whitespaceOrPlus = /^\s*\+(?=[\w.])|^\s+|\s+$/g;
    return function(x, str2, isNum, b) {
      var base, s = isNum ? str2 : str2.replace(whitespaceOrPlus, "");
      if (isInfinityOrNaN.test(s)) {
        x.s = isNaN(s) ? null : s < 0 ? -1 : 1;
      } else {
        if (!isNum) {
          s = s.replace(basePrefix, function(m, p1, p2) {
            base = (p2 = p2.toLowerCase()) == "x" ? 16 : p2 == "b" ? 2 : 8;
            return !b || b == base ? p1 : m;
          });
          if (b) {
            base = b;
            s = s.replace(dotAfter, "$1").replace(dotBefore, "0.$1");
          }
          if (str2 != s)
            return new BigNumber2(s, base);
        }
        if (BigNumber2.DEBUG) {
          throw Error(bignumberError + "Not a" + (b ? " base " + b : "") + " number: " + str2);
        }
        x.s = null;
      }
      x.c = x.e = null;
    };
  }();
  function round2(x, sd, rm, r) {
    var d, i, j, k, n, ni, rd, xc = x.c, pows10 = POWS_TEN;
    if (xc) {
      out: {
        for (d = 1, k = xc[0]; k >= 10; k /= 10, d++)
          ;
        i = sd - d;
        if (i < 0) {
          i += LOG_BASE;
          j = sd;
          n = xc[ni = 0];
          rd = mathfloor(n / pows10[d - j - 1] % 10);
        } else {
          ni = mathceil((i + 1) / LOG_BASE);
          if (ni >= xc.length) {
            if (r) {
              for (; xc.length <= ni; xc.push(0))
                ;
              n = rd = 0;
              d = 1;
              i %= LOG_BASE;
              j = i - LOG_BASE + 1;
            } else {
              break out;
            }
          } else {
            n = k = xc[ni];
            for (d = 1; k >= 10; k /= 10, d++)
              ;
            i %= LOG_BASE;
            j = i - LOG_BASE + d;
            rd = j < 0 ? 0 : mathfloor(n / pows10[d - j - 1] % 10);
          }
        }
        r = r || sd < 0 || // Are there any non-zero digits after the rounding digit?
        // The expression  n % pows10[d - j - 1]  returns all digits of n to the right
        // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.
        xc[ni + 1] != null || (j < 0 ? n : n % pows10[d - j - 1]);
        r = rm < 4 ? (rd || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : rd > 5 || rd == 5 && (rm == 4 || r || rm == 6 && // Check whether the digit to the left of the rounding digit is odd.
        (i > 0 ? j > 0 ? n / pows10[d - j] : 0 : xc[ni - 1]) % 10 & 1 || rm == (x.s < 0 ? 8 : 7));
        if (sd < 1 || !xc[0]) {
          xc.length = 0;
          if (r) {
            sd -= x.e + 1;
            xc[0] = pows10[(LOG_BASE - sd % LOG_BASE) % LOG_BASE];
            x.e = -sd || 0;
          } else {
            xc[0] = x.e = 0;
          }
          return x;
        }
        if (i == 0) {
          xc.length = ni;
          k = 1;
          ni--;
        } else {
          xc.length = ni + 1;
          k = pows10[LOG_BASE - i];
          xc[ni] = j > 0 ? mathfloor(n / pows10[d - j] % pows10[j]) * k : 0;
        }
        if (r) {
          for (; ; ) {
            if (ni == 0) {
              for (i = 1, j = xc[0]; j >= 10; j /= 10, i++)
                ;
              j = xc[0] += k;
              for (k = 1; j >= 10; j /= 10, k++)
                ;
              if (i != k) {
                x.e++;
                if (xc[0] == BASE)
                  xc[0] = 1;
              }
              break;
            } else {
              xc[ni] += k;
              if (xc[ni] != BASE)
                break;
              xc[ni--] = 0;
              k = 1;
            }
          }
        }
        for (i = xc.length; xc[--i] === 0; xc.pop())
          ;
      }
      if (x.e > MAX_EXP) {
        x.c = x.e = null;
      } else if (x.e < MIN_EXP) {
        x.c = [x.e = 0];
      }
    }
    return x;
  }
  function valueOf(n) {
    var str2, e = n.e;
    if (e === null)
      return n.toString();
    str2 = coeffToString(n.c);
    str2 = e <= TO_EXP_NEG || e >= TO_EXP_POS ? toExponential(str2, e) : toFixedPoint(str2, e, "0");
    return n.s < 0 ? "-" + str2 : str2;
  }
  P2.absoluteValue = P2.abs = function() {
    var x = new BigNumber2(this);
    if (x.s < 0)
      x.s = 1;
    return x;
  };
  P2.comparedTo = function(y, b) {
    return compare(this, new BigNumber2(y, b));
  };
  P2.decimalPlaces = P2.dp = function(dp, rm) {
    var c, n, v, x = this;
    if (dp != null) {
      intCheck(dp, 0, MAX);
      if (rm == null)
        rm = ROUNDING_MODE;
      else
        intCheck(rm, 0, 8);
      return round2(new BigNumber2(x), dp + x.e + 1, rm);
    }
    if (!(c = x.c))
      return null;
    n = ((v = c.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE;
    if (v = c[v])
      for (; v % 10 == 0; v /= 10, n--)
        ;
    if (n < 0)
      n = 0;
    return n;
  };
  P2.dividedBy = P2.div = function(y, b) {
    return div3(this, new BigNumber2(y, b), DECIMAL_PLACES, ROUNDING_MODE);
  };
  P2.dividedToIntegerBy = P2.idiv = function(y, b) {
    return div3(this, new BigNumber2(y, b), 0, 1);
  };
  P2.exponentiatedBy = P2.pow = function(n, m) {
    var half, isModExp, i, k, more, nIsBig, nIsNeg, nIsOdd, y, x = this;
    n = new BigNumber2(n);
    if (n.c && !n.isInteger()) {
      throw Error(bignumberError + "Exponent not an integer: " + valueOf(n));
    }
    if (m != null)
      m = new BigNumber2(m);
    nIsBig = n.e > 14;
    if (!x.c || !x.c[0] || x.c[0] == 1 && !x.e && x.c.length == 1 || !n.c || !n.c[0]) {
      y = new BigNumber2(Math.pow(+valueOf(x), nIsBig ? n.s * (2 - isOdd(n)) : +valueOf(n)));
      return m ? y.mod(m) : y;
    }
    nIsNeg = n.s < 0;
    if (m) {
      if (m.c ? !m.c[0] : !m.s)
        return new BigNumber2(NaN);
      isModExp = !nIsNeg && x.isInteger() && m.isInteger();
      if (isModExp)
        x = x.mod(m);
    } else if (n.e > 9 && (x.e > 0 || x.e < -1 || (x.e == 0 ? x.c[0] > 1 || nIsBig && x.c[1] >= 24e7 : x.c[0] < 8e13 || nIsBig && x.c[0] <= 9999975e7))) {
      k = x.s < 0 && isOdd(n) ? -0 : 0;
      if (x.e > -1)
        k = 1 / k;
      return new BigNumber2(nIsNeg ? 1 / k : k);
    } else if (POW_PRECISION) {
      k = mathceil(POW_PRECISION / LOG_BASE + 2);
    }
    if (nIsBig) {
      half = new BigNumber2(0.5);
      if (nIsNeg)
        n.s = 1;
      nIsOdd = isOdd(n);
    } else {
      i = Math.abs(+valueOf(n));
      nIsOdd = i % 2;
    }
    y = new BigNumber2(ONE2);
    for (; ; ) {
      if (nIsOdd) {
        y = y.times(x);
        if (!y.c)
          break;
        if (k) {
          if (y.c.length > k)
            y.c.length = k;
        } else if (isModExp) {
          y = y.mod(m);
        }
      }
      if (i) {
        i = mathfloor(i / 2);
        if (i === 0)
          break;
        nIsOdd = i % 2;
      } else {
        n = n.times(half);
        round2(n, n.e + 1, 1);
        if (n.e > 14) {
          nIsOdd = isOdd(n);
        } else {
          i = +valueOf(n);
          if (i === 0)
            break;
          nIsOdd = i % 2;
        }
      }
      x = x.times(x);
      if (k) {
        if (x.c && x.c.length > k)
          x.c.length = k;
      } else if (isModExp) {
        x = x.mod(m);
      }
    }
    if (isModExp)
      return y;
    if (nIsNeg)
      y = ONE2.div(y);
    return m ? y.mod(m) : k ? round2(y, POW_PRECISION, ROUNDING_MODE, more) : y;
  };
  P2.integerValue = function(rm) {
    var n = new BigNumber2(this);
    if (rm == null)
      rm = ROUNDING_MODE;
    else
      intCheck(rm, 0, 8);
    return round2(n, n.e + 1, rm);
  };
  P2.isEqualTo = P2.eq = function(y, b) {
    return compare(this, new BigNumber2(y, b)) === 0;
  };
  P2.isFinite = function() {
    return !!this.c;
  };
  P2.isGreaterThan = P2.gt = function(y, b) {
    return compare(this, new BigNumber2(y, b)) > 0;
  };
  P2.isGreaterThanOrEqualTo = P2.gte = function(y, b) {
    return (b = compare(this, new BigNumber2(y, b))) === 1 || b === 0;
  };
  P2.isInteger = function() {
    return !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2;
  };
  P2.isLessThan = P2.lt = function(y, b) {
    return compare(this, new BigNumber2(y, b)) < 0;
  };
  P2.isLessThanOrEqualTo = P2.lte = function(y, b) {
    return (b = compare(this, new BigNumber2(y, b))) === -1 || b === 0;
  };
  P2.isNaN = function() {
    return !this.s;
  };
  P2.isNegative = function() {
    return this.s < 0;
  };
  P2.isPositive = function() {
    return this.s > 0;
  };
  P2.isZero = function() {
    return !!this.c && this.c[0] == 0;
  };
  P2.minus = function(y, b) {
    var i, j, t, xLTy, x = this, a = x.s;
    y = new BigNumber2(y, b);
    b = y.s;
    if (!a || !b)
      return new BigNumber2(NaN);
    if (a != b) {
      y.s = -b;
      return x.plus(y);
    }
    var xe = x.e / LOG_BASE, ye = y.e / LOG_BASE, xc = x.c, yc = y.c;
    if (!xe || !ye) {
      if (!xc || !yc)
        return xc ? (y.s = -b, y) : new BigNumber2(yc ? x : NaN);
      if (!xc[0] || !yc[0]) {
        return yc[0] ? (y.s = -b, y) : new BigNumber2(xc[0] ? x : (
          // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity
          ROUNDING_MODE == 3 ? -0 : 0
        ));
      }
    }
    xe = bitFloor(xe);
    ye = bitFloor(ye);
    xc = xc.slice();
    if (a = xe - ye) {
      if (xLTy = a < 0) {
        a = -a;
        t = xc;
      } else {
        ye = xe;
        t = yc;
      }
      t.reverse();
      for (b = a; b--; t.push(0))
        ;
      t.reverse();
    } else {
      j = (xLTy = (a = xc.length) < (b = yc.length)) ? a : b;
      for (a = b = 0; b < j; b++) {
        if (xc[b] != yc[b]) {
          xLTy = xc[b] < yc[b];
          break;
        }
      }
    }
    if (xLTy) {
      t = xc;
      xc = yc;
      yc = t;
      y.s = -y.s;
    }
    b = (j = yc.length) - (i = xc.length);
    if (b > 0)
      for (; b--; xc[i++] = 0)
        ;
    b = BASE - 1;
    for (; j > a; ) {
      if (xc[--j] < yc[j]) {
        for (i = j; i && !xc[--i]; xc[i] = b)
          ;
        --xc[i];
        xc[j] += BASE;
      }
      xc[j] -= yc[j];
    }
    for (; xc[0] == 0; xc.splice(0, 1), --ye)
      ;
    if (!xc[0]) {
      y.s = ROUNDING_MODE == 3 ? -1 : 1;
      y.c = [y.e = 0];
      return y;
    }
    return normalise(y, xc, ye);
  };
  P2.modulo = P2.mod = function(y, b) {
    var q, s, x = this;
    y = new BigNumber2(y, b);
    if (!x.c || !y.s || y.c && !y.c[0]) {
      return new BigNumber2(NaN);
    } else if (!y.c || x.c && !x.c[0]) {
      return new BigNumber2(x);
    }
    if (MODULO_MODE == 9) {
      s = y.s;
      y.s = 1;
      q = div3(x, y, 0, 3);
      y.s = s;
      q.s *= s;
    } else {
      q = div3(x, y, 0, MODULO_MODE);
    }
    y = x.minus(q.times(y));
    if (!y.c[0] && MODULO_MODE == 1)
      y.s = x.s;
    return y;
  };
  P2.multipliedBy = P2.times = function(y, b) {
    var c, e, i, j, k, m, xcL, xlo, xhi, ycL, ylo, yhi, zc, base, sqrtBase, x = this, xc = x.c, yc = (y = new BigNumber2(y, b)).c;
    if (!xc || !yc || !xc[0] || !yc[0]) {
      if (!x.s || !y.s || xc && !xc[0] && !yc || yc && !yc[0] && !xc) {
        y.c = y.e = y.s = null;
      } else {
        y.s *= x.s;
        if (!xc || !yc) {
          y.c = y.e = null;
        } else {
          y.c = [0];
          y.e = 0;
        }
      }
      return y;
    }
    e = bitFloor(x.e / LOG_BASE) + bitFloor(y.e / LOG_BASE);
    y.s *= x.s;
    xcL = xc.length;
    ycL = yc.length;
    if (xcL < ycL) {
      zc = xc;
      xc = yc;
      yc = zc;
      i = xcL;
      xcL = ycL;
      ycL = i;
    }
    for (i = xcL + ycL, zc = []; i--; zc.push(0))
      ;
    base = BASE;
    sqrtBase = SQRT_BASE;
    for (i = ycL; --i >= 0; ) {
      c = 0;
      ylo = yc[i] % sqrtBase;
      yhi = yc[i] / sqrtBase | 0;
      for (k = xcL, j = i + k; j > i; ) {
        xlo = xc[--k] % sqrtBase;
        xhi = xc[k] / sqrtBase | 0;
        m = yhi * xlo + xhi * ylo;
        xlo = ylo * xlo + m % sqrtBase * sqrtBase + zc[j] + c;
        c = (xlo / base | 0) + (m / sqrtBase | 0) + yhi * xhi;
        zc[j--] = xlo % base;
      }
      zc[j] = c;
    }
    if (c) {
      ++e;
    } else {
      zc.splice(0, 1);
    }
    return normalise(y, zc, e);
  };
  P2.negated = function() {
    var x = new BigNumber2(this);
    x.s = -x.s || null;
    return x;
  };
  P2.plus = function(y, b) {
    var t, x = this, a = x.s;
    y = new BigNumber2(y, b);
    b = y.s;
    if (!a || !b)
      return new BigNumber2(NaN);
    if (a != b) {
      y.s = -b;
      return x.minus(y);
    }
    var xe = x.e / LOG_BASE, ye = y.e / LOG_BASE, xc = x.c, yc = y.c;
    if (!xe || !ye) {
      if (!xc || !yc)
        return new BigNumber2(a / 0);
      if (!xc[0] || !yc[0])
        return yc[0] ? y : new BigNumber2(xc[0] ? x : a * 0);
    }
    xe = bitFloor(xe);
    ye = bitFloor(ye);
    xc = xc.slice();
    if (a = xe - ye) {
      if (a > 0) {
        ye = xe;
        t = yc;
      } else {
        a = -a;
        t = xc;
      }
      t.reverse();
      for (; a--; t.push(0))
        ;
      t.reverse();
    }
    a = xc.length;
    b = yc.length;
    if (a - b < 0) {
      t = yc;
      yc = xc;
      xc = t;
      b = a;
    }
    for (a = 0; b; ) {
      a = (xc[--b] = xc[b] + yc[b] + a) / BASE | 0;
      xc[b] = BASE === xc[b] ? 0 : xc[b] % BASE;
    }
    if (a) {
      xc = [a].concat(xc);
      ++ye;
    }
    return normalise(y, xc, ye);
  };
  P2.precision = P2.sd = function(sd, rm) {
    var c, n, v, x = this;
    if (sd != null && sd !== !!sd) {
      intCheck(sd, 1, MAX);
      if (rm == null)
        rm = ROUNDING_MODE;
      else
        intCheck(rm, 0, 8);
      return round2(new BigNumber2(x), sd, rm);
    }
    if (!(c = x.c))
      return null;
    v = c.length - 1;
    n = v * LOG_BASE + 1;
    if (v = c[v]) {
      for (; v % 10 == 0; v /= 10, n--)
        ;
      for (v = c[0]; v >= 10; v /= 10, n++)
        ;
    }
    if (sd && x.e + 1 > n)
      n = x.e + 1;
    return n;
  };
  P2.shiftedBy = function(k) {
    intCheck(k, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER);
    return this.times("1e" + k);
  };
  P2.squareRoot = P2.sqrt = function() {
    var m, n, r, rep, t, x = this, c = x.c, s = x.s, e = x.e, dp = DECIMAL_PLACES + 4, half = new BigNumber2("0.5");
    if (s !== 1 || !c || !c[0]) {
      return new BigNumber2(!s || s < 0 && (!c || c[0]) ? NaN : c ? x : 1 / 0);
    }
    s = Math.sqrt(+valueOf(x));
    if (s == 0 || s == 1 / 0) {
      n = coeffToString(c);
      if ((n.length + e) % 2 == 0)
        n += "0";
      s = Math.sqrt(+n);
      e = bitFloor((e + 1) / 2) - (e < 0 || e % 2);
      if (s == 1 / 0) {
        n = "5e" + e;
      } else {
        n = s.toExponential();
        n = n.slice(0, n.indexOf("e") + 1) + e;
      }
      r = new BigNumber2(n);
    } else {
      r = new BigNumber2(s + "");
    }
    if (r.c[0]) {
      e = r.e;
      s = e + dp;
      if (s < 3)
        s = 0;
      for (; ; ) {
        t = r;
        r = half.times(t.plus(div3(x, t, dp, 1)));
        if (coeffToString(t.c).slice(0, s) === (n = coeffToString(r.c)).slice(0, s)) {
          if (r.e < e)
            --s;
          n = n.slice(s - 3, s + 1);
          if (n == "9999" || !rep && n == "4999") {
            if (!rep) {
              round2(t, t.e + DECIMAL_PLACES + 2, 0);
              if (t.times(t).eq(x)) {
                r = t;
                break;
              }
            }
            dp += 4;
            s += 4;
            rep = 1;
          } else {
            if (!+n || !+n.slice(1) && n.charAt(0) == "5") {
              round2(r, r.e + DECIMAL_PLACES + 2, 1);
              m = !r.times(r).eq(x);
            }
            break;
          }
        }
      }
    }
    return round2(r, r.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m);
  };
  P2.toExponential = function(dp, rm) {
    if (dp != null) {
      intCheck(dp, 0, MAX);
      dp++;
    }
    return format(this, dp, rm, 1);
  };
  P2.toFixed = function(dp, rm) {
    if (dp != null) {
      intCheck(dp, 0, MAX);
      dp = dp + this.e + 1;
    }
    return format(this, dp, rm);
  };
  P2.toFormat = function(dp, rm, format2) {
    var str2, x = this;
    if (format2 == null) {
      if (dp != null && rm && typeof rm == "object") {
        format2 = rm;
        rm = null;
      } else if (dp && typeof dp == "object") {
        format2 = dp;
        dp = rm = null;
      } else {
        format2 = FORMAT;
      }
    } else if (typeof format2 != "object") {
      throw Error(bignumberError + "Argument not an object: " + format2);
    }
    str2 = x.toFixed(dp, rm);
    if (x.c) {
      var i, arr = str2.split("."), g1 = +format2.groupSize, g2 = +format2.secondaryGroupSize, groupSeparator = format2.groupSeparator || "", intPart = arr[0], fractionPart = arr[1], isNeg = x.s < 0, intDigits = isNeg ? intPart.slice(1) : intPart, len = intDigits.length;
      if (g2) {
        i = g1;
        g1 = g2;
        g2 = i;
        len -= i;
      }
      if (g1 > 0 && len > 0) {
        i = len % g1 || g1;
        intPart = intDigits.substr(0, i);
        for (; i < len; i += g1)
          intPart += groupSeparator + intDigits.substr(i, g1);
        if (g2 > 0)
          intPart += groupSeparator + intDigits.slice(i);
        if (isNeg)
          intPart = "-" + intPart;
      }
      str2 = fractionPart ? intPart + (format2.decimalSeparator || "") + ((g2 = +format2.fractionGroupSize) ? fractionPart.replace(
        new RegExp("\\d{" + g2 + "}\\B", "g"),
        "$&" + (format2.fractionGroupSeparator || "")
      ) : fractionPart) : intPart;
    }
    return (format2.prefix || "") + str2 + (format2.suffix || "");
  };
  P2.toFraction = function(md) {
    var d, d0, d1, d2, e, exp2, n, n0, n1, q, r, s, x = this, xc = x.c;
    if (md != null) {
      n = new BigNumber2(md);
      if (!n.isInteger() && (n.c || n.s !== 1) || n.lt(ONE2)) {
        throw Error(bignumberError + "Argument " + (n.isInteger() ? "out of range: " : "not an integer: ") + valueOf(n));
      }
    }
    if (!xc)
      return new BigNumber2(x);
    d = new BigNumber2(ONE2);
    n1 = d0 = new BigNumber2(ONE2);
    d1 = n0 = new BigNumber2(ONE2);
    s = coeffToString(xc);
    e = d.e = s.length - x.e - 1;
    d.c[0] = POWS_TEN[(exp2 = e % LOG_BASE) < 0 ? LOG_BASE + exp2 : exp2];
    md = !md || n.comparedTo(d) > 0 ? e > 0 ? d : n1 : n;
    exp2 = MAX_EXP;
    MAX_EXP = 1 / 0;
    n = new BigNumber2(s);
    n0.c[0] = 0;
    for (; ; ) {
      q = div3(n, d, 0, 1);
      d2 = d0.plus(q.times(d1));
      if (d2.comparedTo(md) == 1)
        break;
      d0 = d1;
      d1 = d2;
      n1 = n0.plus(q.times(d2 = n1));
      n0 = d2;
      d = n.minus(q.times(d2 = d));
      n = d2;
    }
    d2 = div3(md.minus(d0), d1, 0, 1);
    n0 = n0.plus(d2.times(n1));
    d0 = d0.plus(d2.times(d1));
    n0.s = n1.s = x.s;
    e = e * 2;
    r = div3(n1, d1, e, ROUNDING_MODE).minus(x).abs().comparedTo(
      div3(n0, d0, e, ROUNDING_MODE).minus(x).abs()
    ) < 1 ? [n1, d1] : [n0, d0];
    MAX_EXP = exp2;
    return r;
  };
  P2.toNumber = function() {
    return +valueOf(this);
  };
  P2.toPrecision = function(sd, rm) {
    if (sd != null)
      intCheck(sd, 1, MAX);
    return format(this, sd, rm, 2);
  };
  P2.toString = function(b) {
    var str2, n = this, s = n.s, e = n.e;
    if (e === null) {
      if (s) {
        str2 = "Infinity";
        if (s < 0)
          str2 = "-" + str2;
      } else {
        str2 = "NaN";
      }
    } else {
      if (b == null) {
        str2 = e <= TO_EXP_NEG || e >= TO_EXP_POS ? toExponential(coeffToString(n.c), e) : toFixedPoint(coeffToString(n.c), e, "0");
      } else if (b === 10 && alphabetHasNormalDecimalDigits) {
        n = round2(new BigNumber2(n), DECIMAL_PLACES + e + 1, ROUNDING_MODE);
        str2 = toFixedPoint(coeffToString(n.c), n.e, "0");
      } else {
        intCheck(b, 2, ALPHABET.length, "Base");
        str2 = convertBase2(toFixedPoint(coeffToString(n.c), e, "0"), 10, b, s, true);
      }
      if (s < 0 && n.c[0])
        str2 = "-" + str2;
    }
    return str2;
  };
  P2.valueOf = P2.toJSON = function() {
    return valueOf(this);
  };
  P2._isBigNumber = true;
  P2[Symbol.toStringTag] = "BigNumber";
  P2[Symbol.for("nodejs.util.inspect.custom")] = P2.valueOf;
  if (configObject != null)
    BigNumber2.set(configObject);
  return BigNumber2;
}
function bitFloor(n) {
  var i = n | 0;
  return n > 0 || n === i ? i : i - 1;
}
function coeffToString(a) {
  var s, z, i = 1, j = a.length, r = a[0] + "";
  for (; i < j; ) {
    s = a[i++] + "";
    z = LOG_BASE - s.length;
    for (; z--; s = "0" + s)
      ;
    r += s;
  }
  for (j = r.length; r.charCodeAt(--j) === 48; )
    ;
  return r.slice(0, j + 1 || 1);
}
function compare(x, y) {
  var a, b, xc = x.c, yc = y.c, i = x.s, j = y.s, k = x.e, l = y.e;
  if (!i || !j)
    return null;
  a = xc && !xc[0];
  b = yc && !yc[0];
  if (a || b)
    return a ? b ? 0 : -j : i;
  if (i != j)
    return i;
  a = i < 0;
  b = k == l;
  if (!xc || !yc)
    return b ? 0 : !xc ^ a ? 1 : -1;
  if (!b)
    return k > l ^ a ? 1 : -1;
  j = (k = xc.length) < (l = yc.length) ? k : l;
  for (i = 0; i < j; i++)
    if (xc[i] != yc[i])
      return xc[i] > yc[i] ^ a ? 1 : -1;
  return k == l ? 0 : k > l ^ a ? 1 : -1;
}
function intCheck(n, min2, max2, name) {
  if (n < min2 || n > max2 || n !== mathfloor(n)) {
    throw Error(bignumberError + (name || "Argument") + (typeof n == "number" ? n < min2 || n > max2 ? " out of range: " : " not an integer: " : " not a primitive number: ") + String(n));
  }
}
function isOdd(n) {
  var k = n.c.length - 1;
  return bitFloor(n.e / LOG_BASE) == k && n.c[k] % 2 != 0;
}
function toExponential(str2, e) {
  return (str2.length > 1 ? str2.charAt(0) + "." + str2.slice(1) : str2) + (e < 0 ? "e" : "e+") + e;
}
function toFixedPoint(str2, e, z) {
  var len, zs;
  if (e < 0) {
    for (zs = z + "."; ++e; zs += z)
      ;
    str2 = zs + str2;
  } else {
    len = str2.length;
    if (++e > len) {
      for (zs = z, e -= len; --e; zs += z)
        ;
      str2 += zs;
    } else if (e < len) {
      str2 = str2.slice(0, e) + "." + str2.slice(e);
    }
  }
  return str2;
}
var BigNumber = clone();
var bignumber_default = BigNumber;

// node_modules/@solana/buffer-layout-utils/lib/esm/decimal.mjs
var WAD = new bignumber_default("1e+18");

// node_modules/@solana/buffer-layout-utils/lib/esm/native.mjs
var import_buffer_layout2 = __toESM(require_Layout(), 1);

// node_modules/@solana/buffer-layout-utils/lib/esm/web3.mjs
var import_buffer_layout3 = __toESM(require_Layout(), 1);
var import_web32 = require("@solana/web3.js");
var publicKey2 = (property) => {
  const layout = (0, import_buffer_layout3.blob)(32, property);
  const { encode, decode } = encodeDecode(layout);
  const publicKeyLayout = layout;
  publicKeyLayout.decode = (buffer, offset2) => {
    const src = decode(buffer, offset2);
    return new import_web32.PublicKey(src);
  };
  publicKeyLayout.encode = (publicKey3, buffer, offset2) => {
    const src = publicKey3.toBuffer();
    return encode(src, buffer, offset2);
  };
  return publicKeyLayout;
};

// node_modules/@solana/spl-token/lib/esm/state/account.js
var import_buffer_layout4 = __toESM(require_Layout(), 1);
var AccountState;
(function(AccountState2) {
  AccountState2[AccountState2["Uninitialized"] = 0] = "Uninitialized";
  AccountState2[AccountState2["Initialized"] = 1] = "Initialized";
  AccountState2[AccountState2["Frozen"] = 2] = "Frozen";
})(AccountState || (AccountState = {}));
var AccountLayout = (0, import_buffer_layout4.struct)([
  publicKey2("mint"),
  publicKey2("owner"),
  u642("amount"),
  (0, import_buffer_layout4.u32)("delegateOption"),
  publicKey2("delegate"),
  (0, import_buffer_layout4.u8)("state"),
  (0, import_buffer_layout4.u32)("isNativeOption"),
  u642("isNative"),
  u642("delegatedAmount"),
  (0, import_buffer_layout4.u32)("closeAuthorityOption"),
  publicKey2("closeAuthority")
]);
var ACCOUNT_SIZE = AccountLayout.span;

// raydium_daemon.ts
var import_bs58 = __toESM(require_bs58());
var import_bn = __toESM(require_bn());

// node_modules/decimal.js/decimal.mjs
var EXP_LIMIT = 9e15;
var MAX_DIGITS = 1e9;
var NUMERALS = "0123456789abcdef";
var LN10 = "2.3025850929940456840179914546843642076011014886287729760333279009675726096773524802359972050895982983419677840422862486334095254650828067566662873690987816894829072083255546808437998948262331985283935053089653777326288461633662222876982198867465436674744042432743651550489343149393914796194044002221051017141748003688084012647080685567743216228355220114804663715659121373450747856947683463616792101806445070648000277502684916746550586856935673420670581136429224554405758925724208241314695689016758940256776311356919292033376587141660230105703089634572075440370847469940168269282808481184289314848524948644871927809676271275775397027668605952496716674183485704422507197965004714951050492214776567636938662976979522110718264549734772662425709429322582798502585509785265383207606726317164309505995087807523710333101197857547331541421808427543863591778117054309827482385045648019095610299291824318237525357709750539565187697510374970888692180205189339507238539205144634197265287286965110862571492198849978748873771345686209167058";
var PI = "3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632789";
var DEFAULTS = {
  // These values must be integers within the stated ranges (inclusive).
  // Most of these values can be changed at run-time using the `Decimal.config` method.
  // The maximum number of significant digits of the result of a calculation or base conversion.
  // E.g. `Decimal.config({ precision: 20 });`
  precision: 20,
  // 1 to MAX_DIGITS
  // The rounding mode used when rounding to `precision`.
  //
  // ROUND_UP         0 Away from zero.
  // ROUND_DOWN       1 Towards zero.
  // ROUND_CEIL       2 Towards +Infinity.
  // ROUND_FLOOR      3 Towards -Infinity.
  // ROUND_HALF_UP    4 Towards nearest neighbour. If equidistant, up.
  // ROUND_HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.
  // ROUND_HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.
  // ROUND_HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.
  // ROUND_HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.
  //
  // E.g.
  // `Decimal.rounding = 4;`
  // `Decimal.rounding = Decimal.ROUND_HALF_UP;`
  rounding: 4,
  // 0 to 8
  // The modulo mode used when calculating the modulus: a mod n.
  // The quotient (q = a / n) is calculated according to the corresponding rounding mode.
  // The remainder (r) is calculated as: r = a - n * q.
  //
  // UP         0 The remainder is positive if the dividend is negative, else is negative.
  // DOWN       1 The remainder has the same sign as the dividend (JavaScript %).
  // FLOOR      3 The remainder has the same sign as the divisor (Python %).
  // HALF_EVEN  6 The IEEE 754 remainder function.
  // EUCLID     9 Euclidian division. q = sign(n) * floor(a / abs(n)). Always positive.
  //
  // Truncated division (1), floored division (3), the IEEE 754 remainder (6), and Euclidian
  // division (9) are commonly used for the modulus operation. The other rounding modes can also
  // be used, but they may not give useful results.
  modulo: 1,
  // 0 to 9
  // The exponent value at and beneath which `toString` returns exponential notation.
  // JavaScript numbers: -7
  toExpNeg: -7,
  // 0 to -EXP_LIMIT
  // The exponent value at and above which `toString` returns exponential notation.
  // JavaScript numbers: 21
  toExpPos: 21,
  // 0 to EXP_LIMIT
  // The minimum exponent value, beneath which underflow to zero occurs.
  // JavaScript numbers: -324  (5e-324)
  minE: -EXP_LIMIT,
  // -1 to -EXP_LIMIT
  // The maximum exponent value, above which overflow to Infinity occurs.
  // JavaScript numbers: 308  (1.7976931348623157e+308)
  maxE: EXP_LIMIT,
  // 1 to EXP_LIMIT
  // Whether to use cryptographically-secure random number generation, if available.
  crypto: false
  // true/false
};
var inexact;
var quadrant;
var external = true;
var decimalError = "[DecimalError] ";
var invalidArgument = decimalError + "Invalid argument: ";
var precisionLimitExceeded = decimalError + "Precision limit exceeded";
var cryptoUnavailable = decimalError + "crypto unavailable";
var tag = "[object Decimal]";
var mathfloor2 = Math.floor;
var mathpow = Math.pow;
var isBinary = /^0b([01]+(\.[01]*)?|\.[01]+)(p[+-]?\d+)?$/i;
var isHex = /^0x([0-9a-f]+(\.[0-9a-f]*)?|\.[0-9a-f]+)(p[+-]?\d+)?$/i;
var isOctal = /^0o([0-7]+(\.[0-7]*)?|\.[0-7]+)(p[+-]?\d+)?$/i;
var isDecimal2 = /^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i;
var BASE2 = 1e7;
var LOG_BASE2 = 7;
var MAX_SAFE_INTEGER2 = 9007199254740991;
var LN10_PRECISION = LN10.length - 1;
var PI_PRECISION = PI.length - 1;
var P = { toStringTag: tag };
P.absoluteValue = P.abs = function() {
  var x = new this.constructor(this);
  if (x.s < 0)
    x.s = 1;
  return finalise(x);
};
P.ceil = function() {
  return finalise(new this.constructor(this), this.e + 1, 2);
};
P.clampedTo = P.clamp = function(min2, max2) {
  var k, x = this, Ctor = x.constructor;
  min2 = new Ctor(min2);
  max2 = new Ctor(max2);
  if (!min2.s || !max2.s)
    return new Ctor(NaN);
  if (min2.gt(max2))
    throw Error(invalidArgument + max2);
  k = x.cmp(min2);
  return k < 0 ? min2 : x.cmp(max2) > 0 ? max2 : new Ctor(x);
};
P.comparedTo = P.cmp = function(y) {
  var i, j, xdL, ydL, x = this, xd = x.d, yd = (y = new x.constructor(y)).d, xs = x.s, ys = y.s;
  if (!xd || !yd) {
    return !xs || !ys ? NaN : xs !== ys ? xs : xd === yd ? 0 : !xd ^ xs < 0 ? 1 : -1;
  }
  if (!xd[0] || !yd[0])
    return xd[0] ? xs : yd[0] ? -ys : 0;
  if (xs !== ys)
    return xs;
  if (x.e !== y.e)
    return x.e > y.e ^ xs < 0 ? 1 : -1;
  xdL = xd.length;
  ydL = yd.length;
  for (i = 0, j = xdL < ydL ? xdL : ydL; i < j; ++i) {
    if (xd[i] !== yd[i])
      return xd[i] > yd[i] ^ xs < 0 ? 1 : -1;
  }
  return xdL === ydL ? 0 : xdL > ydL ^ xs < 0 ? 1 : -1;
};
P.cosine = P.cos = function() {
  var pr, rm, x = this, Ctor = x.constructor;
  if (!x.d)
    return new Ctor(NaN);
  if (!x.d[0])
    return new Ctor(1);
  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + Math.max(x.e, x.sd()) + LOG_BASE2;
  Ctor.rounding = 1;
  x = cosine(Ctor, toLessThanHalfPi(Ctor, x));
  Ctor.precision = pr;
  Ctor.rounding = rm;
  return finalise(quadrant == 2 || quadrant == 3 ? x.neg() : x, pr, rm, true);
};
P.cubeRoot = P.cbrt = function() {
  var e, m, n, r, rep, s, sd, t, t3, t3plusx, x = this, Ctor = x.constructor;
  if (!x.isFinite() || x.isZero())
    return new Ctor(x);
  external = false;
  s = x.s * mathpow(x.s * x, 1 / 3);
  if (!s || Math.abs(s) == 1 / 0) {
    n = digitsToString(x.d);
    e = x.e;
    if (s = (e - n.length + 1) % 3)
      n += s == 1 || s == -2 ? "0" : "00";
    s = mathpow(n, 1 / 3);
    e = mathfloor2((e + 1) / 3) - (e % 3 == (e < 0 ? -1 : 2));
    if (s == 1 / 0) {
      n = "5e" + e;
    } else {
      n = s.toExponential();
      n = n.slice(0, n.indexOf("e") + 1) + e;
    }
    r = new Ctor(n);
    r.s = x.s;
  } else {
    r = new Ctor(s.toString());
  }
  sd = (e = Ctor.precision) + 3;
  for (; ; ) {
    t = r;
    t3 = t.times(t).times(t);
    t3plusx = t3.plus(x);
    r = divide(t3plusx.plus(x).times(t), t3plusx.plus(t3), sd + 2, 1);
    if (digitsToString(t.d).slice(0, sd) === (n = digitsToString(r.d)).slice(0, sd)) {
      n = n.slice(sd - 3, sd + 1);
      if (n == "9999" || !rep && n == "4999") {
        if (!rep) {
          finalise(t, e + 1, 0);
          if (t.times(t).times(t).eq(x)) {
            r = t;
            break;
          }
        }
        sd += 4;
        rep = 1;
      } else {
        if (!+n || !+n.slice(1) && n.charAt(0) == "5") {
          finalise(r, e + 1, 1);
          m = !r.times(r).times(r).eq(x);
        }
        break;
      }
    }
  }
  external = true;
  return finalise(r, e, Ctor.rounding, m);
};
P.decimalPlaces = P.dp = function() {
  var w, d = this.d, n = NaN;
  if (d) {
    w = d.length - 1;
    n = (w - mathfloor2(this.e / LOG_BASE2)) * LOG_BASE2;
    w = d[w];
    if (w)
      for (; w % 10 == 0; w /= 10)
        n--;
    if (n < 0)
      n = 0;
  }
  return n;
};
P.dividedBy = P.div = function(y) {
  return divide(this, new this.constructor(y));
};
P.dividedToIntegerBy = P.divToInt = function(y) {
  var x = this, Ctor = x.constructor;
  return finalise(divide(x, new Ctor(y), 0, 1, 1), Ctor.precision, Ctor.rounding);
};
P.equals = P.eq = function(y) {
  return this.cmp(y) === 0;
};
P.floor = function() {
  return finalise(new this.constructor(this), this.e + 1, 3);
};
P.greaterThan = P.gt = function(y) {
  return this.cmp(y) > 0;
};
P.greaterThanOrEqualTo = P.gte = function(y) {
  var k = this.cmp(y);
  return k == 1 || k === 0;
};
P.hyperbolicCosine = P.cosh = function() {
  var k, n, pr, rm, len, x = this, Ctor = x.constructor, one = new Ctor(1);
  if (!x.isFinite())
    return new Ctor(x.s ? 1 / 0 : NaN);
  if (x.isZero())
    return one;
  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + Math.max(x.e, x.sd()) + 4;
  Ctor.rounding = 1;
  len = x.d.length;
  if (len < 32) {
    k = Math.ceil(len / 3);
    n = (1 / tinyPow(4, k)).toString();
  } else {
    k = 16;
    n = "2.3283064365386962890625e-10";
  }
  x = taylorSeries(Ctor, 1, x.times(n), new Ctor(1), true);
  var cosh2_x, i = k, d8 = new Ctor(8);
  for (; i--; ) {
    cosh2_x = x.times(x);
    x = one.minus(cosh2_x.times(d8.minus(cosh2_x.times(d8))));
  }
  return finalise(x, Ctor.precision = pr, Ctor.rounding = rm, true);
};
P.hyperbolicSine = P.sinh = function() {
  var k, pr, rm, len, x = this, Ctor = x.constructor;
  if (!x.isFinite() || x.isZero())
    return new Ctor(x);
  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + Math.max(x.e, x.sd()) + 4;
  Ctor.rounding = 1;
  len = x.d.length;
  if (len < 3) {
    x = taylorSeries(Ctor, 2, x, x, true);
  } else {
    k = 1.4 * Math.sqrt(len);
    k = k > 16 ? 16 : k | 0;
    x = x.times(1 / tinyPow(5, k));
    x = taylorSeries(Ctor, 2, x, x, true);
    var sinh2_x, d5 = new Ctor(5), d16 = new Ctor(16), d20 = new Ctor(20);
    for (; k--; ) {
      sinh2_x = x.times(x);
      x = x.times(d5.plus(sinh2_x.times(d16.times(sinh2_x).plus(d20))));
    }
  }
  Ctor.precision = pr;
  Ctor.rounding = rm;
  return finalise(x, pr, rm, true);
};
P.hyperbolicTangent = P.tanh = function() {
  var pr, rm, x = this, Ctor = x.constructor;
  if (!x.isFinite())
    return new Ctor(x.s);
  if (x.isZero())
    return new Ctor(x);
  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + 7;
  Ctor.rounding = 1;
  return divide(x.sinh(), x.cosh(), Ctor.precision = pr, Ctor.rounding = rm);
};
P.inverseCosine = P.acos = function() {
  var x = this, Ctor = x.constructor, k = x.abs().cmp(1), pr = Ctor.precision, rm = Ctor.rounding;
  if (k !== -1) {
    return k === 0 ? x.isNeg() ? getPi(Ctor, pr, rm) : new Ctor(0) : new Ctor(NaN);
  }
  if (x.isZero())
    return getPi(Ctor, pr + 4, rm).times(0.5);
  Ctor.precision = pr + 6;
  Ctor.rounding = 1;
  x = new Ctor(1).minus(x).div(x.plus(1)).sqrt().atan();
  Ctor.precision = pr;
  Ctor.rounding = rm;
  return x.times(2);
};
P.inverseHyperbolicCosine = P.acosh = function() {
  var pr, rm, x = this, Ctor = x.constructor;
  if (x.lte(1))
    return new Ctor(x.eq(1) ? 0 : NaN);
  if (!x.isFinite())
    return new Ctor(x);
  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + Math.max(Math.abs(x.e), x.sd()) + 4;
  Ctor.rounding = 1;
  external = false;
  x = x.times(x).minus(1).sqrt().plus(x);
  external = true;
  Ctor.precision = pr;
  Ctor.rounding = rm;
  return x.ln();
};
P.inverseHyperbolicSine = P.asinh = function() {
  var pr, rm, x = this, Ctor = x.constructor;
  if (!x.isFinite() || x.isZero())
    return new Ctor(x);
  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + 2 * Math.max(Math.abs(x.e), x.sd()) + 6;
  Ctor.rounding = 1;
  external = false;
  x = x.times(x).plus(1).sqrt().plus(x);
  external = true;
  Ctor.precision = pr;
  Ctor.rounding = rm;
  return x.ln();
};
P.inverseHyperbolicTangent = P.atanh = function() {
  var pr, rm, wpr, xsd, x = this, Ctor = x.constructor;
  if (!x.isFinite())
    return new Ctor(NaN);
  if (x.e >= 0)
    return new Ctor(x.abs().eq(1) ? x.s / 0 : x.isZero() ? x : NaN);
  pr = Ctor.precision;
  rm = Ctor.rounding;
  xsd = x.sd();
  if (Math.max(xsd, pr) < 2 * -x.e - 1)
    return finalise(new Ctor(x), pr, rm, true);
  Ctor.precision = wpr = xsd - x.e;
  x = divide(x.plus(1), new Ctor(1).minus(x), wpr + pr, 1);
  Ctor.precision = pr + 4;
  Ctor.rounding = 1;
  x = x.ln();
  Ctor.precision = pr;
  Ctor.rounding = rm;
  return x.times(0.5);
};
P.inverseSine = P.asin = function() {
  var halfPi, k, pr, rm, x = this, Ctor = x.constructor;
  if (x.isZero())
    return new Ctor(x);
  k = x.abs().cmp(1);
  pr = Ctor.precision;
  rm = Ctor.rounding;
  if (k !== -1) {
    if (k === 0) {
      halfPi = getPi(Ctor, pr + 4, rm).times(0.5);
      halfPi.s = x.s;
      return halfPi;
    }
    return new Ctor(NaN);
  }
  Ctor.precision = pr + 6;
  Ctor.rounding = 1;
  x = x.div(new Ctor(1).minus(x.times(x)).sqrt().plus(1)).atan();
  Ctor.precision = pr;
  Ctor.rounding = rm;
  return x.times(2);
};
P.inverseTangent = P.atan = function() {
  var i, j, k, n, px, t, r, wpr, x2, x = this, Ctor = x.constructor, pr = Ctor.precision, rm = Ctor.rounding;
  if (!x.isFinite()) {
    if (!x.s)
      return new Ctor(NaN);
    if (pr + 4 <= PI_PRECISION) {
      r = getPi(Ctor, pr + 4, rm).times(0.5);
      r.s = x.s;
      return r;
    }
  } else if (x.isZero()) {
    return new Ctor(x);
  } else if (x.abs().eq(1) && pr + 4 <= PI_PRECISION) {
    r = getPi(Ctor, pr + 4, rm).times(0.25);
    r.s = x.s;
    return r;
  }
  Ctor.precision = wpr = pr + 10;
  Ctor.rounding = 1;
  k = Math.min(28, wpr / LOG_BASE2 + 2 | 0);
  for (i = k; i; --i)
    x = x.div(x.times(x).plus(1).sqrt().plus(1));
  external = false;
  j = Math.ceil(wpr / LOG_BASE2);
  n = 1;
  x2 = x.times(x);
  r = new Ctor(x);
  px = x;
  for (; i !== -1; ) {
    px = px.times(x2);
    t = r.minus(px.div(n += 2));
    px = px.times(x2);
    r = t.plus(px.div(n += 2));
    if (r.d[j] !== void 0)
      for (i = j; r.d[i] === t.d[i] && i--; )
        ;
  }
  if (k)
    r = r.times(2 << k - 1);
  external = true;
  return finalise(r, Ctor.precision = pr, Ctor.rounding = rm, true);
};
P.isFinite = function() {
  return !!this.d;
};
P.isInteger = P.isInt = function() {
  return !!this.d && mathfloor2(this.e / LOG_BASE2) > this.d.length - 2;
};
P.isNaN = function() {
  return !this.s;
};
P.isNegative = P.isNeg = function() {
  return this.s < 0;
};
P.isPositive = P.isPos = function() {
  return this.s > 0;
};
P.isZero = function() {
  return !!this.d && this.d[0] === 0;
};
P.lessThan = P.lt = function(y) {
  return this.cmp(y) < 0;
};
P.lessThanOrEqualTo = P.lte = function(y) {
  return this.cmp(y) < 1;
};
P.logarithm = P.log = function(base) {
  var isBase10, d, denominator, k, inf, num, sd, r, arg = this, Ctor = arg.constructor, pr = Ctor.precision, rm = Ctor.rounding, guard = 5;
  if (base == null) {
    base = new Ctor(10);
    isBase10 = true;
  } else {
    base = new Ctor(base);
    d = base.d;
    if (base.s < 0 || !d || !d[0] || base.eq(1))
      return new Ctor(NaN);
    isBase10 = base.eq(10);
  }
  d = arg.d;
  if (arg.s < 0 || !d || !d[0] || arg.eq(1)) {
    return new Ctor(d && !d[0] ? -1 / 0 : arg.s != 1 ? NaN : d ? 0 : 1 / 0);
  }
  if (isBase10) {
    if (d.length > 1) {
      inf = true;
    } else {
      for (k = d[0]; k % 10 === 0; )
        k /= 10;
      inf = k !== 1;
    }
  }
  external = false;
  sd = pr + guard;
  num = naturalLogarithm(arg, sd);
  denominator = isBase10 ? getLn10(Ctor, sd + 10) : naturalLogarithm(base, sd);
  r = divide(num, denominator, sd, 1);
  if (checkRoundingDigits(r.d, k = pr, rm)) {
    do {
      sd += 10;
      num = naturalLogarithm(arg, sd);
      denominator = isBase10 ? getLn10(Ctor, sd + 10) : naturalLogarithm(base, sd);
      r = divide(num, denominator, sd, 1);
      if (!inf) {
        if (+digitsToString(r.d).slice(k + 1, k + 15) + 1 == 1e14) {
          r = finalise(r, pr + 1, 0);
        }
        break;
      }
    } while (checkRoundingDigits(r.d, k += 10, rm));
  }
  external = true;
  return finalise(r, pr, rm);
};
P.minus = P.sub = function(y) {
  var d, e, i, j, k, len, pr, rm, xd, xe, xLTy, yd, x = this, Ctor = x.constructor;
  y = new Ctor(y);
  if (!x.d || !y.d) {
    if (!x.s || !y.s)
      y = new Ctor(NaN);
    else if (x.d)
      y.s = -y.s;
    else
      y = new Ctor(y.d || x.s !== y.s ? x : NaN);
    return y;
  }
  if (x.s != y.s) {
    y.s = -y.s;
    return x.plus(y);
  }
  xd = x.d;
  yd = y.d;
  pr = Ctor.precision;
  rm = Ctor.rounding;
  if (!xd[0] || !yd[0]) {
    if (yd[0])
      y.s = -y.s;
    else if (xd[0])
      y = new Ctor(x);
    else
      return new Ctor(rm === 3 ? -0 : 0);
    return external ? finalise(y, pr, rm) : y;
  }
  e = mathfloor2(y.e / LOG_BASE2);
  xe = mathfloor2(x.e / LOG_BASE2);
  xd = xd.slice();
  k = xe - e;
  if (k) {
    xLTy = k < 0;
    if (xLTy) {
      d = xd;
      k = -k;
      len = yd.length;
    } else {
      d = yd;
      e = xe;
      len = xd.length;
    }
    i = Math.max(Math.ceil(pr / LOG_BASE2), len) + 2;
    if (k > i) {
      k = i;
      d.length = 1;
    }
    d.reverse();
    for (i = k; i--; )
      d.push(0);
    d.reverse();
  } else {
    i = xd.length;
    len = yd.length;
    xLTy = i < len;
    if (xLTy)
      len = i;
    for (i = 0; i < len; i++) {
      if (xd[i] != yd[i]) {
        xLTy = xd[i] < yd[i];
        break;
      }
    }
    k = 0;
  }
  if (xLTy) {
    d = xd;
    xd = yd;
    yd = d;
    y.s = -y.s;
  }
  len = xd.length;
  for (i = yd.length - len; i > 0; --i)
    xd[len++] = 0;
  for (i = yd.length; i > k; ) {
    if (xd[--i] < yd[i]) {
      for (j = i; j && xd[--j] === 0; )
        xd[j] = BASE2 - 1;
      --xd[j];
      xd[i] += BASE2;
    }
    xd[i] -= yd[i];
  }
  for (; xd[--len] === 0; )
    xd.pop();
  for (; xd[0] === 0; xd.shift())
    --e;
  if (!xd[0])
    return new Ctor(rm === 3 ? -0 : 0);
  y.d = xd;
  y.e = getBase10Exponent(xd, e);
  return external ? finalise(y, pr, rm) : y;
};
P.modulo = P.mod = function(y) {
  var q, x = this, Ctor = x.constructor;
  y = new Ctor(y);
  if (!x.d || !y.s || y.d && !y.d[0])
    return new Ctor(NaN);
  if (!y.d || x.d && !x.d[0]) {
    return finalise(new Ctor(x), Ctor.precision, Ctor.rounding);
  }
  external = false;
  if (Ctor.modulo == 9) {
    q = divide(x, y.abs(), 0, 3, 1);
    q.s *= y.s;
  } else {
    q = divide(x, y, 0, Ctor.modulo, 1);
  }
  q = q.times(y);
  external = true;
  return x.minus(q);
};
P.naturalExponential = P.exp = function() {
  return naturalExponential(this);
};
P.naturalLogarithm = P.ln = function() {
  return naturalLogarithm(this);
};
P.negated = P.neg = function() {
  var x = new this.constructor(this);
  x.s = -x.s;
  return finalise(x);
};
P.plus = P.add = function(y) {
  var carry, d, e, i, k, len, pr, rm, xd, yd, x = this, Ctor = x.constructor;
  y = new Ctor(y);
  if (!x.d || !y.d) {
    if (!x.s || !y.s)
      y = new Ctor(NaN);
    else if (!x.d)
      y = new Ctor(y.d || x.s === y.s ? x : NaN);
    return y;
  }
  if (x.s != y.s) {
    y.s = -y.s;
    return x.minus(y);
  }
  xd = x.d;
  yd = y.d;
  pr = Ctor.precision;
  rm = Ctor.rounding;
  if (!xd[0] || !yd[0]) {
    if (!yd[0])
      y = new Ctor(x);
    return external ? finalise(y, pr, rm) : y;
  }
  k = mathfloor2(x.e / LOG_BASE2);
  e = mathfloor2(y.e / LOG_BASE2);
  xd = xd.slice();
  i = k - e;
  if (i) {
    if (i < 0) {
      d = xd;
      i = -i;
      len = yd.length;
    } else {
      d = yd;
      e = k;
      len = xd.length;
    }
    k = Math.ceil(pr / LOG_BASE2);
    len = k > len ? k + 1 : len + 1;
    if (i > len) {
      i = len;
      d.length = 1;
    }
    d.reverse();
    for (; i--; )
      d.push(0);
    d.reverse();
  }
  len = xd.length;
  i = yd.length;
  if (len - i < 0) {
    i = len;
    d = yd;
    yd = xd;
    xd = d;
  }
  for (carry = 0; i; ) {
    carry = (xd[--i] = xd[i] + yd[i] + carry) / BASE2 | 0;
    xd[i] %= BASE2;
  }
  if (carry) {
    xd.unshift(carry);
    ++e;
  }
  for (len = xd.length; xd[--len] == 0; )
    xd.pop();
  y.d = xd;
  y.e = getBase10Exponent(xd, e);
  return external ? finalise(y, pr, rm) : y;
};
P.precision = P.sd = function(z) {
  var k, x = this;
  if (z !== void 0 && z !== !!z && z !== 1 && z !== 0)
    throw Error(invalidArgument + z);
  if (x.d) {
    k = getPrecision(x.d);
    if (z && x.e + 1 > k)
      k = x.e + 1;
  } else {
    k = NaN;
  }
  return k;
};
P.round = function() {
  var x = this, Ctor = x.constructor;
  return finalise(new Ctor(x), x.e + 1, Ctor.rounding);
};
P.sine = P.sin = function() {
  var pr, rm, x = this, Ctor = x.constructor;
  if (!x.isFinite())
    return new Ctor(NaN);
  if (x.isZero())
    return new Ctor(x);
  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + Math.max(x.e, x.sd()) + LOG_BASE2;
  Ctor.rounding = 1;
  x = sine(Ctor, toLessThanHalfPi(Ctor, x));
  Ctor.precision = pr;
  Ctor.rounding = rm;
  return finalise(quadrant > 2 ? x.neg() : x, pr, rm, true);
};
P.squareRoot = P.sqrt = function() {
  var m, n, sd, r, rep, t, x = this, d = x.d, e = x.e, s = x.s, Ctor = x.constructor;
  if (s !== 1 || !d || !d[0]) {
    return new Ctor(!s || s < 0 && (!d || d[0]) ? NaN : d ? x : 1 / 0);
  }
  external = false;
  s = Math.sqrt(+x);
  if (s == 0 || s == 1 / 0) {
    n = digitsToString(d);
    if ((n.length + e) % 2 == 0)
      n += "0";
    s = Math.sqrt(n);
    e = mathfloor2((e + 1) / 2) - (e < 0 || e % 2);
    if (s == 1 / 0) {
      n = "5e" + e;
    } else {
      n = s.toExponential();
      n = n.slice(0, n.indexOf("e") + 1) + e;
    }
    r = new Ctor(n);
  } else {
    r = new Ctor(s.toString());
  }
  sd = (e = Ctor.precision) + 3;
  for (; ; ) {
    t = r;
    r = t.plus(divide(x, t, sd + 2, 1)).times(0.5);
    if (digitsToString(t.d).slice(0, sd) === (n = digitsToString(r.d)).slice(0, sd)) {
      n = n.slice(sd - 3, sd + 1);
      if (n == "9999" || !rep && n == "4999") {
        if (!rep) {
          finalise(t, e + 1, 0);
          if (t.times(t).eq(x)) {
            r = t;
            break;
          }
        }
        sd += 4;
        rep = 1;
      } else {
        if (!+n || !+n.slice(1) && n.charAt(0) == "5") {
          finalise(r, e + 1, 1);
          m = !r.times(r).eq(x);
        }
        break;
      }
    }
  }
  external = true;
  return finalise(r, e, Ctor.rounding, m);
};
P.tangent = P.tan = function() {
  var pr, rm, x = this, Ctor = x.constructor;
  if (!x.isFinite())
    return new Ctor(NaN);
  if (x.isZero())
    return new Ctor(x);
  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + 10;
  Ctor.rounding = 1;
  x = x.sin();
  x.s = 1;
  x = divide(x, new Ctor(1).minus(x.times(x)).sqrt(), pr + 10, 0);
  Ctor.precision = pr;
  Ctor.rounding = rm;
  return finalise(quadrant == 2 || quadrant == 4 ? x.neg() : x, pr, rm, true);
};
P.times = P.mul = function(y) {
  var carry, e, i, k, r, rL, t, xdL, ydL, x = this, Ctor = x.constructor, xd = x.d, yd = (y = new Ctor(y)).d;
  y.s *= x.s;
  if (!xd || !xd[0] || !yd || !yd[0]) {
    return new Ctor(!y.s || xd && !xd[0] && !yd || yd && !yd[0] && !xd ? NaN : !xd || !yd ? y.s / 0 : y.s * 0);
  }
  e = mathfloor2(x.e / LOG_BASE2) + mathfloor2(y.e / LOG_BASE2);
  xdL = xd.length;
  ydL = yd.length;
  if (xdL < ydL) {
    r = xd;
    xd = yd;
    yd = r;
    rL = xdL;
    xdL = ydL;
    ydL = rL;
  }
  r = [];
  rL = xdL + ydL;
  for (i = rL; i--; )
    r.push(0);
  for (i = ydL; --i >= 0; ) {
    carry = 0;
    for (k = xdL + i; k > i; ) {
      t = r[k] + yd[i] * xd[k - i - 1] + carry;
      r[k--] = t % BASE2 | 0;
      carry = t / BASE2 | 0;
    }
    r[k] = (r[k] + carry) % BASE2 | 0;
  }
  for (; !r[--rL]; )
    r.pop();
  if (carry)
    ++e;
  else
    r.shift();
  y.d = r;
  y.e = getBase10Exponent(r, e);
  return external ? finalise(y, Ctor.precision, Ctor.rounding) : y;
};
P.toBinary = function(sd, rm) {
  return toStringBinary(this, 2, sd, rm);
};
P.toDecimalPlaces = P.toDP = function(dp, rm) {
  var x = this, Ctor = x.constructor;
  x = new Ctor(x);
  if (dp === void 0)
    return x;
  checkInt32(dp, 0, MAX_DIGITS);
  if (rm === void 0)
    rm = Ctor.rounding;
  else
    checkInt32(rm, 0, 8);
  return finalise(x, dp + x.e + 1, rm);
};
P.toExponential = function(dp, rm) {
  var str2, x = this, Ctor = x.constructor;
  if (dp === void 0) {
    str2 = finiteToString(x, true);
  } else {
    checkInt32(dp, 0, MAX_DIGITS);
    if (rm === void 0)
      rm = Ctor.rounding;
    else
      checkInt32(rm, 0, 8);
    x = finalise(new Ctor(x), dp + 1, rm);
    str2 = finiteToString(x, true, dp + 1);
  }
  return x.isNeg() && !x.isZero() ? "-" + str2 : str2;
};
P.toFixed = function(dp, rm) {
  var str2, y, x = this, Ctor = x.constructor;
  if (dp === void 0) {
    str2 = finiteToString(x);
  } else {
    checkInt32(dp, 0, MAX_DIGITS);
    if (rm === void 0)
      rm = Ctor.rounding;
    else
      checkInt32(rm, 0, 8);
    y = finalise(new Ctor(x), dp + x.e + 1, rm);
    str2 = finiteToString(y, false, dp + y.e + 1);
  }
  return x.isNeg() && !x.isZero() ? "-" + str2 : str2;
};
P.toFraction = function(maxD) {
  var d, d0, d1, d2, e, k, n, n0, n1, pr, q, r, x = this, xd = x.d, Ctor = x.constructor;
  if (!xd)
    return new Ctor(x);
  n1 = d0 = new Ctor(1);
  d1 = n0 = new Ctor(0);
  d = new Ctor(d1);
  e = d.e = getPrecision(xd) - x.e - 1;
  k = e % LOG_BASE2;
  d.d[0] = mathpow(10, k < 0 ? LOG_BASE2 + k : k);
  if (maxD == null) {
    maxD = e > 0 ? d : n1;
  } else {
    n = new Ctor(maxD);
    if (!n.isInt() || n.lt(n1))
      throw Error(invalidArgument + n);
    maxD = n.gt(d) ? e > 0 ? d : n1 : n;
  }
  external = false;
  n = new Ctor(digitsToString(xd));
  pr = Ctor.precision;
  Ctor.precision = e = xd.length * LOG_BASE2 * 2;
  for (; ; ) {
    q = divide(n, d, 0, 1, 1);
    d2 = d0.plus(q.times(d1));
    if (d2.cmp(maxD) == 1)
      break;
    d0 = d1;
    d1 = d2;
    d2 = n1;
    n1 = n0.plus(q.times(d2));
    n0 = d2;
    d2 = d;
    d = n.minus(q.times(d2));
    n = d2;
  }
  d2 = divide(maxD.minus(d0), d1, 0, 1, 1);
  n0 = n0.plus(d2.times(n1));
  d0 = d0.plus(d2.times(d1));
  n0.s = n1.s = x.s;
  r = divide(n1, d1, e, 1).minus(x).abs().cmp(divide(n0, d0, e, 1).minus(x).abs()) < 1 ? [n1, d1] : [n0, d0];
  Ctor.precision = pr;
  external = true;
  return r;
};
P.toHexadecimal = P.toHex = function(sd, rm) {
  return toStringBinary(this, 16, sd, rm);
};
P.toNearest = function(y, rm) {
  var x = this, Ctor = x.constructor;
  x = new Ctor(x);
  if (y == null) {
    if (!x.d)
      return x;
    y = new Ctor(1);
    rm = Ctor.rounding;
  } else {
    y = new Ctor(y);
    if (rm === void 0) {
      rm = Ctor.rounding;
    } else {
      checkInt32(rm, 0, 8);
    }
    if (!x.d)
      return y.s ? x : y;
    if (!y.d) {
      if (y.s)
        y.s = x.s;
      return y;
    }
  }
  if (y.d[0]) {
    external = false;
    x = divide(x, y, 0, rm, 1).times(y);
    external = true;
    finalise(x);
  } else {
    y.s = x.s;
    x = y;
  }
  return x;
};
P.toNumber = function() {
  return +this;
};
P.toOctal = function(sd, rm) {
  return toStringBinary(this, 8, sd, rm);
};
P.toPower = P.pow = function(y) {
  var e, k, pr, r, rm, s, x = this, Ctor = x.constructor, yn = +(y = new Ctor(y));
  if (!x.d || !y.d || !x.d[0] || !y.d[0])
    return new Ctor(mathpow(+x, yn));
  x = new Ctor(x);
  if (x.eq(1))
    return x;
  pr = Ctor.precision;
  rm = Ctor.rounding;
  if (y.eq(1))
    return finalise(x, pr, rm);
  e = mathfloor2(y.e / LOG_BASE2);
  if (e >= y.d.length - 1 && (k = yn < 0 ? -yn : yn) <= MAX_SAFE_INTEGER2) {
    r = intPow(Ctor, x, k, pr);
    return y.s < 0 ? new Ctor(1).div(r) : finalise(r, pr, rm);
  }
  s = x.s;
  if (s < 0) {
    if (e < y.d.length - 1)
      return new Ctor(NaN);
    if ((y.d[e] & 1) == 0)
      s = 1;
    if (x.e == 0 && x.d[0] == 1 && x.d.length == 1) {
      x.s = s;
      return x;
    }
  }
  k = mathpow(+x, yn);
  e = k == 0 || !isFinite(k) ? mathfloor2(yn * (Math.log("0." + digitsToString(x.d)) / Math.LN10 + x.e + 1)) : new Ctor(k + "").e;
  if (e > Ctor.maxE + 1 || e < Ctor.minE - 1)
    return new Ctor(e > 0 ? s / 0 : 0);
  external = false;
  Ctor.rounding = x.s = 1;
  k = Math.min(12, (e + "").length);
  r = naturalExponential(y.times(naturalLogarithm(x, pr + k)), pr);
  if (r.d) {
    r = finalise(r, pr + 5, 1);
    if (checkRoundingDigits(r.d, pr, rm)) {
      e = pr + 10;
      r = finalise(naturalExponential(y.times(naturalLogarithm(x, e + k)), e), e + 5, 1);
      if (+digitsToString(r.d).slice(pr + 1, pr + 15) + 1 == 1e14) {
        r = finalise(r, pr + 1, 0);
      }
    }
  }
  r.s = s;
  external = true;
  Ctor.rounding = rm;
  return finalise(r, pr, rm);
};
P.toPrecision = function(sd, rm) {
  var str2, x = this, Ctor = x.constructor;
  if (sd === void 0) {
    str2 = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);
  } else {
    checkInt32(sd, 1, MAX_DIGITS);
    if (rm === void 0)
      rm = Ctor.rounding;
    else
      checkInt32(rm, 0, 8);
    x = finalise(new Ctor(x), sd, rm);
    str2 = finiteToString(x, sd <= x.e || x.e <= Ctor.toExpNeg, sd);
  }
  return x.isNeg() && !x.isZero() ? "-" + str2 : str2;
};
P.toSignificantDigits = P.toSD = function(sd, rm) {
  var x = this, Ctor = x.constructor;
  if (sd === void 0) {
    sd = Ctor.precision;
    rm = Ctor.rounding;
  } else {
    checkInt32(sd, 1, MAX_DIGITS);
    if (rm === void 0)
      rm = Ctor.rounding;
    else
      checkInt32(rm, 0, 8);
  }
  return finalise(new Ctor(x), sd, rm);
};
P.toString = function() {
  var x = this, Ctor = x.constructor, str2 = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);
  return x.isNeg() && !x.isZero() ? "-" + str2 : str2;
};
P.truncated = P.trunc = function() {
  return finalise(new this.constructor(this), this.e + 1, 1);
};
P.valueOf = P.toJSON = function() {
  var x = this, Ctor = x.constructor, str2 = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);
  return x.isNeg() ? "-" + str2 : str2;
};
function digitsToString(d) {
  var i, k, ws, indexOfLastWord = d.length - 1, str2 = "", w = d[0];
  if (indexOfLastWord > 0) {
    str2 += w;
    for (i = 1; i < indexOfLastWord; i++) {
      ws = d[i] + "";
      k = LOG_BASE2 - ws.length;
      if (k)
        str2 += getZeroString(k);
      str2 += ws;
    }
    w = d[i];
    ws = w + "";
    k = LOG_BASE2 - ws.length;
    if (k)
      str2 += getZeroString(k);
  } else if (w === 0) {
    return "0";
  }
  for (; w % 10 === 0; )
    w /= 10;
  return str2 + w;
}
function checkInt32(i, min2, max2) {
  if (i !== ~~i || i < min2 || i > max2) {
    throw Error(invalidArgument + i);
  }
}
function checkRoundingDigits(d, i, rm, repeating) {
  var di, k, r, rd;
  for (k = d[0]; k >= 10; k /= 10)
    --i;
  if (--i < 0) {
    i += LOG_BASE2;
    di = 0;
  } else {
    di = Math.ceil((i + 1) / LOG_BASE2);
    i %= LOG_BASE2;
  }
  k = mathpow(10, LOG_BASE2 - i);
  rd = d[di] % k | 0;
  if (repeating == null) {
    if (i < 3) {
      if (i == 0)
        rd = rd / 100 | 0;
      else if (i == 1)
        rd = rd / 10 | 0;
      r = rm < 4 && rd == 99999 || rm > 3 && rd == 49999 || rd == 5e4 || rd == 0;
    } else {
      r = (rm < 4 && rd + 1 == k || rm > 3 && rd + 1 == k / 2) && (d[di + 1] / k / 100 | 0) == mathpow(10, i - 2) - 1 || (rd == k / 2 || rd == 0) && (d[di + 1] / k / 100 | 0) == 0;
    }
  } else {
    if (i < 4) {
      if (i == 0)
        rd = rd / 1e3 | 0;
      else if (i == 1)
        rd = rd / 100 | 0;
      else if (i == 2)
        rd = rd / 10 | 0;
      r = (repeating || rm < 4) && rd == 9999 || !repeating && rm > 3 && rd == 4999;
    } else {
      r = ((repeating || rm < 4) && rd + 1 == k || !repeating && rm > 3 && rd + 1 == k / 2) && (d[di + 1] / k / 1e3 | 0) == mathpow(10, i - 3) - 1;
    }
  }
  return r;
}
function convertBase(str2, baseIn, baseOut) {
  var j, arr = [0], arrL, i = 0, strL = str2.length;
  for (; i < strL; ) {
    for (arrL = arr.length; arrL--; )
      arr[arrL] *= baseIn;
    arr[0] += NUMERALS.indexOf(str2.charAt(i++));
    for (j = 0; j < arr.length; j++) {
      if (arr[j] > baseOut - 1) {
        if (arr[j + 1] === void 0)
          arr[j + 1] = 0;
        arr[j + 1] += arr[j] / baseOut | 0;
        arr[j] %= baseOut;
      }
    }
  }
  return arr.reverse();
}
function cosine(Ctor, x) {
  var k, len, y;
  if (x.isZero())
    return x;
  len = x.d.length;
  if (len < 32) {
    k = Math.ceil(len / 3);
    y = (1 / tinyPow(4, k)).toString();
  } else {
    k = 16;
    y = "2.3283064365386962890625e-10";
  }
  Ctor.precision += k;
  x = taylorSeries(Ctor, 1, x.times(y), new Ctor(1));
  for (var i = k; i--; ) {
    var cos2x = x.times(x);
    x = cos2x.times(cos2x).minus(cos2x).times(8).plus(1);
  }
  Ctor.precision -= k;
  return x;
}
var divide = /* @__PURE__ */ function() {
  function multiplyInteger(x, k, base) {
    var temp, carry = 0, i = x.length;
    for (x = x.slice(); i--; ) {
      temp = x[i] * k + carry;
      x[i] = temp % base | 0;
      carry = temp / base | 0;
    }
    if (carry)
      x.unshift(carry);
    return x;
  }
  function compare2(a, b, aL, bL) {
    var i, r;
    if (aL != bL) {
      r = aL > bL ? 1 : -1;
    } else {
      for (i = r = 0; i < aL; i++) {
        if (a[i] != b[i]) {
          r = a[i] > b[i] ? 1 : -1;
          break;
        }
      }
    }
    return r;
  }
  function subtract(a, b, aL, base) {
    var i = 0;
    for (; aL--; ) {
      a[aL] -= i;
      i = a[aL] < b[aL] ? 1 : 0;
      a[aL] = i * base + a[aL] - b[aL];
    }
    for (; !a[0] && a.length > 1; )
      a.shift();
  }
  return function(x, y, pr, rm, dp, base) {
    var cmp, e, i, k, logBase, more, prod, prodL, q, qd, rem, remL, rem0, sd, t, xi, xL, yd0, yL, yz, Ctor = x.constructor, sign2 = x.s == y.s ? 1 : -1, xd = x.d, yd = y.d;
    if (!xd || !xd[0] || !yd || !yd[0]) {
      return new Ctor(
        // Return NaN if either NaN, or both Infinity or 0.
        !x.s || !y.s || (xd ? yd && xd[0] == yd[0] : !yd) ? NaN : (
          // Return 0 if x is 0 or y is Infinity, or return Infinity as y is 0.
          xd && xd[0] == 0 || !yd ? sign2 * 0 : sign2 / 0
        )
      );
    }
    if (base) {
      logBase = 1;
      e = x.e - y.e;
    } else {
      base = BASE2;
      logBase = LOG_BASE2;
      e = mathfloor2(x.e / logBase) - mathfloor2(y.e / logBase);
    }
    yL = yd.length;
    xL = xd.length;
    q = new Ctor(sign2);
    qd = q.d = [];
    for (i = 0; yd[i] == (xd[i] || 0); i++)
      ;
    if (yd[i] > (xd[i] || 0))
      e--;
    if (pr == null) {
      sd = pr = Ctor.precision;
      rm = Ctor.rounding;
    } else if (dp) {
      sd = pr + (x.e - y.e) + 1;
    } else {
      sd = pr;
    }
    if (sd < 0) {
      qd.push(1);
      more = true;
    } else {
      sd = sd / logBase + 2 | 0;
      i = 0;
      if (yL == 1) {
        k = 0;
        yd = yd[0];
        sd++;
        for (; (i < xL || k) && sd--; i++) {
          t = k * base + (xd[i] || 0);
          qd[i] = t / yd | 0;
          k = t % yd | 0;
        }
        more = k || i < xL;
      } else {
        k = base / (yd[0] + 1) | 0;
        if (k > 1) {
          yd = multiplyInteger(yd, k, base);
          xd = multiplyInteger(xd, k, base);
          yL = yd.length;
          xL = xd.length;
        }
        xi = yL;
        rem = xd.slice(0, yL);
        remL = rem.length;
        for (; remL < yL; )
          rem[remL++] = 0;
        yz = yd.slice();
        yz.unshift(0);
        yd0 = yd[0];
        if (yd[1] >= base / 2)
          ++yd0;
        do {
          k = 0;
          cmp = compare2(yd, rem, yL, remL);
          if (cmp < 0) {
            rem0 = rem[0];
            if (yL != remL)
              rem0 = rem0 * base + (rem[1] || 0);
            k = rem0 / yd0 | 0;
            if (k > 1) {
              if (k >= base)
                k = base - 1;
              prod = multiplyInteger(yd, k, base);
              prodL = prod.length;
              remL = rem.length;
              cmp = compare2(prod, rem, prodL, remL);
              if (cmp == 1) {
                k--;
                subtract(prod, yL < prodL ? yz : yd, prodL, base);
              }
            } else {
              if (k == 0)
                cmp = k = 1;
              prod = yd.slice();
            }
            prodL = prod.length;
            if (prodL < remL)
              prod.unshift(0);
            subtract(rem, prod, remL, base);
            if (cmp == -1) {
              remL = rem.length;
              cmp = compare2(yd, rem, yL, remL);
              if (cmp < 1) {
                k++;
                subtract(rem, yL < remL ? yz : yd, remL, base);
              }
            }
            remL = rem.length;
          } else if (cmp === 0) {
            k++;
            rem = [0];
          }
          qd[i++] = k;
          if (cmp && rem[0]) {
            rem[remL++] = xd[xi] || 0;
          } else {
            rem = [xd[xi]];
            remL = 1;
          }
        } while ((xi++ < xL || rem[0] !== void 0) && sd--);
        more = rem[0] !== void 0;
      }
      if (!qd[0])
        qd.shift();
    }
    if (logBase == 1) {
      q.e = e;
      inexact = more;
    } else {
      for (i = 1, k = qd[0]; k >= 10; k /= 10)
        i++;
      q.e = i + e * logBase - 1;
      finalise(q, dp ? pr + q.e + 1 : pr, rm, more);
    }
    return q;
  };
}();
function finalise(x, sd, rm, isTruncated) {
  var digits, i, j, k, rd, roundUp, w, xd, xdi, Ctor = x.constructor;
  out:
    if (sd != null) {
      xd = x.d;
      if (!xd)
        return x;
      for (digits = 1, k = xd[0]; k >= 10; k /= 10)
        digits++;
      i = sd - digits;
      if (i < 0) {
        i += LOG_BASE2;
        j = sd;
        w = xd[xdi = 0];
        rd = w / mathpow(10, digits - j - 1) % 10 | 0;
      } else {
        xdi = Math.ceil((i + 1) / LOG_BASE2);
        k = xd.length;
        if (xdi >= k) {
          if (isTruncated) {
            for (; k++ <= xdi; )
              xd.push(0);
            w = rd = 0;
            digits = 1;
            i %= LOG_BASE2;
            j = i - LOG_BASE2 + 1;
          } else {
            break out;
          }
        } else {
          w = k = xd[xdi];
          for (digits = 1; k >= 10; k /= 10)
            digits++;
          i %= LOG_BASE2;
          j = i - LOG_BASE2 + digits;
          rd = j < 0 ? 0 : w / mathpow(10, digits - j - 1) % 10 | 0;
        }
      }
      isTruncated = isTruncated || sd < 0 || xd[xdi + 1] !== void 0 || (j < 0 ? w : w % mathpow(10, digits - j - 1));
      roundUp = rm < 4 ? (rd || isTruncated) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : rd > 5 || rd == 5 && (rm == 4 || isTruncated || rm == 6 && // Check whether the digit to the left of the rounding digit is odd.
      (i > 0 ? j > 0 ? w / mathpow(10, digits - j) : 0 : xd[xdi - 1]) % 10 & 1 || rm == (x.s < 0 ? 8 : 7));
      if (sd < 1 || !xd[0]) {
        xd.length = 0;
        if (roundUp) {
          sd -= x.e + 1;
          xd[0] = mathpow(10, (LOG_BASE2 - sd % LOG_BASE2) % LOG_BASE2);
          x.e = -sd || 0;
        } else {
          xd[0] = x.e = 0;
        }
        return x;
      }
      if (i == 0) {
        xd.length = xdi;
        k = 1;
        xdi--;
      } else {
        xd.length = xdi + 1;
        k = mathpow(10, LOG_BASE2 - i);
        xd[xdi] = j > 0 ? (w / mathpow(10, digits - j) % mathpow(10, j) | 0) * k : 0;
      }
      if (roundUp) {
        for (; ; ) {
          if (xdi == 0) {
            for (i = 1, j = xd[0]; j >= 10; j /= 10)
              i++;
            j = xd[0] += k;
            for (k = 1; j >= 10; j /= 10)
              k++;
            if (i != k) {
              x.e++;
              if (xd[0] == BASE2)
                xd[0] = 1;
            }
            break;
          } else {
            xd[xdi] += k;
            if (xd[xdi] != BASE2)
              break;
            xd[xdi--] = 0;
            k = 1;
          }
        }
      }
      for (i = xd.length; xd[--i] === 0; )
        xd.pop();
    }
  if (external) {
    if (x.e > Ctor.maxE) {
      x.d = null;
      x.e = NaN;
    } else if (x.e < Ctor.minE) {
      x.e = 0;
      x.d = [0];
    }
  }
  return x;
}
function finiteToString(x, isExp, sd) {
  if (!x.isFinite())
    return nonFiniteToString(x);
  var k, e = x.e, str2 = digitsToString(x.d), len = str2.length;
  if (isExp) {
    if (sd && (k = sd - len) > 0) {
      str2 = str2.charAt(0) + "." + str2.slice(1) + getZeroString(k);
    } else if (len > 1) {
      str2 = str2.charAt(0) + "." + str2.slice(1);
    }
    str2 = str2 + (x.e < 0 ? "e" : "e+") + x.e;
  } else if (e < 0) {
    str2 = "0." + getZeroString(-e - 1) + str2;
    if (sd && (k = sd - len) > 0)
      str2 += getZeroString(k);
  } else if (e >= len) {
    str2 += getZeroString(e + 1 - len);
    if (sd && (k = sd - e - 1) > 0)
      str2 = str2 + "." + getZeroString(k);
  } else {
    if ((k = e + 1) < len)
      str2 = str2.slice(0, k) + "." + str2.slice(k);
    if (sd && (k = sd - len) > 0) {
      if (e + 1 === len)
        str2 += ".";
      str2 += getZeroString(k);
    }
  }
  return str2;
}
function getBase10Exponent(digits, e) {
  var w = digits[0];
  for (e *= LOG_BASE2; w >= 10; w /= 10)
    e++;
  return e;
}
function getLn10(Ctor, sd, pr) {
  if (sd > LN10_PRECISION) {
    external = true;
    if (pr)
      Ctor.precision = pr;
    throw Error(precisionLimitExceeded);
  }
  return finalise(new Ctor(LN10), sd, 1, true);
}
function getPi(Ctor, sd, rm) {
  if (sd > PI_PRECISION)
    throw Error(precisionLimitExceeded);
  return finalise(new Ctor(PI), sd, rm, true);
}
function getPrecision(digits) {
  var w = digits.length - 1, len = w * LOG_BASE2 + 1;
  w = digits[w];
  if (w) {
    for (; w % 10 == 0; w /= 10)
      len--;
    for (w = digits[0]; w >= 10; w /= 10)
      len++;
  }
  return len;
}
function getZeroString(k) {
  var zs = "";
  for (; k--; )
    zs += "0";
  return zs;
}
function intPow(Ctor, x, n, pr) {
  var isTruncated, r = new Ctor(1), k = Math.ceil(pr / LOG_BASE2 + 4);
  external = false;
  for (; ; ) {
    if (n % 2) {
      r = r.times(x);
      if (truncate(r.d, k))
        isTruncated = true;
    }
    n = mathfloor2(n / 2);
    if (n === 0) {
      n = r.d.length - 1;
      if (isTruncated && r.d[n] === 0)
        ++r.d[n];
      break;
    }
    x = x.times(x);
    truncate(x.d, k);
  }
  external = true;
  return r;
}
function isOdd2(n) {
  return n.d[n.d.length - 1] & 1;
}
function maxOrMin(Ctor, args, n) {
  var k, y, x = new Ctor(args[0]), i = 0;
  for (; ++i < args.length; ) {
    y = new Ctor(args[i]);
    if (!y.s) {
      x = y;
      break;
    }
    k = x.cmp(y);
    if (k === n || k === 0 && x.s === n) {
      x = y;
    }
  }
  return x;
}
function naturalExponential(x, sd) {
  var denominator, guard, j, pow2, sum2, t, wpr, rep = 0, i = 0, k = 0, Ctor = x.constructor, rm = Ctor.rounding, pr = Ctor.precision;
  if (!x.d || !x.d[0] || x.e > 17) {
    return new Ctor(x.d ? !x.d[0] ? 1 : x.s < 0 ? 0 : 1 / 0 : x.s ? x.s < 0 ? 0 : x : 0 / 0);
  }
  if (sd == null) {
    external = false;
    wpr = pr;
  } else {
    wpr = sd;
  }
  t = new Ctor(0.03125);
  while (x.e > -2) {
    x = x.times(t);
    k += 5;
  }
  guard = Math.log(mathpow(2, k)) / Math.LN10 * 2 + 5 | 0;
  wpr += guard;
  denominator = pow2 = sum2 = new Ctor(1);
  Ctor.precision = wpr;
  for (; ; ) {
    pow2 = finalise(pow2.times(x), wpr, 1);
    denominator = denominator.times(++i);
    t = sum2.plus(divide(pow2, denominator, wpr, 1));
    if (digitsToString(t.d).slice(0, wpr) === digitsToString(sum2.d).slice(0, wpr)) {
      j = k;
      while (j--)
        sum2 = finalise(sum2.times(sum2), wpr, 1);
      if (sd == null) {
        if (rep < 3 && checkRoundingDigits(sum2.d, wpr - guard, rm, rep)) {
          Ctor.precision = wpr += 10;
          denominator = pow2 = t = new Ctor(1);
          i = 0;
          rep++;
        } else {
          return finalise(sum2, Ctor.precision = pr, rm, external = true);
        }
      } else {
        Ctor.precision = pr;
        return sum2;
      }
    }
    sum2 = t;
  }
}
function naturalLogarithm(y, sd) {
  var c, c0, denominator, e, numerator, rep, sum2, t, wpr, x1, x2, n = 1, guard = 10, x = y, xd = x.d, Ctor = x.constructor, rm = Ctor.rounding, pr = Ctor.precision;
  if (x.s < 0 || !xd || !xd[0] || !x.e && xd[0] == 1 && xd.length == 1) {
    return new Ctor(xd && !xd[0] ? -1 / 0 : x.s != 1 ? NaN : xd ? 0 : x);
  }
  if (sd == null) {
    external = false;
    wpr = pr;
  } else {
    wpr = sd;
  }
  Ctor.precision = wpr += guard;
  c = digitsToString(xd);
  c0 = c.charAt(0);
  if (Math.abs(e = x.e) < 15e14) {
    while (c0 < 7 && c0 != 1 || c0 == 1 && c.charAt(1) > 3) {
      x = x.times(y);
      c = digitsToString(x.d);
      c0 = c.charAt(0);
      n++;
    }
    e = x.e;
    if (c0 > 1) {
      x = new Ctor("0." + c);
      e++;
    } else {
      x = new Ctor(c0 + "." + c.slice(1));
    }
  } else {
    t = getLn10(Ctor, wpr + 2, pr).times(e + "");
    x = naturalLogarithm(new Ctor(c0 + "." + c.slice(1)), wpr - guard).plus(t);
    Ctor.precision = pr;
    return sd == null ? finalise(x, pr, rm, external = true) : x;
  }
  x1 = x;
  sum2 = numerator = x = divide(x.minus(1), x.plus(1), wpr, 1);
  x2 = finalise(x.times(x), wpr, 1);
  denominator = 3;
  for (; ; ) {
    numerator = finalise(numerator.times(x2), wpr, 1);
    t = sum2.plus(divide(numerator, new Ctor(denominator), wpr, 1));
    if (digitsToString(t.d).slice(0, wpr) === digitsToString(sum2.d).slice(0, wpr)) {
      sum2 = sum2.times(2);
      if (e !== 0)
        sum2 = sum2.plus(getLn10(Ctor, wpr + 2, pr).times(e + ""));
      sum2 = divide(sum2, new Ctor(n), wpr, 1);
      if (sd == null) {
        if (checkRoundingDigits(sum2.d, wpr - guard, rm, rep)) {
          Ctor.precision = wpr += guard;
          t = numerator = x = divide(x1.minus(1), x1.plus(1), wpr, 1);
          x2 = finalise(x.times(x), wpr, 1);
          denominator = rep = 1;
        } else {
          return finalise(sum2, Ctor.precision = pr, rm, external = true);
        }
      } else {
        Ctor.precision = pr;
        return sum2;
      }
    }
    sum2 = t;
    denominator += 2;
  }
}
function nonFiniteToString(x) {
  return String(x.s * x.s / 0);
}
function parseDecimal(x, str2) {
  var e, i, len;
  if ((e = str2.indexOf(".")) > -1)
    str2 = str2.replace(".", "");
  if ((i = str2.search(/e/i)) > 0) {
    if (e < 0)
      e = i;
    e += +str2.slice(i + 1);
    str2 = str2.substring(0, i);
  } else if (e < 0) {
    e = str2.length;
  }
  for (i = 0; str2.charCodeAt(i) === 48; i++)
    ;
  for (len = str2.length; str2.charCodeAt(len - 1) === 48; --len)
    ;
  str2 = str2.slice(i, len);
  if (str2) {
    len -= i;
    x.e = e = e - i - 1;
    x.d = [];
    i = (e + 1) % LOG_BASE2;
    if (e < 0)
      i += LOG_BASE2;
    if (i < len) {
      if (i)
        x.d.push(+str2.slice(0, i));
      for (len -= LOG_BASE2; i < len; )
        x.d.push(+str2.slice(i, i += LOG_BASE2));
      str2 = str2.slice(i);
      i = LOG_BASE2 - str2.length;
    } else {
      i -= len;
    }
    for (; i--; )
      str2 += "0";
    x.d.push(+str2);
    if (external) {
      if (x.e > x.constructor.maxE) {
        x.d = null;
        x.e = NaN;
      } else if (x.e < x.constructor.minE) {
        x.e = 0;
        x.d = [0];
      }
    }
  } else {
    x.e = 0;
    x.d = [0];
  }
  return x;
}
function parseOther(x, str2) {
  var base, Ctor, divisor, i, isFloat, len, p, xd, xe;
  if (str2.indexOf("_") > -1) {
    str2 = str2.replace(/(\d)_(?=\d)/g, "$1");
    if (isDecimal2.test(str2))
      return parseDecimal(x, str2);
  } else if (str2 === "Infinity" || str2 === "NaN") {
    if (!+str2)
      x.s = NaN;
    x.e = NaN;
    x.d = null;
    return x;
  }
  if (isHex.test(str2)) {
    base = 16;
    str2 = str2.toLowerCase();
  } else if (isBinary.test(str2)) {
    base = 2;
  } else if (isOctal.test(str2)) {
    base = 8;
  } else {
    throw Error(invalidArgument + str2);
  }
  i = str2.search(/p/i);
  if (i > 0) {
    p = +str2.slice(i + 1);
    str2 = str2.substring(2, i);
  } else {
    str2 = str2.slice(2);
  }
  i = str2.indexOf(".");
  isFloat = i >= 0;
  Ctor = x.constructor;
  if (isFloat) {
    str2 = str2.replace(".", "");
    len = str2.length;
    i = len - i;
    divisor = intPow(Ctor, new Ctor(base), i, i * 2);
  }
  xd = convertBase(str2, base, BASE2);
  xe = xd.length - 1;
  for (i = xe; xd[i] === 0; --i)
    xd.pop();
  if (i < 0)
    return new Ctor(x.s * 0);
  x.e = getBase10Exponent(xd, xe);
  x.d = xd;
  external = false;
  if (isFloat)
    x = divide(x, divisor, len * 4);
  if (p)
    x = x.times(Math.abs(p) < 54 ? mathpow(2, p) : Decimal.pow(2, p));
  external = true;
  return x;
}
function sine(Ctor, x) {
  var k, len = x.d.length;
  if (len < 3) {
    return x.isZero() ? x : taylorSeries(Ctor, 2, x, x);
  }
  k = 1.4 * Math.sqrt(len);
  k = k > 16 ? 16 : k | 0;
  x = x.times(1 / tinyPow(5, k));
  x = taylorSeries(Ctor, 2, x, x);
  var sin2_x, d5 = new Ctor(5), d16 = new Ctor(16), d20 = new Ctor(20);
  for (; k--; ) {
    sin2_x = x.times(x);
    x = x.times(d5.plus(sin2_x.times(d16.times(sin2_x).minus(d20))));
  }
  return x;
}
function taylorSeries(Ctor, n, x, y, isHyperbolic) {
  var j, t, u, x2, i = 1, pr = Ctor.precision, k = Math.ceil(pr / LOG_BASE2);
  external = false;
  x2 = x.times(x);
  u = new Ctor(y);
  for (; ; ) {
    t = divide(u.times(x2), new Ctor(n++ * n++), pr, 1);
    u = isHyperbolic ? y.plus(t) : y.minus(t);
    y = divide(t.times(x2), new Ctor(n++ * n++), pr, 1);
    t = u.plus(y);
    if (t.d[k] !== void 0) {
      for (j = k; t.d[j] === u.d[j] && j--; )
        ;
      if (j == -1)
        break;
    }
    j = u;
    u = y;
    y = t;
    t = j;
    i++;
  }
  external = true;
  t.d.length = k + 1;
  return t;
}
function tinyPow(b, e) {
  var n = b;
  while (--e)
    n *= b;
  return n;
}
function toLessThanHalfPi(Ctor, x) {
  var t, isNeg = x.s < 0, pi = getPi(Ctor, Ctor.precision, 1), halfPi = pi.times(0.5);
  x = x.abs();
  if (x.lte(halfPi)) {
    quadrant = isNeg ? 4 : 1;
    return x;
  }
  t = x.divToInt(pi);
  if (t.isZero()) {
    quadrant = isNeg ? 3 : 2;
  } else {
    x = x.minus(t.times(pi));
    if (x.lte(halfPi)) {
      quadrant = isOdd2(t) ? isNeg ? 2 : 3 : isNeg ? 4 : 1;
      return x;
    }
    quadrant = isOdd2(t) ? isNeg ? 1 : 4 : isNeg ? 3 : 2;
  }
  return x.minus(pi).abs();
}
function toStringBinary(x, baseOut, sd, rm) {
  var base, e, i, k, len, roundUp, str2, xd, y, Ctor = x.constructor, isExp = sd !== void 0;
  if (isExp) {
    checkInt32(sd, 1, MAX_DIGITS);
    if (rm === void 0)
      rm = Ctor.rounding;
    else
      checkInt32(rm, 0, 8);
  } else {
    sd = Ctor.precision;
    rm = Ctor.rounding;
  }
  if (!x.isFinite()) {
    str2 = nonFiniteToString(x);
  } else {
    str2 = finiteToString(x);
    i = str2.indexOf(".");
    if (isExp) {
      base = 2;
      if (baseOut == 16) {
        sd = sd * 4 - 3;
      } else if (baseOut == 8) {
        sd = sd * 3 - 2;
      }
    } else {
      base = baseOut;
    }
    if (i >= 0) {
      str2 = str2.replace(".", "");
      y = new Ctor(1);
      y.e = str2.length - i;
      y.d = convertBase(finiteToString(y), 10, base);
      y.e = y.d.length;
    }
    xd = convertBase(str2, 10, base);
    e = len = xd.length;
    for (; xd[--len] == 0; )
      xd.pop();
    if (!xd[0]) {
      str2 = isExp ? "0p+0" : "0";
    } else {
      if (i < 0) {
        e--;
      } else {
        x = new Ctor(x);
        x.d = xd;
        x.e = e;
        x = divide(x, y, sd, rm, 0, base);
        xd = x.d;
        e = x.e;
        roundUp = inexact;
      }
      i = xd[sd];
      k = base / 2;
      roundUp = roundUp || xd[sd + 1] !== void 0;
      roundUp = rm < 4 ? (i !== void 0 || roundUp) && (rm === 0 || rm === (x.s < 0 ? 3 : 2)) : i > k || i === k && (rm === 4 || roundUp || rm === 6 && xd[sd - 1] & 1 || rm === (x.s < 0 ? 8 : 7));
      xd.length = sd;
      if (roundUp) {
        for (; ++xd[--sd] > base - 1; ) {
          xd[sd] = 0;
          if (!sd) {
            ++e;
            xd.unshift(1);
          }
        }
      }
      for (len = xd.length; !xd[len - 1]; --len)
        ;
      for (i = 0, str2 = ""; i < len; i++)
        str2 += NUMERALS.charAt(xd[i]);
      if (isExp) {
        if (len > 1) {
          if (baseOut == 16 || baseOut == 8) {
            i = baseOut == 16 ? 4 : 3;
            for (--len; len % i; len++)
              str2 += "0";
            xd = convertBase(str2, base, baseOut);
            for (len = xd.length; !xd[len - 1]; --len)
              ;
            for (i = 1, str2 = "1."; i < len; i++)
              str2 += NUMERALS.charAt(xd[i]);
          } else {
            str2 = str2.charAt(0) + "." + str2.slice(1);
          }
        }
        str2 = str2 + (e < 0 ? "p" : "p+") + e;
      } else if (e < 0) {
        for (; ++e; )
          str2 = "0" + str2;
        str2 = "0." + str2;
      } else {
        if (++e > len)
          for (e -= len; e--; )
            str2 += "0";
        else if (e < len)
          str2 = str2.slice(0, e) + "." + str2.slice(e);
      }
    }
    str2 = (baseOut == 16 ? "0x" : baseOut == 2 ? "0b" : baseOut == 8 ? "0o" : "") + str2;
  }
  return x.s < 0 ? "-" + str2 : str2;
}
function truncate(arr, len) {
  if (arr.length > len) {
    arr.length = len;
    return true;
  }
}
function abs(x) {
  return new this(x).abs();
}
function acos(x) {
  return new this(x).acos();
}
function acosh(x) {
  return new this(x).acosh();
}
function add2(x, y) {
  return new this(x).plus(y);
}
function asin(x) {
  return new this(x).asin();
}
function asinh(x) {
  return new this(x).asinh();
}
function atan(x) {
  return new this(x).atan();
}
function atanh(x) {
  return new this(x).atanh();
}
function atan2(y, x) {
  y = new this(y);
  x = new this(x);
  var r, pr = this.precision, rm = this.rounding, wpr = pr + 4;
  if (!y.s || !x.s) {
    r = new this(NaN);
  } else if (!y.d && !x.d) {
    r = getPi(this, wpr, 1).times(x.s > 0 ? 0.25 : 0.75);
    r.s = y.s;
  } else if (!x.d || y.isZero()) {
    r = x.s < 0 ? getPi(this, pr, rm) : new this(0);
    r.s = y.s;
  } else if (!y.d || x.isZero()) {
    r = getPi(this, wpr, 1).times(0.5);
    r.s = y.s;
  } else if (x.s < 0) {
    this.precision = wpr;
    this.rounding = 1;
    r = this.atan(divide(y, x, wpr, 1));
    x = getPi(this, wpr, 1);
    this.precision = pr;
    this.rounding = rm;
    r = y.s < 0 ? r.minus(x) : r.plus(x);
  } else {
    r = this.atan(divide(y, x, wpr, 1));
  }
  return r;
}
function cbrt(x) {
  return new this(x).cbrt();
}
function ceil(x) {
  return finalise(x = new this(x), x.e + 1, 2);
}
function clamp(x, min2, max2) {
  return new this(x).clamp(min2, max2);
}
function config(obj) {
  if (!obj || typeof obj !== "object")
    throw Error(decimalError + "Object expected");
  var i, p, v, useDefaults = obj.defaults === true, ps = [
    "precision",
    1,
    MAX_DIGITS,
    "rounding",
    0,
    8,
    "toExpNeg",
    -EXP_LIMIT,
    0,
    "toExpPos",
    0,
    EXP_LIMIT,
    "maxE",
    0,
    EXP_LIMIT,
    "minE",
    -EXP_LIMIT,
    0,
    "modulo",
    0,
    9
  ];
  for (i = 0; i < ps.length; i += 3) {
    if (p = ps[i], useDefaults)
      this[p] = DEFAULTS[p];
    if ((v = obj[p]) !== void 0) {
      if (mathfloor2(v) === v && v >= ps[i + 1] && v <= ps[i + 2])
        this[p] = v;
      else
        throw Error(invalidArgument + p + ": " + v);
    }
  }
  if (p = "crypto", useDefaults)
    this[p] = DEFAULTS[p];
  if ((v = obj[p]) !== void 0) {
    if (v === true || v === false || v === 0 || v === 1) {
      if (v) {
        if (typeof crypto != "undefined" && crypto && (crypto.getRandomValues || crypto.randomBytes)) {
          this[p] = true;
        } else {
          throw Error(cryptoUnavailable);
        }
      } else {
        this[p] = false;
      }
    } else {
      throw Error(invalidArgument + p + ": " + v);
    }
  }
  return this;
}
function cos(x) {
  return new this(x).cos();
}
function cosh(x) {
  return new this(x).cosh();
}
function clone2(obj) {
  var i, p, ps;
  function Decimal2(v) {
    var e, i2, t, x = this;
    if (!(x instanceof Decimal2))
      return new Decimal2(v);
    x.constructor = Decimal2;
    if (isDecimalInstance(v)) {
      x.s = v.s;
      if (external) {
        if (!v.d || v.e > Decimal2.maxE) {
          x.e = NaN;
          x.d = null;
        } else if (v.e < Decimal2.minE) {
          x.e = 0;
          x.d = [0];
        } else {
          x.e = v.e;
          x.d = v.d.slice();
        }
      } else {
        x.e = v.e;
        x.d = v.d ? v.d.slice() : v.d;
      }
      return;
    }
    t = typeof v;
    if (t === "number") {
      if (v === 0) {
        x.s = 1 / v < 0 ? -1 : 1;
        x.e = 0;
        x.d = [0];
        return;
      }
      if (v < 0) {
        v = -v;
        x.s = -1;
      } else {
        x.s = 1;
      }
      if (v === ~~v && v < 1e7) {
        for (e = 0, i2 = v; i2 >= 10; i2 /= 10)
          e++;
        if (external) {
          if (e > Decimal2.maxE) {
            x.e = NaN;
            x.d = null;
          } else if (e < Decimal2.minE) {
            x.e = 0;
            x.d = [0];
          } else {
            x.e = e;
            x.d = [v];
          }
        } else {
          x.e = e;
          x.d = [v];
        }
        return;
      }
      if (v * 0 !== 0) {
        if (!v)
          x.s = NaN;
        x.e = NaN;
        x.d = null;
        return;
      }
      return parseDecimal(x, v.toString());
    }
    if (t === "string") {
      if ((i2 = v.charCodeAt(0)) === 45) {
        v = v.slice(1);
        x.s = -1;
      } else {
        if (i2 === 43)
          v = v.slice(1);
        x.s = 1;
      }
      return isDecimal2.test(v) ? parseDecimal(x, v) : parseOther(x, v);
    }
    if (t === "bigint") {
      if (v < 0) {
        v = -v;
        x.s = -1;
      } else {
        x.s = 1;
      }
      return parseDecimal(x, v.toString());
    }
    throw Error(invalidArgument + v);
  }
  Decimal2.prototype = P;
  Decimal2.ROUND_UP = 0;
  Decimal2.ROUND_DOWN = 1;
  Decimal2.ROUND_CEIL = 2;
  Decimal2.ROUND_FLOOR = 3;
  Decimal2.ROUND_HALF_UP = 4;
  Decimal2.ROUND_HALF_DOWN = 5;
  Decimal2.ROUND_HALF_EVEN = 6;
  Decimal2.ROUND_HALF_CEIL = 7;
  Decimal2.ROUND_HALF_FLOOR = 8;
  Decimal2.EUCLID = 9;
  Decimal2.config = Decimal2.set = config;
  Decimal2.clone = clone2;
  Decimal2.isDecimal = isDecimalInstance;
  Decimal2.abs = abs;
  Decimal2.acos = acos;
  Decimal2.acosh = acosh;
  Decimal2.add = add2;
  Decimal2.asin = asin;
  Decimal2.asinh = asinh;
  Decimal2.atan = atan;
  Decimal2.atanh = atanh;
  Decimal2.atan2 = atan2;
  Decimal2.cbrt = cbrt;
  Decimal2.ceil = ceil;
  Decimal2.clamp = clamp;
  Decimal2.cos = cos;
  Decimal2.cosh = cosh;
  Decimal2.div = div2;
  Decimal2.exp = exp;
  Decimal2.floor = floor;
  Decimal2.hypot = hypot;
  Decimal2.ln = ln;
  Decimal2.log = log;
  Decimal2.log10 = log10;
  Decimal2.log2 = log2;
  Decimal2.max = max;
  Decimal2.min = min;
  Decimal2.mod = mod;
  Decimal2.mul = mul2;
  Decimal2.pow = pow;
  Decimal2.random = random;
  Decimal2.round = round;
  Decimal2.sign = sign;
  Decimal2.sin = sin;
  Decimal2.sinh = sinh;
  Decimal2.sqrt = sqrt;
  Decimal2.sub = sub2;
  Decimal2.sum = sum;
  Decimal2.tan = tan;
  Decimal2.tanh = tanh;
  Decimal2.trunc = trunc;
  if (obj === void 0)
    obj = {};
  if (obj) {
    if (obj.defaults !== true) {
      ps = ["precision", "rounding", "toExpNeg", "toExpPos", "maxE", "minE", "modulo", "crypto"];
      for (i = 0; i < ps.length; )
        if (!obj.hasOwnProperty(p = ps[i++]))
          obj[p] = this[p];
    }
  }
  Decimal2.config(obj);
  return Decimal2;
}
function div2(x, y) {
  return new this(x).div(y);
}
function exp(x) {
  return new this(x).exp();
}
function floor(x) {
  return finalise(x = new this(x), x.e + 1, 3);
}
function hypot() {
  var i, n, t = new this(0);
  external = false;
  for (i = 0; i < arguments.length; ) {
    n = new this(arguments[i++]);
    if (!n.d) {
      if (n.s) {
        external = true;
        return new this(1 / 0);
      }
      t = n;
    } else if (t.d) {
      t = t.plus(n.times(n));
    }
  }
  external = true;
  return t.sqrt();
}
function isDecimalInstance(obj) {
  return obj instanceof Decimal || obj && obj.toStringTag === tag || false;
}
function ln(x) {
  return new this(x).ln();
}
function log(x, y) {
  return new this(x).log(y);
}
function log2(x) {
  return new this(x).log(2);
}
function log10(x) {
  return new this(x).log(10);
}
function max() {
  return maxOrMin(this, arguments, -1);
}
function min() {
  return maxOrMin(this, arguments, 1);
}
function mod(x, y) {
  return new this(x).mod(y);
}
function mul2(x, y) {
  return new this(x).mul(y);
}
function pow(x, y) {
  return new this(x).pow(y);
}
function random(sd) {
  var d, e, k, n, i = 0, r = new this(1), rd = [];
  if (sd === void 0)
    sd = this.precision;
  else
    checkInt32(sd, 1, MAX_DIGITS);
  k = Math.ceil(sd / LOG_BASE2);
  if (!this.crypto) {
    for (; i < k; )
      rd[i++] = Math.random() * 1e7 | 0;
  } else if (crypto.getRandomValues) {
    d = crypto.getRandomValues(new Uint32Array(k));
    for (; i < k; ) {
      n = d[i];
      if (n >= 429e7) {
        d[i] = crypto.getRandomValues(new Uint32Array(1))[0];
      } else {
        rd[i++] = n % 1e7;
      }
    }
  } else if (crypto.randomBytes) {
    d = crypto.randomBytes(k *= 4);
    for (; i < k; ) {
      n = d[i] + (d[i + 1] << 8) + (d[i + 2] << 16) + ((d[i + 3] & 127) << 24);
      if (n >= 214e7) {
        crypto.randomBytes(4).copy(d, i);
      } else {
        rd.push(n % 1e7);
        i += 4;
      }
    }
    i = k / 4;
  } else {
    throw Error(cryptoUnavailable);
  }
  k = rd[--i];
  sd %= LOG_BASE2;
  if (k && sd) {
    n = mathpow(10, LOG_BASE2 - sd);
    rd[i] = (k / n | 0) * n;
  }
  for (; rd[i] === 0; i--)
    rd.pop();
  if (i < 0) {
    e = 0;
    rd = [0];
  } else {
    e = -1;
    for (; rd[0] === 0; e -= LOG_BASE2)
      rd.shift();
    for (k = 1, n = rd[0]; n >= 10; n /= 10)
      k++;
    if (k < LOG_BASE2)
      e -= LOG_BASE2 - k;
  }
  r.e = e;
  r.d = rd;
  return r;
}
function round(x) {
  return finalise(x = new this(x), x.e + 1, this.rounding);
}
function sign(x) {
  x = new this(x);
  return x.d ? x.d[0] ? x.s : 0 * x.s : x.s || NaN;
}
function sin(x) {
  return new this(x).sin();
}
function sinh(x) {
  return new this(x).sinh();
}
function sqrt(x) {
  return new this(x).sqrt();
}
function sub2(x, y) {
  return new this(x).sub(y);
}
function sum() {
  var i = 0, args = arguments, x = new this(args[i]);
  external = false;
  for (; x.s && ++i < args.length; )
    x = x.plus(args[i]);
  external = true;
  return finalise(x, this.precision, this.rounding);
}
function tan(x) {
  return new this(x).tan();
}
function tanh(x) {
  return new this(x).tanh();
}
function trunc(x) {
  return finalise(x = new this(x), x.e + 1, 1);
}
P[Symbol.for("nodejs.util.inspect.custom")] = P.toString;
P[Symbol.toStringTag] = "Decimal";
var Decimal = P.constructor = clone2(DEFAULTS);
LN10 = new Decimal(LN10);
PI = new Decimal(PI);
var decimal_default = Decimal;

// raydium_daemon.ts
var RPC_URL = process.env.SOLANA_RPC_URL || "https://api.mainnet-beta.solana.com";
async function initRaydium(connection, owner) {
  let tokenAccountData;
  if (owner) {
    const tokenAccounts = await connection.getTokenAccountsByOwner(owner.publicKey, {
      programId: TOKEN_PROGRAM_ID2
    });
    const token2022Accounts = await connection.getTokenAccountsByOwner(owner.publicKey, {
      programId: TOKEN_2022_PROGRAM_ID
    });
    tokenAccountData = (0, import_raydium_sdk_v2.parseTokenAccountResp)({
      owner: owner.publicKey,
      solAccountResp: await connection.getAccountInfo(owner.publicKey),
      tokenAccountResp: {
        context: tokenAccounts.context,
        value: [...tokenAccounts.value, ...token2022Accounts.value]
      }
    });
  }
  const raydium = await import_raydium_sdk_v2.Raydium.load({
    connection,
    owner: owner?.publicKey,
    signAllTransactions: owner ? async (txs) => {
      return txs.map((tx) => {
        if (tx instanceof import_web33.VersionedTransaction) {
          tx.sign([owner]);
        } else {
          tx.sign(owner);
        }
        return tx;
      });
    } : void 0,
    tokenAccounts: tokenAccountData?.tokenAccounts,
    tokenAccountRawInfos: tokenAccountData?.tokenAccountRawInfos,
    disableFeatureCheck: true,
    disableLoadToken: true,
    blockhashCommitment: "confirmed"
  });
  return raydium;
}
async function discoverPoolViaRaydiumV3(mintA, mintB) {
  try {
    const url = `https://api-v3.raydium.io/pools/info/mint?mint1=${mintA}&mint2=${mintB}&poolType=all&poolSortField=default&sortType=desc&pageSize=1&page=1`;
    const response = await fetch(url);
    if (!response.ok) {
      return {
        success: false,
        poolId: "",
        mintA,
        mintB,
        tvl: 0,
        volume24h: 0,
        feeRate: 0,
        type: "standard",
        // Default
        error: `Raydium V3 API error: ${response.status}`
      };
    }
    const data = await response.json();
    if (!data.success || !data.data || data.data.count === 0) {
      return {
        success: false,
        poolId: "",
        mintA,
        mintB,
        tvl: 0,
        volume24h: 0,
        feeRate: 0,
        type: "standard",
        error: "No pool found via Raydium V3"
      };
    }
    const pool = data.data.data[0];
    const isClmm = pool.programId === "CAMMCzo5YLykboFQLsScxMWiDtXBxFobNKdQLu5XbK";
    return {
      success: true,
      poolId: pool.id,
      mintA: pool.mintA?.address || mintA,
      mintB: pool.mintB?.address || mintB,
      tvl: pool.tvl || 0,
      volume24h: pool.day?.volume || 0,
      feeRate: pool.feeRate || 0,
      type: isClmm ? "clmm" : "standard"
    };
  } catch (error) {
    return {
      success: false,
      poolId: "",
      mintA,
      mintB,
      tvl: 0,
      volume24h: 0,
      feeRate: 0,
      type: "standard",
      // Default on error
      error: `Raydium V3: ${error.message || String(error)}`
    };
  }
}
async function discoverPoolViaDexScreener(mintA, mintB) {
  try {
    const url = `https://api.dexscreener.com/latest/dex/tokens/${mintA}`;
    const response = await fetch(url);
    if (!response.ok) {
      return {
        success: false,
        poolId: "",
        mintA,
        mintB,
        tvl: 0,
        volume24h: 0,
        feeRate: 0,
        type: "standard",
        error: `DexScreener API error: ${response.status}`
      };
    }
    const data = await response.json();
    const pairs = data.pairs || [];
    const raydiumPairs = pairs.filter((p) => {
      if (p.dexId !== "raydium")
        return false;
      const base = p.baseToken?.address;
      const quote = p.quoteToken?.address;
      return base === mintA && quote === mintB || base === mintB && quote === mintA;
    });
    if (raydiumPairs.length === 0) {
      return {
        success: false,
        poolId: "",
        mintA,
        mintB,
        tvl: 0,
        volume24h: 0,
        feeRate: 0,
        type: "standard",
        error: "No Raydium pool found via DexScreener"
      };
    }
    const bestPair = raydiumPairs.sort(
      (a, b) => (b.liquidity?.usd || 0) - (a.liquidity?.usd || 0)
    )[0];
    return {
      success: true,
      poolId: bestPair.pairAddress,
      mintA: bestPair.baseToken?.address || mintA,
      mintB: bestPair.quoteToken?.address || mintB,
      tvl: bestPair.liquidity?.usd || 0,
      volume24h: bestPair.volume?.h24 || 0,
      feeRate: 0,
      // DexScreener doesn't expose fee tier
      type: "standard"
      // DexScreener typically returns V4 pools as primary, though we should verify
    };
  } catch (error) {
    return {
      success: false,
      poolId: "",
      mintA,
      mintB,
      tvl: 0,
      volume24h: 0,
      feeRate: 0,
      type: "standard",
      error: `DexScreener: ${error.message || String(error)}`
    };
  }
}
async function discoverPool(mintA, mintB) {
  const v3Result = await discoverPoolViaRaydiumV3(mintA, mintB);
  if (v3Result.success) {
    return v3Result;
  }
  const dexResult = await discoverPoolViaDexScreener(mintA, mintB);
  if (dexResult.success) {
    return dexResult;
  }
  return {
    success: false,
    poolId: "",
    mintA,
    mintB,
    tvl: 0,
    volume24h: 0,
    feeRate: 0,
    type: "standard",
    error: `${v3Result.error} | ${dexResult.error}`
  };
}
async function getPrice(poolAddress, existingRaydium) {
  try {
    let raydium = existingRaydium;
    let connection;
    if (raydium) {
      connection = raydium.connection;
    } else {
      connection = new import_web33.Connection(RPC_URL, "confirmed");
      raydium = await initRaydium(connection);
    }
    const poolId = new import_web33.PublicKey(poolAddress);
    const rpcResult = await raydium.clmm.getPoolInfoFromRpc(poolId.toString());
    if (!rpcResult || !rpcResult.poolInfo) {
      return await getStandardPoolPrice(poolAddress, connection);
    }
    const info = rpcResult.poolInfo;
    const compute = rpcResult.computePoolInfo;
    if (!info.mintA || !info.mintB) {
      return await getStandardPoolPrice(poolAddress, connection);
    }
    let priceAtoB = 0;
    let priceBtoA = 0;
    let liquidity = "0";
    let currentTick;
    if (compute && compute.currentPrice) {
      priceAtoB = compute.currentPrice.toNumber();
      priceBtoA = priceAtoB > 0 ? 1 / priceAtoB : 0;
    }
    if (compute?.liquidity) {
      liquidity = compute.liquidity.toString();
    }
    if (compute?.tickCurrent !== void 0) {
      currentTick = compute.tickCurrent;
    }
    return {
      success: true,
      pool: poolAddress,
      tokenA: info.mintA.address,
      tokenB: info.mintB.address,
      priceAtoB,
      priceBtoA,
      liquidity,
      currentTick
    };
  } catch (error) {
    try {
      const std = await getStandardPoolPrice(poolAddress, existingRaydium?.connection || new import_web33.Connection(RPC_URL, "confirmed"));
      if (std.success)
        return std;
    } catch (e) {
    }
    return {
      success: false,
      pool: poolAddress,
      tokenA: "",
      tokenB: "",
      priceAtoB: 0,
      priceBtoA: 0,
      liquidity: "0",
      error: error.message || String(error)
    };
  }
}
async function getStandardPoolPrice(poolAddress, connection) {
  try {
    const info = await connection.getAccountInfo(new import_web33.PublicKey(poolAddress));
    if (!info) {
      return {
        success: false,
        pool: poolAddress,
        tokenA: "",
        tokenB: "",
        priceAtoB: 0,
        priceBtoA: 0,
        liquidity: "0",
        error: "Pool account not found"
      };
    }
    return parseStandardPoolAccount(poolAddress, info);
  } catch (err) {
    return {
      success: false,
      pool: poolAddress,
      tokenA: "",
      tokenB: "",
      priceAtoB: 0,
      priceBtoA: 0,
      liquidity: "0",
      error: `Standard AMM Error: ${err.message}`
    };
  }
}
function parseStandardPoolAccount(poolAddress, info) {
  try {
    const layout = import_raydium_sdk.Liquidity.getStateLayout(4);
    const poolState = layout.decode(info.data);
    const baseMint = poolState.baseMint.toBase58();
    const quoteMint = poolState.quoteMint.toBase58();
    return { success: false, pool: poolAddress, tokenA: baseMint, tokenB: quoteMint, priceAtoB: 0, priceBtoA: 0, liquidity: "0", error: "Need vault balances" };
  } catch (e) {
    return { success: false, pool: poolAddress, tokenA: "", tokenB: "", priceAtoB: 0, priceBtoA: 0, liquidity: "0", error: "Decode failed" };
  }
}
async function getBatchPrices(pools, connection) {
  const results = {};
  const standardPools = pools.filter((p) => p.type === "standard");
  if (standardPools.length === 0)
    return results;
  const poolKeys = standardPools.map((p) => new import_web33.PublicKey(p.id));
  const chunks = [];
  for (let i = 0; i < poolKeys.length; i += 100) {
    chunks.push(poolKeys.slice(i, i + 100));
  }
  const poolInfosMap = {};
  for (const chunk of chunks) {
    const infos = await connection.getMultipleAccountsInfo(chunk);
    infos.forEach((info, idx) => {
      if (info)
        poolInfosMap[chunk[idx].toBase58()] = info;
    });
  }
  const poolToVaults = {};
  const vaultKeys = [];
  const layout = import_raydium_sdk.Liquidity.getStateLayout(4);
  for (const p of standardPools) {
    const info = poolInfosMap[p.id];
    if (!info)
      continue;
    try {
      const state = layout.decode(info.data);
      poolToVaults[p.id] = {
        base: state.baseVault,
        quote: state.quoteVault,
        baseDec: state.baseDecimal.toNumber(),
        quoteDec: state.quoteDecimal.toNumber()
      };
      vaultKeys.push(state.baseVault);
      vaultKeys.push(state.quoteVault);
    } catch (e) {
    }
  }
  const vaultBalances = {};
  const uniqueVaultKeys = [...new Set(vaultKeys.map((k) => k.toBase58()))].map((k) => new import_web33.PublicKey(k));
  const vaultChunks = [];
  for (let i = 0; i < uniqueVaultKeys.length; i += 100)
    vaultChunks.push(uniqueVaultKeys.slice(i, i + 100));
  for (const chunk of vaultChunks) {
    const infos = await connection.getMultipleAccountsInfo(chunk);
    infos.forEach((info, idx) => {
      if (info) {
        try {
          const rawAccount = AccountLayout.decode(info.data);
          const amount = Number(rawAccount.amount);
          vaultBalances[chunk[idx].toBase58()] = amount;
        } catch (e) {
        }
      }
    });
  }
  for (const p of standardPools) {
    const vaults = poolToVaults[p.id];
    if (!vaults)
      continue;
    const baseBal = vaultBalances[vaults.base.toBase58()];
    const quoteBal = vaultBalances[vaults.quote.toBase58()];
    if (baseBal !== void 0 && quoteBal !== void 0 && baseBal > 0) {
      const baseReserve = baseBal / 10 ** vaults.baseDec;
      const quoteReserve = quoteBal / 10 ** vaults.quoteDec;
      if (baseReserve > 0) {
        results[p.id] = quoteReserve / baseReserve;
      }
    }
  }
  return results;
}
async function getQuote(poolAddress, inputMint, amountIn, existingRaydium) {
  try {
    let raydium = existingRaydium;
    let connection = raydium?.connection || new import_web33.Connection(RPC_URL, "confirmed");
    if (!raydium) {
      raydium = await initRaydium(connection);
    }
    const poolId = new import_web33.PublicKey(poolAddress);
    const rpcResult = await raydium.clmm.getPoolInfoFromRpc(poolId.toString());
    if (!rpcResult || !rpcResult.poolInfo) {
      return {
        success: false,
        inputMint,
        outputMint: "",
        inputAmount: amountIn,
        outputAmount: "0",
        priceImpact: 0,
        error: "Pool not found"
      };
    }
    const info = rpcResult.poolInfo;
    const isAtoB = info.mintA.address === inputMint;
    const outputMint = isAtoB ? info.mintB.address : info.mintA.address;
    const inputDecimals = isAtoB ? info.mintA.decimals : info.mintB.decimals;
    const outputDecimals = isAtoB ? info.mintB.decimals : info.mintA.decimals;
    const amountInBN = new import_bn.default(new decimal_default(amountIn).mul(10 ** inputDecimals).floor().toString());
    const clmmPoolInfo = rpcResult.computePoolInfo;
    const swapResult = clmmPoolInfo ? await import_raydium_sdk_v2.PoolUtils.computeAmountOutFormat({
      poolInfo: clmmPoolInfo,
      tickArrayCache: rpcResult.tickData[poolAddress] || rpcResult.tickData,
      amountIn: amountInBN,
      tokenOut: isAtoB ? info.mintB : info.mintA,
      slippage: 5e-3,
      epochInfo: await connection.getEpochInfo()
    }) : null;
    if (!swapResult || !swapResult.amountOut) {
      const priceResult = await getPrice(poolAddress);
      if (priceResult.success) {
        const price = isAtoB ? priceResult.priceAtoB : priceResult.priceBtoA;
        const estimatedOut = parseFloat(amountIn) * price;
        return {
          success: true,
          inputMint,
          outputMint,
          inputAmount: amountIn,
          outputAmount: estimatedOut.toFixed(outputDecimals),
          priceImpact: 1e-3
          // Estimated
        };
      }
      return {
        success: false,
        inputMint,
        outputMint,
        inputAmount: amountIn,
        outputAmount: "0",
        priceImpact: 0,
        error: "Could not compute swap output"
      };
    }
    return {
      success: true,
      inputMint,
      outputMint,
      inputAmount: amountIn,
      outputAmount: new decimal_default(swapResult.amountOut.amount.toString()).div(10 ** outputDecimals).toString(),
      priceImpact: swapResult.priceImpact ? Number(swapResult.priceImpact.numerator) / Number(swapResult.priceImpact.denominator) : 0
    };
  } catch (error) {
    return {
      success: false,
      inputMint,
      outputMint: "",
      inputAmount: amountIn,
      outputAmount: "0",
      priceImpact: 0,
      error: error.message || String(error)
    };
  }
}
async function executeSwap(poolAddress, inputMint, amountIn, slippageBps, privateKeyBase58, existingRaydium) {
  try {
    let raydium = existingRaydium;
    let connection = raydium?.connection || new import_web33.Connection(RPC_URL, "confirmed");
    if (!raydium) {
      if (!privateKeyBase58)
        throw new Error("Missing private key");
      const privateKey = import_bs58.default.decode(privateKeyBase58);
      const owner = import_web33.Keypair.fromSecretKey(privateKey);
      raydium = await initRaydium(connection, owner);
    }
    const poolId = new import_web33.PublicKey(poolAddress);
    const rpcResult = await raydium.clmm.getPoolInfoFromRpc(poolId.toString());
    if (!rpcResult || !rpcResult.poolInfo) {
      return {
        success: false,
        inputMint,
        outputMint: "",
        inputAmount: amountIn,
        outputAmount: "0",
        error: "Pool not found"
      };
    }
    const info = rpcResult.poolInfo;
    const isAtoB = info.mintA.address === inputMint;
    const outputMint = isAtoB ? info.mintB.address : info.mintA.address;
    const inputDecimals = isAtoB ? info.mintA.decimals : info.mintB.decimals;
    const outputDecimals = isAtoB ? info.mintB.decimals : info.mintA.decimals;
    const amountInBN = new import_bn.default(new decimal_default(amountIn).mul(10 ** inputDecimals).floor().toString());
    const slippage = slippageBps / 1e4;
    const { execute } = await raydium.clmm.swap({
      poolInfo: info,
      inputMint: new import_web33.PublicKey(inputMint),
      amountIn: amountInBN,
      amountOutMin: new import_bn.default(0),
      // Will compute internally
      observationId: rpcResult.poolKeys?.observationId,
      ownerInfo: { useSOLBalance: true },
      remainingAccounts: [],
      txVersion: import_raydium_sdk_v2.TxVersion.V0
    });
    const { txId } = await execute({ sendAndConfirm: true });
    return {
      success: true,
      signature: txId,
      inputMint,
      outputMint,
      inputAmount: amountIn,
      outputAmount: "0"
      // Would need to parse transaction
    };
  } catch (error) {
    return {
      success: false,
      inputMint,
      outputMint: "",
      inputAmount: amountIn,
      outputAmount: "0",
      error: error.message || String(error)
    };
  }
}
async function main() {
  const args = process.argv.slice(2);
  const command = args[0];
  if (command === "daemon") {
    const connection = new import_web33.Connection(RPC_URL, "confirmed");
    console.error("DEBUG: Initializing Raydium Daemon...");
    const privateKeyBase58 = process.env.PHANTOM_PRIVATE_KEY;
    let owner;
    if (privateKeyBase58) {
      try {
        const privateKey = import_bs58.default.decode(privateKeyBase58);
        owner = import_web33.Keypair.fromSecretKey(privateKey);
      } catch (e) {
        console.error("DEBUG: Invalid Private Key in env");
      }
    }
    const raydium = await initRaydium(connection, owner);
    console.error("DEBUG: Raydium Daemon Ready");
    const readline = require("readline");
    const rl = readline.createInterface({
      input: process.stdin,
      output: process.stdout,
      terminal: false
    });
    rl.on("line", async (line) => {
      if (!line.trim())
        return;
      try {
        const req = JSON.parse(line);
        let result = {};
        if (req.cmd === "price") {
          result = await getPrice(req.pool, raydium);
        } else if (req.cmd === "quote") {
          result = await getQuote(req.pool, req.inputMint, req.amount, raydium);
        } else if (req.cmd === "swap") {
          result = await executeSwap(req.pool, req.inputMint, req.amount, req.slippageBps, void 0, raydium);
        } else if (req.cmd === "batch_prices") {
          result = { success: true, prices: await getBatchPrices(req.pools, connection) };
        }
        console.log(JSON.stringify(result));
      } catch (e) {
        console.log(JSON.stringify({ success: false, error: e.message }));
      }
    });
    return;
  }
  if (!command) {
    console.log(JSON.stringify({
      success: false,
      error: "Usage: node raydium_clmm.js <price|quote|swap|daemon> [args...]"
    }));
    process.exit(1);
  }
  switch (command.toLowerCase()) {
    case "price": {
      const [, poolAddress] = args;
      if (!poolAddress) {
        console.log(JSON.stringify({ success: false, error: "Usage: price <pool_address>" }));
        process.exit(1);
      }
      const result = await getPrice(poolAddress);
      console.log(JSON.stringify(result));
      break;
    }
    case "quote": {
      const [, poolAddress, inputMint, amount] = args;
      if (!poolAddress || !inputMint || !amount) {
        console.log(JSON.stringify({ success: false, error: "Usage: quote <pool> <input_mint> <amount>" }));
        process.exit(1);
      }
      const result = await getQuote(poolAddress, inputMint, amount);
      console.log(JSON.stringify(result));
      break;
    }
    case "swap": {
      const [, poolAddress, inputMint, amount, slippageBps, privateKey] = args;
      if (!poolAddress || !inputMint || !amount || !slippageBps || !privateKey) {
        console.log(JSON.stringify({ success: false, error: "Usage: swap <pool> <input_mint> <amount> <slippage_bps> <key>" }));
        process.exit(1);
      }
      const result = await executeSwap(poolAddress, inputMint, amount, parseInt(slippageBps), privateKey);
      console.log(JSON.stringify(result));
      break;
    }
    case "discover": {
      const [, mintA, mintB] = args;
      if (!mintA || !mintB) {
        console.log(JSON.stringify({ success: false, error: "Usage: discover <mint_a> <mint_b>" }));
        process.exit(1);
      }
      const result = await discoverPool(mintA, mintB);
      console.log(JSON.stringify(result));
      break;
    }
    default:
      console.log(JSON.stringify({ success: false, error: `Unknown command: ${command}. Use: discover|price|quote|swap|daemon` }));
      process.exit(1);
  }
}
main().catch((err) => {
  console.log(JSON.stringify({ success: false, error: err.message || String(err) }));
  process.exit(1);
});
/*! Bundled license information:

mime-db/index.js:
  (*!
   * mime-db
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2015-2022 Douglas Christopher Wilson
   * MIT Licensed
   *)

mime-types/index.js:
  (*!
   * mime-types
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2015 Douglas Christopher Wilson
   * MIT Licensed
   *)

axios/dist/node/axios.cjs:
  (*! Axios v1.13.2 Copyright (c) 2025 Matt Zabriskie and contributors *)

lodash/lodash.js:
  (**
   * @license
   * Lodash <https://lodash.com/>
   * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
   * Released under MIT license <https://lodash.com/license>
   * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
   * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
   *)

@solana/buffer-layout/lib/Layout.js:
  (**
   * Support for translating between Uint8Array instances and JavaScript
   * native types.
   *
   * {@link module:Layout~Layout|Layout} is the basis of a class
   * hierarchy that associates property names with sequences of encoded
   * bytes.
   *
   * Layouts are supported for these scalar (numeric) types:
   * * {@link module:Layout~UInt|Unsigned integers in little-endian
   *   format} with {@link module:Layout.u8|8-bit}, {@link
   *   module:Layout.u16|16-bit}, {@link module:Layout.u24|24-bit},
   *   {@link module:Layout.u32|32-bit}, {@link
   *   module:Layout.u40|40-bit}, and {@link module:Layout.u48|48-bit}
   *   representation ranges;
   * * {@link module:Layout~UIntBE|Unsigned integers in big-endian
   *   format} with {@link module:Layout.u16be|16-bit}, {@link
   *   module:Layout.u24be|24-bit}, {@link module:Layout.u32be|32-bit},
   *   {@link module:Layout.u40be|40-bit}, and {@link
   *   module:Layout.u48be|48-bit} representation ranges;
   * * {@link module:Layout~Int|Signed integers in little-endian
   *   format} with {@link module:Layout.s8|8-bit}, {@link
   *   module:Layout.s16|16-bit}, {@link module:Layout.s24|24-bit},
   *   {@link module:Layout.s32|32-bit}, {@link
   *   module:Layout.s40|40-bit}, and {@link module:Layout.s48|48-bit}
   *   representation ranges;
   * * {@link module:Layout~IntBE|Signed integers in big-endian format}
   *   with {@link module:Layout.s16be|16-bit}, {@link
   *   module:Layout.s24be|24-bit}, {@link module:Layout.s32be|32-bit},
   *   {@link module:Layout.s40be|40-bit}, and {@link
   *   module:Layout.s48be|48-bit} representation ranges;
   * * 64-bit integral values that decode to an exact (if magnitude is
   *   less than 2^53) or nearby integral Number in {@link
   *   module:Layout.nu64|unsigned little-endian}, {@link
   *   module:Layout.nu64be|unsigned big-endian}, {@link
   *   module:Layout.ns64|signed little-endian}, and {@link
   *   module:Layout.ns64be|unsigned big-endian} encodings;
   * * 32-bit floating point values with {@link
   *   module:Layout.f32|little-endian} and {@link
   *   module:Layout.f32be|big-endian} representations;
   * * 64-bit floating point values with {@link
   *   module:Layout.f64|little-endian} and {@link
   *   module:Layout.f64be|big-endian} representations;
   * * {@link module:Layout.const|Constants} that take no space in the
   *   encoded expression.
   *
   * and for these aggregate types:
   * * {@link module:Layout.seq|Sequence}s of instances of a {@link
   *   module:Layout~Layout|Layout}, with JavaScript representation as
   *   an Array and constant or data-dependent {@link
   *   module:Layout~Sequence#count|length};
   * * {@link module:Layout.struct|Structure}s that aggregate a
   *   heterogeneous sequence of {@link module:Layout~Layout|Layout}
   *   instances, with JavaScript representation as an Object;
   * * {@link module:Layout.union|Union}s that support multiple {@link
   *   module:Layout~VariantLayout|variant layouts} over a fixed
   *   (padded) or variable (not padded) span of bytes, using an
   *   unsigned integer at the start of the data or a separate {@link
   *   module:Layout.unionLayoutDiscriminator|layout element} to
   *   determine which layout to use when interpreting the buffer
   *   contents;
   * * {@link module:Layout.bits|BitStructure}s that contain a sequence
   *   of individual {@link
   *   module:Layout~BitStructure#addField|BitField}s packed into an 8,
   *   16, 24, or 32-bit unsigned integer starting at the least- or
   *   most-significant bit;
   * * {@link module:Layout.cstr|C strings} of varying length;
   * * {@link module:Layout.blob|Blobs} of fixed- or variable-{@link
   *   module:Layout~Blob#length|length} raw data.
   *
   * All {@link module:Layout~Layout|Layout} instances are immutable
   * after construction, to prevent internal state from becoming
   * inconsistent.
   *
   * @local Layout
   * @local ExternalLayout
   * @local GreedyCount
   * @local OffsetLayout
   * @local UInt
   * @local UIntBE
   * @local Int
   * @local IntBE
   * @local NearUInt64
   * @local NearUInt64BE
   * @local NearInt64
   * @local NearInt64BE
   * @local Float
   * @local FloatBE
   * @local Double
   * @local DoubleBE
   * @local Sequence
   * @local Structure
   * @local UnionDiscriminator
   * @local UnionLayoutDiscriminator
   * @local Union
   * @local VariantLayout
   * @local BitStructure
   * @local BitField
   * @local Boolean
   * @local Blob
   * @local CString
   * @local Constant
   * @local bindConstructorLayout
   * @module Layout
   * @license MIT
   * @author Peter A. Bigot
   * @see {@link https://github.com/pabigot/buffer-layout|buffer-layout on GitHub}
   *)

decimal.js-light/decimal.js:
  (*! decimal.js-light v2.5.1 https://github.com/MikeMcl/decimal.js-light/LICENCE *)

@raydium-io/raydium-sdk-v2/lib/index.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

decimal.js/decimal.js:
  (*!
   *  decimal.js v10.6.0
   *  An arbitrary-precision Decimal type for JavaScript.
   *  https://github.com/MikeMcl/decimal.js
   *  Copyright (c) 2025 Michael Mclaughlin <M8ch88l@gmail.com>
   *  MIT Licence
   *)

@raydium-io/raydium-sdk/dist/index.js:
  (*! Bundled license information:
  
  @noble/hashes/esm/utils.js:
    (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)
  *)

decimal.js/decimal.mjs:
  (*!
   *  decimal.js v10.6.0
   *  An arbitrary-precision Decimal type for JavaScript.
   *  https://github.com/MikeMcl/decimal.js
   *  Copyright (c) 2025 Michael Mclaughlin <M8ch88l@gmail.com>
   *  MIT Licence
   *)
*/
