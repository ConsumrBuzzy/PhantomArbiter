"""
Trading Data Models
==================

Shared trading signal and execution models for all trading engines.
"""

from dataclasses import dataclass
from typing import List, Dict, Any, Optional
from datetime import datetime
from enum import Enum
from decimal import Decimal


class SignalType(Enum):
    """Trading signal types."""
    HEDGE = "hedge"
    ARBITRAGE = "arbitrage"
    MOMENTUM = "momentum"
    MEAN_REVERSION = "mean_reversion"
    RISK_REDUCTION = "risk_reduction"
    REBALANCE = "rebalance"
    EMERGENCY = "emergency"


class OrderSide(Enum):
    """Order side enumeration."""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """Order type enumeration."""
    MARKET = "market"
    LIMIT = "limit"
    STOP = "stop"
    STOP_LIMIT = "stop_limit"
    POST_ONLY = "post_only"


class OrderStatus(Enum):
    """Order status enumeration."""
    PENDING = "pending"
    OPEN = "open"
    FILLED = "filled"
    PARTIALLY_FILLED = "partially_filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"
    EXPIRED = "expired"


class ExecutionQuality(Enum):
    """Execution quality assessment."""
    EXCELLENT = "excellent"
    GOOD = "good"
    FAIR = "fair"
    POOR = "poor"


@dataclass
class TradeSignal:
    """Trading signal generated by engines."""
    
    # Signal identification
    signal_id: str
    engine_name: str  # Which engine generated this signal
    signal_type: SignalType
    
    # Market and execution details
    market: str
    side: OrderSide
    size: float  # Requested size
    signal_strength: float  # Signal confidence (0-1)
    
    # Pricing information
    target_price: Optional[float] = None  # Preferred execution price
    max_slippage: float = 0.005  # Maximum acceptable slippage (0.5% default)
    urgency: float = 0.5  # Execution urgency (0-1, higher = more urgent)
    
    # Risk and validation
    risk_score: float = 0.0  # Risk assessment of this signal (0-1)
    max_position_impact: float = 0.1  # Maximum impact on portfolio (10% default)
    
    # Timing and lifecycle
    created_at: datetime
    valid_until: Optional[datetime] = None  # Signal expiration
    priority: int = 5  # Priority level (1-10, higher = more important)
    
    # Context and reasoning
    reasoning: str = ""  # Human-readable explanation
    metadata: Dict[str, Any] = None  # Additional signal-specific data
    
    # Dependencies and conflicts
    depends_on: List[str] = None  # Other signal IDs this depends on
    conflicts_with: List[str] = None  # Conflicting signal IDs
    
    def __post_init__(self):
        """Initialize default values."""
        if self.metadata is None:
            self.metadata = {}
        if self.depends_on is None:
            self.depends_on = []
        if self.conflicts_with is None:
            self.conflicts_with = []
    
    @property
    def is_expired(self) -> bool:
        """Check if signal has expired."""
        if self.valid_until is None:
            return False
        return datetime.now() > self.valid_until
    
    @property
    def age_seconds(self) -> float:
        """Get signal age in seconds."""
        return (datetime.now() - self.created_at).total_seconds()
    
    @property
    def notional_value(self) -> float:
        """Calculate approximate notional value."""
        if self.target_price:
            return abs(self.size) * self.target_price
        return 0.0
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for serialization."""
        return {
            'signal_id': self.signal_id,
            'engine_name': self.engine_name,
            'signal_type': self.signal_type.value,
            'market': self.market,
            'side': self.side.value,
            'size': self.size,
            'signal_strength': self.signal_strength,
            'target_price': self.target_price,
            'max_slippage': self.max_slippage,
            'urgency': self.urgency,
            'risk_score': self.risk_score,
            'max_position_impact': self.max_position_impact,
            'created_at': self.created_at.isoformat(),
            'valid_until': self.valid_until.isoformat() if self.valid_until else None,
            'priority': self.priority,
            'reasoning': self.reasoning,
            'metadata': self.metadata,
            'depends_on': self.depends_on,
            'conflicts_with': self.conflicts_with,
            'is_expired': self.is_expired,
            'age_seconds': self.age_seconds,
            'notional_value': self.notional_value
        }


@dataclass
class OrderRequest:
    """Order request for execution."""
    
    # Order identification
    request_id: str
    signal_id: Optional[str] = None  # Originating signal ID
    
    # Market and execution
    market: str
    side: OrderSide
    order_type: OrderType
    size: float
    
    # Pricing
    price: Optional[float] = None  # For limit orders
    stop_price: Optional[float] = None  # For stop orders
    
    # Execution parameters
    time_in_force: str = "GTC"  # Good Till Cancelled
    reduce_only: bool = False
    post_only: bool = False
    
    # Risk controls
    max_slippage: float = 0.01  # 1% default
    min_fill_size: Optional[float] = None
    
    # Metadata
    created_at: datetime
    client_order_id: Optional[str] = None
    tags: List[str] = None
    
    def __post_init__(self):
        """Initialize default values."""
        if self.tags is None:
            self.tags = []


@dataclass
class OrderResponse:
    """Order execution response."""
    
    # Request reference
    request_id: str
    order_id: Optional[str] = None  # Exchange order ID
    
    # Execution status
    status: OrderStatus
    filled_size: float = 0.0
    remaining_size: float = 0.0
    
    # Execution details
    average_fill_price: Optional[float] = None
    total_fees: float = 0.0
    
    # Timing
    created_at: datetime
    updated_at: datetime
    filled_at: Optional[datetime] = None
    
    # Error handling
    error_code: Optional[str] = None
    error_message: Optional[str] = None
    
    # Execution quality
    slippage: Optional[float] = None  # Actual slippage experienced
    execution_quality: Optional[ExecutionQuality] = None
    
    @property
    def is_complete(self) -> bool:
        """Check if order is completely filled."""
        return self.status == OrderStatus.FILLED
    
    @property
    def is_active(self) -> bool:
        """Check if order is still active."""
        return self.status in [OrderStatus.PENDING, OrderStatus.OPEN, OrderStatus.PARTIALLY_FILLED]
    
    @property
    def fill_percentage(self) -> float:
        """Calculate fill percentage."""
        total_size = self.filled_size + self.remaining_size
        if total_size == 0:
            return 0.0
        return (self.filled_size / total_size) * 100


@dataclass
class TradeResult:
    """Complete trade execution result."""
    
    # Trade identification
    trade_id: str
    signal_id: Optional[str] = None
    engine_name: Optional[str] = None
    
    # Execution summary
    market: str
    side: OrderSide
    requested_size: float
    executed_size: float
    average_price: float
    
    # Financial impact
    notional_value: float
    total_fees: float
    estimated_pnl: float = 0.0  # Immediate PnL impact
    
    # Execution quality metrics
    slippage: float = 0.0
    execution_time_ms: float = 0.0
    execution_quality: ExecutionQuality = ExecutionQuality.FAIR
    
    # Market impact
    market_impact_bps: float = 0.0  # Market impact in basis points
    
    # Timing
    signal_time: Optional[datetime] = None
    execution_start: datetime
    execution_end: datetime
    
    # Order details
    orders: List[OrderResponse] = None  # Individual orders that made up this trade
    
    # Success metrics
    success: bool = True
    partial_fill: bool = False
    
    # Error handling
    error_message: Optional[str] = None
    warnings: List[str] = None
    
    def __post_init__(self):
        """Initialize default values."""
        if self.orders is None:
            self.orders = []
        if self.warnings is None:
            self.warnings = []
    
    @property
    def fill_rate(self) -> float:
        """Calculate fill rate as percentage."""
        if self.requested_size == 0:
            return 0.0
        return (self.executed_size / self.requested_size) * 100
    
    @property
    def execution_duration_ms(self) -> float:
        """Calculate execution duration in milliseconds."""
        return (self.execution_end - self.execution_start).total_seconds() * 1000
    
    @property
    def signal_to_execution_delay_ms(self) -> float:
        """Calculate delay from signal to execution start."""
        if self.signal_time is None:
            return 0.0
        return (self.execution_start - self.signal_time).total_seconds() * 1000
    
    def calculate_execution_score(self) -> float:
        """Calculate overall execution quality score (0-1)."""
        score = 0.0
        
        # Fill rate component (40% weight)
        fill_component = (self.fill_rate / 100.0) * 0.4
        
        # Slippage component (30% weight) - lower slippage is better
        slippage_component = max(0, 1 - abs(self.slippage) * 10) * 0.3
        
        # Speed component (20% weight) - faster is better (under 1 second ideal)
        speed_component = max(0, 1 - (self.execution_time_ms / 1000.0)) * 0.2
        
        # Success component (10% weight)
        success_component = 1.0 if self.success else 0.0
        success_component *= 0.1
        
        return min(1.0, score + fill_component + slippage_component + speed_component + success_component)
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for serialization."""
        return {
            'trade_id': self.trade_id,
            'signal_id': self.signal_id,
            'engine_name': self.engine_name,
            'market': self.market,
            'side': self.side.value,
            'requested_size': self.requested_size,
            'executed_size': self.executed_size,
            'average_price': self.average_price,
            'notional_value': self.notional_value,
            'total_fees': self.total_fees,
            'estimated_pnl': self.estimated_pnl,
            'slippage': self.slippage,
            'execution_time_ms': self.execution_time_ms,
            'execution_quality': self.execution_quality.value,
            'market_impact_bps': self.market_impact_bps,
            'signal_time': self.signal_time.isoformat() if self.signal_time else None,
            'execution_start': self.execution_start.isoformat(),
            'execution_end': self.execution_end.isoformat(),
            'success': self.success,
            'partial_fill': self.partial_fill,
            'fill_rate': self.fill_rate,
            'execution_duration_ms': self.execution_duration_ms,
            'signal_to_execution_delay_ms': self.signal_to_execution_delay_ms,
            'execution_score': self.calculate_execution_score(),
            'error_message': self.error_message,
            'warnings': self.warnings,
            'order_count': len(self.orders)
        }